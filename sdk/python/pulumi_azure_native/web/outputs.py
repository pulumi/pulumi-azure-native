# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AllowedAudiencesValidationResponse',
    'AllowedPrincipalsResponse',
    'ApiConnectionDefinitionResponseProperties',
    'ApiConnectionTestLinkResponse',
    'ApiDefinitionInfoResponse',
    'ApiManagementConfigResponse',
    'ApiOAuthSettingsParameterResponse',
    'ApiOAuthSettingsResponse',
    'ApiReferenceResponse',
    'ApiResourceBackendServiceResponse',
    'ApiResourceDefinitionsResponse',
    'AppLogsConfigurationResponse',
    'AppRegistrationResponse',
    'AppleRegistrationResponse',
    'AppleResponse',
    'ApplicationLogsConfigResponse',
    'ArcConfigurationResponse',
    'ArmIdWrapperResponse',
    'ArmPlanResponse',
    'AseV3NetworkingConfigurationResponse',
    'AuthPlatformResponse',
    'AutoHealActionsResponse',
    'AutoHealCustomActionResponse',
    'AutoHealRulesResponse',
    'AutoHealTriggersResponse',
    'AzureActiveDirectoryLoginResponse',
    'AzureActiveDirectoryRegistrationResponse',
    'AzureActiveDirectoryResponse',
    'AzureActiveDirectoryValidationResponse',
    'AzureBlobStorageApplicationLogsConfigResponse',
    'AzureBlobStorageHttpLogsConfigResponse',
    'AzureResourceErrorInfoResponse',
    'AzureStaticWebAppsRegistrationResponse',
    'AzureStaticWebAppsResponse',
    'AzureStorageInfoValueResponse',
    'AzureTableStorageApplicationLogsConfigResponse',
    'BackupItemResponse',
    'BackupScheduleResponse',
    'BlobStorageTokenStoreResponse',
    'CapabilityResponse',
    'ClientRegistrationResponse',
    'ConnStringInfoResponse',
    'ConnStringValueTypePairResponse',
    'ConnectionErrorResponse',
    'ConnectionGatewayDefinitionResponseProperties',
    'ConnectionGatewayReferenceResponse',
    'ConnectionParameterResponse',
    'ConnectionStatusDefinitionResponse',
    'ConsentLinkDefinitionResponse',
    'ContainerAppsConfigurationResponse',
    'CookieExpirationResponse',
    'CorsSettingsResponse',
    'CustomApiPropertiesDefinitionResponse',
    'CustomDnsSuffixConfigurationResponse',
    'CustomOpenIdConnectProviderResponse',
    'DaprConfigResponse',
    'DatabaseBackupSettingResponse',
    'DatabaseConnectionOverviewResponse',
    'DefaultAuthorizationPolicyResponse',
    'EnabledConfigResponse',
    'EnvironmentVariableResponse',
    'ErrorEntityResponse',
    'ExperimentsResponse',
    'ExpressionResponse',
    'ExpressionRootResponse',
    'ExtendedLocationResponse',
    'FacebookResponse',
    'FileSystemApplicationLogsConfigResponse',
    'FileSystemHttpLogsConfigResponse',
    'FileSystemTokenStoreResponse',
    'ForwardProxyResponse',
    'FrontEndConfigurationResponse',
    'FunctionAppConfigResponse',
    'FunctionsAlwaysReadyConfigResponse',
    'FunctionsDeploymentResponse',
    'FunctionsDeploymentResponseAuthentication',
    'FunctionsDeploymentResponseStorage',
    'FunctionsRuntimeResponse',
    'FunctionsScaleAndConcurrencyResponse',
    'FunctionsScaleAndConcurrencyResponseHttp',
    'FunctionsScaleAndConcurrencyResponseTriggers',
    'GitHubActionCodeConfigurationResponse',
    'GitHubActionConfigurationResponse',
    'GitHubActionContainerConfigurationResponse',
    'GitHubResponse',
    'GlobalValidationResponse',
    'GoogleResponse',
    'HandlerMappingResponse',
    'HostNameSslStateResponse',
    'HostingEnvironmentProfileResponse',
    'HttpLogsConfigResponse',
    'HttpSettingsResponse',
    'HttpSettingsRoutesResponse',
    'IdentifierResponse',
    'IdentityProvidersResponse',
    'IpSecurityRestrictionResponse',
    'JwtClaimChecksResponse',
    'KubeEnvironmentProfileResponse',
    'LegacyMicrosoftAccountResponse',
    'LogAnalyticsConfigurationResponse',
    'LoginResponse',
    'LoginRoutesResponse',
    'LoginScopesResponse',
    'ManagedServiceIdentityResponse',
    'NameValuePairResponse',
    'NonceResponse',
    'OpenIdConnectClientCredentialResponse',
    'OpenIdConnectConfigResponse',
    'OpenIdConnectLoginResponse',
    'OpenIdConnectRegistrationResponse',
    'PrivateLinkConnectionStateResponse',
    'PushSettingsResponse',
    'RampUpRuleResponse',
    'RemotePrivateEndpointConnectionResponse',
    'RequestsBasedTriggerResponse',
    'ResourceConfigResponse',
    'ResponseMessageEnvelopeRemotePrivateEndpointConnectionResponse',
    'SiteConfigResponse',
    'SiteDnsConfigResponse',
    'SiteLimitsResponse',
    'SiteMachineKeyResponse',
    'SkuCapacityResponse',
    'SkuDescriptionResponse',
    'SlotSwapStatusResponse',
    'SlowRequestsBasedTriggerResponse',
    'StaticSiteBuildPropertiesResponse',
    'StaticSiteDatabaseConnectionConfigurationFileOverviewResponse',
    'StaticSiteLinkedBackendResponse',
    'StaticSiteTemplateOptionsResponse',
    'StaticSiteUserARMResourceResponse',
    'StaticSiteUserProvidedFunctionAppResponse',
    'StatusCodesBasedTriggerResponse',
    'StatusCodesRangeBasedTriggerResponse',
    'TokenStoreResponse',
    'TwitterRegistrationResponse',
    'TwitterResponse',
    'UserAssignedIdentityResponse',
    'VirtualApplicationResponse',
    'VirtualDirectoryResponse',
    'VirtualNetworkProfileResponse',
    'VnetRouteResponse',
    'VolumeMountResponse',
    'WorkflowEnvelopeResponseProperties',
    'WorkflowHealthResponse',
    'WorkflowTriggerListCallbackUrlQueriesResponse',
    'WsdlDefinitionResponse',
    'WsdlServiceResponse',
]

@pulumi.output_type
class AllowedAudiencesValidationResponse(dict):
    """
    The configuration settings of the Allowed Audiences validation flow.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAudiences":
            suggest = "allowed_audiences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AllowedAudiencesValidationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AllowedAudiencesValidationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AllowedAudiencesValidationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_audiences: Optional[Sequence[builtins.str]] = None):
        """
        The configuration settings of the Allowed Audiences validation flow.
        :param Sequence[builtins.str] allowed_audiences: The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[builtins.str]]:
        """
        The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
        return pulumi.get(self, "allowed_audiences")


@pulumi.output_type
class AllowedPrincipalsResponse(dict):
    """
    The configuration settings of the Azure Active Directory allowed principals.
    """
    def __init__(__self__, *,
                 groups: Optional[Sequence[builtins.str]] = None,
                 identities: Optional[Sequence[builtins.str]] = None):
        """
        The configuration settings of the Azure Active Directory allowed principals.
        :param Sequence[builtins.str] groups: The list of the allowed groups.
        :param Sequence[builtins.str] identities: The list of the allowed identities.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if identities is not None:
            pulumi.set(__self__, "identities", identities)

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The list of the allowed groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def identities(self) -> Optional[Sequence[builtins.str]]:
        """
        The list of the allowed identities.
        """
        return pulumi.get(self, "identities")


@pulumi.output_type
class ApiConnectionDefinitionResponseProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changedTime":
            suggest = "changed_time"
        elif key == "createdTime":
            suggest = "created_time"
        elif key == "customParameterValues":
            suggest = "custom_parameter_values"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "nonSecretParameterValues":
            suggest = "non_secret_parameter_values"
        elif key == "parameterValues":
            suggest = "parameter_values"
        elif key == "testLinks":
            suggest = "test_links"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiConnectionDefinitionResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiConnectionDefinitionResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiConnectionDefinitionResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api: Optional['outputs.ApiReferenceResponse'] = None,
                 changed_time: Optional[builtins.str] = None,
                 created_time: Optional[builtins.str] = None,
                 custom_parameter_values: Optional[Mapping[str, builtins.str]] = None,
                 display_name: Optional[builtins.str] = None,
                 non_secret_parameter_values: Optional[Mapping[str, builtins.str]] = None,
                 parameter_values: Optional[Mapping[str, builtins.str]] = None,
                 statuses: Optional[Sequence['outputs.ConnectionStatusDefinitionResponse']] = None,
                 test_links: Optional[Sequence['outputs.ApiConnectionTestLinkResponse']] = None):
        """
        :param builtins.str changed_time: Timestamp of last connection change
        :param builtins.str created_time: Timestamp of the connection creation
        :param Mapping[str, builtins.str] custom_parameter_values: Dictionary of custom parameter values
        :param builtins.str display_name: Display name
        :param Mapping[str, builtins.str] non_secret_parameter_values: Dictionary of nonsecret parameter values
        :param Mapping[str, builtins.str] parameter_values: Dictionary of parameter values
        :param Sequence['ConnectionStatusDefinitionResponse'] statuses: Status of the connection
        :param Sequence['ApiConnectionTestLinkResponse'] test_links: Links to test the API connection
        """
        if api is not None:
            pulumi.set(__self__, "api", api)
        if changed_time is not None:
            pulumi.set(__self__, "changed_time", changed_time)
        if created_time is not None:
            pulumi.set(__self__, "created_time", created_time)
        if custom_parameter_values is not None:
            pulumi.set(__self__, "custom_parameter_values", custom_parameter_values)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if non_secret_parameter_values is not None:
            pulumi.set(__self__, "non_secret_parameter_values", non_secret_parameter_values)
        if parameter_values is not None:
            pulumi.set(__self__, "parameter_values", parameter_values)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)
        if test_links is not None:
            pulumi.set(__self__, "test_links", test_links)

    @property
    @pulumi.getter
    def api(self) -> Optional['outputs.ApiReferenceResponse']:
        return pulumi.get(self, "api")

    @property
    @pulumi.getter(name="changedTime")
    def changed_time(self) -> Optional[builtins.str]:
        """
        Timestamp of last connection change
        """
        return pulumi.get(self, "changed_time")

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> Optional[builtins.str]:
        """
        Timestamp of the connection creation
        """
        return pulumi.get(self, "created_time")

    @property
    @pulumi.getter(name="customParameterValues")
    def custom_parameter_values(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Dictionary of custom parameter values
        """
        return pulumi.get(self, "custom_parameter_values")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="nonSecretParameterValues")
    def non_secret_parameter_values(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Dictionary of nonsecret parameter values
        """
        return pulumi.get(self, "non_secret_parameter_values")

    @property
    @pulumi.getter(name="parameterValues")
    def parameter_values(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Dictionary of parameter values
        """
        return pulumi.get(self, "parameter_values")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence['outputs.ConnectionStatusDefinitionResponse']]:
        """
        Status of the connection
        """
        return pulumi.get(self, "statuses")

    @property
    @pulumi.getter(name="testLinks")
    def test_links(self) -> Optional[Sequence['outputs.ApiConnectionTestLinkResponse']]:
        """
        Links to test the API connection
        """
        return pulumi.get(self, "test_links")


@pulumi.output_type
class ApiConnectionTestLinkResponse(dict):
    """
    API connection properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestUri":
            suggest = "request_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiConnectionTestLinkResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiConnectionTestLinkResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiConnectionTestLinkResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 method: Optional[builtins.str] = None,
                 request_uri: Optional[builtins.str] = None):
        """
        API connection properties
        :param builtins.str method: HTTP Method
        :param builtins.str request_uri: Test link request URI
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)

    @property
    @pulumi.getter
    def method(self) -> Optional[builtins.str]:
        """
        HTTP Method
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional[builtins.str]:
        """
        Test link request URI
        """
        return pulumi.get(self, "request_uri")


@pulumi.output_type
class ApiDefinitionInfoResponse(dict):
    """
    Information about the formal API definition for the app.
    """
    def __init__(__self__, *,
                 url: Optional[builtins.str] = None):
        """
        Information about the formal API definition for the app.
        :param builtins.str url: The URL of the API definition.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[builtins.str]:
        """
        The URL of the API definition.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ApiManagementConfigResponse(dict):
    """
    Azure API management (APIM) configuration linked to the app.
    """
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        """
        Azure API management (APIM) configuration linked to the app.
        :param builtins.str id: APIM-Api Identifier.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        APIM-Api Identifier.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApiOAuthSettingsParameterResponse(dict):
    """
    OAuth settings for the API
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "uiDefinition":
            suggest = "ui_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiOAuthSettingsParameterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiOAuthSettingsParameterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiOAuthSettingsParameterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 options: Optional[Any] = None,
                 ui_definition: Optional[Any] = None,
                 value: Optional[builtins.str] = None):
        """
        OAuth settings for the API
        :param Any options: Options available to this parameter
        :param Any ui_definition: UI definitions per culture as caller can specify the culture
        :param builtins.str value: Value of the setting
        """
        if options is not None:
            pulumi.set(__self__, "options", options)
        if ui_definition is not None:
            pulumi.set(__self__, "ui_definition", ui_definition)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[Any]:
        """
        Options available to this parameter
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="uiDefinition")
    def ui_definition(self) -> Optional[Any]:
        """
        UI definitions per culture as caller can specify the culture
        """
        return pulumi.get(self, "ui_definition")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value of the setting
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ApiOAuthSettingsResponse(dict):
    """
    OAuth settings for the connection provider
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "customParameters":
            suggest = "custom_parameters"
        elif key == "identityProvider":
            suggest = "identity_provider"
        elif key == "redirectUrl":
            suggest = "redirect_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiOAuthSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiOAuthSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiOAuthSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 custom_parameters: Optional[Mapping[str, 'outputs.ApiOAuthSettingsParameterResponse']] = None,
                 identity_provider: Optional[builtins.str] = None,
                 properties: Optional[Any] = None,
                 redirect_url: Optional[builtins.str] = None,
                 scopes: Optional[Sequence[builtins.str]] = None):
        """
        OAuth settings for the connection provider
        :param builtins.str client_id: Resource provider client id
        :param builtins.str client_secret: Client Secret needed for OAuth
        :param Mapping[str, 'ApiOAuthSettingsParameterResponse'] custom_parameters: OAuth parameters key is the name of parameter
        :param builtins.str identity_provider: Identity provider
        :param Any properties: Read only properties for this oauth setting.
        :param builtins.str redirect_url: Url
        :param Sequence[builtins.str] scopes: OAuth scopes
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if custom_parameters is not None:
            pulumi.set(__self__, "custom_parameters", custom_parameters)
        if identity_provider is not None:
            pulumi.set(__self__, "identity_provider", identity_provider)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        Resource provider client id
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        """
        Client Secret needed for OAuth
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="customParameters")
    def custom_parameters(self) -> Optional[Mapping[str, 'outputs.ApiOAuthSettingsParameterResponse']]:
        """
        OAuth parameters key is the name of parameter
        """
        return pulumi.get(self, "custom_parameters")

    @property
    @pulumi.getter(name="identityProvider")
    def identity_provider(self) -> Optional[builtins.str]:
        """
        Identity provider
        """
        return pulumi.get(self, "identity_provider")

    @property
    @pulumi.getter
    def properties(self) -> Optional[Any]:
        """
        Read only properties for this oauth setting.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[builtins.str]:
        """
        Url
        """
        return pulumi.get(self, "redirect_url")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[builtins.str]]:
        """
        OAuth scopes
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class ApiReferenceResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "brandColor":
            suggest = "brand_color"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "iconUri":
            suggest = "icon_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 brand_color: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 icon_uri: Optional[builtins.str] = None,
                 id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 swagger: Optional[Any] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str brand_color: Brand color
        :param builtins.str description: The custom API description
        :param builtins.str display_name: The display name
        :param builtins.str icon_uri: The icon URI
        :param builtins.str id: Resource reference id
        :param builtins.str name: The name of the API
        :param Any swagger: The JSON representation of the swagger
        :param builtins.str type: Resource reference type
        """
        if brand_color is not None:
            pulumi.set(__self__, "brand_color", brand_color)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if icon_uri is not None:
            pulumi.set(__self__, "icon_uri", icon_uri)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if swagger is not None:
            pulumi.set(__self__, "swagger", swagger)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="brandColor")
    def brand_color(self) -> Optional[builtins.str]:
        """
        Brand color
        """
        return pulumi.get(self, "brand_color")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The custom API description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        The display name
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="iconUri")
    def icon_uri(self) -> Optional[builtins.str]:
        """
        The icon URI
        """
        return pulumi.get(self, "icon_uri")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Resource reference id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name of the API
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def swagger(self) -> Optional[Any]:
        """
        The JSON representation of the swagger
        """
        return pulumi.get(self, "swagger")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Resource reference type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApiResourceBackendServiceResponse(dict):
    """
    The API backend service
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceUrl":
            suggest = "service_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiResourceBackendServiceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiResourceBackendServiceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiResourceBackendServiceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_url: Optional[builtins.str] = None):
        """
        The API backend service
        :param builtins.str service_url: The service URL
        """
        if service_url is not None:
            pulumi.set(__self__, "service_url", service_url)

    @property
    @pulumi.getter(name="serviceUrl")
    def service_url(self) -> Optional[builtins.str]:
        """
        The service URL
        """
        return pulumi.get(self, "service_url")


@pulumi.output_type
class ApiResourceDefinitionsResponse(dict):
    """
    API Definitions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modifiedSwaggerUrl":
            suggest = "modified_swagger_url"
        elif key == "originalSwaggerUrl":
            suggest = "original_swagger_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiResourceDefinitionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiResourceDefinitionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiResourceDefinitionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 modified_swagger_url: Optional[builtins.str] = None,
                 original_swagger_url: Optional[builtins.str] = None):
        """
        API Definitions
        :param builtins.str modified_swagger_url: The modified swagger URL
        :param builtins.str original_swagger_url: The original swagger URL
        """
        if modified_swagger_url is not None:
            pulumi.set(__self__, "modified_swagger_url", modified_swagger_url)
        if original_swagger_url is not None:
            pulumi.set(__self__, "original_swagger_url", original_swagger_url)

    @property
    @pulumi.getter(name="modifiedSwaggerUrl")
    def modified_swagger_url(self) -> Optional[builtins.str]:
        """
        The modified swagger URL
        """
        return pulumi.get(self, "modified_swagger_url")

    @property
    @pulumi.getter(name="originalSwaggerUrl")
    def original_swagger_url(self) -> Optional[builtins.str]:
        """
        The original swagger URL
        """
        return pulumi.get(self, "original_swagger_url")


@pulumi.output_type
class AppLogsConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsConfiguration":
            suggest = "log_analytics_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppLogsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppLogsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppLogsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional[builtins.str] = None,
                 log_analytics_configuration: Optional['outputs.LogAnalyticsConfigurationResponse'] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if log_analytics_configuration is not None:
            pulumi.set(__self__, "log_analytics_configuration", log_analytics_configuration)

    @property
    @pulumi.getter
    def destination(self) -> Optional[builtins.str]:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="logAnalyticsConfiguration")
    def log_analytics_configuration(self) -> Optional['outputs.LogAnalyticsConfigurationResponse']:
        return pulumi.get(self, "log_analytics_configuration")


@pulumi.output_type
class AppRegistrationResponse(dict):
    """
    The configuration settings of the app registration for providers that have app ids and app secrets
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[builtins.str] = None,
                 app_secret_setting_name: Optional[builtins.str] = None):
        """
        The configuration settings of the app registration for providers that have app ids and app secrets
        :param builtins.str app_id: The App ID of the app used for login.
        :param builtins.str app_secret_setting_name: The app setting name that contains the app secret.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[builtins.str]:
        """
        The App ID of the app used for login.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[builtins.str]:
        """
        The app setting name that contains the app secret.
        """
        return pulumi.get(self, "app_secret_setting_name")


@pulumi.output_type
class AppleRegistrationResponse(dict):
    """
    The configuration settings of the registration for the Apple provider
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppleRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppleRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppleRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[builtins.str] = None,
                 client_secret_setting_name: Optional[builtins.str] = None):
        """
        The configuration settings of the registration for the Apple provider
        :param builtins.str client_id: The Client ID of the app used for login.
        :param builtins.str client_secret_setting_name: The app setting name that contains the client secret.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[builtins.str]:
        """
        The app setting name that contains the client secret.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class AppleResponse(dict):
    """
    The configuration settings of the Apple provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.AppleRegistrationResponse'] = None):
        """
        The configuration settings of the Apple provider.
        :param builtins.bool enabled: <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'AppleRegistrationResponse' registration: The configuration settings of the Apple registration.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.AppleRegistrationResponse']:
        """
        The configuration settings of the Apple registration.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class ApplicationLogsConfigResponse(dict):
    """
    Application logs configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "azureTableStorage":
            suggest = "azure_table_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationLogsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationLogsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationLogsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.AzureBlobStorageApplicationLogsConfigResponse'] = None,
                 azure_table_storage: Optional['outputs.AzureTableStorageApplicationLogsConfigResponse'] = None,
                 file_system: Optional['outputs.FileSystemApplicationLogsConfigResponse'] = None):
        """
        Application logs configuration.
        :param 'AzureBlobStorageApplicationLogsConfigResponse' azure_blob_storage: Application logs to blob storage configuration.
        :param 'AzureTableStorageApplicationLogsConfigResponse' azure_table_storage: Application logs to azure table storage configuration.
        :param 'FileSystemApplicationLogsConfigResponse' file_system: Application logs to file system configuration.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if azure_table_storage is not None:
            pulumi.set(__self__, "azure_table_storage", azure_table_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.AzureBlobStorageApplicationLogsConfigResponse']:
        """
        Application logs to blob storage configuration.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="azureTableStorage")
    def azure_table_storage(self) -> Optional['outputs.AzureTableStorageApplicationLogsConfigResponse']:
        """
        Application logs to azure table storage configuration.
        """
        return pulumi.get(self, "azure_table_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.FileSystemApplicationLogsConfigResponse']:
        """
        Application logs to file system configuration.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class ArcConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactStorageAccessMode":
            suggest = "artifact_storage_access_mode"
        elif key == "artifactStorageClassName":
            suggest = "artifact_storage_class_name"
        elif key == "artifactStorageMountPath":
            suggest = "artifact_storage_mount_path"
        elif key == "artifactStorageNodeName":
            suggest = "artifact_storage_node_name"
        elif key == "artifactsStorageType":
            suggest = "artifacts_storage_type"
        elif key == "frontEndServiceConfiguration":
            suggest = "front_end_service_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArcConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArcConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArcConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_storage_access_mode: Optional[builtins.str] = None,
                 artifact_storage_class_name: Optional[builtins.str] = None,
                 artifact_storage_mount_path: Optional[builtins.str] = None,
                 artifact_storage_node_name: Optional[builtins.str] = None,
                 artifacts_storage_type: Optional[builtins.str] = None,
                 front_end_service_configuration: Optional['outputs.FrontEndConfigurationResponse'] = None):
        if artifact_storage_access_mode is not None:
            pulumi.set(__self__, "artifact_storage_access_mode", artifact_storage_access_mode)
        if artifact_storage_class_name is not None:
            pulumi.set(__self__, "artifact_storage_class_name", artifact_storage_class_name)
        if artifact_storage_mount_path is not None:
            pulumi.set(__self__, "artifact_storage_mount_path", artifact_storage_mount_path)
        if artifact_storage_node_name is not None:
            pulumi.set(__self__, "artifact_storage_node_name", artifact_storage_node_name)
        if artifacts_storage_type is not None:
            pulumi.set(__self__, "artifacts_storage_type", artifacts_storage_type)
        if front_end_service_configuration is not None:
            pulumi.set(__self__, "front_end_service_configuration", front_end_service_configuration)

    @property
    @pulumi.getter(name="artifactStorageAccessMode")
    def artifact_storage_access_mode(self) -> Optional[builtins.str]:
        return pulumi.get(self, "artifact_storage_access_mode")

    @property
    @pulumi.getter(name="artifactStorageClassName")
    def artifact_storage_class_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "artifact_storage_class_name")

    @property
    @pulumi.getter(name="artifactStorageMountPath")
    def artifact_storage_mount_path(self) -> Optional[builtins.str]:
        return pulumi.get(self, "artifact_storage_mount_path")

    @property
    @pulumi.getter(name="artifactStorageNodeName")
    def artifact_storage_node_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "artifact_storage_node_name")

    @property
    @pulumi.getter(name="artifactsStorageType")
    def artifacts_storage_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "artifacts_storage_type")

    @property
    @pulumi.getter(name="frontEndServiceConfiguration")
    def front_end_service_configuration(self) -> Optional['outputs.FrontEndConfigurationResponse']:
        return pulumi.get(self, "front_end_service_configuration")


@pulumi.output_type
class ArmIdWrapperResponse(dict):
    """
    A wrapper for an ARM resource id
    """
    def __init__(__self__, *,
                 id: builtins.str):
        """
        A wrapper for an ARM resource id
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class ArmPlanResponse(dict):
    """
    The plan object in Azure Resource Manager, represents a marketplace plan.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "promotionCode":
            suggest = "promotion_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArmPlanResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArmPlanResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArmPlanResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 product: Optional[builtins.str] = None,
                 promotion_code: Optional[builtins.str] = None,
                 publisher: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        The plan object in Azure Resource Manager, represents a marketplace plan.
        :param builtins.str name: The name.
        :param builtins.str product: The product.
        :param builtins.str promotion_code: The promotion code.
        :param builtins.str publisher: The publisher.
        :param builtins.str version: Version of product.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if promotion_code is not None:
            pulumi.set(__self__, "promotion_code", promotion_code)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> Optional[builtins.str]:
        """
        The product.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[builtins.str]:
        """
        The promotion code.
        """
        return pulumi.get(self, "promotion_code")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[builtins.str]:
        """
        The publisher.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version of product.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AseV3NetworkingConfigurationResponse(dict):
    """
    Full view of networking configuration for an ASE.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalInboundIpAddresses":
            suggest = "external_inbound_ip_addresses"
        elif key == "internalInboundIpAddresses":
            suggest = "internal_inbound_ip_addresses"
        elif key == "linuxOutboundIpAddresses":
            suggest = "linux_outbound_ip_addresses"
        elif key == "windowsOutboundIpAddresses":
            suggest = "windows_outbound_ip_addresses"
        elif key == "allowNewPrivateEndpointConnections":
            suggest = "allow_new_private_endpoint_connections"
        elif key == "ftpEnabled":
            suggest = "ftp_enabled"
        elif key == "inboundIpAddressOverride":
            suggest = "inbound_ip_address_override"
        elif key == "remoteDebugEnabled":
            suggest = "remote_debug_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AseV3NetworkingConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AseV3NetworkingConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AseV3NetworkingConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_inbound_ip_addresses: Sequence[builtins.str],
                 id: builtins.str,
                 internal_inbound_ip_addresses: Sequence[builtins.str],
                 linux_outbound_ip_addresses: Sequence[builtins.str],
                 name: builtins.str,
                 type: builtins.str,
                 windows_outbound_ip_addresses: Sequence[builtins.str],
                 allow_new_private_endpoint_connections: Optional[builtins.bool] = None,
                 ftp_enabled: Optional[builtins.bool] = None,
                 inbound_ip_address_override: Optional[builtins.str] = None,
                 kind: Optional[builtins.str] = None,
                 remote_debug_enabled: Optional[builtins.bool] = None):
        """
        Full view of networking configuration for an ASE.
        :param builtins.str id: Resource Id.
        :param builtins.str name: Resource Name.
        :param builtins.str type: Resource type.
        :param builtins.bool allow_new_private_endpoint_connections: Property to enable and disable new private endpoint connection creation on ASE
        :param builtins.bool ftp_enabled: Property to enable and disable FTP on ASEV3
        :param builtins.str inbound_ip_address_override: Customer provided Inbound IP Address. Only able to be set on Ase create.
        :param builtins.str kind: Kind of resource.
        :param builtins.bool remote_debug_enabled: Property to enable and disable Remote Debug on ASEV3
        """
        pulumi.set(__self__, "external_inbound_ip_addresses", external_inbound_ip_addresses)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "internal_inbound_ip_addresses", internal_inbound_ip_addresses)
        pulumi.set(__self__, "linux_outbound_ip_addresses", linux_outbound_ip_addresses)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "windows_outbound_ip_addresses", windows_outbound_ip_addresses)
        if allow_new_private_endpoint_connections is not None:
            pulumi.set(__self__, "allow_new_private_endpoint_connections", allow_new_private_endpoint_connections)
        if ftp_enabled is not None:
            pulumi.set(__self__, "ftp_enabled", ftp_enabled)
        if inbound_ip_address_override is not None:
            pulumi.set(__self__, "inbound_ip_address_override", inbound_ip_address_override)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if remote_debug_enabled is not None:
            pulumi.set(__self__, "remote_debug_enabled", remote_debug_enabled)

    @property
    @pulumi.getter(name="externalInboundIpAddresses")
    def external_inbound_ip_addresses(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "external_inbound_ip_addresses")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="internalInboundIpAddresses")
    def internal_inbound_ip_addresses(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "internal_inbound_ip_addresses")

    @property
    @pulumi.getter(name="linuxOutboundIpAddresses")
    def linux_outbound_ip_addresses(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "linux_outbound_ip_addresses")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="windowsOutboundIpAddresses")
    def windows_outbound_ip_addresses(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "windows_outbound_ip_addresses")

    @property
    @pulumi.getter(name="allowNewPrivateEndpointConnections")
    def allow_new_private_endpoint_connections(self) -> Optional[builtins.bool]:
        """
        Property to enable and disable new private endpoint connection creation on ASE
        """
        return pulumi.get(self, "allow_new_private_endpoint_connections")

    @property
    @pulumi.getter(name="ftpEnabled")
    def ftp_enabled(self) -> Optional[builtins.bool]:
        """
        Property to enable and disable FTP on ASEV3
        """
        return pulumi.get(self, "ftp_enabled")

    @property
    @pulumi.getter(name="inboundIpAddressOverride")
    def inbound_ip_address_override(self) -> Optional[builtins.str]:
        """
        Customer provided Inbound IP Address. Only able to be set on Ase create.
        """
        return pulumi.get(self, "inbound_ip_address_override")

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="remoteDebugEnabled")
    def remote_debug_enabled(self) -> Optional[builtins.bool]:
        """
        Property to enable and disable Remote Debug on ASEV3
        """
        return pulumi.get(self, "remote_debug_enabled")


@pulumi.output_type
class AuthPlatformResponse(dict):
    """
    The configuration settings of the platform of App Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configFilePath":
            suggest = "config_file_path"
        elif key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthPlatformResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthPlatformResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthPlatformResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_file_path: Optional[builtins.str] = None,
                 enabled: Optional[builtins.bool] = None,
                 runtime_version: Optional[builtins.str] = None):
        """
        The configuration settings of the platform of App Service Authentication/Authorization.
        :param builtins.str config_file_path: The path of the config file containing auth settings if they come from a file.
               If the path is relative, base will the site's root directory.
        :param builtins.bool enabled: <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        :param builtins.str runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
               The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[builtins.str]:
        """
        The path of the config file containing auth settings if they come from a file.
        If the path is relative, base will the site's root directory.
        """
        return pulumi.get(self, "config_file_path")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[builtins.str]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
        return pulumi.get(self, "runtime_version")


@pulumi.output_type
class AutoHealActionsResponse(dict):
    """
    Actions which to take by the auto-heal module when a rule is triggered.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "customAction":
            suggest = "custom_action"
        elif key == "minProcessExecutionTime":
            suggest = "min_process_execution_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoHealActionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoHealActionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoHealActionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: Optional[builtins.str] = None,
                 custom_action: Optional['outputs.AutoHealCustomActionResponse'] = None,
                 min_process_execution_time: Optional[builtins.str] = None):
        """
        Actions which to take by the auto-heal module when a rule is triggered.
        :param builtins.str action_type: Predefined action to be taken.
        :param 'AutoHealCustomActionResponse' custom_action: Custom action to be taken.
        :param builtins.str min_process_execution_time: Minimum time the process must execute
               before taking the action
        """
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if custom_action is not None:
            pulumi.set(__self__, "custom_action", custom_action)
        if min_process_execution_time is not None:
            pulumi.set(__self__, "min_process_execution_time", min_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[builtins.str]:
        """
        Predefined action to be taken.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="customAction")
    def custom_action(self) -> Optional['outputs.AutoHealCustomActionResponse']:
        """
        Custom action to be taken.
        """
        return pulumi.get(self, "custom_action")

    @property
    @pulumi.getter(name="minProcessExecutionTime")
    def min_process_execution_time(self) -> Optional[builtins.str]:
        """
        Minimum time the process must execute
        before taking the action
        """
        return pulumi.get(self, "min_process_execution_time")


@pulumi.output_type
class AutoHealCustomActionResponse(dict):
    """
    Custom action to be executed
    when an auto heal rule is triggered.
    """
    def __init__(__self__, *,
                 exe: Optional[builtins.str] = None,
                 parameters: Optional[builtins.str] = None):
        """
        Custom action to be executed
        when an auto heal rule is triggered.
        :param builtins.str exe: Executable to be run.
        :param builtins.str parameters: Parameters for the executable.
        """
        if exe is not None:
            pulumi.set(__self__, "exe", exe)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def exe(self) -> Optional[builtins.str]:
        """
        Executable to be run.
        """
        return pulumi.get(self, "exe")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[builtins.str]:
        """
        Parameters for the executable.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class AutoHealRulesResponse(dict):
    """
    Rules that can be defined for auto-heal.
    """
    def __init__(__self__, *,
                 actions: Optional['outputs.AutoHealActionsResponse'] = None,
                 triggers: Optional['outputs.AutoHealTriggersResponse'] = None):
        """
        Rules that can be defined for auto-heal.
        :param 'AutoHealActionsResponse' actions: Actions to be executed when a rule is triggered.
        :param 'AutoHealTriggersResponse' triggers: Conditions that describe when to execute the auto-heal actions.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.AutoHealActionsResponse']:
        """
        Actions to be executed when a rule is triggered.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def triggers(self) -> Optional['outputs.AutoHealTriggersResponse']:
        """
        Conditions that describe when to execute the auto-heal actions.
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class AutoHealTriggersResponse(dict):
    """
    Triggers for auto-heal.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateBytesInKB":
            suggest = "private_bytes_in_kb"
        elif key == "slowRequests":
            suggest = "slow_requests"
        elif key == "slowRequestsWithPath":
            suggest = "slow_requests_with_path"
        elif key == "statusCodes":
            suggest = "status_codes"
        elif key == "statusCodesRange":
            suggest = "status_codes_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoHealTriggersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoHealTriggersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoHealTriggersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_bytes_in_kb: Optional[builtins.int] = None,
                 requests: Optional['outputs.RequestsBasedTriggerResponse'] = None,
                 slow_requests: Optional['outputs.SlowRequestsBasedTriggerResponse'] = None,
                 slow_requests_with_path: Optional[Sequence['outputs.SlowRequestsBasedTriggerResponse']] = None,
                 status_codes: Optional[Sequence['outputs.StatusCodesBasedTriggerResponse']] = None,
                 status_codes_range: Optional[Sequence['outputs.StatusCodesRangeBasedTriggerResponse']] = None):
        """
        Triggers for auto-heal.
        :param builtins.int private_bytes_in_kb: A rule based on private bytes.
        :param 'RequestsBasedTriggerResponse' requests: A rule based on total requests.
        :param 'SlowRequestsBasedTriggerResponse' slow_requests: A rule based on request execution time.
        :param Sequence['SlowRequestsBasedTriggerResponse'] slow_requests_with_path: A rule based on multiple Slow Requests Rule with path
        :param Sequence['StatusCodesBasedTriggerResponse'] status_codes: A rule based on status codes.
        :param Sequence['StatusCodesRangeBasedTriggerResponse'] status_codes_range: A rule based on status codes ranges.
        """
        if private_bytes_in_kb is not None:
            pulumi.set(__self__, "private_bytes_in_kb", private_bytes_in_kb)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_requests is not None:
            pulumi.set(__self__, "slow_requests", slow_requests)
        if slow_requests_with_path is not None:
            pulumi.set(__self__, "slow_requests_with_path", slow_requests_with_path)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)
        if status_codes_range is not None:
            pulumi.set(__self__, "status_codes_range", status_codes_range)

    @property
    @pulumi.getter(name="privateBytesInKB")
    def private_bytes_in_kb(self) -> Optional[builtins.int]:
        """
        A rule based on private bytes.
        """
        return pulumi.get(self, "private_bytes_in_kb")

    @property
    @pulumi.getter
    def requests(self) -> Optional['outputs.RequestsBasedTriggerResponse']:
        """
        A rule based on total requests.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional['outputs.SlowRequestsBasedTriggerResponse']:
        """
        A rule based on request execution time.
        """
        return pulumi.get(self, "slow_requests")

    @property
    @pulumi.getter(name="slowRequestsWithPath")
    def slow_requests_with_path(self) -> Optional[Sequence['outputs.SlowRequestsBasedTriggerResponse']]:
        """
        A rule based on multiple Slow Requests Rule with path
        """
        return pulumi.get(self, "slow_requests_with_path")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[Sequence['outputs.StatusCodesBasedTriggerResponse']]:
        """
        A rule based on status codes.
        """
        return pulumi.get(self, "status_codes")

    @property
    @pulumi.getter(name="statusCodesRange")
    def status_codes_range(self) -> Optional[Sequence['outputs.StatusCodesRangeBasedTriggerResponse']]:
        """
        A rule based on status codes ranges.
        """
        return pulumi.get(self, "status_codes_range")


@pulumi.output_type
class AzureActiveDirectoryLoginResponse(dict):
    """
    The configuration settings of the Azure Active Directory login flow.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableWWWAuthenticate":
            suggest = "disable_www_authenticate"
        elif key == "loginParameters":
            suggest = "login_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureActiveDirectoryLoginResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureActiveDirectoryLoginResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureActiveDirectoryLoginResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_www_authenticate: Optional[builtins.bool] = None,
                 login_parameters: Optional[Sequence[builtins.str]] = None):
        """
        The configuration settings of the Azure Active Directory login flow.
        :param builtins.bool disable_www_authenticate: <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        :param Sequence[builtins.str] login_parameters: Login parameters to send to the OpenID Connect authorization endpoint when
               a user logs in. Each parameter must be in the form "key=value".
        """
        if disable_www_authenticate is not None:
            pulumi.set(__self__, "disable_www_authenticate", disable_www_authenticate)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)

    @property
    @pulumi.getter(name="disableWWWAuthenticate")
    def disable_www_authenticate(self) -> Optional[builtins.bool]:
        """
        <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "disable_www_authenticate")

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[Sequence[builtins.str]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when
        a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "login_parameters")


@pulumi.output_type
class AzureActiveDirectoryRegistrationResponse(dict):
    """
    The configuration settings of the Azure Active Directory app registration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretCertificateIssuer":
            suggest = "client_secret_certificate_issuer"
        elif key == "clientSecretCertificateSubjectAlternativeName":
            suggest = "client_secret_certificate_subject_alternative_name"
        elif key == "clientSecretCertificateThumbprint":
            suggest = "client_secret_certificate_thumbprint"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "openIdIssuer":
            suggest = "open_id_issuer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureActiveDirectoryRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureActiveDirectoryRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureActiveDirectoryRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[builtins.str] = None,
                 client_secret_certificate_issuer: Optional[builtins.str] = None,
                 client_secret_certificate_subject_alternative_name: Optional[builtins.str] = None,
                 client_secret_certificate_thumbprint: Optional[builtins.str] = None,
                 client_secret_setting_name: Optional[builtins.str] = None,
                 open_id_issuer: Optional[builtins.str] = None):
        """
        The configuration settings of the Azure Active Directory app registration.
        :param builtins.str client_id: The Client ID of this relying party application, known as the client_id.
               This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
               other 3rd party OpenID Connect providers.
               More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        :param builtins.str client_secret_certificate_issuer: An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        :param builtins.str client_secret_certificate_subject_alternative_name: An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        :param builtins.str client_secret_certificate_thumbprint: An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret. It is also optional.
        :param builtins.str client_secret_setting_name: The app setting name that contains the client secret of the relying party application.
        :param builtins.str open_id_issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
               When using Azure Active Directory, this value is the URI of the directory tenant, e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
               This URI is a case-sensitive identifier for the token issuer.
               More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_certificate_issuer is not None:
            pulumi.set(__self__, "client_secret_certificate_issuer", client_secret_certificate_issuer)
        if client_secret_certificate_subject_alternative_name is not None:
            pulumi.set(__self__, "client_secret_certificate_subject_alternative_name", client_secret_certificate_subject_alternative_name)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if open_id_issuer is not None:
            pulumi.set(__self__, "open_id_issuer", open_id_issuer)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The Client ID of this relying party application, known as the client_id.
        This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
        other 3rd party OpenID Connect providers.
        More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretCertificateIssuer")
    def client_secret_certificate_issuer(self) -> Optional[builtins.str]:
        """
        An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_issuer")

    @property
    @pulumi.getter(name="clientSecretCertificateSubjectAlternativeName")
    def client_secret_certificate_subject_alternative_name(self) -> Optional[builtins.str]:
        """
        An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_subject_alternative_name")

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[builtins.str]:
        """
        An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[builtins.str]:
        """
        The app setting name that contains the client secret of the relying party application.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter(name="openIdIssuer")
    def open_id_issuer(self) -> Optional[builtins.str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
        When using Azure Active Directory, this value is the URI of the directory tenant, e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
        This URI is a case-sensitive identifier for the token issuer.
        More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
        return pulumi.get(self, "open_id_issuer")


@pulumi.output_type
class AzureActiveDirectoryResponse(dict):
    """
    The configuration settings of the Azure Active directory provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAutoProvisioned":
            suggest = "is_auto_provisioned"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureActiveDirectoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureActiveDirectoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureActiveDirectoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 is_auto_provisioned: Optional[builtins.bool] = None,
                 login: Optional['outputs.AzureActiveDirectoryLoginResponse'] = None,
                 registration: Optional['outputs.AzureActiveDirectoryRegistrationResponse'] = None,
                 validation: Optional['outputs.AzureActiveDirectoryValidationResponse'] = None):
        """
        The configuration settings of the Azure Active directory provider.
        :param builtins.bool enabled: <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param builtins.bool is_auto_provisioned: Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
               This is an internal flag primarily intended to support the Azure Management Portal. Users should not
               read or write to this property.
        :param 'AzureActiveDirectoryLoginResponse' login: The configuration settings of the Azure Active Directory login flow.
        :param 'AzureActiveDirectoryRegistrationResponse' registration: The configuration settings of the Azure Active Directory app registration.
        :param 'AzureActiveDirectoryValidationResponse' validation: The configuration settings of the Azure Active Directory token validation flow.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if is_auto_provisioned is not None:
            pulumi.set(__self__, "is_auto_provisioned", is_auto_provisioned)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="isAutoProvisioned")
    def is_auto_provisioned(self) -> Optional[builtins.bool]:
        """
        Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
        This is an internal flag primarily intended to support the Azure Management Portal. Users should not
        read or write to this property.
        """
        return pulumi.get(self, "is_auto_provisioned")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.AzureActiveDirectoryLoginResponse']:
        """
        The configuration settings of the Azure Active Directory login flow.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.AzureActiveDirectoryRegistrationResponse']:
        """
        The configuration settings of the Azure Active Directory app registration.
        """
        return pulumi.get(self, "registration")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.AzureActiveDirectoryValidationResponse']:
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class AzureActiveDirectoryValidationResponse(dict):
    """
    The configuration settings of the Azure Active Directory token validation flow.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "defaultAuthorizationPolicy":
            suggest = "default_authorization_policy"
        elif key == "jwtClaimChecks":
            suggest = "jwt_claim_checks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureActiveDirectoryValidationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureActiveDirectoryValidationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureActiveDirectoryValidationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_audiences: Optional[Sequence[builtins.str]] = None,
                 default_authorization_policy: Optional['outputs.DefaultAuthorizationPolicyResponse'] = None,
                 jwt_claim_checks: Optional['outputs.JwtClaimChecksResponse'] = None):
        """
        The configuration settings of the Azure Active Directory token validation flow.
        :param Sequence[builtins.str] allowed_audiences: The list of audiences that can make successful authentication/authorization requests.
        :param 'DefaultAuthorizationPolicyResponse' default_authorization_policy: The configuration settings of the default authorization policy.
        :param 'JwtClaimChecksResponse' jwt_claim_checks: The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if default_authorization_policy is not None:
            pulumi.set(__self__, "default_authorization_policy", default_authorization_policy)
        if jwt_claim_checks is not None:
            pulumi.set(__self__, "jwt_claim_checks", jwt_claim_checks)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[builtins.str]]:
        """
        The list of audiences that can make successful authentication/authorization requests.
        """
        return pulumi.get(self, "allowed_audiences")

    @property
    @pulumi.getter(name="defaultAuthorizationPolicy")
    def default_authorization_policy(self) -> Optional['outputs.DefaultAuthorizationPolicyResponse']:
        """
        The configuration settings of the default authorization policy.
        """
        return pulumi.get(self, "default_authorization_policy")

    @property
    @pulumi.getter(name="jwtClaimChecks")
    def jwt_claim_checks(self) -> Optional['outputs.JwtClaimChecksResponse']:
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        return pulumi.get(self, "jwt_claim_checks")


@pulumi.output_type
class AzureBlobStorageApplicationLogsConfigResponse(dict):
    """
    Application logs azure blob storage configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureBlobStorageApplicationLogsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureBlobStorageApplicationLogsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureBlobStorageApplicationLogsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level: Optional[builtins.str] = None,
                 retention_in_days: Optional[builtins.int] = None,
                 sas_url: Optional[builtins.str] = None):
        """
        Application logs azure blob storage configuration.
        :param builtins.str level: Log level.
        :param builtins.int retention_in_days: Retention in days.
               Remove blobs older than X days.
               0 or lower means no retention.
        :param builtins.str sas_url: SAS url to a azure blob container with read/write/list/delete permissions.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if sas_url is not None:
            pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> Optional[builtins.str]:
        """
        Log level.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[builtins.int]:
        """
        Retention in days.
        Remove blobs older than X days.
        0 or lower means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> Optional[builtins.str]:
        """
        SAS url to a azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class AzureBlobStorageHttpLogsConfigResponse(dict):
    """
    Http logs to azure blob storage configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureBlobStorageHttpLogsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureBlobStorageHttpLogsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureBlobStorageHttpLogsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 retention_in_days: Optional[builtins.int] = None,
                 sas_url: Optional[builtins.str] = None):
        """
        Http logs to azure blob storage configuration.
        :param builtins.bool enabled: True if configuration is enabled, false if it is disabled and null if configuration is not set.
        :param builtins.int retention_in_days: Retention in days.
               Remove blobs older than X days.
               0 or lower means no retention.
        :param builtins.str sas_url: SAS url to a azure blob container with read/write/list/delete permissions.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if sas_url is not None:
            pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[builtins.int]:
        """
        Retention in days.
        Remove blobs older than X days.
        0 or lower means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> Optional[builtins.str]:
        """
        SAS url to a azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")


@pulumi.output_type
class AzureResourceErrorInfoResponse(dict):
    """
    The azure resource error info.
    """
    def __init__(__self__, *,
                 code: builtins.str,
                 message: builtins.str,
                 details: Optional[Sequence['outputs.AzureResourceErrorInfoResponse']] = None):
        """
        The azure resource error info.
        :param builtins.str code: The error code.
        :param builtins.str message: The error message.
        :param Sequence['AzureResourceErrorInfoResponse'] details: The error details.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "message", message)
        if details is not None:
            pulumi.set(__self__, "details", details)

    @property
    @pulumi.getter
    def code(self) -> builtins.str:
        """
        The error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> builtins.str:
        """
        The error message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.AzureResourceErrorInfoResponse']]:
        """
        The error details.
        """
        return pulumi.get(self, "details")


@pulumi.output_type
class AzureStaticWebAppsRegistrationResponse(dict):
    """
    The configuration settings of the registration for the Azure Static Web Apps provider
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureStaticWebAppsRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureStaticWebAppsRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureStaticWebAppsRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[builtins.str] = None):
        """
        The configuration settings of the registration for the Azure Static Web Apps provider
        :param builtins.str client_id: The Client ID of the app used for login.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class AzureStaticWebAppsResponse(dict):
    """
    The configuration settings of the Azure Static Web Apps provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 registration: Optional['outputs.AzureStaticWebAppsRegistrationResponse'] = None):
        """
        The configuration settings of the Azure Static Web Apps provider.
        :param builtins.bool enabled: <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'AzureStaticWebAppsRegistrationResponse' registration: The configuration settings of the Azure Static Web Apps registration.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.AzureStaticWebAppsRegistrationResponse']:
        """
        The configuration settings of the Azure Static Web Apps registration.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class AzureStorageInfoValueResponse(dict):
    """
    Azure Files or Blob Storage access information value for dictionary storage.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "mountPath":
            suggest = "mount_path"
        elif key == "shareName":
            suggest = "share_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureStorageInfoValueResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureStorageInfoValueResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureStorageInfoValueResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 account_name: Optional[builtins.str] = None,
                 mount_path: Optional[builtins.str] = None,
                 protocol: Optional[builtins.str] = None,
                 share_name: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        Azure Files or Blob Storage access information value for dictionary storage.
        :param builtins.str state: State of the storage account.
        :param builtins.str access_key: Access key for the storage account.
        :param builtins.str account_name: Name of the storage account.
        :param builtins.str mount_path: Path to mount the storage within the site's runtime environment.
        :param builtins.str protocol: Mounting protocol to use for the storage account.
        :param builtins.str share_name: Name of the file share (container name, for Blob storage).
        :param builtins.str type: Type of storage.
        """
        pulumi.set(__self__, "state", state)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        State of the storage account.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[builtins.str]:
        """
        Name of the storage account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[builtins.str]:
        """
        Path to mount the storage within the site's runtime environment.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[builtins.str]:
        """
        Mounting protocol to use for the storage account.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[builtins.str]:
        """
        Name of the file share (container name, for Blob storage).
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of storage.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AzureTableStorageApplicationLogsConfigResponse(dict):
    """
    Application logs to Azure table storage configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sasUrl":
            suggest = "sas_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureTableStorageApplicationLogsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureTableStorageApplicationLogsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureTableStorageApplicationLogsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sas_url: builtins.str,
                 level: Optional[builtins.str] = None):
        """
        Application logs to Azure table storage configuration.
        :param builtins.str sas_url: SAS URL to an Azure table with add/query/delete permissions.
        :param builtins.str level: Log level.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> builtins.str:
        """
        SAS URL to an Azure table with add/query/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @property
    @pulumi.getter
    def level(self) -> Optional[builtins.str]:
        """
        Log level.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class BackupItemResponse(dict):
    """
    Backup description.
    """
    def __init__(__self__, *,
                 backup_id: builtins.int,
                 blob_name: builtins.str,
                 correlation_id: builtins.str,
                 created: builtins.str,
                 databases: Sequence['outputs.DatabaseBackupSettingResponse'],
                 finished_time_stamp: builtins.str,
                 id: builtins.str,
                 last_restore_time_stamp: builtins.str,
                 log: builtins.str,
                 name: builtins.str,
                 scheduled: builtins.bool,
                 size_in_bytes: builtins.float,
                 status: builtins.str,
                 storage_account_url: builtins.str,
                 type: builtins.str,
                 website_size_in_bytes: builtins.float,
                 kind: Optional[builtins.str] = None):
        """
        Backup description.
        :param builtins.int backup_id: Id of the backup.
        :param builtins.str blob_name: Name of the blob which contains data for this backup.
        :param builtins.str correlation_id: Unique correlation identifier. Please use this along with the timestamp while communicating with Azure support.
        :param builtins.str created: Timestamp of the backup creation.
        :param Sequence['DatabaseBackupSettingResponse'] databases: List of databases included in the backup.
        :param builtins.str finished_time_stamp: Timestamp when this backup finished.
        :param builtins.str id: Resource Id.
        :param builtins.str last_restore_time_stamp: Timestamp of a last restore operation which used this backup.
        :param builtins.str log: Details regarding this backup. Might contain an error message.
        :param builtins.str name: Resource Name.
        :param builtins.bool scheduled: True if this backup has been created due to a schedule being triggered.
        :param builtins.float size_in_bytes: Size of the backup in bytes.
        :param builtins.str status: Backup status.
        :param builtins.str storage_account_url: SAS URL for the storage account container which contains this backup.
        :param builtins.str type: Resource type.
        :param builtins.float website_size_in_bytes: Size of the original web app which has been backed up.
        :param builtins.str kind: Kind of resource.
        """
        pulumi.set(__self__, "backup_id", backup_id)
        pulumi.set(__self__, "blob_name", blob_name)
        pulumi.set(__self__, "correlation_id", correlation_id)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "databases", databases)
        pulumi.set(__self__, "finished_time_stamp", finished_time_stamp)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_restore_time_stamp", last_restore_time_stamp)
        pulumi.set(__self__, "log", log)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "scheduled", scheduled)
        pulumi.set(__self__, "size_in_bytes", size_in_bytes)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "storage_account_url", storage_account_url)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "website_size_in_bytes", website_size_in_bytes)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> builtins.int:
        """
        Id of the backup.
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="blobName")
    def blob_name(self) -> builtins.str:
        """
        Name of the blob which contains data for this backup.
        """
        return pulumi.get(self, "blob_name")

    @property
    @pulumi.getter(name="correlationId")
    def correlation_id(self) -> builtins.str:
        """
        Unique correlation identifier. Please use this along with the timestamp while communicating with Azure support.
        """
        return pulumi.get(self, "correlation_id")

    @property
    @pulumi.getter
    def created(self) -> builtins.str:
        """
        Timestamp of the backup creation.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def databases(self) -> Sequence['outputs.DatabaseBackupSettingResponse']:
        """
        List of databases included in the backup.
        """
        return pulumi.get(self, "databases")

    @property
    @pulumi.getter(name="finishedTimeStamp")
    def finished_time_stamp(self) -> builtins.str:
        """
        Timestamp when this backup finished.
        """
        return pulumi.get(self, "finished_time_stamp")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastRestoreTimeStamp")
    def last_restore_time_stamp(self) -> builtins.str:
        """
        Timestamp of a last restore operation which used this backup.
        """
        return pulumi.get(self, "last_restore_time_stamp")

    @property
    @pulumi.getter
    def log(self) -> builtins.str:
        """
        Details regarding this backup. Might contain an error message.
        """
        return pulumi.get(self, "log")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scheduled(self) -> builtins.bool:
        """
        True if this backup has been created due to a schedule being triggered.
        """
        return pulumi.get(self, "scheduled")

    @property
    @pulumi.getter(name="sizeInBytes")
    def size_in_bytes(self) -> builtins.float:
        """
        Size of the backup in bytes.
        """
        return pulumi.get(self, "size_in_bytes")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Backup status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storageAccountUrl")
    def storage_account_url(self) -> builtins.str:
        """
        SAS URL for the storage account container which contains this backup.
        """
        return pulumi.get(self, "storage_account_url")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="websiteSizeInBytes")
    def website_size_in_bytes(self) -> builtins.float:
        """
        Size of the original web app which has been backed up.
        """
        return pulumi.get(self, "website_size_in_bytes")

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class BackupScheduleResponse(dict):
    """
    Description of a backup schedule. Describes how often should be the backup performed and what should be the retention policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyUnit":
            suggest = "frequency_unit"
        elif key == "keepAtLeastOneBackup":
            suggest = "keep_at_least_one_backup"
        elif key == "lastExecutionTime":
            suggest = "last_execution_time"
        elif key == "retentionPeriodInDays":
            suggest = "retention_period_in_days"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: Optional[builtins.int] = None,
                 frequency_unit: Optional[builtins.str] = None,
                 keep_at_least_one_backup: Optional[builtins.bool] = None,
                 last_execution_time: builtins.str,
                 retention_period_in_days: Optional[builtins.int] = None,
                 start_time: Optional[builtins.str] = None):
        """
        Description of a backup schedule. Describes how often should be the backup performed and what should be the retention policy.
        :param builtins.int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        :param builtins.str frequency_unit: The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        :param builtins.bool keep_at_least_one_backup: True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        :param builtins.str last_execution_time: Last time when this schedule was triggered.
        :param builtins.int retention_period_in_days: After how many days backups should be deleted.
        :param builtins.str start_time: When the schedule should start working.
        """
        if frequency_interval is None:
            frequency_interval = 7
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        if frequency_unit is None:
            frequency_unit = 'Day'
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is None:
            keep_at_least_one_backup = True
        pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        pulumi.set(__self__, "last_execution_time", last_execution_time)
        if retention_period_in_days is None:
            retention_period_in_days = 30
        pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> builtins.int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> builtins.str:
        """
        The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        """
        return pulumi.get(self, "frequency_unit")

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> builtins.bool:
        """
        True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> builtins.str:
        """
        Last time when this schedule was triggered.
        """
        return pulumi.get(self, "last_execution_time")

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> builtins.int:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_in_days")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[builtins.str]:
        """
        When the schedule should start working.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class BlobStorageTokenStoreResponse(dict):
    """
    The configuration settings of the storage of the tokens if blob storage is used.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sasUrlSettingName":
            suggest = "sas_url_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BlobStorageTokenStoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BlobStorageTokenStoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BlobStorageTokenStoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sas_url_setting_name: Optional[builtins.str] = None):
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        :param builtins.str sas_url_setting_name: The name of the app setting containing the SAS URL of the blob storage containing the tokens.
        """
        if sas_url_setting_name is not None:
            pulumi.set(__self__, "sas_url_setting_name", sas_url_setting_name)

    @property
    @pulumi.getter(name="sasUrlSettingName")
    def sas_url_setting_name(self) -> Optional[builtins.str]:
        """
        The name of the app setting containing the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "sas_url_setting_name")


@pulumi.output_type
class CapabilityResponse(dict):
    """
    Describes the capabilities/features allowed for a specific SKU.
    """
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 reason: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        Describes the capabilities/features allowed for a specific SKU.
        :param builtins.str name: Name of the SKU capability.
        :param builtins.str reason: Reason of the SKU capability.
        :param builtins.str value: Value of the SKU capability.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the SKU capability.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        Reason of the SKU capability.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value of the SKU capability.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClientRegistrationResponse(dict):
    """
    The configuration settings of the app registration for providers that have client ids and client secrets
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[builtins.str] = None,
                 client_secret_setting_name: Optional[builtins.str] = None):
        """
        The configuration settings of the app registration for providers that have client ids and client secrets
        :param builtins.str client_id: The Client ID of the app used for login.
        :param builtins.str client_secret_setting_name: The app setting name that contains the client secret.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[builtins.str]:
        """
        The app setting name that contains the client secret.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class ConnStringInfoResponse(dict):
    """
    Database connection string information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnStringInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnStringInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnStringInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        Database connection string information.
        :param builtins.str connection_string: Connection string value.
        :param builtins.str name: Name of connection string.
        :param builtins.str type: Type of database.
        """
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[builtins.str]:
        """
        Connection string value.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of connection string.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of database.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ConnStringValueTypePairResponse(dict):
    """
    Database connection string value to type pair.
    """
    def __init__(__self__, *,
                 type: builtins.str,
                 value: builtins.str):
        """
        Database connection string value to type pair.
        :param builtins.str type: Type of database.
        :param builtins.str value: Value of pair.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of database.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        Value of pair.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ConnectionErrorResponse(dict):
    """
    Connection error
    """
    def __init__(__self__, *,
                 id: builtins.str,
                 name: builtins.str,
                 type: builtins.str,
                 code: Optional[builtins.str] = None,
                 etag: Optional[builtins.str] = None,
                 location: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None):
        """
        Connection error
        :param builtins.str id: Resource id
        :param builtins.str name: Resource name
        :param builtins.str type: Resource type
        :param builtins.str code: Code of the status
        :param builtins.str etag: Resource ETag
        :param builtins.str location: Resource location
        :param builtins.str message: Description of the status
        :param Mapping[str, builtins.str] tags: Resource tags
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Resource id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Resource name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def code(self) -> Optional[builtins.str]:
        """
        Code of the status
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def etag(self) -> Optional[builtins.str]:
        """
        Resource ETag
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def location(self) -> Optional[builtins.str]:
        """
        Resource location
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Description of the status
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Resource tags
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ConnectionGatewayDefinitionResponseProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendUri":
            suggest = "backend_uri"
        elif key == "connectionGatewayInstallation":
            suggest = "connection_gateway_installation"
        elif key == "contactInformation":
            suggest = "contact_information"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "machineName":
            suggest = "machine_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionGatewayDefinitionResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionGatewayDefinitionResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionGatewayDefinitionResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_uri: Optional[builtins.str] = None,
                 connection_gateway_installation: Optional['outputs.ConnectionGatewayReferenceResponse'] = None,
                 contact_information: Optional[Sequence[builtins.str]] = None,
                 description: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 machine_name: Optional[builtins.str] = None,
                 status: Optional[Any] = None):
        """
        :param builtins.str backend_uri: The URI of the backend
        :param 'ConnectionGatewayReferenceResponse' connection_gateway_installation: The gateway installation reference
        :param Sequence[builtins.str] contact_information: The gateway admin
        :param builtins.str description: The gateway description
        :param builtins.str display_name: The gateway display name
        :param builtins.str machine_name: The machine name of the gateway
        :param Any status: The gateway status
        """
        if backend_uri is not None:
            pulumi.set(__self__, "backend_uri", backend_uri)
        if connection_gateway_installation is not None:
            pulumi.set(__self__, "connection_gateway_installation", connection_gateway_installation)
        if contact_information is not None:
            pulumi.set(__self__, "contact_information", contact_information)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if machine_name is not None:
            pulumi.set(__self__, "machine_name", machine_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="backendUri")
    def backend_uri(self) -> Optional[builtins.str]:
        """
        The URI of the backend
        """
        return pulumi.get(self, "backend_uri")

    @property
    @pulumi.getter(name="connectionGatewayInstallation")
    def connection_gateway_installation(self) -> Optional['outputs.ConnectionGatewayReferenceResponse']:
        """
        The gateway installation reference
        """
        return pulumi.get(self, "connection_gateway_installation")

    @property
    @pulumi.getter(name="contactInformation")
    def contact_information(self) -> Optional[Sequence[builtins.str]]:
        """
        The gateway admin
        """
        return pulumi.get(self, "contact_information")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The gateway description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        The gateway display name
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="machineName")
    def machine_name(self) -> Optional[builtins.str]:
        """
        The machine name of the gateway
        """
        return pulumi.get(self, "machine_name")

    @property
    @pulumi.getter
    def status(self) -> Optional[Any]:
        """
        The gateway status
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ConnectionGatewayReferenceResponse(dict):
    """
    The gateway installation reference
    """
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None,
                 location: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        The gateway installation reference
        :param builtins.str id: Resource reference id
        :param builtins.str location: Resource reference location
        :param builtins.str name: Resource reference name
        :param builtins.str type: Resource reference type
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Resource reference id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Optional[builtins.str]:
        """
        Resource reference location
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Resource reference name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Resource reference type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ConnectionParameterResponse(dict):
    """
    Connection provider parameters
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oAuthSettings":
            suggest = "o_auth_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionParameterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionParameterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionParameterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 o_auth_settings: Optional['outputs.ApiOAuthSettingsResponse'] = None,
                 type: Optional[builtins.str] = None):
        """
        Connection provider parameters
        :param 'ApiOAuthSettingsResponse' o_auth_settings: OAuth settings for the connection provider
        :param builtins.str type: Type of the parameter
        """
        if o_auth_settings is not None:
            pulumi.set(__self__, "o_auth_settings", o_auth_settings)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="oAuthSettings")
    def o_auth_settings(self) -> Optional['outputs.ApiOAuthSettingsResponse']:
        """
        OAuth settings for the connection provider
        """
        return pulumi.get(self, "o_auth_settings")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the parameter
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ConnectionStatusDefinitionResponse(dict):
    """
    Connection status
    """
    def __init__(__self__, *,
                 error: Optional['outputs.ConnectionErrorResponse'] = None,
                 status: Optional[builtins.str] = None,
                 target: Optional[builtins.str] = None):
        """
        Connection status
        :param 'ConnectionErrorResponse' error: Connection error
        :param builtins.str status: The gateway status
        :param builtins.str target: Target of the error
        """
        if error is not None:
            pulumi.set(__self__, "error", error)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.ConnectionErrorResponse']:
        """
        Connection error
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        The gateway status
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        """
        Target of the error
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ConsentLinkDefinitionResponse(dict):
    """
    A consent link
    """
    def __init__(__self__, *,
                 display_name: Optional[builtins.str] = None,
                 first_party_login_uri: Optional[builtins.str] = None,
                 link: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None):
        """
        A consent link
        :param builtins.str display_name: Display name of the parameter in the connection provider's OAuth settings
        :param builtins.str first_party_login_uri: URI for first party login
        :param builtins.str link: URI for the consent link
        :param builtins.str status: Status of the link
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if first_party_login_uri is not None:
            pulumi.set(__self__, "first_party_login_uri", first_party_login_uri)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        Display name of the parameter in the connection provider's OAuth settings
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="firstPartyLoginUri")
    def first_party_login_uri(self) -> Optional[builtins.str]:
        """
        URI for first party login
        """
        return pulumi.get(self, "first_party_login_uri")

    @property
    @pulumi.getter
    def link(self) -> Optional[builtins.str]:
        """
        URI for the consent link
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Status of the link
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ContainerAppsConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appSubnetResourceId":
            suggest = "app_subnet_resource_id"
        elif key == "controlPlaneSubnetResourceId":
            suggest = "control_plane_subnet_resource_id"
        elif key == "daprAIInstrumentationKey":
            suggest = "dapr_ai_instrumentation_key"
        elif key == "dockerBridgeCidr":
            suggest = "docker_bridge_cidr"
        elif key == "platformReservedCidr":
            suggest = "platform_reserved_cidr"
        elif key == "platformReservedDnsIP":
            suggest = "platform_reserved_dns_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerAppsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerAppsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerAppsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_subnet_resource_id: Optional[builtins.str] = None,
                 control_plane_subnet_resource_id: Optional[builtins.str] = None,
                 dapr_ai_instrumentation_key: Optional[builtins.str] = None,
                 docker_bridge_cidr: Optional[builtins.str] = None,
                 platform_reserved_cidr: Optional[builtins.str] = None,
                 platform_reserved_dns_ip: Optional[builtins.str] = None):
        """
        :param builtins.str app_subnet_resource_id: Resource ID of a subnet for control plane infrastructure components. This subnet must be in the same VNET as the subnet defined in appSubnetResourceId. Must not overlap with the IP range defined in platformReservedCidr, if defined.
        :param builtins.str control_plane_subnet_resource_id: Resource ID of a subnet for control plane infrastructure components. This subnet must be in the same VNET as the subnet defined in appSubnetResourceId. Must not overlap with the IP range defined in platformReservedCidr, if defined.
        :param builtins.str dapr_ai_instrumentation_key: Azure Monitor instrumentation key used by Dapr to export Service to Service communication telemetry
        :param builtins.str docker_bridge_cidr: CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the IP range defined in platformReservedCidr, if defined.
        :param builtins.str platform_reserved_cidr: IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. It must not overlap with any other Subnet IP ranges.
        :param builtins.str platform_reserved_dns_ip: An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server
        """
        if app_subnet_resource_id is not None:
            pulumi.set(__self__, "app_subnet_resource_id", app_subnet_resource_id)
        if control_plane_subnet_resource_id is not None:
            pulumi.set(__self__, "control_plane_subnet_resource_id", control_plane_subnet_resource_id)
        if dapr_ai_instrumentation_key is not None:
            pulumi.set(__self__, "dapr_ai_instrumentation_key", dapr_ai_instrumentation_key)
        if docker_bridge_cidr is not None:
            pulumi.set(__self__, "docker_bridge_cidr", docker_bridge_cidr)
        if platform_reserved_cidr is not None:
            pulumi.set(__self__, "platform_reserved_cidr", platform_reserved_cidr)
        if platform_reserved_dns_ip is not None:
            pulumi.set(__self__, "platform_reserved_dns_ip", platform_reserved_dns_ip)

    @property
    @pulumi.getter(name="appSubnetResourceId")
    def app_subnet_resource_id(self) -> Optional[builtins.str]:
        """
        Resource ID of a subnet for control plane infrastructure components. This subnet must be in the same VNET as the subnet defined in appSubnetResourceId. Must not overlap with the IP range defined in platformReservedCidr, if defined.
        """
        return pulumi.get(self, "app_subnet_resource_id")

    @property
    @pulumi.getter(name="controlPlaneSubnetResourceId")
    def control_plane_subnet_resource_id(self) -> Optional[builtins.str]:
        """
        Resource ID of a subnet for control plane infrastructure components. This subnet must be in the same VNET as the subnet defined in appSubnetResourceId. Must not overlap with the IP range defined in platformReservedCidr, if defined.
        """
        return pulumi.get(self, "control_plane_subnet_resource_id")

    @property
    @pulumi.getter(name="daprAIInstrumentationKey")
    def dapr_ai_instrumentation_key(self) -> Optional[builtins.str]:
        """
        Azure Monitor instrumentation key used by Dapr to export Service to Service communication telemetry
        """
        return pulumi.get(self, "dapr_ai_instrumentation_key")

    @property
    @pulumi.getter(name="dockerBridgeCidr")
    def docker_bridge_cidr(self) -> Optional[builtins.str]:
        """
        CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the IP range defined in platformReservedCidr, if defined.
        """
        return pulumi.get(self, "docker_bridge_cidr")

    @property
    @pulumi.getter(name="platformReservedCidr")
    def platform_reserved_cidr(self) -> Optional[builtins.str]:
        """
        IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. It must not overlap with any other Subnet IP ranges.
        """
        return pulumi.get(self, "platform_reserved_cidr")

    @property
    @pulumi.getter(name="platformReservedDnsIP")
    def platform_reserved_dns_ip(self) -> Optional[builtins.str]:
        """
        An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server
        """
        return pulumi.get(self, "platform_reserved_dns_ip")


@pulumi.output_type
class CookieExpirationResponse(dict):
    """
    The configuration settings of the session cookie's expiration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeToExpiration":
            suggest = "time_to_expiration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CookieExpirationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CookieExpirationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CookieExpirationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 convention: Optional[builtins.str] = None,
                 time_to_expiration: Optional[builtins.str] = None):
        """
        The configuration settings of the session cookie's expiration.
        :param builtins.str convention: The convention used when determining the session cookie's expiration.
        :param builtins.str time_to_expiration: The time after the request is made when the session cookie should expire.
        """
        if convention is not None:
            pulumi.set(__self__, "convention", convention)
        if time_to_expiration is not None:
            pulumi.set(__self__, "time_to_expiration", time_to_expiration)

    @property
    @pulumi.getter
    def convention(self) -> Optional[builtins.str]:
        """
        The convention used when determining the session cookie's expiration.
        """
        return pulumi.get(self, "convention")

    @property
    @pulumi.getter(name="timeToExpiration")
    def time_to_expiration(self) -> Optional[builtins.str]:
        """
        The time after the request is made when the session cookie should expire.
        """
        return pulumi.get(self, "time_to_expiration")


@pulumi.output_type
class CorsSettingsResponse(dict):
    """
    Cross-Origin Resource Sharing (CORS) settings for the app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CorsSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CorsSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CorsSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Optional[Sequence[builtins.str]] = None,
                 support_credentials: Optional[builtins.bool] = None):
        """
        Cross-Origin Resource Sharing (CORS) settings for the app.
        :param Sequence[builtins.str] allowed_origins: Gets or sets the list of origins that should be allowed to make cross-origin
               calls (for example: http://example.com:12345). Use "*" to allow all.
        :param builtins.bool support_credentials: Gets or sets whether CORS requests with credentials are allowed. See 
               https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
               for more details.
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[builtins.str]]:
        """
        Gets or sets the list of origins that should be allowed to make cross-origin
        calls (for example: http://example.com:12345). Use "*" to allow all.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[builtins.bool]:
        """
        Gets or sets whether CORS requests with credentials are allowed. See 
        https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
        for more details.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class CustomApiPropertiesDefinitionResponse(dict):
    """
    Custom API properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiDefinitions":
            suggest = "api_definitions"
        elif key == "apiType":
            suggest = "api_type"
        elif key == "backendService":
            suggest = "backend_service"
        elif key == "brandColor":
            suggest = "brand_color"
        elif key == "connectionParameters":
            suggest = "connection_parameters"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "iconUri":
            suggest = "icon_uri"
        elif key == "runtimeUrls":
            suggest = "runtime_urls"
        elif key == "wsdlDefinition":
            suggest = "wsdl_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomApiPropertiesDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomApiPropertiesDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomApiPropertiesDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_definitions: Optional['outputs.ApiResourceDefinitionsResponse'] = None,
                 api_type: Optional[builtins.str] = None,
                 backend_service: Optional['outputs.ApiResourceBackendServiceResponse'] = None,
                 brand_color: Optional[builtins.str] = None,
                 capabilities: Optional[Sequence[builtins.str]] = None,
                 connection_parameters: Optional[Mapping[str, 'outputs.ConnectionParameterResponse']] = None,
                 description: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 icon_uri: Optional[builtins.str] = None,
                 runtime_urls: Optional[Sequence[builtins.str]] = None,
                 swagger: Optional[Any] = None,
                 wsdl_definition: Optional['outputs.WsdlDefinitionResponse'] = None):
        """
        Custom API properties
        :param 'ApiResourceDefinitionsResponse' api_definitions: API Definitions
        :param builtins.str api_type: The API type
        :param 'ApiResourceBackendServiceResponse' backend_service: The API backend service
        :param builtins.str brand_color: Brand color
        :param Sequence[builtins.str] capabilities: The custom API capabilities
        :param Mapping[str, 'ConnectionParameterResponse'] connection_parameters: Connection parameters
        :param builtins.str description: The custom API description
        :param builtins.str display_name: The display name
        :param builtins.str icon_uri: The icon URI
        :param Sequence[builtins.str] runtime_urls: Runtime URLs
        :param Any swagger: The JSON representation of the swagger
        :param 'WsdlDefinitionResponse' wsdl_definition: The WSDL definition
        """
        if api_definitions is not None:
            pulumi.set(__self__, "api_definitions", api_definitions)
        if api_type is not None:
            pulumi.set(__self__, "api_type", api_type)
        if backend_service is not None:
            pulumi.set(__self__, "backend_service", backend_service)
        if brand_color is not None:
            pulumi.set(__self__, "brand_color", brand_color)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if connection_parameters is not None:
            pulumi.set(__self__, "connection_parameters", connection_parameters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if icon_uri is not None:
            pulumi.set(__self__, "icon_uri", icon_uri)
        if runtime_urls is not None:
            pulumi.set(__self__, "runtime_urls", runtime_urls)
        if swagger is not None:
            pulumi.set(__self__, "swagger", swagger)
        if wsdl_definition is not None:
            pulumi.set(__self__, "wsdl_definition", wsdl_definition)

    @property
    @pulumi.getter(name="apiDefinitions")
    def api_definitions(self) -> Optional['outputs.ApiResourceDefinitionsResponse']:
        """
        API Definitions
        """
        return pulumi.get(self, "api_definitions")

    @property
    @pulumi.getter(name="apiType")
    def api_type(self) -> Optional[builtins.str]:
        """
        The API type
        """
        return pulumi.get(self, "api_type")

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> Optional['outputs.ApiResourceBackendServiceResponse']:
        """
        The API backend service
        """
        return pulumi.get(self, "backend_service")

    @property
    @pulumi.getter(name="brandColor")
    def brand_color(self) -> Optional[builtins.str]:
        """
        Brand color
        """
        return pulumi.get(self, "brand_color")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence[builtins.str]]:
        """
        The custom API capabilities
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter(name="connectionParameters")
    def connection_parameters(self) -> Optional[Mapping[str, 'outputs.ConnectionParameterResponse']]:
        """
        Connection parameters
        """
        return pulumi.get(self, "connection_parameters")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        The custom API description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        The display name
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="iconUri")
    def icon_uri(self) -> Optional[builtins.str]:
        """
        The icon URI
        """
        return pulumi.get(self, "icon_uri")

    @property
    @pulumi.getter(name="runtimeUrls")
    def runtime_urls(self) -> Optional[Sequence[builtins.str]]:
        """
        Runtime URLs
        """
        return pulumi.get(self, "runtime_urls")

    @property
    @pulumi.getter
    def swagger(self) -> Optional[Any]:
        """
        The JSON representation of the swagger
        """
        return pulumi.get(self, "swagger")

    @property
    @pulumi.getter(name="wsdlDefinition")
    def wsdl_definition(self) -> Optional['outputs.WsdlDefinitionResponse']:
        """
        The WSDL definition
        """
        return pulumi.get(self, "wsdl_definition")


@pulumi.output_type
class CustomDnsSuffixConfigurationResponse(dict):
    """
    Full view of the custom domain suffix configuration for ASEv3.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningDetails":
            suggest = "provisioning_details"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "certificateUrl":
            suggest = "certificate_url"
        elif key == "dnsSuffix":
            suggest = "dns_suffix"
        elif key == "keyVaultReferenceIdentity":
            suggest = "key_vault_reference_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDnsSuffixConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDnsSuffixConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDnsSuffixConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 name: builtins.str,
                 provisioning_details: builtins.str,
                 provisioning_state: builtins.str,
                 type: builtins.str,
                 certificate_url: Optional[builtins.str] = None,
                 dns_suffix: Optional[builtins.str] = None,
                 key_vault_reference_identity: Optional[builtins.str] = None,
                 kind: Optional[builtins.str] = None):
        """
        Full view of the custom domain suffix configuration for ASEv3.
        :param builtins.str id: Resource Id.
        :param builtins.str name: Resource Name.
        :param builtins.str type: Resource type.
        :param builtins.str certificate_url: The URL referencing the Azure Key Vault certificate secret that should be used as the default SSL/TLS certificate for sites with the custom domain suffix.
        :param builtins.str dns_suffix: The default custom domain suffix to use for all sites deployed on the ASE.
        :param builtins.str key_vault_reference_identity: The user-assigned identity to use for resolving the key vault certificate reference. If not specified, the system-assigned ASE identity will be used if available.
        :param builtins.str kind: Kind of resource.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provisioning_details", provisioning_details)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", type)
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)
        if dns_suffix is not None:
            pulumi.set(__self__, "dns_suffix", dns_suffix)
        if key_vault_reference_identity is not None:
            pulumi.set(__self__, "key_vault_reference_identity", key_vault_reference_identity)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningDetails")
    def provisioning_details(self) -> builtins.str:
        return pulumi.get(self, "provisioning_details")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[builtins.str]:
        """
        The URL referencing the Azure Key Vault certificate secret that should be used as the default SSL/TLS certificate for sites with the custom domain suffix.
        """
        return pulumi.get(self, "certificate_url")

    @property
    @pulumi.getter(name="dnsSuffix")
    def dns_suffix(self) -> Optional[builtins.str]:
        """
        The default custom domain suffix to use for all sites deployed on the ASE.
        """
        return pulumi.get(self, "dns_suffix")

    @property
    @pulumi.getter(name="keyVaultReferenceIdentity")
    def key_vault_reference_identity(self) -> Optional[builtins.str]:
        """
        The user-assigned identity to use for resolving the key vault certificate reference. If not specified, the system-assigned ASE identity will be used if available.
        """
        return pulumi.get(self, "key_vault_reference_identity")

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class CustomOpenIdConnectProviderResponse(dict):
    """
    The configuration settings of the custom Open ID Connect provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 login: Optional['outputs.OpenIdConnectLoginResponse'] = None,
                 registration: Optional['outputs.OpenIdConnectRegistrationResponse'] = None):
        """
        The configuration settings of the custom Open ID Connect provider.
        :param builtins.bool enabled: <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        :param 'OpenIdConnectLoginResponse' login: The configuration settings of the login flow of the custom Open ID Connect provider.
        :param 'OpenIdConnectRegistrationResponse' registration: The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.OpenIdConnectLoginResponse']:
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.OpenIdConnectRegistrationResponse']:
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class DaprConfigResponse(dict):
    """
    App Dapr configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appPort":
            suggest = "app_port"
        elif key == "enableApiLogging":
            suggest = "enable_api_logging"
        elif key == "httpMaxRequestSize":
            suggest = "http_max_request_size"
        elif key == "httpReadBufferSize":
            suggest = "http_read_buffer_size"
        elif key == "logLevel":
            suggest = "log_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DaprConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DaprConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DaprConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[builtins.str] = None,
                 app_port: Optional[builtins.int] = None,
                 enable_api_logging: Optional[builtins.bool] = None,
                 enabled: Optional[builtins.bool] = None,
                 http_max_request_size: Optional[builtins.int] = None,
                 http_read_buffer_size: Optional[builtins.int] = None,
                 log_level: Optional[builtins.str] = None):
        """
        App Dapr configuration.
        :param builtins.str app_id: Dapr application identifier
        :param builtins.int app_port: Tells Dapr which port your application is listening on
        :param builtins.bool enable_api_logging: Enables API logging for the Dapr sidecar
        :param builtins.bool enabled: Boolean indicating if the Dapr side car is enabled
        :param builtins.int http_max_request_size: Increasing max size of request body http servers parameter in MB to handle uploading of big files. Default is 4 MB.
        :param builtins.int http_read_buffer_size: Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        :param builtins.str log_level: Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_port is not None:
            pulumi.set(__self__, "app_port", app_port)
        if enable_api_logging is not None:
            pulumi.set(__self__, "enable_api_logging", enable_api_logging)
        if enabled is None:
            enabled = False
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if http_max_request_size is not None:
            pulumi.set(__self__, "http_max_request_size", http_max_request_size)
        if http_read_buffer_size is not None:
            pulumi.set(__self__, "http_read_buffer_size", http_read_buffer_size)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[builtins.str]:
        """
        Dapr application identifier
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appPort")
    def app_port(self) -> Optional[builtins.int]:
        """
        Tells Dapr which port your application is listening on
        """
        return pulumi.get(self, "app_port")

    @property
    @pulumi.getter(name="enableApiLogging")
    def enable_api_logging(self) -> Optional[builtins.bool]:
        """
        Enables API logging for the Dapr sidecar
        """
        return pulumi.get(self, "enable_api_logging")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Boolean indicating if the Dapr side car is enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="httpMaxRequestSize")
    def http_max_request_size(self) -> Optional[builtins.int]:
        """
        Increasing max size of request body http servers parameter in MB to handle uploading of big files. Default is 4 MB.
        """
        return pulumi.get(self, "http_max_request_size")

    @property
    @pulumi.getter(name="httpReadBufferSize")
    def http_read_buffer_size(self) -> Optional[builtins.int]:
        """
        Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        """
        return pulumi.get(self, "http_read_buffer_size")

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[builtins.str]:
        """
        Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        """
        return pulumi.get(self, "log_level")


@pulumi.output_type
class DatabaseBackupSettingResponse(dict):
    """
    Database backup settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseType":
            suggest = "database_type"
        elif key == "connectionString":
            suggest = "connection_string"
        elif key == "connectionStringName":
            suggest = "connection_string_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseBackupSettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseBackupSettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseBackupSettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_type: builtins.str,
                 connection_string: Optional[builtins.str] = None,
                 connection_string_name: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        """
        Database backup settings.
        :param builtins.str database_type: Database type (e.g. SqlAzure / MySql).
        :param builtins.str connection_string: Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        :param builtins.str connection_string_name: Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
               This is used during restore with overwrite connection strings options.
        """
        pulumi.set(__self__, "database_type", database_type)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if connection_string_name is not None:
            pulumi.set(__self__, "connection_string_name", connection_string_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> builtins.str:
        """
        Database type (e.g. SqlAzure / MySql).
        """
        return pulumi.get(self, "database_type")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[builtins.str]:
        """
        Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter(name="connectionStringName")
    def connection_string_name(self) -> Optional[builtins.str]:
        """
        Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
        This is used during restore with overwrite connection strings options.
        """
        return pulumi.get(self, "connection_string_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class DatabaseConnectionOverviewResponse(dict):
    """
    Static Site Database Connection overview.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationFiles":
            suggest = "configuration_files"
        elif key == "connectionIdentity":
            suggest = "connection_identity"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseConnectionOverviewResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseConnectionOverviewResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseConnectionOverviewResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_files: Sequence['outputs.StaticSiteDatabaseConnectionConfigurationFileOverviewResponse'],
                 connection_identity: builtins.str,
                 name: builtins.str,
                 region: builtins.str,
                 resource_id: builtins.str):
        """
        Static Site Database Connection overview.
        :param Sequence['StaticSiteDatabaseConnectionConfigurationFileOverviewResponse'] configuration_files: A list of configuration files associated with this database connection.
        :param builtins.str connection_identity: If present, the identity is used in conjunction with connection string to connect to the database. Use of the system-assigned managed identity is indicated with the string 'SystemAssigned', while use of a user-assigned managed identity is indicated with the resource id of the managed identity resource.
        :param builtins.str name: If present, the name of this database connection resource.
        :param builtins.str region: The region of the database resource.
        :param builtins.str resource_id: The resource id of the database.
        """
        pulumi.set(__self__, "configuration_files", configuration_files)
        pulumi.set(__self__, "connection_identity", connection_identity)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="configurationFiles")
    def configuration_files(self) -> Sequence['outputs.StaticSiteDatabaseConnectionConfigurationFileOverviewResponse']:
        """
        A list of configuration files associated with this database connection.
        """
        return pulumi.get(self, "configuration_files")

    @property
    @pulumi.getter(name="connectionIdentity")
    def connection_identity(self) -> builtins.str:
        """
        If present, the identity is used in conjunction with connection string to connect to the database. Use of the system-assigned managed identity is indicated with the string 'SystemAssigned', while use of a user-assigned managed identity is indicated with the resource id of the managed identity resource.
        """
        return pulumi.get(self, "connection_identity")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        If present, the name of this database connection resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> builtins.str:
        """
        The region of the database resource.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> builtins.str:
        """
        The resource id of the database.
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class DefaultAuthorizationPolicyResponse(dict):
    """
    The configuration settings of the Azure Active Directory default authorization policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedApplications":
            suggest = "allowed_applications"
        elif key == "allowedPrincipals":
            suggest = "allowed_principals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultAuthorizationPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultAuthorizationPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultAuthorizationPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_applications: Optional[Sequence[builtins.str]] = None,
                 allowed_principals: Optional['outputs.AllowedPrincipalsResponse'] = None):
        """
        The configuration settings of the Azure Active Directory default authorization policy.
        :param Sequence[builtins.str] allowed_applications: The configuration settings of the Azure Active Directory allowed applications.
        :param 'AllowedPrincipalsResponse' allowed_principals: The configuration settings of the Azure Active Directory allowed principals.
        """
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_principals is not None:
            pulumi.set(__self__, "allowed_principals", allowed_principals)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[Sequence[builtins.str]]:
        """
        The configuration settings of the Azure Active Directory allowed applications.
        """
        return pulumi.get(self, "allowed_applications")

    @property
    @pulumi.getter(name="allowedPrincipals")
    def allowed_principals(self) -> Optional['outputs.AllowedPrincipalsResponse']:
        """
        The configuration settings of the Azure Active Directory allowed principals.
        """
        return pulumi.get(self, "allowed_principals")


@pulumi.output_type
class EnabledConfigResponse(dict):
    """
    Enabled configuration.
    """
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None):
        """
        Enabled configuration.
        :param builtins.bool enabled: True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class EnvironmentVariableResponse(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str name: Environment variable name
        :param builtins.str value: Environment variable value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Environment variable name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        Environment variable value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ErrorEntityResponse(dict):
    """
    Body of the error response returned from the API.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extendedCode":
            suggest = "extended_code"
        elif key == "innerErrors":
            suggest = "inner_errors"
        elif key == "messageTemplate":
            suggest = "message_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ErrorEntityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ErrorEntityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ErrorEntityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional[builtins.str] = None,
                 details: Optional[Sequence['outputs.ErrorEntityResponse']] = None,
                 extended_code: Optional[builtins.str] = None,
                 inner_errors: Optional[Sequence['outputs.ErrorEntityResponse']] = None,
                 message: Optional[builtins.str] = None,
                 message_template: Optional[builtins.str] = None,
                 parameters: Optional[Sequence[builtins.str]] = None,
                 target: Optional[builtins.str] = None):
        """
        Body of the error response returned from the API.
        :param builtins.str code: Basic error code.
        :param Sequence['ErrorEntityResponse'] details: Error Details.
        :param builtins.str extended_code: Type of error.
        :param Sequence['ErrorEntityResponse'] inner_errors: Inner errors.
        :param builtins.str message: Any details of the error.
        :param builtins.str message_template: Message template.
        :param Sequence[builtins.str] parameters: Parameters for the template.
        :param builtins.str target: The error target.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if extended_code is not None:
            pulumi.set(__self__, "extended_code", extended_code)
        if inner_errors is not None:
            pulumi.set(__self__, "inner_errors", inner_errors)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_template is not None:
            pulumi.set(__self__, "message_template", message_template)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def code(self) -> Optional[builtins.str]:
        """
        Basic error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.ErrorEntityResponse']]:
        """
        Error Details.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter(name="extendedCode")
    def extended_code(self) -> Optional[builtins.str]:
        """
        Type of error.
        """
        return pulumi.get(self, "extended_code")

    @property
    @pulumi.getter(name="innerErrors")
    def inner_errors(self) -> Optional[Sequence['outputs.ErrorEntityResponse']]:
        """
        Inner errors.
        """
        return pulumi.get(self, "inner_errors")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Any details of the error.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="messageTemplate")
    def message_template(self) -> Optional[builtins.str]:
        """
        Message template.
        """
        return pulumi.get(self, "message_template")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[builtins.str]]:
        """
        Parameters for the template.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def target(self) -> Optional[builtins.str]:
        """
        The error target.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ExperimentsResponse(dict):
    """
    Routing rules in production experiments.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rampUpRules":
            suggest = "ramp_up_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExperimentsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExperimentsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExperimentsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ramp_up_rules: Optional[Sequence['outputs.RampUpRuleResponse']] = None):
        """
        Routing rules in production experiments.
        :param Sequence['RampUpRuleResponse'] ramp_up_rules: List of ramp-up rules.
        """
        if ramp_up_rules is not None:
            pulumi.set(__self__, "ramp_up_rules", ramp_up_rules)

    @property
    @pulumi.getter(name="rampUpRules")
    def ramp_up_rules(self) -> Optional[Sequence['outputs.RampUpRuleResponse']]:
        """
        List of ramp-up rules.
        """
        return pulumi.get(self, "ramp_up_rules")


@pulumi.output_type
class ExpressionResponse(dict):
    """
    The expression.
    """
    def __init__(__self__, *,
                 error: Optional['outputs.AzureResourceErrorInfoResponse'] = None,
                 subexpressions: Optional[Sequence['outputs.ExpressionResponse']] = None,
                 text: Optional[builtins.str] = None,
                 value: Optional[Any] = None):
        """
        The expression.
        :param 'AzureResourceErrorInfoResponse' error: The azure resource error info.
        :param Sequence['ExpressionResponse'] subexpressions: The sub expressions.
        :param builtins.str text: The text.
        """
        if error is not None:
            pulumi.set(__self__, "error", error)
        if subexpressions is not None:
            pulumi.set(__self__, "subexpressions", subexpressions)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.AzureResourceErrorInfoResponse']:
        """
        The azure resource error info.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def subexpressions(self) -> Optional[Sequence['outputs.ExpressionResponse']]:
        """
        The sub expressions.
        """
        return pulumi.get(self, "subexpressions")

    @property
    @pulumi.getter
    def text(self) -> Optional[builtins.str]:
        """
        The text.
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def value(self) -> Optional[Any]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ExpressionRootResponse(dict):
    """
    The expression root.
    """
    def __init__(__self__, *,
                 error: Optional['outputs.AzureResourceErrorInfoResponse'] = None,
                 path: Optional[builtins.str] = None,
                 subexpressions: Optional[Sequence['outputs.ExpressionResponse']] = None,
                 text: Optional[builtins.str] = None,
                 value: Optional[Any] = None):
        """
        The expression root.
        :param 'AzureResourceErrorInfoResponse' error: The azure resource error info.
        :param builtins.str path: The path.
        :param Sequence['ExpressionResponse'] subexpressions: The sub expressions.
        :param builtins.str text: The text.
        """
        if error is not None:
            pulumi.set(__self__, "error", error)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if subexpressions is not None:
            pulumi.set(__self__, "subexpressions", subexpressions)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.AzureResourceErrorInfoResponse']:
        """
        The azure resource error info.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        The path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def subexpressions(self) -> Optional[Sequence['outputs.ExpressionResponse']]:
        """
        The sub expressions.
        """
        return pulumi.get(self, "subexpressions")

    @property
    @pulumi.getter
    def text(self) -> Optional[builtins.str]:
        """
        The text.
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def value(self) -> Optional[Any]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ExtendedLocationResponse(dict):
    """
    Extended Location.
    """
    def __init__(__self__, *,
                 type: builtins.str,
                 name: Optional[builtins.str] = None):
        """
        Extended Location.
        :param builtins.str type: Type of extended location.
        :param builtins.str name: Name of extended location.
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of extended location.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of extended location.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FacebookResponse(dict):
    """
    The configuration settings of the Facebook provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "graphApiVersion":
            suggest = "graph_api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FacebookResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FacebookResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FacebookResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 graph_api_version: Optional[builtins.str] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.AppRegistrationResponse'] = None):
        """
        The configuration settings of the Facebook provider.
        :param builtins.bool enabled: <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param builtins.str graph_api_version: The version of the Facebook api to be used while logging in.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'AppRegistrationResponse' registration: The configuration settings of the app registration for the Facebook provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[builtins.str]:
        """
        The version of the Facebook api to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.AppRegistrationResponse']:
        """
        The configuration settings of the app registration for the Facebook provider.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class FileSystemApplicationLogsConfigResponse(dict):
    """
    Application logs to file system configuration.
    """
    def __init__(__self__, *,
                 level: Optional[builtins.str] = None):
        """
        Application logs to file system configuration.
        :param builtins.str level: Log level.
        """
        if level is None:
            level = 'Off'
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def level(self) -> Optional[builtins.str]:
        """
        Log level.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class FileSystemHttpLogsConfigResponse(dict):
    """
    Http logs to file system configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionInDays":
            suggest = "retention_in_days"
        elif key == "retentionInMb":
            suggest = "retention_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemHttpLogsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemHttpLogsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemHttpLogsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 retention_in_days: Optional[builtins.int] = None,
                 retention_in_mb: Optional[builtins.int] = None):
        """
        Http logs to file system configuration.
        :param builtins.bool enabled: True if configuration is enabled, false if it is disabled and null if configuration is not set.
        :param builtins.int retention_in_days: Retention in days.
               Remove files older than X days.
               0 or lower means no retention.
        :param builtins.int retention_in_mb: Maximum size in megabytes that http log files can use.
               When reached old log files will be removed to make space for new ones.
               Value can range between 25 and 100.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if retention_in_mb is not None:
            pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[builtins.int]:
        """
        Retention in days.
        Remove files older than X days.
        0 or lower means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> Optional[builtins.int]:
        """
        Maximum size in megabytes that http log files can use.
        When reached old log files will be removed to make space for new ones.
        Value can range between 25 and 100.
        """
        return pulumi.get(self, "retention_in_mb")


@pulumi.output_type
class FileSystemTokenStoreResponse(dict):
    """
    The configuration settings of the storage of the tokens if a file system is used.
    """
    def __init__(__self__, *,
                 directory: Optional[builtins.str] = None):
        """
        The configuration settings of the storage of the tokens if a file system is used.
        :param builtins.str directory: The directory in which the tokens will be stored.
        """
        if directory is not None:
            pulumi.set(__self__, "directory", directory)

    @property
    @pulumi.getter
    def directory(self) -> Optional[builtins.str]:
        """
        The directory in which the tokens will be stored.
        """
        return pulumi.get(self, "directory")


@pulumi.output_type
class ForwardProxyResponse(dict):
    """
    The configuration settings of a forward proxy used to make the requests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHostHeaderName":
            suggest = "custom_host_header_name"
        elif key == "customProtoHeaderName":
            suggest = "custom_proto_header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ForwardProxyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ForwardProxyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ForwardProxyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 convention: Optional[builtins.str] = None,
                 custom_host_header_name: Optional[builtins.str] = None,
                 custom_proto_header_name: Optional[builtins.str] = None):
        """
        The configuration settings of a forward proxy used to make the requests.
        :param builtins.str convention: The convention used to determine the url of the request made.
        :param builtins.str custom_host_header_name: The name of the header containing the host of the request.
        :param builtins.str custom_proto_header_name: The name of the header containing the scheme of the request.
        """
        if convention is not None:
            pulumi.set(__self__, "convention", convention)
        if custom_host_header_name is not None:
            pulumi.set(__self__, "custom_host_header_name", custom_host_header_name)
        if custom_proto_header_name is not None:
            pulumi.set(__self__, "custom_proto_header_name", custom_proto_header_name)

    @property
    @pulumi.getter
    def convention(self) -> Optional[builtins.str]:
        """
        The convention used to determine the url of the request made.
        """
        return pulumi.get(self, "convention")

    @property
    @pulumi.getter(name="customHostHeaderName")
    def custom_host_header_name(self) -> Optional[builtins.str]:
        """
        The name of the header containing the host of the request.
        """
        return pulumi.get(self, "custom_host_header_name")

    @property
    @pulumi.getter(name="customProtoHeaderName")
    def custom_proto_header_name(self) -> Optional[builtins.str]:
        """
        The name of the header containing the scheme of the request.
        """
        return pulumi.get(self, "custom_proto_header_name")


@pulumi.output_type
class FrontEndConfigurationResponse(dict):
    def __init__(__self__, *,
                 kind: Optional[builtins.str] = None):
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        return pulumi.get(self, "kind")


@pulumi.output_type
class FunctionAppConfigResponse(dict):
    """
    Function app configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleAndConcurrency":
            suggest = "scale_and_concurrency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionAppConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionAppConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionAppConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment: Optional['outputs.FunctionsDeploymentResponse'] = None,
                 runtime: Optional['outputs.FunctionsRuntimeResponse'] = None,
                 scale_and_concurrency: Optional['outputs.FunctionsScaleAndConcurrencyResponse'] = None):
        """
        Function app configuration.
        :param 'FunctionsDeploymentResponse' deployment: Function app deployment configuration.
        :param 'FunctionsRuntimeResponse' runtime: Function app runtime settings.
        :param 'FunctionsScaleAndConcurrencyResponse' scale_and_concurrency: Function app scale and concurrency settings.
        """
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)
        if scale_and_concurrency is not None:
            pulumi.set(__self__, "scale_and_concurrency", scale_and_concurrency)

    @property
    @pulumi.getter
    def deployment(self) -> Optional['outputs.FunctionsDeploymentResponse']:
        """
        Function app deployment configuration.
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter
    def runtime(self) -> Optional['outputs.FunctionsRuntimeResponse']:
        """
        Function app runtime settings.
        """
        return pulumi.get(self, "runtime")

    @property
    @pulumi.getter(name="scaleAndConcurrency")
    def scale_and_concurrency(self) -> Optional['outputs.FunctionsScaleAndConcurrencyResponse']:
        """
        Function app scale and concurrency settings.
        """
        return pulumi.get(self, "scale_and_concurrency")


@pulumi.output_type
class FunctionsAlwaysReadyConfigResponse(dict):
    """
    Sets the number of 'Always Ready' instances for a function group or a specific function.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceCount":
            suggest = "instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionsAlwaysReadyConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionsAlwaysReadyConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionsAlwaysReadyConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_count: Optional[builtins.int] = None,
                 name: Optional[builtins.str] = None):
        """
        Sets the number of 'Always Ready' instances for a function group or a specific function.
        :param builtins.int instance_count: Sets the number of 'Always Ready' instances for a given function group or a specific function. For additional information see https://aka.ms/flexconsumption/alwaysready.
        :param builtins.str name: Either a function group or a function name is required. For additional information see https://aka.ms/flexconsumption/alwaysready.
        """
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[builtins.int]:
        """
        Sets the number of 'Always Ready' instances for a given function group or a specific function. For additional information see https://aka.ms/flexconsumption/alwaysready.
        """
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Either a function group or a function name is required. For additional information see https://aka.ms/flexconsumption/alwaysready.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FunctionsDeploymentResponse(dict):
    """
    Configuration section for the function app deployment.
    """
    def __init__(__self__, *,
                 storage: Optional['outputs.FunctionsDeploymentResponseStorage'] = None):
        """
        Configuration section for the function app deployment.
        :param 'FunctionsDeploymentResponseStorage' storage: Storage for deployed package used by the function app.
        """
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def storage(self) -> Optional['outputs.FunctionsDeploymentResponseStorage']:
        """
        Storage for deployed package used by the function app.
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class FunctionsDeploymentResponseAuthentication(dict):
    """
    Authentication method to access the storage account for deployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccountConnectionStringName":
            suggest = "storage_account_connection_string_name"
        elif key == "userAssignedIdentityResourceId":
            suggest = "user_assigned_identity_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionsDeploymentResponseAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionsDeploymentResponseAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionsDeploymentResponseAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_account_connection_string_name: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None,
                 user_assigned_identity_resource_id: Optional[builtins.str] = None):
        """
        Authentication method to access the storage account for deployment.
        :param builtins.str storage_account_connection_string_name: Use this property for StorageAccountConnectionString. Set the name of the app setting that has the storage account connection string. Do not set a value for this property when using other authentication type.
        :param builtins.str type: Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity, UserAssignedIdentity, StorageAccountConnectionString.
        :param builtins.str user_assigned_identity_resource_id: Use this property for UserAssignedIdentity. Set the resource ID of the identity. Do not set a value for this property when using other authentication type.
        """
        if storage_account_connection_string_name is not None:
            pulumi.set(__self__, "storage_account_connection_string_name", storage_account_connection_string_name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identity_resource_id is not None:
            pulumi.set(__self__, "user_assigned_identity_resource_id", user_assigned_identity_resource_id)

    @property
    @pulumi.getter(name="storageAccountConnectionStringName")
    def storage_account_connection_string_name(self) -> Optional[builtins.str]:
        """
        Use this property for StorageAccountConnectionString. Set the name of the app setting that has the storage account connection string. Do not set a value for this property when using other authentication type.
        """
        return pulumi.get(self, "storage_account_connection_string_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity, UserAssignedIdentity, StorageAccountConnectionString.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentityResourceId")
    def user_assigned_identity_resource_id(self) -> Optional[builtins.str]:
        """
        Use this property for UserAssignedIdentity. Set the resource ID of the identity. Do not set a value for this property when using other authentication type.
        """
        return pulumi.get(self, "user_assigned_identity_resource_id")


@pulumi.output_type
class FunctionsDeploymentResponseStorage(dict):
    """
    Storage for deployed package used by the function app.
    """
    def __init__(__self__, *,
                 authentication: Optional['outputs.FunctionsDeploymentResponseAuthentication'] = None,
                 type: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        Storage for deployed package used by the function app.
        :param 'FunctionsDeploymentResponseAuthentication' authentication: Authentication method to access the storage account for deployment.
        :param builtins.str type: Property to select Azure Storage type. Available options: blobContainer.
        :param builtins.str value: Property to set the URL for the selected Azure Storage type. Example: For blobContainer, the value could be https://<storageAccountName>.blob.core.windows.net/<containerName>.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.FunctionsDeploymentResponseAuthentication']:
        """
        Authentication method to access the storage account for deployment.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Property to select Azure Storage type. Available options: blobContainer.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Property to set the URL for the selected Azure Storage type. Example: For blobContainer, the value could be https://<storageAccountName>.blob.core.windows.net/<containerName>.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FunctionsRuntimeResponse(dict):
    """
    Function app runtime name and version.
    """
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        Function app runtime name and version.
        :param builtins.str name: Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom
        :param builtins.str version: Function app runtime version. Example: 8 (for dotnet-isolated)
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Function app runtime version. Example: 8 (for dotnet-isolated)
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class FunctionsScaleAndConcurrencyResponse(dict):
    """
    Scale and concurrency settings for the function app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysReady":
            suggest = "always_ready"
        elif key == "instanceMemoryMB":
            suggest = "instance_memory_mb"
        elif key == "maximumInstanceCount":
            suggest = "maximum_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionsScaleAndConcurrencyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionsScaleAndConcurrencyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionsScaleAndConcurrencyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_ready: Optional[Sequence['outputs.FunctionsAlwaysReadyConfigResponse']] = None,
                 instance_memory_mb: Optional[builtins.int] = None,
                 maximum_instance_count: Optional[builtins.int] = None,
                 triggers: Optional['outputs.FunctionsScaleAndConcurrencyResponseTriggers'] = None):
        """
        Scale and concurrency settings for the function app.
        :param Sequence['FunctionsAlwaysReadyConfigResponse'] always_ready: 'Always Ready' configuration for the function app.
        :param builtins.int instance_memory_mb: Set the amount of memory allocated to each instance of the function app in MB. CPU and network bandwidth are allocated proportionally.
        :param builtins.int maximum_instance_count: The maximum number of instances for the function app.
        :param 'FunctionsScaleAndConcurrencyResponseTriggers' triggers: Scale and concurrency settings for the function app triggers.
        """
        if always_ready is not None:
            pulumi.set(__self__, "always_ready", always_ready)
        if instance_memory_mb is not None:
            pulumi.set(__self__, "instance_memory_mb", instance_memory_mb)
        if maximum_instance_count is not None:
            pulumi.set(__self__, "maximum_instance_count", maximum_instance_count)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter(name="alwaysReady")
    def always_ready(self) -> Optional[Sequence['outputs.FunctionsAlwaysReadyConfigResponse']]:
        """
        'Always Ready' configuration for the function app.
        """
        return pulumi.get(self, "always_ready")

    @property
    @pulumi.getter(name="instanceMemoryMB")
    def instance_memory_mb(self) -> Optional[builtins.int]:
        """
        Set the amount of memory allocated to each instance of the function app in MB. CPU and network bandwidth are allocated proportionally.
        """
        return pulumi.get(self, "instance_memory_mb")

    @property
    @pulumi.getter(name="maximumInstanceCount")
    def maximum_instance_count(self) -> Optional[builtins.int]:
        """
        The maximum number of instances for the function app.
        """
        return pulumi.get(self, "maximum_instance_count")

    @property
    @pulumi.getter
    def triggers(self) -> Optional['outputs.FunctionsScaleAndConcurrencyResponseTriggers']:
        """
        Scale and concurrency settings for the function app triggers.
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class FunctionsScaleAndConcurrencyResponseHttp(dict):
    """
    Scale and concurrency settings for the HTTP trigger.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perInstanceConcurrency":
            suggest = "per_instance_concurrency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionsScaleAndConcurrencyResponseHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionsScaleAndConcurrencyResponseHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionsScaleAndConcurrencyResponseHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 per_instance_concurrency: Optional[builtins.int] = None):
        """
        Scale and concurrency settings for the HTTP trigger.
        :param builtins.int per_instance_concurrency: The maximum number of concurrent HTTP trigger invocations per instance.
        """
        if per_instance_concurrency is not None:
            pulumi.set(__self__, "per_instance_concurrency", per_instance_concurrency)

    @property
    @pulumi.getter(name="perInstanceConcurrency")
    def per_instance_concurrency(self) -> Optional[builtins.int]:
        """
        The maximum number of concurrent HTTP trigger invocations per instance.
        """
        return pulumi.get(self, "per_instance_concurrency")


@pulumi.output_type
class FunctionsScaleAndConcurrencyResponseTriggers(dict):
    """
    Scale and concurrency settings for the function app triggers.
    """
    def __init__(__self__, *,
                 http: Optional['outputs.FunctionsScaleAndConcurrencyResponseHttp'] = None):
        """
        Scale and concurrency settings for the function app triggers.
        :param 'FunctionsScaleAndConcurrencyResponseHttp' http: Scale and concurrency settings for the HTTP trigger.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.FunctionsScaleAndConcurrencyResponseHttp']:
        """
        Scale and concurrency settings for the HTTP trigger.
        """
        return pulumi.get(self, "http")


@pulumi.output_type
class GitHubActionCodeConfigurationResponse(dict):
    """
    The GitHub action code configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runtimeStack":
            suggest = "runtime_stack"
        elif key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitHubActionCodeConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitHubActionCodeConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitHubActionCodeConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 runtime_stack: Optional[builtins.str] = None,
                 runtime_version: Optional[builtins.str] = None):
        """
        The GitHub action code configuration.
        :param builtins.str runtime_stack: Runtime stack is used to determine the workflow file content for code base apps.
        :param builtins.str runtime_version: Runtime version is used to determine what build version to set in the workflow file.
        """
        if runtime_stack is not None:
            pulumi.set(__self__, "runtime_stack", runtime_stack)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="runtimeStack")
    def runtime_stack(self) -> Optional[builtins.str]:
        """
        Runtime stack is used to determine the workflow file content for code base apps.
        """
        return pulumi.get(self, "runtime_stack")

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[builtins.str]:
        """
        Runtime version is used to determine what build version to set in the workflow file.
        """
        return pulumi.get(self, "runtime_version")


@pulumi.output_type
class GitHubActionConfigurationResponse(dict):
    """
    The GitHub action configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codeConfiguration":
            suggest = "code_configuration"
        elif key == "containerConfiguration":
            suggest = "container_configuration"
        elif key == "generateWorkflowFile":
            suggest = "generate_workflow_file"
        elif key == "isLinux":
            suggest = "is_linux"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitHubActionConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitHubActionConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitHubActionConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code_configuration: Optional['outputs.GitHubActionCodeConfigurationResponse'] = None,
                 container_configuration: Optional['outputs.GitHubActionContainerConfigurationResponse'] = None,
                 generate_workflow_file: Optional[builtins.bool] = None,
                 is_linux: Optional[builtins.bool] = None):
        """
        The GitHub action configuration.
        :param 'GitHubActionCodeConfigurationResponse' code_configuration: GitHub Action code configuration.
        :param 'GitHubActionContainerConfigurationResponse' container_configuration: GitHub Action container configuration.
        :param builtins.bool generate_workflow_file: Workflow option to determine whether the workflow file should be generated and written to the repository.
        :param builtins.bool is_linux: This will help determine the workflow configuration to select.
        """
        if code_configuration is not None:
            pulumi.set(__self__, "code_configuration", code_configuration)
        if container_configuration is not None:
            pulumi.set(__self__, "container_configuration", container_configuration)
        if generate_workflow_file is not None:
            pulumi.set(__self__, "generate_workflow_file", generate_workflow_file)
        if is_linux is not None:
            pulumi.set(__self__, "is_linux", is_linux)

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional['outputs.GitHubActionCodeConfigurationResponse']:
        """
        GitHub Action code configuration.
        """
        return pulumi.get(self, "code_configuration")

    @property
    @pulumi.getter(name="containerConfiguration")
    def container_configuration(self) -> Optional['outputs.GitHubActionContainerConfigurationResponse']:
        """
        GitHub Action container configuration.
        """
        return pulumi.get(self, "container_configuration")

    @property
    @pulumi.getter(name="generateWorkflowFile")
    def generate_workflow_file(self) -> Optional[builtins.bool]:
        """
        Workflow option to determine whether the workflow file should be generated and written to the repository.
        """
        return pulumi.get(self, "generate_workflow_file")

    @property
    @pulumi.getter(name="isLinux")
    def is_linux(self) -> Optional[builtins.bool]:
        """
        This will help determine the workflow configuration to select.
        """
        return pulumi.get(self, "is_linux")


@pulumi.output_type
class GitHubActionContainerConfigurationResponse(dict):
    """
    The GitHub action container configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageName":
            suggest = "image_name"
        elif key == "serverUrl":
            suggest = "server_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitHubActionContainerConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitHubActionContainerConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitHubActionContainerConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_name: Optional[builtins.str] = None,
                 password: Optional[builtins.str] = None,
                 server_url: Optional[builtins.str] = None,
                 username: Optional[builtins.str] = None):
        """
        The GitHub action container configuration.
        :param builtins.str image_name: The image name for the build.
        :param builtins.str password: The password used to upload the image to the container registry.
        :param builtins.str server_url: The server URL for the container registry where the build will be hosted.
        :param builtins.str username: The username used to upload the image to the container registry.
        """
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> Optional[builtins.str]:
        """
        The image name for the build.
        """
        return pulumi.get(self, "image_name")

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        """
        The password used to upload the image to the container registry.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[builtins.str]:
        """
        The server URL for the container registry where the build will be hosted.
        """
        return pulumi.get(self, "server_url")

    @property
    @pulumi.getter
    def username(self) -> Optional[builtins.str]:
        """
        The username used to upload the image to the container registry.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GitHubResponse(dict):
    """
    The configuration settings of the GitHub provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.ClientRegistrationResponse'] = None):
        """
        The configuration settings of the GitHub provider.
        :param builtins.bool enabled: <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'ClientRegistrationResponse' registration: The configuration settings of the app registration for the GitHub provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.ClientRegistrationResponse']:
        """
        The configuration settings of the app registration for the GitHub provider.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class GlobalValidationResponse(dict):
    """
    The configuration settings that determines the validation flow of users using App Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedPaths":
            suggest = "excluded_paths"
        elif key == "redirectToProvider":
            suggest = "redirect_to_provider"
        elif key == "requireAuthentication":
            suggest = "require_authentication"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalValidationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalValidationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalValidationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 excluded_paths: Optional[Sequence[builtins.str]] = None,
                 redirect_to_provider: Optional[builtins.str] = None,
                 require_authentication: Optional[builtins.bool] = None,
                 unauthenticated_client_action: Optional[builtins.str] = None):
        """
        The configuration settings that determines the validation flow of users using App Service Authentication/Authorization.
        :param Sequence[builtins.str] excluded_paths: The paths for which unauthenticated flow would not be redirected to the login page.
        :param builtins.str redirect_to_provider: The default authentication provider to use when multiple providers are configured.
               This setting is only needed if multiple providers are configured and the unauthenticated client
               action is set to "RedirectToLoginPage".
        :param builtins.bool require_authentication: <code>true</code> if the authentication flow is required any request is made; otherwise, <code>false</code>.
        :param builtins.str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app.
        """
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if redirect_to_provider is not None:
            pulumi.set(__self__, "redirect_to_provider", redirect_to_provider)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[builtins.str]]:
        """
        The paths for which unauthenticated flow would not be redirected to the login page.
        """
        return pulumi.get(self, "excluded_paths")

    @property
    @pulumi.getter(name="redirectToProvider")
    def redirect_to_provider(self) -> Optional[builtins.str]:
        """
        The default authentication provider to use when multiple providers are configured.
        This setting is only needed if multiple providers are configured and the unauthenticated client
        action is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "redirect_to_provider")

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[builtins.bool]:
        """
        <code>true</code> if the authentication flow is required any request is made; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "require_authentication")

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[builtins.str]:
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class GoogleResponse(dict):
    """
    The configuration settings of the Google provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.ClientRegistrationResponse'] = None,
                 validation: Optional['outputs.AllowedAudiencesValidationResponse'] = None):
        """
        The configuration settings of the Google provider.
        :param builtins.bool enabled: <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'ClientRegistrationResponse' registration: The configuration settings of the app registration for the Google provider.
        :param 'AllowedAudiencesValidationResponse' validation: The configuration settings of the Azure Active Directory token validation flow.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.ClientRegistrationResponse']:
        """
        The configuration settings of the app registration for the Google provider.
        """
        return pulumi.get(self, "registration")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.AllowedAudiencesValidationResponse']:
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class HandlerMappingResponse(dict):
    """
    The IIS handler mappings used to define which handler processes HTTP requests with certain extension. 
    For example, it is used to configure php-cgi.exe process to handle all HTTP requests with *.php extension.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scriptProcessor":
            suggest = "script_processor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HandlerMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HandlerMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HandlerMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arguments: Optional[builtins.str] = None,
                 extension: Optional[builtins.str] = None,
                 script_processor: Optional[builtins.str] = None):
        """
        The IIS handler mappings used to define which handler processes HTTP requests with certain extension. 
        For example, it is used to configure php-cgi.exe process to handle all HTTP requests with *.php extension.
        :param builtins.str arguments: Command-line arguments to be passed to the script processor.
        :param builtins.str extension: Requests with this extension will be handled using the specified FastCGI application.
        :param builtins.str script_processor: The absolute path to the FastCGI application.
        """
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if extension is not None:
            pulumi.set(__self__, "extension", extension)
        if script_processor is not None:
            pulumi.set(__self__, "script_processor", script_processor)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[builtins.str]:
        """
        Command-line arguments to be passed to the script processor.
        """
        return pulumi.get(self, "arguments")

    @property
    @pulumi.getter
    def extension(self) -> Optional[builtins.str]:
        """
        Requests with this extension will be handled using the specified FastCGI application.
        """
        return pulumi.get(self, "extension")

    @property
    @pulumi.getter(name="scriptProcessor")
    def script_processor(self) -> Optional[builtins.str]:
        """
        The absolute path to the FastCGI application.
        """
        return pulumi.get(self, "script_processor")


@pulumi.output_type
class HostNameSslStateResponse(dict):
    """
    SSL-enabled hostname.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostType":
            suggest = "host_type"
        elif key == "sslState":
            suggest = "ssl_state"
        elif key == "toUpdate":
            suggest = "to_update"
        elif key == "virtualIP":
            suggest = "virtual_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNameSslStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNameSslStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNameSslStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_type: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 ssl_state: Optional[builtins.str] = None,
                 thumbprint: Optional[builtins.str] = None,
                 to_update: Optional[builtins.bool] = None,
                 virtual_ip: Optional[builtins.str] = None):
        """
        SSL-enabled hostname.
        :param builtins.str host_type: Indicates whether the hostname is a standard or repository hostname.
        :param builtins.str name: Hostname.
        :param builtins.str ssl_state: SSL type.
        :param builtins.str thumbprint: SSL certificate thumbprint.
        :param builtins.bool to_update: Set to <code>true</code> to update existing hostname.
        :param builtins.str virtual_ip: Virtual IP address assigned to the hostname if IP based SSL is enabled.
        """
        if host_type is not None:
            pulumi.set(__self__, "host_type", host_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ssl_state is not None:
            pulumi.set(__self__, "ssl_state", ssl_state)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if to_update is not None:
            pulumi.set(__self__, "to_update", to_update)
        if virtual_ip is not None:
            pulumi.set(__self__, "virtual_ip", virtual_ip)

    @property
    @pulumi.getter(name="hostType")
    def host_type(self) -> Optional[builtins.str]:
        """
        Indicates whether the hostname is a standard or repository hostname.
        """
        return pulumi.get(self, "host_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Hostname.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sslState")
    def ssl_state(self) -> Optional[builtins.str]:
        """
        SSL type.
        """
        return pulumi.get(self, "ssl_state")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[builtins.str]:
        """
        SSL certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="toUpdate")
    def to_update(self) -> Optional[builtins.bool]:
        """
        Set to <code>true</code> to update existing hostname.
        """
        return pulumi.get(self, "to_update")

    @property
    @pulumi.getter(name="virtualIP")
    def virtual_ip(self) -> Optional[builtins.str]:
        """
        Virtual IP address assigned to the hostname if IP based SSL is enabled.
        """
        return pulumi.get(self, "virtual_ip")


@pulumi.output_type
class HostingEnvironmentProfileResponse(dict):
    """
    Specification for an App Service Environment to use for this resource.
    """
    def __init__(__self__, *,
                 name: builtins.str,
                 type: builtins.str,
                 id: Optional[builtins.str] = None):
        """
        Specification for an App Service Environment to use for this resource.
        :param builtins.str name: Name of the App Service Environment.
        :param builtins.str type: Resource type of the App Service Environment.
        :param builtins.str id: Resource ID of the App Service Environment.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the App Service Environment.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type of the App Service Environment.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Resource ID of the App Service Environment.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class HttpLogsConfigResponse(dict):
    """
    Http logs configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpLogsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpLogsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpLogsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.AzureBlobStorageHttpLogsConfigResponse'] = None,
                 file_system: Optional['outputs.FileSystemHttpLogsConfigResponse'] = None):
        """
        Http logs configuration.
        :param 'AzureBlobStorageHttpLogsConfigResponse' azure_blob_storage: Http logs to azure blob storage configuration.
        :param 'FileSystemHttpLogsConfigResponse' file_system: Http logs to file system configuration.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.AzureBlobStorageHttpLogsConfigResponse']:
        """
        Http logs to azure blob storage configuration.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.FileSystemHttpLogsConfigResponse']:
        """
        Http logs to file system configuration.
        """
        return pulumi.get(self, "file_system")


@pulumi.output_type
class HttpSettingsResponse(dict):
    """
    The configuration settings of the HTTP requests for authentication and authorization requests made against App Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardProxy":
            suggest = "forward_proxy"
        elif key == "requireHttps":
            suggest = "require_https"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forward_proxy: Optional['outputs.ForwardProxyResponse'] = None,
                 require_https: Optional[builtins.bool] = None,
                 routes: Optional['outputs.HttpSettingsRoutesResponse'] = None):
        """
        The configuration settings of the HTTP requests for authentication and authorization requests made against App Service Authentication/Authorization.
        :param 'ForwardProxyResponse' forward_proxy: The configuration settings of a forward proxy used to make the requests.
        :param builtins.bool require_https: <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        :param 'HttpSettingsRoutesResponse' routes: The configuration settings of the paths HTTP requests.
        """
        if forward_proxy is not None:
            pulumi.set(__self__, "forward_proxy", forward_proxy)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @property
    @pulumi.getter(name="forwardProxy")
    def forward_proxy(self) -> Optional['outputs.ForwardProxyResponse']:
        """
        The configuration settings of a forward proxy used to make the requests.
        """
        return pulumi.get(self, "forward_proxy")

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[builtins.bool]:
        """
        <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "require_https")

    @property
    @pulumi.getter
    def routes(self) -> Optional['outputs.HttpSettingsRoutesResponse']:
        """
        The configuration settings of the paths HTTP requests.
        """
        return pulumi.get(self, "routes")


@pulumi.output_type
class HttpSettingsRoutesResponse(dict):
    """
    The configuration settings of the paths HTTP requests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiPrefix":
            suggest = "api_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpSettingsRoutesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpSettingsRoutesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpSettingsRoutesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_prefix: Optional[builtins.str] = None):
        """
        The configuration settings of the paths HTTP requests.
        :param builtins.str api_prefix: The prefix that should precede all the authentication/authorization paths.
        """
        if api_prefix is not None:
            pulumi.set(__self__, "api_prefix", api_prefix)

    @property
    @pulumi.getter(name="apiPrefix")
    def api_prefix(self) -> Optional[builtins.str]:
        """
        The prefix that should precede all the authentication/authorization paths.
        """
        return pulumi.get(self, "api_prefix")


@pulumi.output_type
class IdentifierResponse(dict):
    """
    A domain specific resource identifier.
    """
    def __init__(__self__, *,
                 id: builtins.str,
                 name: builtins.str,
                 type: builtins.str,
                 kind: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        A domain specific resource identifier.
        :param builtins.str id: Resource Id.
        :param builtins.str name: Resource Name.
        :param builtins.str type: Resource type.
        :param builtins.str kind: Kind of resource.
        :param builtins.str value: String representation of the identity.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        String representation of the identity.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IdentityProvidersResponse(dict):
    """
    The configuration settings of each of the identity providers used to configure App Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureActiveDirectory":
            suggest = "azure_active_directory"
        elif key == "azureStaticWebApps":
            suggest = "azure_static_web_apps"
        elif key == "customOpenIdConnectProviders":
            suggest = "custom_open_id_connect_providers"
        elif key == "gitHub":
            suggest = "git_hub"
        elif key == "legacyMicrosoftAccount":
            suggest = "legacy_microsoft_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityProvidersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityProvidersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityProvidersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apple: Optional['outputs.AppleResponse'] = None,
                 azure_active_directory: Optional['outputs.AzureActiveDirectoryResponse'] = None,
                 azure_static_web_apps: Optional['outputs.AzureStaticWebAppsResponse'] = None,
                 custom_open_id_connect_providers: Optional[Mapping[str, 'outputs.CustomOpenIdConnectProviderResponse']] = None,
                 facebook: Optional['outputs.FacebookResponse'] = None,
                 git_hub: Optional['outputs.GitHubResponse'] = None,
                 google: Optional['outputs.GoogleResponse'] = None,
                 legacy_microsoft_account: Optional['outputs.LegacyMicrosoftAccountResponse'] = None,
                 twitter: Optional['outputs.TwitterResponse'] = None):
        """
        The configuration settings of each of the identity providers used to configure App Service Authentication/Authorization.
        :param 'AppleResponse' apple: The configuration settings of the Apple provider.
        :param 'AzureActiveDirectoryResponse' azure_active_directory: The configuration settings of the Azure Active directory provider.
        :param 'AzureStaticWebAppsResponse' azure_static_web_apps: The configuration settings of the Azure Static Web Apps provider.
        :param Mapping[str, 'CustomOpenIdConnectProviderResponse'] custom_open_id_connect_providers: The map of the name of the alias of each custom Open ID Connect provider to the
               configuration settings of the custom Open ID Connect provider.
        :param 'FacebookResponse' facebook: The configuration settings of the Facebook provider.
        :param 'GitHubResponse' git_hub: The configuration settings of the GitHub provider.
        :param 'GoogleResponse' google: The configuration settings of the Google provider.
        :param 'LegacyMicrosoftAccountResponse' legacy_microsoft_account: The configuration settings of the legacy Microsoft Account provider.
        :param 'TwitterResponse' twitter: The configuration settings of the Twitter provider.
        """
        if apple is not None:
            pulumi.set(__self__, "apple", apple)
        if azure_active_directory is not None:
            pulumi.set(__self__, "azure_active_directory", azure_active_directory)
        if azure_static_web_apps is not None:
            pulumi.set(__self__, "azure_static_web_apps", azure_static_web_apps)
        if custom_open_id_connect_providers is not None:
            pulumi.set(__self__, "custom_open_id_connect_providers", custom_open_id_connect_providers)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if git_hub is not None:
            pulumi.set(__self__, "git_hub", git_hub)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if legacy_microsoft_account is not None:
            pulumi.set(__self__, "legacy_microsoft_account", legacy_microsoft_account)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)

    @property
    @pulumi.getter
    def apple(self) -> Optional['outputs.AppleResponse']:
        """
        The configuration settings of the Apple provider.
        """
        return pulumi.get(self, "apple")

    @property
    @pulumi.getter(name="azureActiveDirectory")
    def azure_active_directory(self) -> Optional['outputs.AzureActiveDirectoryResponse']:
        """
        The configuration settings of the Azure Active directory provider.
        """
        return pulumi.get(self, "azure_active_directory")

    @property
    @pulumi.getter(name="azureStaticWebApps")
    def azure_static_web_apps(self) -> Optional['outputs.AzureStaticWebAppsResponse']:
        """
        The configuration settings of the Azure Static Web Apps provider.
        """
        return pulumi.get(self, "azure_static_web_apps")

    @property
    @pulumi.getter(name="customOpenIdConnectProviders")
    def custom_open_id_connect_providers(self) -> Optional[Mapping[str, 'outputs.CustomOpenIdConnectProviderResponse']]:
        """
        The map of the name of the alias of each custom Open ID Connect provider to the
        configuration settings of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "custom_open_id_connect_providers")

    @property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.FacebookResponse']:
        """
        The configuration settings of the Facebook provider.
        """
        return pulumi.get(self, "facebook")

    @property
    @pulumi.getter(name="gitHub")
    def git_hub(self) -> Optional['outputs.GitHubResponse']:
        """
        The configuration settings of the GitHub provider.
        """
        return pulumi.get(self, "git_hub")

    @property
    @pulumi.getter
    def google(self) -> Optional['outputs.GoogleResponse']:
        """
        The configuration settings of the Google provider.
        """
        return pulumi.get(self, "google")

    @property
    @pulumi.getter(name="legacyMicrosoftAccount")
    def legacy_microsoft_account(self) -> Optional['outputs.LegacyMicrosoftAccountResponse']:
        """
        The configuration settings of the legacy Microsoft Account provider.
        """
        return pulumi.get(self, "legacy_microsoft_account")

    @property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.TwitterResponse']:
        """
        The configuration settings of the Twitter provider.
        """
        return pulumi.get(self, "twitter")


@pulumi.output_type
class IpSecurityRestrictionResponse(dict):
    """
    IP security restriction on an app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "subnetMask":
            suggest = "subnet_mask"
        elif key == "subnetTrafficTag":
            suggest = "subnet_traffic_tag"
        elif key == "vnetSubnetResourceId":
            suggest = "vnet_subnet_resource_id"
        elif key == "vnetTrafficTag":
            suggest = "vnet_traffic_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpSecurityRestrictionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpSecurityRestrictionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpSecurityRestrictionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 headers: Optional[Mapping[str, Sequence[builtins.str]]] = None,
                 ip_address: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 priority: Optional[builtins.int] = None,
                 subnet_mask: Optional[builtins.str] = None,
                 subnet_traffic_tag: Optional[builtins.int] = None,
                 tag: Optional[builtins.str] = None,
                 vnet_subnet_resource_id: Optional[builtins.str] = None,
                 vnet_traffic_tag: Optional[builtins.int] = None):
        """
        IP security restriction on an app.
        :param builtins.str action: Allow or Deny access for this IP range.
        :param builtins.str description: IP restriction rule description.
        :param Mapping[str, Sequence[builtins.str]] headers: IP restriction rule headers.
               X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples). 
               The matching logic is ..
               - If the property is null or empty (default), all hosts(or lack of) are allowed.
               - A value is compared using ordinal-ignore-case (excluding port number).
               - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain foo.contoso.com
                but not the root domain contoso.com or multi-level foo.bar.contoso.com
               - Unicode host names are allowed but are converted to Punycode for matching.
               
               X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
               The matching logic is ..
               - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
               - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.
               
               X-Azure-FDID and X-FD-HealthProbe.
               The matching logic is exact match.
        :param builtins.str ip_address: IP address the security restriction is valid for.
               It can be in form of pure ipv4 address (required SubnetMask property) or
               CIDR notation such as ipv4/mask (leading bit match). For CIDR,
               SubnetMask property must not be specified.
        :param builtins.str name: IP restriction rule name.
        :param builtins.int priority: Priority of IP restriction rule.
        :param builtins.str subnet_mask: Subnet mask for the range of IP addresses the restriction is valid for.
        :param builtins.int subnet_traffic_tag: (internal) Subnet traffic tag
        :param builtins.str tag: Defines what this IP filter will be used for. This is to support IP filtering on proxies.
        :param builtins.str vnet_subnet_resource_id: Virtual network resource id
        :param builtins.int vnet_traffic_tag: (internal) Vnet traffic tag
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)
        if subnet_traffic_tag is not None:
            pulumi.set(__self__, "subnet_traffic_tag", subnet_traffic_tag)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if vnet_subnet_resource_id is not None:
            pulumi.set(__self__, "vnet_subnet_resource_id", vnet_subnet_resource_id)
        if vnet_traffic_tag is not None:
            pulumi.set(__self__, "vnet_traffic_tag", vnet_traffic_tag)

    @property
    @pulumi.getter
    def action(self) -> Optional[builtins.str]:
        """
        Allow or Deny access for this IP range.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        IP restriction rule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, Sequence[builtins.str]]]:
        """
        IP restriction rule headers.
        X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples). 
        The matching logic is ..
        - If the property is null or empty (default), all hosts(or lack of) are allowed.
        - A value is compared using ordinal-ignore-case (excluding port number).
        - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain foo.contoso.com
         but not the root domain contoso.com or multi-level foo.bar.contoso.com
        - Unicode host names are allowed but are converted to Punycode for matching.

        X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
        The matching logic is ..
        - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
        - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.

        X-Azure-FDID and X-FD-HealthProbe.
        The matching logic is exact match.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[builtins.str]:
        """
        IP address the security restriction is valid for.
        It can be in form of pure ipv4 address (required SubnetMask property) or
        CIDR notation such as ipv4/mask (leading bit match). For CIDR,
        SubnetMask property must not be specified.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        IP restriction rule name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[builtins.int]:
        """
        Priority of IP restriction rule.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[builtins.str]:
        """
        Subnet mask for the range of IP addresses the restriction is valid for.
        """
        return pulumi.get(self, "subnet_mask")

    @property
    @pulumi.getter(name="subnetTrafficTag")
    def subnet_traffic_tag(self) -> Optional[builtins.int]:
        """
        (internal) Subnet traffic tag
        """
        return pulumi.get(self, "subnet_traffic_tag")

    @property
    @pulumi.getter
    def tag(self) -> Optional[builtins.str]:
        """
        Defines what this IP filter will be used for. This is to support IP filtering on proxies.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="vnetSubnetResourceId")
    def vnet_subnet_resource_id(self) -> Optional[builtins.str]:
        """
        Virtual network resource id
        """
        return pulumi.get(self, "vnet_subnet_resource_id")

    @property
    @pulumi.getter(name="vnetTrafficTag")
    def vnet_traffic_tag(self) -> Optional[builtins.int]:
        """
        (internal) Vnet traffic tag
        """
        return pulumi.get(self, "vnet_traffic_tag")


@pulumi.output_type
class JwtClaimChecksResponse(dict):
    """
    The configuration settings of the checks that should be made while validating the JWT Claims.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedClientApplications":
            suggest = "allowed_client_applications"
        elif key == "allowedGroups":
            suggest = "allowed_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JwtClaimChecksResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JwtClaimChecksResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JwtClaimChecksResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_client_applications: Optional[Sequence[builtins.str]] = None,
                 allowed_groups: Optional[Sequence[builtins.str]] = None):
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        :param Sequence[builtins.str] allowed_client_applications: The list of the allowed client applications.
        :param Sequence[builtins.str] allowed_groups: The list of the allowed groups.
        """
        if allowed_client_applications is not None:
            pulumi.set(__self__, "allowed_client_applications", allowed_client_applications)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)

    @property
    @pulumi.getter(name="allowedClientApplications")
    def allowed_client_applications(self) -> Optional[Sequence[builtins.str]]:
        """
        The list of the allowed client applications.
        """
        return pulumi.get(self, "allowed_client_applications")

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The list of the allowed groups.
        """
        return pulumi.get(self, "allowed_groups")


@pulumi.output_type
class KubeEnvironmentProfileResponse(dict):
    """
    Specification for a Kubernetes Environment to use for this resource.
    """
    def __init__(__self__, *,
                 name: builtins.str,
                 type: builtins.str,
                 id: Optional[builtins.str] = None):
        """
        Specification for a Kubernetes Environment to use for this resource.
        :param builtins.str name: Name of the Kubernetes Environment.
        :param builtins.str type: Resource type of the Kubernetes Environment.
        :param builtins.str id: Resource ID of the Kubernetes Environment.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the Kubernetes Environment.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type of the Kubernetes Environment.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Resource ID of the Kubernetes Environment.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class LegacyMicrosoftAccountResponse(dict):
    """
    The configuration settings of the legacy Microsoft Account provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.ClientRegistrationResponse'] = None,
                 validation: Optional['outputs.AllowedAudiencesValidationResponse'] = None):
        """
        The configuration settings of the legacy Microsoft Account provider.
        :param builtins.bool enabled: <code>false</code> if the legacy Microsoft Account provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'ClientRegistrationResponse' registration: The configuration settings of the app registration for the legacy Microsoft Account provider.
        :param 'AllowedAudiencesValidationResponse' validation: The configuration settings of the legacy Microsoft Account provider token validation flow.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        <code>false</code> if the legacy Microsoft Account provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.ClientRegistrationResponse']:
        """
        The configuration settings of the app registration for the legacy Microsoft Account provider.
        """
        return pulumi.get(self, "registration")

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.AllowedAudiencesValidationResponse']:
        """
        The configuration settings of the legacy Microsoft Account provider token validation flow.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class LogAnalyticsConfigurationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerId":
            suggest = "customer_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAnalyticsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAnalyticsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAnalyticsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_id: Optional[builtins.str] = None):
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "customer_id")


@pulumi.output_type
class LoginResponse(dict):
    """
    The configuration settings of the login flow of users using App Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "cookieExpiration":
            suggest = "cookie_expiration"
        elif key == "preserveUrlFragmentsForLogins":
            suggest = "preserve_url_fragments_for_logins"
        elif key == "tokenStore":
            suggest = "token_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoginResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoginResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoginResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[Sequence[builtins.str]] = None,
                 cookie_expiration: Optional['outputs.CookieExpirationResponse'] = None,
                 nonce: Optional['outputs.NonceResponse'] = None,
                 preserve_url_fragments_for_logins: Optional[builtins.bool] = None,
                 routes: Optional['outputs.LoginRoutesResponse'] = None,
                 token_store: Optional['outputs.TokenStoreResponse'] = None):
        """
        The configuration settings of the login flow of users using App Service Authentication/Authorization.
        :param Sequence[builtins.str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
               This is an advanced setting typically only needed by Windows Store application backends.
               Note that URLs within the current domain are always implicitly allowed.
        :param 'CookieExpirationResponse' cookie_expiration: The configuration settings of the session cookie's expiration.
        :param 'NonceResponse' nonce: The configuration settings of the nonce used in the login flow.
        :param builtins.bool preserve_url_fragments_for_logins: <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        :param 'LoginRoutesResponse' routes: The routes that specify the endpoints used for login and logout requests.
        :param 'TokenStoreResponse' token_store: The configuration settings of the token store.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration is not None:
            pulumi.set(__self__, "cookie_expiration", cookie_expiration)
        if nonce is not None:
            pulumi.set(__self__, "nonce", nonce)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if token_store is not None:
            pulumi.set(__self__, "token_store", token_store)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[builtins.str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
        This is an advanced setting typically only needed by Windows Store application backends.
        Note that URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @property
    @pulumi.getter(name="cookieExpiration")
    def cookie_expiration(self) -> Optional['outputs.CookieExpirationResponse']:
        """
        The configuration settings of the session cookie's expiration.
        """
        return pulumi.get(self, "cookie_expiration")

    @property
    @pulumi.getter
    def nonce(self) -> Optional['outputs.NonceResponse']:
        """
        The configuration settings of the nonce used in the login flow.
        """
        return pulumi.get(self, "nonce")

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[builtins.bool]:
        """
        <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @property
    @pulumi.getter
    def routes(self) -> Optional['outputs.LoginRoutesResponse']:
        """
        The routes that specify the endpoints used for login and logout requests.
        """
        return pulumi.get(self, "routes")

    @property
    @pulumi.getter(name="tokenStore")
    def token_store(self) -> Optional['outputs.TokenStoreResponse']:
        """
        The configuration settings of the token store.
        """
        return pulumi.get(self, "token_store")


@pulumi.output_type
class LoginRoutesResponse(dict):
    """
    The routes that specify the endpoints used for login and logout requests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logoutEndpoint":
            suggest = "logout_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoginRoutesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoginRoutesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoginRoutesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logout_endpoint: Optional[builtins.str] = None):
        """
        The routes that specify the endpoints used for login and logout requests.
        :param builtins.str logout_endpoint: The endpoint at which a logout request should be made.
        """
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[builtins.str]:
        """
        The endpoint at which a logout request should be made.
        """
        return pulumi.get(self, "logout_endpoint")


@pulumi.output_type
class LoginScopesResponse(dict):
    """
    The configuration settings of the login flow, including the scopes that should be requested.
    """
    def __init__(__self__, *,
                 scopes: Optional[Sequence[builtins.str]] = None):
        """
        The configuration settings of the login flow, including the scopes that should be requested.
        :param Sequence[builtins.str] scopes: A list of the scopes that should be requested while authenticating.
        """
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: builtins.str,
                 tenant_id: builtins.str,
                 type: Optional[builtins.str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity.
        :param builtins.str principal_id: Principal Id of managed service identity.
        :param builtins.str tenant_id: Tenant of managed service identity.
        :param builtins.str type: Type of managed service identity.
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        Principal Id of managed service identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        Tenant of managed service identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of managed service identity.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class NameValuePairResponse(dict):
    """
    Name value pair.
    """
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        Name value pair.
        :param builtins.str name: Pair name.
        :param builtins.str value: Pair value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Pair name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Pair value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NonceResponse(dict):
    """
    The configuration settings of the nonce used in the login flow.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nonceExpirationInterval":
            suggest = "nonce_expiration_interval"
        elif key == "validateNonce":
            suggest = "validate_nonce"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NonceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NonceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NonceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nonce_expiration_interval: Optional[builtins.str] = None,
                 validate_nonce: Optional[builtins.bool] = None):
        """
        The configuration settings of the nonce used in the login flow.
        :param builtins.str nonce_expiration_interval: The time after the request is made when the nonce should expire.
        :param builtins.bool validate_nonce: <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
        if nonce_expiration_interval is not None:
            pulumi.set(__self__, "nonce_expiration_interval", nonce_expiration_interval)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="nonceExpirationInterval")
    def nonce_expiration_interval(self) -> Optional[builtins.str]:
        """
        The time after the request is made when the nonce should expire.
        """
        return pulumi.get(self, "nonce_expiration_interval")

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[builtins.bool]:
        """
        <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class OpenIdConnectClientCredentialResponse(dict):
    """
    The authentication client credentials of the custom Open ID Connect provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdConnectClientCredentialResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdConnectClientCredentialResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdConnectClientCredentialResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_secret_setting_name: Optional[builtins.str] = None,
                 method: Optional[builtins.str] = None):
        """
        The authentication client credentials of the custom Open ID Connect provider.
        :param builtins.str client_secret_setting_name: The app setting that contains the client secret for the custom Open ID Connect provider.
        :param builtins.str method: The method that should be used to authenticate the user.
        """
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[builtins.str]:
        """
        The app setting that contains the client secret for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @property
    @pulumi.getter
    def method(self) -> Optional[builtins.str]:
        """
        The method that should be used to authenticate the user.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class OpenIdConnectConfigResponse(dict):
    """
    The configuration settings of the endpoints used for the custom Open ID Connect provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "certificationUri":
            suggest = "certification_uri"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "wellKnownOpenIdConfiguration":
            suggest = "well_known_open_id_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdConnectConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdConnectConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdConnectConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_endpoint: Optional[builtins.str] = None,
                 certification_uri: Optional[builtins.str] = None,
                 issuer: Optional[builtins.str] = None,
                 token_endpoint: Optional[builtins.str] = None,
                 well_known_open_id_configuration: Optional[builtins.str] = None):
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        :param builtins.str authorization_endpoint: The endpoint to be used to make an authorization request.
        :param builtins.str certification_uri: The endpoint that provides the keys necessary to validate the token.
        :param builtins.str issuer: The endpoint that issues the token.
        :param builtins.str token_endpoint: The endpoint to be used to request a token.
        :param builtins.str well_known_open_id_configuration: The endpoint that contains all the configuration endpoints for the provider.
        """
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if well_known_open_id_configuration is not None:
            pulumi.set(__self__, "well_known_open_id_configuration", well_known_open_id_configuration)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[builtins.str]:
        """
        The endpoint to be used to make an authorization request.
        """
        return pulumi.get(self, "authorization_endpoint")

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[builtins.str]:
        """
        The endpoint that provides the keys necessary to validate the token.
        """
        return pulumi.get(self, "certification_uri")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[builtins.str]:
        """
        The endpoint that issues the token.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[builtins.str]:
        """
        The endpoint to be used to request a token.
        """
        return pulumi.get(self, "token_endpoint")

    @property
    @pulumi.getter(name="wellKnownOpenIdConfiguration")
    def well_known_open_id_configuration(self) -> Optional[builtins.str]:
        """
        The endpoint that contains all the configuration endpoints for the provider.
        """
        return pulumi.get(self, "well_known_open_id_configuration")


@pulumi.output_type
class OpenIdConnectLoginResponse(dict):
    """
    The configuration settings of the login flow of the custom Open ID Connect provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameClaimType":
            suggest = "name_claim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdConnectLoginResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdConnectLoginResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdConnectLoginResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name_claim_type: Optional[builtins.str] = None,
                 scopes: Optional[Sequence[builtins.str]] = None):
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        :param builtins.str name_claim_type: The name of the claim that contains the users name.
        :param Sequence[builtins.str] scopes: A list of the scopes that should be requested while authenticating.
        """
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[builtins.str]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class OpenIdConnectRegistrationResponse(dict):
    """
    The configuration settings of the app registration for the custom Open ID Connect provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCredential":
            suggest = "client_credential"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "openIdConnectConfiguration":
            suggest = "open_id_connect_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdConnectRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdConnectRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdConnectRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_credential: Optional['outputs.OpenIdConnectClientCredentialResponse'] = None,
                 client_id: Optional[builtins.str] = None,
                 open_id_connect_configuration: Optional['outputs.OpenIdConnectConfigResponse'] = None):
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        :param 'OpenIdConnectClientCredentialResponse' client_credential: The authentication credentials of the custom Open ID Connect provider.
        :param builtins.str client_id: The client id of the custom Open ID Connect provider.
        :param 'OpenIdConnectConfigResponse' open_id_connect_configuration: The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        if client_credential is not None:
            pulumi.set(__self__, "client_credential", client_credential)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if open_id_connect_configuration is not None:
            pulumi.set(__self__, "open_id_connect_configuration", open_id_connect_configuration)

    @property
    @pulumi.getter(name="clientCredential")
    def client_credential(self) -> Optional['outputs.OpenIdConnectClientCredentialResponse']:
        """
        The authentication credentials of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_credential")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        The client id of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="openIdConnectConfiguration")
    def open_id_connect_configuration(self) -> Optional['outputs.OpenIdConnectConfigResponse']:
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "open_id_connect_configuration")


@pulumi.output_type
class PrivateLinkConnectionStateResponse(dict):
    """
    The state of a private link connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None):
        """
        The state of a private link connection
        :param builtins.str actions_required: ActionsRequired for a private link connection
        :param builtins.str description: Description of a private link connection
        :param builtins.str status: Status of a private link connection
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[builtins.str]:
        """
        ActionsRequired for a private link connection
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of a private link connection
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Status of a private link connection
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class PushSettingsResponse(dict):
    """
    Push settings for the App.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPushEnabled":
            suggest = "is_push_enabled"
        elif key == "dynamicTagsJson":
            suggest = "dynamic_tags_json"
        elif key == "tagWhitelistJson":
            suggest = "tag_whitelist_json"
        elif key == "tagsRequiringAuth":
            suggest = "tags_requiring_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PushSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PushSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PushSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 is_push_enabled: builtins.bool,
                 name: builtins.str,
                 type: builtins.str,
                 dynamic_tags_json: Optional[builtins.str] = None,
                 kind: Optional[builtins.str] = None,
                 tag_whitelist_json: Optional[builtins.str] = None,
                 tags_requiring_auth: Optional[builtins.str] = None):
        """
        Push settings for the App.
        :param builtins.str id: Resource Id.
        :param builtins.bool is_push_enabled: Gets or sets a flag indicating whether the Push endpoint is enabled.
        :param builtins.str name: Resource Name.
        :param builtins.str type: Resource type.
        :param builtins.str dynamic_tags_json: Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration endpoint.
        :param builtins.str kind: Kind of resource.
        :param builtins.str tag_whitelist_json: Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push registration endpoint.
        :param builtins.str tags_requiring_auth: Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration endpoint.
               Tags can consist of alphanumeric characters and the following:
               '_', '@', '#', '.', ':', '-'. 
               Validation should be performed at the PushRequestHandler.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_push_enabled", is_push_enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if dynamic_tags_json is not None:
            pulumi.set(__self__, "dynamic_tags_json", dynamic_tags_json)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if tag_whitelist_json is not None:
            pulumi.set(__self__, "tag_whitelist_json", tag_whitelist_json)
        if tags_requiring_auth is not None:
            pulumi.set(__self__, "tags_requiring_auth", tags_requiring_auth)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isPushEnabled")
    def is_push_enabled(self) -> builtins.bool:
        """
        Gets or sets a flag indicating whether the Push endpoint is enabled.
        """
        return pulumi.get(self, "is_push_enabled")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dynamicTagsJson")
    def dynamic_tags_json(self) -> Optional[builtins.str]:
        """
        Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration endpoint.
        """
        return pulumi.get(self, "dynamic_tags_json")

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="tagWhitelistJson")
    def tag_whitelist_json(self) -> Optional[builtins.str]:
        """
        Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push registration endpoint.
        """
        return pulumi.get(self, "tag_whitelist_json")

    @property
    @pulumi.getter(name="tagsRequiringAuth")
    def tags_requiring_auth(self) -> Optional[builtins.str]:
        """
        Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration endpoint.
        Tags can consist of alphanumeric characters and the following:
        '_', '@', '#', '.', ':', '-'. 
        Validation should be performed at the PushRequestHandler.
        """
        return pulumi.get(self, "tags_requiring_auth")


@pulumi.output_type
class RampUpRuleResponse(dict):
    """
    Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to gradually change routing % based on performance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionHostName":
            suggest = "action_host_name"
        elif key == "changeDecisionCallbackUrl":
            suggest = "change_decision_callback_url"
        elif key == "changeIntervalInMinutes":
            suggest = "change_interval_in_minutes"
        elif key == "changeStep":
            suggest = "change_step"
        elif key == "maxReroutePercentage":
            suggest = "max_reroute_percentage"
        elif key == "minReroutePercentage":
            suggest = "min_reroute_percentage"
        elif key == "reroutePercentage":
            suggest = "reroute_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RampUpRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RampUpRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RampUpRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_host_name: Optional[builtins.str] = None,
                 change_decision_callback_url: Optional[builtins.str] = None,
                 change_interval_in_minutes: Optional[builtins.int] = None,
                 change_step: Optional[builtins.float] = None,
                 max_reroute_percentage: Optional[builtins.float] = None,
                 min_reroute_percentage: Optional[builtins.float] = None,
                 name: Optional[builtins.str] = None,
                 reroute_percentage: Optional[builtins.float] = None):
        """
        Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to gradually change routing % based on performance.
        :param builtins.str action_host_name: Hostname of a slot to which the traffic will be redirected if decided to. E.g. myapp-stage.azurewebsites.net.
        :param builtins.str change_decision_callback_url: Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified.
        :param builtins.int change_interval_in_minutes: Specifies interval in minutes to reevaluate ReroutePercentage.
        :param builtins.float change_step: In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches \\n<code>MinReroutePercentage</code> or 
               <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in <code>ChangeIntervalInMinutes</code>.\\nCustom decision algorithm 
               can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
        :param builtins.float max_reroute_percentage: Specifies upper boundary below which ReroutePercentage will stay.
        :param builtins.float min_reroute_percentage: Specifies lower boundary above which ReroutePercentage will stay.
        :param builtins.str name: Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the experiment.
        :param builtins.float reroute_percentage: Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
        """
        if action_host_name is not None:
            pulumi.set(__self__, "action_host_name", action_host_name)
        if change_decision_callback_url is not None:
            pulumi.set(__self__, "change_decision_callback_url", change_decision_callback_url)
        if change_interval_in_minutes is not None:
            pulumi.set(__self__, "change_interval_in_minutes", change_interval_in_minutes)
        if change_step is not None:
            pulumi.set(__self__, "change_step", change_step)
        if max_reroute_percentage is not None:
            pulumi.set(__self__, "max_reroute_percentage", max_reroute_percentage)
        if min_reroute_percentage is not None:
            pulumi.set(__self__, "min_reroute_percentage", min_reroute_percentage)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if reroute_percentage is not None:
            pulumi.set(__self__, "reroute_percentage", reroute_percentage)

    @property
    @pulumi.getter(name="actionHostName")
    def action_host_name(self) -> Optional[builtins.str]:
        """
        Hostname of a slot to which the traffic will be redirected if decided to. E.g. myapp-stage.azurewebsites.net.
        """
        return pulumi.get(self, "action_host_name")

    @property
    @pulumi.getter(name="changeDecisionCallbackUrl")
    def change_decision_callback_url(self) -> Optional[builtins.str]:
        """
        Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified.
        """
        return pulumi.get(self, "change_decision_callback_url")

    @property
    @pulumi.getter(name="changeIntervalInMinutes")
    def change_interval_in_minutes(self) -> Optional[builtins.int]:
        """
        Specifies interval in minutes to reevaluate ReroutePercentage.
        """
        return pulumi.get(self, "change_interval_in_minutes")

    @property
    @pulumi.getter(name="changeStep")
    def change_step(self) -> Optional[builtins.float]:
        """
        In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches \\n<code>MinReroutePercentage</code> or 
        <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in <code>ChangeIntervalInMinutes</code>.\\nCustom decision algorithm 
        can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
        """
        return pulumi.get(self, "change_step")

    @property
    @pulumi.getter(name="maxReroutePercentage")
    def max_reroute_percentage(self) -> Optional[builtins.float]:
        """
        Specifies upper boundary below which ReroutePercentage will stay.
        """
        return pulumi.get(self, "max_reroute_percentage")

    @property
    @pulumi.getter(name="minReroutePercentage")
    def min_reroute_percentage(self) -> Optional[builtins.float]:
        """
        Specifies lower boundary above which ReroutePercentage will stay.
        """
        return pulumi.get(self, "min_reroute_percentage")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the experiment.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="reroutePercentage")
    def reroute_percentage(self) -> Optional[builtins.float]:
        """
        Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
        """
        return pulumi.get(self, "reroute_percentage")


@pulumi.output_type
class RemotePrivateEndpointConnectionResponse(dict):
    """
    A remote private endpoint connection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "ipAddresses":
            suggest = "ip_addresses"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 name: builtins.str,
                 provisioning_state: builtins.str,
                 type: builtins.str,
                 ip_addresses: Optional[Sequence[builtins.str]] = None,
                 kind: Optional[builtins.str] = None,
                 private_endpoint: Optional['outputs.ArmIdWrapperResponse'] = None,
                 private_link_service_connection_state: Optional['outputs.PrivateLinkConnectionStateResponse'] = None):
        """
        A remote private endpoint connection
        :param builtins.str id: Resource Id.
        :param builtins.str name: Resource Name.
        :param builtins.str type: Resource type.
        :param Sequence[builtins.str] ip_addresses: Private IPAddresses mapped to the remote private endpoint
        :param builtins.str kind: Kind of resource.
        :param 'ArmIdWrapperResponse' private_endpoint: PrivateEndpoint of a remote private endpoint connection
        :param 'PrivateLinkConnectionStateResponse' private_link_service_connection_state: The state of a private link connection
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", type)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if private_link_service_connection_state is not None:
            pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[builtins.str]]:
        """
        Private IPAddresses mapped to the remote private endpoint
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.ArmIdWrapperResponse']:
        """
        PrivateEndpoint of a remote private endpoint connection
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> Optional['outputs.PrivateLinkConnectionStateResponse']:
        """
        The state of a private link connection
        """
        return pulumi.get(self, "private_link_service_connection_state")


@pulumi.output_type
class RequestsBasedTriggerResponse(dict):
    """
    Trigger based on total requests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeInterval":
            suggest = "time_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestsBasedTriggerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestsBasedTriggerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestsBasedTriggerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[builtins.int] = None,
                 time_interval: Optional[builtins.str] = None):
        """
        Trigger based on total requests.
        :param builtins.int count: Request Count.
        :param builtins.str time_interval: Time interval.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.int]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[builtins.str]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")


@pulumi.output_type
class ResourceConfigResponse(dict):
    """
    Function app resource requirements.
    """
    def __init__(__self__, *,
                 cpu: Optional[builtins.float] = None,
                 memory: Optional[builtins.str] = None):
        """
        Function app resource requirements.
        :param builtins.float cpu: Required CPU in cores, e.g. 0.5
        :param builtins.str memory: Required memory, e.g. "1Gi"
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[builtins.float]:
        """
        Required CPU in cores, e.g. 0.5
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> Optional[builtins.str]:
        """
        Required memory, e.g. "1Gi"
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ResponseMessageEnvelopeRemotePrivateEndpointConnectionResponse(dict):
    """
    Message envelope that contains the common Azure resource manager properties and the resource provider specific content.
    """
    def __init__(__self__, *,
                 error: Optional['outputs.ErrorEntityResponse'] = None,
                 id: Optional[builtins.str] = None,
                 identity: Optional['outputs.ManagedServiceIdentityResponse'] = None,
                 location: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 plan: Optional['outputs.ArmPlanResponse'] = None,
                 properties: Optional['outputs.RemotePrivateEndpointConnectionResponse'] = None,
                 sku: Optional['outputs.SkuDescriptionResponse'] = None,
                 status: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None,
                 type: Optional[builtins.str] = None,
                 zones: Optional[Sequence[builtins.str]] = None):
        """
        Message envelope that contains the common Azure resource manager properties and the resource provider specific content.
        :param 'ErrorEntityResponse' error: Azure-AsyncOperation Error info.
        :param builtins.str id: Resource Id. Typically ID is populated only for responses to GET requests. Caller is responsible for passing in this
               value for GET requests only.
               For example: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupId}/providers/Microsoft.Web/sites/{sitename}
        :param 'ManagedServiceIdentityResponse' identity: MSI resource
        :param builtins.str location: Geographical region resource belongs to e.g. SouthCentralUS, SouthEastAsia.
        :param builtins.str name: Name of resource.
        :param 'ArmPlanResponse' plan: Azure resource manager plan.
        :param 'RemotePrivateEndpointConnectionResponse' properties: Resource specific properties.
        :param 'SkuDescriptionResponse' sku: SKU description of the resource.
        :param builtins.str status: Azure-AsyncOperation Status info.
        :param Mapping[str, builtins.str] tags: Tags associated with resource.
        :param builtins.str type: Type of resource e.g "Microsoft.Web/sites".
        :param Sequence[builtins.str] zones: Logical Availability Zones the service is hosted in
        """
        if error is not None:
            pulumi.set(__self__, "error", error)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if plan is not None:
            pulumi.set(__self__, "plan", plan)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.ErrorEntityResponse']:
        """
        Azure-AsyncOperation Error info.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        Resource Id. Typically ID is populated only for responses to GET requests. Caller is responsible for passing in this
        value for GET requests only.
        For example: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupId}/providers/Microsoft.Web/sites/{sitename}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.ManagedServiceIdentityResponse']:
        """
        MSI resource
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter
    def location(self) -> Optional[builtins.str]:
        """
        Geographical region resource belongs to e.g. SouthCentralUS, SouthEastAsia.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def plan(self) -> Optional['outputs.ArmPlanResponse']:
        """
        Azure resource manager plan.
        """
        return pulumi.get(self, "plan")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.RemotePrivateEndpointConnectionResponse']:
        """
        Resource specific properties.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def sku(self) -> Optional['outputs.SkuDescriptionResponse']:
        """
        SKU description of the resource.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Azure-AsyncOperation Status info.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Tags associated with resource.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of resource e.g "Microsoft.Web/sites".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[builtins.str]]:
        """
        Logical Availability Zones the service is hosted in
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class SiteConfigResponse(dict):
    """
    Configuration of an App Service app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineKey":
            suggest = "machine_key"
        elif key == "acrUseManagedIdentityCreds":
            suggest = "acr_use_managed_identity_creds"
        elif key == "acrUserManagedIdentityID":
            suggest = "acr_user_managed_identity_id"
        elif key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinition":
            suggest = "api_definition"
        elif key == "apiManagementConfig":
            suggest = "api_management_config"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "appSettings":
            suggest = "app_settings"
        elif key == "autoHealEnabled":
            suggest = "auto_heal_enabled"
        elif key == "autoHealRules":
            suggest = "auto_heal_rules"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "azureStorageAccounts":
            suggest = "azure_storage_accounts"
        elif key == "connectionStrings":
            suggest = "connection_strings"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "documentRoot":
            suggest = "document_root"
        elif key == "elasticWebAppScaleLimit":
            suggest = "elastic_web_app_scale_limit"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "functionAppScaleLimit":
            suggest = "function_app_scale_limit"
        elif key == "functionsRuntimeScaleMonitoringEnabled":
            suggest = "functions_runtime_scale_monitoring_enabled"
        elif key == "handlerMappings":
            suggest = "handler_mappings"
        elif key == "healthCheckPath":
            suggest = "health_check_path"
        elif key == "http20Enabled":
            suggest = "http20_enabled"
        elif key == "httpLoggingEnabled":
            suggest = "http_logging_enabled"
        elif key == "ipSecurityRestrictions":
            suggest = "ip_security_restrictions"
        elif key == "ipSecurityRestrictionsDefaultAction":
            suggest = "ip_security_restrictions_default_action"
        elif key == "javaContainer":
            suggest = "java_container"
        elif key == "javaContainerVersion":
            suggest = "java_container_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "keyVaultReferenceIdentity":
            suggest = "key_vault_reference_identity"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "loadBalancing":
            suggest = "load_balancing"
        elif key == "localMySqlEnabled":
            suggest = "local_my_sql_enabled"
        elif key == "logsDirectorySizeLimit":
            suggest = "logs_directory_size_limit"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "managedServiceIdentityId":
            suggest = "managed_service_identity_id"
        elif key == "minTlsCipherSuite":
            suggest = "min_tls_cipher_suite"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "minimumElasticInstanceCount":
            suggest = "minimum_elastic_instance_count"
        elif key == "netFrameworkVersion":
            suggest = "net_framework_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "powerShellVersion":
            suggest = "power_shell_version"
        elif key == "preWarmedInstanceCount":
            suggest = "pre_warmed_instance_count"
        elif key == "publicNetworkAccess":
            suggest = "public_network_access"
        elif key == "publishingUsername":
            suggest = "publishing_username"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "requestTracingEnabled":
            suggest = "request_tracing_enabled"
        elif key == "requestTracingExpirationTime":
            suggest = "request_tracing_expiration_time"
        elif key == "scmIpSecurityRestrictions":
            suggest = "scm_ip_security_restrictions"
        elif key == "scmIpSecurityRestrictionsDefaultAction":
            suggest = "scm_ip_security_restrictions_default_action"
        elif key == "scmIpSecurityRestrictionsUseMain":
            suggest = "scm_ip_security_restrictions_use_main"
        elif key == "scmMinTlsVersion":
            suggest = "scm_min_tls_version"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "tracingOptions":
            suggest = "tracing_options"
        elif key == "use32BitWorkerProcess":
            suggest = "use32_bit_worker_process"
        elif key == "virtualApplications":
            suggest = "virtual_applications"
        elif key == "vnetName":
            suggest = "vnet_name"
        elif key == "vnetPrivatePortsCount":
            suggest = "vnet_private_ports_count"
        elif key == "vnetRouteAllEnabled":
            suggest = "vnet_route_all_enabled"
        elif key == "webSocketsEnabled":
            suggest = "web_sockets_enabled"
        elif key == "websiteTimeZone":
            suggest = "website_time_zone"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"
        elif key == "xManagedServiceIdentityId":
            suggest = "x_managed_service_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SiteConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SiteConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SiteConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 machine_key: 'outputs.SiteMachineKeyResponse',
                 acr_use_managed_identity_creds: Optional[builtins.bool] = None,
                 acr_user_managed_identity_id: Optional[builtins.str] = None,
                 always_on: Optional[builtins.bool] = None,
                 api_definition: Optional['outputs.ApiDefinitionInfoResponse'] = None,
                 api_management_config: Optional['outputs.ApiManagementConfigResponse'] = None,
                 app_command_line: Optional[builtins.str] = None,
                 app_settings: Optional[Sequence['outputs.NameValuePairResponse']] = None,
                 auto_heal_enabled: Optional[builtins.bool] = None,
                 auto_heal_rules: Optional['outputs.AutoHealRulesResponse'] = None,
                 auto_swap_slot_name: Optional[builtins.str] = None,
                 azure_storage_accounts: Optional[Mapping[str, 'outputs.AzureStorageInfoValueResponse']] = None,
                 connection_strings: Optional[Sequence['outputs.ConnStringInfoResponse']] = None,
                 cors: Optional['outputs.CorsSettingsResponse'] = None,
                 default_documents: Optional[Sequence[builtins.str]] = None,
                 detailed_error_logging_enabled: Optional[builtins.bool] = None,
                 document_root: Optional[builtins.str] = None,
                 elastic_web_app_scale_limit: Optional[builtins.int] = None,
                 experiments: Optional['outputs.ExperimentsResponse'] = None,
                 ftps_state: Optional[builtins.str] = None,
                 function_app_scale_limit: Optional[builtins.int] = None,
                 functions_runtime_scale_monitoring_enabled: Optional[builtins.bool] = None,
                 handler_mappings: Optional[Sequence['outputs.HandlerMappingResponse']] = None,
                 health_check_path: Optional[builtins.str] = None,
                 http20_enabled: Optional[builtins.bool] = None,
                 http_logging_enabled: Optional[builtins.bool] = None,
                 ip_security_restrictions: Optional[Sequence['outputs.IpSecurityRestrictionResponse']] = None,
                 ip_security_restrictions_default_action: Optional[builtins.str] = None,
                 java_container: Optional[builtins.str] = None,
                 java_container_version: Optional[builtins.str] = None,
                 java_version: Optional[builtins.str] = None,
                 key_vault_reference_identity: Optional[builtins.str] = None,
                 limits: Optional['outputs.SiteLimitsResponse'] = None,
                 linux_fx_version: Optional[builtins.str] = None,
                 load_balancing: Optional[builtins.str] = None,
                 local_my_sql_enabled: Optional[builtins.bool] = None,
                 logs_directory_size_limit: Optional[builtins.int] = None,
                 managed_pipeline_mode: Optional[builtins.str] = None,
                 managed_service_identity_id: Optional[builtins.int] = None,
                 min_tls_cipher_suite: Optional[builtins.str] = None,
                 min_tls_version: Optional[builtins.str] = None,
                 minimum_elastic_instance_count: Optional[builtins.int] = None,
                 net_framework_version: Optional[builtins.str] = None,
                 node_version: Optional[builtins.str] = None,
                 number_of_workers: Optional[builtins.int] = None,
                 php_version: Optional[builtins.str] = None,
                 power_shell_version: Optional[builtins.str] = None,
                 pre_warmed_instance_count: Optional[builtins.int] = None,
                 public_network_access: Optional[builtins.str] = None,
                 publishing_username: Optional[builtins.str] = None,
                 push: Optional['outputs.PushSettingsResponse'] = None,
                 python_version: Optional[builtins.str] = None,
                 remote_debugging_enabled: Optional[builtins.bool] = None,
                 remote_debugging_version: Optional[builtins.str] = None,
                 request_tracing_enabled: Optional[builtins.bool] = None,
                 request_tracing_expiration_time: Optional[builtins.str] = None,
                 scm_ip_security_restrictions: Optional[Sequence['outputs.IpSecurityRestrictionResponse']] = None,
                 scm_ip_security_restrictions_default_action: Optional[builtins.str] = None,
                 scm_ip_security_restrictions_use_main: Optional[builtins.bool] = None,
                 scm_min_tls_version: Optional[builtins.str] = None,
                 scm_type: Optional[builtins.str] = None,
                 tracing_options: Optional[builtins.str] = None,
                 use32_bit_worker_process: Optional[builtins.bool] = None,
                 virtual_applications: Optional[Sequence['outputs.VirtualApplicationResponse']] = None,
                 vnet_name: Optional[builtins.str] = None,
                 vnet_private_ports_count: Optional[builtins.int] = None,
                 vnet_route_all_enabled: Optional[builtins.bool] = None,
                 web_sockets_enabled: Optional[builtins.bool] = None,
                 website_time_zone: Optional[builtins.str] = None,
                 windows_fx_version: Optional[builtins.str] = None,
                 x_managed_service_identity_id: Optional[builtins.int] = None):
        """
        Configuration of an App Service app.
        :param 'SiteMachineKeyResponse' machine_key: Site MachineKey.
        :param builtins.bool acr_use_managed_identity_creds: Flag to use Managed Identity Creds for ACR pull
        :param builtins.str acr_user_managed_identity_id: If using user managed identity, the user managed identity ClientId
        :param builtins.bool always_on: <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
        :param 'ApiDefinitionInfoResponse' api_definition: Information about the formal API definition for the app.
        :param 'ApiManagementConfigResponse' api_management_config: Azure API management settings linked to the app.
        :param builtins.str app_command_line: App command line to launch.
        :param Sequence['NameValuePairResponse'] app_settings: Application settings.
        :param builtins.bool auto_heal_enabled: <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
        :param 'AutoHealRulesResponse' auto_heal_rules: Auto Heal rules.
        :param builtins.str auto_swap_slot_name: Auto-swap slot name.
        :param Mapping[str, 'AzureStorageInfoValueResponse'] azure_storage_accounts: List of Azure Storage Accounts.
        :param Sequence['ConnStringInfoResponse'] connection_strings: Connection strings.
        :param 'CorsSettingsResponse' cors: Cross-Origin Resource Sharing (CORS) settings.
        :param Sequence[builtins.str] default_documents: Default documents.
        :param builtins.bool detailed_error_logging_enabled: <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
        :param builtins.str document_root: Document root.
        :param builtins.int elastic_web_app_scale_limit: Maximum number of workers that a site can scale out to.
               This setting only applies to apps in plans where ElasticScaleEnabled is <code>true</code>
        :param 'ExperimentsResponse' experiments: This is work around for polymorphic types.
        :param builtins.str ftps_state: State of FTP / FTPS service
        :param builtins.int function_app_scale_limit: Maximum number of workers that a site can scale out to.
               This setting only applies to the Consumption and Elastic Premium Plans
        :param builtins.bool functions_runtime_scale_monitoring_enabled: Gets or sets a value indicating whether functions runtime scale monitoring is enabled. When enabled,
               the ScaleController will not monitor event sources directly, but will instead call to the
               runtime to get scale status.
        :param Sequence['HandlerMappingResponse'] handler_mappings: Handler mappings.
        :param builtins.str health_check_path: Health check path
        :param builtins.bool http20_enabled: Http20Enabled: configures a web site to allow clients to connect over http2.0
        :param builtins.bool http_logging_enabled: <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
        :param Sequence['IpSecurityRestrictionResponse'] ip_security_restrictions: IP security restrictions for main.
        :param builtins.str ip_security_restrictions_default_action: Default action for main access restriction if no rules are matched.
        :param builtins.str java_container: Java container.
        :param builtins.str java_container_version: Java container version.
        :param builtins.str java_version: Java version.
        :param builtins.str key_vault_reference_identity: Identity to use for Key Vault Reference authentication.
        :param 'SiteLimitsResponse' limits: Site limits.
        :param builtins.str linux_fx_version: Linux App Framework and version
        :param builtins.str load_balancing: Site load balancing.
        :param builtins.bool local_my_sql_enabled: <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
        :param builtins.int logs_directory_size_limit: HTTP logs directory size limit.
        :param builtins.str managed_pipeline_mode: Managed pipeline mode.
        :param builtins.int managed_service_identity_id: Managed Service Identity Id
        :param builtins.str min_tls_cipher_suite: The minimum strength TLS cipher suite allowed for an application
        :param builtins.str min_tls_version: MinTlsVersion: configures the minimum version of TLS required for SSL requests
        :param builtins.int minimum_elastic_instance_count: Number of minimum instance count for a site
               This setting only applies to the Elastic Plans
        :param builtins.str net_framework_version: .NET Framework version.
        :param builtins.str node_version: Version of Node.js.
        :param builtins.int number_of_workers: Number of workers.
        :param builtins.str php_version: Version of PHP.
        :param builtins.str power_shell_version: Version of PowerShell.
        :param builtins.int pre_warmed_instance_count: Number of preWarmed instances.
               This setting only applies to the Consumption and Elastic Plans
        :param builtins.str public_network_access: Property to allow or block all public traffic.
        :param builtins.str publishing_username: Publishing user name.
        :param 'PushSettingsResponse' push: Push endpoint settings.
        :param builtins.str python_version: Version of Python.
        :param builtins.bool remote_debugging_enabled: <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
        :param builtins.str remote_debugging_version: Remote debugging version.
        :param builtins.bool request_tracing_enabled: <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
        :param builtins.str request_tracing_expiration_time: Request tracing expiration time.
        :param Sequence['IpSecurityRestrictionResponse'] scm_ip_security_restrictions: IP security restrictions for scm.
        :param builtins.str scm_ip_security_restrictions_default_action: Default action for scm access restriction if no rules are matched.
        :param builtins.bool scm_ip_security_restrictions_use_main: IP security restrictions for scm to use main.
        :param builtins.str scm_min_tls_version: ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
        :param builtins.str scm_type: SCM type.
        :param builtins.str tracing_options: Tracing options.
        :param builtins.bool use32_bit_worker_process: <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
        :param Sequence['VirtualApplicationResponse'] virtual_applications: Virtual applications.
        :param builtins.str vnet_name: Virtual Network name.
        :param builtins.int vnet_private_ports_count: The number of private ports assigned to this app. These will be assigned dynamically on runtime.
        :param builtins.bool vnet_route_all_enabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied.
        :param builtins.bool web_sockets_enabled: <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
        :param builtins.str website_time_zone: Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App Service. Setting the WEBSITE_TIME_ZONE app setting takes precedence over this config. For Linux, expects tz database values https://www.iana.org/time-zones (for a quick reference see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time zones listed under HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones
        :param builtins.str windows_fx_version: Xenon App Framework and version
        :param builtins.int x_managed_service_identity_id: Explicit Managed Service Identity Id
        """
        pulumi.set(__self__, "machine_key", machine_key)
        if acr_use_managed_identity_creds is not None:
            pulumi.set(__self__, "acr_use_managed_identity_creds", acr_use_managed_identity_creds)
        if acr_user_managed_identity_id is not None:
            pulumi.set(__self__, "acr_user_managed_identity_id", acr_user_managed_identity_id)
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition is not None:
            pulumi.set(__self__, "api_definition", api_definition)
        if api_management_config is not None:
            pulumi.set(__self__, "api_management_config", api_management_config)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_settings is not None:
            pulumi.set(__self__, "app_settings", app_settings)
        if auto_heal_enabled is not None:
            pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        if auto_heal_rules is not None:
            pulumi.set(__self__, "auto_heal_rules", auto_heal_rules)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if azure_storage_accounts is not None:
            pulumi.set(__self__, "azure_storage_accounts", azure_storage_accounts)
        if connection_strings is not None:
            pulumi.set(__self__, "connection_strings", connection_strings)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if document_root is not None:
            pulumi.set(__self__, "document_root", document_root)
        if elastic_web_app_scale_limit is not None:
            pulumi.set(__self__, "elastic_web_app_scale_limit", elastic_web_app_scale_limit)
        if experiments is not None:
            pulumi.set(__self__, "experiments", experiments)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if function_app_scale_limit is not None:
            pulumi.set(__self__, "function_app_scale_limit", function_app_scale_limit)
        if functions_runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "functions_runtime_scale_monitoring_enabled", functions_runtime_scale_monitoring_enabled)
        if handler_mappings is not None:
            pulumi.set(__self__, "handler_mappings", handler_mappings)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http20_enabled is None:
            http20_enabled = True
        if http20_enabled is not None:
            pulumi.set(__self__, "http20_enabled", http20_enabled)
        if http_logging_enabled is not None:
            pulumi.set(__self__, "http_logging_enabled", http_logging_enabled)
        if ip_security_restrictions is not None:
            pulumi.set(__self__, "ip_security_restrictions", ip_security_restrictions)
        if ip_security_restrictions_default_action is not None:
            pulumi.set(__self__, "ip_security_restrictions_default_action", ip_security_restrictions_default_action)
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if key_vault_reference_identity is not None:
            pulumi.set(__self__, "key_vault_reference_identity", key_vault_reference_identity)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing is not None:
            pulumi.set(__self__, "load_balancing", load_balancing)
        if local_my_sql_enabled is None:
            local_my_sql_enabled = False
        if local_my_sql_enabled is not None:
            pulumi.set(__self__, "local_my_sql_enabled", local_my_sql_enabled)
        if logs_directory_size_limit is not None:
            pulumi.set(__self__, "logs_directory_size_limit", logs_directory_size_limit)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if managed_service_identity_id is not None:
            pulumi.set(__self__, "managed_service_identity_id", managed_service_identity_id)
        if min_tls_cipher_suite is not None:
            pulumi.set(__self__, "min_tls_cipher_suite", min_tls_cipher_suite)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if minimum_elastic_instance_count is not None:
            pulumi.set(__self__, "minimum_elastic_instance_count", minimum_elastic_instance_count)
        if net_framework_version is None:
            net_framework_version = 'v4.6'
        if net_framework_version is not None:
            pulumi.set(__self__, "net_framework_version", net_framework_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if number_of_workers is not None:
            pulumi.set(__self__, "number_of_workers", number_of_workers)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if power_shell_version is not None:
            pulumi.set(__self__, "power_shell_version", power_shell_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if publishing_username is not None:
            pulumi.set(__self__, "publishing_username", publishing_username)
        if push is not None:
            pulumi.set(__self__, "push", push)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if request_tracing_enabled is not None:
            pulumi.set(__self__, "request_tracing_enabled", request_tracing_enabled)
        if request_tracing_expiration_time is not None:
            pulumi.set(__self__, "request_tracing_expiration_time", request_tracing_expiration_time)
        if scm_ip_security_restrictions is not None:
            pulumi.set(__self__, "scm_ip_security_restrictions", scm_ip_security_restrictions)
        if scm_ip_security_restrictions_default_action is not None:
            pulumi.set(__self__, "scm_ip_security_restrictions_default_action", scm_ip_security_restrictions_default_action)
        if scm_ip_security_restrictions_use_main is not None:
            pulumi.set(__self__, "scm_ip_security_restrictions_use_main", scm_ip_security_restrictions_use_main)
        if scm_min_tls_version is not None:
            pulumi.set(__self__, "scm_min_tls_version", scm_min_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if tracing_options is not None:
            pulumi.set(__self__, "tracing_options", tracing_options)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if virtual_applications is not None:
            pulumi.set(__self__, "virtual_applications", virtual_applications)
        if vnet_name is not None:
            pulumi.set(__self__, "vnet_name", vnet_name)
        if vnet_private_ports_count is not None:
            pulumi.set(__self__, "vnet_private_ports_count", vnet_private_ports_count)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if web_sockets_enabled is not None:
            pulumi.set(__self__, "web_sockets_enabled", web_sockets_enabled)
        if website_time_zone is not None:
            pulumi.set(__self__, "website_time_zone", website_time_zone)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if x_managed_service_identity_id is not None:
            pulumi.set(__self__, "x_managed_service_identity_id", x_managed_service_identity_id)

    @property
    @pulumi.getter(name="machineKey")
    def machine_key(self) -> 'outputs.SiteMachineKeyResponse':
        """
        Site MachineKey.
        """
        return pulumi.get(self, "machine_key")

    @property
    @pulumi.getter(name="acrUseManagedIdentityCreds")
    def acr_use_managed_identity_creds(self) -> Optional[builtins.bool]:
        """
        Flag to use Managed Identity Creds for ACR pull
        """
        return pulumi.get(self, "acr_use_managed_identity_creds")

    @property
    @pulumi.getter(name="acrUserManagedIdentityID")
    def acr_user_managed_identity_id(self) -> Optional[builtins.str]:
        """
        If using user managed identity, the user managed identity ClientId
        """
        return pulumi.get(self, "acr_user_managed_identity_id")

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[builtins.bool]:
        """
        <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinition")
    def api_definition(self) -> Optional['outputs.ApiDefinitionInfoResponse']:
        """
        Information about the formal API definition for the app.
        """
        return pulumi.get(self, "api_definition")

    @property
    @pulumi.getter(name="apiManagementConfig")
    def api_management_config(self) -> Optional['outputs.ApiManagementConfigResponse']:
        """
        Azure API management settings linked to the app.
        """
        return pulumi.get(self, "api_management_config")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[builtins.str]:
        """
        App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appSettings")
    def app_settings(self) -> Optional[Sequence['outputs.NameValuePairResponse']]:
        """
        Application settings.
        """
        return pulumi.get(self, "app_settings")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> Optional[builtins.bool]:
        """
        <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealRules")
    def auto_heal_rules(self) -> Optional['outputs.AutoHealRulesResponse']:
        """
        Auto Heal rules.
        """
        return pulumi.get(self, "auto_heal_rules")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[builtins.str]:
        """
        Auto-swap slot name.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter(name="azureStorageAccounts")
    def azure_storage_accounts(self) -> Optional[Mapping[str, 'outputs.AzureStorageInfoValueResponse']]:
        """
        List of Azure Storage Accounts.
        """
        return pulumi.get(self, "azure_storage_accounts")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[Sequence['outputs.ConnStringInfoResponse']]:
        """
        Connection strings.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.CorsSettingsResponse']:
        """
        Cross-Origin Resource Sharing (CORS) settings.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[builtins.str]]:
        """
        Default documents.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[builtins.bool]:
        """
        <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="documentRoot")
    def document_root(self) -> Optional[builtins.str]:
        """
        Document root.
        """
        return pulumi.get(self, "document_root")

    @property
    @pulumi.getter(name="elasticWebAppScaleLimit")
    def elastic_web_app_scale_limit(self) -> Optional[builtins.int]:
        """
        Maximum number of workers that a site can scale out to.
        This setting only applies to apps in plans where ElasticScaleEnabled is <code>true</code>
        """
        return pulumi.get(self, "elastic_web_app_scale_limit")

    @property
    @pulumi.getter
    def experiments(self) -> Optional['outputs.ExperimentsResponse']:
        """
        This is work around for polymorphic types.
        """
        return pulumi.get(self, "experiments")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[builtins.str]:
        """
        State of FTP / FTPS service
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="functionAppScaleLimit")
    def function_app_scale_limit(self) -> Optional[builtins.int]:
        """
        Maximum number of workers that a site can scale out to.
        This setting only applies to the Consumption and Elastic Premium Plans
        """
        return pulumi.get(self, "function_app_scale_limit")

    @property
    @pulumi.getter(name="functionsRuntimeScaleMonitoringEnabled")
    def functions_runtime_scale_monitoring_enabled(self) -> Optional[builtins.bool]:
        """
        Gets or sets a value indicating whether functions runtime scale monitoring is enabled. When enabled,
        the ScaleController will not monitor event sources directly, but will instead call to the
        runtime to get scale status.
        """
        return pulumi.get(self, "functions_runtime_scale_monitoring_enabled")

    @property
    @pulumi.getter(name="handlerMappings")
    def handler_mappings(self) -> Optional[Sequence['outputs.HandlerMappingResponse']]:
        """
        Handler mappings.
        """
        return pulumi.get(self, "handler_mappings")

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[builtins.str]:
        """
        Health check path
        """
        return pulumi.get(self, "health_check_path")

    @property
    @pulumi.getter(name="http20Enabled")
    def http20_enabled(self) -> Optional[builtins.bool]:
        """
        Http20Enabled: configures a web site to allow clients to connect over http2.0
        """
        return pulumi.get(self, "http20_enabled")

    @property
    @pulumi.getter(name="httpLoggingEnabled")
    def http_logging_enabled(self) -> Optional[builtins.bool]:
        """
        <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "http_logging_enabled")

    @property
    @pulumi.getter(name="ipSecurityRestrictions")
    def ip_security_restrictions(self) -> Optional[Sequence['outputs.IpSecurityRestrictionResponse']]:
        """
        IP security restrictions for main.
        """
        return pulumi.get(self, "ip_security_restrictions")

    @property
    @pulumi.getter(name="ipSecurityRestrictionsDefaultAction")
    def ip_security_restrictions_default_action(self) -> Optional[builtins.str]:
        """
        Default action for main access restriction if no rules are matched.
        """
        return pulumi.get(self, "ip_security_restrictions_default_action")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[builtins.str]:
        """
        Java container.
        """
        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[builtins.str]:
        """
        Java container version.
        """
        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[builtins.str]:
        """
        Java version.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter(name="keyVaultReferenceIdentity")
    def key_vault_reference_identity(self) -> Optional[builtins.str]:
        """
        Identity to use for Key Vault Reference authentication.
        """
        return pulumi.get(self, "key_vault_reference_identity")

    @property
    @pulumi.getter
    def limits(self) -> Optional['outputs.SiteLimitsResponse']:
        """
        Site limits.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[builtins.str]:
        """
        Linux App Framework and version
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancing")
    def load_balancing(self) -> Optional[builtins.str]:
        """
        Site load balancing.
        """
        return pulumi.get(self, "load_balancing")

    @property
    @pulumi.getter(name="localMySqlEnabled")
    def local_my_sql_enabled(self) -> Optional[builtins.bool]:
        """
        <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "local_my_sql_enabled")

    @property
    @pulumi.getter(name="logsDirectorySizeLimit")
    def logs_directory_size_limit(self) -> Optional[builtins.int]:
        """
        HTTP logs directory size limit.
        """
        return pulumi.get(self, "logs_directory_size_limit")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[builtins.str]:
        """
        Managed pipeline mode.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="managedServiceIdentityId")
    def managed_service_identity_id(self) -> Optional[builtins.int]:
        """
        Managed Service Identity Id
        """
        return pulumi.get(self, "managed_service_identity_id")

    @property
    @pulumi.getter(name="minTlsCipherSuite")
    def min_tls_cipher_suite(self) -> Optional[builtins.str]:
        """
        The minimum strength TLS cipher suite allowed for an application
        """
        return pulumi.get(self, "min_tls_cipher_suite")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[builtins.str]:
        """
        MinTlsVersion: configures the minimum version of TLS required for SSL requests
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="minimumElasticInstanceCount")
    def minimum_elastic_instance_count(self) -> Optional[builtins.int]:
        """
        Number of minimum instance count for a site
        This setting only applies to the Elastic Plans
        """
        return pulumi.get(self, "minimum_elastic_instance_count")

    @property
    @pulumi.getter(name="netFrameworkVersion")
    def net_framework_version(self) -> Optional[builtins.str]:
        """
        .NET Framework version.
        """
        return pulumi.get(self, "net_framework_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[builtins.str]:
        """
        Version of Node.js.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[builtins.int]:
        """
        Number of workers.
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[builtins.str]:
        """
        Version of PHP.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="powerShellVersion")
    def power_shell_version(self) -> Optional[builtins.str]:
        """
        Version of PowerShell.
        """
        return pulumi.get(self, "power_shell_version")

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[builtins.int]:
        """
        Number of preWarmed instances.
        This setting only applies to the Consumption and Elastic Plans
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[builtins.str]:
        """
        Property to allow or block all public traffic.
        """
        return pulumi.get(self, "public_network_access")

    @property
    @pulumi.getter(name="publishingUsername")
    def publishing_username(self) -> Optional[builtins.str]:
        """
        Publishing user name.
        """
        return pulumi.get(self, "publishing_username")

    @property
    @pulumi.getter
    def push(self) -> Optional['outputs.PushSettingsResponse']:
        """
        Push endpoint settings.
        """
        return pulumi.get(self, "push")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[builtins.str]:
        """
        Version of Python.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[builtins.bool]:
        """
        <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[builtins.str]:
        """
        Remote debugging version.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="requestTracingEnabled")
    def request_tracing_enabled(self) -> Optional[builtins.bool]:
        """
        <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "request_tracing_enabled")

    @property
    @pulumi.getter(name="requestTracingExpirationTime")
    def request_tracing_expiration_time(self) -> Optional[builtins.str]:
        """
        Request tracing expiration time.
        """
        return pulumi.get(self, "request_tracing_expiration_time")

    @property
    @pulumi.getter(name="scmIpSecurityRestrictions")
    def scm_ip_security_restrictions(self) -> Optional[Sequence['outputs.IpSecurityRestrictionResponse']]:
        """
        IP security restrictions for scm.
        """
        return pulumi.get(self, "scm_ip_security_restrictions")

    @property
    @pulumi.getter(name="scmIpSecurityRestrictionsDefaultAction")
    def scm_ip_security_restrictions_default_action(self) -> Optional[builtins.str]:
        """
        Default action for scm access restriction if no rules are matched.
        """
        return pulumi.get(self, "scm_ip_security_restrictions_default_action")

    @property
    @pulumi.getter(name="scmIpSecurityRestrictionsUseMain")
    def scm_ip_security_restrictions_use_main(self) -> Optional[builtins.bool]:
        """
        IP security restrictions for scm to use main.
        """
        return pulumi.get(self, "scm_ip_security_restrictions_use_main")

    @property
    @pulumi.getter(name="scmMinTlsVersion")
    def scm_min_tls_version(self) -> Optional[builtins.str]:
        """
        ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
        """
        return pulumi.get(self, "scm_min_tls_version")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[builtins.str]:
        """
        SCM type.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="tracingOptions")
    def tracing_options(self) -> Optional[builtins.str]:
        """
        Tracing options.
        """
        return pulumi.get(self, "tracing_options")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[builtins.bool]:
        """
        <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="virtualApplications")
    def virtual_applications(self) -> Optional[Sequence['outputs.VirtualApplicationResponse']]:
        """
        Virtual applications.
        """
        return pulumi.get(self, "virtual_applications")

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> Optional[builtins.str]:
        """
        Virtual Network name.
        """
        return pulumi.get(self, "vnet_name")

    @property
    @pulumi.getter(name="vnetPrivatePortsCount")
    def vnet_private_ports_count(self) -> Optional[builtins.int]:
        """
        The number of private ports assigned to this app. These will be assigned dynamically on runtime.
        """
        return pulumi.get(self, "vnet_private_ports_count")

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[builtins.bool]:
        """
        Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @property
    @pulumi.getter(name="webSocketsEnabled")
    def web_sockets_enabled(self) -> Optional[builtins.bool]:
        """
        <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "web_sockets_enabled")

    @property
    @pulumi.getter(name="websiteTimeZone")
    def website_time_zone(self) -> Optional[builtins.str]:
        """
        Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App Service. Setting the WEBSITE_TIME_ZONE app setting takes precedence over this config. For Linux, expects tz database values https://www.iana.org/time-zones (for a quick reference see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time zones listed under HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones
        """
        return pulumi.get(self, "website_time_zone")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[builtins.str]:
        """
        Xenon App Framework and version
        """
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="xManagedServiceIdentityId")
    def x_managed_service_identity_id(self) -> Optional[builtins.int]:
        """
        Explicit Managed Service Identity Id
        """
        return pulumi.get(self, "x_managed_service_identity_id")


@pulumi.output_type
class SiteDnsConfigResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsLegacySortOrder":
            suggest = "dns_legacy_sort_order"
        elif key == "dnsAltServer":
            suggest = "dns_alt_server"
        elif key == "dnsMaxCacheTimeout":
            suggest = "dns_max_cache_timeout"
        elif key == "dnsRetryAttemptCount":
            suggest = "dns_retry_attempt_count"
        elif key == "dnsRetryAttemptTimeout":
            suggest = "dns_retry_attempt_timeout"
        elif key == "dnsServers":
            suggest = "dns_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SiteDnsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SiteDnsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SiteDnsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_legacy_sort_order: builtins.bool,
                 dns_alt_server: Optional[builtins.str] = None,
                 dns_max_cache_timeout: Optional[builtins.int] = None,
                 dns_retry_attempt_count: Optional[builtins.int] = None,
                 dns_retry_attempt_timeout: Optional[builtins.int] = None,
                 dns_servers: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool dns_legacy_sort_order: Indicates that sites using Virtual network custom DNS servers are still sorting the list of DNS servers. Read-Only.
        :param builtins.str dns_alt_server: Alternate DNS server to be used by apps. This property replicates the WEBSITE_DNS_ALT_SERVER app setting.
        :param builtins.int dns_max_cache_timeout: Custom time for DNS to be cached in seconds. Allowed range: 0-60. Default is 30 seconds. 0 means caching disabled.
        :param builtins.int dns_retry_attempt_count: Total number of retries for dns lookup. Allowed range: 1-5. Default is 3.
        :param builtins.int dns_retry_attempt_timeout: Timeout for a single dns lookup in seconds. Allowed range: 1-30. Default is 3.
        :param Sequence[builtins.str] dns_servers: List of custom DNS servers to be used by an app for lookups. Maximum 5 dns servers can be set.
        """
        pulumi.set(__self__, "dns_legacy_sort_order", dns_legacy_sort_order)
        if dns_alt_server is not None:
            pulumi.set(__self__, "dns_alt_server", dns_alt_server)
        if dns_max_cache_timeout is not None:
            pulumi.set(__self__, "dns_max_cache_timeout", dns_max_cache_timeout)
        if dns_retry_attempt_count is not None:
            pulumi.set(__self__, "dns_retry_attempt_count", dns_retry_attempt_count)
        if dns_retry_attempt_timeout is not None:
            pulumi.set(__self__, "dns_retry_attempt_timeout", dns_retry_attempt_timeout)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="dnsLegacySortOrder")
    def dns_legacy_sort_order(self) -> builtins.bool:
        """
        Indicates that sites using Virtual network custom DNS servers are still sorting the list of DNS servers. Read-Only.
        """
        return pulumi.get(self, "dns_legacy_sort_order")

    @property
    @pulumi.getter(name="dnsAltServer")
    def dns_alt_server(self) -> Optional[builtins.str]:
        """
        Alternate DNS server to be used by apps. This property replicates the WEBSITE_DNS_ALT_SERVER app setting.
        """
        return pulumi.get(self, "dns_alt_server")

    @property
    @pulumi.getter(name="dnsMaxCacheTimeout")
    def dns_max_cache_timeout(self) -> Optional[builtins.int]:
        """
        Custom time for DNS to be cached in seconds. Allowed range: 0-60. Default is 30 seconds. 0 means caching disabled.
        """
        return pulumi.get(self, "dns_max_cache_timeout")

    @property
    @pulumi.getter(name="dnsRetryAttemptCount")
    def dns_retry_attempt_count(self) -> Optional[builtins.int]:
        """
        Total number of retries for dns lookup. Allowed range: 1-5. Default is 3.
        """
        return pulumi.get(self, "dns_retry_attempt_count")

    @property
    @pulumi.getter(name="dnsRetryAttemptTimeout")
    def dns_retry_attempt_timeout(self) -> Optional[builtins.int]:
        """
        Timeout for a single dns lookup in seconds. Allowed range: 1-30. Default is 3.
        """
        return pulumi.get(self, "dns_retry_attempt_timeout")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[builtins.str]]:
        """
        List of custom DNS servers to be used by an app for lookups. Maximum 5 dns servers can be set.
        """
        return pulumi.get(self, "dns_servers")


@pulumi.output_type
class SiteLimitsResponse(dict):
    """
    Metric limits set on an app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxDiskSizeInMb":
            suggest = "max_disk_size_in_mb"
        elif key == "maxMemoryInMb":
            suggest = "max_memory_in_mb"
        elif key == "maxPercentageCpu":
            suggest = "max_percentage_cpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SiteLimitsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SiteLimitsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SiteLimitsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_disk_size_in_mb: Optional[builtins.float] = None,
                 max_memory_in_mb: Optional[builtins.float] = None,
                 max_percentage_cpu: Optional[builtins.float] = None):
        """
        Metric limits set on an app.
        :param builtins.float max_disk_size_in_mb: Maximum allowed disk size usage in MB.
        :param builtins.float max_memory_in_mb: Maximum allowed memory usage in MB.
        :param builtins.float max_percentage_cpu: Maximum allowed CPU usage percentage.
        """
        if max_disk_size_in_mb is not None:
            pulumi.set(__self__, "max_disk_size_in_mb", max_disk_size_in_mb)
        if max_memory_in_mb is not None:
            pulumi.set(__self__, "max_memory_in_mb", max_memory_in_mb)
        if max_percentage_cpu is not None:
            pulumi.set(__self__, "max_percentage_cpu", max_percentage_cpu)

    @property
    @pulumi.getter(name="maxDiskSizeInMb")
    def max_disk_size_in_mb(self) -> Optional[builtins.float]:
        """
        Maximum allowed disk size usage in MB.
        """
        return pulumi.get(self, "max_disk_size_in_mb")

    @property
    @pulumi.getter(name="maxMemoryInMb")
    def max_memory_in_mb(self) -> Optional[builtins.float]:
        """
        Maximum allowed memory usage in MB.
        """
        return pulumi.get(self, "max_memory_in_mb")

    @property
    @pulumi.getter(name="maxPercentageCpu")
    def max_percentage_cpu(self) -> Optional[builtins.float]:
        """
        Maximum allowed CPU usage percentage.
        """
        return pulumi.get(self, "max_percentage_cpu")


@pulumi.output_type
class SiteMachineKeyResponse(dict):
    """
    MachineKey of an app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decryptionKey":
            suggest = "decryption_key"
        elif key == "validationKey":
            suggest = "validation_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SiteMachineKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SiteMachineKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SiteMachineKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decryption: Optional[builtins.str] = None,
                 decryption_key: Optional[builtins.str] = None,
                 validation: Optional[builtins.str] = None,
                 validation_key: Optional[builtins.str] = None):
        """
        MachineKey of an app.
        :param builtins.str decryption: Algorithm used for decryption.
        :param builtins.str decryption_key: Decryption key.
        :param builtins.str validation: MachineKey validation.
        :param builtins.str validation_key: Validation key.
        """
        if decryption is not None:
            pulumi.set(__self__, "decryption", decryption)
        if decryption_key is not None:
            pulumi.set(__self__, "decryption_key", decryption_key)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)
        if validation_key is not None:
            pulumi.set(__self__, "validation_key", validation_key)

    @property
    @pulumi.getter
    def decryption(self) -> Optional[builtins.str]:
        """
        Algorithm used for decryption.
        """
        return pulumi.get(self, "decryption")

    @property
    @pulumi.getter(name="decryptionKey")
    def decryption_key(self) -> Optional[builtins.str]:
        """
        Decryption key.
        """
        return pulumi.get(self, "decryption_key")

    @property
    @pulumi.getter
    def validation(self) -> Optional[builtins.str]:
        """
        MachineKey validation.
        """
        return pulumi.get(self, "validation")

    @property
    @pulumi.getter(name="validationKey")
    def validation_key(self) -> Optional[builtins.str]:
        """
        Validation key.
        """
        return pulumi.get(self, "validation_key")


@pulumi.output_type
class SkuCapacityResponse(dict):
    """
    Description of the App Service plan scale options.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elasticMaximum":
            suggest = "elastic_maximum"
        elif key == "scaleType":
            suggest = "scale_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SkuCapacityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SkuCapacityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SkuCapacityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default: Optional[builtins.int] = None,
                 elastic_maximum: Optional[builtins.int] = None,
                 maximum: Optional[builtins.int] = None,
                 minimum: Optional[builtins.int] = None,
                 scale_type: Optional[builtins.str] = None):
        """
        Description of the App Service plan scale options.
        :param builtins.int default: Default number of workers for this App Service plan SKU.
        :param builtins.int elastic_maximum: Maximum number of Elastic workers for this App Service plan SKU.
        :param builtins.int maximum: Maximum number of workers for this App Service plan SKU.
        :param builtins.int minimum: Minimum number of workers for this App Service plan SKU.
        :param builtins.str scale_type: Available scale configurations for an App Service plan.
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if elastic_maximum is not None:
            pulumi.set(__self__, "elastic_maximum", elastic_maximum)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if scale_type is not None:
            pulumi.set(__self__, "scale_type", scale_type)

    @property
    @pulumi.getter
    def default(self) -> Optional[builtins.int]:
        """
        Default number of workers for this App Service plan SKU.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter(name="elasticMaximum")
    def elastic_maximum(self) -> Optional[builtins.int]:
        """
        Maximum number of Elastic workers for this App Service plan SKU.
        """
        return pulumi.get(self, "elastic_maximum")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[builtins.int]:
        """
        Maximum number of workers for this App Service plan SKU.
        """
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter
    def minimum(self) -> Optional[builtins.int]:
        """
        Minimum number of workers for this App Service plan SKU.
        """
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter(name="scaleType")
    def scale_type(self) -> Optional[builtins.str]:
        """
        Available scale configurations for an App Service plan.
        """
        return pulumi.get(self, "scale_type")


@pulumi.output_type
class SkuDescriptionResponse(dict):
    """
    Description of a SKU for a scalable resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skuCapacity":
            suggest = "sku_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SkuDescriptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SkuDescriptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SkuDescriptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capabilities: Optional[Sequence['outputs.CapabilityResponse']] = None,
                 capacity: Optional[builtins.int] = None,
                 family: Optional[builtins.str] = None,
                 locations: Optional[Sequence[builtins.str]] = None,
                 name: Optional[builtins.str] = None,
                 size: Optional[builtins.str] = None,
                 sku_capacity: Optional['outputs.SkuCapacityResponse'] = None,
                 tier: Optional[builtins.str] = None):
        """
        Description of a SKU for a scalable resource.
        :param Sequence['CapabilityResponse'] capabilities: Capabilities of the SKU, e.g., is traffic manager enabled?
        :param builtins.int capacity: Current number of instances assigned to the resource.
        :param builtins.str family: Family code of the resource SKU.
        :param Sequence[builtins.str] locations: Locations of the SKU.
        :param builtins.str name: Name of the resource SKU.
        :param builtins.str size: Size specifier of the resource SKU.
        :param 'SkuCapacityResponse' sku_capacity: Min, max, and default scale values of the SKU.
        :param builtins.str tier: Service tier of the resource SKU.
        """
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if sku_capacity is not None:
            pulumi.set(__self__, "sku_capacity", sku_capacity)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence['outputs.CapabilityResponse']]:
        """
        Capabilities of the SKU, e.g., is traffic manager enabled?
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[builtins.int]:
        """
        Current number of instances assigned to the resource.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def family(self) -> Optional[builtins.str]:
        """
        Family code of the resource SKU.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[builtins.str]]:
        """
        Locations of the SKU.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name of the resource SKU.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> Optional[builtins.str]:
        """
        Size specifier of the resource SKU.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="skuCapacity")
    def sku_capacity(self) -> Optional['outputs.SkuCapacityResponse']:
        """
        Min, max, and default scale values of the SKU.
        """
        return pulumi.get(self, "sku_capacity")

    @property
    @pulumi.getter
    def tier(self) -> Optional[builtins.str]:
        """
        Service tier of the resource SKU.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SlotSwapStatusResponse(dict):
    """
    The status of the last successful slot swap operation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationSlotName":
            suggest = "destination_slot_name"
        elif key == "sourceSlotName":
            suggest = "source_slot_name"
        elif key == "timestampUtc":
            suggest = "timestamp_utc"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSwapStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSwapStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSwapStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_slot_name: builtins.str,
                 source_slot_name: builtins.str,
                 timestamp_utc: builtins.str):
        """
        The status of the last successful slot swap operation.
        :param builtins.str destination_slot_name: The destination slot of the last swap operation.
        :param builtins.str source_slot_name: The source slot of the last swap operation.
        :param builtins.str timestamp_utc: The time the last successful slot swap completed.
        """
        pulumi.set(__self__, "destination_slot_name", destination_slot_name)
        pulumi.set(__self__, "source_slot_name", source_slot_name)
        pulumi.set(__self__, "timestamp_utc", timestamp_utc)

    @property
    @pulumi.getter(name="destinationSlotName")
    def destination_slot_name(self) -> builtins.str:
        """
        The destination slot of the last swap operation.
        """
        return pulumi.get(self, "destination_slot_name")

    @property
    @pulumi.getter(name="sourceSlotName")
    def source_slot_name(self) -> builtins.str:
        """
        The source slot of the last swap operation.
        """
        return pulumi.get(self, "source_slot_name")

    @property
    @pulumi.getter(name="timestampUtc")
    def timestamp_utc(self) -> builtins.str:
        """
        The time the last successful slot swap completed.
        """
        return pulumi.get(self, "timestamp_utc")


@pulumi.output_type
class SlowRequestsBasedTriggerResponse(dict):
    """
    Trigger based on request execution time.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeInterval":
            suggest = "time_interval"
        elif key == "timeTaken":
            suggest = "time_taken"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlowRequestsBasedTriggerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlowRequestsBasedTriggerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlowRequestsBasedTriggerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[builtins.int] = None,
                 path: Optional[builtins.str] = None,
                 time_interval: Optional[builtins.str] = None,
                 time_taken: Optional[builtins.str] = None):
        """
        Trigger based on request execution time.
        :param builtins.int count: Request Count.
        :param builtins.str path: Request Path.
        :param builtins.str time_interval: Time interval.
        :param builtins.str time_taken: Time taken.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)
        if time_taken is not None:
            pulumi.set(__self__, "time_taken", time_taken)

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.int]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        Request Path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[builtins.str]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> Optional[builtins.str]:
        """
        Time taken.
        """
        return pulumi.get(self, "time_taken")


@pulumi.output_type
class StaticSiteBuildPropertiesResponse(dict):
    """
    Build properties for the static site.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiBuildCommand":
            suggest = "api_build_command"
        elif key == "apiLocation":
            suggest = "api_location"
        elif key == "appArtifactLocation":
            suggest = "app_artifact_location"
        elif key == "appBuildCommand":
            suggest = "app_build_command"
        elif key == "appLocation":
            suggest = "app_location"
        elif key == "githubActionSecretNameOverride":
            suggest = "github_action_secret_name_override"
        elif key == "outputLocation":
            suggest = "output_location"
        elif key == "skipGithubActionWorkflowGeneration":
            suggest = "skip_github_action_workflow_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticSiteBuildPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticSiteBuildPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticSiteBuildPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_build_command: Optional[builtins.str] = None,
                 api_location: Optional[builtins.str] = None,
                 app_artifact_location: Optional[builtins.str] = None,
                 app_build_command: Optional[builtins.str] = None,
                 app_location: Optional[builtins.str] = None,
                 github_action_secret_name_override: Optional[builtins.str] = None,
                 output_location: Optional[builtins.str] = None,
                 skip_github_action_workflow_generation: Optional[builtins.bool] = None):
        """
        Build properties for the static site.
        :param builtins.str api_build_command: A custom command to run during deployment of the Azure Functions API application.
        :param builtins.str api_location: The path to the api code within the repository.
        :param builtins.str app_artifact_location: Deprecated: The path of the app artifacts after building (deprecated in favor of OutputLocation)
        :param builtins.str app_build_command: A custom command to run during deployment of the static content application.
        :param builtins.str app_location: The path to the app code within the repository.
        :param builtins.str github_action_secret_name_override: Github Action secret name override.
        :param builtins.str output_location: The output path of the app after building.
        :param builtins.bool skip_github_action_workflow_generation: Skip Github Action workflow generation.
        """
        if api_build_command is not None:
            pulumi.set(__self__, "api_build_command", api_build_command)
        if api_location is not None:
            pulumi.set(__self__, "api_location", api_location)
        if app_artifact_location is not None:
            pulumi.set(__self__, "app_artifact_location", app_artifact_location)
        if app_build_command is not None:
            pulumi.set(__self__, "app_build_command", app_build_command)
        if app_location is not None:
            pulumi.set(__self__, "app_location", app_location)
        if github_action_secret_name_override is not None:
            pulumi.set(__self__, "github_action_secret_name_override", github_action_secret_name_override)
        if output_location is not None:
            pulumi.set(__self__, "output_location", output_location)
        if skip_github_action_workflow_generation is not None:
            pulumi.set(__self__, "skip_github_action_workflow_generation", skip_github_action_workflow_generation)

    @property
    @pulumi.getter(name="apiBuildCommand")
    def api_build_command(self) -> Optional[builtins.str]:
        """
        A custom command to run during deployment of the Azure Functions API application.
        """
        return pulumi.get(self, "api_build_command")

    @property
    @pulumi.getter(name="apiLocation")
    def api_location(self) -> Optional[builtins.str]:
        """
        The path to the api code within the repository.
        """
        return pulumi.get(self, "api_location")

    @property
    @pulumi.getter(name="appArtifactLocation")
    def app_artifact_location(self) -> Optional[builtins.str]:
        """
        Deprecated: The path of the app artifacts after building (deprecated in favor of OutputLocation)
        """
        return pulumi.get(self, "app_artifact_location")

    @property
    @pulumi.getter(name="appBuildCommand")
    def app_build_command(self) -> Optional[builtins.str]:
        """
        A custom command to run during deployment of the static content application.
        """
        return pulumi.get(self, "app_build_command")

    @property
    @pulumi.getter(name="appLocation")
    def app_location(self) -> Optional[builtins.str]:
        """
        The path to the app code within the repository.
        """
        return pulumi.get(self, "app_location")

    @property
    @pulumi.getter(name="githubActionSecretNameOverride")
    def github_action_secret_name_override(self) -> Optional[builtins.str]:
        """
        Github Action secret name override.
        """
        return pulumi.get(self, "github_action_secret_name_override")

    @property
    @pulumi.getter(name="outputLocation")
    def output_location(self) -> Optional[builtins.str]:
        """
        The output path of the app after building.
        """
        return pulumi.get(self, "output_location")

    @property
    @pulumi.getter(name="skipGithubActionWorkflowGeneration")
    def skip_github_action_workflow_generation(self) -> Optional[builtins.bool]:
        """
        Skip Github Action workflow generation.
        """
        return pulumi.get(self, "skip_github_action_workflow_generation")


@pulumi.output_type
class StaticSiteDatabaseConnectionConfigurationFileOverviewResponse(dict):
    """
    A database connection configuration file
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileName":
            suggest = "file_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticSiteDatabaseConnectionConfigurationFileOverviewResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticSiteDatabaseConnectionConfigurationFileOverviewResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticSiteDatabaseConnectionConfigurationFileOverviewResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contents: builtins.str,
                 file_name: builtins.str,
                 type: builtins.str):
        """
        A database connection configuration file
        :param builtins.str contents: The Base64 encoding of the file contents.
        :param builtins.str file_name: The name of the configuration file.
        :param builtins.str type: The type of configuration file.
        """
        pulumi.set(__self__, "contents", contents)
        pulumi.set(__self__, "file_name", file_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def contents(self) -> builtins.str:
        """
        The Base64 encoding of the file contents.
        """
        return pulumi.get(self, "contents")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> builtins.str:
        """
        The name of the configuration file.
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of configuration file.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class StaticSiteLinkedBackendResponse(dict):
    """
    Static Site Linked Backend ARM resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdOn":
            suggest = "created_on"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "backendResourceId":
            suggest = "backend_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticSiteLinkedBackendResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticSiteLinkedBackendResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticSiteLinkedBackendResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_on: builtins.str,
                 provisioning_state: builtins.str,
                 backend_resource_id: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None):
        """
        Static Site Linked Backend ARM resource.
        :param builtins.str created_on: The date and time on which the backend was linked to the static site.
        :param builtins.str provisioning_state: The provisioning state of the linking process.
        :param builtins.str backend_resource_id: The resource id of the backend linked to the static site
        :param builtins.str region: The region of the backend linked to the static site
        """
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if backend_resource_id is not None:
            pulumi.set(__self__, "backend_resource_id", backend_resource_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> builtins.str:
        """
        The date and time on which the backend was linked to the static site.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        The provisioning state of the linking process.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="backendResourceId")
    def backend_resource_id(self) -> Optional[builtins.str]:
        """
        The resource id of the backend linked to the static site
        """
        return pulumi.get(self, "backend_resource_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        The region of the backend linked to the static site
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class StaticSiteTemplateOptionsResponse(dict):
    """
    Template Options for the static site.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPrivate":
            suggest = "is_private"
        elif key == "repositoryName":
            suggest = "repository_name"
        elif key == "templateRepositoryUrl":
            suggest = "template_repository_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticSiteTemplateOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticSiteTemplateOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticSiteTemplateOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[builtins.str] = None,
                 is_private: Optional[builtins.bool] = None,
                 owner: Optional[builtins.str] = None,
                 repository_name: Optional[builtins.str] = None,
                 template_repository_url: Optional[builtins.str] = None):
        """
        Template Options for the static site.
        :param builtins.str description: Description of the newly generated repository.
        :param builtins.bool is_private: Whether or not the newly generated repository is a private repository. Defaults to false (i.e. public).
        :param builtins.str owner: Owner of the newly generated repository.
        :param builtins.str repository_name: Name of the newly generated repository.
        :param builtins.str template_repository_url: URL of the template repository. The newly generated repository will be based on this one.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_private is not None:
            pulumi.set(__self__, "is_private", is_private)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if repository_name is not None:
            pulumi.set(__self__, "repository_name", repository_name)
        if template_repository_url is not None:
            pulumi.set(__self__, "template_repository_url", template_repository_url)

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the newly generated repository.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="isPrivate")
    def is_private(self) -> Optional[builtins.bool]:
        """
        Whether or not the newly generated repository is a private repository. Defaults to false (i.e. public).
        """
        return pulumi.get(self, "is_private")

    @property
    @pulumi.getter
    def owner(self) -> Optional[builtins.str]:
        """
        Owner of the newly generated repository.
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[builtins.str]:
        """
        Name of the newly generated repository.
        """
        return pulumi.get(self, "repository_name")

    @property
    @pulumi.getter(name="templateRepositoryUrl")
    def template_repository_url(self) -> Optional[builtins.str]:
        """
        URL of the template repository. The newly generated repository will be based on this one.
        """
        return pulumi.get(self, "template_repository_url")


@pulumi.output_type
class StaticSiteUserARMResourceResponse(dict):
    """
    Static Site User ARM resource.
    """
    def __init__(__self__, *,
                 display_name: builtins.str,
                 id: builtins.str,
                 name: builtins.str,
                 provider: builtins.str,
                 type: builtins.str,
                 user_id: builtins.str,
                 kind: Optional[builtins.str] = None,
                 roles: Optional[builtins.str] = None):
        """
        Static Site User ARM resource.
        :param builtins.str display_name: The display name for the static site user.
        :param builtins.str id: Resource Id.
        :param builtins.str name: Resource Name.
        :param builtins.str provider: The identity provider for the static site user.
        :param builtins.str type: Resource type.
        :param builtins.str user_id: The user id for the static site user.
        :param builtins.str kind: Kind of resource.
        :param builtins.str roles: The roles for the static site user, in free-form string format
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_id", user_id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> builtins.str:
        """
        The display name for the static site user.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def provider(self) -> builtins.str:
        """
        The identity provider for the static site user.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> builtins.str:
        """
        The user id for the static site user.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def roles(self) -> Optional[builtins.str]:
        """
        The roles for the static site user, in free-form string format
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class StaticSiteUserProvidedFunctionAppResponse(dict):
    """
    A static site user provided function.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdOn":
            suggest = "created_on"
        elif key == "functionAppRegion":
            suggest = "function_app_region"
        elif key == "functionAppResourceId":
            suggest = "function_app_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticSiteUserProvidedFunctionAppResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticSiteUserProvidedFunctionAppResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticSiteUserProvidedFunctionAppResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_on: builtins.str,
                 id: builtins.str,
                 name: builtins.str,
                 type: builtins.str,
                 function_app_region: Optional[builtins.str] = None,
                 function_app_resource_id: Optional[builtins.str] = None,
                 kind: Optional[builtins.str] = None):
        """
        A static site user provided function.
        :param builtins.str created_on: The date and time on which the function app was registered with the static site.
        :param builtins.str id: Resource Id.
        :param builtins.str name: Resource Name.
        :param builtins.str type: Resource type.
        :param builtins.str function_app_region: The region of the function app registered with the static site
        :param builtins.str function_app_resource_id: The resource id of the function app registered with the static site
        :param builtins.str kind: Kind of resource.
        """
        pulumi.set(__self__, "created_on", created_on)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if function_app_region is not None:
            pulumi.set(__self__, "function_app_region", function_app_region)
        if function_app_resource_id is not None:
            pulumi.set(__self__, "function_app_resource_id", function_app_resource_id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter(name="createdOn")
    def created_on(self) -> builtins.str:
        """
        The date and time on which the function app was registered with the static site.
        """
        return pulumi.get(self, "created_on")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="functionAppRegion")
    def function_app_region(self) -> Optional[builtins.str]:
        """
        The region of the function app registered with the static site
        """
        return pulumi.get(self, "function_app_region")

    @property
    @pulumi.getter(name="functionAppResourceId")
    def function_app_resource_id(self) -> Optional[builtins.str]:
        """
        The resource id of the function app registered with the static site
        """
        return pulumi.get(self, "function_app_resource_id")

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class StatusCodesBasedTriggerResponse(dict):
    """
    Trigger based on status code.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subStatus":
            suggest = "sub_status"
        elif key == "timeInterval":
            suggest = "time_interval"
        elif key == "win32Status":
            suggest = "win32_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatusCodesBasedTriggerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatusCodesBasedTriggerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatusCodesBasedTriggerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[builtins.int] = None,
                 path: Optional[builtins.str] = None,
                 status: Optional[builtins.int] = None,
                 sub_status: Optional[builtins.int] = None,
                 time_interval: Optional[builtins.str] = None,
                 win32_status: Optional[builtins.int] = None):
        """
        Trigger based on status code.
        :param builtins.int count: Request Count.
        :param builtins.str path: Request Path
        :param builtins.int status: HTTP status code.
        :param builtins.int sub_status: Request Sub Status.
        :param builtins.str time_interval: Time interval.
        :param builtins.int win32_status: Win32 error code.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)
        if win32_status is not None:
            pulumi.set(__self__, "win32_status", win32_status)

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.int]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        """
        Request Path
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.int]:
        """
        HTTP status code.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[builtins.int]:
        """
        Request Sub Status.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[builtins.str]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")

    @property
    @pulumi.getter(name="win32Status")
    def win32_status(self) -> Optional[builtins.int]:
        """
        Win32 error code.
        """
        return pulumi.get(self, "win32_status")


@pulumi.output_type
class StatusCodesRangeBasedTriggerResponse(dict):
    """
    Trigger based on range of status codes.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCodes":
            suggest = "status_codes"
        elif key == "timeInterval":
            suggest = "time_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatusCodesRangeBasedTriggerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatusCodesRangeBasedTriggerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatusCodesRangeBasedTriggerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[builtins.int] = None,
                 path: Optional[builtins.str] = None,
                 status_codes: Optional[builtins.str] = None,
                 time_interval: Optional[builtins.str] = None):
        """
        Trigger based on range of status codes.
        :param builtins.int count: Request Count.
        :param builtins.str status_codes: HTTP status code.
        :param builtins.str time_interval: Time interval.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.int]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def path(self) -> Optional[builtins.str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[builtins.str]:
        """
        HTTP status code.
        """
        return pulumi.get(self, "status_codes")

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[builtins.str]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")


@pulumi.output_type
class TokenStoreResponse(dict):
    """
    The configuration settings of the token store.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "fileSystem":
            suggest = "file_system"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TokenStoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TokenStoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TokenStoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.BlobStorageTokenStoreResponse'] = None,
                 enabled: Optional[builtins.bool] = None,
                 file_system: Optional['outputs.FileSystemTokenStoreResponse'] = None,
                 token_refresh_extension_hours: Optional[builtins.float] = None):
        """
        The configuration settings of the token store.
        :param 'BlobStorageTokenStoreResponse' azure_blob_storage: The configuration settings of the storage of the tokens if blob storage is used.
        :param builtins.bool enabled: <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
                The default is <code>false</code>.
        :param 'FileSystemTokenStoreResponse' file_system: The configuration settings of the storage of the tokens if a file system is used.
        :param builtins.float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to
               call the token refresh API. The default is 72 hours.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.BlobStorageTokenStoreResponse']:
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        """
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
         The default is <code>false</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional['outputs.FileSystemTokenStoreResponse']:
        """
        The configuration settings of the storage of the tokens if a file system is used.
        """
        return pulumi.get(self, "file_system")

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[builtins.float]:
        """
        The number of hours after session token expiration that a session token can be used to
        call the token refresh API. The default is 72 hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")


@pulumi.output_type
class TwitterRegistrationResponse(dict):
    """
    The configuration settings of the app registration for the Twitter provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TwitterRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TwitterRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TwitterRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: Optional[builtins.str] = None,
                 consumer_secret_setting_name: Optional[builtins.str] = None):
        """
        The configuration settings of the app registration for the Twitter provider.
        :param builtins.str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
               This setting is required for enabling Twitter Sign-In.
               Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        :param builtins.str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
               application used for sign-in.
        """
        if consumer_key is not None:
            pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> Optional[builtins.str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        This setting is required for enabling Twitter Sign-In.
        Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[builtins.str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
        application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class TwitterResponse(dict):
    """
    The configuration settings of the Twitter provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 registration: Optional['outputs.TwitterRegistrationResponse'] = None):
        """
        The configuration settings of the Twitter provider.
        :param builtins.bool enabled: <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'TwitterRegistrationResponse' registration: The configuration settings of the app registration for the Twitter provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def registration(self) -> Optional['outputs.TwitterRegistrationResponse']:
        """
        The configuration settings of the app registration for the Twitter provider.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User Assigned identity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: builtins.str,
                 principal_id: builtins.str):
        """
        User Assigned identity.
        :param builtins.str client_id: Client Id of user assigned identity
        :param builtins.str principal_id: Principal Id of user assigned identity
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> builtins.str:
        """
        Client Id of user assigned identity
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        Principal Id of user assigned identity
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VirtualApplicationResponse(dict):
    """
    Virtual application in an app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "physicalPath":
            suggest = "physical_path"
        elif key == "preloadEnabled":
            suggest = "preload_enabled"
        elif key == "virtualDirectories":
            suggest = "virtual_directories"
        elif key == "virtualPath":
            suggest = "virtual_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualApplicationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualApplicationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualApplicationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 physical_path: Optional[builtins.str] = None,
                 preload_enabled: Optional[builtins.bool] = None,
                 virtual_directories: Optional[Sequence['outputs.VirtualDirectoryResponse']] = None,
                 virtual_path: Optional[builtins.str] = None):
        """
        Virtual application in an app.
        :param builtins.str physical_path: Physical path.
        :param builtins.bool preload_enabled: <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
        :param Sequence['VirtualDirectoryResponse'] virtual_directories: Virtual directories for virtual application.
        :param builtins.str virtual_path: Virtual path.
        """
        if physical_path is not None:
            pulumi.set(__self__, "physical_path", physical_path)
        if preload_enabled is not None:
            pulumi.set(__self__, "preload_enabled", preload_enabled)
        if virtual_directories is not None:
            pulumi.set(__self__, "virtual_directories", virtual_directories)
        if virtual_path is not None:
            pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[builtins.str]:
        """
        Physical path.
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter(name="preloadEnabled")
    def preload_enabled(self) -> Optional[builtins.bool]:
        """
        <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "preload_enabled")

    @property
    @pulumi.getter(name="virtualDirectories")
    def virtual_directories(self) -> Optional[Sequence['outputs.VirtualDirectoryResponse']]:
        """
        Virtual directories for virtual application.
        """
        return pulumi.get(self, "virtual_directories")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[builtins.str]:
        """
        Virtual path.
        """
        return pulumi.get(self, "virtual_path")


@pulumi.output_type
class VirtualDirectoryResponse(dict):
    """
    Directory for virtual application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "physicalPath":
            suggest = "physical_path"
        elif key == "virtualPath":
            suggest = "virtual_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualDirectoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualDirectoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualDirectoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 physical_path: Optional[builtins.str] = None,
                 virtual_path: Optional[builtins.str] = None):
        """
        Directory for virtual application.
        :param builtins.str physical_path: Physical path.
        :param builtins.str virtual_path: Path to virtual application.
        """
        if physical_path is not None:
            pulumi.set(__self__, "physical_path", physical_path)
        if virtual_path is not None:
            pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[builtins.str]:
        """
        Physical path.
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[builtins.str]:
        """
        Path to virtual application.
        """
        return pulumi.get(self, "virtual_path")


@pulumi.output_type
class VirtualNetworkProfileResponse(dict):
    """
    Specification for using a Virtual Network.
    """
    def __init__(__self__, *,
                 id: builtins.str,
                 name: builtins.str,
                 type: builtins.str,
                 subnet: Optional[builtins.str] = None):
        """
        Specification for using a Virtual Network.
        :param builtins.str id: Resource id of the Virtual Network.
        :param builtins.str name: Name of the Virtual Network (read-only).
        :param builtins.str type: Resource type of the Virtual Network (read-only).
        :param builtins.str subnet: Subnet within the Virtual Network.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Resource id of the Virtual Network.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the Virtual Network (read-only).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type of the Virtual Network (read-only).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def subnet(self) -> Optional[builtins.str]:
        """
        Subnet within the Virtual Network.
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class VnetRouteResponse(dict):
    """
    Virtual Network route contract used to pass routing information for a Virtual Network.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "routeType":
            suggest = "route_type"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VnetRouteResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VnetRouteResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VnetRouteResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 name: builtins.str,
                 type: builtins.str,
                 end_address: Optional[builtins.str] = None,
                 kind: Optional[builtins.str] = None,
                 route_type: Optional[builtins.str] = None,
                 start_address: Optional[builtins.str] = None):
        """
        Virtual Network route contract used to pass routing information for a Virtual Network.
        :param builtins.str id: Resource Id.
        :param builtins.str name: Resource Name.
        :param builtins.str type: Resource type.
        :param builtins.str end_address: The ending address for this route. If the start address is specified in CIDR notation, this must be omitted.
        :param builtins.str kind: Kind of resource.
        :param builtins.str route_type: The type of route this is:
               DEFAULT - By default, every app has routes to the local address ranges specified by RFC1918
               INHERITED - Routes inherited from the real Virtual Network routes
               STATIC - Static route set on the app only
               
               These values will be used for syncing an app's routes with those from a Virtual Network.
        :param builtins.str start_address: The starting address for this route. This may also include a CIDR notation, in which case the end address must not be specified.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if end_address is not None:
            pulumi.set(__self__, "end_address", end_address)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if route_type is not None:
            pulumi.set(__self__, "route_type", route_type)
        if start_address is not None:
            pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> Optional[builtins.str]:
        """
        The ending address for this route. If the start address is specified in CIDR notation, this must be omitted.
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter
    def kind(self) -> Optional[builtins.str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="routeType")
    def route_type(self) -> Optional[builtins.str]:
        """
        The type of route this is:
        DEFAULT - By default, every app has routes to the local address ranges specified by RFC1918
        INHERITED - Routes inherited from the real Virtual Network routes
        STATIC - Static route set on the app only

        These values will be used for syncing an app's routes with those from a Virtual Network.
        """
        return pulumi.get(self, "route_type")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> Optional[builtins.str]:
        """
        The starting address for this route. This may also include a CIDR notation, in which case the end address must not be specified.
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class VolumeMountResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerMountPath":
            suggest = "container_mount_path"
        elif key == "volumeSubPath":
            suggest = "volume_sub_path"
        elif key == "readOnly":
            suggest = "read_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeMountResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeMountResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeMountResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_mount_path: builtins.str,
                 volume_sub_path: builtins.str,
                 data: Optional[builtins.str] = None,
                 read_only: Optional[builtins.bool] = None):
        """
        :param builtins.str container_mount_path: Target path on the container where volume is mounted on
        :param builtins.str volume_sub_path: Sub path in the volume where volume is mounted from.
        :param builtins.str data: Config Data to be mounted on the volume
        :param builtins.bool read_only: Boolean to specify if the mount is read only on the container
        """
        pulumi.set(__self__, "container_mount_path", container_mount_path)
        pulumi.set(__self__, "volume_sub_path", volume_sub_path)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="containerMountPath")
    def container_mount_path(self) -> builtins.str:
        """
        Target path on the container where volume is mounted on
        """
        return pulumi.get(self, "container_mount_path")

    @property
    @pulumi.getter(name="volumeSubPath")
    def volume_sub_path(self) -> builtins.str:
        """
        Sub path in the volume where volume is mounted from.
        """
        return pulumi.get(self, "volume_sub_path")

    @property
    @pulumi.getter
    def data(self) -> Optional[builtins.str]:
        """
        Config Data to be mounted on the volume
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[builtins.bool]:
        """
        Boolean to specify if the mount is read only on the container
        """
        return pulumi.get(self, "read_only")


@pulumi.output_type
class WorkflowEnvelopeResponseProperties(dict):
    """
    Additional workflow properties.
    """
    def __init__(__self__, *,
                 files: Optional[Mapping[str, Any]] = None,
                 flow_state: Optional[builtins.str] = None,
                 health: Optional['outputs.WorkflowHealthResponse'] = None):
        """
        Additional workflow properties.
        :param Mapping[str, Any] files: Gets or sets the files.
        :param builtins.str flow_state: Gets or sets the state of the workflow.
        :param 'WorkflowHealthResponse' health: Gets or sets workflow health.
        """
        if files is not None:
            pulumi.set(__self__, "files", files)
        if flow_state is not None:
            pulumi.set(__self__, "flow_state", flow_state)
        if health is not None:
            pulumi.set(__self__, "health", health)

    @property
    @pulumi.getter
    def files(self) -> Optional[Mapping[str, Any]]:
        """
        Gets or sets the files.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter(name="flowState")
    def flow_state(self) -> Optional[builtins.str]:
        """
        Gets or sets the state of the workflow.
        """
        return pulumi.get(self, "flow_state")

    @property
    @pulumi.getter
    def health(self) -> Optional['outputs.WorkflowHealthResponse']:
        """
        Gets or sets workflow health.
        """
        return pulumi.get(self, "health")


@pulumi.output_type
class WorkflowHealthResponse(dict):
    """
    Represents the workflow health.
    """
    def __init__(__self__, *,
                 state: builtins.str,
                 error: Optional['outputs.ErrorEntityResponse'] = None):
        """
        Represents the workflow health.
        :param builtins.str state: Gets or sets the workflow health state.
        :param 'ErrorEntityResponse' error: Gets or sets the workflow error.
        """
        pulumi.set(__self__, "state", state)
        if error is not None:
            pulumi.set(__self__, "error", error)

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        Gets or sets the workflow health state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.ErrorEntityResponse']:
        """
        Gets or sets the workflow error.
        """
        return pulumi.get(self, "error")


@pulumi.output_type
class WorkflowTriggerListCallbackUrlQueriesResponse(dict):
    """
    Gets the workflow trigger callback URL query parameters.
    """
    def __init__(__self__, *,
                 api_version: Optional[builtins.str] = None,
                 se: Optional[builtins.str] = None,
                 sig: Optional[builtins.str] = None,
                 sp: Optional[builtins.str] = None,
                 sv: Optional[builtins.str] = None):
        """
        Gets the workflow trigger callback URL query parameters.
        :param builtins.str api_version: The api version.
        :param builtins.str se: The SAS timestamp.
        :param builtins.str sig: The SAS signature.
        :param builtins.str sp: The SAS permissions.
        :param builtins.str sv: The SAS version.
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if se is not None:
            pulumi.set(__self__, "se", se)
        if sig is not None:
            pulumi.set(__self__, "sig", sig)
        if sp is not None:
            pulumi.set(__self__, "sp", sp)
        if sv is not None:
            pulumi.set(__self__, "sv", sv)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[builtins.str]:
        """
        The api version.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter
    def se(self) -> Optional[builtins.str]:
        """
        The SAS timestamp.
        """
        return pulumi.get(self, "se")

    @property
    @pulumi.getter
    def sig(self) -> Optional[builtins.str]:
        """
        The SAS signature.
        """
        return pulumi.get(self, "sig")

    @property
    @pulumi.getter
    def sp(self) -> Optional[builtins.str]:
        """
        The SAS permissions.
        """
        return pulumi.get(self, "sp")

    @property
    @pulumi.getter
    def sv(self) -> Optional[builtins.str]:
        """
        The SAS version.
        """
        return pulumi.get(self, "sv")


@pulumi.output_type
class WsdlDefinitionResponse(dict):
    """
    The WSDL definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "importMethod":
            suggest = "import_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WsdlDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WsdlDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WsdlDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: Optional[builtins.str] = None,
                 import_method: Optional[builtins.str] = None,
                 service: Optional['outputs.WsdlServiceResponse'] = None,
                 url: Optional[builtins.str] = None):
        """
        The WSDL definition
        :param builtins.str content: The WSDL content
        :param builtins.str import_method: The WSDL import method
        :param 'WsdlServiceResponse' service: The service with name and endpoint names
        :param builtins.str url: The WSDL URL
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if import_method is not None:
            pulumi.set(__self__, "import_method", import_method)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def content(self) -> Optional[builtins.str]:
        """
        The WSDL content
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="importMethod")
    def import_method(self) -> Optional[builtins.str]:
        """
        The WSDL import method
        """
        return pulumi.get(self, "import_method")

    @property
    @pulumi.getter
    def service(self) -> Optional['outputs.WsdlServiceResponse']:
        """
        The service with name and endpoint names
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def url(self) -> Optional[builtins.str]:
        """
        The WSDL URL
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WsdlServiceResponse(dict):
    """
    The service with name and endpoint names
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qualifiedName":
            suggest = "qualified_name"
        elif key == "endpointQualifiedNames":
            suggest = "endpoint_qualified_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WsdlServiceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WsdlServiceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WsdlServiceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 qualified_name: builtins.str,
                 endpoint_qualified_names: Optional[Sequence[builtins.str]] = None):
        """
        The service with name and endpoint names
        :param builtins.str qualified_name: The service's qualified name
        :param Sequence[builtins.str] endpoint_qualified_names: List of the endpoints' qualified names
        """
        pulumi.set(__self__, "qualified_name", qualified_name)
        if endpoint_qualified_names is not None:
            pulumi.set(__self__, "endpoint_qualified_names", endpoint_qualified_names)

    @property
    @pulumi.getter(name="qualifiedName")
    def qualified_name(self) -> builtins.str:
        """
        The service's qualified name
        """
        return pulumi.get(self, "qualified_name")

    @property
    @pulumi.getter(name="endpointQualifiedNames")
    def endpoint_qualified_names(self) -> Optional[Sequence[builtins.str]]:
        """
        List of the endpoints' qualified names
        """
        return pulumi.get(self, "endpoint_qualified_names")


