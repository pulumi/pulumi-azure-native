# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'AllowedAudiencesValidationArgs',
    'ApiDefinitionInfoArgs',
    'ApiManagementConfigArgs',
    'AppRegistrationArgs',
    'ApplicationLogsConfigArgs',
    'AuthPlatformArgs',
    'AutoHealActionsArgs',
    'AutoHealCustomActionArgs',
    'AutoHealRulesArgs',
    'AutoHealTriggersArgs',
    'AzureActiveDirectoryLoginArgs',
    'AzureActiveDirectoryRegistrationArgs',
    'AzureActiveDirectoryValidationArgs',
    'AzureActiveDirectoryArgs',
    'AzureBlobStorageApplicationLogsConfigArgs',
    'AzureBlobStorageHttpLogsConfigArgs',
    'AzureStorageInfoValueArgs',
    'AzureTableStorageApplicationLogsConfigArgs',
    'BackupSchedule',
    'BackupScheduleArgs',
    'BlobStorageTokenStoreArgs',
    'CapabilityArgs',
    'ClientRegistrationArgs',
    'CloningInfoArgs',
    'ConnStringInfoArgs',
    'ConnStringValueTypePairArgs',
    'CookieExpirationArgs',
    'CorsSettingsArgs',
    'CustomOpenIdConnectProviderArgs',
    'DatabaseBackupSetting',
    'DatabaseBackupSettingArgs',
    'EnabledConfigArgs',
    'ExperimentsArgs',
    'FacebookArgs',
    'FileSystemApplicationLogsConfigArgs',
    'FileSystemHttpLogsConfigArgs',
    'FileSystemTokenStoreArgs',
    'ForwardProxyArgs',
    'GitHubArgs',
    'GlobalValidationArgs',
    'GoogleArgs',
    'HandlerMappingArgs',
    'HostNameSslStateArgs',
    'HostingEnvironmentProfileArgs',
    'HttpLogsConfigArgs',
    'HttpSettingsRoutesArgs',
    'HttpSettingsArgs',
    'IdentityProvidersArgs',
    'IpSecurityRestrictionArgs',
    'JwtClaimChecksArgs',
    'LoginRoutesArgs',
    'LoginScopesArgs',
    'LoginArgs',
    'ManagedServiceIdentityArgs',
    'NameValuePairArgs',
    'NetworkAccessControlEntryArgs',
    'NonceArgs',
    'OpenIdConnectClientCredentialArgs',
    'OpenIdConnectConfigArgs',
    'OpenIdConnectLoginArgs',
    'OpenIdConnectRegistrationArgs',
    'PrivateLinkConnectionStateArgs',
    'PushSettingsArgs',
    'RampUpRuleArgs',
    'RequestsBasedTriggerArgs',
    'SiteConfigArgs',
    'SiteLimitsArgs',
    'SkuCapacityArgs',
    'SkuDescriptionArgs',
    'SlowRequestsBasedTriggerArgs',
    'StaticSiteBuildPropertiesArgs',
    'StatusCodesBasedTriggerArgs',
    'TokenStoreArgs',
    'TwitterRegistrationArgs',
    'TwitterArgs',
    'VirtualApplicationArgs',
    'VirtualDirectoryArgs',
    'VirtualNetworkProfileArgs',
    'WorkerPoolArgs',
]

@pulumi.input_type
class AllowedAudiencesValidationArgs:
    def __init__(__self__, *,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        AllowedAudiencesValidationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_audiences=allowed_audiences,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedAudiences' in kwargs:
            allowed_audiences = kwargs['allowedAudiences']

        if allowed_audiences is not None:
            _setter("allowed_audiences", allowed_audiences)
        if kind is not None:
            _setter("kind", kind)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


@pulumi.input_type
class ApiDefinitionInfoArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[str]] = None):
        """
        Information about the formal API definition for the app.
        :param pulumi.Input[str] url: The URL of the API definition.
        """
        ApiDefinitionInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the API definition.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class ApiManagementConfigArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Azure API management (APIM) configuration linked to the app.
        :param pulumi.Input[str] id: APIM-Api Identifier.
        """
        ApiManagementConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        APIM-Api Identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class AppRegistrationArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[str]] = None,
                 app_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        AppRegistrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_id=app_id,
            app_secret_setting_name=app_secret_setting_name,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_id: Optional[pulumi.Input[str]] = None,
             app_secret_setting_name: Optional[pulumi.Input[str]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'appId' in kwargs:
            app_id = kwargs['appId']
        if 'appSecretSettingName' in kwargs:
            app_secret_setting_name = kwargs['appSecretSettingName']

        if app_id is not None:
            _setter("app_id", app_id)
        if app_secret_setting_name is not None:
            _setter("app_secret_setting_name", app_secret_setting_name)
        if kind is not None:
            _setter("kind", kind)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret_setting_name", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


@pulumi.input_type
class ApplicationLogsConfigArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['AzureBlobStorageApplicationLogsConfigArgs']] = None,
                 azure_table_storage: Optional[pulumi.Input['AzureTableStorageApplicationLogsConfigArgs']] = None,
                 file_system: Optional[pulumi.Input['FileSystemApplicationLogsConfigArgs']] = None):
        """
        Application logs configuration.
        :param pulumi.Input['AzureBlobStorageApplicationLogsConfigArgs'] azure_blob_storage: Application logs to blob storage configuration.
        :param pulumi.Input['AzureTableStorageApplicationLogsConfigArgs'] azure_table_storage: Application logs to azure table storage configuration.
        :param pulumi.Input['FileSystemApplicationLogsConfigArgs'] file_system: Application logs to file system configuration.
        """
        ApplicationLogsConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_blob_storage=azure_blob_storage,
            azure_table_storage=azure_table_storage,
            file_system=file_system,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_blob_storage: Optional[pulumi.Input['AzureBlobStorageApplicationLogsConfigArgs']] = None,
             azure_table_storage: Optional[pulumi.Input['AzureTableStorageApplicationLogsConfigArgs']] = None,
             file_system: Optional[pulumi.Input['FileSystemApplicationLogsConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'azureBlobStorage' in kwargs:
            azure_blob_storage = kwargs['azureBlobStorage']
        if 'azureTableStorage' in kwargs:
            azure_table_storage = kwargs['azureTableStorage']
        if 'fileSystem' in kwargs:
            file_system = kwargs['fileSystem']

        if azure_blob_storage is not None:
            _setter("azure_blob_storage", azure_blob_storage)
        if azure_table_storage is not None:
            _setter("azure_table_storage", azure_table_storage)
        if file_system is not None:
            _setter("file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['AzureBlobStorageApplicationLogsConfigArgs']]:
        """
        Application logs to blob storage configuration.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['AzureBlobStorageApplicationLogsConfigArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter(name="azureTableStorage")
    def azure_table_storage(self) -> Optional[pulumi.Input['AzureTableStorageApplicationLogsConfigArgs']]:
        """
        Application logs to azure table storage configuration.
        """
        return pulumi.get(self, "azure_table_storage")

    @azure_table_storage.setter
    def azure_table_storage(self, value: Optional[pulumi.Input['AzureTableStorageApplicationLogsConfigArgs']]):
        pulumi.set(self, "azure_table_storage", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input['FileSystemApplicationLogsConfigArgs']]:
        """
        Application logs to file system configuration.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input['FileSystemApplicationLogsConfigArgs']]):
        pulumi.set(self, "file_system", value)


@pulumi.input_type
class AuthPlatformArgs:
    def __init__(__self__, *,
                 config_file_path: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        AuthPlatformArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_file_path=config_file_path,
            enabled=enabled,
            kind=kind,
            runtime_version=runtime_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_file_path: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             runtime_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'configFilePath' in kwargs:
            config_file_path = kwargs['configFilePath']
        if 'runtimeVersion' in kwargs:
            runtime_version = kwargs['runtimeVersion']

        if config_file_path is not None:
            _setter("config_file_path", config_file_path)
        if enabled is not None:
            _setter("enabled", enabled)
        if kind is not None:
            _setter("kind", kind)
        if runtime_version is not None:
            _setter("runtime_version", runtime_version)

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "config_file_path")

    @config_file_path.setter
    def config_file_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_file_path", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)


@pulumi.input_type
class AutoHealActionsArgs:
    def __init__(__self__, *,
                 action_type: Optional[pulumi.Input['AutoHealActionType']] = None,
                 custom_action: Optional[pulumi.Input['AutoHealCustomActionArgs']] = None,
                 min_process_execution_time: Optional[pulumi.Input[str]] = None):
        """
        Actions which to take by the auto-heal module when a rule is triggered.
        :param pulumi.Input['AutoHealActionType'] action_type: Predefined action to be taken.
        :param pulumi.Input['AutoHealCustomActionArgs'] custom_action: Custom action to be taken.
        :param pulumi.Input[str] min_process_execution_time: Minimum time the process must execute
               before taking the action
        """
        AutoHealActionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_type=action_type,
            custom_action=custom_action,
            min_process_execution_time=min_process_execution_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_type: Optional[pulumi.Input['AutoHealActionType']] = None,
             custom_action: Optional[pulumi.Input['AutoHealCustomActionArgs']] = None,
             min_process_execution_time: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if 'customAction' in kwargs:
            custom_action = kwargs['customAction']
        if 'minProcessExecutionTime' in kwargs:
            min_process_execution_time = kwargs['minProcessExecutionTime']

        if action_type is not None:
            _setter("action_type", action_type)
        if custom_action is not None:
            _setter("custom_action", custom_action)
        if min_process_execution_time is not None:
            _setter("min_process_execution_time", min_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input['AutoHealActionType']]:
        """
        Predefined action to be taken.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input['AutoHealActionType']]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="customAction")
    def custom_action(self) -> Optional[pulumi.Input['AutoHealCustomActionArgs']]:
        """
        Custom action to be taken.
        """
        return pulumi.get(self, "custom_action")

    @custom_action.setter
    def custom_action(self, value: Optional[pulumi.Input['AutoHealCustomActionArgs']]):
        pulumi.set(self, "custom_action", value)

    @property
    @pulumi.getter(name="minProcessExecutionTime")
    def min_process_execution_time(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum time the process must execute
        before taking the action
        """
        return pulumi.get(self, "min_process_execution_time")

    @min_process_execution_time.setter
    def min_process_execution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_process_execution_time", value)


@pulumi.input_type
class AutoHealCustomActionArgs:
    def __init__(__self__, *,
                 exe: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[str]] = None):
        """
        Custom action to be executed
        when an auto heal rule is triggered.
        :param pulumi.Input[str] exe: Executable to be run.
        :param pulumi.Input[str] parameters: Parameters for the executable.
        """
        AutoHealCustomActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exe=exe,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exe: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if exe is not None:
            _setter("exe", exe)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def exe(self) -> Optional[pulumi.Input[str]]:
        """
        Executable to be run.
        """
        return pulumi.get(self, "exe")

    @exe.setter
    def exe(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exe", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[str]]:
        """
        Parameters for the executable.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class AutoHealRulesArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input['AutoHealActionsArgs']] = None,
                 triggers: Optional[pulumi.Input['AutoHealTriggersArgs']] = None):
        """
        Rules that can be defined for auto-heal.
        :param pulumi.Input['AutoHealActionsArgs'] actions: Actions to be executed when a rule is triggered.
        :param pulumi.Input['AutoHealTriggersArgs'] triggers: Conditions that describe when to execute the auto-heal actions.
        """
        AutoHealRulesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            triggers=triggers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[pulumi.Input['AutoHealActionsArgs']] = None,
             triggers: Optional[pulumi.Input['AutoHealTriggersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if actions is not None:
            _setter("actions", actions)
        if triggers is not None:
            _setter("triggers", triggers)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['AutoHealActionsArgs']]:
        """
        Actions to be executed when a rule is triggered.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['AutoHealActionsArgs']]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def triggers(self) -> Optional[pulumi.Input['AutoHealTriggersArgs']]:
        """
        Conditions that describe when to execute the auto-heal actions.
        """
        return pulumi.get(self, "triggers")

    @triggers.setter
    def triggers(self, value: Optional[pulumi.Input['AutoHealTriggersArgs']]):
        pulumi.set(self, "triggers", value)


@pulumi.input_type
class AutoHealTriggersArgs:
    def __init__(__self__, *,
                 private_bytes_in_kb: Optional[pulumi.Input[int]] = None,
                 requests: Optional[pulumi.Input['RequestsBasedTriggerArgs']] = None,
                 slow_requests: Optional[pulumi.Input['SlowRequestsBasedTriggerArgs']] = None,
                 status_codes: Optional[pulumi.Input[Sequence[pulumi.Input['StatusCodesBasedTriggerArgs']]]] = None):
        """
        Triggers for auto-heal.
        :param pulumi.Input[int] private_bytes_in_kb: A rule based on private bytes.
        :param pulumi.Input['RequestsBasedTriggerArgs'] requests: A rule based on total requests.
        :param pulumi.Input['SlowRequestsBasedTriggerArgs'] slow_requests: A rule based on request execution time.
        :param pulumi.Input[Sequence[pulumi.Input['StatusCodesBasedTriggerArgs']]] status_codes: A rule based on status codes.
        """
        AutoHealTriggersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_bytes_in_kb=private_bytes_in_kb,
            requests=requests,
            slow_requests=slow_requests,
            status_codes=status_codes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_bytes_in_kb: Optional[pulumi.Input[int]] = None,
             requests: Optional[pulumi.Input['RequestsBasedTriggerArgs']] = None,
             slow_requests: Optional[pulumi.Input['SlowRequestsBasedTriggerArgs']] = None,
             status_codes: Optional[pulumi.Input[Sequence[pulumi.Input['StatusCodesBasedTriggerArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateBytesInKB' in kwargs:
            private_bytes_in_kb = kwargs['privateBytesInKB']
        if 'slowRequests' in kwargs:
            slow_requests = kwargs['slowRequests']
        if 'statusCodes' in kwargs:
            status_codes = kwargs['statusCodes']

        if private_bytes_in_kb is not None:
            _setter("private_bytes_in_kb", private_bytes_in_kb)
        if requests is not None:
            _setter("requests", requests)
        if slow_requests is not None:
            _setter("slow_requests", slow_requests)
        if status_codes is not None:
            _setter("status_codes", status_codes)

    @property
    @pulumi.getter(name="privateBytesInKB")
    def private_bytes_in_kb(self) -> Optional[pulumi.Input[int]]:
        """
        A rule based on private bytes.
        """
        return pulumi.get(self, "private_bytes_in_kb")

    @private_bytes_in_kb.setter
    def private_bytes_in_kb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "private_bytes_in_kb", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input['RequestsBasedTriggerArgs']]:
        """
        A rule based on total requests.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input['RequestsBasedTriggerArgs']]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional[pulumi.Input['SlowRequestsBasedTriggerArgs']]:
        """
        A rule based on request execution time.
        """
        return pulumi.get(self, "slow_requests")

    @slow_requests.setter
    def slow_requests(self, value: Optional[pulumi.Input['SlowRequestsBasedTriggerArgs']]):
        pulumi.set(self, "slow_requests", value)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatusCodesBasedTriggerArgs']]]]:
        """
        A rule based on status codes.
        """
        return pulumi.get(self, "status_codes")

    @status_codes.setter
    def status_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatusCodesBasedTriggerArgs']]]]):
        pulumi.set(self, "status_codes", value)


@pulumi.input_type
class AzureActiveDirectoryLoginArgs:
    def __init__(__self__, *,
                 disable_www_authenticate: Optional[pulumi.Input[bool]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 login_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        AzureActiveDirectoryLoginArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_www_authenticate=disable_www_authenticate,
            kind=kind,
            login_parameters=login_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_www_authenticate: Optional[pulumi.Input[bool]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             login_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'disableWWWAuthenticate' in kwargs:
            disable_www_authenticate = kwargs['disableWWWAuthenticate']
        if 'loginParameters' in kwargs:
            login_parameters = kwargs['loginParameters']

        if disable_www_authenticate is not None:
            _setter("disable_www_authenticate", disable_www_authenticate)
        if kind is not None:
            _setter("kind", kind)
        if login_parameters is not None:
            _setter("login_parameters", login_parameters)

    @property
    @pulumi.getter(name="disableWWWAuthenticate")
    def disable_www_authenticate(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disable_www_authenticate")

    @disable_www_authenticate.setter
    def disable_www_authenticate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_www_authenticate", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "login_parameters")

    @login_parameters.setter
    def login_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_parameters", value)


@pulumi.input_type
class AzureActiveDirectoryRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret_certificate_thumbprint: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 open_id_issuer: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        AzureActiveDirectoryRegistrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret_certificate_thumbprint=client_secret_certificate_thumbprint,
            client_secret_setting_name=client_secret_setting_name,
            kind=kind,
            open_id_issuer=open_id_issuer,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[pulumi.Input[str]] = None,
             client_secret_certificate_thumbprint: Optional[pulumi.Input[str]] = None,
             client_secret_setting_name: Optional[pulumi.Input[str]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             open_id_issuer: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if 'clientSecretCertificateThumbprint' in kwargs:
            client_secret_certificate_thumbprint = kwargs['clientSecretCertificateThumbprint']
        if 'clientSecretSettingName' in kwargs:
            client_secret_setting_name = kwargs['clientSecretSettingName']
        if 'openIdIssuer' in kwargs:
            open_id_issuer = kwargs['openIdIssuer']

        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret_certificate_thumbprint is not None:
            _setter("client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            _setter("client_secret_setting_name", client_secret_setting_name)
        if kind is not None:
            _setter("kind", kind)
        if open_id_issuer is not None:
            _setter("open_id_issuer", open_id_issuer)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @client_secret_certificate_thumbprint.setter
    def client_secret_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_certificate_thumbprint", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="openIdIssuer")
    def open_id_issuer(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "open_id_issuer")

    @open_id_issuer.setter
    def open_id_issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "open_id_issuer", value)


@pulumi.input_type
class AzureActiveDirectoryValidationArgs:
    def __init__(__self__, *,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jwt_claim_checks: Optional[pulumi.Input['JwtClaimChecksArgs']] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        AzureActiveDirectoryValidationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_audiences=allowed_audiences,
            jwt_claim_checks=jwt_claim_checks,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             jwt_claim_checks: Optional[pulumi.Input['JwtClaimChecksArgs']] = None,
             kind: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedAudiences' in kwargs:
            allowed_audiences = kwargs['allowedAudiences']
        if 'jwtClaimChecks' in kwargs:
            jwt_claim_checks = kwargs['jwtClaimChecks']

        if allowed_audiences is not None:
            _setter("allowed_audiences", allowed_audiences)
        if jwt_claim_checks is not None:
            _setter("jwt_claim_checks", jwt_claim_checks)
        if kind is not None:
            _setter("kind", kind)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="jwtClaimChecks")
    def jwt_claim_checks(self) -> Optional[pulumi.Input['JwtClaimChecksArgs']]:
        return pulumi.get(self, "jwt_claim_checks")

    @jwt_claim_checks.setter
    def jwt_claim_checks(self, value: Optional[pulumi.Input['JwtClaimChecksArgs']]):
        pulumi.set(self, "jwt_claim_checks", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


@pulumi.input_type
class AzureActiveDirectoryArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 is_auto_provisioned: Optional[pulumi.Input[bool]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 login: Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']] = None,
                 registration: Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']] = None,
                 validation: Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        AzureActiveDirectoryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            is_auto_provisioned=is_auto_provisioned,
            kind=kind,
            login=login,
            registration=registration,
            validation=validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             is_auto_provisioned: Optional[pulumi.Input[bool]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             login: Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']] = None,
             registration: Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']] = None,
             validation: Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isAutoProvisioned' in kwargs:
            is_auto_provisioned = kwargs['isAutoProvisioned']

        if enabled is not None:
            _setter("enabled", enabled)
        if is_auto_provisioned is not None:
            _setter("is_auto_provisioned", is_auto_provisioned)
        if kind is not None:
            _setter("kind", kind)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)
        if validation is not None:
            _setter("validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="isAutoProvisioned")
    def is_auto_provisioned(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_auto_provisioned")

    @is_auto_provisioned.setter
    def is_auto_provisioned(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_auto_provisioned", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']]:
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']]:
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']]):
        pulumi.set(self, "registration", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']]:
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']]):
        pulumi.set(self, "validation", value)


@pulumi.input_type
class AzureBlobStorageApplicationLogsConfigArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input['LogLevel']] = None,
                 retention_in_days: Optional[pulumi.Input[int]] = None,
                 sas_url: Optional[pulumi.Input[str]] = None):
        """
        Application logs azure blob storage configuration.
        :param pulumi.Input['LogLevel'] level: Log level.
        :param pulumi.Input[int] retention_in_days: Retention in days.
               Remove blobs older than X days.
               0 or lower means no retention.
        :param pulumi.Input[str] sas_url: SAS url to a azure blob container with read/write/list/delete permissions.
        """
        AzureBlobStorageApplicationLogsConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            level=level,
            retention_in_days=retention_in_days,
            sas_url=sas_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             level: Optional[pulumi.Input['LogLevel']] = None,
             retention_in_days: Optional[pulumi.Input[int]] = None,
             sas_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'retentionInDays' in kwargs:
            retention_in_days = kwargs['retentionInDays']
        if 'sasUrl' in kwargs:
            sas_url = kwargs['sasUrl']

        if level is not None:
            _setter("level", level)
        if retention_in_days is not None:
            _setter("retention_in_days", retention_in_days)
        if sas_url is not None:
            _setter("sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input['LogLevel']]:
        """
        Log level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input['LogLevel']]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Retention in days.
        Remove blobs older than X days.
        0 or lower means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> Optional[pulumi.Input[str]]:
        """
        SAS url to a azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sas_url", value)


@pulumi.input_type
class AzureBlobStorageHttpLogsConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 retention_in_days: Optional[pulumi.Input[int]] = None,
                 sas_url: Optional[pulumi.Input[str]] = None):
        """
        Http logs to azure blob storage configuration.
        :param pulumi.Input[bool] enabled: True if configuration is enabled, false if it is disabled and null if configuration is not set.
        :param pulumi.Input[int] retention_in_days: Retention in days.
               Remove blobs older than X days.
               0 or lower means no retention.
        :param pulumi.Input[str] sas_url: SAS url to a azure blob container with read/write/list/delete permissions.
        """
        AzureBlobStorageHttpLogsConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            retention_in_days=retention_in_days,
            sas_url=sas_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             retention_in_days: Optional[pulumi.Input[int]] = None,
             sas_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'retentionInDays' in kwargs:
            retention_in_days = kwargs['retentionInDays']
        if 'sasUrl' in kwargs:
            sas_url = kwargs['sasUrl']

        if enabled is not None:
            _setter("enabled", enabled)
        if retention_in_days is not None:
            _setter("retention_in_days", retention_in_days)
        if sas_url is not None:
            _setter("sas_url", sas_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Retention in days.
        Remove blobs older than X days.
        0 or lower means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> Optional[pulumi.Input[str]]:
        """
        SAS url to a azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sas_url", value)


@pulumi.input_type
class AzureStorageInfoValueArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[str]] = None,
                 account_name: Optional[pulumi.Input[str]] = None,
                 mount_path: Optional[pulumi.Input[str]] = None,
                 share_name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input['AzureStorageType']] = None):
        """
        Azure Files or Blob Storage access information value for dictionary storage.
        :param pulumi.Input[str] access_key: Access key for the storage account.
        :param pulumi.Input[str] account_name: Name of the storage account.
        :param pulumi.Input[str] mount_path: Path to mount the storage within the site's runtime environment.
        :param pulumi.Input[str] share_name: Name of the file share (container name, for Blob storage).
        :param pulumi.Input['AzureStorageType'] type: Type of storage.
        """
        AzureStorageInfoValueArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            account_name=account_name,
            mount_path=mount_path,
            share_name=share_name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: Optional[pulumi.Input[str]] = None,
             account_name: Optional[pulumi.Input[str]] = None,
             mount_path: Optional[pulumi.Input[str]] = None,
             share_name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input['AzureStorageType']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if 'accountName' in kwargs:
            account_name = kwargs['accountName']
        if 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']
        if 'shareName' in kwargs:
            share_name = kwargs['shareName']

        if access_key is not None:
            _setter("access_key", access_key)
        if account_name is not None:
            _setter("account_name", account_name)
        if mount_path is not None:
            _setter("mount_path", mount_path)
        if share_name is not None:
            _setter("share_name", share_name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the storage account.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to mount the storage within the site's runtime environment.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the file share (container name, for Blob storage).
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['AzureStorageType']]:
        """
        Type of storage.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['AzureStorageType']]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class AzureTableStorageApplicationLogsConfigArgs:
    def __init__(__self__, *,
                 sas_url: pulumi.Input[str],
                 level: Optional[pulumi.Input['LogLevel']] = None):
        """
        Application logs to Azure table storage configuration.
        :param pulumi.Input[str] sas_url: SAS URL to an Azure table with add/query/delete permissions.
        :param pulumi.Input['LogLevel'] level: Log level.
        """
        AzureTableStorageApplicationLogsConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sas_url=sas_url,
            level=level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sas_url: pulumi.Input[str],
             level: Optional[pulumi.Input['LogLevel']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'sasUrl' in kwargs:
            sas_url = kwargs['sasUrl']

        _setter("sas_url", sas_url)
        if level is not None:
            _setter("level", level)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[str]:
        """
        SAS URL to an Azure table with add/query/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sas_url", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input['LogLevel']]:
        """
        Log level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input['LogLevel']]):
        pulumi.set(self, "level", value)


@pulumi.input_type
class BackupSchedule:
    def __init__(__self__, *,
                 frequency_interval: Optional[int] = None,
                 frequency_unit: Optional['FrequencyUnit'] = None,
                 keep_at_least_one_backup: Optional[bool] = None,
                 retention_period_in_days: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        Description of a backup schedule. Describes how often should be the backup performed and what should be the retention policy.
        :param int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        :param 'FrequencyUnit' frequency_unit: The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        :param bool keep_at_least_one_backup: True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        :param int retention_period_in_days: After how many days backups should be deleted.
        :param str start_time: When the schedule should start working.
        """
        BackupSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_unit=frequency_unit,
            keep_at_least_one_backup=keep_at_least_one_backup,
            retention_period_in_days=retention_period_in_days,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: Optional[int] = None,
             frequency_unit: Optional['FrequencyUnit'] = None,
             keep_at_least_one_backup: Optional[bool] = None,
             retention_period_in_days: Optional[int] = None,
             start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'frequencyInterval' in kwargs:
            frequency_interval = kwargs['frequencyInterval']
        if 'frequencyUnit' in kwargs:
            frequency_unit = kwargs['frequencyUnit']
        if 'keepAtLeastOneBackup' in kwargs:
            keep_at_least_one_backup = kwargs['keepAtLeastOneBackup']
        if 'retentionPeriodInDays' in kwargs:
            retention_period_in_days = kwargs['retentionPeriodInDays']
        if 'startTime' in kwargs:
            start_time = kwargs['startTime']

        if frequency_interval is None:
            frequency_interval = 7
        _setter("frequency_interval", frequency_interval)
        if frequency_unit is None:
            frequency_unit = 'Day'
        _setter("frequency_unit", frequency_unit)
        if keep_at_least_one_backup is None:
            keep_at_least_one_backup = True
        _setter("keep_at_least_one_backup", keep_at_least_one_backup)
        if retention_period_in_days is None:
            retention_period_in_days = 30
        _setter("retention_period_in_days", retention_period_in_days)
        if start_time is not None:
            _setter("start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: int):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> 'FrequencyUnit':
        """
        The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        """
        return pulumi.get(self, "frequency_unit")

    @frequency_unit.setter
    def frequency_unit(self, value: 'FrequencyUnit'):
        pulumi.set(self, "frequency_unit", value)

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> bool:
        """
        True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @keep_at_least_one_backup.setter
    def keep_at_least_one_backup(self, value: bool):
        pulumi.set(self, "keep_at_least_one_backup", value)

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> int:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_in_days")

    @retention_period_in_days.setter
    def retention_period_in_days(self, value: int):
        pulumi.set(self, "retention_period_in_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        When the schedule should start working.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[str]):
        pulumi.set(self, "start_time", value)


@pulumi.input_type
class BackupScheduleArgs:
    def __init__(__self__, *,
                 frequency_interval: Optional[pulumi.Input[int]] = None,
                 frequency_unit: Optional[pulumi.Input['FrequencyUnit']] = None,
                 keep_at_least_one_backup: Optional[pulumi.Input[bool]] = None,
                 retention_period_in_days: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        Description of a backup schedule. Describes how often should be the backup performed and what should be the retention policy.
        :param pulumi.Input[int] frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        :param pulumi.Input['FrequencyUnit'] frequency_unit: The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        :param pulumi.Input[bool] keep_at_least_one_backup: True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        :param pulumi.Input[int] retention_period_in_days: After how many days backups should be deleted.
        :param pulumi.Input[str] start_time: When the schedule should start working.
        """
        BackupScheduleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_unit=frequency_unit,
            keep_at_least_one_backup=keep_at_least_one_backup,
            retention_period_in_days=retention_period_in_days,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: Optional[pulumi.Input[int]] = None,
             frequency_unit: Optional[pulumi.Input['FrequencyUnit']] = None,
             keep_at_least_one_backup: Optional[pulumi.Input[bool]] = None,
             retention_period_in_days: Optional[pulumi.Input[int]] = None,
             start_time: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'frequencyInterval' in kwargs:
            frequency_interval = kwargs['frequencyInterval']
        if 'frequencyUnit' in kwargs:
            frequency_unit = kwargs['frequencyUnit']
        if 'keepAtLeastOneBackup' in kwargs:
            keep_at_least_one_backup = kwargs['keepAtLeastOneBackup']
        if 'retentionPeriodInDays' in kwargs:
            retention_period_in_days = kwargs['retentionPeriodInDays']
        if 'startTime' in kwargs:
            start_time = kwargs['startTime']

        if frequency_interval is None:
            frequency_interval = 7
        _setter("frequency_interval", frequency_interval)
        if frequency_unit is None:
            frequency_unit = 'Day'
        _setter("frequency_unit", frequency_unit)
        if keep_at_least_one_backup is None:
            keep_at_least_one_backup = True
        _setter("keep_at_least_one_backup", keep_at_least_one_backup)
        if retention_period_in_days is None:
            retention_period_in_days = 30
        _setter("retention_period_in_days", retention_period_in_days)
        if start_time is not None:
            _setter("start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> pulumi.Input['FrequencyUnit']:
        """
        The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        """
        return pulumi.get(self, "frequency_unit")

    @frequency_unit.setter
    def frequency_unit(self, value: pulumi.Input['FrequencyUnit']):
        pulumi.set(self, "frequency_unit", value)

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> pulumi.Input[bool]:
        """
        True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @keep_at_least_one_backup.setter
    def keep_at_least_one_backup(self, value: pulumi.Input[bool]):
        pulumi.set(self, "keep_at_least_one_backup", value)

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> pulumi.Input[int]:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_in_days")

    @retention_period_in_days.setter
    def retention_period_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_period_in_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        When the schedule should start working.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


@pulumi.input_type
class BlobStorageTokenStoreArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 sas_url_setting_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        BlobStorageTokenStoreArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
            sas_url_setting_name=sas_url_setting_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: Optional[pulumi.Input[str]] = None,
             sas_url_setting_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'sasUrlSettingName' in kwargs:
            sas_url_setting_name = kwargs['sasUrlSettingName']

        if kind is not None:
            _setter("kind", kind)
        if sas_url_setting_name is not None:
            _setter("sas_url_setting_name", sas_url_setting_name)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="sasUrlSettingName")
    def sas_url_setting_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sas_url_setting_name")

    @sas_url_setting_name.setter
    def sas_url_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sas_url_setting_name", value)


@pulumi.input_type
class CapabilityArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Describes the capabilities/features allowed for a specific SKU.
        :param pulumi.Input[str] name: Name of the SKU capability.
        :param pulumi.Input[str] reason: Reason of the SKU capability.
        :param pulumi.Input[str] value: Value of the SKU capability.
        """
        CapabilityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            reason=reason,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             reason: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if reason is not None:
            _setter("reason", reason)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the SKU capability.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        Reason of the SKU capability.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the SKU capability.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ClientRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        ClientRegistrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret_setting_name=client_secret_setting_name,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[pulumi.Input[str]] = None,
             client_secret_setting_name: Optional[pulumi.Input[str]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if 'clientSecretSettingName' in kwargs:
            client_secret_setting_name = kwargs['clientSecretSettingName']

        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret_setting_name is not None:
            _setter("client_secret_setting_name", client_secret_setting_name)
        if kind is not None:
            _setter("kind", kind)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


@pulumi.input_type
class CloningInfoArgs:
    def __init__(__self__, *,
                 source_web_app_id: pulumi.Input[str],
                 app_settings_overrides: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 clone_custom_host_names: Optional[pulumi.Input[bool]] = None,
                 clone_source_control: Optional[pulumi.Input[bool]] = None,
                 configure_load_balancing: Optional[pulumi.Input[bool]] = None,
                 correlation_id: Optional[pulumi.Input[str]] = None,
                 hosting_environment: Optional[pulumi.Input[str]] = None,
                 overwrite: Optional[pulumi.Input[bool]] = None,
                 source_web_app_location: Optional[pulumi.Input[str]] = None,
                 traffic_manager_profile_id: Optional[pulumi.Input[str]] = None,
                 traffic_manager_profile_name: Optional[pulumi.Input[str]] = None):
        """
        Information needed for cloning operation.
        :param pulumi.Input[str] source_web_app_id: ARM resource ID of the source app. App resource ID is of the form 
               /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots and 
               /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for other slots.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] app_settings_overrides: Application setting overrides for cloned app. If specified, these settings override the settings cloned 
               from source app. Otherwise, application settings from source app are retained.
        :param pulumi.Input[bool] clone_custom_host_names: <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
        :param pulumi.Input[bool] clone_source_control: <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
        :param pulumi.Input[bool] configure_load_balancing: <code>true</code> to configure load balancing for source and destination app.
        :param pulumi.Input[str] correlation_id: Correlation ID of cloning operation. This ID ties multiple cloning operations
               together to use the same snapshot.
        :param pulumi.Input[str] hosting_environment: App Service Environment.
        :param pulumi.Input[bool] overwrite: <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
        :param pulumi.Input[str] source_web_app_location: Location of source app ex: West US or North Europe
        :param pulumi.Input[str] traffic_manager_profile_id: ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form 
               /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
        :param pulumi.Input[str] traffic_manager_profile_name: Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
        """
        CloningInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_web_app_id=source_web_app_id,
            app_settings_overrides=app_settings_overrides,
            clone_custom_host_names=clone_custom_host_names,
            clone_source_control=clone_source_control,
            configure_load_balancing=configure_load_balancing,
            correlation_id=correlation_id,
            hosting_environment=hosting_environment,
            overwrite=overwrite,
            source_web_app_location=source_web_app_location,
            traffic_manager_profile_id=traffic_manager_profile_id,
            traffic_manager_profile_name=traffic_manager_profile_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_web_app_id: pulumi.Input[str],
             app_settings_overrides: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             clone_custom_host_names: Optional[pulumi.Input[bool]] = None,
             clone_source_control: Optional[pulumi.Input[bool]] = None,
             configure_load_balancing: Optional[pulumi.Input[bool]] = None,
             correlation_id: Optional[pulumi.Input[str]] = None,
             hosting_environment: Optional[pulumi.Input[str]] = None,
             overwrite: Optional[pulumi.Input[bool]] = None,
             source_web_app_location: Optional[pulumi.Input[str]] = None,
             traffic_manager_profile_id: Optional[pulumi.Input[str]] = None,
             traffic_manager_profile_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'sourceWebAppId' in kwargs:
            source_web_app_id = kwargs['sourceWebAppId']
        if 'appSettingsOverrides' in kwargs:
            app_settings_overrides = kwargs['appSettingsOverrides']
        if 'cloneCustomHostNames' in kwargs:
            clone_custom_host_names = kwargs['cloneCustomHostNames']
        if 'cloneSourceControl' in kwargs:
            clone_source_control = kwargs['cloneSourceControl']
        if 'configureLoadBalancing' in kwargs:
            configure_load_balancing = kwargs['configureLoadBalancing']
        if 'correlationId' in kwargs:
            correlation_id = kwargs['correlationId']
        if 'hostingEnvironment' in kwargs:
            hosting_environment = kwargs['hostingEnvironment']
        if 'sourceWebAppLocation' in kwargs:
            source_web_app_location = kwargs['sourceWebAppLocation']
        if 'trafficManagerProfileId' in kwargs:
            traffic_manager_profile_id = kwargs['trafficManagerProfileId']
        if 'trafficManagerProfileName' in kwargs:
            traffic_manager_profile_name = kwargs['trafficManagerProfileName']

        _setter("source_web_app_id", source_web_app_id)
        if app_settings_overrides is not None:
            _setter("app_settings_overrides", app_settings_overrides)
        if clone_custom_host_names is not None:
            _setter("clone_custom_host_names", clone_custom_host_names)
        if clone_source_control is not None:
            _setter("clone_source_control", clone_source_control)
        if configure_load_balancing is not None:
            _setter("configure_load_balancing", configure_load_balancing)
        if correlation_id is not None:
            _setter("correlation_id", correlation_id)
        if hosting_environment is not None:
            _setter("hosting_environment", hosting_environment)
        if overwrite is not None:
            _setter("overwrite", overwrite)
        if source_web_app_location is not None:
            _setter("source_web_app_location", source_web_app_location)
        if traffic_manager_profile_id is not None:
            _setter("traffic_manager_profile_id", traffic_manager_profile_id)
        if traffic_manager_profile_name is not None:
            _setter("traffic_manager_profile_name", traffic_manager_profile_name)

    @property
    @pulumi.getter(name="sourceWebAppId")
    def source_web_app_id(self) -> pulumi.Input[str]:
        """
        ARM resource ID of the source app. App resource ID is of the form 
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots and 
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for other slots.
        """
        return pulumi.get(self, "source_web_app_id")

    @source_web_app_id.setter
    def source_web_app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_web_app_id", value)

    @property
    @pulumi.getter(name="appSettingsOverrides")
    def app_settings_overrides(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Application setting overrides for cloned app. If specified, these settings override the settings cloned 
        from source app. Otherwise, application settings from source app are retained.
        """
        return pulumi.get(self, "app_settings_overrides")

    @app_settings_overrides.setter
    def app_settings_overrides(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "app_settings_overrides", value)

    @property
    @pulumi.getter(name="cloneCustomHostNames")
    def clone_custom_host_names(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "clone_custom_host_names")

    @clone_custom_host_names.setter
    def clone_custom_host_names(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clone_custom_host_names", value)

    @property
    @pulumi.getter(name="cloneSourceControl")
    def clone_source_control(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "clone_source_control")

    @clone_source_control.setter
    def clone_source_control(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clone_source_control", value)

    @property
    @pulumi.getter(name="configureLoadBalancing")
    def configure_load_balancing(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> to configure load balancing for source and destination app.
        """
        return pulumi.get(self, "configure_load_balancing")

    @configure_load_balancing.setter
    def configure_load_balancing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "configure_load_balancing", value)

    @property
    @pulumi.getter(name="correlationId")
    def correlation_id(self) -> Optional[pulumi.Input[str]]:
        """
        Correlation ID of cloning operation. This ID ties multiple cloning operations
        together to use the same snapshot.
        """
        return pulumi.get(self, "correlation_id")

    @correlation_id.setter
    def correlation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "correlation_id", value)

    @property
    @pulumi.getter(name="hostingEnvironment")
    def hosting_environment(self) -> Optional[pulumi.Input[str]]:
        """
        App Service Environment.
        """
        return pulumi.get(self, "hosting_environment")

    @hosting_environment.setter
    def hosting_environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hosting_environment", value)

    @property
    @pulumi.getter
    def overwrite(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "overwrite")

    @overwrite.setter
    def overwrite(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "overwrite", value)

    @property
    @pulumi.getter(name="sourceWebAppLocation")
    def source_web_app_location(self) -> Optional[pulumi.Input[str]]:
        """
        Location of source app ex: West US or North Europe
        """
        return pulumi.get(self, "source_web_app_location")

    @source_web_app_location.setter
    def source_web_app_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_web_app_location", value)

    @property
    @pulumi.getter(name="trafficManagerProfileId")
    def traffic_manager_profile_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form 
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
        """
        return pulumi.get(self, "traffic_manager_profile_id")

    @traffic_manager_profile_id.setter
    def traffic_manager_profile_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "traffic_manager_profile_id", value)

    @property
    @pulumi.getter(name="trafficManagerProfileName")
    def traffic_manager_profile_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
        """
        return pulumi.get(self, "traffic_manager_profile_name")

    @traffic_manager_profile_name.setter
    def traffic_manager_profile_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "traffic_manager_profile_name", value)


@pulumi.input_type
class ConnStringInfoArgs:
    def __init__(__self__, *,
                 connection_string: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input['ConnectionStringType']] = None):
        """
        Database connection string information.
        :param pulumi.Input[str] connection_string: Connection string value.
        :param pulumi.Input[str] name: Name of connection string.
        :param pulumi.Input['ConnectionStringType'] type: Type of database.
        """
        ConnStringInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_string=connection_string,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_string: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input['ConnectionStringType']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'connectionString' in kwargs:
            connection_string = kwargs['connectionString']

        if connection_string is not None:
            _setter("connection_string", connection_string)
        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[pulumi.Input[str]]:
        """
        Connection string value.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of connection string.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ConnectionStringType']]:
        """
        Type of database.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ConnectionStringType']]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ConnStringValueTypePairArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['ConnectionStringType'],
                 value: pulumi.Input[str]):
        """
        Database connection string value to type pair.
        :param pulumi.Input['ConnectionStringType'] type: Type of database.
        :param pulumi.Input[str] value: Value of pair.
        """
        ConnStringValueTypePairArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input['ConnectionStringType'],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("type", type)
        _setter("value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['ConnectionStringType']:
        """
        Type of database.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ConnectionStringType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of pair.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class CookieExpirationArgs:
    def __init__(__self__, *,
                 convention: Optional[pulumi.Input['CookieExpirationConvention']] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 time_to_expiration: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        CookieExpirationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            convention=convention,
            kind=kind,
            time_to_expiration=time_to_expiration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             convention: Optional[pulumi.Input['CookieExpirationConvention']] = None,
             kind: Optional[pulumi.Input[str]] = None,
             time_to_expiration: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'timeToExpiration' in kwargs:
            time_to_expiration = kwargs['timeToExpiration']

        if convention is not None:
            _setter("convention", convention)
        if kind is not None:
            _setter("kind", kind)
        if time_to_expiration is not None:
            _setter("time_to_expiration", time_to_expiration)

    @property
    @pulumi.getter
    def convention(self) -> Optional[pulumi.Input['CookieExpirationConvention']]:
        return pulumi.get(self, "convention")

    @convention.setter
    def convention(self, value: Optional[pulumi.Input['CookieExpirationConvention']]):
        pulumi.set(self, "convention", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="timeToExpiration")
    def time_to_expiration(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_to_expiration")

    @time_to_expiration.setter
    def time_to_expiration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_to_expiration", value)


@pulumi.input_type
class CorsSettingsArgs:
    def __init__(__self__, *,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 support_credentials: Optional[pulumi.Input[bool]] = None):
        """
        Cross-Origin Resource Sharing (CORS) settings for the app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Gets or sets the list of origins that should be allowed to make cross-origin
               calls (for example: http://example.com:12345). Use "*" to allow all.
        :param pulumi.Input[bool] support_credentials: Gets or sets whether CORS requests with credentials are allowed. See 
               https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
               for more details.
        """
        CorsSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_origins=allowed_origins,
            support_credentials=support_credentials,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             support_credentials: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedOrigins' in kwargs:
            allowed_origins = kwargs['allowedOrigins']
        if 'supportCredentials' in kwargs:
            support_credentials = kwargs['supportCredentials']

        if allowed_origins is not None:
            _setter("allowed_origins", allowed_origins)
        if support_credentials is not None:
            _setter("support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Gets or sets the list of origins that should be allowed to make cross-origin
        calls (for example: http://example.com:12345). Use "*" to allow all.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets or sets whether CORS requests with credentials are allowed. See 
        https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
        for more details.
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "support_credentials", value)


@pulumi.input_type
class CustomOpenIdConnectProviderArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 login: Optional[pulumi.Input['OpenIdConnectLoginArgs']] = None,
                 registration: Optional[pulumi.Input['OpenIdConnectRegistrationArgs']] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        CustomOpenIdConnectProviderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            kind=kind,
            login=login,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             login: Optional[pulumi.Input['OpenIdConnectLoginArgs']] = None,
             registration: Optional[pulumi.Input['OpenIdConnectRegistrationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if kind is not None:
            _setter("kind", kind)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['OpenIdConnectLoginArgs']]:
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['OpenIdConnectLoginArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['OpenIdConnectRegistrationArgs']]:
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['OpenIdConnectRegistrationArgs']]):
        pulumi.set(self, "registration", value)


@pulumi.input_type
class DatabaseBackupSetting:
    def __init__(__self__, *,
                 database_type: Union[str, 'DatabaseType'],
                 connection_string: Optional[str] = None,
                 connection_string_name: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Database backup settings.
        :param Union[str, 'DatabaseType'] database_type: Database type (e.g. SqlAzure / MySql).
        :param str connection_string: Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        :param str connection_string_name: Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
               This is used during restore with overwrite connection strings options.
        """
        DatabaseBackupSetting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_type=database_type,
            connection_string=connection_string,
            connection_string_name=connection_string_name,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_type: Union[str, 'DatabaseType'],
             connection_string: Optional[str] = None,
             connection_string_name: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'databaseType' in kwargs:
            database_type = kwargs['databaseType']
        if 'connectionString' in kwargs:
            connection_string = kwargs['connectionString']
        if 'connectionStringName' in kwargs:
            connection_string_name = kwargs['connectionStringName']

        _setter("database_type", database_type)
        if connection_string is not None:
            _setter("connection_string", connection_string)
        if connection_string_name is not None:
            _setter("connection_string_name", connection_string_name)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> Union[str, 'DatabaseType']:
        """
        Database type (e.g. SqlAzure / MySql).
        """
        return pulumi.get(self, "database_type")

    @database_type.setter
    def database_type(self, value: Union[str, 'DatabaseType']):
        pulumi.set(self, "database_type", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        """
        Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[str]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter(name="connectionStringName")
    def connection_string_name(self) -> Optional[str]:
        """
        Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
        This is used during restore with overwrite connection strings options.
        """
        return pulumi.get(self, "connection_string_name")

    @connection_string_name.setter
    def connection_string_name(self, value: Optional[str]):
        pulumi.set(self, "connection_string_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseBackupSettingArgs:
    def __init__(__self__, *,
                 database_type: pulumi.Input[Union[str, 'DatabaseType']],
                 connection_string: Optional[pulumi.Input[str]] = None,
                 connection_string_name: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Database backup settings.
        :param pulumi.Input[Union[str, 'DatabaseType']] database_type: Database type (e.g. SqlAzure / MySql).
        :param pulumi.Input[str] connection_string: Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        :param pulumi.Input[str] connection_string_name: Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
               This is used during restore with overwrite connection strings options.
        """
        DatabaseBackupSettingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_type=database_type,
            connection_string=connection_string,
            connection_string_name=connection_string_name,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_type: pulumi.Input[Union[str, 'DatabaseType']],
             connection_string: Optional[pulumi.Input[str]] = None,
             connection_string_name: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'databaseType' in kwargs:
            database_type = kwargs['databaseType']
        if 'connectionString' in kwargs:
            connection_string = kwargs['connectionString']
        if 'connectionStringName' in kwargs:
            connection_string_name = kwargs['connectionStringName']

        _setter("database_type", database_type)
        if connection_string is not None:
            _setter("connection_string", connection_string)
        if connection_string_name is not None:
            _setter("connection_string_name", connection_string_name)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> pulumi.Input[Union[str, 'DatabaseType']]:
        """
        Database type (e.g. SqlAzure / MySql).
        """
        return pulumi.get(self, "database_type")

    @database_type.setter
    def database_type(self, value: pulumi.Input[Union[str, 'DatabaseType']]):
        pulumi.set(self, "database_type", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[pulumi.Input[str]]:
        """
        Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter(name="connectionStringName")
    def connection_string_name(self) -> Optional[pulumi.Input[str]]:
        """
        Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
        This is used during restore with overwrite connection strings options.
        """
        return pulumi.get(self, "connection_string_name")

    @connection_string_name.setter
    def connection_string_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_string_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class EnabledConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Enabled configuration.
        :param pulumi.Input[bool] enabled: True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        EnabledConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ExperimentsArgs:
    def __init__(__self__, *,
                 ramp_up_rules: Optional[pulumi.Input[Sequence[pulumi.Input['RampUpRuleArgs']]]] = None):
        """
        Routing rules in production experiments.
        :param pulumi.Input[Sequence[pulumi.Input['RampUpRuleArgs']]] ramp_up_rules: List of ramp-up rules.
        """
        ExperimentsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ramp_up_rules=ramp_up_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ramp_up_rules: Optional[pulumi.Input[Sequence[pulumi.Input['RampUpRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'rampUpRules' in kwargs:
            ramp_up_rules = kwargs['rampUpRules']

        if ramp_up_rules is not None:
            _setter("ramp_up_rules", ramp_up_rules)

    @property
    @pulumi.getter(name="rampUpRules")
    def ramp_up_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RampUpRuleArgs']]]]:
        """
        List of ramp-up rules.
        """
        return pulumi.get(self, "ramp_up_rules")

    @ramp_up_rules.setter
    def ramp_up_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RampUpRuleArgs']]]]):
        pulumi.set(self, "ramp_up_rules", value)


@pulumi.input_type
class FacebookArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 graph_api_version: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['AppRegistrationArgs']] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        FacebookArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            graph_api_version=graph_api_version,
            kind=kind,
            login=login,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             graph_api_version: Optional[pulumi.Input[str]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             login: Optional[pulumi.Input['LoginScopesArgs']] = None,
             registration: Optional[pulumi.Input['AppRegistrationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'graphApiVersion' in kwargs:
            graph_api_version = kwargs['graphApiVersion']

        if enabled is not None:
            _setter("enabled", enabled)
        if graph_api_version is not None:
            _setter("graph_api_version", graph_api_version)
        if kind is not None:
            _setter("kind", kind)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "graph_api_version")

    @graph_api_version.setter
    def graph_api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_api_version", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AppRegistrationArgs']]:
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AppRegistrationArgs']]):
        pulumi.set(self, "registration", value)


@pulumi.input_type
class FileSystemApplicationLogsConfigArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input['LogLevel']] = None):
        """
        Application logs to file system configuration.
        :param pulumi.Input['LogLevel'] level: Log level.
        """
        FileSystemApplicationLogsConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            level=level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             level: Optional[pulumi.Input['LogLevel']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if level is None:
            level = 'Off'
        if level is not None:
            _setter("level", level)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input['LogLevel']]:
        """
        Log level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input['LogLevel']]):
        pulumi.set(self, "level", value)


@pulumi.input_type
class FileSystemHttpLogsConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 retention_in_days: Optional[pulumi.Input[int]] = None,
                 retention_in_mb: Optional[pulumi.Input[int]] = None):
        """
        Http logs to file system configuration.
        :param pulumi.Input[bool] enabled: True if configuration is enabled, false if it is disabled and null if configuration is not set.
        :param pulumi.Input[int] retention_in_days: Retention in days.
               Remove files older than X days.
               0 or lower means no retention.
        :param pulumi.Input[int] retention_in_mb: Maximum size in megabytes that http log files can use.
               When reached old log files will be removed to make space for new ones.
               Value can range between 25 and 100.
        """
        FileSystemHttpLogsConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            retention_in_days=retention_in_days,
            retention_in_mb=retention_in_mb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             retention_in_days: Optional[pulumi.Input[int]] = None,
             retention_in_mb: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'retentionInDays' in kwargs:
            retention_in_days = kwargs['retentionInDays']
        if 'retentionInMb' in kwargs:
            retention_in_mb = kwargs['retentionInMb']

        if enabled is not None:
            _setter("enabled", enabled)
        if retention_in_days is not None:
            _setter("retention_in_days", retention_in_days)
        if retention_in_mb is not None:
            _setter("retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Retention in days.
        Remove files older than X days.
        0 or lower means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum size in megabytes that http log files can use.
        When reached old log files will be removed to make space for new ones.
        Value can range between 25 and 100.
        """
        return pulumi.get(self, "retention_in_mb")

    @retention_in_mb.setter
    def retention_in_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_in_mb", value)


@pulumi.input_type
class FileSystemTokenStoreArgs:
    def __init__(__self__, *,
                 directory: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        FileSystemTokenStoreArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            directory=directory,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             directory: Optional[pulumi.Input[str]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if directory is not None:
            _setter("directory", directory)
        if kind is not None:
            _setter("kind", kind)

    @property
    @pulumi.getter
    def directory(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "directory")

    @directory.setter
    def directory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


@pulumi.input_type
class ForwardProxyArgs:
    def __init__(__self__, *,
                 convention: Optional[pulumi.Input['ForwardProxyConvention']] = None,
                 custom_host_header_name: Optional[pulumi.Input[str]] = None,
                 custom_proto_header_name: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        ForwardProxyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            convention=convention,
            custom_host_header_name=custom_host_header_name,
            custom_proto_header_name=custom_proto_header_name,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             convention: Optional[pulumi.Input['ForwardProxyConvention']] = None,
             custom_host_header_name: Optional[pulumi.Input[str]] = None,
             custom_proto_header_name: Optional[pulumi.Input[str]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customHostHeaderName' in kwargs:
            custom_host_header_name = kwargs['customHostHeaderName']
        if 'customProtoHeaderName' in kwargs:
            custom_proto_header_name = kwargs['customProtoHeaderName']

        if convention is not None:
            _setter("convention", convention)
        if custom_host_header_name is not None:
            _setter("custom_host_header_name", custom_host_header_name)
        if custom_proto_header_name is not None:
            _setter("custom_proto_header_name", custom_proto_header_name)
        if kind is not None:
            _setter("kind", kind)

    @property
    @pulumi.getter
    def convention(self) -> Optional[pulumi.Input['ForwardProxyConvention']]:
        return pulumi.get(self, "convention")

    @convention.setter
    def convention(self, value: Optional[pulumi.Input['ForwardProxyConvention']]):
        pulumi.set(self, "convention", value)

    @property
    @pulumi.getter(name="customHostHeaderName")
    def custom_host_header_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "custom_host_header_name")

    @custom_host_header_name.setter
    def custom_host_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_host_header_name", value)

    @property
    @pulumi.getter(name="customProtoHeaderName")
    def custom_proto_header_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "custom_proto_header_name")

    @custom_proto_header_name.setter
    def custom_proto_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_proto_header_name", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


@pulumi.input_type
class GitHubArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['ClientRegistrationArgs']] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        GitHubArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            kind=kind,
            login=login,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             login: Optional[pulumi.Input['LoginScopesArgs']] = None,
             registration: Optional[pulumi.Input['ClientRegistrationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if kind is not None:
            _setter("kind", kind)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['ClientRegistrationArgs']]:
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['ClientRegistrationArgs']]):
        pulumi.set(self, "registration", value)


@pulumi.input_type
class GlobalValidationArgs:
    def __init__(__self__, *,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 redirect_to_provider: Optional[pulumi.Input[str]] = None,
                 require_authentication: Optional[pulumi.Input[bool]] = None,
                 unauthenticated_client_action: Optional[pulumi.Input['UnauthenticatedClientActionV2']] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        GlobalValidationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            excluded_paths=excluded_paths,
            kind=kind,
            redirect_to_provider=redirect_to_provider,
            require_authentication=require_authentication,
            unauthenticated_client_action=unauthenticated_client_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             redirect_to_provider: Optional[pulumi.Input[str]] = None,
             require_authentication: Optional[pulumi.Input[bool]] = None,
             unauthenticated_client_action: Optional[pulumi.Input['UnauthenticatedClientActionV2']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'excludedPaths' in kwargs:
            excluded_paths = kwargs['excludedPaths']
        if 'redirectToProvider' in kwargs:
            redirect_to_provider = kwargs['redirectToProvider']
        if 'requireAuthentication' in kwargs:
            require_authentication = kwargs['requireAuthentication']
        if 'unauthenticatedClientAction' in kwargs:
            unauthenticated_client_action = kwargs['unauthenticatedClientAction']

        if excluded_paths is not None:
            _setter("excluded_paths", excluded_paths)
        if kind is not None:
            _setter("kind", kind)
        if redirect_to_provider is not None:
            _setter("redirect_to_provider", redirect_to_provider)
        if require_authentication is not None:
            _setter("require_authentication", require_authentication)
        if unauthenticated_client_action is not None:
            _setter("unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="redirectToProvider")
    def redirect_to_provider(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "redirect_to_provider")

    @redirect_to_provider.setter
    def redirect_to_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_to_provider", value)

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "require_authentication")

    @require_authentication.setter
    def require_authentication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_authentication", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input['UnauthenticatedClientActionV2']]:
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input['UnauthenticatedClientActionV2']]):
        pulumi.set(self, "unauthenticated_client_action", value)


@pulumi.input_type
class GoogleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['ClientRegistrationArgs']] = None,
                 validation: Optional[pulumi.Input['AllowedAudiencesValidationArgs']] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        GoogleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            kind=kind,
            login=login,
            registration=registration,
            validation=validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             login: Optional[pulumi.Input['LoginScopesArgs']] = None,
             registration: Optional[pulumi.Input['ClientRegistrationArgs']] = None,
             validation: Optional[pulumi.Input['AllowedAudiencesValidationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if kind is not None:
            _setter("kind", kind)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)
        if validation is not None:
            _setter("validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['ClientRegistrationArgs']]:
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['ClientRegistrationArgs']]):
        pulumi.set(self, "registration", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input['AllowedAudiencesValidationArgs']]:
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input['AllowedAudiencesValidationArgs']]):
        pulumi.set(self, "validation", value)


@pulumi.input_type
class HandlerMappingArgs:
    def __init__(__self__, *,
                 arguments: Optional[pulumi.Input[str]] = None,
                 extension: Optional[pulumi.Input[str]] = None,
                 script_processor: Optional[pulumi.Input[str]] = None):
        """
        The IIS handler mappings used to define which handler processes HTTP requests with certain extension. 
        For example, it is used to configure php-cgi.exe process to handle all HTTP requests with *.php extension.
        :param pulumi.Input[str] arguments: Command-line arguments to be passed to the script processor.
        :param pulumi.Input[str] extension: Requests with this extension will be handled using the specified FastCGI application.
        :param pulumi.Input[str] script_processor: The absolute path to the FastCGI application.
        """
        HandlerMappingArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arguments=arguments,
            extension=extension,
            script_processor=script_processor,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arguments: Optional[pulumi.Input[str]] = None,
             extension: Optional[pulumi.Input[str]] = None,
             script_processor: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'scriptProcessor' in kwargs:
            script_processor = kwargs['scriptProcessor']

        if arguments is not None:
            _setter("arguments", arguments)
        if extension is not None:
            _setter("extension", extension)
        if script_processor is not None:
            _setter("script_processor", script_processor)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[str]]:
        """
        Command-line arguments to be passed to the script processor.
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arguments", value)

    @property
    @pulumi.getter
    def extension(self) -> Optional[pulumi.Input[str]]:
        """
        Requests with this extension will be handled using the specified FastCGI application.
        """
        return pulumi.get(self, "extension")

    @extension.setter
    def extension(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "extension", value)

    @property
    @pulumi.getter(name="scriptProcessor")
    def script_processor(self) -> Optional[pulumi.Input[str]]:
        """
        The absolute path to the FastCGI application.
        """
        return pulumi.get(self, "script_processor")

    @script_processor.setter
    def script_processor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script_processor", value)


@pulumi.input_type
class HostNameSslStateArgs:
    def __init__(__self__, *,
                 host_type: Optional[pulumi.Input['HostType']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ssl_state: Optional[pulumi.Input['SslState']] = None,
                 thumbprint: Optional[pulumi.Input[str]] = None,
                 to_update: Optional[pulumi.Input[bool]] = None,
                 virtual_ip: Optional[pulumi.Input[str]] = None):
        """
        SSL-enabled hostname.
        :param pulumi.Input['HostType'] host_type: Indicates whether the hostname is a standard or repository hostname.
        :param pulumi.Input[str] name: Hostname.
        :param pulumi.Input['SslState'] ssl_state: SSL type.
        :param pulumi.Input[str] thumbprint: SSL certificate thumbprint.
        :param pulumi.Input[bool] to_update: Set to <code>true</code> to update existing hostname.
        :param pulumi.Input[str] virtual_ip: Virtual IP address assigned to the hostname if IP based SSL is enabled.
        """
        HostNameSslStateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host_type=host_type,
            name=name,
            ssl_state=ssl_state,
            thumbprint=thumbprint,
            to_update=to_update,
            virtual_ip=virtual_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host_type: Optional[pulumi.Input['HostType']] = None,
             name: Optional[pulumi.Input[str]] = None,
             ssl_state: Optional[pulumi.Input['SslState']] = None,
             thumbprint: Optional[pulumi.Input[str]] = None,
             to_update: Optional[pulumi.Input[bool]] = None,
             virtual_ip: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'hostType' in kwargs:
            host_type = kwargs['hostType']
        if 'sslState' in kwargs:
            ssl_state = kwargs['sslState']
        if 'toUpdate' in kwargs:
            to_update = kwargs['toUpdate']
        if 'virtualIP' in kwargs:
            virtual_ip = kwargs['virtualIP']

        if host_type is not None:
            _setter("host_type", host_type)
        if name is not None:
            _setter("name", name)
        if ssl_state is not None:
            _setter("ssl_state", ssl_state)
        if thumbprint is not None:
            _setter("thumbprint", thumbprint)
        if to_update is not None:
            _setter("to_update", to_update)
        if virtual_ip is not None:
            _setter("virtual_ip", virtual_ip)

    @property
    @pulumi.getter(name="hostType")
    def host_type(self) -> Optional[pulumi.Input['HostType']]:
        """
        Indicates whether the hostname is a standard or repository hostname.
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: Optional[pulumi.Input['HostType']]):
        pulumi.set(self, "host_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sslState")
    def ssl_state(self) -> Optional[pulumi.Input['SslState']]:
        """
        SSL type.
        """
        return pulumi.get(self, "ssl_state")

    @ssl_state.setter
    def ssl_state(self, value: Optional[pulumi.Input['SslState']]):
        pulumi.set(self, "ssl_state", value)

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        SSL certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @thumbprint.setter
    def thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thumbprint", value)

    @property
    @pulumi.getter(name="toUpdate")
    def to_update(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to <code>true</code> to update existing hostname.
        """
        return pulumi.get(self, "to_update")

    @to_update.setter
    def to_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "to_update", value)

    @property
    @pulumi.getter(name="virtualIP")
    def virtual_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Virtual IP address assigned to the hostname if IP based SSL is enabled.
        """
        return pulumi.get(self, "virtual_ip")

    @virtual_ip.setter
    def virtual_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_ip", value)


@pulumi.input_type
class HostingEnvironmentProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Specification for an App Service Environment to use for this resource.
        :param pulumi.Input[str] id: Resource ID of the App Service Environment.
        """
        HostingEnvironmentProfileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID of the App Service Environment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class HttpLogsConfigArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['AzureBlobStorageHttpLogsConfigArgs']] = None,
                 file_system: Optional[pulumi.Input['FileSystemHttpLogsConfigArgs']] = None):
        """
        Http logs configuration.
        :param pulumi.Input['AzureBlobStorageHttpLogsConfigArgs'] azure_blob_storage: Http logs to azure blob storage configuration.
        :param pulumi.Input['FileSystemHttpLogsConfigArgs'] file_system: Http logs to file system configuration.
        """
        HttpLogsConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_blob_storage=azure_blob_storage,
            file_system=file_system,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_blob_storage: Optional[pulumi.Input['AzureBlobStorageHttpLogsConfigArgs']] = None,
             file_system: Optional[pulumi.Input['FileSystemHttpLogsConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'azureBlobStorage' in kwargs:
            azure_blob_storage = kwargs['azureBlobStorage']
        if 'fileSystem' in kwargs:
            file_system = kwargs['fileSystem']

        if azure_blob_storage is not None:
            _setter("azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            _setter("file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['AzureBlobStorageHttpLogsConfigArgs']]:
        """
        Http logs to azure blob storage configuration.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['AzureBlobStorageHttpLogsConfigArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input['FileSystemHttpLogsConfigArgs']]:
        """
        Http logs to file system configuration.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input['FileSystemHttpLogsConfigArgs']]):
        pulumi.set(self, "file_system", value)


@pulumi.input_type
class HttpSettingsRoutesArgs:
    def __init__(__self__, *,
                 api_prefix: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        HttpSettingsRoutesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_prefix=api_prefix,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_prefix: Optional[pulumi.Input[str]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'apiPrefix' in kwargs:
            api_prefix = kwargs['apiPrefix']

        if api_prefix is not None:
            _setter("api_prefix", api_prefix)
        if kind is not None:
            _setter("kind", kind)

    @property
    @pulumi.getter(name="apiPrefix")
    def api_prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "api_prefix")

    @api_prefix.setter
    def api_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_prefix", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


@pulumi.input_type
class HttpSettingsArgs:
    def __init__(__self__, *,
                 forward_proxy: Optional[pulumi.Input['ForwardProxyArgs']] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 require_https: Optional[pulumi.Input[bool]] = None,
                 routes: Optional[pulumi.Input['HttpSettingsRoutesArgs']] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        HttpSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forward_proxy=forward_proxy,
            kind=kind,
            require_https=require_https,
            routes=routes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forward_proxy: Optional[pulumi.Input['ForwardProxyArgs']] = None,
             kind: Optional[pulumi.Input[str]] = None,
             require_https: Optional[pulumi.Input[bool]] = None,
             routes: Optional[pulumi.Input['HttpSettingsRoutesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'forwardProxy' in kwargs:
            forward_proxy = kwargs['forwardProxy']
        if 'requireHttps' in kwargs:
            require_https = kwargs['requireHttps']

        if forward_proxy is not None:
            _setter("forward_proxy", forward_proxy)
        if kind is not None:
            _setter("kind", kind)
        if require_https is not None:
            _setter("require_https", require_https)
        if routes is not None:
            _setter("routes", routes)

    @property
    @pulumi.getter(name="forwardProxy")
    def forward_proxy(self) -> Optional[pulumi.Input['ForwardProxyArgs']]:
        return pulumi.get(self, "forward_proxy")

    @forward_proxy.setter
    def forward_proxy(self, value: Optional[pulumi.Input['ForwardProxyArgs']]):
        pulumi.set(self, "forward_proxy", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "require_https")

    @require_https.setter
    def require_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_https", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input['HttpSettingsRoutesArgs']]:
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input['HttpSettingsRoutesArgs']]):
        pulumi.set(self, "routes", value)


@pulumi.input_type
class IdentityProvidersArgs:
    def __init__(__self__, *,
                 azure_active_directory: Optional[pulumi.Input['AzureActiveDirectoryArgs']] = None,
                 custom_open_id_connect_providers: Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]] = None,
                 facebook: Optional[pulumi.Input['FacebookArgs']] = None,
                 git_hub: Optional[pulumi.Input['GitHubArgs']] = None,
                 google: Optional[pulumi.Input['GoogleArgs']] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 twitter: Optional[pulumi.Input['TwitterArgs']] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        IdentityProvidersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_active_directory=azure_active_directory,
            custom_open_id_connect_providers=custom_open_id_connect_providers,
            facebook=facebook,
            git_hub=git_hub,
            google=google,
            kind=kind,
            twitter=twitter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_active_directory: Optional[pulumi.Input['AzureActiveDirectoryArgs']] = None,
             custom_open_id_connect_providers: Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]] = None,
             facebook: Optional[pulumi.Input['FacebookArgs']] = None,
             git_hub: Optional[pulumi.Input['GitHubArgs']] = None,
             google: Optional[pulumi.Input['GoogleArgs']] = None,
             kind: Optional[pulumi.Input[str]] = None,
             twitter: Optional[pulumi.Input['TwitterArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'azureActiveDirectory' in kwargs:
            azure_active_directory = kwargs['azureActiveDirectory']
        if 'customOpenIdConnectProviders' in kwargs:
            custom_open_id_connect_providers = kwargs['customOpenIdConnectProviders']
        if 'gitHub' in kwargs:
            git_hub = kwargs['gitHub']

        if azure_active_directory is not None:
            _setter("azure_active_directory", azure_active_directory)
        if custom_open_id_connect_providers is not None:
            _setter("custom_open_id_connect_providers", custom_open_id_connect_providers)
        if facebook is not None:
            _setter("facebook", facebook)
        if git_hub is not None:
            _setter("git_hub", git_hub)
        if google is not None:
            _setter("google", google)
        if kind is not None:
            _setter("kind", kind)
        if twitter is not None:
            _setter("twitter", twitter)

    @property
    @pulumi.getter(name="azureActiveDirectory")
    def azure_active_directory(self) -> Optional[pulumi.Input['AzureActiveDirectoryArgs']]:
        return pulumi.get(self, "azure_active_directory")

    @azure_active_directory.setter
    def azure_active_directory(self, value: Optional[pulumi.Input['AzureActiveDirectoryArgs']]):
        pulumi.set(self, "azure_active_directory", value)

    @property
    @pulumi.getter(name="customOpenIdConnectProviders")
    def custom_open_id_connect_providers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]]:
        return pulumi.get(self, "custom_open_id_connect_providers")

    @custom_open_id_connect_providers.setter
    def custom_open_id_connect_providers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]]):
        pulumi.set(self, "custom_open_id_connect_providers", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['FacebookArgs']]:
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['FacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter(name="gitHub")
    def git_hub(self) -> Optional[pulumi.Input['GitHubArgs']]:
        return pulumi.get(self, "git_hub")

    @git_hub.setter
    def git_hub(self, value: Optional[pulumi.Input['GitHubArgs']]):
        pulumi.set(self, "git_hub", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['GoogleArgs']]:
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['GoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['TwitterArgs']]:
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['TwitterArgs']]):
        pulumi.set(self, "twitter", value)


@pulumi.input_type
class IpSecurityRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 subnet_mask: Optional[pulumi.Input[str]] = None,
                 subnet_traffic_tag: Optional[pulumi.Input[int]] = None,
                 tag: Optional[pulumi.Input[Union[str, 'IpFilterTag']]] = None,
                 vnet_subnet_resource_id: Optional[pulumi.Input[str]] = None,
                 vnet_traffic_tag: Optional[pulumi.Input[int]] = None):
        """
        IP security restriction on an app.
        :param pulumi.Input[str] action: Allow or Deny access for this IP range.
        :param pulumi.Input[str] description: IP restriction rule description.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]] headers: IP restriction rule headers.
               X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples). 
               The matching logic is ..
               - If the property is null or empty (default), all hosts(or lack of) are allowed.
               - A value is compared using ordinal-ignore-case (excluding port number).
               - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain foo.contoso.com
                but not the root domain contoso.com or multi-level foo.bar.contoso.com
               - Unicode host names are allowed but are converted to Punycode for matching.
               
               X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
               The matching logic is ..
               - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
               - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.
               
               X-Azure-FDID and X-FD-HealthProbe.
               The matching logic is exact match.
        :param pulumi.Input[str] ip_address: IP address the security restriction is valid for.
               It can be in form of pure ipv4 address (required SubnetMask property) or
               CIDR notation such as ipv4/mask (leading bit match). For CIDR,
               SubnetMask property must not be specified.
        :param pulumi.Input[str] name: IP restriction rule name.
        :param pulumi.Input[int] priority: Priority of IP restriction rule.
        :param pulumi.Input[str] subnet_mask: Subnet mask for the range of IP addresses the restriction is valid for.
        :param pulumi.Input[int] subnet_traffic_tag: (internal) Subnet traffic tag
        :param pulumi.Input[Union[str, 'IpFilterTag']] tag: Defines what this IP filter will be used for. This is to support IP filtering on proxies.
        :param pulumi.Input[str] vnet_subnet_resource_id: Virtual network resource id
        :param pulumi.Input[int] vnet_traffic_tag: (internal) Vnet traffic tag
        """
        IpSecurityRestrictionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            description=description,
            headers=headers,
            ip_address=ip_address,
            name=name,
            priority=priority,
            subnet_mask=subnet_mask,
            subnet_traffic_tag=subnet_traffic_tag,
            tag=tag,
            vnet_subnet_resource_id=vnet_subnet_resource_id,
            vnet_traffic_tag=vnet_traffic_tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]] = None,
             ip_address: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             priority: Optional[pulumi.Input[int]] = None,
             subnet_mask: Optional[pulumi.Input[str]] = None,
             subnet_traffic_tag: Optional[pulumi.Input[int]] = None,
             tag: Optional[pulumi.Input[Union[str, 'IpFilterTag']]] = None,
             vnet_subnet_resource_id: Optional[pulumi.Input[str]] = None,
             vnet_traffic_tag: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if 'subnetMask' in kwargs:
            subnet_mask = kwargs['subnetMask']
        if 'subnetTrafficTag' in kwargs:
            subnet_traffic_tag = kwargs['subnetTrafficTag']
        if 'vnetSubnetResourceId' in kwargs:
            vnet_subnet_resource_id = kwargs['vnetSubnetResourceId']
        if 'vnetTrafficTag' in kwargs:
            vnet_traffic_tag = kwargs['vnetTrafficTag']

        if action is not None:
            _setter("action", action)
        if description is not None:
            _setter("description", description)
        if headers is not None:
            _setter("headers", headers)
        if ip_address is not None:
            _setter("ip_address", ip_address)
        if name is not None:
            _setter("name", name)
        if priority is not None:
            _setter("priority", priority)
        if subnet_mask is not None:
            _setter("subnet_mask", subnet_mask)
        if subnet_traffic_tag is not None:
            _setter("subnet_traffic_tag", subnet_traffic_tag)
        if tag is not None:
            _setter("tag", tag)
        if vnet_subnet_resource_id is not None:
            _setter("vnet_subnet_resource_id", vnet_subnet_resource_id)
        if vnet_traffic_tag is not None:
            _setter("vnet_traffic_tag", vnet_traffic_tag)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Allow or Deny access for this IP range.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        IP restriction rule description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]:
        """
        IP restriction rule headers.
        X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples). 
        The matching logic is ..
        - If the property is null or empty (default), all hosts(or lack of) are allowed.
        - A value is compared using ordinal-ignore-case (excluding port number).
        - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain foo.contoso.com
         but not the root domain contoso.com or multi-level foo.bar.contoso.com
        - Unicode host names are allowed but are converted to Punycode for matching.

        X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
        The matching logic is ..
        - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
        - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.

        X-Azure-FDID and X-FD-HealthProbe.
        The matching logic is exact match.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[str]]]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        IP address the security restriction is valid for.
        It can be in form of pure ipv4 address (required SubnetMask property) or
        CIDR notation such as ipv4/mask (leading bit match). For CIDR,
        SubnetMask property must not be specified.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        IP restriction rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Priority of IP restriction rule.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[str]]:
        """
        Subnet mask for the range of IP addresses the restriction is valid for.
        """
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_mask", value)

    @property
    @pulumi.getter(name="subnetTrafficTag")
    def subnet_traffic_tag(self) -> Optional[pulumi.Input[int]]:
        """
        (internal) Subnet traffic tag
        """
        return pulumi.get(self, "subnet_traffic_tag")

    @subnet_traffic_tag.setter
    def subnet_traffic_tag(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "subnet_traffic_tag", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[Union[str, 'IpFilterTag']]]:
        """
        Defines what this IP filter will be used for. This is to support IP filtering on proxies.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[Union[str, 'IpFilterTag']]]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter(name="vnetSubnetResourceId")
    def vnet_subnet_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        Virtual network resource id
        """
        return pulumi.get(self, "vnet_subnet_resource_id")

    @vnet_subnet_resource_id.setter
    def vnet_subnet_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_subnet_resource_id", value)

    @property
    @pulumi.getter(name="vnetTrafficTag")
    def vnet_traffic_tag(self) -> Optional[pulumi.Input[int]]:
        """
        (internal) Vnet traffic tag
        """
        return pulumi.get(self, "vnet_traffic_tag")

    @vnet_traffic_tag.setter
    def vnet_traffic_tag(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vnet_traffic_tag", value)


@pulumi.input_type
class JwtClaimChecksArgs:
    def __init__(__self__, *,
                 allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        JwtClaimChecksArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_client_applications=allowed_client_applications,
            allowed_groups=allowed_groups,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedClientApplications' in kwargs:
            allowed_client_applications = kwargs['allowedClientApplications']
        if 'allowedGroups' in kwargs:
            allowed_groups = kwargs['allowedGroups']

        if allowed_client_applications is not None:
            _setter("allowed_client_applications", allowed_client_applications)
        if allowed_groups is not None:
            _setter("allowed_groups", allowed_groups)
        if kind is not None:
            _setter("kind", kind)

    @property
    @pulumi.getter(name="allowedClientApplications")
    def allowed_client_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_client_applications")

    @allowed_client_applications.setter
    def allowed_client_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_client_applications", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_groups", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


@pulumi.input_type
class LoginRoutesArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 logout_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        LoginRoutesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
            logout_endpoint=logout_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: Optional[pulumi.Input[str]] = None,
             logout_endpoint: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'logoutEndpoint' in kwargs:
            logout_endpoint = kwargs['logoutEndpoint']

        if kind is not None:
            _setter("kind", kind)
        if logout_endpoint is not None:
            _setter("logout_endpoint", logout_endpoint)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "logout_endpoint")

    @logout_endpoint.setter
    def logout_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_endpoint", value)


@pulumi.input_type
class LoginScopesArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        LoginScopesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
            scopes=scopes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: Optional[pulumi.Input[str]] = None,
             scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if kind is not None:
            _setter("kind", kind)
        if scopes is not None:
            _setter("scopes", scopes)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)


@pulumi.input_type
class LoginArgs:
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cookie_expiration: Optional[pulumi.Input['CookieExpirationArgs']] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 nonce: Optional[pulumi.Input['NonceArgs']] = None,
                 preserve_url_fragments_for_logins: Optional[pulumi.Input[bool]] = None,
                 routes: Optional[pulumi.Input['LoginRoutesArgs']] = None,
                 token_store: Optional[pulumi.Input['TokenStoreArgs']] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        LoginArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_external_redirect_urls=allowed_external_redirect_urls,
            cookie_expiration=cookie_expiration,
            kind=kind,
            nonce=nonce,
            preserve_url_fragments_for_logins=preserve_url_fragments_for_logins,
            routes=routes,
            token_store=token_store,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cookie_expiration: Optional[pulumi.Input['CookieExpirationArgs']] = None,
             kind: Optional[pulumi.Input[str]] = None,
             nonce: Optional[pulumi.Input['NonceArgs']] = None,
             preserve_url_fragments_for_logins: Optional[pulumi.Input[bool]] = None,
             routes: Optional[pulumi.Input['LoginRoutesArgs']] = None,
             token_store: Optional[pulumi.Input['TokenStoreArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedExternalRedirectUrls' in kwargs:
            allowed_external_redirect_urls = kwargs['allowedExternalRedirectUrls']
        if 'cookieExpiration' in kwargs:
            cookie_expiration = kwargs['cookieExpiration']
        if 'preserveUrlFragmentsForLogins' in kwargs:
            preserve_url_fragments_for_logins = kwargs['preserveUrlFragmentsForLogins']
        if 'tokenStore' in kwargs:
            token_store = kwargs['tokenStore']

        if allowed_external_redirect_urls is not None:
            _setter("allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration is not None:
            _setter("cookie_expiration", cookie_expiration)
        if kind is not None:
            _setter("kind", kind)
        if nonce is not None:
            _setter("nonce", nonce)
        if preserve_url_fragments_for_logins is not None:
            _setter("preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if routes is not None:
            _setter("routes", routes)
        if token_store is not None:
            _setter("token_store", token_store)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="cookieExpiration")
    def cookie_expiration(self) -> Optional[pulumi.Input['CookieExpirationArgs']]:
        return pulumi.get(self, "cookie_expiration")

    @cookie_expiration.setter
    def cookie_expiration(self, value: Optional[pulumi.Input['CookieExpirationArgs']]):
        pulumi.set(self, "cookie_expiration", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def nonce(self) -> Optional[pulumi.Input['NonceArgs']]:
        return pulumi.get(self, "nonce")

    @nonce.setter
    def nonce(self, value: Optional[pulumi.Input['NonceArgs']]):
        pulumi.set(self, "nonce", value)

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @preserve_url_fragments_for_logins.setter
    def preserve_url_fragments_for_logins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_url_fragments_for_logins", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input['LoginRoutesArgs']]:
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input['LoginRoutesArgs']]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter(name="tokenStore")
    def token_store(self) -> Optional[pulumi.Input['TokenStoreArgs']]:
        return pulumi.get(self, "token_store")

    @token_store.setter
    def token_store(self, value: Optional[pulumi.Input['TokenStoreArgs']]):
        pulumi.set(self, "token_store", value)


@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ManagedServiceIdentityType']] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity.
        :param pulumi.Input['ManagedServiceIdentityType'] type: Type of managed service identity.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        """
        ManagedServiceIdentityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input['ManagedServiceIdentityType']] = None,
             user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        if type is not None:
            _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ManagedServiceIdentityType']]:
        """
        Type of managed service identity.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


@pulumi.input_type
class NameValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Name value pair.
        :param pulumi.Input[str] name: Pair name.
        :param pulumi.Input[str] value: Pair value.
        """
        NameValuePairArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Pair name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Pair value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class NetworkAccessControlEntryArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['AccessControlEntryAction']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 remote_subnet: Optional[pulumi.Input[str]] = None):
        """
        Network access control entry.
        :param pulumi.Input['AccessControlEntryAction'] action: Action object.
        :param pulumi.Input[str] description: Description of network access control entry.
        :param pulumi.Input[int] order: Order of precedence.
        :param pulumi.Input[str] remote_subnet: Remote subnet.
        """
        NetworkAccessControlEntryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            description=description,
            order=order,
            remote_subnet=remote_subnet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[pulumi.Input['AccessControlEntryAction']] = None,
             description: Optional[pulumi.Input[str]] = None,
             order: Optional[pulumi.Input[int]] = None,
             remote_subnet: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'remoteSubnet' in kwargs:
            remote_subnet = kwargs['remoteSubnet']

        if action is not None:
            _setter("action", action)
        if description is not None:
            _setter("description", description)
        if order is not None:
            _setter("order", order)
        if remote_subnet is not None:
            _setter("remote_subnet", remote_subnet)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['AccessControlEntryAction']]:
        """
        Action object.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['AccessControlEntryAction']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of network access control entry.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Order of precedence.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="remoteSubnet")
    def remote_subnet(self) -> Optional[pulumi.Input[str]]:
        """
        Remote subnet.
        """
        return pulumi.get(self, "remote_subnet")

    @remote_subnet.setter
    def remote_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_subnet", value)


@pulumi.input_type
class NonceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 nonce_expiration_interval: Optional[pulumi.Input[str]] = None,
                 validate_nonce: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        NonceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
            nonce_expiration_interval=nonce_expiration_interval,
            validate_nonce=validate_nonce,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: Optional[pulumi.Input[str]] = None,
             nonce_expiration_interval: Optional[pulumi.Input[str]] = None,
             validate_nonce: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'nonceExpirationInterval' in kwargs:
            nonce_expiration_interval = kwargs['nonceExpirationInterval']
        if 'validateNonce' in kwargs:
            validate_nonce = kwargs['validateNonce']

        if kind is not None:
            _setter("kind", kind)
        if nonce_expiration_interval is not None:
            _setter("nonce_expiration_interval", nonce_expiration_interval)
        if validate_nonce is not None:
            _setter("validate_nonce", validate_nonce)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="nonceExpirationInterval")
    def nonce_expiration_interval(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nonce_expiration_interval")

    @nonce_expiration_interval.setter
    def nonce_expiration_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nonce_expiration_interval", value)

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "validate_nonce")

    @validate_nonce.setter
    def validate_nonce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_nonce", value)


@pulumi.input_type
class OpenIdConnectClientCredentialArgs:
    def __init__(__self__, *,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input['ClientCredentialMethod']] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        OpenIdConnectClientCredentialArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_secret_setting_name=client_secret_setting_name,
            kind=kind,
            method=method,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_secret_setting_name: Optional[pulumi.Input[str]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             method: Optional[pulumi.Input['ClientCredentialMethod']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientSecretSettingName' in kwargs:
            client_secret_setting_name = kwargs['clientSecretSettingName']

        if client_secret_setting_name is not None:
            _setter("client_secret_setting_name", client_secret_setting_name)
        if kind is not None:
            _setter("kind", kind)
        if method is not None:
            _setter("method", method)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['ClientCredentialMethod']]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['ClientCredentialMethod']]):
        pulumi.set(self, "method", value)


@pulumi.input_type
class OpenIdConnectConfigArgs:
    def __init__(__self__, *,
                 authorization_endpoint: Optional[pulumi.Input[str]] = None,
                 certification_uri: Optional[pulumi.Input[str]] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 token_endpoint: Optional[pulumi.Input[str]] = None,
                 well_known_open_id_configuration: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        OpenIdConnectConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorization_endpoint=authorization_endpoint,
            certification_uri=certification_uri,
            issuer=issuer,
            kind=kind,
            token_endpoint=token_endpoint,
            well_known_open_id_configuration=well_known_open_id_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorization_endpoint: Optional[pulumi.Input[str]] = None,
             certification_uri: Optional[pulumi.Input[str]] = None,
             issuer: Optional[pulumi.Input[str]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             token_endpoint: Optional[pulumi.Input[str]] = None,
             well_known_open_id_configuration: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'authorizationEndpoint' in kwargs:
            authorization_endpoint = kwargs['authorizationEndpoint']
        if 'certificationUri' in kwargs:
            certification_uri = kwargs['certificationUri']
        if 'tokenEndpoint' in kwargs:
            token_endpoint = kwargs['tokenEndpoint']
        if 'wellKnownOpenIdConfiguration' in kwargs:
            well_known_open_id_configuration = kwargs['wellKnownOpenIdConfiguration']

        if authorization_endpoint is not None:
            _setter("authorization_endpoint", authorization_endpoint)
        if certification_uri is not None:
            _setter("certification_uri", certification_uri)
        if issuer is not None:
            _setter("issuer", issuer)
        if kind is not None:
            _setter("kind", kind)
        if token_endpoint is not None:
            _setter("token_endpoint", token_endpoint)
        if well_known_open_id_configuration is not None:
            _setter("well_known_open_id_configuration", well_known_open_id_configuration)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "certification_uri")

    @certification_uri.setter
    def certification_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certification_uri", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="wellKnownOpenIdConfiguration")
    def well_known_open_id_configuration(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "well_known_open_id_configuration")

    @well_known_open_id_configuration.setter
    def well_known_open_id_configuration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "well_known_open_id_configuration", value)


@pulumi.input_type
class OpenIdConnectLoginArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name_claim_type: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        OpenIdConnectLoginArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
            name_claim_type=name_claim_type,
            scopes=scopes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: Optional[pulumi.Input[str]] = None,
             name_claim_type: Optional[pulumi.Input[str]] = None,
             scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'nameClaimType' in kwargs:
            name_claim_type = kwargs['nameClaimType']

        if kind is not None:
            _setter("kind", kind)
        if name_claim_type is not None:
            _setter("name_claim_type", name_claim_type)
        if scopes is not None:
            _setter("scopes", scopes)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name_claim_type")

    @name_claim_type.setter
    def name_claim_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_claim_type", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)


@pulumi.input_type
class OpenIdConnectRegistrationArgs:
    def __init__(__self__, *,
                 client_credential: Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 open_id_connect_configuration: Optional[pulumi.Input['OpenIdConnectConfigArgs']] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        OpenIdConnectRegistrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_credential=client_credential,
            client_id=client_id,
            kind=kind,
            open_id_connect_configuration=open_id_connect_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_credential: Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']] = None,
             client_id: Optional[pulumi.Input[str]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             open_id_connect_configuration: Optional[pulumi.Input['OpenIdConnectConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientCredential' in kwargs:
            client_credential = kwargs['clientCredential']
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if 'openIdConnectConfiguration' in kwargs:
            open_id_connect_configuration = kwargs['openIdConnectConfiguration']

        if client_credential is not None:
            _setter("client_credential", client_credential)
        if client_id is not None:
            _setter("client_id", client_id)
        if kind is not None:
            _setter("kind", kind)
        if open_id_connect_configuration is not None:
            _setter("open_id_connect_configuration", open_id_connect_configuration)

    @property
    @pulumi.getter(name="clientCredential")
    def client_credential(self) -> Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']]:
        return pulumi.get(self, "client_credential")

    @client_credential.setter
    def client_credential(self, value: Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']]):
        pulumi.set(self, "client_credential", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="openIdConnectConfiguration")
    def open_id_connect_configuration(self) -> Optional[pulumi.Input['OpenIdConnectConfigArgs']]:
        return pulumi.get(self, "open_id_connect_configuration")

    @open_id_connect_configuration.setter
    def open_id_connect_configuration(self, value: Optional[pulumi.Input['OpenIdConnectConfigArgs']]):
        pulumi.set(self, "open_id_connect_configuration", value)


@pulumi.input_type
class PrivateLinkConnectionStateArgs:
    def __init__(__self__, *,
                 actions_required: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        The state of a private link connection
        :param pulumi.Input[str] actions_required: ActionsRequired for a private link connection
        :param pulumi.Input[str] description: Description of a private link connection
        :param pulumi.Input[str] status: Status of a private link connection
        """
        PrivateLinkConnectionStateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions_required=actions_required,
            description=description,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions_required: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'actionsRequired' in kwargs:
            actions_required = kwargs['actionsRequired']

        if actions_required is not None:
            _setter("actions_required", actions_required)
        if description is not None:
            _setter("description", description)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[pulumi.Input[str]]:
        """
        ActionsRequired for a private link connection
        """
        return pulumi.get(self, "actions_required")

    @actions_required.setter
    def actions_required(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "actions_required", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of a private link connection
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Status of a private link connection
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class PushSettingsArgs:
    def __init__(__self__, *,
                 is_push_enabled: pulumi.Input[bool],
                 dynamic_tags_json: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 tag_whitelist_json: Optional[pulumi.Input[str]] = None,
                 tags_requiring_auth: Optional[pulumi.Input[str]] = None):
        """
        Push settings for the App.
        :param pulumi.Input[bool] is_push_enabled: Gets or sets a flag indicating whether the Push endpoint is enabled.
        :param pulumi.Input[str] dynamic_tags_json: Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration endpoint.
        :param pulumi.Input[str] kind: Kind of resource.
        :param pulumi.Input[str] tag_whitelist_json: Gets or sets a JSON string containing a list of tags that are in the allowed list for use by the push registration endpoint.
        :param pulumi.Input[str] tags_requiring_auth: Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration endpoint.
               Tags can consist of alphanumeric characters and the following:
               '_', '@', '#', '.', ':', '-'. 
               Validation should be performed at the PushRequestHandler.
        """
        PushSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_push_enabled=is_push_enabled,
            dynamic_tags_json=dynamic_tags_json,
            kind=kind,
            tag_whitelist_json=tag_whitelist_json,
            tags_requiring_auth=tags_requiring_auth,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_push_enabled: pulumi.Input[bool],
             dynamic_tags_json: Optional[pulumi.Input[str]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             tag_whitelist_json: Optional[pulumi.Input[str]] = None,
             tags_requiring_auth: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isPushEnabled' in kwargs:
            is_push_enabled = kwargs['isPushEnabled']
        if 'dynamicTagsJson' in kwargs:
            dynamic_tags_json = kwargs['dynamicTagsJson']
        if 'tagWhitelistJson' in kwargs:
            tag_whitelist_json = kwargs['tagWhitelistJson']
        if 'tagsRequiringAuth' in kwargs:
            tags_requiring_auth = kwargs['tagsRequiringAuth']

        _setter("is_push_enabled", is_push_enabled)
        if dynamic_tags_json is not None:
            _setter("dynamic_tags_json", dynamic_tags_json)
        if kind is not None:
            _setter("kind", kind)
        if tag_whitelist_json is not None:
            _setter("tag_whitelist_json", tag_whitelist_json)
        if tags_requiring_auth is not None:
            _setter("tags_requiring_auth", tags_requiring_auth)

    @property
    @pulumi.getter(name="isPushEnabled")
    def is_push_enabled(self) -> pulumi.Input[bool]:
        """
        Gets or sets a flag indicating whether the Push endpoint is enabled.
        """
        return pulumi.get(self, "is_push_enabled")

    @is_push_enabled.setter
    def is_push_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_push_enabled", value)

    @property
    @pulumi.getter(name="dynamicTagsJson")
    def dynamic_tags_json(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration endpoint.
        """
        return pulumi.get(self, "dynamic_tags_json")

    @dynamic_tags_json.setter
    def dynamic_tags_json(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dynamic_tags_json", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="tagWhitelistJson")
    def tag_whitelist_json(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets a JSON string containing a list of tags that are in the allowed list for use by the push registration endpoint.
        """
        return pulumi.get(self, "tag_whitelist_json")

    @tag_whitelist_json.setter
    def tag_whitelist_json(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_whitelist_json", value)

    @property
    @pulumi.getter(name="tagsRequiringAuth")
    def tags_requiring_auth(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration endpoint.
        Tags can consist of alphanumeric characters and the following:
        '_', '@', '#', '.', ':', '-'. 
        Validation should be performed at the PushRequestHandler.
        """
        return pulumi.get(self, "tags_requiring_auth")

    @tags_requiring_auth.setter
    def tags_requiring_auth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags_requiring_auth", value)


@pulumi.input_type
class RampUpRuleArgs:
    def __init__(__self__, *,
                 action_host_name: Optional[pulumi.Input[str]] = None,
                 change_decision_callback_url: Optional[pulumi.Input[str]] = None,
                 change_interval_in_minutes: Optional[pulumi.Input[int]] = None,
                 change_step: Optional[pulumi.Input[float]] = None,
                 max_reroute_percentage: Optional[pulumi.Input[float]] = None,
                 min_reroute_percentage: Optional[pulumi.Input[float]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 reroute_percentage: Optional[pulumi.Input[float]] = None):
        """
        Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to gradually change routing % based on performance.
        :param pulumi.Input[str] action_host_name: Hostname of a slot to which the traffic will be redirected if decided to. E.g. myapp-stage.azurewebsites.net.
        :param pulumi.Input[str] change_decision_callback_url: Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified. See TiPCallback site extension for the scaffold and contracts.
               https://www.siteextensions.net/packages/TiPCallback/
        :param pulumi.Input[int] change_interval_in_minutes: Specifies interval in minutes to reevaluate ReroutePercentage.
        :param pulumi.Input[float] change_step: In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches \\n<code>MinReroutePercentage</code> or 
               <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in <code>ChangeIntervalInMinutes</code>.\\nCustom decision algorithm 
               can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
        :param pulumi.Input[float] max_reroute_percentage: Specifies upper boundary below which ReroutePercentage will stay.
        :param pulumi.Input[float] min_reroute_percentage: Specifies lower boundary above which ReroutePercentage will stay.
        :param pulumi.Input[str] name: Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the experiment.
        :param pulumi.Input[float] reroute_percentage: Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
        """
        RampUpRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_host_name=action_host_name,
            change_decision_callback_url=change_decision_callback_url,
            change_interval_in_minutes=change_interval_in_minutes,
            change_step=change_step,
            max_reroute_percentage=max_reroute_percentage,
            min_reroute_percentage=min_reroute_percentage,
            name=name,
            reroute_percentage=reroute_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_host_name: Optional[pulumi.Input[str]] = None,
             change_decision_callback_url: Optional[pulumi.Input[str]] = None,
             change_interval_in_minutes: Optional[pulumi.Input[int]] = None,
             change_step: Optional[pulumi.Input[float]] = None,
             max_reroute_percentage: Optional[pulumi.Input[float]] = None,
             min_reroute_percentage: Optional[pulumi.Input[float]] = None,
             name: Optional[pulumi.Input[str]] = None,
             reroute_percentage: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'actionHostName' in kwargs:
            action_host_name = kwargs['actionHostName']
        if 'changeDecisionCallbackUrl' in kwargs:
            change_decision_callback_url = kwargs['changeDecisionCallbackUrl']
        if 'changeIntervalInMinutes' in kwargs:
            change_interval_in_minutes = kwargs['changeIntervalInMinutes']
        if 'changeStep' in kwargs:
            change_step = kwargs['changeStep']
        if 'maxReroutePercentage' in kwargs:
            max_reroute_percentage = kwargs['maxReroutePercentage']
        if 'minReroutePercentage' in kwargs:
            min_reroute_percentage = kwargs['minReroutePercentage']
        if 'reroutePercentage' in kwargs:
            reroute_percentage = kwargs['reroutePercentage']

        if action_host_name is not None:
            _setter("action_host_name", action_host_name)
        if change_decision_callback_url is not None:
            _setter("change_decision_callback_url", change_decision_callback_url)
        if change_interval_in_minutes is not None:
            _setter("change_interval_in_minutes", change_interval_in_minutes)
        if change_step is not None:
            _setter("change_step", change_step)
        if max_reroute_percentage is not None:
            _setter("max_reroute_percentage", max_reroute_percentage)
        if min_reroute_percentage is not None:
            _setter("min_reroute_percentage", min_reroute_percentage)
        if name is not None:
            _setter("name", name)
        if reroute_percentage is not None:
            _setter("reroute_percentage", reroute_percentage)

    @property
    @pulumi.getter(name="actionHostName")
    def action_host_name(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of a slot to which the traffic will be redirected if decided to. E.g. myapp-stage.azurewebsites.net.
        """
        return pulumi.get(self, "action_host_name")

    @action_host_name.setter
    def action_host_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_host_name", value)

    @property
    @pulumi.getter(name="changeDecisionCallbackUrl")
    def change_decision_callback_url(self) -> Optional[pulumi.Input[str]]:
        """
        Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified. See TiPCallback site extension for the scaffold and contracts.
        https://www.siteextensions.net/packages/TiPCallback/
        """
        return pulumi.get(self, "change_decision_callback_url")

    @change_decision_callback_url.setter
    def change_decision_callback_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "change_decision_callback_url", value)

    @property
    @pulumi.getter(name="changeIntervalInMinutes")
    def change_interval_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies interval in minutes to reevaluate ReroutePercentage.
        """
        return pulumi.get(self, "change_interval_in_minutes")

    @change_interval_in_minutes.setter
    def change_interval_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "change_interval_in_minutes", value)

    @property
    @pulumi.getter(name="changeStep")
    def change_step(self) -> Optional[pulumi.Input[float]]:
        """
        In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches \\n<code>MinReroutePercentage</code> or 
        <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in <code>ChangeIntervalInMinutes</code>.\\nCustom decision algorithm 
        can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
        """
        return pulumi.get(self, "change_step")

    @change_step.setter
    def change_step(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "change_step", value)

    @property
    @pulumi.getter(name="maxReroutePercentage")
    def max_reroute_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies upper boundary below which ReroutePercentage will stay.
        """
        return pulumi.get(self, "max_reroute_percentage")

    @max_reroute_percentage.setter
    def max_reroute_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_reroute_percentage", value)

    @property
    @pulumi.getter(name="minReroutePercentage")
    def min_reroute_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies lower boundary above which ReroutePercentage will stay.
        """
        return pulumi.get(self, "min_reroute_percentage")

    @min_reroute_percentage.setter
    def min_reroute_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_reroute_percentage", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the experiment.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="reroutePercentage")
    def reroute_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
        """
        return pulumi.get(self, "reroute_percentage")

    @reroute_percentage.setter
    def reroute_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "reroute_percentage", value)


@pulumi.input_type
class RequestsBasedTriggerArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 time_interval: Optional[pulumi.Input[str]] = None):
        """
        Trigger based on total requests.
        :param pulumi.Input[int] count: Request Count.
        :param pulumi.Input[str] time_interval: Time interval.
        """
        RequestsBasedTriggerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            time_interval=time_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[pulumi.Input[int]] = None,
             time_interval: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'timeInterval' in kwargs:
            time_interval = kwargs['timeInterval']

        if count is not None:
            _setter("count", count)
        if time_interval is not None:
            _setter("time_interval", time_interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")

    @time_interval.setter
    def time_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_interval", value)


@pulumi.input_type
class SiteConfigArgs:
    def __init__(__self__, *,
                 acr_use_managed_identity_creds: Optional[pulumi.Input[bool]] = None,
                 acr_user_managed_identity_id: Optional[pulumi.Input[str]] = None,
                 always_on: Optional[pulumi.Input[bool]] = None,
                 api_definition: Optional[pulumi.Input['ApiDefinitionInfoArgs']] = None,
                 api_management_config: Optional[pulumi.Input['ApiManagementConfigArgs']] = None,
                 app_command_line: Optional[pulumi.Input[str]] = None,
                 app_settings: Optional[pulumi.Input[Sequence[pulumi.Input['NameValuePairArgs']]]] = None,
                 auto_heal_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_heal_rules: Optional[pulumi.Input['AutoHealRulesArgs']] = None,
                 auto_swap_slot_name: Optional[pulumi.Input[str]] = None,
                 connection_strings: Optional[pulumi.Input[Sequence[pulumi.Input['ConnStringInfoArgs']]]] = None,
                 cors: Optional[pulumi.Input['CorsSettingsArgs']] = None,
                 default_documents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 detailed_error_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 document_root: Optional[pulumi.Input[str]] = None,
                 experiments: Optional[pulumi.Input['ExperimentsArgs']] = None,
                 ftps_state: Optional[pulumi.Input[Union[str, 'FtpsState']]] = None,
                 handler_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['HandlerMappingArgs']]]] = None,
                 health_check_path: Optional[pulumi.Input[str]] = None,
                 http20_enabled: Optional[pulumi.Input[bool]] = None,
                 http_logging_enabled: Optional[pulumi.Input[bool]] = None,
                 ip_security_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]] = None,
                 java_container: Optional[pulumi.Input[str]] = None,
                 java_container_version: Optional[pulumi.Input[str]] = None,
                 java_version: Optional[pulumi.Input[str]] = None,
                 limits: Optional[pulumi.Input['SiteLimitsArgs']] = None,
                 linux_fx_version: Optional[pulumi.Input[str]] = None,
                 load_balancing: Optional[pulumi.Input['SiteLoadBalancing']] = None,
                 local_my_sql_enabled: Optional[pulumi.Input[bool]] = None,
                 logs_directory_size_limit: Optional[pulumi.Input[int]] = None,
                 managed_pipeline_mode: Optional[pulumi.Input['ManagedPipelineMode']] = None,
                 managed_service_identity_id: Optional[pulumi.Input[int]] = None,
                 min_tls_version: Optional[pulumi.Input[Union[str, 'SupportedTlsVersions']]] = None,
                 net_framework_version: Optional[pulumi.Input[str]] = None,
                 node_version: Optional[pulumi.Input[str]] = None,
                 number_of_workers: Optional[pulumi.Input[int]] = None,
                 php_version: Optional[pulumi.Input[str]] = None,
                 power_shell_version: Optional[pulumi.Input[str]] = None,
                 pre_warmed_instance_count: Optional[pulumi.Input[int]] = None,
                 publishing_username: Optional[pulumi.Input[str]] = None,
                 push: Optional[pulumi.Input['PushSettingsArgs']] = None,
                 python_version: Optional[pulumi.Input[str]] = None,
                 remote_debugging_enabled: Optional[pulumi.Input[bool]] = None,
                 remote_debugging_version: Optional[pulumi.Input[str]] = None,
                 request_tracing_enabled: Optional[pulumi.Input[bool]] = None,
                 request_tracing_expiration_time: Optional[pulumi.Input[str]] = None,
                 scm_ip_security_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]] = None,
                 scm_ip_security_restrictions_use_main: Optional[pulumi.Input[bool]] = None,
                 scm_min_tls_version: Optional[pulumi.Input[Union[str, 'SupportedTlsVersions']]] = None,
                 scm_type: Optional[pulumi.Input[Union[str, 'ScmType']]] = None,
                 tracing_options: Optional[pulumi.Input[str]] = None,
                 use32_bit_worker_process: Optional[pulumi.Input[bool]] = None,
                 virtual_applications: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualApplicationArgs']]]] = None,
                 vnet_name: Optional[pulumi.Input[str]] = None,
                 vnet_private_ports_count: Optional[pulumi.Input[int]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
                 web_sockets_enabled: Optional[pulumi.Input[bool]] = None,
                 windows_fx_version: Optional[pulumi.Input[str]] = None,
                 x_managed_service_identity_id: Optional[pulumi.Input[int]] = None):
        """
        Configuration of an App Service app.
        :param pulumi.Input[bool] acr_use_managed_identity_creds: Flag to use Managed Identity Creds for ACR pull
        :param pulumi.Input[str] acr_user_managed_identity_id: If using user managed identity, the user managed identity ClientId
        :param pulumi.Input[bool] always_on: <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
        :param pulumi.Input['ApiDefinitionInfoArgs'] api_definition: Information about the formal API definition for the app.
        :param pulumi.Input['ApiManagementConfigArgs'] api_management_config: Azure API management settings linked to the app.
        :param pulumi.Input[str] app_command_line: App command line to launch.
        :param pulumi.Input[Sequence[pulumi.Input['NameValuePairArgs']]] app_settings: Application settings.
        :param pulumi.Input[bool] auto_heal_enabled: <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
        :param pulumi.Input['AutoHealRulesArgs'] auto_heal_rules: Auto Heal rules.
        :param pulumi.Input[str] auto_swap_slot_name: Auto-swap slot name.
        :param pulumi.Input[Sequence[pulumi.Input['ConnStringInfoArgs']]] connection_strings: Connection strings.
        :param pulumi.Input['CorsSettingsArgs'] cors: Cross-Origin Resource Sharing (CORS) settings.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] default_documents: Default documents.
        :param pulumi.Input[bool] detailed_error_logging_enabled: <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
        :param pulumi.Input[str] document_root: Document root.
        :param pulumi.Input['ExperimentsArgs'] experiments: This is work around for polymorphic types.
        :param pulumi.Input[Union[str, 'FtpsState']] ftps_state: State of FTP / FTPS service
        :param pulumi.Input[Sequence[pulumi.Input['HandlerMappingArgs']]] handler_mappings: Handler mappings.
        :param pulumi.Input[str] health_check_path: Health check path
        :param pulumi.Input[bool] http20_enabled: Http20Enabled: configures a web site to allow clients to connect over http2.0
        :param pulumi.Input[bool] http_logging_enabled: <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
        :param pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]] ip_security_restrictions: IP security restrictions for main.
        :param pulumi.Input[str] java_container: Java container.
        :param pulumi.Input[str] java_container_version: Java container version.
        :param pulumi.Input[str] java_version: Java version.
        :param pulumi.Input['SiteLimitsArgs'] limits: Site limits.
        :param pulumi.Input[str] linux_fx_version: Linux App Framework and version
        :param pulumi.Input['SiteLoadBalancing'] load_balancing: Site load balancing.
        :param pulumi.Input[bool] local_my_sql_enabled: <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
        :param pulumi.Input[int] logs_directory_size_limit: HTTP logs directory size limit.
        :param pulumi.Input['ManagedPipelineMode'] managed_pipeline_mode: Managed pipeline mode.
        :param pulumi.Input[int] managed_service_identity_id: Managed Service Identity Id
        :param pulumi.Input[Union[str, 'SupportedTlsVersions']] min_tls_version: MinTlsVersion: configures the minimum version of TLS required for SSL requests
        :param pulumi.Input[str] net_framework_version: .NET Framework version.
        :param pulumi.Input[str] node_version: Version of Node.js.
        :param pulumi.Input[int] number_of_workers: Number of workers.
        :param pulumi.Input[str] php_version: Version of PHP.
        :param pulumi.Input[str] power_shell_version: Version of PowerShell.
        :param pulumi.Input[int] pre_warmed_instance_count: Number of preWarmed instances.
               This setting only applies to the Consumption and Elastic Plans
        :param pulumi.Input[str] publishing_username: Publishing user name.
        :param pulumi.Input['PushSettingsArgs'] push: Push endpoint settings.
        :param pulumi.Input[str] python_version: Version of Python.
        :param pulumi.Input[bool] remote_debugging_enabled: <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
        :param pulumi.Input[str] remote_debugging_version: Remote debugging version.
        :param pulumi.Input[bool] request_tracing_enabled: <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
        :param pulumi.Input[str] request_tracing_expiration_time: Request tracing expiration time.
        :param pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]] scm_ip_security_restrictions: IP security restrictions for scm.
        :param pulumi.Input[bool] scm_ip_security_restrictions_use_main: IP security restrictions for scm to use main.
        :param pulumi.Input[Union[str, 'SupportedTlsVersions']] scm_min_tls_version: ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
        :param pulumi.Input[Union[str, 'ScmType']] scm_type: SCM type.
        :param pulumi.Input[str] tracing_options: Tracing options.
        :param pulumi.Input[bool] use32_bit_worker_process: <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualApplicationArgs']]] virtual_applications: Virtual applications.
        :param pulumi.Input[str] vnet_name: Virtual Network name.
        :param pulumi.Input[int] vnet_private_ports_count: The number of private ports assigned to this app. These will be assigned dynamically on runtime.
        :param pulumi.Input[bool] vnet_route_all_enabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied.
        :param pulumi.Input[bool] web_sockets_enabled: <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
        :param pulumi.Input[str] windows_fx_version: Xenon App Framework and version
        :param pulumi.Input[int] x_managed_service_identity_id: Explicit Managed Service Identity Id
        """
        SiteConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acr_use_managed_identity_creds=acr_use_managed_identity_creds,
            acr_user_managed_identity_id=acr_user_managed_identity_id,
            always_on=always_on,
            api_definition=api_definition,
            api_management_config=api_management_config,
            app_command_line=app_command_line,
            app_settings=app_settings,
            auto_heal_enabled=auto_heal_enabled,
            auto_heal_rules=auto_heal_rules,
            auto_swap_slot_name=auto_swap_slot_name,
            connection_strings=connection_strings,
            cors=cors,
            default_documents=default_documents,
            detailed_error_logging_enabled=detailed_error_logging_enabled,
            document_root=document_root,
            experiments=experiments,
            ftps_state=ftps_state,
            handler_mappings=handler_mappings,
            health_check_path=health_check_path,
            http20_enabled=http20_enabled,
            http_logging_enabled=http_logging_enabled,
            ip_security_restrictions=ip_security_restrictions,
            java_container=java_container,
            java_container_version=java_container_version,
            java_version=java_version,
            limits=limits,
            linux_fx_version=linux_fx_version,
            load_balancing=load_balancing,
            local_my_sql_enabled=local_my_sql_enabled,
            logs_directory_size_limit=logs_directory_size_limit,
            managed_pipeline_mode=managed_pipeline_mode,
            managed_service_identity_id=managed_service_identity_id,
            min_tls_version=min_tls_version,
            net_framework_version=net_framework_version,
            node_version=node_version,
            number_of_workers=number_of_workers,
            php_version=php_version,
            power_shell_version=power_shell_version,
            pre_warmed_instance_count=pre_warmed_instance_count,
            publishing_username=publishing_username,
            push=push,
            python_version=python_version,
            remote_debugging_enabled=remote_debugging_enabled,
            remote_debugging_version=remote_debugging_version,
            request_tracing_enabled=request_tracing_enabled,
            request_tracing_expiration_time=request_tracing_expiration_time,
            scm_ip_security_restrictions=scm_ip_security_restrictions,
            scm_ip_security_restrictions_use_main=scm_ip_security_restrictions_use_main,
            scm_min_tls_version=scm_min_tls_version,
            scm_type=scm_type,
            tracing_options=tracing_options,
            use32_bit_worker_process=use32_bit_worker_process,
            virtual_applications=virtual_applications,
            vnet_name=vnet_name,
            vnet_private_ports_count=vnet_private_ports_count,
            vnet_route_all_enabled=vnet_route_all_enabled,
            web_sockets_enabled=web_sockets_enabled,
            windows_fx_version=windows_fx_version,
            x_managed_service_identity_id=x_managed_service_identity_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acr_use_managed_identity_creds: Optional[pulumi.Input[bool]] = None,
             acr_user_managed_identity_id: Optional[pulumi.Input[str]] = None,
             always_on: Optional[pulumi.Input[bool]] = None,
             api_definition: Optional[pulumi.Input['ApiDefinitionInfoArgs']] = None,
             api_management_config: Optional[pulumi.Input['ApiManagementConfigArgs']] = None,
             app_command_line: Optional[pulumi.Input[str]] = None,
             app_settings: Optional[pulumi.Input[Sequence[pulumi.Input['NameValuePairArgs']]]] = None,
             auto_heal_enabled: Optional[pulumi.Input[bool]] = None,
             auto_heal_rules: Optional[pulumi.Input['AutoHealRulesArgs']] = None,
             auto_swap_slot_name: Optional[pulumi.Input[str]] = None,
             connection_strings: Optional[pulumi.Input[Sequence[pulumi.Input['ConnStringInfoArgs']]]] = None,
             cors: Optional[pulumi.Input['CorsSettingsArgs']] = None,
             default_documents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             detailed_error_logging_enabled: Optional[pulumi.Input[bool]] = None,
             document_root: Optional[pulumi.Input[str]] = None,
             experiments: Optional[pulumi.Input['ExperimentsArgs']] = None,
             ftps_state: Optional[pulumi.Input[Union[str, 'FtpsState']]] = None,
             handler_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['HandlerMappingArgs']]]] = None,
             health_check_path: Optional[pulumi.Input[str]] = None,
             http20_enabled: Optional[pulumi.Input[bool]] = None,
             http_logging_enabled: Optional[pulumi.Input[bool]] = None,
             ip_security_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]] = None,
             java_container: Optional[pulumi.Input[str]] = None,
             java_container_version: Optional[pulumi.Input[str]] = None,
             java_version: Optional[pulumi.Input[str]] = None,
             limits: Optional[pulumi.Input['SiteLimitsArgs']] = None,
             linux_fx_version: Optional[pulumi.Input[str]] = None,
             load_balancing: Optional[pulumi.Input['SiteLoadBalancing']] = None,
             local_my_sql_enabled: Optional[pulumi.Input[bool]] = None,
             logs_directory_size_limit: Optional[pulumi.Input[int]] = None,
             managed_pipeline_mode: Optional[pulumi.Input['ManagedPipelineMode']] = None,
             managed_service_identity_id: Optional[pulumi.Input[int]] = None,
             min_tls_version: Optional[pulumi.Input[Union[str, 'SupportedTlsVersions']]] = None,
             net_framework_version: Optional[pulumi.Input[str]] = None,
             node_version: Optional[pulumi.Input[str]] = None,
             number_of_workers: Optional[pulumi.Input[int]] = None,
             php_version: Optional[pulumi.Input[str]] = None,
             power_shell_version: Optional[pulumi.Input[str]] = None,
             pre_warmed_instance_count: Optional[pulumi.Input[int]] = None,
             publishing_username: Optional[pulumi.Input[str]] = None,
             push: Optional[pulumi.Input['PushSettingsArgs']] = None,
             python_version: Optional[pulumi.Input[str]] = None,
             remote_debugging_enabled: Optional[pulumi.Input[bool]] = None,
             remote_debugging_version: Optional[pulumi.Input[str]] = None,
             request_tracing_enabled: Optional[pulumi.Input[bool]] = None,
             request_tracing_expiration_time: Optional[pulumi.Input[str]] = None,
             scm_ip_security_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]] = None,
             scm_ip_security_restrictions_use_main: Optional[pulumi.Input[bool]] = None,
             scm_min_tls_version: Optional[pulumi.Input[Union[str, 'SupportedTlsVersions']]] = None,
             scm_type: Optional[pulumi.Input[Union[str, 'ScmType']]] = None,
             tracing_options: Optional[pulumi.Input[str]] = None,
             use32_bit_worker_process: Optional[pulumi.Input[bool]] = None,
             virtual_applications: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualApplicationArgs']]]] = None,
             vnet_name: Optional[pulumi.Input[str]] = None,
             vnet_private_ports_count: Optional[pulumi.Input[int]] = None,
             vnet_route_all_enabled: Optional[pulumi.Input[bool]] = None,
             web_sockets_enabled: Optional[pulumi.Input[bool]] = None,
             windows_fx_version: Optional[pulumi.Input[str]] = None,
             x_managed_service_identity_id: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'acrUseManagedIdentityCreds' in kwargs:
            acr_use_managed_identity_creds = kwargs['acrUseManagedIdentityCreds']
        if 'acrUserManagedIdentityID' in kwargs:
            acr_user_managed_identity_id = kwargs['acrUserManagedIdentityID']
        if 'alwaysOn' in kwargs:
            always_on = kwargs['alwaysOn']
        if 'apiDefinition' in kwargs:
            api_definition = kwargs['apiDefinition']
        if 'apiManagementConfig' in kwargs:
            api_management_config = kwargs['apiManagementConfig']
        if 'appCommandLine' in kwargs:
            app_command_line = kwargs['appCommandLine']
        if 'appSettings' in kwargs:
            app_settings = kwargs['appSettings']
        if 'autoHealEnabled' in kwargs:
            auto_heal_enabled = kwargs['autoHealEnabled']
        if 'autoHealRules' in kwargs:
            auto_heal_rules = kwargs['autoHealRules']
        if 'autoSwapSlotName' in kwargs:
            auto_swap_slot_name = kwargs['autoSwapSlotName']
        if 'connectionStrings' in kwargs:
            connection_strings = kwargs['connectionStrings']
        if 'defaultDocuments' in kwargs:
            default_documents = kwargs['defaultDocuments']
        if 'detailedErrorLoggingEnabled' in kwargs:
            detailed_error_logging_enabled = kwargs['detailedErrorLoggingEnabled']
        if 'documentRoot' in kwargs:
            document_root = kwargs['documentRoot']
        if 'ftpsState' in kwargs:
            ftps_state = kwargs['ftpsState']
        if 'handlerMappings' in kwargs:
            handler_mappings = kwargs['handlerMappings']
        if 'healthCheckPath' in kwargs:
            health_check_path = kwargs['healthCheckPath']
        if 'http20Enabled' in kwargs:
            http20_enabled = kwargs['http20Enabled']
        if 'httpLoggingEnabled' in kwargs:
            http_logging_enabled = kwargs['httpLoggingEnabled']
        if 'ipSecurityRestrictions' in kwargs:
            ip_security_restrictions = kwargs['ipSecurityRestrictions']
        if 'javaContainer' in kwargs:
            java_container = kwargs['javaContainer']
        if 'javaContainerVersion' in kwargs:
            java_container_version = kwargs['javaContainerVersion']
        if 'javaVersion' in kwargs:
            java_version = kwargs['javaVersion']
        if 'linuxFxVersion' in kwargs:
            linux_fx_version = kwargs['linuxFxVersion']
        if 'loadBalancing' in kwargs:
            load_balancing = kwargs['loadBalancing']
        if 'localMySqlEnabled' in kwargs:
            local_my_sql_enabled = kwargs['localMySqlEnabled']
        if 'logsDirectorySizeLimit' in kwargs:
            logs_directory_size_limit = kwargs['logsDirectorySizeLimit']
        if 'managedPipelineMode' in kwargs:
            managed_pipeline_mode = kwargs['managedPipelineMode']
        if 'managedServiceIdentityId' in kwargs:
            managed_service_identity_id = kwargs['managedServiceIdentityId']
        if 'minTlsVersion' in kwargs:
            min_tls_version = kwargs['minTlsVersion']
        if 'netFrameworkVersion' in kwargs:
            net_framework_version = kwargs['netFrameworkVersion']
        if 'nodeVersion' in kwargs:
            node_version = kwargs['nodeVersion']
        if 'numberOfWorkers' in kwargs:
            number_of_workers = kwargs['numberOfWorkers']
        if 'phpVersion' in kwargs:
            php_version = kwargs['phpVersion']
        if 'powerShellVersion' in kwargs:
            power_shell_version = kwargs['powerShellVersion']
        if 'preWarmedInstanceCount' in kwargs:
            pre_warmed_instance_count = kwargs['preWarmedInstanceCount']
        if 'publishingUsername' in kwargs:
            publishing_username = kwargs['publishingUsername']
        if 'pythonVersion' in kwargs:
            python_version = kwargs['pythonVersion']
        if 'remoteDebuggingEnabled' in kwargs:
            remote_debugging_enabled = kwargs['remoteDebuggingEnabled']
        if 'remoteDebuggingVersion' in kwargs:
            remote_debugging_version = kwargs['remoteDebuggingVersion']
        if 'requestTracingEnabled' in kwargs:
            request_tracing_enabled = kwargs['requestTracingEnabled']
        if 'requestTracingExpirationTime' in kwargs:
            request_tracing_expiration_time = kwargs['requestTracingExpirationTime']
        if 'scmIpSecurityRestrictions' in kwargs:
            scm_ip_security_restrictions = kwargs['scmIpSecurityRestrictions']
        if 'scmIpSecurityRestrictionsUseMain' in kwargs:
            scm_ip_security_restrictions_use_main = kwargs['scmIpSecurityRestrictionsUseMain']
        if 'scmMinTlsVersion' in kwargs:
            scm_min_tls_version = kwargs['scmMinTlsVersion']
        if 'scmType' in kwargs:
            scm_type = kwargs['scmType']
        if 'tracingOptions' in kwargs:
            tracing_options = kwargs['tracingOptions']
        if 'use32BitWorkerProcess' in kwargs:
            use32_bit_worker_process = kwargs['use32BitWorkerProcess']
        if 'virtualApplications' in kwargs:
            virtual_applications = kwargs['virtualApplications']
        if 'vnetName' in kwargs:
            vnet_name = kwargs['vnetName']
        if 'vnetPrivatePortsCount' in kwargs:
            vnet_private_ports_count = kwargs['vnetPrivatePortsCount']
        if 'vnetRouteAllEnabled' in kwargs:
            vnet_route_all_enabled = kwargs['vnetRouteAllEnabled']
        if 'webSocketsEnabled' in kwargs:
            web_sockets_enabled = kwargs['webSocketsEnabled']
        if 'windowsFxVersion' in kwargs:
            windows_fx_version = kwargs['windowsFxVersion']
        if 'xManagedServiceIdentityId' in kwargs:
            x_managed_service_identity_id = kwargs['xManagedServiceIdentityId']

        if acr_use_managed_identity_creds is not None:
            _setter("acr_use_managed_identity_creds", acr_use_managed_identity_creds)
        if acr_user_managed_identity_id is not None:
            _setter("acr_user_managed_identity_id", acr_user_managed_identity_id)
        if always_on is not None:
            _setter("always_on", always_on)
        if api_definition is not None:
            _setter("api_definition", api_definition)
        if api_management_config is not None:
            _setter("api_management_config", api_management_config)
        if app_command_line is not None:
            _setter("app_command_line", app_command_line)
        if app_settings is not None:
            _setter("app_settings", app_settings)
        if auto_heal_enabled is not None:
            _setter("auto_heal_enabled", auto_heal_enabled)
        if auto_heal_rules is not None:
            _setter("auto_heal_rules", auto_heal_rules)
        if auto_swap_slot_name is not None:
            _setter("auto_swap_slot_name", auto_swap_slot_name)
        if connection_strings is not None:
            _setter("connection_strings", connection_strings)
        if cors is not None:
            _setter("cors", cors)
        if default_documents is not None:
            _setter("default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            _setter("detailed_error_logging_enabled", detailed_error_logging_enabled)
        if document_root is not None:
            _setter("document_root", document_root)
        if experiments is not None:
            _setter("experiments", experiments)
        if ftps_state is not None:
            _setter("ftps_state", ftps_state)
        if handler_mappings is not None:
            _setter("handler_mappings", handler_mappings)
        if health_check_path is not None:
            _setter("health_check_path", health_check_path)
        if http20_enabled is None:
            http20_enabled = True
        if http20_enabled is not None:
            _setter("http20_enabled", http20_enabled)
        if http_logging_enabled is not None:
            _setter("http_logging_enabled", http_logging_enabled)
        if ip_security_restrictions is not None:
            _setter("ip_security_restrictions", ip_security_restrictions)
        if java_container is not None:
            _setter("java_container", java_container)
        if java_container_version is not None:
            _setter("java_container_version", java_container_version)
        if java_version is not None:
            _setter("java_version", java_version)
        if limits is not None:
            _setter("limits", limits)
        if linux_fx_version is not None:
            _setter("linux_fx_version", linux_fx_version)
        if load_balancing is not None:
            _setter("load_balancing", load_balancing)
        if local_my_sql_enabled is None:
            local_my_sql_enabled = False
        if local_my_sql_enabled is not None:
            _setter("local_my_sql_enabled", local_my_sql_enabled)
        if logs_directory_size_limit is not None:
            _setter("logs_directory_size_limit", logs_directory_size_limit)
        if managed_pipeline_mode is not None:
            _setter("managed_pipeline_mode", managed_pipeline_mode)
        if managed_service_identity_id is not None:
            _setter("managed_service_identity_id", managed_service_identity_id)
        if min_tls_version is not None:
            _setter("min_tls_version", min_tls_version)
        if net_framework_version is None:
            net_framework_version = 'v4.6'
        if net_framework_version is not None:
            _setter("net_framework_version", net_framework_version)
        if node_version is not None:
            _setter("node_version", node_version)
        if number_of_workers is not None:
            _setter("number_of_workers", number_of_workers)
        if php_version is not None:
            _setter("php_version", php_version)
        if power_shell_version is not None:
            _setter("power_shell_version", power_shell_version)
        if pre_warmed_instance_count is not None:
            _setter("pre_warmed_instance_count", pre_warmed_instance_count)
        if publishing_username is not None:
            _setter("publishing_username", publishing_username)
        if push is not None:
            _setter("push", push)
        if python_version is not None:
            _setter("python_version", python_version)
        if remote_debugging_enabled is not None:
            _setter("remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            _setter("remote_debugging_version", remote_debugging_version)
        if request_tracing_enabled is not None:
            _setter("request_tracing_enabled", request_tracing_enabled)
        if request_tracing_expiration_time is not None:
            _setter("request_tracing_expiration_time", request_tracing_expiration_time)
        if scm_ip_security_restrictions is not None:
            _setter("scm_ip_security_restrictions", scm_ip_security_restrictions)
        if scm_ip_security_restrictions_use_main is not None:
            _setter("scm_ip_security_restrictions_use_main", scm_ip_security_restrictions_use_main)
        if scm_min_tls_version is not None:
            _setter("scm_min_tls_version", scm_min_tls_version)
        if scm_type is not None:
            _setter("scm_type", scm_type)
        if tracing_options is not None:
            _setter("tracing_options", tracing_options)
        if use32_bit_worker_process is not None:
            _setter("use32_bit_worker_process", use32_bit_worker_process)
        if virtual_applications is not None:
            _setter("virtual_applications", virtual_applications)
        if vnet_name is not None:
            _setter("vnet_name", vnet_name)
        if vnet_private_ports_count is not None:
            _setter("vnet_private_ports_count", vnet_private_ports_count)
        if vnet_route_all_enabled is not None:
            _setter("vnet_route_all_enabled", vnet_route_all_enabled)
        if web_sockets_enabled is not None:
            _setter("web_sockets_enabled", web_sockets_enabled)
        if windows_fx_version is not None:
            _setter("windows_fx_version", windows_fx_version)
        if x_managed_service_identity_id is not None:
            _setter("x_managed_service_identity_id", x_managed_service_identity_id)

    @property
    @pulumi.getter(name="acrUseManagedIdentityCreds")
    def acr_use_managed_identity_creds(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to use Managed Identity Creds for ACR pull
        """
        return pulumi.get(self, "acr_use_managed_identity_creds")

    @acr_use_managed_identity_creds.setter
    def acr_use_managed_identity_creds(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "acr_use_managed_identity_creds", value)

    @property
    @pulumi.getter(name="acrUserManagedIdentityID")
    def acr_user_managed_identity_id(self) -> Optional[pulumi.Input[str]]:
        """
        If using user managed identity, the user managed identity ClientId
        """
        return pulumi.get(self, "acr_user_managed_identity_id")

    @acr_user_managed_identity_id.setter
    def acr_user_managed_identity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "acr_user_managed_identity_id", value)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="apiDefinition")
    def api_definition(self) -> Optional[pulumi.Input['ApiDefinitionInfoArgs']]:
        """
        Information about the formal API definition for the app.
        """
        return pulumi.get(self, "api_definition")

    @api_definition.setter
    def api_definition(self, value: Optional[pulumi.Input['ApiDefinitionInfoArgs']]):
        pulumi.set(self, "api_definition", value)

    @property
    @pulumi.getter(name="apiManagementConfig")
    def api_management_config(self) -> Optional[pulumi.Input['ApiManagementConfigArgs']]:
        """
        Azure API management settings linked to the app.
        """
        return pulumi.get(self, "api_management_config")

    @api_management_config.setter
    def api_management_config(self, value: Optional[pulumi.Input['ApiManagementConfigArgs']]):
        pulumi.set(self, "api_management_config", value)

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[pulumi.Input[str]]:
        """
        App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @app_command_line.setter
    def app_command_line(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_command_line", value)

    @property
    @pulumi.getter(name="appSettings")
    def app_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NameValuePairArgs']]]]:
        """
        Application settings.
        """
        return pulumi.get(self, "app_settings")

    @app_settings.setter
    def app_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NameValuePairArgs']]]]):
        pulumi.set(self, "app_settings", value)

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @auto_heal_enabled.setter
    def auto_heal_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_heal_enabled", value)

    @property
    @pulumi.getter(name="autoHealRules")
    def auto_heal_rules(self) -> Optional[pulumi.Input['AutoHealRulesArgs']]:
        """
        Auto Heal rules.
        """
        return pulumi.get(self, "auto_heal_rules")

    @auto_heal_rules.setter
    def auto_heal_rules(self, value: Optional[pulumi.Input['AutoHealRulesArgs']]):
        pulumi.set(self, "auto_heal_rules", value)

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[pulumi.Input[str]]:
        """
        Auto-swap slot name.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @auto_swap_slot_name.setter
    def auto_swap_slot_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_swap_slot_name", value)

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnStringInfoArgs']]]]:
        """
        Connection strings.
        """
        return pulumi.get(self, "connection_strings")

    @connection_strings.setter
    def connection_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnStringInfoArgs']]]]):
        pulumi.set(self, "connection_strings", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['CorsSettingsArgs']]:
        """
        Cross-Origin Resource Sharing (CORS) settings.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['CorsSettingsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Default documents.
        """
        return pulumi.get(self, "default_documents")

    @default_documents.setter
    def default_documents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "default_documents", value)

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @detailed_error_logging_enabled.setter
    def detailed_error_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detailed_error_logging_enabled", value)

    @property
    @pulumi.getter(name="documentRoot")
    def document_root(self) -> Optional[pulumi.Input[str]]:
        """
        Document root.
        """
        return pulumi.get(self, "document_root")

    @document_root.setter
    def document_root(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "document_root", value)

    @property
    @pulumi.getter
    def experiments(self) -> Optional[pulumi.Input['ExperimentsArgs']]:
        """
        This is work around for polymorphic types.
        """
        return pulumi.get(self, "experiments")

    @experiments.setter
    def experiments(self, value: Optional[pulumi.Input['ExperimentsArgs']]):
        pulumi.set(self, "experiments", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[Union[str, 'FtpsState']]]:
        """
        State of FTP / FTPS service
        """
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[Union[str, 'FtpsState']]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="handlerMappings")
    def handler_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HandlerMappingArgs']]]]:
        """
        Handler mappings.
        """
        return pulumi.get(self, "handler_mappings")

    @handler_mappings.setter
    def handler_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HandlerMappingArgs']]]]):
        pulumi.set(self, "handler_mappings", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[str]]:
        """
        Health check path
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http20Enabled")
    def http20_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Http20Enabled: configures a web site to allow clients to connect over http2.0
        """
        return pulumi.get(self, "http20_enabled")

    @http20_enabled.setter
    def http20_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http20_enabled", value)

    @property
    @pulumi.getter(name="httpLoggingEnabled")
    def http_logging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "http_logging_enabled")

    @http_logging_enabled.setter
    def http_logging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http_logging_enabled", value)

    @property
    @pulumi.getter(name="ipSecurityRestrictions")
    def ip_security_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]]:
        """
        IP security restrictions for main.
        """
        return pulumi.get(self, "ip_security_restrictions")

    @ip_security_restrictions.setter
    def ip_security_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]]):
        pulumi.set(self, "ip_security_restrictions", value)

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[pulumi.Input[str]]:
        """
        Java container.
        """
        return pulumi.get(self, "java_container")

    @java_container.setter
    def java_container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_container", value)

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[pulumi.Input[str]]:
        """
        Java container version.
        """
        return pulumi.get(self, "java_container_version")

    @java_container_version.setter
    def java_container_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_container_version", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[str]]:
        """
        Java version.
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input['SiteLimitsArgs']]:
        """
        Site limits.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input['SiteLimitsArgs']]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[pulumi.Input[str]]:
        """
        Linux App Framework and version
        """
        return pulumi.get(self, "linux_fx_version")

    @linux_fx_version.setter
    def linux_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux_fx_version", value)

    @property
    @pulumi.getter(name="loadBalancing")
    def load_balancing(self) -> Optional[pulumi.Input['SiteLoadBalancing']]:
        """
        Site load balancing.
        """
        return pulumi.get(self, "load_balancing")

    @load_balancing.setter
    def load_balancing(self, value: Optional[pulumi.Input['SiteLoadBalancing']]):
        pulumi.set(self, "load_balancing", value)

    @property
    @pulumi.getter(name="localMySqlEnabled")
    def local_my_sql_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "local_my_sql_enabled")

    @local_my_sql_enabled.setter
    def local_my_sql_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "local_my_sql_enabled", value)

    @property
    @pulumi.getter(name="logsDirectorySizeLimit")
    def logs_directory_size_limit(self) -> Optional[pulumi.Input[int]]:
        """
        HTTP logs directory size limit.
        """
        return pulumi.get(self, "logs_directory_size_limit")

    @logs_directory_size_limit.setter
    def logs_directory_size_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "logs_directory_size_limit", value)

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[pulumi.Input['ManagedPipelineMode']]:
        """
        Managed pipeline mode.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @managed_pipeline_mode.setter
    def managed_pipeline_mode(self, value: Optional[pulumi.Input['ManagedPipelineMode']]):
        pulumi.set(self, "managed_pipeline_mode", value)

    @property
    @pulumi.getter(name="managedServiceIdentityId")
    def managed_service_identity_id(self) -> Optional[pulumi.Input[int]]:
        """
        Managed Service Identity Id
        """
        return pulumi.get(self, "managed_service_identity_id")

    @managed_service_identity_id.setter
    def managed_service_identity_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "managed_service_identity_id", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[Union[str, 'SupportedTlsVersions']]]:
        """
        MinTlsVersion: configures the minimum version of TLS required for SSL requests
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[Union[str, 'SupportedTlsVersions']]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter(name="netFrameworkVersion")
    def net_framework_version(self) -> Optional[pulumi.Input[str]]:
        """
        .NET Framework version.
        """
        return pulumi.get(self, "net_framework_version")

    @net_framework_version.setter
    def net_framework_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "net_framework_version", value)

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of Node.js.
        """
        return pulumi.get(self, "node_version")

    @node_version.setter
    def node_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_version", value)

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[pulumi.Input[int]]:
        """
        Number of workers.
        """
        return pulumi.get(self, "number_of_workers")

    @number_of_workers.setter
    def number_of_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_workers", value)

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of PHP.
        """
        return pulumi.get(self, "php_version")

    @php_version.setter
    def php_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "php_version", value)

    @property
    @pulumi.getter(name="powerShellVersion")
    def power_shell_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of PowerShell.
        """
        return pulumi.get(self, "power_shell_version")

    @power_shell_version.setter
    def power_shell_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "power_shell_version", value)

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of preWarmed instances.
        This setting only applies to the Consumption and Elastic Plans
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @pre_warmed_instance_count.setter
    def pre_warmed_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pre_warmed_instance_count", value)

    @property
    @pulumi.getter(name="publishingUsername")
    def publishing_username(self) -> Optional[pulumi.Input[str]]:
        """
        Publishing user name.
        """
        return pulumi.get(self, "publishing_username")

    @publishing_username.setter
    def publishing_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "publishing_username", value)

    @property
    @pulumi.getter
    def push(self) -> Optional[pulumi.Input['PushSettingsArgs']]:
        """
        Push endpoint settings.
        """
        return pulumi.get(self, "push")

    @push.setter
    def push(self, value: Optional[pulumi.Input['PushSettingsArgs']]):
        pulumi.set(self, "push", value)

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of Python.
        """
        return pulumi.get(self, "python_version")

    @python_version.setter
    def python_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "python_version", value)

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @remote_debugging_enabled.setter
    def remote_debugging_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "remote_debugging_enabled", value)

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[pulumi.Input[str]]:
        """
        Remote debugging version.
        """
        return pulumi.get(self, "remote_debugging_version")

    @remote_debugging_version.setter
    def remote_debugging_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_debugging_version", value)

    @property
    @pulumi.getter(name="requestTracingEnabled")
    def request_tracing_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "request_tracing_enabled")

    @request_tracing_enabled.setter
    def request_tracing_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "request_tracing_enabled", value)

    @property
    @pulumi.getter(name="requestTracingExpirationTime")
    def request_tracing_expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        Request tracing expiration time.
        """
        return pulumi.get(self, "request_tracing_expiration_time")

    @request_tracing_expiration_time.setter
    def request_tracing_expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_tracing_expiration_time", value)

    @property
    @pulumi.getter(name="scmIpSecurityRestrictions")
    def scm_ip_security_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]]:
        """
        IP security restrictions for scm.
        """
        return pulumi.get(self, "scm_ip_security_restrictions")

    @scm_ip_security_restrictions.setter
    def scm_ip_security_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_security_restrictions", value)

    @property
    @pulumi.getter(name="scmIpSecurityRestrictionsUseMain")
    def scm_ip_security_restrictions_use_main(self) -> Optional[pulumi.Input[bool]]:
        """
        IP security restrictions for scm to use main.
        """
        return pulumi.get(self, "scm_ip_security_restrictions_use_main")

    @scm_ip_security_restrictions_use_main.setter
    def scm_ip_security_restrictions_use_main(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "scm_ip_security_restrictions_use_main", value)

    @property
    @pulumi.getter(name="scmMinTlsVersion")
    def scm_min_tls_version(self) -> Optional[pulumi.Input[Union[str, 'SupportedTlsVersions']]]:
        """
        ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
        """
        return pulumi.get(self, "scm_min_tls_version")

    @scm_min_tls_version.setter
    def scm_min_tls_version(self, value: Optional[pulumi.Input[Union[str, 'SupportedTlsVersions']]]):
        pulumi.set(self, "scm_min_tls_version", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[Union[str, 'ScmType']]]:
        """
        SCM type.
        """
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[Union[str, 'ScmType']]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="tracingOptions")
    def tracing_options(self) -> Optional[pulumi.Input[str]]:
        """
        Tracing options.
        """
        return pulumi.get(self, "tracing_options")

    @tracing_options.setter
    def tracing_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tracing_options", value)

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @use32_bit_worker_process.setter
    def use32_bit_worker_process(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use32_bit_worker_process", value)

    @property
    @pulumi.getter(name="virtualApplications")
    def virtual_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualApplicationArgs']]]]:
        """
        Virtual applications.
        """
        return pulumi.get(self, "virtual_applications")

    @virtual_applications.setter
    def virtual_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualApplicationArgs']]]]):
        pulumi.set(self, "virtual_applications", value)

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> Optional[pulumi.Input[str]]:
        """
        Virtual Network name.
        """
        return pulumi.get(self, "vnet_name")

    @vnet_name.setter
    def vnet_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_name", value)

    @property
    @pulumi.getter(name="vnetPrivatePortsCount")
    def vnet_private_ports_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of private ports assigned to this app. These will be assigned dynamically on runtime.
        """
        return pulumi.get(self, "vnet_private_ports_count")

    @vnet_private_ports_count.setter
    def vnet_private_ports_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vnet_private_ports_count", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="webSocketsEnabled")
    def web_sockets_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "web_sockets_enabled")

    @web_sockets_enabled.setter
    def web_sockets_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "web_sockets_enabled", value)

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[pulumi.Input[str]]:
        """
        Xenon App Framework and version
        """
        return pulumi.get(self, "windows_fx_version")

    @windows_fx_version.setter
    def windows_fx_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "windows_fx_version", value)

    @property
    @pulumi.getter(name="xManagedServiceIdentityId")
    def x_managed_service_identity_id(self) -> Optional[pulumi.Input[int]]:
        """
        Explicit Managed Service Identity Id
        """
        return pulumi.get(self, "x_managed_service_identity_id")

    @x_managed_service_identity_id.setter
    def x_managed_service_identity_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "x_managed_service_identity_id", value)


@pulumi.input_type
class SiteLimitsArgs:
    def __init__(__self__, *,
                 max_disk_size_in_mb: Optional[pulumi.Input[float]] = None,
                 max_memory_in_mb: Optional[pulumi.Input[float]] = None,
                 max_percentage_cpu: Optional[pulumi.Input[float]] = None):
        """
        Metric limits set on an app.
        :param pulumi.Input[float] max_disk_size_in_mb: Maximum allowed disk size usage in MB.
        :param pulumi.Input[float] max_memory_in_mb: Maximum allowed memory usage in MB.
        :param pulumi.Input[float] max_percentage_cpu: Maximum allowed CPU usage percentage.
        """
        SiteLimitsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_disk_size_in_mb=max_disk_size_in_mb,
            max_memory_in_mb=max_memory_in_mb,
            max_percentage_cpu=max_percentage_cpu,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_disk_size_in_mb: Optional[pulumi.Input[float]] = None,
             max_memory_in_mb: Optional[pulumi.Input[float]] = None,
             max_percentage_cpu: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxDiskSizeInMb' in kwargs:
            max_disk_size_in_mb = kwargs['maxDiskSizeInMb']
        if 'maxMemoryInMb' in kwargs:
            max_memory_in_mb = kwargs['maxMemoryInMb']
        if 'maxPercentageCpu' in kwargs:
            max_percentage_cpu = kwargs['maxPercentageCpu']

        if max_disk_size_in_mb is not None:
            _setter("max_disk_size_in_mb", max_disk_size_in_mb)
        if max_memory_in_mb is not None:
            _setter("max_memory_in_mb", max_memory_in_mb)
        if max_percentage_cpu is not None:
            _setter("max_percentage_cpu", max_percentage_cpu)

    @property
    @pulumi.getter(name="maxDiskSizeInMb")
    def max_disk_size_in_mb(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum allowed disk size usage in MB.
        """
        return pulumi.get(self, "max_disk_size_in_mb")

    @max_disk_size_in_mb.setter
    def max_disk_size_in_mb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_disk_size_in_mb", value)

    @property
    @pulumi.getter(name="maxMemoryInMb")
    def max_memory_in_mb(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum allowed memory usage in MB.
        """
        return pulumi.get(self, "max_memory_in_mb")

    @max_memory_in_mb.setter
    def max_memory_in_mb(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_memory_in_mb", value)

    @property
    @pulumi.getter(name="maxPercentageCpu")
    def max_percentage_cpu(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum allowed CPU usage percentage.
        """
        return pulumi.get(self, "max_percentage_cpu")

    @max_percentage_cpu.setter
    def max_percentage_cpu(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_percentage_cpu", value)


@pulumi.input_type
class SkuCapacityArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[int]] = None,
                 maximum: Optional[pulumi.Input[int]] = None,
                 minimum: Optional[pulumi.Input[int]] = None,
                 scale_type: Optional[pulumi.Input[str]] = None):
        """
        Description of the App Service plan scale options.
        :param pulumi.Input[int] default: Default number of workers for this App Service plan SKU.
        :param pulumi.Input[int] maximum: Maximum number of workers for this App Service plan SKU.
        :param pulumi.Input[int] minimum: Minimum number of workers for this App Service plan SKU.
        :param pulumi.Input[str] scale_type: Available scale configurations for an App Service plan.
        """
        SkuCapacityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default=default,
            maximum=maximum,
            minimum=minimum,
            scale_type=scale_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default: Optional[pulumi.Input[int]] = None,
             maximum: Optional[pulumi.Input[int]] = None,
             minimum: Optional[pulumi.Input[int]] = None,
             scale_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'scaleType' in kwargs:
            scale_type = kwargs['scaleType']

        if default is not None:
            _setter("default", default)
        if maximum is not None:
            _setter("maximum", maximum)
        if minimum is not None:
            _setter("minimum", minimum)
        if scale_type is not None:
            _setter("scale_type", scale_type)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[int]]:
        """
        Default number of workers for this App Service plan SKU.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of workers for this App Service plan SKU.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of workers for this App Service plan SKU.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter(name="scaleType")
    def scale_type(self) -> Optional[pulumi.Input[str]]:
        """
        Available scale configurations for an App Service plan.
        """
        return pulumi.get(self, "scale_type")

    @scale_type.setter
    def scale_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_type", value)


@pulumi.input_type
class SkuDescriptionArgs:
    def __init__(__self__, *,
                 capabilities: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]] = None,
                 capacity: Optional[pulumi.Input[int]] = None,
                 family: Optional[pulumi.Input[str]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 sku_capacity: Optional[pulumi.Input['SkuCapacityArgs']] = None,
                 tier: Optional[pulumi.Input[str]] = None):
        """
        Description of a SKU for a scalable resource.
        :param pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]] capabilities: Capabilities of the SKU, e.g., is traffic manager enabled?
        :param pulumi.Input[int] capacity: Current number of instances assigned to the resource.
        :param pulumi.Input[str] family: Family code of the resource SKU.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] locations: Locations of the SKU.
        :param pulumi.Input[str] name: Name of the resource SKU.
        :param pulumi.Input[str] size: Size specifier of the resource SKU.
        :param pulumi.Input['SkuCapacityArgs'] sku_capacity: Min, max, and default scale values of the SKU.
        :param pulumi.Input[str] tier: Service tier of the resource SKU.
        """
        SkuDescriptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capabilities=capabilities,
            capacity=capacity,
            family=family,
            locations=locations,
            name=name,
            size=size,
            sku_capacity=sku_capacity,
            tier=tier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capabilities: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]] = None,
             capacity: Optional[pulumi.Input[int]] = None,
             family: Optional[pulumi.Input[str]] = None,
             locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             name: Optional[pulumi.Input[str]] = None,
             size: Optional[pulumi.Input[str]] = None,
             sku_capacity: Optional[pulumi.Input['SkuCapacityArgs']] = None,
             tier: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'skuCapacity' in kwargs:
            sku_capacity = kwargs['skuCapacity']

        if capabilities is not None:
            _setter("capabilities", capabilities)
        if capacity is not None:
            _setter("capacity", capacity)
        if family is not None:
            _setter("family", family)
        if locations is not None:
            _setter("locations", locations)
        if name is not None:
            _setter("name", name)
        if size is not None:
            _setter("size", size)
        if sku_capacity is not None:
            _setter("sku_capacity", sku_capacity)
        if tier is not None:
            _setter("tier", tier)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]]:
        """
        Capabilities of the SKU, e.g., is traffic manager enabled?
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[int]]:
        """
        Current number of instances assigned to the resource.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[str]]:
        """
        Family code of the resource SKU.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Locations of the SKU.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the resource SKU.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        Size specifier of the resource SKU.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="skuCapacity")
    def sku_capacity(self) -> Optional[pulumi.Input['SkuCapacityArgs']]:
        """
        Min, max, and default scale values of the SKU.
        """
        return pulumi.get(self, "sku_capacity")

    @sku_capacity.setter
    def sku_capacity(self, value: Optional[pulumi.Input['SkuCapacityArgs']]):
        pulumi.set(self, "sku_capacity", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[str]]:
        """
        Service tier of the resource SKU.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tier", value)


@pulumi.input_type
class SlowRequestsBasedTriggerArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 time_interval: Optional[pulumi.Input[str]] = None,
                 time_taken: Optional[pulumi.Input[str]] = None):
        """
        Trigger based on request execution time.
        :param pulumi.Input[int] count: Request Count.
        :param pulumi.Input[str] time_interval: Time interval.
        :param pulumi.Input[str] time_taken: Time taken.
        """
        SlowRequestsBasedTriggerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            time_interval=time_interval,
            time_taken=time_taken,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[pulumi.Input[int]] = None,
             time_interval: Optional[pulumi.Input[str]] = None,
             time_taken: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'timeInterval' in kwargs:
            time_interval = kwargs['timeInterval']
        if 'timeTaken' in kwargs:
            time_taken = kwargs['timeTaken']

        if count is not None:
            _setter("count", count)
        if time_interval is not None:
            _setter("time_interval", time_interval)
        if time_taken is not None:
            _setter("time_taken", time_taken)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")

    @time_interval.setter
    def time_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_interval", value)

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> Optional[pulumi.Input[str]]:
        """
        Time taken.
        """
        return pulumi.get(self, "time_taken")

    @time_taken.setter
    def time_taken(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_taken", value)


@pulumi.input_type
class StaticSiteBuildPropertiesArgs:
    def __init__(__self__, *,
                 api_location: Optional[pulumi.Input[str]] = None,
                 app_artifact_location: Optional[pulumi.Input[str]] = None,
                 app_location: Optional[pulumi.Input[str]] = None):
        """
        Build properties for the static site.
        :param pulumi.Input[str] api_location: The path to the api code within the repository.
        :param pulumi.Input[str] app_artifact_location: The path of the app artifacts after building.
        :param pulumi.Input[str] app_location: The path to the app code within the repository.
        """
        StaticSiteBuildPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_location=api_location,
            app_artifact_location=app_artifact_location,
            app_location=app_location,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_location: Optional[pulumi.Input[str]] = None,
             app_artifact_location: Optional[pulumi.Input[str]] = None,
             app_location: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'apiLocation' in kwargs:
            api_location = kwargs['apiLocation']
        if 'appArtifactLocation' in kwargs:
            app_artifact_location = kwargs['appArtifactLocation']
        if 'appLocation' in kwargs:
            app_location = kwargs['appLocation']

        if api_location is not None:
            _setter("api_location", api_location)
        if app_artifact_location is not None:
            _setter("app_artifact_location", app_artifact_location)
        if app_location is not None:
            _setter("app_location", app_location)

    @property
    @pulumi.getter(name="apiLocation")
    def api_location(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the api code within the repository.
        """
        return pulumi.get(self, "api_location")

    @api_location.setter
    def api_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_location", value)

    @property
    @pulumi.getter(name="appArtifactLocation")
    def app_artifact_location(self) -> Optional[pulumi.Input[str]]:
        """
        The path of the app artifacts after building.
        """
        return pulumi.get(self, "app_artifact_location")

    @app_artifact_location.setter
    def app_artifact_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_artifact_location", value)

    @property
    @pulumi.getter(name="appLocation")
    def app_location(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the app code within the repository.
        """
        return pulumi.get(self, "app_location")

    @app_location.setter
    def app_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_location", value)


@pulumi.input_type
class StatusCodesBasedTriggerArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[int]] = None,
                 sub_status: Optional[pulumi.Input[int]] = None,
                 time_interval: Optional[pulumi.Input[str]] = None,
                 win32_status: Optional[pulumi.Input[int]] = None):
        """
        Trigger based on status code.
        :param pulumi.Input[int] count: Request Count.
        :param pulumi.Input[int] status: HTTP status code.
        :param pulumi.Input[int] sub_status: Request Sub Status.
        :param pulumi.Input[str] time_interval: Time interval.
        :param pulumi.Input[int] win32_status: Win32 error code.
        """
        StatusCodesBasedTriggerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            status=status,
            sub_status=sub_status,
            time_interval=time_interval,
            win32_status=win32_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[pulumi.Input[int]] = None,
             status: Optional[pulumi.Input[int]] = None,
             sub_status: Optional[pulumi.Input[int]] = None,
             time_interval: Optional[pulumi.Input[str]] = None,
             win32_status: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'subStatus' in kwargs:
            sub_status = kwargs['subStatus']
        if 'timeInterval' in kwargs:
            time_interval = kwargs['timeInterval']
        if 'win32Status' in kwargs:
            win32_status = kwargs['win32Status']

        if count is not None:
            _setter("count", count)
        if status is not None:
            _setter("status", status)
        if sub_status is not None:
            _setter("sub_status", sub_status)
        if time_interval is not None:
            _setter("time_interval", time_interval)
        if win32_status is not None:
            _setter("win32_status", win32_status)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[int]]:
        """
        HTTP status code.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[pulumi.Input[int]]:
        """
        Request Sub Status.
        """
        return pulumi.get(self, "sub_status")

    @sub_status.setter
    def sub_status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sub_status", value)

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")

    @time_interval.setter
    def time_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_interval", value)

    @property
    @pulumi.getter(name="win32Status")
    def win32_status(self) -> Optional[pulumi.Input[int]]:
        """
        Win32 error code.
        """
        return pulumi.get(self, "win32_status")

    @win32_status.setter
    def win32_status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "win32_status", value)


@pulumi.input_type
class TokenStoreArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['BlobStorageTokenStoreArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 file_system: Optional[pulumi.Input['FileSystemTokenStoreArgs']] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        TokenStoreArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_blob_storage=azure_blob_storage,
            enabled=enabled,
            file_system=file_system,
            kind=kind,
            token_refresh_extension_hours=token_refresh_extension_hours,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_blob_storage: Optional[pulumi.Input['BlobStorageTokenStoreArgs']] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             file_system: Optional[pulumi.Input['FileSystemTokenStoreArgs']] = None,
             kind: Optional[pulumi.Input[str]] = None,
             token_refresh_extension_hours: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'azureBlobStorage' in kwargs:
            azure_blob_storage = kwargs['azureBlobStorage']
        if 'fileSystem' in kwargs:
            file_system = kwargs['fileSystem']
        if 'tokenRefreshExtensionHours' in kwargs:
            token_refresh_extension_hours = kwargs['tokenRefreshExtensionHours']

        if azure_blob_storage is not None:
            _setter("azure_blob_storage", azure_blob_storage)
        if enabled is not None:
            _setter("enabled", enabled)
        if file_system is not None:
            _setter("file_system", file_system)
        if kind is not None:
            _setter("kind", kind)
        if token_refresh_extension_hours is not None:
            _setter("token_refresh_extension_hours", token_refresh_extension_hours)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['BlobStorageTokenStoreArgs']]:
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['BlobStorageTokenStoreArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input['FileSystemTokenStoreArgs']]:
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input['FileSystemTokenStoreArgs']]):
        pulumi.set(self, "file_system", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)


@pulumi.input_type
class TwitterRegistrationArgs:
    def __init__(__self__, *,
                 consumer_key: Optional[pulumi.Input[str]] = None,
                 consumer_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        TwitterRegistrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            consumer_key=consumer_key,
            consumer_secret_setting_name=consumer_secret_setting_name,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             consumer_key: Optional[pulumi.Input[str]] = None,
             consumer_secret_setting_name: Optional[pulumi.Input[str]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'consumerKey' in kwargs:
            consumer_key = kwargs['consumerKey']
        if 'consumerSecretSettingName' in kwargs:
            consumer_secret_setting_name = kwargs['consumerSecretSettingName']

        if consumer_key is not None:
            _setter("consumer_key", consumer_key)
        if consumer_secret_setting_name is not None:
            _setter("consumer_secret_setting_name", consumer_secret_setting_name)
        if kind is not None:
            _setter("kind", kind)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret_setting_name", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


@pulumi.input_type
class TwitterArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 registration: Optional[pulumi.Input['TwitterRegistrationArgs']] = None):
        """
        :param pulumi.Input[str] kind: Kind of resource.
        """
        TwitterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            kind=kind,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             kind: Optional[pulumi.Input[str]] = None,
             registration: Optional[pulumi.Input['TwitterRegistrationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if kind is not None:
            _setter("kind", kind)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['TwitterRegistrationArgs']]:
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['TwitterRegistrationArgs']]):
        pulumi.set(self, "registration", value)


@pulumi.input_type
class VirtualApplicationArgs:
    def __init__(__self__, *,
                 physical_path: Optional[pulumi.Input[str]] = None,
                 preload_enabled: Optional[pulumi.Input[bool]] = None,
                 virtual_directories: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualDirectoryArgs']]]] = None,
                 virtual_path: Optional[pulumi.Input[str]] = None):
        """
        Virtual application in an app.
        :param pulumi.Input[str] physical_path: Physical path.
        :param pulumi.Input[bool] preload_enabled: <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualDirectoryArgs']]] virtual_directories: Virtual directories for virtual application.
        :param pulumi.Input[str] virtual_path: Virtual path.
        """
        VirtualApplicationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            physical_path=physical_path,
            preload_enabled=preload_enabled,
            virtual_directories=virtual_directories,
            virtual_path=virtual_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             physical_path: Optional[pulumi.Input[str]] = None,
             preload_enabled: Optional[pulumi.Input[bool]] = None,
             virtual_directories: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualDirectoryArgs']]]] = None,
             virtual_path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'physicalPath' in kwargs:
            physical_path = kwargs['physicalPath']
        if 'preloadEnabled' in kwargs:
            preload_enabled = kwargs['preloadEnabled']
        if 'virtualDirectories' in kwargs:
            virtual_directories = kwargs['virtualDirectories']
        if 'virtualPath' in kwargs:
            virtual_path = kwargs['virtualPath']

        if physical_path is not None:
            _setter("physical_path", physical_path)
        if preload_enabled is not None:
            _setter("preload_enabled", preload_enabled)
        if virtual_directories is not None:
            _setter("virtual_directories", virtual_directories)
        if virtual_path is not None:
            _setter("virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[pulumi.Input[str]]:
        """
        Physical path.
        """
        return pulumi.get(self, "physical_path")

    @physical_path.setter
    def physical_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "physical_path", value)

    @property
    @pulumi.getter(name="preloadEnabled")
    def preload_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "preload_enabled")

    @preload_enabled.setter
    def preload_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preload_enabled", value)

    @property
    @pulumi.getter(name="virtualDirectories")
    def virtual_directories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualDirectoryArgs']]]]:
        """
        Virtual directories for virtual application.
        """
        return pulumi.get(self, "virtual_directories")

    @virtual_directories.setter
    def virtual_directories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualDirectoryArgs']]]]):
        pulumi.set(self, "virtual_directories", value)

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[pulumi.Input[str]]:
        """
        Virtual path.
        """
        return pulumi.get(self, "virtual_path")

    @virtual_path.setter
    def virtual_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_path", value)


@pulumi.input_type
class VirtualDirectoryArgs:
    def __init__(__self__, *,
                 physical_path: Optional[pulumi.Input[str]] = None,
                 virtual_path: Optional[pulumi.Input[str]] = None):
        """
        Directory for virtual application.
        :param pulumi.Input[str] physical_path: Physical path.
        :param pulumi.Input[str] virtual_path: Path to virtual application.
        """
        VirtualDirectoryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            physical_path=physical_path,
            virtual_path=virtual_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             physical_path: Optional[pulumi.Input[str]] = None,
             virtual_path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'physicalPath' in kwargs:
            physical_path = kwargs['physicalPath']
        if 'virtualPath' in kwargs:
            virtual_path = kwargs['virtualPath']

        if physical_path is not None:
            _setter("physical_path", physical_path)
        if virtual_path is not None:
            _setter("virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[pulumi.Input[str]]:
        """
        Physical path.
        """
        return pulumi.get(self, "physical_path")

    @physical_path.setter
    def physical_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "physical_path", value)

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to virtual application.
        """
        return pulumi.get(self, "virtual_path")

    @virtual_path.setter
    def virtual_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_path", value)


@pulumi.input_type
class VirtualNetworkProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 subnet: Optional[pulumi.Input[str]] = None):
        """
        Specification for using a Virtual Network.
        :param pulumi.Input[str] id: Resource id of the Virtual Network.
        :param pulumi.Input[str] subnet: Subnet within the Virtual Network.
        """
        VirtualNetworkProfileArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            subnet=subnet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             subnet: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if subnet is not None:
            _setter("subnet", subnet)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource id of the Virtual Network.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[str]]:
        """
        Subnet within the Virtual Network.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet", value)


@pulumi.input_type
class WorkerPoolArgs:
    def __init__(__self__, *,
                 compute_mode: Optional[pulumi.Input['ComputeModeOptions']] = None,
                 worker_count: Optional[pulumi.Input[int]] = None,
                 worker_size: Optional[pulumi.Input[str]] = None,
                 worker_size_id: Optional[pulumi.Input[int]] = None):
        """
        Worker pool of an App Service Environment.
        :param pulumi.Input['ComputeModeOptions'] compute_mode: Shared or dedicated app hosting.
        :param pulumi.Input[int] worker_count: Number of instances in the worker pool.
        :param pulumi.Input[str] worker_size: VM size of the worker pool instances.
        :param pulumi.Input[int] worker_size_id: Worker size ID for referencing this worker pool.
        """
        WorkerPoolArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_mode=compute_mode,
            worker_count=worker_count,
            worker_size=worker_size,
            worker_size_id=worker_size_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_mode: Optional[pulumi.Input['ComputeModeOptions']] = None,
             worker_count: Optional[pulumi.Input[int]] = None,
             worker_size: Optional[pulumi.Input[str]] = None,
             worker_size_id: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'computeMode' in kwargs:
            compute_mode = kwargs['computeMode']
        if 'workerCount' in kwargs:
            worker_count = kwargs['workerCount']
        if 'workerSize' in kwargs:
            worker_size = kwargs['workerSize']
        if 'workerSizeId' in kwargs:
            worker_size_id = kwargs['workerSizeId']

        if compute_mode is not None:
            _setter("compute_mode", compute_mode)
        if worker_count is not None:
            _setter("worker_count", worker_count)
        if worker_size is not None:
            _setter("worker_size", worker_size)
        if worker_size_id is not None:
            _setter("worker_size_id", worker_size_id)

    @property
    @pulumi.getter(name="computeMode")
    def compute_mode(self) -> Optional[pulumi.Input['ComputeModeOptions']]:
        """
        Shared or dedicated app hosting.
        """
        return pulumi.get(self, "compute_mode")

    @compute_mode.setter
    def compute_mode(self, value: Optional[pulumi.Input['ComputeModeOptions']]):
        pulumi.set(self, "compute_mode", value)

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of instances in the worker pool.
        """
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "worker_count", value)

    @property
    @pulumi.getter(name="workerSize")
    def worker_size(self) -> Optional[pulumi.Input[str]]:
        """
        VM size of the worker pool instances.
        """
        return pulumi.get(self, "worker_size")

    @worker_size.setter
    def worker_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "worker_size", value)

    @property
    @pulumi.getter(name="workerSizeId")
    def worker_size_id(self) -> Optional[pulumi.Input[int]]:
        """
        Worker size ID for referencing this worker pool.
        """
        return pulumi.get(self, "worker_size_id")

    @worker_size_id.setter
    def worker_size_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "worker_size_id", value)


