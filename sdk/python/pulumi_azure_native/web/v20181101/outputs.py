# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ApiDefinitionInfoResponse',
    'AutoHealActionsResponse',
    'AutoHealCustomActionResponse',
    'AutoHealRulesResponse',
    'AutoHealTriggersResponse',
    'AzureStorageInfoValueResponse',
    'ConnStringInfoResponse',
    'CorsSettingsResponse',
    'DatabaseBackupSettingResponse',
    'ExperimentsResponse',
    'GeoDistributionResponse',
    'HandlerMappingResponse',
    'HostNameSslStateResponse',
    'HostingEnvironmentProfileResponse',
    'IpSecurityRestrictionResponse',
    'ManagedServiceIdentityResponse',
    'ManagedServiceIdentityResponseUserAssignedIdentities',
    'NameValuePairResponse',
    'PushSettingsResponse',
    'RampUpRuleResponse',
    'RequestsBasedTriggerResponse',
    'SiteConfigResponse',
    'SiteLimitsResponse',
    'SiteMachineKeyResponse',
    'SlotSwapStatusResponse',
    'SlowRequestsBasedTriggerResponse',
    'StatusCodesBasedTriggerResponse',
    'VirtualApplicationResponse',
    'VirtualDirectoryResponse',
]

@pulumi.output_type
class ApiDefinitionInfoResponse(dict):
    """
    Information about the formal API definition for the app.
    """
    def __init__(__self__, *,
                 url: Optional[str] = None):
        """
        Information about the formal API definition for the app.
        :param str url: The URL of the API definition.
        """
        ApiDefinitionInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL of the API definition.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AutoHealActionsResponse(dict):
    """
    Actions which to take by the auto-heal module when a rule is triggered.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "customAction":
            suggest = "custom_action"
        elif key == "minProcessExecutionTime":
            suggest = "min_process_execution_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoHealActionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoHealActionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoHealActionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: Optional[str] = None,
                 custom_action: Optional['outputs.AutoHealCustomActionResponse'] = None,
                 min_process_execution_time: Optional[str] = None):
        """
        Actions which to take by the auto-heal module when a rule is triggered.
        :param str action_type: Predefined action to be taken.
        :param 'AutoHealCustomActionResponse' custom_action: Custom action to be taken.
        :param str min_process_execution_time: Minimum time the process must execute
               before taking the action
        """
        AutoHealActionsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_type=action_type,
            custom_action=custom_action,
            min_process_execution_time=min_process_execution_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_type: Optional[str] = None,
             custom_action: Optional['outputs.AutoHealCustomActionResponse'] = None,
             min_process_execution_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_type is None and 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if custom_action is None and 'customAction' in kwargs:
            custom_action = kwargs['customAction']
        if min_process_execution_time is None and 'minProcessExecutionTime' in kwargs:
            min_process_execution_time = kwargs['minProcessExecutionTime']

        if action_type is not None:
            _setter("action_type", action_type)
        if custom_action is not None:
            _setter("custom_action", custom_action)
        if min_process_execution_time is not None:
            _setter("min_process_execution_time", min_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        """
        Predefined action to be taken.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="customAction")
    def custom_action(self) -> Optional['outputs.AutoHealCustomActionResponse']:
        """
        Custom action to be taken.
        """
        return pulumi.get(self, "custom_action")

    @property
    @pulumi.getter(name="minProcessExecutionTime")
    def min_process_execution_time(self) -> Optional[str]:
        """
        Minimum time the process must execute
        before taking the action
        """
        return pulumi.get(self, "min_process_execution_time")


@pulumi.output_type
class AutoHealCustomActionResponse(dict):
    """
    Custom action to be executed
    when an auto heal rule is triggered.
    """
    def __init__(__self__, *,
                 exe: Optional[str] = None,
                 parameters: Optional[str] = None):
        """
        Custom action to be executed
        when an auto heal rule is triggered.
        :param str exe: Executable to be run.
        :param str parameters: Parameters for the executable.
        """
        AutoHealCustomActionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exe=exe,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exe: Optional[str] = None,
             parameters: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if exe is not None:
            _setter("exe", exe)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def exe(self) -> Optional[str]:
        """
        Executable to be run.
        """
        return pulumi.get(self, "exe")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        Parameters for the executable.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class AutoHealRulesResponse(dict):
    """
    Rules that can be defined for auto-heal.
    """
    def __init__(__self__, *,
                 actions: Optional['outputs.AutoHealActionsResponse'] = None,
                 triggers: Optional['outputs.AutoHealTriggersResponse'] = None):
        """
        Rules that can be defined for auto-heal.
        :param 'AutoHealActionsResponse' actions: Actions to be executed when a rule is triggered.
        :param 'AutoHealTriggersResponse' triggers: Conditions that describe when to execute the auto-heal actions.
        """
        AutoHealRulesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            triggers=triggers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional['outputs.AutoHealActionsResponse'] = None,
             triggers: Optional['outputs.AutoHealTriggersResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if actions is not None:
            _setter("actions", actions)
        if triggers is not None:
            _setter("triggers", triggers)

    @property
    @pulumi.getter
    def actions(self) -> Optional['outputs.AutoHealActionsResponse']:
        """
        Actions to be executed when a rule is triggered.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def triggers(self) -> Optional['outputs.AutoHealTriggersResponse']:
        """
        Conditions that describe when to execute the auto-heal actions.
        """
        return pulumi.get(self, "triggers")


@pulumi.output_type
class AutoHealTriggersResponse(dict):
    """
    Triggers for auto-heal.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateBytesInKB":
            suggest = "private_bytes_in_kb"
        elif key == "slowRequests":
            suggest = "slow_requests"
        elif key == "statusCodes":
            suggest = "status_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoHealTriggersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoHealTriggersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoHealTriggersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_bytes_in_kb: Optional[int] = None,
                 requests: Optional['outputs.RequestsBasedTriggerResponse'] = None,
                 slow_requests: Optional['outputs.SlowRequestsBasedTriggerResponse'] = None,
                 status_codes: Optional[Sequence['outputs.StatusCodesBasedTriggerResponse']] = None):
        """
        Triggers for auto-heal.
        :param int private_bytes_in_kb: A rule based on private bytes.
        :param 'RequestsBasedTriggerResponse' requests: A rule based on total requests.
        :param 'SlowRequestsBasedTriggerResponse' slow_requests: A rule based on request execution time.
        :param Sequence['StatusCodesBasedTriggerResponse'] status_codes: A rule based on status codes.
        """
        AutoHealTriggersResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_bytes_in_kb=private_bytes_in_kb,
            requests=requests,
            slow_requests=slow_requests,
            status_codes=status_codes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_bytes_in_kb: Optional[int] = None,
             requests: Optional['outputs.RequestsBasedTriggerResponse'] = None,
             slow_requests: Optional['outputs.SlowRequestsBasedTriggerResponse'] = None,
             status_codes: Optional[Sequence['outputs.StatusCodesBasedTriggerResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_bytes_in_kb is None and 'privateBytesInKB' in kwargs:
            private_bytes_in_kb = kwargs['privateBytesInKB']
        if slow_requests is None and 'slowRequests' in kwargs:
            slow_requests = kwargs['slowRequests']
        if status_codes is None and 'statusCodes' in kwargs:
            status_codes = kwargs['statusCodes']

        if private_bytes_in_kb is not None:
            _setter("private_bytes_in_kb", private_bytes_in_kb)
        if requests is not None:
            _setter("requests", requests)
        if slow_requests is not None:
            _setter("slow_requests", slow_requests)
        if status_codes is not None:
            _setter("status_codes", status_codes)

    @property
    @pulumi.getter(name="privateBytesInKB")
    def private_bytes_in_kb(self) -> Optional[int]:
        """
        A rule based on private bytes.
        """
        return pulumi.get(self, "private_bytes_in_kb")

    @property
    @pulumi.getter
    def requests(self) -> Optional['outputs.RequestsBasedTriggerResponse']:
        """
        A rule based on total requests.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional['outputs.SlowRequestsBasedTriggerResponse']:
        """
        A rule based on request execution time.
        """
        return pulumi.get(self, "slow_requests")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[Sequence['outputs.StatusCodesBasedTriggerResponse']]:
        """
        A rule based on status codes.
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class AzureStorageInfoValueResponse(dict):
    """
    Azure Files or Blob Storage access information value for dictionary storage.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "mountPath":
            suggest = "mount_path"
        elif key == "shareName":
            suggest = "share_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureStorageInfoValueResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureStorageInfoValueResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureStorageInfoValueResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: str,
                 access_key: Optional[str] = None,
                 account_name: Optional[str] = None,
                 mount_path: Optional[str] = None,
                 share_name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Azure Files or Blob Storage access information value for dictionary storage.
        :param str state: State of the storage account.
        :param str access_key: Access key for the storage account.
        :param str account_name: Name of the storage account.
        :param str mount_path: Path to mount the storage within the site's runtime environment.
        :param str share_name: Name of the file share (container name, for Blob storage).
        :param str type: Type of storage.
        """
        AzureStorageInfoValueResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
            access_key=access_key,
            account_name=account_name,
            mount_path=mount_path,
            share_name=share_name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             access_key: Optional[str] = None,
             account_name: Optional[str] = None,
             mount_path: Optional[str] = None,
             share_name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")
        if access_key is None and 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if account_name is None and 'accountName' in kwargs:
            account_name = kwargs['accountName']
        if mount_path is None and 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']
        if share_name is None and 'shareName' in kwargs:
            share_name = kwargs['shareName']

        _setter("state", state)
        if access_key is not None:
            _setter("access_key", access_key)
        if account_name is not None:
            _setter("account_name", account_name)
        if mount_path is not None:
            _setter("mount_path", mount_path)
        if share_name is not None:
            _setter("share_name", share_name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State of the storage account.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[str]:
        """
        Name of the storage account.
        """
        return pulumi.get(self, "account_name")

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        Path to mount the storage within the site's runtime environment.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[str]:
        """
        Name of the file share (container name, for Blob storage).
        """
        return pulumi.get(self, "share_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of storage.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ConnStringInfoResponse(dict):
    """
    Database connection string information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnStringInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnStringInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnStringInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Database connection string information.
        :param str connection_string: Connection string value.
        :param str name: Name of connection string.
        :param str type: Type of database.
        """
        ConnStringInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_string=connection_string,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_string: Optional[str] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connection_string is None and 'connectionString' in kwargs:
            connection_string = kwargs['connectionString']

        if connection_string is not None:
            _setter("connection_string", connection_string)
        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        """
        Connection string value.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of connection string.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of database.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CorsSettingsResponse(dict):
    """
    Cross-Origin Resource Sharing (CORS) settings for the app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "supportCredentials":
            suggest = "support_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CorsSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CorsSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CorsSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Optional[Sequence[str]] = None,
                 support_credentials: Optional[bool] = None):
        """
        Cross-Origin Resource Sharing (CORS) settings for the app.
        :param Sequence[str] allowed_origins: Gets or sets the list of origins that should be allowed to make cross-origin
               calls (for example: http://example.com:12345). Use "*" to allow all.
        :param bool support_credentials: Gets or sets whether CORS requests with credentials are allowed. See 
               https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
               for more details.
        """
        CorsSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_origins=allowed_origins,
            support_credentials=support_credentials,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_origins: Optional[Sequence[str]] = None,
             support_credentials: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allowed_origins is None and 'allowedOrigins' in kwargs:
            allowed_origins = kwargs['allowedOrigins']
        if support_credentials is None and 'supportCredentials' in kwargs:
            support_credentials = kwargs['supportCredentials']

        if allowed_origins is not None:
            _setter("allowed_origins", allowed_origins)
        if support_credentials is not None:
            _setter("support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[Sequence[str]]:
        """
        Gets or sets the list of origins that should be allowed to make cross-origin
        calls (for example: http://example.com:12345). Use "*" to allow all.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[bool]:
        """
        Gets or sets whether CORS requests with credentials are allowed. See 
        https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
        for more details.
        """
        return pulumi.get(self, "support_credentials")


@pulumi.output_type
class DatabaseBackupSettingResponse(dict):
    """
    Database backup settings.
    """
    def __init__(__self__, *,
                 database_type: str,
                 connection_string: Optional[str] = None,
                 connection_string_name: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Database backup settings.
        :param str database_type: Database type (e.g. SqlAzure / MySql).
        :param str connection_string: Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        :param str connection_string_name: Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
               This is used during restore with overwrite connection strings options.
        """
        DatabaseBackupSettingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_type=database_type,
            connection_string=connection_string,
            connection_string_name=connection_string_name,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_type: Optional[str] = None,
             connection_string: Optional[str] = None,
             connection_string_name: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_type is None and 'databaseType' in kwargs:
            database_type = kwargs['databaseType']
        if database_type is None:
            raise TypeError("Missing 'database_type' argument")
        if connection_string is None and 'connectionString' in kwargs:
            connection_string = kwargs['connectionString']
        if connection_string_name is None and 'connectionStringName' in kwargs:
            connection_string_name = kwargs['connectionStringName']

        _setter("database_type", database_type)
        if connection_string is not None:
            _setter("connection_string", connection_string)
        if connection_string_name is not None:
            _setter("connection_string_name", connection_string_name)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> str:
        """
        Database type (e.g. SqlAzure / MySql).
        """
        return pulumi.get(self, "database_type")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        """
        Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter(name="connectionStringName")
    def connection_string_name(self) -> Optional[str]:
        """
        Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
        This is used during restore with overwrite connection strings options.
        """
        return pulumi.get(self, "connection_string_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ExperimentsResponse(dict):
    """
    Routing rules in production experiments.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rampUpRules":
            suggest = "ramp_up_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExperimentsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExperimentsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExperimentsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ramp_up_rules: Optional[Sequence['outputs.RampUpRuleResponse']] = None):
        """
        Routing rules in production experiments.
        :param Sequence['RampUpRuleResponse'] ramp_up_rules: List of ramp-up rules.
        """
        ExperimentsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ramp_up_rules=ramp_up_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ramp_up_rules: Optional[Sequence['outputs.RampUpRuleResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ramp_up_rules is None and 'rampUpRules' in kwargs:
            ramp_up_rules = kwargs['rampUpRules']

        if ramp_up_rules is not None:
            _setter("ramp_up_rules", ramp_up_rules)

    @property
    @pulumi.getter(name="rampUpRules")
    def ramp_up_rules(self) -> Optional[Sequence['outputs.RampUpRuleResponse']]:
        """
        List of ramp-up rules.
        """
        return pulumi.get(self, "ramp_up_rules")


@pulumi.output_type
class GeoDistributionResponse(dict):
    """
    A global distribution definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfWorkers":
            suggest = "number_of_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GeoDistributionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GeoDistributionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GeoDistributionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: Optional[str] = None,
                 number_of_workers: Optional[int] = None):
        """
        A global distribution definition.
        :param str location: Location.
        :param int number_of_workers: NumberOfWorkers.
        """
        GeoDistributionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            location=location,
            number_of_workers=number_of_workers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             location: Optional[str] = None,
             number_of_workers: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if number_of_workers is None and 'numberOfWorkers' in kwargs:
            number_of_workers = kwargs['numberOfWorkers']

        if location is not None:
            _setter("location", location)
        if number_of_workers is not None:
            _setter("number_of_workers", number_of_workers)

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[int]:
        """
        NumberOfWorkers.
        """
        return pulumi.get(self, "number_of_workers")


@pulumi.output_type
class HandlerMappingResponse(dict):
    """
    The IIS handler mappings used to define which handler processes HTTP requests with certain extension. 
    For example, it is used to configure php-cgi.exe process to handle all HTTP requests with *.php extension.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scriptProcessor":
            suggest = "script_processor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HandlerMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HandlerMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HandlerMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arguments: Optional[str] = None,
                 extension: Optional[str] = None,
                 script_processor: Optional[str] = None):
        """
        The IIS handler mappings used to define which handler processes HTTP requests with certain extension. 
        For example, it is used to configure php-cgi.exe process to handle all HTTP requests with *.php extension.
        :param str arguments: Command-line arguments to be passed to the script processor.
        :param str extension: Requests with this extension will be handled using the specified FastCGI application.
        :param str script_processor: The absolute path to the FastCGI application.
        """
        HandlerMappingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arguments=arguments,
            extension=extension,
            script_processor=script_processor,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arguments: Optional[str] = None,
             extension: Optional[str] = None,
             script_processor: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if script_processor is None and 'scriptProcessor' in kwargs:
            script_processor = kwargs['scriptProcessor']

        if arguments is not None:
            _setter("arguments", arguments)
        if extension is not None:
            _setter("extension", extension)
        if script_processor is not None:
            _setter("script_processor", script_processor)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[str]:
        """
        Command-line arguments to be passed to the script processor.
        """
        return pulumi.get(self, "arguments")

    @property
    @pulumi.getter
    def extension(self) -> Optional[str]:
        """
        Requests with this extension will be handled using the specified FastCGI application.
        """
        return pulumi.get(self, "extension")

    @property
    @pulumi.getter(name="scriptProcessor")
    def script_processor(self) -> Optional[str]:
        """
        The absolute path to the FastCGI application.
        """
        return pulumi.get(self, "script_processor")


@pulumi.output_type
class HostNameSslStateResponse(dict):
    """
    SSL-enabled hostname.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostType":
            suggest = "host_type"
        elif key == "sslState":
            suggest = "ssl_state"
        elif key == "toUpdate":
            suggest = "to_update"
        elif key == "virtualIP":
            suggest = "virtual_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNameSslStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNameSslStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNameSslStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_type: Optional[str] = None,
                 name: Optional[str] = None,
                 ssl_state: Optional[str] = None,
                 thumbprint: Optional[str] = None,
                 to_update: Optional[bool] = None,
                 virtual_ip: Optional[str] = None):
        """
        SSL-enabled hostname.
        :param str host_type: Indicates whether the hostname is a standard or repository hostname.
        :param str name: Hostname.
        :param str ssl_state: SSL type.
        :param str thumbprint: SSL certificate thumbprint.
        :param bool to_update: Set to <code>true</code> to update existing hostname.
        :param str virtual_ip: Virtual IP address assigned to the hostname if IP based SSL is enabled.
        """
        HostNameSslStateResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host_type=host_type,
            name=name,
            ssl_state=ssl_state,
            thumbprint=thumbprint,
            to_update=to_update,
            virtual_ip=virtual_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host_type: Optional[str] = None,
             name: Optional[str] = None,
             ssl_state: Optional[str] = None,
             thumbprint: Optional[str] = None,
             to_update: Optional[bool] = None,
             virtual_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if host_type is None and 'hostType' in kwargs:
            host_type = kwargs['hostType']
        if ssl_state is None and 'sslState' in kwargs:
            ssl_state = kwargs['sslState']
        if to_update is None and 'toUpdate' in kwargs:
            to_update = kwargs['toUpdate']
        if virtual_ip is None and 'virtualIP' in kwargs:
            virtual_ip = kwargs['virtualIP']

        if host_type is not None:
            _setter("host_type", host_type)
        if name is not None:
            _setter("name", name)
        if ssl_state is not None:
            _setter("ssl_state", ssl_state)
        if thumbprint is not None:
            _setter("thumbprint", thumbprint)
        if to_update is not None:
            _setter("to_update", to_update)
        if virtual_ip is not None:
            _setter("virtual_ip", virtual_ip)

    @property
    @pulumi.getter(name="hostType")
    def host_type(self) -> Optional[str]:
        """
        Indicates whether the hostname is a standard or repository hostname.
        """
        return pulumi.get(self, "host_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Hostname.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sslState")
    def ssl_state(self) -> Optional[str]:
        """
        SSL type.
        """
        return pulumi.get(self, "ssl_state")

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[str]:
        """
        SSL certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter(name="toUpdate")
    def to_update(self) -> Optional[bool]:
        """
        Set to <code>true</code> to update existing hostname.
        """
        return pulumi.get(self, "to_update")

    @property
    @pulumi.getter(name="virtualIP")
    def virtual_ip(self) -> Optional[str]:
        """
        Virtual IP address assigned to the hostname if IP based SSL is enabled.
        """
        return pulumi.get(self, "virtual_ip")


@pulumi.output_type
class HostingEnvironmentProfileResponse(dict):
    """
    Specification for an App Service Environment to use for this resource.
    """
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 id: Optional[str] = None):
        """
        Specification for an App Service Environment to use for this resource.
        :param str name: Name of the App Service Environment.
        :param str type: Resource type of the App Service Environment.
        :param str id: Resource ID of the App Service Environment.
        """
        HostingEnvironmentProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             type: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("name", name)
        _setter("type", type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the App Service Environment.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type of the App Service Environment.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID of the App Service Environment.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class IpSecurityRestrictionResponse(dict):
    """
    IP security restriction on an app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "subnetMask":
            suggest = "subnet_mask"
        elif key == "subnetTrafficTag":
            suggest = "subnet_traffic_tag"
        elif key == "vnetSubnetResourceId":
            suggest = "vnet_subnet_resource_id"
        elif key == "vnetTrafficTag":
            suggest = "vnet_traffic_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpSecurityRestrictionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpSecurityRestrictionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpSecurityRestrictionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 description: Optional[str] = None,
                 ip_address: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 subnet_mask: Optional[str] = None,
                 subnet_traffic_tag: Optional[int] = None,
                 tag: Optional[str] = None,
                 vnet_subnet_resource_id: Optional[str] = None,
                 vnet_traffic_tag: Optional[int] = None):
        """
        IP security restriction on an app.
        :param str action: Allow or Deny access for this IP range.
        :param str description: IP restriction rule description.
        :param str ip_address: IP address the security restriction is valid for.
               It can be in form of pure ipv4 address (required SubnetMask property) or
               CIDR notation such as ipv4/mask (leading bit match). For CIDR,
               SubnetMask property must not be specified.
        :param str name: IP restriction rule name.
        :param int priority: Priority of IP restriction rule.
        :param str subnet_mask: Subnet mask for the range of IP addresses the restriction is valid for.
        :param int subnet_traffic_tag: (internal) Subnet traffic tag
        :param str tag: Defines what this IP filter will be used for. This is to support IP filtering on proxies.
        :param str vnet_subnet_resource_id: Virtual network resource id
        :param int vnet_traffic_tag: (internal) Vnet traffic tag
        """
        IpSecurityRestrictionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            description=description,
            ip_address=ip_address,
            name=name,
            priority=priority,
            subnet_mask=subnet_mask,
            subnet_traffic_tag=subnet_traffic_tag,
            tag=tag,
            vnet_subnet_resource_id=vnet_subnet_resource_id,
            vnet_traffic_tag=vnet_traffic_tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             description: Optional[str] = None,
             ip_address: Optional[str] = None,
             name: Optional[str] = None,
             priority: Optional[int] = None,
             subnet_mask: Optional[str] = None,
             subnet_traffic_tag: Optional[int] = None,
             tag: Optional[str] = None,
             vnet_subnet_resource_id: Optional[str] = None,
             vnet_traffic_tag: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_address is None and 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if subnet_mask is None and 'subnetMask' in kwargs:
            subnet_mask = kwargs['subnetMask']
        if subnet_traffic_tag is None and 'subnetTrafficTag' in kwargs:
            subnet_traffic_tag = kwargs['subnetTrafficTag']
        if vnet_subnet_resource_id is None and 'vnetSubnetResourceId' in kwargs:
            vnet_subnet_resource_id = kwargs['vnetSubnetResourceId']
        if vnet_traffic_tag is None and 'vnetTrafficTag' in kwargs:
            vnet_traffic_tag = kwargs['vnetTrafficTag']

        if action is not None:
            _setter("action", action)
        if description is not None:
            _setter("description", description)
        if ip_address is not None:
            _setter("ip_address", ip_address)
        if name is not None:
            _setter("name", name)
        if priority is not None:
            _setter("priority", priority)
        if subnet_mask is not None:
            _setter("subnet_mask", subnet_mask)
        if subnet_traffic_tag is not None:
            _setter("subnet_traffic_tag", subnet_traffic_tag)
        if tag is not None:
            _setter("tag", tag)
        if vnet_subnet_resource_id is not None:
            _setter("vnet_subnet_resource_id", vnet_subnet_resource_id)
        if vnet_traffic_tag is not None:
            _setter("vnet_traffic_tag", vnet_traffic_tag)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Allow or Deny access for this IP range.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        IP restriction rule description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        IP address the security restriction is valid for.
        It can be in form of pure ipv4 address (required SubnetMask property) or
        CIDR notation such as ipv4/mask (leading bit match). For CIDR,
        SubnetMask property must not be specified.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        IP restriction rule name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority of IP restriction rule.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[str]:
        """
        Subnet mask for the range of IP addresses the restriction is valid for.
        """
        return pulumi.get(self, "subnet_mask")

    @property
    @pulumi.getter(name="subnetTrafficTag")
    def subnet_traffic_tag(self) -> Optional[int]:
        """
        (internal) Subnet traffic tag
        """
        return pulumi.get(self, "subnet_traffic_tag")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Defines what this IP filter will be used for. This is to support IP filtering on proxies.
        """
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter(name="vnetSubnetResourceId")
    def vnet_subnet_resource_id(self) -> Optional[str]:
        """
        Virtual network resource id
        """
        return pulumi.get(self, "vnet_subnet_resource_id")

    @property
    @pulumi.getter(name="vnetTrafficTag")
    def vnet_traffic_tag(self) -> Optional[int]:
        """
        (internal) Vnet traffic tag
        """
        return pulumi.get(self, "vnet_traffic_tag")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.ManagedServiceIdentityResponseUserAssignedIdentities']] = None):
        """
        Managed service identity.
        :param str principal_id: Principal Id of managed service identity.
        :param str tenant_id: Tenant of managed service identity.
        :param str type: Type of managed service identity.
        :param Mapping[str, 'ManagedServiceIdentityResponseUserAssignedIdentities'] user_assigned_identities: The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        """
        ManagedServiceIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             type: Optional[str] = None,
             user_assigned_identities: Optional[Mapping[str, 'outputs.ManagedServiceIdentityResponseUserAssignedIdentities']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if user_assigned_identities is None and 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        _setter("principal_id", principal_id)
        _setter("tenant_id", tenant_id)
        if type is not None:
            _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        Principal Id of managed service identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Tenant of managed service identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of managed service identity.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.ManagedServiceIdentityResponseUserAssignedIdentities']]:
        """
        The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ManagedServiceIdentityResponseUserAssignedIdentities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponseUserAssignedIdentities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        :param str client_id: Client Id of user assigned identity
        :param str principal_id: Principal Id of user assigned identity
        """
        ManagedServiceIdentityResponseUserAssignedIdentities._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            principal_id=principal_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             principal_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")

        _setter("client_id", client_id)
        _setter("principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client Id of user assigned identity
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        Principal Id of user assigned identity
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class NameValuePairResponse(dict):
    """
    Name value pair.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Name value pair.
        :param str name: Pair name.
        :param str value: Pair value.
        """
        NameValuePairResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Pair name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Pair value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PushSettingsResponse(dict):
    """
    Push settings for the App.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPushEnabled":
            suggest = "is_push_enabled"
        elif key == "dynamicTagsJson":
            suggest = "dynamic_tags_json"
        elif key == "tagWhitelistJson":
            suggest = "tag_whitelist_json"
        elif key == "tagsRequiringAuth":
            suggest = "tags_requiring_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PushSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PushSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PushSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 is_push_enabled: bool,
                 name: str,
                 type: str,
                 dynamic_tags_json: Optional[str] = None,
                 kind: Optional[str] = None,
                 tag_whitelist_json: Optional[str] = None,
                 tags_requiring_auth: Optional[str] = None):
        """
        Push settings for the App.
        :param str id: Resource Id.
        :param bool is_push_enabled: Gets or sets a flag indicating whether the Push endpoint is enabled.
        :param str name: Resource Name.
        :param str type: Resource type.
        :param str dynamic_tags_json: Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration endpoint.
        :param str kind: Kind of resource.
        :param str tag_whitelist_json: Gets or sets a JSON string containing a list of tags that are in the allowed list for use by the push registration endpoint.
        :param str tags_requiring_auth: Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration endpoint.
               Tags can consist of alphanumeric characters and the following:
               '_', '@', '#', '.', ':', '-'. 
               Validation should be performed at the PushRequestHandler.
        """
        PushSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            is_push_enabled=is_push_enabled,
            name=name,
            type=type,
            dynamic_tags_json=dynamic_tags_json,
            kind=kind,
            tag_whitelist_json=tag_whitelist_json,
            tags_requiring_auth=tags_requiring_auth,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             is_push_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             dynamic_tags_json: Optional[str] = None,
             kind: Optional[str] = None,
             tag_whitelist_json: Optional[str] = None,
             tags_requiring_auth: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if is_push_enabled is None and 'isPushEnabled' in kwargs:
            is_push_enabled = kwargs['isPushEnabled']
        if is_push_enabled is None:
            raise TypeError("Missing 'is_push_enabled' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if dynamic_tags_json is None and 'dynamicTagsJson' in kwargs:
            dynamic_tags_json = kwargs['dynamicTagsJson']
        if tag_whitelist_json is None and 'tagWhitelistJson' in kwargs:
            tag_whitelist_json = kwargs['tagWhitelistJson']
        if tags_requiring_auth is None and 'tagsRequiringAuth' in kwargs:
            tags_requiring_auth = kwargs['tagsRequiringAuth']

        _setter("id", id)
        _setter("is_push_enabled", is_push_enabled)
        _setter("name", name)
        _setter("type", type)
        if dynamic_tags_json is not None:
            _setter("dynamic_tags_json", dynamic_tags_json)
        if kind is not None:
            _setter("kind", kind)
        if tag_whitelist_json is not None:
            _setter("tag_whitelist_json", tag_whitelist_json)
        if tags_requiring_auth is not None:
            _setter("tags_requiring_auth", tags_requiring_auth)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isPushEnabled")
    def is_push_enabled(self) -> bool:
        """
        Gets or sets a flag indicating whether the Push endpoint is enabled.
        """
        return pulumi.get(self, "is_push_enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dynamicTagsJson")
    def dynamic_tags_json(self) -> Optional[str]:
        """
        Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration endpoint.
        """
        return pulumi.get(self, "dynamic_tags_json")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="tagWhitelistJson")
    def tag_whitelist_json(self) -> Optional[str]:
        """
        Gets or sets a JSON string containing a list of tags that are in the allowed list for use by the push registration endpoint.
        """
        return pulumi.get(self, "tag_whitelist_json")

    @property
    @pulumi.getter(name="tagsRequiringAuth")
    def tags_requiring_auth(self) -> Optional[str]:
        """
        Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration endpoint.
        Tags can consist of alphanumeric characters and the following:
        '_', '@', '#', '.', ':', '-'. 
        Validation should be performed at the PushRequestHandler.
        """
        return pulumi.get(self, "tags_requiring_auth")


@pulumi.output_type
class RampUpRuleResponse(dict):
    """
    Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to gradually change routing % based on performance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionHostName":
            suggest = "action_host_name"
        elif key == "changeDecisionCallbackUrl":
            suggest = "change_decision_callback_url"
        elif key == "changeIntervalInMinutes":
            suggest = "change_interval_in_minutes"
        elif key == "changeStep":
            suggest = "change_step"
        elif key == "maxReroutePercentage":
            suggest = "max_reroute_percentage"
        elif key == "minReroutePercentage":
            suggest = "min_reroute_percentage"
        elif key == "reroutePercentage":
            suggest = "reroute_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RampUpRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RampUpRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RampUpRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_host_name: Optional[str] = None,
                 change_decision_callback_url: Optional[str] = None,
                 change_interval_in_minutes: Optional[int] = None,
                 change_step: Optional[float] = None,
                 max_reroute_percentage: Optional[float] = None,
                 min_reroute_percentage: Optional[float] = None,
                 name: Optional[str] = None,
                 reroute_percentage: Optional[float] = None):
        """
        Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to gradually change routing % based on performance.
        :param str action_host_name: Hostname of a slot to which the traffic will be redirected if decided to. E.g. myapp-stage.azurewebsites.net.
        :param str change_decision_callback_url: Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified. See TiPCallback site extension for the scaffold and contracts.
               https://www.siteextensions.net/packages/TiPCallback/
        :param int change_interval_in_minutes: Specifies interval in minutes to reevaluate ReroutePercentage.
        :param float change_step: In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches 
               <code>MinReroutePercentage</code> or <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in <code>ChangeIntervalInMinutes</code>.
               Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
        :param float max_reroute_percentage: Specifies upper boundary below which ReroutePercentage will stay.
        :param float min_reroute_percentage: Specifies lower boundary above which ReroutePercentage will stay.
        :param str name: Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the experiment.
        :param float reroute_percentage: Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
        """
        RampUpRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_host_name=action_host_name,
            change_decision_callback_url=change_decision_callback_url,
            change_interval_in_minutes=change_interval_in_minutes,
            change_step=change_step,
            max_reroute_percentage=max_reroute_percentage,
            min_reroute_percentage=min_reroute_percentage,
            name=name,
            reroute_percentage=reroute_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_host_name: Optional[str] = None,
             change_decision_callback_url: Optional[str] = None,
             change_interval_in_minutes: Optional[int] = None,
             change_step: Optional[float] = None,
             max_reroute_percentage: Optional[float] = None,
             min_reroute_percentage: Optional[float] = None,
             name: Optional[str] = None,
             reroute_percentage: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_host_name is None and 'actionHostName' in kwargs:
            action_host_name = kwargs['actionHostName']
        if change_decision_callback_url is None and 'changeDecisionCallbackUrl' in kwargs:
            change_decision_callback_url = kwargs['changeDecisionCallbackUrl']
        if change_interval_in_minutes is None and 'changeIntervalInMinutes' in kwargs:
            change_interval_in_minutes = kwargs['changeIntervalInMinutes']
        if change_step is None and 'changeStep' in kwargs:
            change_step = kwargs['changeStep']
        if max_reroute_percentage is None and 'maxReroutePercentage' in kwargs:
            max_reroute_percentage = kwargs['maxReroutePercentage']
        if min_reroute_percentage is None and 'minReroutePercentage' in kwargs:
            min_reroute_percentage = kwargs['minReroutePercentage']
        if reroute_percentage is None and 'reroutePercentage' in kwargs:
            reroute_percentage = kwargs['reroutePercentage']

        if action_host_name is not None:
            _setter("action_host_name", action_host_name)
        if change_decision_callback_url is not None:
            _setter("change_decision_callback_url", change_decision_callback_url)
        if change_interval_in_minutes is not None:
            _setter("change_interval_in_minutes", change_interval_in_minutes)
        if change_step is not None:
            _setter("change_step", change_step)
        if max_reroute_percentage is not None:
            _setter("max_reroute_percentage", max_reroute_percentage)
        if min_reroute_percentage is not None:
            _setter("min_reroute_percentage", min_reroute_percentage)
        if name is not None:
            _setter("name", name)
        if reroute_percentage is not None:
            _setter("reroute_percentage", reroute_percentage)

    @property
    @pulumi.getter(name="actionHostName")
    def action_host_name(self) -> Optional[str]:
        """
        Hostname of a slot to which the traffic will be redirected if decided to. E.g. myapp-stage.azurewebsites.net.
        """
        return pulumi.get(self, "action_host_name")

    @property
    @pulumi.getter(name="changeDecisionCallbackUrl")
    def change_decision_callback_url(self) -> Optional[str]:
        """
        Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified. See TiPCallback site extension for the scaffold and contracts.
        https://www.siteextensions.net/packages/TiPCallback/
        """
        return pulumi.get(self, "change_decision_callback_url")

    @property
    @pulumi.getter(name="changeIntervalInMinutes")
    def change_interval_in_minutes(self) -> Optional[int]:
        """
        Specifies interval in minutes to reevaluate ReroutePercentage.
        """
        return pulumi.get(self, "change_interval_in_minutes")

    @property
    @pulumi.getter(name="changeStep")
    def change_step(self) -> Optional[float]:
        """
        In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches 
        <code>MinReroutePercentage</code> or <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in <code>ChangeIntervalInMinutes</code>.
        Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
        """
        return pulumi.get(self, "change_step")

    @property
    @pulumi.getter(name="maxReroutePercentage")
    def max_reroute_percentage(self) -> Optional[float]:
        """
        Specifies upper boundary below which ReroutePercentage will stay.
        """
        return pulumi.get(self, "max_reroute_percentage")

    @property
    @pulumi.getter(name="minReroutePercentage")
    def min_reroute_percentage(self) -> Optional[float]:
        """
        Specifies lower boundary above which ReroutePercentage will stay.
        """
        return pulumi.get(self, "min_reroute_percentage")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the experiment.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="reroutePercentage")
    def reroute_percentage(self) -> Optional[float]:
        """
        Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
        """
        return pulumi.get(self, "reroute_percentage")


@pulumi.output_type
class RequestsBasedTriggerResponse(dict):
    """
    Trigger based on total requests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeInterval":
            suggest = "time_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestsBasedTriggerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestsBasedTriggerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestsBasedTriggerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[int] = None,
                 time_interval: Optional[str] = None):
        """
        Trigger based on total requests.
        :param int count: Request Count.
        :param str time_interval: Time interval.
        """
        RequestsBasedTriggerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            time_interval=time_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             time_interval: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if time_interval is None and 'timeInterval' in kwargs:
            time_interval = kwargs['timeInterval']

        if count is not None:
            _setter("count", count)
        if time_interval is not None:
            _setter("time_interval", time_interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[str]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")


@pulumi.output_type
class SiteConfigResponse(dict):
    """
    Configuration of an App Service app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineKey":
            suggest = "machine_key"
        elif key == "alwaysOn":
            suggest = "always_on"
        elif key == "apiDefinition":
            suggest = "api_definition"
        elif key == "appCommandLine":
            suggest = "app_command_line"
        elif key == "appSettings":
            suggest = "app_settings"
        elif key == "autoHealEnabled":
            suggest = "auto_heal_enabled"
        elif key == "autoHealRules":
            suggest = "auto_heal_rules"
        elif key == "autoSwapSlotName":
            suggest = "auto_swap_slot_name"
        elif key == "azureStorageAccounts":
            suggest = "azure_storage_accounts"
        elif key == "connectionStrings":
            suggest = "connection_strings"
        elif key == "defaultDocuments":
            suggest = "default_documents"
        elif key == "detailedErrorLoggingEnabled":
            suggest = "detailed_error_logging_enabled"
        elif key == "documentRoot":
            suggest = "document_root"
        elif key == "ftpsState":
            suggest = "ftps_state"
        elif key == "handlerMappings":
            suggest = "handler_mappings"
        elif key == "http20Enabled":
            suggest = "http20_enabled"
        elif key == "httpLoggingEnabled":
            suggest = "http_logging_enabled"
        elif key == "ipSecurityRestrictions":
            suggest = "ip_security_restrictions"
        elif key == "javaContainer":
            suggest = "java_container"
        elif key == "javaContainerVersion":
            suggest = "java_container_version"
        elif key == "javaVersion":
            suggest = "java_version"
        elif key == "linuxFxVersion":
            suggest = "linux_fx_version"
        elif key == "loadBalancing":
            suggest = "load_balancing"
        elif key == "localMySqlEnabled":
            suggest = "local_my_sql_enabled"
        elif key == "logsDirectorySizeLimit":
            suggest = "logs_directory_size_limit"
        elif key == "managedPipelineMode":
            suggest = "managed_pipeline_mode"
        elif key == "managedServiceIdentityId":
            suggest = "managed_service_identity_id"
        elif key == "minTlsVersion":
            suggest = "min_tls_version"
        elif key == "netFrameworkVersion":
            suggest = "net_framework_version"
        elif key == "nodeVersion":
            suggest = "node_version"
        elif key == "numberOfWorkers":
            suggest = "number_of_workers"
        elif key == "phpVersion":
            suggest = "php_version"
        elif key == "publishingUsername":
            suggest = "publishing_username"
        elif key == "pythonVersion":
            suggest = "python_version"
        elif key == "remoteDebuggingEnabled":
            suggest = "remote_debugging_enabled"
        elif key == "remoteDebuggingVersion":
            suggest = "remote_debugging_version"
        elif key == "requestTracingEnabled":
            suggest = "request_tracing_enabled"
        elif key == "requestTracingExpirationTime":
            suggest = "request_tracing_expiration_time"
        elif key == "reservedInstanceCount":
            suggest = "reserved_instance_count"
        elif key == "scmIpSecurityRestrictions":
            suggest = "scm_ip_security_restrictions"
        elif key == "scmIpSecurityRestrictionsUseMain":
            suggest = "scm_ip_security_restrictions_use_main"
        elif key == "scmType":
            suggest = "scm_type"
        elif key == "tracingOptions":
            suggest = "tracing_options"
        elif key == "use32BitWorkerProcess":
            suggest = "use32_bit_worker_process"
        elif key == "virtualApplications":
            suggest = "virtual_applications"
        elif key == "vnetName":
            suggest = "vnet_name"
        elif key == "webSocketsEnabled":
            suggest = "web_sockets_enabled"
        elif key == "windowsFxVersion":
            suggest = "windows_fx_version"
        elif key == "xManagedServiceIdentityId":
            suggest = "x_managed_service_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SiteConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SiteConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SiteConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 machine_key: 'outputs.SiteMachineKeyResponse',
                 always_on: Optional[bool] = None,
                 api_definition: Optional['outputs.ApiDefinitionInfoResponse'] = None,
                 app_command_line: Optional[str] = None,
                 app_settings: Optional[Sequence['outputs.NameValuePairResponse']] = None,
                 auto_heal_enabled: Optional[bool] = None,
                 auto_heal_rules: Optional['outputs.AutoHealRulesResponse'] = None,
                 auto_swap_slot_name: Optional[str] = None,
                 azure_storage_accounts: Optional[Mapping[str, 'outputs.AzureStorageInfoValueResponse']] = None,
                 connection_strings: Optional[Sequence['outputs.ConnStringInfoResponse']] = None,
                 cors: Optional['outputs.CorsSettingsResponse'] = None,
                 default_documents: Optional[Sequence[str]] = None,
                 detailed_error_logging_enabled: Optional[bool] = None,
                 document_root: Optional[str] = None,
                 experiments: Optional['outputs.ExperimentsResponse'] = None,
                 ftps_state: Optional[str] = None,
                 handler_mappings: Optional[Sequence['outputs.HandlerMappingResponse']] = None,
                 http20_enabled: Optional[bool] = None,
                 http_logging_enabled: Optional[bool] = None,
                 ip_security_restrictions: Optional[Sequence['outputs.IpSecurityRestrictionResponse']] = None,
                 java_container: Optional[str] = None,
                 java_container_version: Optional[str] = None,
                 java_version: Optional[str] = None,
                 limits: Optional['outputs.SiteLimitsResponse'] = None,
                 linux_fx_version: Optional[str] = None,
                 load_balancing: Optional[str] = None,
                 local_my_sql_enabled: Optional[bool] = None,
                 logs_directory_size_limit: Optional[int] = None,
                 managed_pipeline_mode: Optional[str] = None,
                 managed_service_identity_id: Optional[int] = None,
                 min_tls_version: Optional[str] = None,
                 net_framework_version: Optional[str] = None,
                 node_version: Optional[str] = None,
                 number_of_workers: Optional[int] = None,
                 php_version: Optional[str] = None,
                 publishing_username: Optional[str] = None,
                 push: Optional['outputs.PushSettingsResponse'] = None,
                 python_version: Optional[str] = None,
                 remote_debugging_enabled: Optional[bool] = None,
                 remote_debugging_version: Optional[str] = None,
                 request_tracing_enabled: Optional[bool] = None,
                 request_tracing_expiration_time: Optional[str] = None,
                 reserved_instance_count: Optional[int] = None,
                 scm_ip_security_restrictions: Optional[Sequence['outputs.IpSecurityRestrictionResponse']] = None,
                 scm_ip_security_restrictions_use_main: Optional[bool] = None,
                 scm_type: Optional[str] = None,
                 tracing_options: Optional[str] = None,
                 use32_bit_worker_process: Optional[bool] = None,
                 virtual_applications: Optional[Sequence['outputs.VirtualApplicationResponse']] = None,
                 vnet_name: Optional[str] = None,
                 web_sockets_enabled: Optional[bool] = None,
                 windows_fx_version: Optional[str] = None,
                 x_managed_service_identity_id: Optional[int] = None):
        """
        Configuration of an App Service app.
        :param 'SiteMachineKeyResponse' machine_key: Site MachineKey.
        :param bool always_on: <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
        :param 'ApiDefinitionInfoResponse' api_definition: Information about the formal API definition for the app.
        :param str app_command_line: App command line to launch.
        :param Sequence['NameValuePairResponse'] app_settings: Application settings.
        :param bool auto_heal_enabled: <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
        :param 'AutoHealRulesResponse' auto_heal_rules: Auto Heal rules.
        :param str auto_swap_slot_name: Auto-swap slot name.
        :param Mapping[str, 'AzureStorageInfoValueResponse'] azure_storage_accounts: User-provided Azure storage accounts.
        :param Sequence['ConnStringInfoResponse'] connection_strings: Connection strings.
        :param 'CorsSettingsResponse' cors: Cross-Origin Resource Sharing (CORS) settings.
        :param Sequence[str] default_documents: Default documents.
        :param bool detailed_error_logging_enabled: <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
        :param str document_root: Document root.
        :param 'ExperimentsResponse' experiments: This is work around for polymorphic types.
        :param str ftps_state: State of FTP / FTPS service
        :param Sequence['HandlerMappingResponse'] handler_mappings: Handler mappings.
        :param bool http20_enabled: Http20Enabled: configures a web site to allow clients to connect over http2.0
        :param bool http_logging_enabled: <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
        :param Sequence['IpSecurityRestrictionResponse'] ip_security_restrictions: IP security restrictions for main.
        :param str java_container: Java container.
        :param str java_container_version: Java container version.
        :param str java_version: Java version.
        :param 'SiteLimitsResponse' limits: Site limits.
        :param str linux_fx_version: Linux App Framework and version
        :param str load_balancing: Site load balancing.
        :param bool local_my_sql_enabled: <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
        :param int logs_directory_size_limit: HTTP logs directory size limit.
        :param str managed_pipeline_mode: Managed pipeline mode.
        :param int managed_service_identity_id: Managed Service Identity Id
        :param str min_tls_version: MinTlsVersion: configures the minimum version of TLS required for SSL requests
        :param str net_framework_version: .NET Framework version.
        :param str node_version: Version of Node.js.
        :param int number_of_workers: Number of workers.
        :param str php_version: Version of PHP.
        :param str publishing_username: Publishing user name.
        :param 'PushSettingsResponse' push: Push endpoint settings.
        :param str python_version: Version of Python.
        :param bool remote_debugging_enabled: <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
        :param str remote_debugging_version: Remote debugging version.
        :param bool request_tracing_enabled: <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
        :param str request_tracing_expiration_time: Request tracing expiration time.
        :param int reserved_instance_count: Number of reserved instances.
               This setting only applies to the Consumption Plan
        :param Sequence['IpSecurityRestrictionResponse'] scm_ip_security_restrictions: IP security restrictions for scm.
        :param bool scm_ip_security_restrictions_use_main: IP security restrictions for scm to use main.
        :param str scm_type: SCM type.
        :param str tracing_options: Tracing options.
        :param bool use32_bit_worker_process: <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
        :param Sequence['VirtualApplicationResponse'] virtual_applications: Virtual applications.
        :param str vnet_name: Virtual Network name.
        :param bool web_sockets_enabled: <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
        :param str windows_fx_version: Xenon App Framework and version
        :param int x_managed_service_identity_id: Explicit Managed Service Identity Id
        """
        SiteConfigResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            machine_key=machine_key,
            always_on=always_on,
            api_definition=api_definition,
            app_command_line=app_command_line,
            app_settings=app_settings,
            auto_heal_enabled=auto_heal_enabled,
            auto_heal_rules=auto_heal_rules,
            auto_swap_slot_name=auto_swap_slot_name,
            azure_storage_accounts=azure_storage_accounts,
            connection_strings=connection_strings,
            cors=cors,
            default_documents=default_documents,
            detailed_error_logging_enabled=detailed_error_logging_enabled,
            document_root=document_root,
            experiments=experiments,
            ftps_state=ftps_state,
            handler_mappings=handler_mappings,
            http20_enabled=http20_enabled,
            http_logging_enabled=http_logging_enabled,
            ip_security_restrictions=ip_security_restrictions,
            java_container=java_container,
            java_container_version=java_container_version,
            java_version=java_version,
            limits=limits,
            linux_fx_version=linux_fx_version,
            load_balancing=load_balancing,
            local_my_sql_enabled=local_my_sql_enabled,
            logs_directory_size_limit=logs_directory_size_limit,
            managed_pipeline_mode=managed_pipeline_mode,
            managed_service_identity_id=managed_service_identity_id,
            min_tls_version=min_tls_version,
            net_framework_version=net_framework_version,
            node_version=node_version,
            number_of_workers=number_of_workers,
            php_version=php_version,
            publishing_username=publishing_username,
            push=push,
            python_version=python_version,
            remote_debugging_enabled=remote_debugging_enabled,
            remote_debugging_version=remote_debugging_version,
            request_tracing_enabled=request_tracing_enabled,
            request_tracing_expiration_time=request_tracing_expiration_time,
            reserved_instance_count=reserved_instance_count,
            scm_ip_security_restrictions=scm_ip_security_restrictions,
            scm_ip_security_restrictions_use_main=scm_ip_security_restrictions_use_main,
            scm_type=scm_type,
            tracing_options=tracing_options,
            use32_bit_worker_process=use32_bit_worker_process,
            virtual_applications=virtual_applications,
            vnet_name=vnet_name,
            web_sockets_enabled=web_sockets_enabled,
            windows_fx_version=windows_fx_version,
            x_managed_service_identity_id=x_managed_service_identity_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             machine_key: Optional['outputs.SiteMachineKeyResponse'] = None,
             always_on: Optional[bool] = None,
             api_definition: Optional['outputs.ApiDefinitionInfoResponse'] = None,
             app_command_line: Optional[str] = None,
             app_settings: Optional[Sequence['outputs.NameValuePairResponse']] = None,
             auto_heal_enabled: Optional[bool] = None,
             auto_heal_rules: Optional['outputs.AutoHealRulesResponse'] = None,
             auto_swap_slot_name: Optional[str] = None,
             azure_storage_accounts: Optional[Mapping[str, 'outputs.AzureStorageInfoValueResponse']] = None,
             connection_strings: Optional[Sequence['outputs.ConnStringInfoResponse']] = None,
             cors: Optional['outputs.CorsSettingsResponse'] = None,
             default_documents: Optional[Sequence[str]] = None,
             detailed_error_logging_enabled: Optional[bool] = None,
             document_root: Optional[str] = None,
             experiments: Optional['outputs.ExperimentsResponse'] = None,
             ftps_state: Optional[str] = None,
             handler_mappings: Optional[Sequence['outputs.HandlerMappingResponse']] = None,
             http20_enabled: Optional[bool] = None,
             http_logging_enabled: Optional[bool] = None,
             ip_security_restrictions: Optional[Sequence['outputs.IpSecurityRestrictionResponse']] = None,
             java_container: Optional[str] = None,
             java_container_version: Optional[str] = None,
             java_version: Optional[str] = None,
             limits: Optional['outputs.SiteLimitsResponse'] = None,
             linux_fx_version: Optional[str] = None,
             load_balancing: Optional[str] = None,
             local_my_sql_enabled: Optional[bool] = None,
             logs_directory_size_limit: Optional[int] = None,
             managed_pipeline_mode: Optional[str] = None,
             managed_service_identity_id: Optional[int] = None,
             min_tls_version: Optional[str] = None,
             net_framework_version: Optional[str] = None,
             node_version: Optional[str] = None,
             number_of_workers: Optional[int] = None,
             php_version: Optional[str] = None,
             publishing_username: Optional[str] = None,
             push: Optional['outputs.PushSettingsResponse'] = None,
             python_version: Optional[str] = None,
             remote_debugging_enabled: Optional[bool] = None,
             remote_debugging_version: Optional[str] = None,
             request_tracing_enabled: Optional[bool] = None,
             request_tracing_expiration_time: Optional[str] = None,
             reserved_instance_count: Optional[int] = None,
             scm_ip_security_restrictions: Optional[Sequence['outputs.IpSecurityRestrictionResponse']] = None,
             scm_ip_security_restrictions_use_main: Optional[bool] = None,
             scm_type: Optional[str] = None,
             tracing_options: Optional[str] = None,
             use32_bit_worker_process: Optional[bool] = None,
             virtual_applications: Optional[Sequence['outputs.VirtualApplicationResponse']] = None,
             vnet_name: Optional[str] = None,
             web_sockets_enabled: Optional[bool] = None,
             windows_fx_version: Optional[str] = None,
             x_managed_service_identity_id: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if machine_key is None and 'machineKey' in kwargs:
            machine_key = kwargs['machineKey']
        if machine_key is None:
            raise TypeError("Missing 'machine_key' argument")
        if always_on is None and 'alwaysOn' in kwargs:
            always_on = kwargs['alwaysOn']
        if api_definition is None and 'apiDefinition' in kwargs:
            api_definition = kwargs['apiDefinition']
        if app_command_line is None and 'appCommandLine' in kwargs:
            app_command_line = kwargs['appCommandLine']
        if app_settings is None and 'appSettings' in kwargs:
            app_settings = kwargs['appSettings']
        if auto_heal_enabled is None and 'autoHealEnabled' in kwargs:
            auto_heal_enabled = kwargs['autoHealEnabled']
        if auto_heal_rules is None and 'autoHealRules' in kwargs:
            auto_heal_rules = kwargs['autoHealRules']
        if auto_swap_slot_name is None and 'autoSwapSlotName' in kwargs:
            auto_swap_slot_name = kwargs['autoSwapSlotName']
        if azure_storage_accounts is None and 'azureStorageAccounts' in kwargs:
            azure_storage_accounts = kwargs['azureStorageAccounts']
        if connection_strings is None and 'connectionStrings' in kwargs:
            connection_strings = kwargs['connectionStrings']
        if default_documents is None and 'defaultDocuments' in kwargs:
            default_documents = kwargs['defaultDocuments']
        if detailed_error_logging_enabled is None and 'detailedErrorLoggingEnabled' in kwargs:
            detailed_error_logging_enabled = kwargs['detailedErrorLoggingEnabled']
        if document_root is None and 'documentRoot' in kwargs:
            document_root = kwargs['documentRoot']
        if ftps_state is None and 'ftpsState' in kwargs:
            ftps_state = kwargs['ftpsState']
        if handler_mappings is None and 'handlerMappings' in kwargs:
            handler_mappings = kwargs['handlerMappings']
        if http20_enabled is None and 'http20Enabled' in kwargs:
            http20_enabled = kwargs['http20Enabled']
        if http_logging_enabled is None and 'httpLoggingEnabled' in kwargs:
            http_logging_enabled = kwargs['httpLoggingEnabled']
        if ip_security_restrictions is None and 'ipSecurityRestrictions' in kwargs:
            ip_security_restrictions = kwargs['ipSecurityRestrictions']
        if java_container is None and 'javaContainer' in kwargs:
            java_container = kwargs['javaContainer']
        if java_container_version is None and 'javaContainerVersion' in kwargs:
            java_container_version = kwargs['javaContainerVersion']
        if java_version is None and 'javaVersion' in kwargs:
            java_version = kwargs['javaVersion']
        if linux_fx_version is None and 'linuxFxVersion' in kwargs:
            linux_fx_version = kwargs['linuxFxVersion']
        if load_balancing is None and 'loadBalancing' in kwargs:
            load_balancing = kwargs['loadBalancing']
        if local_my_sql_enabled is None and 'localMySqlEnabled' in kwargs:
            local_my_sql_enabled = kwargs['localMySqlEnabled']
        if logs_directory_size_limit is None and 'logsDirectorySizeLimit' in kwargs:
            logs_directory_size_limit = kwargs['logsDirectorySizeLimit']
        if managed_pipeline_mode is None and 'managedPipelineMode' in kwargs:
            managed_pipeline_mode = kwargs['managedPipelineMode']
        if managed_service_identity_id is None and 'managedServiceIdentityId' in kwargs:
            managed_service_identity_id = kwargs['managedServiceIdentityId']
        if min_tls_version is None and 'minTlsVersion' in kwargs:
            min_tls_version = kwargs['minTlsVersion']
        if net_framework_version is None and 'netFrameworkVersion' in kwargs:
            net_framework_version = kwargs['netFrameworkVersion']
        if node_version is None and 'nodeVersion' in kwargs:
            node_version = kwargs['nodeVersion']
        if number_of_workers is None and 'numberOfWorkers' in kwargs:
            number_of_workers = kwargs['numberOfWorkers']
        if php_version is None and 'phpVersion' in kwargs:
            php_version = kwargs['phpVersion']
        if publishing_username is None and 'publishingUsername' in kwargs:
            publishing_username = kwargs['publishingUsername']
        if python_version is None and 'pythonVersion' in kwargs:
            python_version = kwargs['pythonVersion']
        if remote_debugging_enabled is None and 'remoteDebuggingEnabled' in kwargs:
            remote_debugging_enabled = kwargs['remoteDebuggingEnabled']
        if remote_debugging_version is None and 'remoteDebuggingVersion' in kwargs:
            remote_debugging_version = kwargs['remoteDebuggingVersion']
        if request_tracing_enabled is None and 'requestTracingEnabled' in kwargs:
            request_tracing_enabled = kwargs['requestTracingEnabled']
        if request_tracing_expiration_time is None and 'requestTracingExpirationTime' in kwargs:
            request_tracing_expiration_time = kwargs['requestTracingExpirationTime']
        if reserved_instance_count is None and 'reservedInstanceCount' in kwargs:
            reserved_instance_count = kwargs['reservedInstanceCount']
        if scm_ip_security_restrictions is None and 'scmIpSecurityRestrictions' in kwargs:
            scm_ip_security_restrictions = kwargs['scmIpSecurityRestrictions']
        if scm_ip_security_restrictions_use_main is None and 'scmIpSecurityRestrictionsUseMain' in kwargs:
            scm_ip_security_restrictions_use_main = kwargs['scmIpSecurityRestrictionsUseMain']
        if scm_type is None and 'scmType' in kwargs:
            scm_type = kwargs['scmType']
        if tracing_options is None and 'tracingOptions' in kwargs:
            tracing_options = kwargs['tracingOptions']
        if use32_bit_worker_process is None and 'use32BitWorkerProcess' in kwargs:
            use32_bit_worker_process = kwargs['use32BitWorkerProcess']
        if virtual_applications is None and 'virtualApplications' in kwargs:
            virtual_applications = kwargs['virtualApplications']
        if vnet_name is None and 'vnetName' in kwargs:
            vnet_name = kwargs['vnetName']
        if web_sockets_enabled is None and 'webSocketsEnabled' in kwargs:
            web_sockets_enabled = kwargs['webSocketsEnabled']
        if windows_fx_version is None and 'windowsFxVersion' in kwargs:
            windows_fx_version = kwargs['windowsFxVersion']
        if x_managed_service_identity_id is None and 'xManagedServiceIdentityId' in kwargs:
            x_managed_service_identity_id = kwargs['xManagedServiceIdentityId']

        _setter("machine_key", machine_key)
        if always_on is not None:
            _setter("always_on", always_on)
        if api_definition is not None:
            _setter("api_definition", api_definition)
        if app_command_line is not None:
            _setter("app_command_line", app_command_line)
        if app_settings is not None:
            _setter("app_settings", app_settings)
        if auto_heal_enabled is not None:
            _setter("auto_heal_enabled", auto_heal_enabled)
        if auto_heal_rules is not None:
            _setter("auto_heal_rules", auto_heal_rules)
        if auto_swap_slot_name is not None:
            _setter("auto_swap_slot_name", auto_swap_slot_name)
        if azure_storage_accounts is not None:
            _setter("azure_storage_accounts", azure_storage_accounts)
        if connection_strings is not None:
            _setter("connection_strings", connection_strings)
        if cors is not None:
            _setter("cors", cors)
        if default_documents is not None:
            _setter("default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            _setter("detailed_error_logging_enabled", detailed_error_logging_enabled)
        if document_root is not None:
            _setter("document_root", document_root)
        if experiments is not None:
            _setter("experiments", experiments)
        if ftps_state is not None:
            _setter("ftps_state", ftps_state)
        if handler_mappings is not None:
            _setter("handler_mappings", handler_mappings)
        if http20_enabled is None:
            http20_enabled = True
        if http20_enabled is not None:
            _setter("http20_enabled", http20_enabled)
        if http_logging_enabled is not None:
            _setter("http_logging_enabled", http_logging_enabled)
        if ip_security_restrictions is not None:
            _setter("ip_security_restrictions", ip_security_restrictions)
        if java_container is not None:
            _setter("java_container", java_container)
        if java_container_version is not None:
            _setter("java_container_version", java_container_version)
        if java_version is not None:
            _setter("java_version", java_version)
        if limits is not None:
            _setter("limits", limits)
        if linux_fx_version is not None:
            _setter("linux_fx_version", linux_fx_version)
        if load_balancing is not None:
            _setter("load_balancing", load_balancing)
        if local_my_sql_enabled is None:
            local_my_sql_enabled = False
        if local_my_sql_enabled is not None:
            _setter("local_my_sql_enabled", local_my_sql_enabled)
        if logs_directory_size_limit is not None:
            _setter("logs_directory_size_limit", logs_directory_size_limit)
        if managed_pipeline_mode is not None:
            _setter("managed_pipeline_mode", managed_pipeline_mode)
        if managed_service_identity_id is not None:
            _setter("managed_service_identity_id", managed_service_identity_id)
        if min_tls_version is not None:
            _setter("min_tls_version", min_tls_version)
        if net_framework_version is None:
            net_framework_version = 'v4.6'
        if net_framework_version is not None:
            _setter("net_framework_version", net_framework_version)
        if node_version is not None:
            _setter("node_version", node_version)
        if number_of_workers is not None:
            _setter("number_of_workers", number_of_workers)
        if php_version is not None:
            _setter("php_version", php_version)
        if publishing_username is not None:
            _setter("publishing_username", publishing_username)
        if push is not None:
            _setter("push", push)
        if python_version is not None:
            _setter("python_version", python_version)
        if remote_debugging_enabled is not None:
            _setter("remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            _setter("remote_debugging_version", remote_debugging_version)
        if request_tracing_enabled is not None:
            _setter("request_tracing_enabled", request_tracing_enabled)
        if request_tracing_expiration_time is not None:
            _setter("request_tracing_expiration_time", request_tracing_expiration_time)
        if reserved_instance_count is not None:
            _setter("reserved_instance_count", reserved_instance_count)
        if scm_ip_security_restrictions is not None:
            _setter("scm_ip_security_restrictions", scm_ip_security_restrictions)
        if scm_ip_security_restrictions_use_main is not None:
            _setter("scm_ip_security_restrictions_use_main", scm_ip_security_restrictions_use_main)
        if scm_type is not None:
            _setter("scm_type", scm_type)
        if tracing_options is not None:
            _setter("tracing_options", tracing_options)
        if use32_bit_worker_process is not None:
            _setter("use32_bit_worker_process", use32_bit_worker_process)
        if virtual_applications is not None:
            _setter("virtual_applications", virtual_applications)
        if vnet_name is not None:
            _setter("vnet_name", vnet_name)
        if web_sockets_enabled is not None:
            _setter("web_sockets_enabled", web_sockets_enabled)
        if windows_fx_version is not None:
            _setter("windows_fx_version", windows_fx_version)
        if x_managed_service_identity_id is not None:
            _setter("x_managed_service_identity_id", x_managed_service_identity_id)

    @property
    @pulumi.getter(name="machineKey")
    def machine_key(self) -> 'outputs.SiteMachineKeyResponse':
        """
        Site MachineKey.
        """
        return pulumi.get(self, "machine_key")

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[bool]:
        """
        <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "always_on")

    @property
    @pulumi.getter(name="apiDefinition")
    def api_definition(self) -> Optional['outputs.ApiDefinitionInfoResponse']:
        """
        Information about the formal API definition for the app.
        """
        return pulumi.get(self, "api_definition")

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[str]:
        """
        App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @property
    @pulumi.getter(name="appSettings")
    def app_settings(self) -> Optional[Sequence['outputs.NameValuePairResponse']]:
        """
        Application settings.
        """
        return pulumi.get(self, "app_settings")

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> Optional[bool]:
        """
        <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @property
    @pulumi.getter(name="autoHealRules")
    def auto_heal_rules(self) -> Optional['outputs.AutoHealRulesResponse']:
        """
        Auto Heal rules.
        """
        return pulumi.get(self, "auto_heal_rules")

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[str]:
        """
        Auto-swap slot name.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @property
    @pulumi.getter(name="azureStorageAccounts")
    def azure_storage_accounts(self) -> Optional[Mapping[str, 'outputs.AzureStorageInfoValueResponse']]:
        """
        User-provided Azure storage accounts.
        """
        return pulumi.get(self, "azure_storage_accounts")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[Sequence['outputs.ConnStringInfoResponse']]:
        """
        Connection strings.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.CorsSettingsResponse']:
        """
        Cross-Origin Resource Sharing (CORS) settings.
        """
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[Sequence[str]]:
        """
        Default documents.
        """
        return pulumi.get(self, "default_documents")

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[bool]:
        """
        <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @property
    @pulumi.getter(name="documentRoot")
    def document_root(self) -> Optional[str]:
        """
        Document root.
        """
        return pulumi.get(self, "document_root")

    @property
    @pulumi.getter
    def experiments(self) -> Optional['outputs.ExperimentsResponse']:
        """
        This is work around for polymorphic types.
        """
        return pulumi.get(self, "experiments")

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[str]:
        """
        State of FTP / FTPS service
        """
        return pulumi.get(self, "ftps_state")

    @property
    @pulumi.getter(name="handlerMappings")
    def handler_mappings(self) -> Optional[Sequence['outputs.HandlerMappingResponse']]:
        """
        Handler mappings.
        """
        return pulumi.get(self, "handler_mappings")

    @property
    @pulumi.getter(name="http20Enabled")
    def http20_enabled(self) -> Optional[bool]:
        """
        Http20Enabled: configures a web site to allow clients to connect over http2.0
        """
        return pulumi.get(self, "http20_enabled")

    @property
    @pulumi.getter(name="httpLoggingEnabled")
    def http_logging_enabled(self) -> Optional[bool]:
        """
        <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "http_logging_enabled")

    @property
    @pulumi.getter(name="ipSecurityRestrictions")
    def ip_security_restrictions(self) -> Optional[Sequence['outputs.IpSecurityRestrictionResponse']]:
        """
        IP security restrictions for main.
        """
        return pulumi.get(self, "ip_security_restrictions")

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[str]:
        """
        Java container.
        """
        return pulumi.get(self, "java_container")

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[str]:
        """
        Java container version.
        """
        return pulumi.get(self, "java_container_version")

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[str]:
        """
        Java version.
        """
        return pulumi.get(self, "java_version")

    @property
    @pulumi.getter
    def limits(self) -> Optional['outputs.SiteLimitsResponse']:
        """
        Site limits.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[str]:
        """
        Linux App Framework and version
        """
        return pulumi.get(self, "linux_fx_version")

    @property
    @pulumi.getter(name="loadBalancing")
    def load_balancing(self) -> Optional[str]:
        """
        Site load balancing.
        """
        return pulumi.get(self, "load_balancing")

    @property
    @pulumi.getter(name="localMySqlEnabled")
    def local_my_sql_enabled(self) -> Optional[bool]:
        """
        <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "local_my_sql_enabled")

    @property
    @pulumi.getter(name="logsDirectorySizeLimit")
    def logs_directory_size_limit(self) -> Optional[int]:
        """
        HTTP logs directory size limit.
        """
        return pulumi.get(self, "logs_directory_size_limit")

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[str]:
        """
        Managed pipeline mode.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @property
    @pulumi.getter(name="managedServiceIdentityId")
    def managed_service_identity_id(self) -> Optional[int]:
        """
        Managed Service Identity Id
        """
        return pulumi.get(self, "managed_service_identity_id")

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[str]:
        """
        MinTlsVersion: configures the minimum version of TLS required for SSL requests
        """
        return pulumi.get(self, "min_tls_version")

    @property
    @pulumi.getter(name="netFrameworkVersion")
    def net_framework_version(self) -> Optional[str]:
        """
        .NET Framework version.
        """
        return pulumi.get(self, "net_framework_version")

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[str]:
        """
        Version of Node.js.
        """
        return pulumi.get(self, "node_version")

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[int]:
        """
        Number of workers.
        """
        return pulumi.get(self, "number_of_workers")

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[str]:
        """
        Version of PHP.
        """
        return pulumi.get(self, "php_version")

    @property
    @pulumi.getter(name="publishingUsername")
    def publishing_username(self) -> Optional[str]:
        """
        Publishing user name.
        """
        return pulumi.get(self, "publishing_username")

    @property
    @pulumi.getter
    def push(self) -> Optional['outputs.PushSettingsResponse']:
        """
        Push endpoint settings.
        """
        return pulumi.get(self, "push")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        """
        Version of Python.
        """
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[bool]:
        """
        <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[str]:
        """
        Remote debugging version.
        """
        return pulumi.get(self, "remote_debugging_version")

    @property
    @pulumi.getter(name="requestTracingEnabled")
    def request_tracing_enabled(self) -> Optional[bool]:
        """
        <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "request_tracing_enabled")

    @property
    @pulumi.getter(name="requestTracingExpirationTime")
    def request_tracing_expiration_time(self) -> Optional[str]:
        """
        Request tracing expiration time.
        """
        return pulumi.get(self, "request_tracing_expiration_time")

    @property
    @pulumi.getter(name="reservedInstanceCount")
    def reserved_instance_count(self) -> Optional[int]:
        """
        Number of reserved instances.
        This setting only applies to the Consumption Plan
        """
        return pulumi.get(self, "reserved_instance_count")

    @property
    @pulumi.getter(name="scmIpSecurityRestrictions")
    def scm_ip_security_restrictions(self) -> Optional[Sequence['outputs.IpSecurityRestrictionResponse']]:
        """
        IP security restrictions for scm.
        """
        return pulumi.get(self, "scm_ip_security_restrictions")

    @property
    @pulumi.getter(name="scmIpSecurityRestrictionsUseMain")
    def scm_ip_security_restrictions_use_main(self) -> Optional[bool]:
        """
        IP security restrictions for scm to use main.
        """
        return pulumi.get(self, "scm_ip_security_restrictions_use_main")

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[str]:
        """
        SCM type.
        """
        return pulumi.get(self, "scm_type")

    @property
    @pulumi.getter(name="tracingOptions")
    def tracing_options(self) -> Optional[str]:
        """
        Tracing options.
        """
        return pulumi.get(self, "tracing_options")

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[bool]:
        """
        <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @property
    @pulumi.getter(name="virtualApplications")
    def virtual_applications(self) -> Optional[Sequence['outputs.VirtualApplicationResponse']]:
        """
        Virtual applications.
        """
        return pulumi.get(self, "virtual_applications")

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> Optional[str]:
        """
        Virtual Network name.
        """
        return pulumi.get(self, "vnet_name")

    @property
    @pulumi.getter(name="webSocketsEnabled")
    def web_sockets_enabled(self) -> Optional[bool]:
        """
        <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "web_sockets_enabled")

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[str]:
        """
        Xenon App Framework and version
        """
        return pulumi.get(self, "windows_fx_version")

    @property
    @pulumi.getter(name="xManagedServiceIdentityId")
    def x_managed_service_identity_id(self) -> Optional[int]:
        """
        Explicit Managed Service Identity Id
        """
        return pulumi.get(self, "x_managed_service_identity_id")


@pulumi.output_type
class SiteLimitsResponse(dict):
    """
    Metric limits set on an app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxDiskSizeInMb":
            suggest = "max_disk_size_in_mb"
        elif key == "maxMemoryInMb":
            suggest = "max_memory_in_mb"
        elif key == "maxPercentageCpu":
            suggest = "max_percentage_cpu"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SiteLimitsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SiteLimitsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SiteLimitsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_disk_size_in_mb: Optional[float] = None,
                 max_memory_in_mb: Optional[float] = None,
                 max_percentage_cpu: Optional[float] = None):
        """
        Metric limits set on an app.
        :param float max_disk_size_in_mb: Maximum allowed disk size usage in MB.
        :param float max_memory_in_mb: Maximum allowed memory usage in MB.
        :param float max_percentage_cpu: Maximum allowed CPU usage percentage.
        """
        SiteLimitsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_disk_size_in_mb=max_disk_size_in_mb,
            max_memory_in_mb=max_memory_in_mb,
            max_percentage_cpu=max_percentage_cpu,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_disk_size_in_mb: Optional[float] = None,
             max_memory_in_mb: Optional[float] = None,
             max_percentage_cpu: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if max_disk_size_in_mb is None and 'maxDiskSizeInMb' in kwargs:
            max_disk_size_in_mb = kwargs['maxDiskSizeInMb']
        if max_memory_in_mb is None and 'maxMemoryInMb' in kwargs:
            max_memory_in_mb = kwargs['maxMemoryInMb']
        if max_percentage_cpu is None and 'maxPercentageCpu' in kwargs:
            max_percentage_cpu = kwargs['maxPercentageCpu']

        if max_disk_size_in_mb is not None:
            _setter("max_disk_size_in_mb", max_disk_size_in_mb)
        if max_memory_in_mb is not None:
            _setter("max_memory_in_mb", max_memory_in_mb)
        if max_percentage_cpu is not None:
            _setter("max_percentage_cpu", max_percentage_cpu)

    @property
    @pulumi.getter(name="maxDiskSizeInMb")
    def max_disk_size_in_mb(self) -> Optional[float]:
        """
        Maximum allowed disk size usage in MB.
        """
        return pulumi.get(self, "max_disk_size_in_mb")

    @property
    @pulumi.getter(name="maxMemoryInMb")
    def max_memory_in_mb(self) -> Optional[float]:
        """
        Maximum allowed memory usage in MB.
        """
        return pulumi.get(self, "max_memory_in_mb")

    @property
    @pulumi.getter(name="maxPercentageCpu")
    def max_percentage_cpu(self) -> Optional[float]:
        """
        Maximum allowed CPU usage percentage.
        """
        return pulumi.get(self, "max_percentage_cpu")


@pulumi.output_type
class SiteMachineKeyResponse(dict):
    """
    MachineKey of an app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decryptionKey":
            suggest = "decryption_key"
        elif key == "validationKey":
            suggest = "validation_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SiteMachineKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SiteMachineKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SiteMachineKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decryption: Optional[str] = None,
                 decryption_key: Optional[str] = None,
                 validation: Optional[str] = None,
                 validation_key: Optional[str] = None):
        """
        MachineKey of an app.
        :param str decryption: Algorithm used for decryption.
        :param str decryption_key: Decryption key.
        :param str validation: MachineKey validation.
        :param str validation_key: Validation key.
        """
        SiteMachineKeyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decryption=decryption,
            decryption_key=decryption_key,
            validation=validation,
            validation_key=validation_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decryption: Optional[str] = None,
             decryption_key: Optional[str] = None,
             validation: Optional[str] = None,
             validation_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if decryption_key is None and 'decryptionKey' in kwargs:
            decryption_key = kwargs['decryptionKey']
        if validation_key is None and 'validationKey' in kwargs:
            validation_key = kwargs['validationKey']

        if decryption is not None:
            _setter("decryption", decryption)
        if decryption_key is not None:
            _setter("decryption_key", decryption_key)
        if validation is not None:
            _setter("validation", validation)
        if validation_key is not None:
            _setter("validation_key", validation_key)

    @property
    @pulumi.getter
    def decryption(self) -> Optional[str]:
        """
        Algorithm used for decryption.
        """
        return pulumi.get(self, "decryption")

    @property
    @pulumi.getter(name="decryptionKey")
    def decryption_key(self) -> Optional[str]:
        """
        Decryption key.
        """
        return pulumi.get(self, "decryption_key")

    @property
    @pulumi.getter
    def validation(self) -> Optional[str]:
        """
        MachineKey validation.
        """
        return pulumi.get(self, "validation")

    @property
    @pulumi.getter(name="validationKey")
    def validation_key(self) -> Optional[str]:
        """
        Validation key.
        """
        return pulumi.get(self, "validation_key")


@pulumi.output_type
class SlotSwapStatusResponse(dict):
    """
    The status of the last successful slot swap operation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationSlotName":
            suggest = "destination_slot_name"
        elif key == "sourceSlotName":
            suggest = "source_slot_name"
        elif key == "timestampUtc":
            suggest = "timestamp_utc"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlotSwapStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlotSwapStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlotSwapStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_slot_name: str,
                 source_slot_name: str,
                 timestamp_utc: str):
        """
        The status of the last successful slot swap operation.
        :param str destination_slot_name: The destination slot of the last swap operation.
        :param str source_slot_name: The source slot of the last swap operation.
        :param str timestamp_utc: The time the last successful slot swap completed.
        """
        SlotSwapStatusResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_slot_name=destination_slot_name,
            source_slot_name=source_slot_name,
            timestamp_utc=timestamp_utc,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_slot_name: Optional[str] = None,
             source_slot_name: Optional[str] = None,
             timestamp_utc: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination_slot_name is None and 'destinationSlotName' in kwargs:
            destination_slot_name = kwargs['destinationSlotName']
        if destination_slot_name is None:
            raise TypeError("Missing 'destination_slot_name' argument")
        if source_slot_name is None and 'sourceSlotName' in kwargs:
            source_slot_name = kwargs['sourceSlotName']
        if source_slot_name is None:
            raise TypeError("Missing 'source_slot_name' argument")
        if timestamp_utc is None and 'timestampUtc' in kwargs:
            timestamp_utc = kwargs['timestampUtc']
        if timestamp_utc is None:
            raise TypeError("Missing 'timestamp_utc' argument")

        _setter("destination_slot_name", destination_slot_name)
        _setter("source_slot_name", source_slot_name)
        _setter("timestamp_utc", timestamp_utc)

    @property
    @pulumi.getter(name="destinationSlotName")
    def destination_slot_name(self) -> str:
        """
        The destination slot of the last swap operation.
        """
        return pulumi.get(self, "destination_slot_name")

    @property
    @pulumi.getter(name="sourceSlotName")
    def source_slot_name(self) -> str:
        """
        The source slot of the last swap operation.
        """
        return pulumi.get(self, "source_slot_name")

    @property
    @pulumi.getter(name="timestampUtc")
    def timestamp_utc(self) -> str:
        """
        The time the last successful slot swap completed.
        """
        return pulumi.get(self, "timestamp_utc")


@pulumi.output_type
class SlowRequestsBasedTriggerResponse(dict):
    """
    Trigger based on request execution time.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeInterval":
            suggest = "time_interval"
        elif key == "timeTaken":
            suggest = "time_taken"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SlowRequestsBasedTriggerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SlowRequestsBasedTriggerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SlowRequestsBasedTriggerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[int] = None,
                 time_interval: Optional[str] = None,
                 time_taken: Optional[str] = None):
        """
        Trigger based on request execution time.
        :param int count: Request Count.
        :param str time_interval: Time interval.
        :param str time_taken: Time taken.
        """
        SlowRequestsBasedTriggerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            time_interval=time_interval,
            time_taken=time_taken,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             time_interval: Optional[str] = None,
             time_taken: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if time_interval is None and 'timeInterval' in kwargs:
            time_interval = kwargs['timeInterval']
        if time_taken is None and 'timeTaken' in kwargs:
            time_taken = kwargs['timeTaken']

        if count is not None:
            _setter("count", count)
        if time_interval is not None:
            _setter("time_interval", time_interval)
        if time_taken is not None:
            _setter("time_taken", time_taken)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[str]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> Optional[str]:
        """
        Time taken.
        """
        return pulumi.get(self, "time_taken")


@pulumi.output_type
class StatusCodesBasedTriggerResponse(dict):
    """
    Trigger based on status code.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subStatus":
            suggest = "sub_status"
        elif key == "timeInterval":
            suggest = "time_interval"
        elif key == "win32Status":
            suggest = "win32_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StatusCodesBasedTriggerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StatusCodesBasedTriggerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StatusCodesBasedTriggerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: Optional[int] = None,
                 status: Optional[int] = None,
                 sub_status: Optional[int] = None,
                 time_interval: Optional[str] = None,
                 win32_status: Optional[int] = None):
        """
        Trigger based on status code.
        :param int count: Request Count.
        :param int status: HTTP status code.
        :param int sub_status: Request Sub Status.
        :param str time_interval: Time interval.
        :param int win32_status: Win32 error code.
        """
        StatusCodesBasedTriggerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            status=status,
            sub_status=sub_status,
            time_interval=time_interval,
            win32_status=win32_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             status: Optional[int] = None,
             sub_status: Optional[int] = None,
             time_interval: Optional[str] = None,
             win32_status: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if sub_status is None and 'subStatus' in kwargs:
            sub_status = kwargs['subStatus']
        if time_interval is None and 'timeInterval' in kwargs:
            time_interval = kwargs['timeInterval']
        if win32_status is None and 'win32Status' in kwargs:
            win32_status = kwargs['win32Status']

        if count is not None:
            _setter("count", count)
        if status is not None:
            _setter("status", status)
        if sub_status is not None:
            _setter("sub_status", sub_status)
        if time_interval is not None:
            _setter("time_interval", time_interval)
        if win32_status is not None:
            _setter("win32_status", win32_status)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def status(self) -> Optional[int]:
        """
        HTTP status code.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[int]:
        """
        Request Sub Status.
        """
        return pulumi.get(self, "sub_status")

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[str]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")

    @property
    @pulumi.getter(name="win32Status")
    def win32_status(self) -> Optional[int]:
        """
        Win32 error code.
        """
        return pulumi.get(self, "win32_status")


@pulumi.output_type
class VirtualApplicationResponse(dict):
    """
    Virtual application in an app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "physicalPath":
            suggest = "physical_path"
        elif key == "preloadEnabled":
            suggest = "preload_enabled"
        elif key == "virtualDirectories":
            suggest = "virtual_directories"
        elif key == "virtualPath":
            suggest = "virtual_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualApplicationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualApplicationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualApplicationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 physical_path: Optional[str] = None,
                 preload_enabled: Optional[bool] = None,
                 virtual_directories: Optional[Sequence['outputs.VirtualDirectoryResponse']] = None,
                 virtual_path: Optional[str] = None):
        """
        Virtual application in an app.
        :param str physical_path: Physical path.
        :param bool preload_enabled: <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
        :param Sequence['VirtualDirectoryResponse'] virtual_directories: Virtual directories for virtual application.
        :param str virtual_path: Virtual path.
        """
        VirtualApplicationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            physical_path=physical_path,
            preload_enabled=preload_enabled,
            virtual_directories=virtual_directories,
            virtual_path=virtual_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             physical_path: Optional[str] = None,
             preload_enabled: Optional[bool] = None,
             virtual_directories: Optional[Sequence['outputs.VirtualDirectoryResponse']] = None,
             virtual_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if physical_path is None and 'physicalPath' in kwargs:
            physical_path = kwargs['physicalPath']
        if preload_enabled is None and 'preloadEnabled' in kwargs:
            preload_enabled = kwargs['preloadEnabled']
        if virtual_directories is None and 'virtualDirectories' in kwargs:
            virtual_directories = kwargs['virtualDirectories']
        if virtual_path is None and 'virtualPath' in kwargs:
            virtual_path = kwargs['virtualPath']

        if physical_path is not None:
            _setter("physical_path", physical_path)
        if preload_enabled is not None:
            _setter("preload_enabled", preload_enabled)
        if virtual_directories is not None:
            _setter("virtual_directories", virtual_directories)
        if virtual_path is not None:
            _setter("virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[str]:
        """
        Physical path.
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter(name="preloadEnabled")
    def preload_enabled(self) -> Optional[bool]:
        """
        <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "preload_enabled")

    @property
    @pulumi.getter(name="virtualDirectories")
    def virtual_directories(self) -> Optional[Sequence['outputs.VirtualDirectoryResponse']]:
        """
        Virtual directories for virtual application.
        """
        return pulumi.get(self, "virtual_directories")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[str]:
        """
        Virtual path.
        """
        return pulumi.get(self, "virtual_path")


@pulumi.output_type
class VirtualDirectoryResponse(dict):
    """
    Directory for virtual application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "physicalPath":
            suggest = "physical_path"
        elif key == "virtualPath":
            suggest = "virtual_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualDirectoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualDirectoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualDirectoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 physical_path: Optional[str] = None,
                 virtual_path: Optional[str] = None):
        """
        Directory for virtual application.
        :param str physical_path: Physical path.
        :param str virtual_path: Path to virtual application.
        """
        VirtualDirectoryResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            physical_path=physical_path,
            virtual_path=virtual_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             physical_path: Optional[str] = None,
             virtual_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if physical_path is None and 'physicalPath' in kwargs:
            physical_path = kwargs['physicalPath']
        if virtual_path is None and 'virtualPath' in kwargs:
            virtual_path = kwargs['virtualPath']

        if physical_path is not None:
            _setter("physical_path", physical_path)
        if virtual_path is not None:
            _setter("virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[str]:
        """
        Physical path.
        """
        return pulumi.get(self, "physical_path")

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[str]:
        """
        Path to virtual application.
        """
        return pulumi.get(self, "virtual_path")


