# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'IdentifierResponse',
    'NameValuePairResponse',
    'NetworkAccessControlEntryResponse',
    'StampCapacityResponse',
    'VirtualIPMappingResponse',
    'VirtualNetworkProfileResponse',
    'WorkerPoolResponse',
]

@pulumi.output_type
class IdentifierResponse(dict):
    """
    A domain specific resource identifier.
    """
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str,
                 kind: Optional[str] = None,
                 value: Optional[str] = None):
        """
        A domain specific resource identifier.
        :param str id: Resource Id.
        :param str name: Resource Name.
        :param str type: Resource type.
        :param str kind: Kind of resource.
        :param str value: String representation of the identity.
        """
        IdentifierResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            type=type,
            kind=kind,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             name: str,
             type: str,
             kind: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("id", id)
        _setter("name", name)
        _setter("type", type)
        if kind is not None:
            _setter("kind", kind)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        String representation of the identity.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NameValuePairResponse(dict):
    """
    Name value pair.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Name value pair.
        :param str name: Pair name.
        :param str value: Pair value.
        """
        NameValuePairResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Pair name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Pair value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkAccessControlEntryResponse(dict):
    """
    Network access control entry.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteSubnet":
            suggest = "remote_subnet"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAccessControlEntryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAccessControlEntryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAccessControlEntryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 description: Optional[str] = None,
                 order: Optional[int] = None,
                 remote_subnet: Optional[str] = None):
        """
        Network access control entry.
        :param str action: Action object.
        :param str description: Description of network access control entry.
        :param int order: Order of precedence.
        :param str remote_subnet: Remote subnet.
        """
        NetworkAccessControlEntryResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            description=description,
            order=order,
            remote_subnet=remote_subnet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             description: Optional[str] = None,
             order: Optional[int] = None,
             remote_subnet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'remoteSubnet' in kwargs:
            remote_subnet = kwargs['remoteSubnet']

        if action is not None:
            _setter("action", action)
        if description is not None:
            _setter("description", description)
        if order is not None:
            _setter("order", order)
        if remote_subnet is not None:
            _setter("remote_subnet", remote_subnet)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action object.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of network access control entry.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def order(self) -> Optional[int]:
        """
        Order of precedence.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="remoteSubnet")
    def remote_subnet(self) -> Optional[str]:
        """
        Remote subnet.
        """
        return pulumi.get(self, "remote_subnet")


@pulumi.output_type
class StampCapacityResponse(dict):
    """
    Stamp capacity information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableCapacity":
            suggest = "available_capacity"
        elif key == "computeMode":
            suggest = "compute_mode"
        elif key == "excludeFromCapacityAllocation":
            suggest = "exclude_from_capacity_allocation"
        elif key == "isApplicableForAllComputeModes":
            suggest = "is_applicable_for_all_compute_modes"
        elif key == "isLinux":
            suggest = "is_linux"
        elif key == "siteMode":
            suggest = "site_mode"
        elif key == "totalCapacity":
            suggest = "total_capacity"
        elif key == "workerSize":
            suggest = "worker_size"
        elif key == "workerSizeId":
            suggest = "worker_size_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StampCapacityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StampCapacityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StampCapacityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 available_capacity: Optional[float] = None,
                 compute_mode: Optional[str] = None,
                 exclude_from_capacity_allocation: Optional[bool] = None,
                 is_applicable_for_all_compute_modes: Optional[bool] = None,
                 is_linux: Optional[bool] = None,
                 name: Optional[str] = None,
                 site_mode: Optional[str] = None,
                 total_capacity: Optional[float] = None,
                 unit: Optional[str] = None,
                 worker_size: Optional[str] = None,
                 worker_size_id: Optional[int] = None):
        """
        Stamp capacity information.
        :param float available_capacity: Available capacity (# of machines, bytes of storage etc...).
        :param str compute_mode: Shared/dedicated workers.
        :param bool exclude_from_capacity_allocation: If <code>true</code>, it includes basic apps.
               Basic apps are not used for capacity allocation.
        :param bool is_applicable_for_all_compute_modes: <code>true</code> if capacity is applicable for all apps; otherwise, <code>false</code>.
        :param bool is_linux: Is this a linux stamp capacity
        :param str name: Name of the stamp.
        :param str site_mode: Shared or Dedicated.
        :param float total_capacity: Total capacity (# of machines, bytes of storage etc...).
        :param str unit: Name of the unit.
        :param str worker_size: Size of the machines.
        :param int worker_size_id: Size ID of machines: 
               0 - Small
               1 - Medium
               2 - Large
        """
        StampCapacityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            available_capacity=available_capacity,
            compute_mode=compute_mode,
            exclude_from_capacity_allocation=exclude_from_capacity_allocation,
            is_applicable_for_all_compute_modes=is_applicable_for_all_compute_modes,
            is_linux=is_linux,
            name=name,
            site_mode=site_mode,
            total_capacity=total_capacity,
            unit=unit,
            worker_size=worker_size,
            worker_size_id=worker_size_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             available_capacity: Optional[float] = None,
             compute_mode: Optional[str] = None,
             exclude_from_capacity_allocation: Optional[bool] = None,
             is_applicable_for_all_compute_modes: Optional[bool] = None,
             is_linux: Optional[bool] = None,
             name: Optional[str] = None,
             site_mode: Optional[str] = None,
             total_capacity: Optional[float] = None,
             unit: Optional[str] = None,
             worker_size: Optional[str] = None,
             worker_size_id: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'availableCapacity' in kwargs:
            available_capacity = kwargs['availableCapacity']
        if 'computeMode' in kwargs:
            compute_mode = kwargs['computeMode']
        if 'excludeFromCapacityAllocation' in kwargs:
            exclude_from_capacity_allocation = kwargs['excludeFromCapacityAllocation']
        if 'isApplicableForAllComputeModes' in kwargs:
            is_applicable_for_all_compute_modes = kwargs['isApplicableForAllComputeModes']
        if 'isLinux' in kwargs:
            is_linux = kwargs['isLinux']
        if 'siteMode' in kwargs:
            site_mode = kwargs['siteMode']
        if 'totalCapacity' in kwargs:
            total_capacity = kwargs['totalCapacity']
        if 'workerSize' in kwargs:
            worker_size = kwargs['workerSize']
        if 'workerSizeId' in kwargs:
            worker_size_id = kwargs['workerSizeId']

        if available_capacity is not None:
            _setter("available_capacity", available_capacity)
        if compute_mode is not None:
            _setter("compute_mode", compute_mode)
        if exclude_from_capacity_allocation is not None:
            _setter("exclude_from_capacity_allocation", exclude_from_capacity_allocation)
        if is_applicable_for_all_compute_modes is not None:
            _setter("is_applicable_for_all_compute_modes", is_applicable_for_all_compute_modes)
        if is_linux is not None:
            _setter("is_linux", is_linux)
        if name is not None:
            _setter("name", name)
        if site_mode is not None:
            _setter("site_mode", site_mode)
        if total_capacity is not None:
            _setter("total_capacity", total_capacity)
        if unit is not None:
            _setter("unit", unit)
        if worker_size is not None:
            _setter("worker_size", worker_size)
        if worker_size_id is not None:
            _setter("worker_size_id", worker_size_id)

    @property
    @pulumi.getter(name="availableCapacity")
    def available_capacity(self) -> Optional[float]:
        """
        Available capacity (# of machines, bytes of storage etc...).
        """
        return pulumi.get(self, "available_capacity")

    @property
    @pulumi.getter(name="computeMode")
    def compute_mode(self) -> Optional[str]:
        """
        Shared/dedicated workers.
        """
        return pulumi.get(self, "compute_mode")

    @property
    @pulumi.getter(name="excludeFromCapacityAllocation")
    def exclude_from_capacity_allocation(self) -> Optional[bool]:
        """
        If <code>true</code>, it includes basic apps.
        Basic apps are not used for capacity allocation.
        """
        return pulumi.get(self, "exclude_from_capacity_allocation")

    @property
    @pulumi.getter(name="isApplicableForAllComputeModes")
    def is_applicable_for_all_compute_modes(self) -> Optional[bool]:
        """
        <code>true</code> if capacity is applicable for all apps; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "is_applicable_for_all_compute_modes")

    @property
    @pulumi.getter(name="isLinux")
    def is_linux(self) -> Optional[bool]:
        """
        Is this a linux stamp capacity
        """
        return pulumi.get(self, "is_linux")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the stamp.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="siteMode")
    def site_mode(self) -> Optional[str]:
        """
        Shared or Dedicated.
        """
        return pulumi.get(self, "site_mode")

    @property
    @pulumi.getter(name="totalCapacity")
    def total_capacity(self) -> Optional[float]:
        """
        Total capacity (# of machines, bytes of storage etc...).
        """
        return pulumi.get(self, "total_capacity")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        Name of the unit.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter(name="workerSize")
    def worker_size(self) -> Optional[str]:
        """
        Size of the machines.
        """
        return pulumi.get(self, "worker_size")

    @property
    @pulumi.getter(name="workerSizeId")
    def worker_size_id(self) -> Optional[int]:
        """
        Size ID of machines: 
        0 - Small
        1 - Medium
        2 - Large
        """
        return pulumi.get(self, "worker_size_id")


@pulumi.output_type
class VirtualIPMappingResponse(dict):
    """
    Virtual IP mapping.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inUse":
            suggest = "in_use"
        elif key == "internalHttpPort":
            suggest = "internal_http_port"
        elif key == "internalHttpsPort":
            suggest = "internal_https_port"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "virtualIP":
            suggest = "virtual_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualIPMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualIPMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualIPMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_use: Optional[bool] = None,
                 internal_http_port: Optional[int] = None,
                 internal_https_port: Optional[int] = None,
                 service_name: Optional[str] = None,
                 virtual_ip: Optional[str] = None):
        """
        Virtual IP mapping.
        :param bool in_use: Is virtual IP mapping in use.
        :param int internal_http_port: Internal HTTP port.
        :param int internal_https_port: Internal HTTPS port.
        :param str service_name: name of the service that virtual IP is assigned to
        :param str virtual_ip: Virtual IP address.
        """
        VirtualIPMappingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            in_use=in_use,
            internal_http_port=internal_http_port,
            internal_https_port=internal_https_port,
            service_name=service_name,
            virtual_ip=virtual_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             in_use: Optional[bool] = None,
             internal_http_port: Optional[int] = None,
             internal_https_port: Optional[int] = None,
             service_name: Optional[str] = None,
             virtual_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'inUse' in kwargs:
            in_use = kwargs['inUse']
        if 'internalHttpPort' in kwargs:
            internal_http_port = kwargs['internalHttpPort']
        if 'internalHttpsPort' in kwargs:
            internal_https_port = kwargs['internalHttpsPort']
        if 'serviceName' in kwargs:
            service_name = kwargs['serviceName']
        if 'virtualIP' in kwargs:
            virtual_ip = kwargs['virtualIP']

        if in_use is not None:
            _setter("in_use", in_use)
        if internal_http_port is not None:
            _setter("internal_http_port", internal_http_port)
        if internal_https_port is not None:
            _setter("internal_https_port", internal_https_port)
        if service_name is not None:
            _setter("service_name", service_name)
        if virtual_ip is not None:
            _setter("virtual_ip", virtual_ip)

    @property
    @pulumi.getter(name="inUse")
    def in_use(self) -> Optional[bool]:
        """
        Is virtual IP mapping in use.
        """
        return pulumi.get(self, "in_use")

    @property
    @pulumi.getter(name="internalHttpPort")
    def internal_http_port(self) -> Optional[int]:
        """
        Internal HTTP port.
        """
        return pulumi.get(self, "internal_http_port")

    @property
    @pulumi.getter(name="internalHttpsPort")
    def internal_https_port(self) -> Optional[int]:
        """
        Internal HTTPS port.
        """
        return pulumi.get(self, "internal_https_port")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        name of the service that virtual IP is assigned to
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="virtualIP")
    def virtual_ip(self) -> Optional[str]:
        """
        Virtual IP address.
        """
        return pulumi.get(self, "virtual_ip")


@pulumi.output_type
class VirtualNetworkProfileResponse(dict):
    """
    Specification for using a Virtual Network.
    """
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 id: Optional[str] = None,
                 subnet: Optional[str] = None):
        """
        Specification for using a Virtual Network.
        :param str name: Name of the Virtual Network (read-only).
        :param str type: Resource type of the Virtual Network (read-only).
        :param str id: Resource id of the Virtual Network.
        :param str subnet: Subnet within the Virtual Network.
        """
        VirtualNetworkProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
            id=id,
            subnet=subnet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             type: str,
             id: Optional[str] = None,
             subnet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("type", type)
        if id is not None:
            _setter("id", id)
        if subnet is not None:
            _setter("subnet", subnet)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Virtual Network (read-only).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type of the Virtual Network (read-only).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource id of the Virtual Network.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def subnet(self) -> Optional[str]:
        """
        Subnet within the Virtual Network.
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class WorkerPoolResponse(dict):
    """
    Worker pool of an App Service Environment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceNames":
            suggest = "instance_names"
        elif key == "computeMode":
            suggest = "compute_mode"
        elif key == "workerCount":
            suggest = "worker_count"
        elif key == "workerSize":
            suggest = "worker_size"
        elif key == "workerSizeId":
            suggest = "worker_size_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkerPoolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkerPoolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkerPoolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_names: Sequence[str],
                 compute_mode: Optional[str] = None,
                 worker_count: Optional[int] = None,
                 worker_size: Optional[str] = None,
                 worker_size_id: Optional[int] = None):
        """
        Worker pool of an App Service Environment.
        :param Sequence[str] instance_names: Names of all instances in the worker pool (read only).
        :param str compute_mode: Shared or dedicated app hosting.
        :param int worker_count: Number of instances in the worker pool.
        :param str worker_size: VM size of the worker pool instances.
        :param int worker_size_id: Worker size ID for referencing this worker pool.
        """
        WorkerPoolResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_names=instance_names,
            compute_mode=compute_mode,
            worker_count=worker_count,
            worker_size=worker_size,
            worker_size_id=worker_size_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_names: Sequence[str],
             compute_mode: Optional[str] = None,
             worker_count: Optional[int] = None,
             worker_size: Optional[str] = None,
             worker_size_id: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'instanceNames' in kwargs:
            instance_names = kwargs['instanceNames']
        if 'computeMode' in kwargs:
            compute_mode = kwargs['computeMode']
        if 'workerCount' in kwargs:
            worker_count = kwargs['workerCount']
        if 'workerSize' in kwargs:
            worker_size = kwargs['workerSize']
        if 'workerSizeId' in kwargs:
            worker_size_id = kwargs['workerSizeId']

        _setter("instance_names", instance_names)
        if compute_mode is not None:
            _setter("compute_mode", compute_mode)
        if worker_count is not None:
            _setter("worker_count", worker_count)
        if worker_size is not None:
            _setter("worker_size", worker_size)
        if worker_size_id is not None:
            _setter("worker_size_id", worker_size_id)

    @property
    @pulumi.getter(name="instanceNames")
    def instance_names(self) -> Sequence[str]:
        """
        Names of all instances in the worker pool (read only).
        """
        return pulumi.get(self, "instance_names")

    @property
    @pulumi.getter(name="computeMode")
    def compute_mode(self) -> Optional[str]:
        """
        Shared or dedicated app hosting.
        """
        return pulumi.get(self, "compute_mode")

    @property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> Optional[int]:
        """
        Number of instances in the worker pool.
        """
        return pulumi.get(self, "worker_count")

    @property
    @pulumi.getter(name="workerSize")
    def worker_size(self) -> Optional[str]:
        """
        VM size of the worker pool instances.
        """
        return pulumi.get(self, "worker_size")

    @property
    @pulumi.getter(name="workerSizeId")
    def worker_size_id(self) -> Optional[int]:
        """
        Worker size ID for referencing this worker pool.
        """
        return pulumi.get(self, "worker_size_id")


