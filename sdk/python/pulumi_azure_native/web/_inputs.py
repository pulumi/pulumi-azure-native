# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AllowedAudiencesValidationArgs',
    'AllowedAudiencesValidationArgsDict',
    'AllowedPrincipalsArgs',
    'AllowedPrincipalsArgsDict',
    'ApiConnectionDefinitionPropertiesArgs',
    'ApiConnectionDefinitionPropertiesArgsDict',
    'ApiConnectionTestLinkArgs',
    'ApiConnectionTestLinkArgsDict',
    'ApiDefinitionInfoArgs',
    'ApiDefinitionInfoArgsDict',
    'ApiManagementConfigArgs',
    'ApiManagementConfigArgsDict',
    'ApiOAuthSettingsParameterArgs',
    'ApiOAuthSettingsParameterArgsDict',
    'ApiOAuthSettingsArgs',
    'ApiOAuthSettingsArgsDict',
    'ApiReferenceArgs',
    'ApiReferenceArgsDict',
    'ApiResourceBackendServiceArgs',
    'ApiResourceBackendServiceArgsDict',
    'ApiResourceDefinitionsArgs',
    'ApiResourceDefinitionsArgsDict',
    'AppLogsConfigurationArgs',
    'AppLogsConfigurationArgsDict',
    'AppRegistrationArgs',
    'AppRegistrationArgsDict',
    'AppleRegistrationArgs',
    'AppleRegistrationArgsDict',
    'AppleArgs',
    'AppleArgsDict',
    'ApplicationLogsConfigArgs',
    'ApplicationLogsConfigArgsDict',
    'ArcConfigurationArgs',
    'ArcConfigurationArgsDict',
    'AseV3NetworkingConfigurationArgs',
    'AseV3NetworkingConfigurationArgsDict',
    'AuthPlatformArgs',
    'AuthPlatformArgsDict',
    'AutoHealActionsArgs',
    'AutoHealActionsArgsDict',
    'AutoHealCustomActionArgs',
    'AutoHealCustomActionArgsDict',
    'AutoHealRulesArgs',
    'AutoHealRulesArgsDict',
    'AutoHealTriggersArgs',
    'AutoHealTriggersArgsDict',
    'AzureActiveDirectoryLoginArgs',
    'AzureActiveDirectoryLoginArgsDict',
    'AzureActiveDirectoryRegistrationArgs',
    'AzureActiveDirectoryRegistrationArgsDict',
    'AzureActiveDirectoryValidationArgs',
    'AzureActiveDirectoryValidationArgsDict',
    'AzureActiveDirectoryArgs',
    'AzureActiveDirectoryArgsDict',
    'AzureBlobStorageApplicationLogsConfigArgs',
    'AzureBlobStorageApplicationLogsConfigArgsDict',
    'AzureBlobStorageHttpLogsConfigArgs',
    'AzureBlobStorageHttpLogsConfigArgsDict',
    'AzureStaticWebAppsRegistrationArgs',
    'AzureStaticWebAppsRegistrationArgsDict',
    'AzureStaticWebAppsArgs',
    'AzureStaticWebAppsArgsDict',
    'AzureStorageInfoValueArgs',
    'AzureStorageInfoValueArgsDict',
    'AzureTableStorageApplicationLogsConfigArgs',
    'AzureTableStorageApplicationLogsConfigArgsDict',
    'BackupSchedule',
    'BackupScheduleDict',
    'BackupScheduleArgs',
    'BackupScheduleArgsDict',
    'BlobStorageTokenStoreArgs',
    'BlobStorageTokenStoreArgsDict',
    'CapabilityArgs',
    'CapabilityArgsDict',
    'ClientRegistrationArgs',
    'ClientRegistrationArgsDict',
    'CloningInfoArgs',
    'CloningInfoArgsDict',
    'ConnStringInfoArgs',
    'ConnStringInfoArgsDict',
    'ConnStringValueTypePairArgs',
    'ConnStringValueTypePairArgsDict',
    'ConnectionErrorArgs',
    'ConnectionErrorArgsDict',
    'ConnectionGatewayDefinitionPropertiesArgs',
    'ConnectionGatewayDefinitionPropertiesArgsDict',
    'ConnectionGatewayReferenceArgs',
    'ConnectionGatewayReferenceArgsDict',
    'ConnectionParameterArgs',
    'ConnectionParameterArgsDict',
    'ConnectionStatusDefinitionArgs',
    'ConnectionStatusDefinitionArgsDict',
    'ConsentLinkParameterDefinition',
    'ConsentLinkParameterDefinitionDict',
    'ContainerAppsConfigurationArgs',
    'ContainerAppsConfigurationArgsDict',
    'CookieExpirationArgs',
    'CookieExpirationArgsDict',
    'CorsSettingsArgs',
    'CorsSettingsArgsDict',
    'CustomApiPropertiesDefinitionArgs',
    'CustomApiPropertiesDefinitionArgsDict',
    'CustomDnsSuffixConfigurationArgs',
    'CustomDnsSuffixConfigurationArgsDict',
    'CustomOpenIdConnectProviderArgs',
    'CustomOpenIdConnectProviderArgsDict',
    'DaprConfigArgs',
    'DaprConfigArgsDict',
    'DatabaseBackupSetting',
    'DatabaseBackupSettingDict',
    'DatabaseBackupSettingArgs',
    'DatabaseBackupSettingArgsDict',
    'DefaultAuthorizationPolicyArgs',
    'DefaultAuthorizationPolicyArgsDict',
    'EnabledConfigArgs',
    'EnabledConfigArgsDict',
    'EnvironmentVariableArgs',
    'EnvironmentVariableArgsDict',
    'ExperimentsArgs',
    'ExperimentsArgsDict',
    'ExtendedLocationArgs',
    'ExtendedLocationArgsDict',
    'FacebookArgs',
    'FacebookArgsDict',
    'FileSystemApplicationLogsConfigArgs',
    'FileSystemApplicationLogsConfigArgsDict',
    'FileSystemHttpLogsConfigArgs',
    'FileSystemHttpLogsConfigArgsDict',
    'FileSystemTokenStoreArgs',
    'FileSystemTokenStoreArgsDict',
    'ForwardProxyArgs',
    'ForwardProxyArgsDict',
    'FrontEndConfigurationArgs',
    'FrontEndConfigurationArgsDict',
    'FunctionAppConfigArgs',
    'FunctionAppConfigArgsDict',
    'FunctionsAlwaysReadyConfigArgs',
    'FunctionsAlwaysReadyConfigArgsDict',
    'FunctionsDeploymentAuthenticationArgs',
    'FunctionsDeploymentAuthenticationArgsDict',
    'FunctionsDeploymentStorageArgs',
    'FunctionsDeploymentStorageArgsDict',
    'FunctionsDeploymentArgs',
    'FunctionsDeploymentArgsDict',
    'FunctionsRuntimeArgs',
    'FunctionsRuntimeArgsDict',
    'FunctionsScaleAndConcurrencyHttpArgs',
    'FunctionsScaleAndConcurrencyHttpArgsDict',
    'FunctionsScaleAndConcurrencyTriggersArgs',
    'FunctionsScaleAndConcurrencyTriggersArgsDict',
    'FunctionsScaleAndConcurrencyArgs',
    'FunctionsScaleAndConcurrencyArgsDict',
    'GitHubActionCodeConfigurationArgs',
    'GitHubActionCodeConfigurationArgsDict',
    'GitHubActionConfigurationArgs',
    'GitHubActionConfigurationArgsDict',
    'GitHubActionContainerConfigurationArgs',
    'GitHubActionContainerConfigurationArgsDict',
    'GitHubArgs',
    'GitHubArgsDict',
    'GlobalValidationArgs',
    'GlobalValidationArgsDict',
    'GoogleArgs',
    'GoogleArgsDict',
    'HandlerMappingArgs',
    'HandlerMappingArgsDict',
    'HostNameSslStateArgs',
    'HostNameSslStateArgsDict',
    'HostingEnvironmentProfileArgs',
    'HostingEnvironmentProfileArgsDict',
    'HttpLogsConfigArgs',
    'HttpLogsConfigArgsDict',
    'HttpSettingsRoutesArgs',
    'HttpSettingsRoutesArgsDict',
    'HttpSettingsArgs',
    'HttpSettingsArgsDict',
    'IdentityProvidersArgs',
    'IdentityProvidersArgsDict',
    'IpSecurityRestrictionArgs',
    'IpSecurityRestrictionArgsDict',
    'JwtClaimChecksArgs',
    'JwtClaimChecksArgsDict',
    'KubeEnvironmentProfileArgs',
    'KubeEnvironmentProfileArgsDict',
    'LegacyMicrosoftAccountArgs',
    'LegacyMicrosoftAccountArgsDict',
    'LogAnalyticsConfigurationArgs',
    'LogAnalyticsConfigurationArgsDict',
    'LoginRoutesArgs',
    'LoginRoutesArgsDict',
    'LoginScopesArgs',
    'LoginScopesArgsDict',
    'LoginArgs',
    'LoginArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'NameValuePairArgs',
    'NameValuePairArgsDict',
    'NonceArgs',
    'NonceArgsDict',
    'OpenIdConnectClientCredentialArgs',
    'OpenIdConnectClientCredentialArgsDict',
    'OpenIdConnectConfigArgs',
    'OpenIdConnectConfigArgsDict',
    'OpenIdConnectLoginArgs',
    'OpenIdConnectLoginArgsDict',
    'OpenIdConnectRegistrationArgs',
    'OpenIdConnectRegistrationArgsDict',
    'PrivateLinkConnectionStateArgs',
    'PrivateLinkConnectionStateArgsDict',
    'PushSettingsArgs',
    'PushSettingsArgsDict',
    'RampUpRuleArgs',
    'RampUpRuleArgsDict',
    'RequestsBasedTriggerArgs',
    'RequestsBasedTriggerArgsDict',
    'ResourceConfigArgs',
    'ResourceConfigArgsDict',
    'SiteConfigArgs',
    'SiteConfigArgsDict',
    'SiteDnsConfigArgs',
    'SiteDnsConfigArgsDict',
    'SiteLimitsArgs',
    'SiteLimitsArgsDict',
    'SkuCapacityArgs',
    'SkuCapacityArgsDict',
    'SkuDescriptionArgs',
    'SkuDescriptionArgsDict',
    'SlowRequestsBasedTriggerArgs',
    'SlowRequestsBasedTriggerArgsDict',
    'StaticSiteBuildPropertiesArgs',
    'StaticSiteBuildPropertiesArgsDict',
    'StaticSiteTemplateOptionsArgs',
    'StaticSiteTemplateOptionsArgsDict',
    'StatusCodesBasedTriggerArgs',
    'StatusCodesBasedTriggerArgsDict',
    'StatusCodesRangeBasedTriggerArgs',
    'StatusCodesRangeBasedTriggerArgsDict',
    'TokenStoreArgs',
    'TokenStoreArgsDict',
    'TwitterRegistrationArgs',
    'TwitterRegistrationArgsDict',
    'TwitterArgs',
    'TwitterArgsDict',
    'VirtualApplicationArgs',
    'VirtualApplicationArgsDict',
    'VirtualDirectoryArgs',
    'VirtualDirectoryArgsDict',
    'VirtualNetworkProfileArgs',
    'VirtualNetworkProfileArgsDict',
    'VolumeMountArgs',
    'VolumeMountArgsDict',
    'WsdlDefinitionArgs',
    'WsdlDefinitionArgsDict',
    'WsdlService',
    'WsdlServiceDict',
    'WsdlServiceArgs',
    'WsdlServiceArgsDict',
]

MYPY = False

if not MYPY:
    class AllowedAudiencesValidationArgsDict(TypedDict):
        """
        The configuration settings of the Allowed Audiences validation flow.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
elif False:
    AllowedAudiencesValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AllowedAudiencesValidationArgs:
    def __init__(__self__, *,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The configuration settings of the Allowed Audiences validation flow.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_audiences: The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_audiences", value)


if not MYPY:
    class AllowedPrincipalsArgsDict(TypedDict):
        """
        The configuration settings of the Azure Active Directory allowed principals.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of the allowed groups.
        """
        identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of the allowed identities.
        """
elif False:
    AllowedPrincipalsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AllowedPrincipalsArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The configuration settings of the Azure Active Directory allowed principals.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] groups: The list of the allowed groups.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] identities: The list of the allowed identities.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if identities is not None:
            pulumi.set(__self__, "identities", identities)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of the allowed groups.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of the allowed identities.
        """
        return pulumi.get(self, "identities")

    @identities.setter
    def identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "identities", value)


if not MYPY:
    class ApiConnectionDefinitionPropertiesArgsDict(TypedDict):
        api: NotRequired[pulumi.Input['ApiReferenceArgsDict']]
        changed_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Timestamp of last connection change
        """
        created_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Timestamp of the connection creation
        """
        custom_parameter_values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Dictionary of custom parameter values
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Display name
        """
        non_secret_parameter_values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Dictionary of nonsecret parameter values
        """
        parameter_values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Dictionary of parameter values
        """
        statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectionStatusDefinitionArgsDict']]]]
        """
        Status of the connection
        """
        test_links: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiConnectionTestLinkArgsDict']]]]
        """
        Links to test the API connection
        """
elif False:
    ApiConnectionDefinitionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiConnectionDefinitionPropertiesArgs:
    def __init__(__self__, *,
                 api: Optional[pulumi.Input['ApiReferenceArgs']] = None,
                 changed_time: Optional[pulumi.Input[builtins.str]] = None,
                 created_time: Optional[pulumi.Input[builtins.str]] = None,
                 custom_parameter_values: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 non_secret_parameter_values: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 parameter_values: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 statuses: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionStatusDefinitionArgs']]]] = None,
                 test_links: Optional[pulumi.Input[Sequence[pulumi.Input['ApiConnectionTestLinkArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] changed_time: Timestamp of last connection change
        :param pulumi.Input[builtins.str] created_time: Timestamp of the connection creation
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] custom_parameter_values: Dictionary of custom parameter values
        :param pulumi.Input[builtins.str] display_name: Display name
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] non_secret_parameter_values: Dictionary of nonsecret parameter values
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] parameter_values: Dictionary of parameter values
        :param pulumi.Input[Sequence[pulumi.Input['ConnectionStatusDefinitionArgs']]] statuses: Status of the connection
        :param pulumi.Input[Sequence[pulumi.Input['ApiConnectionTestLinkArgs']]] test_links: Links to test the API connection
        """
        if api is not None:
            pulumi.set(__self__, "api", api)
        if changed_time is not None:
            pulumi.set(__self__, "changed_time", changed_time)
        if created_time is not None:
            pulumi.set(__self__, "created_time", created_time)
        if custom_parameter_values is not None:
            pulumi.set(__self__, "custom_parameter_values", custom_parameter_values)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if non_secret_parameter_values is not None:
            pulumi.set(__self__, "non_secret_parameter_values", non_secret_parameter_values)
        if parameter_values is not None:
            pulumi.set(__self__, "parameter_values", parameter_values)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)
        if test_links is not None:
            pulumi.set(__self__, "test_links", test_links)

    @property
    @pulumi.getter
    def api(self) -> Optional[pulumi.Input['ApiReferenceArgs']]:
        return pulumi.get(self, "api")

    @api.setter
    def api(self, value: Optional[pulumi.Input['ApiReferenceArgs']]):
        pulumi.set(self, "api", value)

    @property
    @pulumi.getter(name="changedTime")
    def changed_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Timestamp of last connection change
        """
        return pulumi.get(self, "changed_time")

    @changed_time.setter
    def changed_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "changed_time", value)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Timestamp of the connection creation
        """
        return pulumi.get(self, "created_time")

    @created_time.setter
    def created_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "created_time", value)

    @property
    @pulumi.getter(name="customParameterValues")
    def custom_parameter_values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Dictionary of custom parameter values
        """
        return pulumi.get(self, "custom_parameter_values")

    @custom_parameter_values.setter
    def custom_parameter_values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "custom_parameter_values", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="nonSecretParameterValues")
    def non_secret_parameter_values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Dictionary of nonsecret parameter values
        """
        return pulumi.get(self, "non_secret_parameter_values")

    @non_secret_parameter_values.setter
    def non_secret_parameter_values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "non_secret_parameter_values", value)

    @property
    @pulumi.getter(name="parameterValues")
    def parameter_values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Dictionary of parameter values
        """
        return pulumi.get(self, "parameter_values")

    @parameter_values.setter
    def parameter_values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "parameter_values", value)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionStatusDefinitionArgs']]]]:
        """
        Status of the connection
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionStatusDefinitionArgs']]]]):
        pulumi.set(self, "statuses", value)

    @property
    @pulumi.getter(name="testLinks")
    def test_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiConnectionTestLinkArgs']]]]:
        """
        Links to test the API connection
        """
        return pulumi.get(self, "test_links")

    @test_links.setter
    def test_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiConnectionTestLinkArgs']]]]):
        pulumi.set(self, "test_links", value)


if not MYPY:
    class ApiConnectionTestLinkArgsDict(TypedDict):
        """
        API connection properties
        """
        method: NotRequired[pulumi.Input[builtins.str]]
        """
        HTTP Method
        """
        request_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        Test link request URI
        """
elif False:
    ApiConnectionTestLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiConnectionTestLinkArgs:
    def __init__(__self__, *,
                 method: Optional[pulumi.Input[builtins.str]] = None,
                 request_uri: Optional[pulumi.Input[builtins.str]] = None):
        """
        API connection properties
        :param pulumi.Input[builtins.str] method: HTTP Method
        :param pulumi.Input[builtins.str] request_uri: Test link request URI
        """
        if method is not None:
            pulumi.set(__self__, "method", method)
        if request_uri is not None:
            pulumi.set(__self__, "request_uri", request_uri)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        HTTP Method
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter(name="requestUri")
    def request_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Test link request URI
        """
        return pulumi.get(self, "request_uri")

    @request_uri.setter
    def request_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "request_uri", value)


if not MYPY:
    class ApiDefinitionInfoArgsDict(TypedDict):
        """
        Information about the formal API definition for the app.
        """
        url: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL of the API definition.
        """
elif False:
    ApiDefinitionInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiDefinitionInfoArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[builtins.str]] = None):
        """
        Information about the formal API definition for the app.
        :param pulumi.Input[builtins.str] url: The URL of the API definition.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL of the API definition.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ApiManagementConfigArgsDict(TypedDict):
        """
        Azure API management (APIM) configuration linked to the app.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        APIM-Api Identifier.
        """
elif False:
    ApiManagementConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiManagementConfigArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Azure API management (APIM) configuration linked to the app.
        :param pulumi.Input[builtins.str] id: APIM-Api Identifier.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        APIM-Api Identifier.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ApiOAuthSettingsParameterArgsDict(TypedDict):
        """
        OAuth settings for the API
        """
        options: NotRequired[Any]
        """
        Options available to this parameter
        """
        ui_definition: NotRequired[Any]
        """
        UI definitions per culture as caller can specify the culture
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Value of the setting
        """
elif False:
    ApiOAuthSettingsParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiOAuthSettingsParameterArgs:
    def __init__(__self__, *,
                 options: Optional[Any] = None,
                 ui_definition: Optional[Any] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        OAuth settings for the API
        :param Any options: Options available to this parameter
        :param Any ui_definition: UI definitions per culture as caller can specify the culture
        :param pulumi.Input[builtins.str] value: Value of the setting
        """
        if options is not None:
            pulumi.set(__self__, "options", options)
        if ui_definition is not None:
            pulumi.set(__self__, "ui_definition", ui_definition)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[Any]:
        """
        Options available to this parameter
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[Any]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter(name="uiDefinition")
    def ui_definition(self) -> Optional[Any]:
        """
        UI definitions per culture as caller can specify the culture
        """
        return pulumi.get(self, "ui_definition")

    @ui_definition.setter
    def ui_definition(self, value: Optional[Any]):
        pulumi.set(self, "ui_definition", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Value of the setting
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApiOAuthSettingsArgsDict(TypedDict):
        """
        OAuth settings for the connection provider
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource provider client id
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Client Secret needed for OAuth
        """
        custom_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['ApiOAuthSettingsParameterArgsDict']]]]
        """
        OAuth parameters key is the name of parameter
        """
        identity_provider: NotRequired[pulumi.Input[builtins.str]]
        """
        Identity provider
        """
        properties: NotRequired[Any]
        """
        Read only properties for this oauth setting.
        """
        redirect_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Url
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        OAuth scopes
        """
elif False:
    ApiOAuthSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiOAuthSettingsArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 custom_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ApiOAuthSettingsParameterArgs']]]] = None,
                 identity_provider: Optional[pulumi.Input[builtins.str]] = None,
                 properties: Optional[Any] = None,
                 redirect_url: Optional[pulumi.Input[builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        OAuth settings for the connection provider
        :param pulumi.Input[builtins.str] client_id: Resource provider client id
        :param pulumi.Input[builtins.str] client_secret: Client Secret needed for OAuth
        :param pulumi.Input[Mapping[str, pulumi.Input['ApiOAuthSettingsParameterArgs']]] custom_parameters: OAuth parameters key is the name of parameter
        :param pulumi.Input[builtins.str] identity_provider: Identity provider
        :param Any properties: Read only properties for this oauth setting.
        :param pulumi.Input[builtins.str] redirect_url: Url
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: OAuth scopes
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if custom_parameters is not None:
            pulumi.set(__self__, "custom_parameters", custom_parameters)
        if identity_provider is not None:
            pulumi.set(__self__, "identity_provider", identity_provider)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource provider client id
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Client Secret needed for OAuth
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="customParameters")
    def custom_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ApiOAuthSettingsParameterArgs']]]]:
        """
        OAuth parameters key is the name of parameter
        """
        return pulumi.get(self, "custom_parameters")

    @custom_parameters.setter
    def custom_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ApiOAuthSettingsParameterArgs']]]]):
        pulumi.set(self, "custom_parameters", value)

    @property
    @pulumi.getter(name="identityProvider")
    def identity_provider(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identity provider
        """
        return pulumi.get(self, "identity_provider")

    @identity_provider.setter
    def identity_provider(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "identity_provider", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[Any]:
        """
        Read only properties for this oauth setting.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[Any]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Url
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        OAuth scopes
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class ApiReferenceArgsDict(TypedDict):
        brand_color: NotRequired[pulumi.Input[builtins.str]]
        """
        Brand color
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The custom API description
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The display name
        """
        icon_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        The icon URI
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource reference id
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the API
        """
        swagger: NotRequired[Any]
        """
        The JSON representation of the swagger
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource reference type
        """
elif False:
    ApiReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiReferenceArgs:
    def __init__(__self__, *,
                 brand_color: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 icon_uri: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 swagger: Optional[Any] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] brand_color: Brand color
        :param pulumi.Input[builtins.str] description: The custom API description
        :param pulumi.Input[builtins.str] display_name: The display name
        :param pulumi.Input[builtins.str] icon_uri: The icon URI
        :param pulumi.Input[builtins.str] id: Resource reference id
        :param pulumi.Input[builtins.str] name: The name of the API
        :param Any swagger: The JSON representation of the swagger
        :param pulumi.Input[builtins.str] type: Resource reference type
        """
        if brand_color is not None:
            pulumi.set(__self__, "brand_color", brand_color)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if icon_uri is not None:
            pulumi.set(__self__, "icon_uri", icon_uri)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if swagger is not None:
            pulumi.set(__self__, "swagger", swagger)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="brandColor")
    def brand_color(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Brand color
        """
        return pulumi.get(self, "brand_color")

    @brand_color.setter
    def brand_color(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "brand_color", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The custom API description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="iconUri")
    def icon_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The icon URI
        """
        return pulumi.get(self, "icon_uri")

    @icon_uri.setter
    def icon_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "icon_uri", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource reference id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the API
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def swagger(self) -> Optional[Any]:
        """
        The JSON representation of the swagger
        """
        return pulumi.get(self, "swagger")

    @swagger.setter
    def swagger(self, value: Optional[Any]):
        pulumi.set(self, "swagger", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource reference type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApiResourceBackendServiceArgsDict(TypedDict):
        """
        The API backend service
        """
        service_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The service URL
        """
elif False:
    ApiResourceBackendServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiResourceBackendServiceArgs:
    def __init__(__self__, *,
                 service_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        The API backend service
        :param pulumi.Input[builtins.str] service_url: The service URL
        """
        if service_url is not None:
            pulumi.set(__self__, "service_url", service_url)

    @property
    @pulumi.getter(name="serviceUrl")
    def service_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The service URL
        """
        return pulumi.get(self, "service_url")

    @service_url.setter
    def service_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_url", value)


if not MYPY:
    class ApiResourceDefinitionsArgsDict(TypedDict):
        """
        API Definitions
        """
        modified_swagger_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The modified swagger URL
        """
        original_swagger_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The original swagger URL
        """
elif False:
    ApiResourceDefinitionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiResourceDefinitionsArgs:
    def __init__(__self__, *,
                 modified_swagger_url: Optional[pulumi.Input[builtins.str]] = None,
                 original_swagger_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        API Definitions
        :param pulumi.Input[builtins.str] modified_swagger_url: The modified swagger URL
        :param pulumi.Input[builtins.str] original_swagger_url: The original swagger URL
        """
        if modified_swagger_url is not None:
            pulumi.set(__self__, "modified_swagger_url", modified_swagger_url)
        if original_swagger_url is not None:
            pulumi.set(__self__, "original_swagger_url", original_swagger_url)

    @property
    @pulumi.getter(name="modifiedSwaggerUrl")
    def modified_swagger_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The modified swagger URL
        """
        return pulumi.get(self, "modified_swagger_url")

    @modified_swagger_url.setter
    def modified_swagger_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "modified_swagger_url", value)

    @property
    @pulumi.getter(name="originalSwaggerUrl")
    def original_swagger_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The original swagger URL
        """
        return pulumi.get(self, "original_swagger_url")

    @original_swagger_url.setter
    def original_swagger_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "original_swagger_url", value)


if not MYPY:
    class AppLogsConfigurationArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[builtins.str]]
        log_analytics_configuration: NotRequired[pulumi.Input['LogAnalyticsConfigurationArgsDict']]
elif False:
    AppLogsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLogsConfigurationArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[builtins.str]] = None,
                 log_analytics_configuration: Optional[pulumi.Input['LogAnalyticsConfigurationArgs']] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if log_analytics_configuration is not None:
            pulumi.set(__self__, "log_analytics_configuration", log_analytics_configuration)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="logAnalyticsConfiguration")
    def log_analytics_configuration(self) -> Optional[pulumi.Input['LogAnalyticsConfigurationArgs']]:
        return pulumi.get(self, "log_analytics_configuration")

    @log_analytics_configuration.setter
    def log_analytics_configuration(self, value: Optional[pulumi.Input['LogAnalyticsConfigurationArgs']]):
        pulumi.set(self, "log_analytics_configuration", value)


if not MYPY:
    class AppRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the app registration for providers that have app ids and app secrets
        """
        app_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The App ID of the app used for login.
        """
        app_secret_setting_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The app setting name that contains the app secret.
        """
elif False:
    AppRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppRegistrationArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[builtins.str]] = None,
                 app_secret_setting_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the app registration for providers that have app ids and app secrets
        :param pulumi.Input[builtins.str] app_id: The App ID of the app used for login.
        :param pulumi.Input[builtins.str] app_secret_setting_name: The app setting name that contains the app secret.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The App ID of the app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The app setting name that contains the app secret.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "app_secret_setting_name", value)


if not MYPY:
    class AppleRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the registration for the Apple provider
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Client ID of the app used for login.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The app setting name that contains the client secret.
        """
elif False:
    AppleRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppleRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the registration for the Apple provider
        :param pulumi.Input[builtins.str] client_id: The Client ID of the app used for login.
        :param pulumi.Input[builtins.str] client_secret_setting_name: The app setting name that contains the client secret.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The app setting name that contains the client secret.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_setting_name", value)


if not MYPY:
    class AppleArgsDict(TypedDict):
        """
        The configuration settings of the Apple provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        login: NotRequired[pulumi.Input['LoginScopesArgsDict']]
        """
        The configuration settings of the login flow.
        """
        registration: NotRequired[pulumi.Input['AppleRegistrationArgsDict']]
        """
        The configuration settings of the Apple registration.
        """
elif False:
    AppleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['AppleRegistrationArgs']] = None):
        """
        The configuration settings of the Apple provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['LoginScopesArgs'] login: The configuration settings of the login flow.
        :param pulumi.Input['AppleRegistrationArgs'] registration: The configuration settings of the Apple registration.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AppleRegistrationArgs']]:
        """
        The configuration settings of the Apple registration.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AppleRegistrationArgs']]):
        pulumi.set(self, "registration", value)


if not MYPY:
    class ApplicationLogsConfigArgsDict(TypedDict):
        """
        Application logs configuration.
        """
        azure_blob_storage: NotRequired[pulumi.Input['AzureBlobStorageApplicationLogsConfigArgsDict']]
        """
        Application logs to blob storage configuration.
        """
        azure_table_storage: NotRequired[pulumi.Input['AzureTableStorageApplicationLogsConfigArgsDict']]
        """
        Application logs to azure table storage configuration.
        """
        file_system: NotRequired[pulumi.Input['FileSystemApplicationLogsConfigArgsDict']]
        """
        Application logs to file system configuration.
        """
elif False:
    ApplicationLogsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationLogsConfigArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['AzureBlobStorageApplicationLogsConfigArgs']] = None,
                 azure_table_storage: Optional[pulumi.Input['AzureTableStorageApplicationLogsConfigArgs']] = None,
                 file_system: Optional[pulumi.Input['FileSystemApplicationLogsConfigArgs']] = None):
        """
        Application logs configuration.
        :param pulumi.Input['AzureBlobStorageApplicationLogsConfigArgs'] azure_blob_storage: Application logs to blob storage configuration.
        :param pulumi.Input['AzureTableStorageApplicationLogsConfigArgs'] azure_table_storage: Application logs to azure table storage configuration.
        :param pulumi.Input['FileSystemApplicationLogsConfigArgs'] file_system: Application logs to file system configuration.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if azure_table_storage is not None:
            pulumi.set(__self__, "azure_table_storage", azure_table_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['AzureBlobStorageApplicationLogsConfigArgs']]:
        """
        Application logs to blob storage configuration.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['AzureBlobStorageApplicationLogsConfigArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter(name="azureTableStorage")
    def azure_table_storage(self) -> Optional[pulumi.Input['AzureTableStorageApplicationLogsConfigArgs']]:
        """
        Application logs to azure table storage configuration.
        """
        return pulumi.get(self, "azure_table_storage")

    @azure_table_storage.setter
    def azure_table_storage(self, value: Optional[pulumi.Input['AzureTableStorageApplicationLogsConfigArgs']]):
        pulumi.set(self, "azure_table_storage", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input['FileSystemApplicationLogsConfigArgs']]:
        """
        Application logs to file system configuration.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input['FileSystemApplicationLogsConfigArgs']]):
        pulumi.set(self, "file_system", value)


if not MYPY:
    class ArcConfigurationArgsDict(TypedDict):
        artifact_storage_access_mode: NotRequired[pulumi.Input[builtins.str]]
        artifact_storage_class_name: NotRequired[pulumi.Input[builtins.str]]
        artifact_storage_mount_path: NotRequired[pulumi.Input[builtins.str]]
        artifact_storage_node_name: NotRequired[pulumi.Input[builtins.str]]
        artifacts_storage_type: NotRequired[pulumi.Input['StorageType']]
        front_end_service_configuration: NotRequired[pulumi.Input['FrontEndConfigurationArgsDict']]
        kube_config: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ArcConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArcConfigurationArgs:
    def __init__(__self__, *,
                 artifact_storage_access_mode: Optional[pulumi.Input[builtins.str]] = None,
                 artifact_storage_class_name: Optional[pulumi.Input[builtins.str]] = None,
                 artifact_storage_mount_path: Optional[pulumi.Input[builtins.str]] = None,
                 artifact_storage_node_name: Optional[pulumi.Input[builtins.str]] = None,
                 artifacts_storage_type: Optional[pulumi.Input['StorageType']] = None,
                 front_end_service_configuration: Optional[pulumi.Input['FrontEndConfigurationArgs']] = None,
                 kube_config: Optional[pulumi.Input[builtins.str]] = None):
        if artifact_storage_access_mode is not None:
            pulumi.set(__self__, "artifact_storage_access_mode", artifact_storage_access_mode)
        if artifact_storage_class_name is not None:
            pulumi.set(__self__, "artifact_storage_class_name", artifact_storage_class_name)
        if artifact_storage_mount_path is not None:
            pulumi.set(__self__, "artifact_storage_mount_path", artifact_storage_mount_path)
        if artifact_storage_node_name is not None:
            pulumi.set(__self__, "artifact_storage_node_name", artifact_storage_node_name)
        if artifacts_storage_type is not None:
            pulumi.set(__self__, "artifacts_storage_type", artifacts_storage_type)
        if front_end_service_configuration is not None:
            pulumi.set(__self__, "front_end_service_configuration", front_end_service_configuration)
        if kube_config is not None:
            pulumi.set(__self__, "kube_config", kube_config)

    @property
    @pulumi.getter(name="artifactStorageAccessMode")
    def artifact_storage_access_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "artifact_storage_access_mode")

    @artifact_storage_access_mode.setter
    def artifact_storage_access_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "artifact_storage_access_mode", value)

    @property
    @pulumi.getter(name="artifactStorageClassName")
    def artifact_storage_class_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "artifact_storage_class_name")

    @artifact_storage_class_name.setter
    def artifact_storage_class_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "artifact_storage_class_name", value)

    @property
    @pulumi.getter(name="artifactStorageMountPath")
    def artifact_storage_mount_path(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "artifact_storage_mount_path")

    @artifact_storage_mount_path.setter
    def artifact_storage_mount_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "artifact_storage_mount_path", value)

    @property
    @pulumi.getter(name="artifactStorageNodeName")
    def artifact_storage_node_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "artifact_storage_node_name")

    @artifact_storage_node_name.setter
    def artifact_storage_node_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "artifact_storage_node_name", value)

    @property
    @pulumi.getter(name="artifactsStorageType")
    def artifacts_storage_type(self) -> Optional[pulumi.Input['StorageType']]:
        return pulumi.get(self, "artifacts_storage_type")

    @artifacts_storage_type.setter
    def artifacts_storage_type(self, value: Optional[pulumi.Input['StorageType']]):
        pulumi.set(self, "artifacts_storage_type", value)

    @property
    @pulumi.getter(name="frontEndServiceConfiguration")
    def front_end_service_configuration(self) -> Optional[pulumi.Input['FrontEndConfigurationArgs']]:
        return pulumi.get(self, "front_end_service_configuration")

    @front_end_service_configuration.setter
    def front_end_service_configuration(self, value: Optional[pulumi.Input['FrontEndConfigurationArgs']]):
        pulumi.set(self, "front_end_service_configuration", value)

    @property
    @pulumi.getter(name="kubeConfig")
    def kube_config(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "kube_config")

    @kube_config.setter
    def kube_config(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kube_config", value)


if not MYPY:
    class AseV3NetworkingConfigurationArgsDict(TypedDict):
        """
        Full view of networking configuration for an ASE.
        """
        allow_new_private_endpoint_connections: NotRequired[pulumi.Input[builtins.bool]]
        """
        Property to enable and disable new private endpoint connection creation on ASE
        """
        ftp_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Property to enable and disable FTP on ASEV3
        """
        inbound_ip_address_override: NotRequired[pulumi.Input[builtins.str]]
        """
        Customer provided Inbound IP Address. Only able to be set on Ase create.
        """
        kind: NotRequired[pulumi.Input[builtins.str]]
        """
        Kind of resource.
        """
        remote_debug_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Property to enable and disable Remote Debug on ASEV3
        """
elif False:
    AseV3NetworkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AseV3NetworkingConfigurationArgs:
    def __init__(__self__, *,
                 allow_new_private_endpoint_connections: Optional[pulumi.Input[builtins.bool]] = None,
                 ftp_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 inbound_ip_address_override: Optional[pulumi.Input[builtins.str]] = None,
                 kind: Optional[pulumi.Input[builtins.str]] = None,
                 remote_debug_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Full view of networking configuration for an ASE.
        :param pulumi.Input[builtins.bool] allow_new_private_endpoint_connections: Property to enable and disable new private endpoint connection creation on ASE
        :param pulumi.Input[builtins.bool] ftp_enabled: Property to enable and disable FTP on ASEV3
        :param pulumi.Input[builtins.str] inbound_ip_address_override: Customer provided Inbound IP Address. Only able to be set on Ase create.
        :param pulumi.Input[builtins.str] kind: Kind of resource.
        :param pulumi.Input[builtins.bool] remote_debug_enabled: Property to enable and disable Remote Debug on ASEV3
        """
        if allow_new_private_endpoint_connections is not None:
            pulumi.set(__self__, "allow_new_private_endpoint_connections", allow_new_private_endpoint_connections)
        if ftp_enabled is not None:
            pulumi.set(__self__, "ftp_enabled", ftp_enabled)
        if inbound_ip_address_override is not None:
            pulumi.set(__self__, "inbound_ip_address_override", inbound_ip_address_override)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if remote_debug_enabled is not None:
            pulumi.set(__self__, "remote_debug_enabled", remote_debug_enabled)

    @property
    @pulumi.getter(name="allowNewPrivateEndpointConnections")
    def allow_new_private_endpoint_connections(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Property to enable and disable new private endpoint connection creation on ASE
        """
        return pulumi.get(self, "allow_new_private_endpoint_connections")

    @allow_new_private_endpoint_connections.setter
    def allow_new_private_endpoint_connections(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_new_private_endpoint_connections", value)

    @property
    @pulumi.getter(name="ftpEnabled")
    def ftp_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Property to enable and disable FTP on ASEV3
        """
        return pulumi.get(self, "ftp_enabled")

    @ftp_enabled.setter
    def ftp_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ftp_enabled", value)

    @property
    @pulumi.getter(name="inboundIpAddressOverride")
    def inbound_ip_address_override(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Customer provided Inbound IP Address. Only able to be set on Ase create.
        """
        return pulumi.get(self, "inbound_ip_address_override")

    @inbound_ip_address_override.setter
    def inbound_ip_address_override(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "inbound_ip_address_override", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="remoteDebugEnabled")
    def remote_debug_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Property to enable and disable Remote Debug on ASEV3
        """
        return pulumi.get(self, "remote_debug_enabled")

    @remote_debug_enabled.setter
    def remote_debug_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "remote_debug_enabled", value)


if not MYPY:
    class AuthPlatformArgsDict(TypedDict):
        """
        The configuration settings of the platform of App Service Authentication/Authorization.
        """
        config_file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        The path of the config file containing auth settings if they come from a file.
        If the path is relative, base will the site's root directory.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        """
        runtime_version: NotRequired[pulumi.Input[builtins.str]]
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
elif False:
    AuthPlatformArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthPlatformArgs:
    def __init__(__self__, *,
                 config_file_path: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 runtime_version: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the platform of App Service Authentication/Authorization.
        :param pulumi.Input[builtins.str] config_file_path: The path of the config file containing auth settings if they come from a file.
               If the path is relative, base will the site's root directory.
        :param pulumi.Input[builtins.bool] enabled: <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        :param pulumi.Input[builtins.str] runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
               The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
        if config_file_path is not None:
            pulumi.set(__self__, "config_file_path", config_file_path)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="configFilePath")
    def config_file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The path of the config file containing auth settings if they come from a file.
        If the path is relative, base will the site's root directory.
        """
        return pulumi.get(self, "config_file_path")

    @config_file_path.setter
    def config_file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "config_file_path", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "runtime_version", value)


if not MYPY:
    class AutoHealActionsArgsDict(TypedDict):
        """
        Actions which to take by the auto-heal module when a rule is triggered.
        """
        action_type: NotRequired[pulumi.Input['AutoHealActionType']]
        """
        Predefined action to be taken.
        """
        custom_action: NotRequired[pulumi.Input['AutoHealCustomActionArgsDict']]
        """
        Custom action to be taken.
        """
        min_process_execution_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Minimum time the process must execute
        before taking the action
        """
elif False:
    AutoHealActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoHealActionsArgs:
    def __init__(__self__, *,
                 action_type: Optional[pulumi.Input['AutoHealActionType']] = None,
                 custom_action: Optional[pulumi.Input['AutoHealCustomActionArgs']] = None,
                 min_process_execution_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        Actions which to take by the auto-heal module when a rule is triggered.
        :param pulumi.Input['AutoHealActionType'] action_type: Predefined action to be taken.
        :param pulumi.Input['AutoHealCustomActionArgs'] custom_action: Custom action to be taken.
        :param pulumi.Input[builtins.str] min_process_execution_time: Minimum time the process must execute
               before taking the action
        """
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if custom_action is not None:
            pulumi.set(__self__, "custom_action", custom_action)
        if min_process_execution_time is not None:
            pulumi.set(__self__, "min_process_execution_time", min_process_execution_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[pulumi.Input['AutoHealActionType']]:
        """
        Predefined action to be taken.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input['AutoHealActionType']]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="customAction")
    def custom_action(self) -> Optional[pulumi.Input['AutoHealCustomActionArgs']]:
        """
        Custom action to be taken.
        """
        return pulumi.get(self, "custom_action")

    @custom_action.setter
    def custom_action(self, value: Optional[pulumi.Input['AutoHealCustomActionArgs']]):
        pulumi.set(self, "custom_action", value)

    @property
    @pulumi.getter(name="minProcessExecutionTime")
    def min_process_execution_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Minimum time the process must execute
        before taking the action
        """
        return pulumi.get(self, "min_process_execution_time")

    @min_process_execution_time.setter
    def min_process_execution_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "min_process_execution_time", value)


if not MYPY:
    class AutoHealCustomActionArgsDict(TypedDict):
        """
        Custom action to be executed
        when an auto heal rule is triggered.
        """
        exe: NotRequired[pulumi.Input[builtins.str]]
        """
        Executable to be run.
        """
        parameters: NotRequired[pulumi.Input[builtins.str]]
        """
        Parameters for the executable.
        """
elif False:
    AutoHealCustomActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoHealCustomActionArgs:
    def __init__(__self__, *,
                 exe: Optional[pulumi.Input[builtins.str]] = None,
                 parameters: Optional[pulumi.Input[builtins.str]] = None):
        """
        Custom action to be executed
        when an auto heal rule is triggered.
        :param pulumi.Input[builtins.str] exe: Executable to be run.
        :param pulumi.Input[builtins.str] parameters: Parameters for the executable.
        """
        if exe is not None:
            pulumi.set(__self__, "exe", exe)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def exe(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Executable to be run.
        """
        return pulumi.get(self, "exe")

    @exe.setter
    def exe(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "exe", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Parameters for the executable.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class AutoHealRulesArgsDict(TypedDict):
        """
        Rules that can be defined for auto-heal.
        """
        actions: NotRequired[pulumi.Input['AutoHealActionsArgsDict']]
        """
        Actions to be executed when a rule is triggered.
        """
        triggers: NotRequired[pulumi.Input['AutoHealTriggersArgsDict']]
        """
        Conditions that describe when to execute the auto-heal actions.
        """
elif False:
    AutoHealRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoHealRulesArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input['AutoHealActionsArgs']] = None,
                 triggers: Optional[pulumi.Input['AutoHealTriggersArgs']] = None):
        """
        Rules that can be defined for auto-heal.
        :param pulumi.Input['AutoHealActionsArgs'] actions: Actions to be executed when a rule is triggered.
        :param pulumi.Input['AutoHealTriggersArgs'] triggers: Conditions that describe when to execute the auto-heal actions.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input['AutoHealActionsArgs']]:
        """
        Actions to be executed when a rule is triggered.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input['AutoHealActionsArgs']]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def triggers(self) -> Optional[pulumi.Input['AutoHealTriggersArgs']]:
        """
        Conditions that describe when to execute the auto-heal actions.
        """
        return pulumi.get(self, "triggers")

    @triggers.setter
    def triggers(self, value: Optional[pulumi.Input['AutoHealTriggersArgs']]):
        pulumi.set(self, "triggers", value)


if not MYPY:
    class AutoHealTriggersArgsDict(TypedDict):
        """
        Triggers for auto-heal.
        """
        private_bytes_in_kb: NotRequired[pulumi.Input[builtins.int]]
        """
        A rule based on private bytes.
        """
        requests: NotRequired[pulumi.Input['RequestsBasedTriggerArgsDict']]
        """
        A rule based on total requests.
        """
        slow_requests: NotRequired[pulumi.Input['SlowRequestsBasedTriggerArgsDict']]
        """
        A rule based on request execution time.
        """
        slow_requests_with_path: NotRequired[pulumi.Input[Sequence[pulumi.Input['SlowRequestsBasedTriggerArgsDict']]]]
        """
        A rule based on multiple Slow Requests Rule with path
        """
        status_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input['StatusCodesBasedTriggerArgsDict']]]]
        """
        A rule based on status codes.
        """
        status_codes_range: NotRequired[pulumi.Input[Sequence[pulumi.Input['StatusCodesRangeBasedTriggerArgsDict']]]]
        """
        A rule based on status codes ranges.
        """
elif False:
    AutoHealTriggersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoHealTriggersArgs:
    def __init__(__self__, *,
                 private_bytes_in_kb: Optional[pulumi.Input[builtins.int]] = None,
                 requests: Optional[pulumi.Input['RequestsBasedTriggerArgs']] = None,
                 slow_requests: Optional[pulumi.Input['SlowRequestsBasedTriggerArgs']] = None,
                 slow_requests_with_path: Optional[pulumi.Input[Sequence[pulumi.Input['SlowRequestsBasedTriggerArgs']]]] = None,
                 status_codes: Optional[pulumi.Input[Sequence[pulumi.Input['StatusCodesBasedTriggerArgs']]]] = None,
                 status_codes_range: Optional[pulumi.Input[Sequence[pulumi.Input['StatusCodesRangeBasedTriggerArgs']]]] = None):
        """
        Triggers for auto-heal.
        :param pulumi.Input[builtins.int] private_bytes_in_kb: A rule based on private bytes.
        :param pulumi.Input['RequestsBasedTriggerArgs'] requests: A rule based on total requests.
        :param pulumi.Input['SlowRequestsBasedTriggerArgs'] slow_requests: A rule based on request execution time.
        :param pulumi.Input[Sequence[pulumi.Input['SlowRequestsBasedTriggerArgs']]] slow_requests_with_path: A rule based on multiple Slow Requests Rule with path
        :param pulumi.Input[Sequence[pulumi.Input['StatusCodesBasedTriggerArgs']]] status_codes: A rule based on status codes.
        :param pulumi.Input[Sequence[pulumi.Input['StatusCodesRangeBasedTriggerArgs']]] status_codes_range: A rule based on status codes ranges.
        """
        if private_bytes_in_kb is not None:
            pulumi.set(__self__, "private_bytes_in_kb", private_bytes_in_kb)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if slow_requests is not None:
            pulumi.set(__self__, "slow_requests", slow_requests)
        if slow_requests_with_path is not None:
            pulumi.set(__self__, "slow_requests_with_path", slow_requests_with_path)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)
        if status_codes_range is not None:
            pulumi.set(__self__, "status_codes_range", status_codes_range)

    @property
    @pulumi.getter(name="privateBytesInKB")
    def private_bytes_in_kb(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        A rule based on private bytes.
        """
        return pulumi.get(self, "private_bytes_in_kb")

    @private_bytes_in_kb.setter
    def private_bytes_in_kb(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "private_bytes_in_kb", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input['RequestsBasedTriggerArgs']]:
        """
        A rule based on total requests.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input['RequestsBasedTriggerArgs']]):
        pulumi.set(self, "requests", value)

    @property
    @pulumi.getter(name="slowRequests")
    def slow_requests(self) -> Optional[pulumi.Input['SlowRequestsBasedTriggerArgs']]:
        """
        A rule based on request execution time.
        """
        return pulumi.get(self, "slow_requests")

    @slow_requests.setter
    def slow_requests(self, value: Optional[pulumi.Input['SlowRequestsBasedTriggerArgs']]):
        pulumi.set(self, "slow_requests", value)

    @property
    @pulumi.getter(name="slowRequestsWithPath")
    def slow_requests_with_path(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SlowRequestsBasedTriggerArgs']]]]:
        """
        A rule based on multiple Slow Requests Rule with path
        """
        return pulumi.get(self, "slow_requests_with_path")

    @slow_requests_with_path.setter
    def slow_requests_with_path(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SlowRequestsBasedTriggerArgs']]]]):
        pulumi.set(self, "slow_requests_with_path", value)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatusCodesBasedTriggerArgs']]]]:
        """
        A rule based on status codes.
        """
        return pulumi.get(self, "status_codes")

    @status_codes.setter
    def status_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatusCodesBasedTriggerArgs']]]]):
        pulumi.set(self, "status_codes", value)

    @property
    @pulumi.getter(name="statusCodesRange")
    def status_codes_range(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StatusCodesRangeBasedTriggerArgs']]]]:
        """
        A rule based on status codes ranges.
        """
        return pulumi.get(self, "status_codes_range")

    @status_codes_range.setter
    def status_codes_range(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StatusCodesRangeBasedTriggerArgs']]]]):
        pulumi.set(self, "status_codes_range", value)


if not MYPY:
    class AzureActiveDirectoryLoginArgsDict(TypedDict):
        """
        The configuration settings of the Azure Active Directory login flow.
        """
        disable_www_authenticate: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        """
        login_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Login parameters to send to the OpenID Connect authorization endpoint when
        a user logs in. Each parameter must be in the form "key=value".
        """
elif False:
    AzureActiveDirectoryLoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureActiveDirectoryLoginArgs:
    def __init__(__self__, *,
                 disable_www_authenticate: Optional[pulumi.Input[builtins.bool]] = None,
                 login_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The configuration settings of the Azure Active Directory login flow.
        :param pulumi.Input[builtins.bool] disable_www_authenticate: <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] login_parameters: Login parameters to send to the OpenID Connect authorization endpoint when
               a user logs in. Each parameter must be in the form "key=value".
        """
        if disable_www_authenticate is not None:
            pulumi.set(__self__, "disable_www_authenticate", disable_www_authenticate)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)

    @property
    @pulumi.getter(name="disableWWWAuthenticate")
    def disable_www_authenticate(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "disable_www_authenticate")

    @disable_www_authenticate.setter
    def disable_www_authenticate(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_www_authenticate", value)

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when
        a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "login_parameters")

    @login_parameters.setter
    def login_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "login_parameters", value)


if not MYPY:
    class AzureActiveDirectoryRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the Azure Active Directory app registration.
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Client ID of this relying party application, known as the client_id.
        This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
        other 3rd party OpenID Connect providers.
        More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        """
        client_secret_certificate_issuer: NotRequired[pulumi.Input[builtins.str]]
        """
        An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        client_secret_certificate_subject_alternative_name: NotRequired[pulumi.Input[builtins.str]]
        """
        An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        client_secret_certificate_thumbprint: NotRequired[pulumi.Input[builtins.str]]
        """
        An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret. It is also optional.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The app setting name that contains the client secret of the relying party application.
        """
        open_id_issuer: NotRequired[pulumi.Input[builtins.str]]
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
        When using Azure Active Directory, this value is the URI of the directory tenant, e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
        This URI is a case-sensitive identifier for the token issuer.
        More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
elif False:
    AzureActiveDirectoryRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureActiveDirectoryRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret_certificate_issuer: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret_certificate_subject_alternative_name: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret_certificate_thumbprint: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[builtins.str]] = None,
                 open_id_issuer: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the Azure Active Directory app registration.
        :param pulumi.Input[builtins.str] client_id: The Client ID of this relying party application, known as the client_id.
               This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
               other 3rd party OpenID Connect providers.
               More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        :param pulumi.Input[builtins.str] client_secret_certificate_issuer: An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        :param pulumi.Input[builtins.str] client_secret_certificate_subject_alternative_name: An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        :param pulumi.Input[builtins.str] client_secret_certificate_thumbprint: An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret. It is also optional.
        :param pulumi.Input[builtins.str] client_secret_setting_name: The app setting name that contains the client secret of the relying party application.
        :param pulumi.Input[builtins.str] open_id_issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
               When using Azure Active Directory, this value is the URI of the directory tenant, e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
               This URI is a case-sensitive identifier for the token issuer.
               More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_certificate_issuer is not None:
            pulumi.set(__self__, "client_secret_certificate_issuer", client_secret_certificate_issuer)
        if client_secret_certificate_subject_alternative_name is not None:
            pulumi.set(__self__, "client_secret_certificate_subject_alternative_name", client_secret_certificate_subject_alternative_name)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if open_id_issuer is not None:
            pulumi.set(__self__, "open_id_issuer", open_id_issuer)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Client ID of this relying party application, known as the client_id.
        This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
        other 3rd party OpenID Connect providers.
        More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretCertificateIssuer")
    def client_secret_certificate_issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_issuer")

    @client_secret_certificate_issuer.setter
    def client_secret_certificate_issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_certificate_issuer", value)

    @property
    @pulumi.getter(name="clientSecretCertificateSubjectAlternativeName")
    def client_secret_certificate_subject_alternative_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_subject_alternative_name")

    @client_secret_certificate_subject_alternative_name.setter
    def client_secret_certificate_subject_alternative_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_certificate_subject_alternative_name", value)

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @client_secret_certificate_thumbprint.setter
    def client_secret_certificate_thumbprint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_certificate_thumbprint", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The app setting name that contains the client secret of the relying party application.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="openIdIssuer")
    def open_id_issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
        When using Azure Active Directory, this value is the URI of the directory tenant, e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
        This URI is a case-sensitive identifier for the token issuer.
        More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
        return pulumi.get(self, "open_id_issuer")

    @open_id_issuer.setter
    def open_id_issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "open_id_issuer", value)


if not MYPY:
    class AzureActiveDirectoryValidationArgsDict(TypedDict):
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of audiences that can make successful authentication/authorization requests.
        """
        default_authorization_policy: NotRequired[pulumi.Input['DefaultAuthorizationPolicyArgsDict']]
        """
        The configuration settings of the default authorization policy.
        """
        jwt_claim_checks: NotRequired[pulumi.Input['JwtClaimChecksArgsDict']]
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        """
elif False:
    AzureActiveDirectoryValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureActiveDirectoryValidationArgs:
    def __init__(__self__, *,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 default_authorization_policy: Optional[pulumi.Input['DefaultAuthorizationPolicyArgs']] = None,
                 jwt_claim_checks: Optional[pulumi.Input['JwtClaimChecksArgs']] = None):
        """
        The configuration settings of the Azure Active Directory token validation flow.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_audiences: The list of audiences that can make successful authentication/authorization requests.
        :param pulumi.Input['DefaultAuthorizationPolicyArgs'] default_authorization_policy: The configuration settings of the default authorization policy.
        :param pulumi.Input['JwtClaimChecksArgs'] jwt_claim_checks: The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if default_authorization_policy is not None:
            pulumi.set(__self__, "default_authorization_policy", default_authorization_policy)
        if jwt_claim_checks is not None:
            pulumi.set(__self__, "jwt_claim_checks", jwt_claim_checks)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of audiences that can make successful authentication/authorization requests.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="defaultAuthorizationPolicy")
    def default_authorization_policy(self) -> Optional[pulumi.Input['DefaultAuthorizationPolicyArgs']]:
        """
        The configuration settings of the default authorization policy.
        """
        return pulumi.get(self, "default_authorization_policy")

    @default_authorization_policy.setter
    def default_authorization_policy(self, value: Optional[pulumi.Input['DefaultAuthorizationPolicyArgs']]):
        pulumi.set(self, "default_authorization_policy", value)

    @property
    @pulumi.getter(name="jwtClaimChecks")
    def jwt_claim_checks(self) -> Optional[pulumi.Input['JwtClaimChecksArgs']]:
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        return pulumi.get(self, "jwt_claim_checks")

    @jwt_claim_checks.setter
    def jwt_claim_checks(self, value: Optional[pulumi.Input['JwtClaimChecksArgs']]):
        pulumi.set(self, "jwt_claim_checks", value)


if not MYPY:
    class AzureActiveDirectoryArgsDict(TypedDict):
        """
        The configuration settings of the Azure Active directory provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        is_auto_provisioned: NotRequired[pulumi.Input[builtins.bool]]
        """
        Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
        This is an internal flag primarily intended to support the Azure Management Portal. Users should not
        read or write to this property.
        """
        login: NotRequired[pulumi.Input['AzureActiveDirectoryLoginArgsDict']]
        """
        The configuration settings of the Azure Active Directory login flow.
        """
        registration: NotRequired[pulumi.Input['AzureActiveDirectoryRegistrationArgsDict']]
        """
        The configuration settings of the Azure Active Directory app registration.
        """
        validation: NotRequired[pulumi.Input['AzureActiveDirectoryValidationArgsDict']]
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
elif False:
    AzureActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureActiveDirectoryArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 is_auto_provisioned: Optional[pulumi.Input[builtins.bool]] = None,
                 login: Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']] = None,
                 registration: Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']] = None,
                 validation: Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']] = None):
        """
        The configuration settings of the Azure Active directory provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input[builtins.bool] is_auto_provisioned: Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
               This is an internal flag primarily intended to support the Azure Management Portal. Users should not
               read or write to this property.
        :param pulumi.Input['AzureActiveDirectoryLoginArgs'] login: The configuration settings of the Azure Active Directory login flow.
        :param pulumi.Input['AzureActiveDirectoryRegistrationArgs'] registration: The configuration settings of the Azure Active Directory app registration.
        :param pulumi.Input['AzureActiveDirectoryValidationArgs'] validation: The configuration settings of the Azure Active Directory token validation flow.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if is_auto_provisioned is not None:
            pulumi.set(__self__, "is_auto_provisioned", is_auto_provisioned)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="isAutoProvisioned")
    def is_auto_provisioned(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
        This is an internal flag primarily intended to support the Azure Management Portal. Users should not
        read or write to this property.
        """
        return pulumi.get(self, "is_auto_provisioned")

    @is_auto_provisioned.setter
    def is_auto_provisioned(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_auto_provisioned", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']]:
        """
        The configuration settings of the Azure Active Directory login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']]:
        """
        The configuration settings of the Azure Active Directory app registration.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']]):
        pulumi.set(self, "registration", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']]:
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class AzureBlobStorageApplicationLogsConfigArgsDict(TypedDict):
        """
        Application logs azure blob storage configuration.
        """
        level: NotRequired[pulumi.Input['LogLevel']]
        """
        Log level.
        """
        retention_in_days: NotRequired[pulumi.Input[builtins.int]]
        """
        Retention in days.
        Remove blobs older than X days.
        0 or lower means no retention.
        """
        sas_url: NotRequired[pulumi.Input[builtins.str]]
        """
        SAS url to a azure blob container with read/write/list/delete permissions.
        """
elif False:
    AzureBlobStorageApplicationLogsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureBlobStorageApplicationLogsConfigArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input['LogLevel']] = None,
                 retention_in_days: Optional[pulumi.Input[builtins.int]] = None,
                 sas_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        Application logs azure blob storage configuration.
        :param pulumi.Input['LogLevel'] level: Log level.
        :param pulumi.Input[builtins.int] retention_in_days: Retention in days.
               Remove blobs older than X days.
               0 or lower means no retention.
        :param pulumi.Input[builtins.str] sas_url: SAS url to a azure blob container with read/write/list/delete permissions.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if sas_url is not None:
            pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input['LogLevel']]:
        """
        Log level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input['LogLevel']]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Retention in days.
        Remove blobs older than X days.
        0 or lower means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SAS url to a azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sas_url", value)


if not MYPY:
    class AzureBlobStorageHttpLogsConfigArgsDict(TypedDict):
        """
        Http logs to azure blob storage configuration.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        retention_in_days: NotRequired[pulumi.Input[builtins.int]]
        """
        Retention in days.
        Remove blobs older than X days.
        0 or lower means no retention.
        """
        sas_url: NotRequired[pulumi.Input[builtins.str]]
        """
        SAS url to a azure blob container with read/write/list/delete permissions.
        """
elif False:
    AzureBlobStorageHttpLogsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureBlobStorageHttpLogsConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 retention_in_days: Optional[pulumi.Input[builtins.int]] = None,
                 sas_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        Http logs to azure blob storage configuration.
        :param pulumi.Input[builtins.bool] enabled: True if configuration is enabled, false if it is disabled and null if configuration is not set.
        :param pulumi.Input[builtins.int] retention_in_days: Retention in days.
               Remove blobs older than X days.
               0 or lower means no retention.
        :param pulumi.Input[builtins.str] sas_url: SAS url to a azure blob container with read/write/list/delete permissions.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if sas_url is not None:
            pulumi.set(__self__, "sas_url", sas_url)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Retention in days.
        Remove blobs older than X days.
        0 or lower means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SAS url to a azure blob container with read/write/list/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sas_url", value)


if not MYPY:
    class AzureStaticWebAppsRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the registration for the Azure Static Web Apps provider
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Client ID of the app used for login.
        """
elif False:
    AzureStaticWebAppsRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureStaticWebAppsRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the registration for the Azure Static Web Apps provider
        :param pulumi.Input[builtins.str] client_id: The Client ID of the app used for login.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)


if not MYPY:
    class AzureStaticWebAppsArgsDict(TypedDict):
        """
        The configuration settings of the Azure Static Web Apps provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        registration: NotRequired[pulumi.Input['AzureStaticWebAppsRegistrationArgsDict']]
        """
        The configuration settings of the Azure Static Web Apps registration.
        """
elif False:
    AzureStaticWebAppsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureStaticWebAppsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 registration: Optional[pulumi.Input['AzureStaticWebAppsRegistrationArgs']] = None):
        """
        The configuration settings of the Azure Static Web Apps provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['AzureStaticWebAppsRegistrationArgs'] registration: The configuration settings of the Azure Static Web Apps registration.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AzureStaticWebAppsRegistrationArgs']]:
        """
        The configuration settings of the Azure Static Web Apps registration.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AzureStaticWebAppsRegistrationArgs']]):
        pulumi.set(self, "registration", value)


if not MYPY:
    class AzureStorageInfoValueArgsDict(TypedDict):
        """
        Azure Files or Blob Storage access information value for dictionary storage.
        """
        access_key: NotRequired[pulumi.Input[builtins.str]]
        """
        Access key for the storage account.
        """
        account_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the storage account.
        """
        mount_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path to mount the storage within the site's runtime environment.
        """
        protocol: NotRequired[pulumi.Input[Union[builtins.str, 'AzureStorageProtocol']]]
        """
        Mounting protocol to use for the storage account.
        """
        share_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the file share (container name, for Blob storage).
        """
        type: NotRequired[pulumi.Input['AzureStorageType']]
        """
        Type of storage.
        """
elif False:
    AzureStorageInfoValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureStorageInfoValueArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[builtins.str]] = None,
                 account_name: Optional[pulumi.Input[builtins.str]] = None,
                 mount_path: Optional[pulumi.Input[builtins.str]] = None,
                 protocol: Optional[pulumi.Input[Union[builtins.str, 'AzureStorageProtocol']]] = None,
                 share_name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input['AzureStorageType']] = None):
        """
        Azure Files or Blob Storage access information value for dictionary storage.
        :param pulumi.Input[builtins.str] access_key: Access key for the storage account.
        :param pulumi.Input[builtins.str] account_name: Name of the storage account.
        :param pulumi.Input[builtins.str] mount_path: Path to mount the storage within the site's runtime environment.
        :param pulumi.Input[Union[builtins.str, 'AzureStorageProtocol']] protocol: Mounting protocol to use for the storage account.
        :param pulumi.Input[builtins.str] share_name: Name of the file share (container name, for Blob storage).
        :param pulumi.Input['AzureStorageType'] type: Type of storage.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Access key for the storage account.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the storage account.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path to mount the storage within the site's runtime environment.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[Union[builtins.str, 'AzureStorageProtocol']]]:
        """
        Mounting protocol to use for the storage account.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[Union[builtins.str, 'AzureStorageProtocol']]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the file share (container name, for Blob storage).
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['AzureStorageType']]:
        """
        Type of storage.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['AzureStorageType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AzureTableStorageApplicationLogsConfigArgsDict(TypedDict):
        """
        Application logs to Azure table storage configuration.
        """
        sas_url: pulumi.Input[builtins.str]
        """
        SAS URL to an Azure table with add/query/delete permissions.
        """
        level: NotRequired[pulumi.Input['LogLevel']]
        """
        Log level.
        """
elif False:
    AzureTableStorageApplicationLogsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureTableStorageApplicationLogsConfigArgs:
    def __init__(__self__, *,
                 sas_url: pulumi.Input[builtins.str],
                 level: Optional[pulumi.Input['LogLevel']] = None):
        """
        Application logs to Azure table storage configuration.
        :param pulumi.Input[builtins.str] sas_url: SAS URL to an Azure table with add/query/delete permissions.
        :param pulumi.Input['LogLevel'] level: Log level.
        """
        pulumi.set(__self__, "sas_url", sas_url)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter(name="sasUrl")
    def sas_url(self) -> pulumi.Input[builtins.str]:
        """
        SAS URL to an Azure table with add/query/delete permissions.
        """
        return pulumi.get(self, "sas_url")

    @sas_url.setter
    def sas_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "sas_url", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input['LogLevel']]:
        """
        Log level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input['LogLevel']]):
        pulumi.set(self, "level", value)


if not MYPY:
    class BackupScheduleDict(TypedDict):
        """
        Description of a backup schedule. Describes how often should be the backup performed and what should be the retention policy.
        """
        frequency_interval: builtins.int
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        """
        frequency_unit: 'FrequencyUnit'
        """
        The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        """
        keep_at_least_one_backup: builtins.bool
        """
        True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        """
        retention_period_in_days: builtins.int
        """
        After how many days backups should be deleted.
        """
        start_time: NotRequired[builtins.str]
        """
        When the schedule should start working.
        """
elif False:
    BackupScheduleDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupSchedule:
    def __init__(__self__, *,
                 frequency_interval: Optional[builtins.int] = None,
                 frequency_unit: Optional['FrequencyUnit'] = None,
                 keep_at_least_one_backup: Optional[builtins.bool] = None,
                 retention_period_in_days: Optional[builtins.int] = None,
                 start_time: Optional[builtins.str] = None):
        """
        Description of a backup schedule. Describes how often should be the backup performed and what should be the retention policy.
        :param builtins.int frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        :param 'FrequencyUnit' frequency_unit: The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        :param builtins.bool keep_at_least_one_backup: True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        :param builtins.int retention_period_in_days: After how many days backups should be deleted.
        :param builtins.str start_time: When the schedule should start working.
        """
        if frequency_interval is None:
            frequency_interval = 7
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        if frequency_unit is None:
            frequency_unit = 'Day'
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is None:
            keep_at_least_one_backup = True
        pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if retention_period_in_days is None:
            retention_period_in_days = 30
        pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> builtins.int:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: builtins.int):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> 'FrequencyUnit':
        """
        The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        """
        return pulumi.get(self, "frequency_unit")

    @frequency_unit.setter
    def frequency_unit(self, value: 'FrequencyUnit'):
        pulumi.set(self, "frequency_unit", value)

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> builtins.bool:
        """
        True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @keep_at_least_one_backup.setter
    def keep_at_least_one_backup(self, value: builtins.bool):
        pulumi.set(self, "keep_at_least_one_backup", value)

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> builtins.int:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_in_days")

    @retention_period_in_days.setter
    def retention_period_in_days(self, value: builtins.int):
        pulumi.set(self, "retention_period_in_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[builtins.str]:
        """
        When the schedule should start working.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[builtins.str]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class BackupScheduleArgsDict(TypedDict):
        """
        Description of a backup schedule. Describes how often should be the backup performed and what should be the retention policy.
        """
        frequency_interval: pulumi.Input[builtins.int]
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        """
        frequency_unit: pulumi.Input['FrequencyUnit']
        """
        The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        """
        keep_at_least_one_backup: pulumi.Input[builtins.bool]
        """
        True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        """
        retention_period_in_days: pulumi.Input[builtins.int]
        """
        After how many days backups should be deleted.
        """
        start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        When the schedule should start working.
        """
elif False:
    BackupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupScheduleArgs:
    def __init__(__self__, *,
                 frequency_interval: Optional[pulumi.Input[builtins.int]] = None,
                 frequency_unit: Optional[pulumi.Input['FrequencyUnit']] = None,
                 keep_at_least_one_backup: Optional[pulumi.Input[builtins.bool]] = None,
                 retention_period_in_days: Optional[pulumi.Input[builtins.int]] = None,
                 start_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        Description of a backup schedule. Describes how often should be the backup performed and what should be the retention policy.
        :param pulumi.Input[builtins.int] frequency_interval: How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        :param pulumi.Input['FrequencyUnit'] frequency_unit: The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        :param pulumi.Input[builtins.bool] keep_at_least_one_backup: True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        :param pulumi.Input[builtins.int] retention_period_in_days: After how many days backups should be deleted.
        :param pulumi.Input[builtins.str] start_time: When the schedule should start working.
        """
        if frequency_interval is None:
            frequency_interval = 7
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        if frequency_unit is None:
            frequency_unit = 'Day'
        pulumi.set(__self__, "frequency_unit", frequency_unit)
        if keep_at_least_one_backup is None:
            keep_at_least_one_backup = True
        pulumi.set(__self__, "keep_at_least_one_backup", keep_at_least_one_backup)
        if retention_period_in_days is None:
            retention_period_in_days = 30
        pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[builtins.int]:
        """
        How often the backup should be executed (e.g. for weekly backup, this should be set to 7 and FrequencyUnit should be set to Day)
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyUnit")
    def frequency_unit(self) -> pulumi.Input['FrequencyUnit']:
        """
        The unit of time for how often the backup should be executed (e.g. for weekly backup, this should be set to Day and FrequencyInterval should be set to 7)
        """
        return pulumi.get(self, "frequency_unit")

    @frequency_unit.setter
    def frequency_unit(self, value: pulumi.Input['FrequencyUnit']):
        pulumi.set(self, "frequency_unit", value)

    @property
    @pulumi.getter(name="keepAtLeastOneBackup")
    def keep_at_least_one_backup(self) -> pulumi.Input[builtins.bool]:
        """
        True if the retention policy should always keep at least one backup in the storage account, regardless how old it is; false otherwise.
        """
        return pulumi.get(self, "keep_at_least_one_backup")

    @keep_at_least_one_backup.setter
    def keep_at_least_one_backup(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "keep_at_least_one_backup", value)

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> pulumi.Input[builtins.int]:
        """
        After how many days backups should be deleted.
        """
        return pulumi.get(self, "retention_period_in_days")

    @retention_period_in_days.setter
    def retention_period_in_days(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "retention_period_in_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        When the schedule should start working.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class BlobStorageTokenStoreArgsDict(TypedDict):
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        """
        sas_url_setting_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the app setting containing the SAS URL of the blob storage containing the tokens.
        """
elif False:
    BlobStorageTokenStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BlobStorageTokenStoreArgs:
    def __init__(__self__, *,
                 sas_url_setting_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        :param pulumi.Input[builtins.str] sas_url_setting_name: The name of the app setting containing the SAS URL of the blob storage containing the tokens.
        """
        if sas_url_setting_name is not None:
            pulumi.set(__self__, "sas_url_setting_name", sas_url_setting_name)

    @property
    @pulumi.getter(name="sasUrlSettingName")
    def sas_url_setting_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the app setting containing the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "sas_url_setting_name")

    @sas_url_setting_name.setter
    def sas_url_setting_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sas_url_setting_name", value)


if not MYPY:
    class CapabilityArgsDict(TypedDict):
        """
        Describes the capabilities/features allowed for a specific SKU.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the SKU capability.
        """
        reason: NotRequired[pulumi.Input[builtins.str]]
        """
        Reason of the SKU capability.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Value of the SKU capability.
        """
elif False:
    CapabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 reason: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Describes the capabilities/features allowed for a specific SKU.
        :param pulumi.Input[builtins.str] name: Name of the SKU capability.
        :param pulumi.Input[builtins.str] reason: Reason of the SKU capability.
        :param pulumi.Input[builtins.str] value: Value of the SKU capability.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the SKU capability.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reason of the SKU capability.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Value of the SKU capability.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClientRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the app registration for providers that have client ids and client secrets
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Client ID of the app used for login.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The app setting name that contains the client secret.
        """
elif False:
    ClientRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the app registration for providers that have client ids and client secrets
        :param pulumi.Input[builtins.str] client_id: The Client ID of the app used for login.
        :param pulumi.Input[builtins.str] client_secret_setting_name: The app setting name that contains the client secret.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The app setting name that contains the client secret.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_setting_name", value)


if not MYPY:
    class CloningInfoArgsDict(TypedDict):
        """
        Information needed for cloning operation.
        """
        source_web_app_id: pulumi.Input[builtins.str]
        """
        ARM resource ID of the source app. App resource ID is of the form 
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots and 
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for other slots.
        """
        app_settings_overrides: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Application setting overrides for cloned app. If specified, these settings override the settings cloned 
        from source app. Otherwise, application settings from source app are retained.
        """
        clone_custom_host_names: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
        """
        clone_source_control: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
        """
        configure_load_balancing: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> to configure load balancing for source and destination app.
        """
        correlation_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Correlation ID of cloning operation. This ID ties multiple cloning operations
        together to use the same snapshot.
        """
        hosting_environment: NotRequired[pulumi.Input[builtins.str]]
        """
        App Service Environment.
        """
        overwrite: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
        """
        source_web_app_location: NotRequired[pulumi.Input[builtins.str]]
        """
        Location of source app ex: West US or North Europe
        """
        traffic_manager_profile_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form 
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
        """
        traffic_manager_profile_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
        """
elif False:
    CloningInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloningInfoArgs:
    def __init__(__self__, *,
                 source_web_app_id: pulumi.Input[builtins.str],
                 app_settings_overrides: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 clone_custom_host_names: Optional[pulumi.Input[builtins.bool]] = None,
                 clone_source_control: Optional[pulumi.Input[builtins.bool]] = None,
                 configure_load_balancing: Optional[pulumi.Input[builtins.bool]] = None,
                 correlation_id: Optional[pulumi.Input[builtins.str]] = None,
                 hosting_environment: Optional[pulumi.Input[builtins.str]] = None,
                 overwrite: Optional[pulumi.Input[builtins.bool]] = None,
                 source_web_app_location: Optional[pulumi.Input[builtins.str]] = None,
                 traffic_manager_profile_id: Optional[pulumi.Input[builtins.str]] = None,
                 traffic_manager_profile_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Information needed for cloning operation.
        :param pulumi.Input[builtins.str] source_web_app_id: ARM resource ID of the source app. App resource ID is of the form 
               /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots and 
               /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for other slots.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] app_settings_overrides: Application setting overrides for cloned app. If specified, these settings override the settings cloned 
               from source app. Otherwise, application settings from source app are retained.
        :param pulumi.Input[builtins.bool] clone_custom_host_names: <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
        :param pulumi.Input[builtins.bool] clone_source_control: <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
        :param pulumi.Input[builtins.bool] configure_load_balancing: <code>true</code> to configure load balancing for source and destination app.
        :param pulumi.Input[builtins.str] correlation_id: Correlation ID of cloning operation. This ID ties multiple cloning operations
               together to use the same snapshot.
        :param pulumi.Input[builtins.str] hosting_environment: App Service Environment.
        :param pulumi.Input[builtins.bool] overwrite: <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
        :param pulumi.Input[builtins.str] source_web_app_location: Location of source app ex: West US or North Europe
        :param pulumi.Input[builtins.str] traffic_manager_profile_id: ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form 
               /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
        :param pulumi.Input[builtins.str] traffic_manager_profile_name: Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
        """
        pulumi.set(__self__, "source_web_app_id", source_web_app_id)
        if app_settings_overrides is not None:
            pulumi.set(__self__, "app_settings_overrides", app_settings_overrides)
        if clone_custom_host_names is not None:
            pulumi.set(__self__, "clone_custom_host_names", clone_custom_host_names)
        if clone_source_control is not None:
            pulumi.set(__self__, "clone_source_control", clone_source_control)
        if configure_load_balancing is not None:
            pulumi.set(__self__, "configure_load_balancing", configure_load_balancing)
        if correlation_id is not None:
            pulumi.set(__self__, "correlation_id", correlation_id)
        if hosting_environment is not None:
            pulumi.set(__self__, "hosting_environment", hosting_environment)
        if overwrite is not None:
            pulumi.set(__self__, "overwrite", overwrite)
        if source_web_app_location is not None:
            pulumi.set(__self__, "source_web_app_location", source_web_app_location)
        if traffic_manager_profile_id is not None:
            pulumi.set(__self__, "traffic_manager_profile_id", traffic_manager_profile_id)
        if traffic_manager_profile_name is not None:
            pulumi.set(__self__, "traffic_manager_profile_name", traffic_manager_profile_name)

    @property
    @pulumi.getter(name="sourceWebAppId")
    def source_web_app_id(self) -> pulumi.Input[builtins.str]:
        """
        ARM resource ID of the source app. App resource ID is of the form 
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots and 
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for other slots.
        """
        return pulumi.get(self, "source_web_app_id")

    @source_web_app_id.setter
    def source_web_app_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_web_app_id", value)

    @property
    @pulumi.getter(name="appSettingsOverrides")
    def app_settings_overrides(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Application setting overrides for cloned app. If specified, these settings override the settings cloned 
        from source app. Otherwise, application settings from source app are retained.
        """
        return pulumi.get(self, "app_settings_overrides")

    @app_settings_overrides.setter
    def app_settings_overrides(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "app_settings_overrides", value)

    @property
    @pulumi.getter(name="cloneCustomHostNames")
    def clone_custom_host_names(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "clone_custom_host_names")

    @clone_custom_host_names.setter
    def clone_custom_host_names(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "clone_custom_host_names", value)

    @property
    @pulumi.getter(name="cloneSourceControl")
    def clone_source_control(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "clone_source_control")

    @clone_source_control.setter
    def clone_source_control(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "clone_source_control", value)

    @property
    @pulumi.getter(name="configureLoadBalancing")
    def configure_load_balancing(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> to configure load balancing for source and destination app.
        """
        return pulumi.get(self, "configure_load_balancing")

    @configure_load_balancing.setter
    def configure_load_balancing(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "configure_load_balancing", value)

    @property
    @pulumi.getter(name="correlationId")
    def correlation_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Correlation ID of cloning operation. This ID ties multiple cloning operations
        together to use the same snapshot.
        """
        return pulumi.get(self, "correlation_id")

    @correlation_id.setter
    def correlation_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "correlation_id", value)

    @property
    @pulumi.getter(name="hostingEnvironment")
    def hosting_environment(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        App Service Environment.
        """
        return pulumi.get(self, "hosting_environment")

    @hosting_environment.setter
    def hosting_environment(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "hosting_environment", value)

    @property
    @pulumi.getter
    def overwrite(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "overwrite")

    @overwrite.setter
    def overwrite(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "overwrite", value)

    @property
    @pulumi.getter(name="sourceWebAppLocation")
    def source_web_app_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Location of source app ex: West US or North Europe
        """
        return pulumi.get(self, "source_web_app_location")

    @source_web_app_location.setter
    def source_web_app_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_web_app_location", value)

    @property
    @pulumi.getter(name="trafficManagerProfileId")
    def traffic_manager_profile_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form 
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
        """
        return pulumi.get(self, "traffic_manager_profile_id")

    @traffic_manager_profile_id.setter
    def traffic_manager_profile_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "traffic_manager_profile_id", value)

    @property
    @pulumi.getter(name="trafficManagerProfileName")
    def traffic_manager_profile_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
        """
        return pulumi.get(self, "traffic_manager_profile_name")

    @traffic_manager_profile_name.setter
    def traffic_manager_profile_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "traffic_manager_profile_name", value)


if not MYPY:
    class ConnStringInfoArgsDict(TypedDict):
        """
        Database connection string information.
        """
        connection_string: NotRequired[pulumi.Input[builtins.str]]
        """
        Connection string value.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of connection string.
        """
        type: NotRequired[pulumi.Input['ConnectionStringType']]
        """
        Type of database.
        """
elif False:
    ConnStringInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnStringInfoArgs:
    def __init__(__self__, *,
                 connection_string: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input['ConnectionStringType']] = None):
        """
        Database connection string information.
        :param pulumi.Input[builtins.str] connection_string: Connection string value.
        :param pulumi.Input[builtins.str] name: Name of connection string.
        :param pulumi.Input['ConnectionStringType'] type: Type of database.
        """
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Connection string value.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of connection string.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ConnectionStringType']]:
        """
        Type of database.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ConnectionStringType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConnStringValueTypePairArgsDict(TypedDict):
        """
        Database connection string value to type pair.
        """
        type: pulumi.Input['ConnectionStringType']
        """
        Type of database.
        """
        value: pulumi.Input[builtins.str]
        """
        Value of pair.
        """
elif False:
    ConnStringValueTypePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnStringValueTypePairArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['ConnectionStringType'],
                 value: pulumi.Input[builtins.str]):
        """
        Database connection string value to type pair.
        :param pulumi.Input['ConnectionStringType'] type: Type of database.
        :param pulumi.Input[builtins.str] value: Value of pair.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['ConnectionStringType']:
        """
        Type of database.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ConnectionStringType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Value of pair.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConnectionErrorArgsDict(TypedDict):
        """
        Connection error
        """
        code: NotRequired[pulumi.Input[builtins.str]]
        """
        Code of the status
        """
        etag: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ETag
        """
        location: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource location
        """
        message: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of the status
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Resource tags
        """
elif False:
    ConnectionErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[builtins.str]] = None,
                 etag: Optional[pulumi.Input[builtins.str]] = None,
                 location: Optional[pulumi.Input[builtins.str]] = None,
                 message: Optional[pulumi.Input[builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        Connection error
        :param pulumi.Input[builtins.str] code: Code of the status
        :param pulumi.Input[builtins.str] etag: Resource ETag
        :param pulumi.Input[builtins.str] location: Resource location
        :param pulumi.Input[builtins.str] message: Description of the status
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] tags: Resource tags
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Code of the status
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def etag(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ETag
        """
        return pulumi.get(self, "etag")

    @etag.setter
    def etag(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "etag", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource location
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of the status
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Resource tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ConnectionGatewayDefinitionPropertiesArgsDict(TypedDict):
        backend_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        The URI of the backend
        """
        connection_gateway_installation: NotRequired[pulumi.Input['ConnectionGatewayReferenceArgsDict']]
        """
        The gateway installation reference
        """
        contact_information: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The gateway admin
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The gateway description
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The gateway display name
        """
        machine_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The machine name of the gateway
        """
        status: NotRequired[Any]
        """
        The gateway status
        """
elif False:
    ConnectionGatewayDefinitionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionGatewayDefinitionPropertiesArgs:
    def __init__(__self__, *,
                 backend_uri: Optional[pulumi.Input[builtins.str]] = None,
                 connection_gateway_installation: Optional[pulumi.Input['ConnectionGatewayReferenceArgs']] = None,
                 contact_information: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 machine_name: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[Any] = None):
        """
        :param pulumi.Input[builtins.str] backend_uri: The URI of the backend
        :param pulumi.Input['ConnectionGatewayReferenceArgs'] connection_gateway_installation: The gateway installation reference
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] contact_information: The gateway admin
        :param pulumi.Input[builtins.str] description: The gateway description
        :param pulumi.Input[builtins.str] display_name: The gateway display name
        :param pulumi.Input[builtins.str] machine_name: The machine name of the gateway
        :param Any status: The gateway status
        """
        if backend_uri is not None:
            pulumi.set(__self__, "backend_uri", backend_uri)
        if connection_gateway_installation is not None:
            pulumi.set(__self__, "connection_gateway_installation", connection_gateway_installation)
        if contact_information is not None:
            pulumi.set(__self__, "contact_information", contact_information)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if machine_name is not None:
            pulumi.set(__self__, "machine_name", machine_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="backendUri")
    def backend_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URI of the backend
        """
        return pulumi.get(self, "backend_uri")

    @backend_uri.setter
    def backend_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backend_uri", value)

    @property
    @pulumi.getter(name="connectionGatewayInstallation")
    def connection_gateway_installation(self) -> Optional[pulumi.Input['ConnectionGatewayReferenceArgs']]:
        """
        The gateway installation reference
        """
        return pulumi.get(self, "connection_gateway_installation")

    @connection_gateway_installation.setter
    def connection_gateway_installation(self, value: Optional[pulumi.Input['ConnectionGatewayReferenceArgs']]):
        pulumi.set(self, "connection_gateway_installation", value)

    @property
    @pulumi.getter(name="contactInformation")
    def contact_information(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The gateway admin
        """
        return pulumi.get(self, "contact_information")

    @contact_information.setter
    def contact_information(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "contact_information", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The gateway description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The gateway display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="machineName")
    def machine_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The machine name of the gateway
        """
        return pulumi.get(self, "machine_name")

    @machine_name.setter
    def machine_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "machine_name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[Any]:
        """
        The gateway status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[Any]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ConnectionGatewayReferenceArgsDict(TypedDict):
        """
        The gateway installation reference
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource reference id
        """
        location: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource reference location
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource reference name
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource reference type
        """
elif False:
    ConnectionGatewayReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionGatewayReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 location: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        The gateway installation reference
        :param pulumi.Input[builtins.str] id: Resource reference id
        :param pulumi.Input[builtins.str] location: Resource reference location
        :param pulumi.Input[builtins.str] name: Resource reference name
        :param pulumi.Input[builtins.str] type: Resource reference type
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource reference id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource reference location
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource reference name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource reference type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConnectionParameterArgsDict(TypedDict):
        """
        Connection provider parameters
        """
        o_auth_settings: NotRequired[pulumi.Input['ApiOAuthSettingsArgsDict']]
        """
        OAuth settings for the connection provider
        """
        type: NotRequired[pulumi.Input['ConnectionParameterType']]
        """
        Type of the parameter
        """
elif False:
    ConnectionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionParameterArgs:
    def __init__(__self__, *,
                 o_auth_settings: Optional[pulumi.Input['ApiOAuthSettingsArgs']] = None,
                 type: Optional[pulumi.Input['ConnectionParameterType']] = None):
        """
        Connection provider parameters
        :param pulumi.Input['ApiOAuthSettingsArgs'] o_auth_settings: OAuth settings for the connection provider
        :param pulumi.Input['ConnectionParameterType'] type: Type of the parameter
        """
        if o_auth_settings is not None:
            pulumi.set(__self__, "o_auth_settings", o_auth_settings)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="oAuthSettings")
    def o_auth_settings(self) -> Optional[pulumi.Input['ApiOAuthSettingsArgs']]:
        """
        OAuth settings for the connection provider
        """
        return pulumi.get(self, "o_auth_settings")

    @o_auth_settings.setter
    def o_auth_settings(self, value: Optional[pulumi.Input['ApiOAuthSettingsArgs']]):
        pulumi.set(self, "o_auth_settings", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ConnectionParameterType']]:
        """
        Type of the parameter
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ConnectionParameterType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConnectionStatusDefinitionArgsDict(TypedDict):
        """
        Connection status
        """
        error: NotRequired[pulumi.Input['ConnectionErrorArgsDict']]
        """
        Connection error
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        The gateway status
        """
        target: NotRequired[pulumi.Input[builtins.str]]
        """
        Target of the error
        """
elif False:
    ConnectionStatusDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionStatusDefinitionArgs:
    def __init__(__self__, *,
                 error: Optional[pulumi.Input['ConnectionErrorArgs']] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 target: Optional[pulumi.Input[builtins.str]] = None):
        """
        Connection status
        :param pulumi.Input['ConnectionErrorArgs'] error: Connection error
        :param pulumi.Input[builtins.str] status: The gateway status
        :param pulumi.Input[builtins.str] target: Target of the error
        """
        if error is not None:
            pulumi.set(__self__, "error", error)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input['ConnectionErrorArgs']]:
        """
        Connection error
        """
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input['ConnectionErrorArgs']]):
        pulumi.set(self, "error", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The gateway status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Target of the error
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class ConsentLinkParameterDefinitionDict(TypedDict):
        """
        Consent link definition
        """
        object_id: NotRequired[builtins.str]
        """
        AAD OID (user or group) if the principal type is ActiveDirectory. MSA PUID if the principal type is MicrosoftAccount
        """
        parameter_name: NotRequired[builtins.str]
        """
        Name of the parameter in the connection provider's OAuth settings
        """
        redirect_url: NotRequired[builtins.str]
        """
        Name of the parameter in the connection provider's OAuth settings
        """
        tenant_id: NotRequired[builtins.str]
        """
        The tenant id
        """
elif False:
    ConsentLinkParameterDefinitionDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConsentLinkParameterDefinition:
    def __init__(__self__, *,
                 object_id: Optional[builtins.str] = None,
                 parameter_name: Optional[builtins.str] = None,
                 redirect_url: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None):
        """
        Consent link definition
        :param builtins.str object_id: AAD OID (user or group) if the principal type is ActiveDirectory. MSA PUID if the principal type is MicrosoftAccount
        :param builtins.str parameter_name: Name of the parameter in the connection provider's OAuth settings
        :param builtins.str redirect_url: Name of the parameter in the connection provider's OAuth settings
        :param builtins.str tenant_id: The tenant id
        """
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if parameter_name is not None:
            pulumi.set(__self__, "parameter_name", parameter_name)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[builtins.str]:
        """
        AAD OID (user or group) if the principal type is ActiveDirectory. MSA PUID if the principal type is MicrosoftAccount
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[builtins.str]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="parameterName")
    def parameter_name(self) -> Optional[builtins.str]:
        """
        Name of the parameter in the connection provider's OAuth settings
        """
        return pulumi.get(self, "parameter_name")

    @parameter_name.setter
    def parameter_name(self, value: Optional[builtins.str]):
        pulumi.set(self, "parameter_name", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[builtins.str]:
        """
        Name of the parameter in the connection provider's OAuth settings
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[builtins.str]):
        pulumi.set(self, "redirect_url", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        """
        The tenant id
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[builtins.str]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class ContainerAppsConfigurationArgsDict(TypedDict):
        app_subnet_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ID of a subnet for control plane infrastructure components. This subnet must be in the same VNET as the subnet defined in appSubnetResourceId. Must not overlap with the IP range defined in platformReservedCidr, if defined.
        """
        control_plane_subnet_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ID of a subnet for control plane infrastructure components. This subnet must be in the same VNET as the subnet defined in appSubnetResourceId. Must not overlap with the IP range defined in platformReservedCidr, if defined.
        """
        dapr_ai_instrumentation_key: NotRequired[pulumi.Input[builtins.str]]
        """
        Azure Monitor instrumentation key used by Dapr to export Service to Service communication telemetry
        """
        docker_bridge_cidr: NotRequired[pulumi.Input[builtins.str]]
        """
        CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the IP range defined in platformReservedCidr, if defined.
        """
        platform_reserved_cidr: NotRequired[pulumi.Input[builtins.str]]
        """
        IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. It must not overlap with any other Subnet IP ranges.
        """
        platform_reserved_dns_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server
        """
elif False:
    ContainerAppsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerAppsConfigurationArgs:
    def __init__(__self__, *,
                 app_subnet_resource_id: Optional[pulumi.Input[builtins.str]] = None,
                 control_plane_subnet_resource_id: Optional[pulumi.Input[builtins.str]] = None,
                 dapr_ai_instrumentation_key: Optional[pulumi.Input[builtins.str]] = None,
                 docker_bridge_cidr: Optional[pulumi.Input[builtins.str]] = None,
                 platform_reserved_cidr: Optional[pulumi.Input[builtins.str]] = None,
                 platform_reserved_dns_ip: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] app_subnet_resource_id: Resource ID of a subnet for control plane infrastructure components. This subnet must be in the same VNET as the subnet defined in appSubnetResourceId. Must not overlap with the IP range defined in platformReservedCidr, if defined.
        :param pulumi.Input[builtins.str] control_plane_subnet_resource_id: Resource ID of a subnet for control plane infrastructure components. This subnet must be in the same VNET as the subnet defined in appSubnetResourceId. Must not overlap with the IP range defined in platformReservedCidr, if defined.
        :param pulumi.Input[builtins.str] dapr_ai_instrumentation_key: Azure Monitor instrumentation key used by Dapr to export Service to Service communication telemetry
        :param pulumi.Input[builtins.str] docker_bridge_cidr: CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the IP range defined in platformReservedCidr, if defined.
        :param pulumi.Input[builtins.str] platform_reserved_cidr: IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. It must not overlap with any other Subnet IP ranges.
        :param pulumi.Input[builtins.str] platform_reserved_dns_ip: An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server
        """
        if app_subnet_resource_id is not None:
            pulumi.set(__self__, "app_subnet_resource_id", app_subnet_resource_id)
        if control_plane_subnet_resource_id is not None:
            pulumi.set(__self__, "control_plane_subnet_resource_id", control_plane_subnet_resource_id)
        if dapr_ai_instrumentation_key is not None:
            pulumi.set(__self__, "dapr_ai_instrumentation_key", dapr_ai_instrumentation_key)
        if docker_bridge_cidr is not None:
            pulumi.set(__self__, "docker_bridge_cidr", docker_bridge_cidr)
        if platform_reserved_cidr is not None:
            pulumi.set(__self__, "platform_reserved_cidr", platform_reserved_cidr)
        if platform_reserved_dns_ip is not None:
            pulumi.set(__self__, "platform_reserved_dns_ip", platform_reserved_dns_ip)

    @property
    @pulumi.getter(name="appSubnetResourceId")
    def app_subnet_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ID of a subnet for control plane infrastructure components. This subnet must be in the same VNET as the subnet defined in appSubnetResourceId. Must not overlap with the IP range defined in platformReservedCidr, if defined.
        """
        return pulumi.get(self, "app_subnet_resource_id")

    @app_subnet_resource_id.setter
    def app_subnet_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "app_subnet_resource_id", value)

    @property
    @pulumi.getter(name="controlPlaneSubnetResourceId")
    def control_plane_subnet_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ID of a subnet for control plane infrastructure components. This subnet must be in the same VNET as the subnet defined in appSubnetResourceId. Must not overlap with the IP range defined in platformReservedCidr, if defined.
        """
        return pulumi.get(self, "control_plane_subnet_resource_id")

    @control_plane_subnet_resource_id.setter
    def control_plane_subnet_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "control_plane_subnet_resource_id", value)

    @property
    @pulumi.getter(name="daprAIInstrumentationKey")
    def dapr_ai_instrumentation_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Azure Monitor instrumentation key used by Dapr to export Service to Service communication telemetry
        """
        return pulumi.get(self, "dapr_ai_instrumentation_key")

    @dapr_ai_instrumentation_key.setter
    def dapr_ai_instrumentation_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dapr_ai_instrumentation_key", value)

    @property
    @pulumi.getter(name="dockerBridgeCidr")
    def docker_bridge_cidr(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the IP range defined in platformReservedCidr, if defined.
        """
        return pulumi.get(self, "docker_bridge_cidr")

    @docker_bridge_cidr.setter
    def docker_bridge_cidr(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "docker_bridge_cidr", value)

    @property
    @pulumi.getter(name="platformReservedCidr")
    def platform_reserved_cidr(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. It must not overlap with any other Subnet IP ranges.
        """
        return pulumi.get(self, "platform_reserved_cidr")

    @platform_reserved_cidr.setter
    def platform_reserved_cidr(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "platform_reserved_cidr", value)

    @property
    @pulumi.getter(name="platformReservedDnsIP")
    def platform_reserved_dns_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server
        """
        return pulumi.get(self, "platform_reserved_dns_ip")

    @platform_reserved_dns_ip.setter
    def platform_reserved_dns_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "platform_reserved_dns_ip", value)


if not MYPY:
    class CookieExpirationArgsDict(TypedDict):
        """
        The configuration settings of the session cookie's expiration.
        """
        convention: NotRequired[pulumi.Input['CookieExpirationConvention']]
        """
        The convention used when determining the session cookie's expiration.
        """
        time_to_expiration: NotRequired[pulumi.Input[builtins.str]]
        """
        The time after the request is made when the session cookie should expire.
        """
elif False:
    CookieExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CookieExpirationArgs:
    def __init__(__self__, *,
                 convention: Optional[pulumi.Input['CookieExpirationConvention']] = None,
                 time_to_expiration: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the session cookie's expiration.
        :param pulumi.Input['CookieExpirationConvention'] convention: The convention used when determining the session cookie's expiration.
        :param pulumi.Input[builtins.str] time_to_expiration: The time after the request is made when the session cookie should expire.
        """
        if convention is not None:
            pulumi.set(__self__, "convention", convention)
        if time_to_expiration is not None:
            pulumi.set(__self__, "time_to_expiration", time_to_expiration)

    @property
    @pulumi.getter
    def convention(self) -> Optional[pulumi.Input['CookieExpirationConvention']]:
        """
        The convention used when determining the session cookie's expiration.
        """
        return pulumi.get(self, "convention")

    @convention.setter
    def convention(self, value: Optional[pulumi.Input['CookieExpirationConvention']]):
        pulumi.set(self, "convention", value)

    @property
    @pulumi.getter(name="timeToExpiration")
    def time_to_expiration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The time after the request is made when the session cookie should expire.
        """
        return pulumi.get(self, "time_to_expiration")

    @time_to_expiration.setter
    def time_to_expiration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_to_expiration", value)


if not MYPY:
    class CorsSettingsArgsDict(TypedDict):
        """
        Cross-Origin Resource Sharing (CORS) settings for the app.
        """
        allowed_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Gets or sets the list of origins that should be allowed to make cross-origin
        calls (for example: http://example.com:12345). Use "*" to allow all.
        """
        support_credentials: NotRequired[pulumi.Input[builtins.bool]]
        """
        Gets or sets whether CORS requests with credentials are allowed. See 
        https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
        for more details.
        """
elif False:
    CorsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CorsSettingsArgs:
    def __init__(__self__, *,
                 allowed_origins: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 support_credentials: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Cross-Origin Resource Sharing (CORS) settings for the app.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_origins: Gets or sets the list of origins that should be allowed to make cross-origin
               calls (for example: http://example.com:12345). Use "*" to allow all.
        :param pulumi.Input[builtins.bool] support_credentials: Gets or sets whether CORS requests with credentials are allowed. See 
               https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
               for more details.
        """
        if allowed_origins is not None:
            pulumi.set(__self__, "allowed_origins", allowed_origins)
        if support_credentials is not None:
            pulumi.set(__self__, "support_credentials", support_credentials)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Gets or sets the list of origins that should be allowed to make cross-origin
        calls (for example: http://example.com:12345). Use "*" to allow all.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="supportCredentials")
    def support_credentials(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Gets or sets whether CORS requests with credentials are allowed. See 
        https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
        for more details.
        """
        return pulumi.get(self, "support_credentials")

    @support_credentials.setter
    def support_credentials(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "support_credentials", value)


if not MYPY:
    class CustomApiPropertiesDefinitionArgsDict(TypedDict):
        """
        Custom API properties
        """
        api_definitions: NotRequired[pulumi.Input['ApiResourceDefinitionsArgsDict']]
        """
        API Definitions
        """
        api_type: NotRequired[pulumi.Input[Union[builtins.str, 'ApiType']]]
        """
        The API type
        """
        backend_service: NotRequired[pulumi.Input['ApiResourceBackendServiceArgsDict']]
        """
        The API backend service
        """
        brand_color: NotRequired[pulumi.Input[builtins.str]]
        """
        Brand color
        """
        capabilities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The custom API capabilities
        """
        connection_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['ConnectionParameterArgsDict']]]]
        """
        Connection parameters
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The custom API description
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The display name
        """
        icon_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        The icon URI
        """
        runtime_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Runtime URLs
        """
        swagger: NotRequired[Any]
        """
        The JSON representation of the swagger
        """
        wsdl_definition: NotRequired[pulumi.Input['WsdlDefinitionArgsDict']]
        """
        The WSDL definition
        """
elif False:
    CustomApiPropertiesDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomApiPropertiesDefinitionArgs:
    def __init__(__self__, *,
                 api_definitions: Optional[pulumi.Input['ApiResourceDefinitionsArgs']] = None,
                 api_type: Optional[pulumi.Input[Union[builtins.str, 'ApiType']]] = None,
                 backend_service: Optional[pulumi.Input['ApiResourceBackendServiceArgs']] = None,
                 brand_color: Optional[pulumi.Input[builtins.str]] = None,
                 capabilities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 connection_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['ConnectionParameterArgs']]]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 icon_uri: Optional[pulumi.Input[builtins.str]] = None,
                 runtime_urls: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 swagger: Optional[Any] = None,
                 wsdl_definition: Optional[pulumi.Input['WsdlDefinitionArgs']] = None):
        """
        Custom API properties
        :param pulumi.Input['ApiResourceDefinitionsArgs'] api_definitions: API Definitions
        :param pulumi.Input[Union[builtins.str, 'ApiType']] api_type: The API type
        :param pulumi.Input['ApiResourceBackendServiceArgs'] backend_service: The API backend service
        :param pulumi.Input[builtins.str] brand_color: Brand color
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] capabilities: The custom API capabilities
        :param pulumi.Input[Mapping[str, pulumi.Input['ConnectionParameterArgs']]] connection_parameters: Connection parameters
        :param pulumi.Input[builtins.str] description: The custom API description
        :param pulumi.Input[builtins.str] display_name: The display name
        :param pulumi.Input[builtins.str] icon_uri: The icon URI
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] runtime_urls: Runtime URLs
        :param Any swagger: The JSON representation of the swagger
        :param pulumi.Input['WsdlDefinitionArgs'] wsdl_definition: The WSDL definition
        """
        if api_definitions is not None:
            pulumi.set(__self__, "api_definitions", api_definitions)
        if api_type is not None:
            pulumi.set(__self__, "api_type", api_type)
        if backend_service is not None:
            pulumi.set(__self__, "backend_service", backend_service)
        if brand_color is not None:
            pulumi.set(__self__, "brand_color", brand_color)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if connection_parameters is not None:
            pulumi.set(__self__, "connection_parameters", connection_parameters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if icon_uri is not None:
            pulumi.set(__self__, "icon_uri", icon_uri)
        if runtime_urls is not None:
            pulumi.set(__self__, "runtime_urls", runtime_urls)
        if swagger is not None:
            pulumi.set(__self__, "swagger", swagger)
        if wsdl_definition is not None:
            pulumi.set(__self__, "wsdl_definition", wsdl_definition)

    @property
    @pulumi.getter(name="apiDefinitions")
    def api_definitions(self) -> Optional[pulumi.Input['ApiResourceDefinitionsArgs']]:
        """
        API Definitions
        """
        return pulumi.get(self, "api_definitions")

    @api_definitions.setter
    def api_definitions(self, value: Optional[pulumi.Input['ApiResourceDefinitionsArgs']]):
        pulumi.set(self, "api_definitions", value)

    @property
    @pulumi.getter(name="apiType")
    def api_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ApiType']]]:
        """
        The API type
        """
        return pulumi.get(self, "api_type")

    @api_type.setter
    def api_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ApiType']]]):
        pulumi.set(self, "api_type", value)

    @property
    @pulumi.getter(name="backendService")
    def backend_service(self) -> Optional[pulumi.Input['ApiResourceBackendServiceArgs']]:
        """
        The API backend service
        """
        return pulumi.get(self, "backend_service")

    @backend_service.setter
    def backend_service(self, value: Optional[pulumi.Input['ApiResourceBackendServiceArgs']]):
        pulumi.set(self, "backend_service", value)

    @property
    @pulumi.getter(name="brandColor")
    def brand_color(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Brand color
        """
        return pulumi.get(self, "brand_color")

    @brand_color.setter
    def brand_color(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "brand_color", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The custom API capabilities
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter(name="connectionParameters")
    def connection_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['ConnectionParameterArgs']]]]:
        """
        Connection parameters
        """
        return pulumi.get(self, "connection_parameters")

    @connection_parameters.setter
    def connection_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['ConnectionParameterArgs']]]]):
        pulumi.set(self, "connection_parameters", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The custom API description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The display name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="iconUri")
    def icon_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The icon URI
        """
        return pulumi.get(self, "icon_uri")

    @icon_uri.setter
    def icon_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "icon_uri", value)

    @property
    @pulumi.getter(name="runtimeUrls")
    def runtime_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Runtime URLs
        """
        return pulumi.get(self, "runtime_urls")

    @runtime_urls.setter
    def runtime_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "runtime_urls", value)

    @property
    @pulumi.getter
    def swagger(self) -> Optional[Any]:
        """
        The JSON representation of the swagger
        """
        return pulumi.get(self, "swagger")

    @swagger.setter
    def swagger(self, value: Optional[Any]):
        pulumi.set(self, "swagger", value)

    @property
    @pulumi.getter(name="wsdlDefinition")
    def wsdl_definition(self) -> Optional[pulumi.Input['WsdlDefinitionArgs']]:
        """
        The WSDL definition
        """
        return pulumi.get(self, "wsdl_definition")

    @wsdl_definition.setter
    def wsdl_definition(self, value: Optional[pulumi.Input['WsdlDefinitionArgs']]):
        pulumi.set(self, "wsdl_definition", value)


if not MYPY:
    class CustomDnsSuffixConfigurationArgsDict(TypedDict):
        """
        Full view of the custom domain suffix configuration for ASEv3.
        """
        certificate_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL referencing the Azure Key Vault certificate secret that should be used as the default SSL/TLS certificate for sites with the custom domain suffix.
        """
        dns_suffix: NotRequired[pulumi.Input[builtins.str]]
        """
        The default custom domain suffix to use for all sites deployed on the ASE.
        """
        key_vault_reference_identity: NotRequired[pulumi.Input[builtins.str]]
        """
        The user-assigned identity to use for resolving the key vault certificate reference. If not specified, the system-assigned ASE identity will be used if available.
        """
        kind: NotRequired[pulumi.Input[builtins.str]]
        """
        Kind of resource.
        """
elif False:
    CustomDnsSuffixConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDnsSuffixConfigurationArgs:
    def __init__(__self__, *,
                 certificate_url: Optional[pulumi.Input[builtins.str]] = None,
                 dns_suffix: Optional[pulumi.Input[builtins.str]] = None,
                 key_vault_reference_identity: Optional[pulumi.Input[builtins.str]] = None,
                 kind: Optional[pulumi.Input[builtins.str]] = None):
        """
        Full view of the custom domain suffix configuration for ASEv3.
        :param pulumi.Input[builtins.str] certificate_url: The URL referencing the Azure Key Vault certificate secret that should be used as the default SSL/TLS certificate for sites with the custom domain suffix.
        :param pulumi.Input[builtins.str] dns_suffix: The default custom domain suffix to use for all sites deployed on the ASE.
        :param pulumi.Input[builtins.str] key_vault_reference_identity: The user-assigned identity to use for resolving the key vault certificate reference. If not specified, the system-assigned ASE identity will be used if available.
        :param pulumi.Input[builtins.str] kind: Kind of resource.
        """
        if certificate_url is not None:
            pulumi.set(__self__, "certificate_url", certificate_url)
        if dns_suffix is not None:
            pulumi.set(__self__, "dns_suffix", dns_suffix)
        if key_vault_reference_identity is not None:
            pulumi.set(__self__, "key_vault_reference_identity", key_vault_reference_identity)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter(name="certificateUrl")
    def certificate_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL referencing the Azure Key Vault certificate secret that should be used as the default SSL/TLS certificate for sites with the custom domain suffix.
        """
        return pulumi.get(self, "certificate_url")

    @certificate_url.setter
    def certificate_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_url", value)

    @property
    @pulumi.getter(name="dnsSuffix")
    def dns_suffix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The default custom domain suffix to use for all sites deployed on the ASE.
        """
        return pulumi.get(self, "dns_suffix")

    @dns_suffix.setter
    def dns_suffix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dns_suffix", value)

    @property
    @pulumi.getter(name="keyVaultReferenceIdentity")
    def key_vault_reference_identity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The user-assigned identity to use for resolving the key vault certificate reference. If not specified, the system-assigned ASE identity will be used if available.
        """
        return pulumi.get(self, "key_vault_reference_identity")

    @key_vault_reference_identity.setter
    def key_vault_reference_identity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_vault_reference_identity", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class CustomOpenIdConnectProviderArgsDict(TypedDict):
        """
        The configuration settings of the custom Open ID Connect provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        """
        login: NotRequired[pulumi.Input['OpenIdConnectLoginArgsDict']]
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        """
        registration: NotRequired[pulumi.Input['OpenIdConnectRegistrationArgsDict']]
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        """
elif False:
    CustomOpenIdConnectProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomOpenIdConnectProviderArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 login: Optional[pulumi.Input['OpenIdConnectLoginArgs']] = None,
                 registration: Optional[pulumi.Input['OpenIdConnectRegistrationArgs']] = None):
        """
        The configuration settings of the custom Open ID Connect provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        :param pulumi.Input['OpenIdConnectLoginArgs'] login: The configuration settings of the login flow of the custom Open ID Connect provider.
        :param pulumi.Input['OpenIdConnectRegistrationArgs'] registration: The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['OpenIdConnectLoginArgs']]:
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['OpenIdConnectLoginArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['OpenIdConnectRegistrationArgs']]:
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['OpenIdConnectRegistrationArgs']]):
        pulumi.set(self, "registration", value)


if not MYPY:
    class DaprConfigArgsDict(TypedDict):
        """
        App Dapr configuration.
        """
        app_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Dapr application identifier
        """
        app_port: NotRequired[pulumi.Input[builtins.int]]
        """
        Tells Dapr which port your application is listening on
        """
        enable_api_logging: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables API logging for the Dapr sidecar
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Boolean indicating if the Dapr side car is enabled
        """
        http_max_request_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Increasing max size of request body http servers parameter in MB to handle uploading of big files. Default is 4 MB.
        """
        http_read_buffer_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        """
        log_level: NotRequired[pulumi.Input[Union[builtins.str, 'DaprLogLevel']]]
        """
        Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        """
elif False:
    DaprConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DaprConfigArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[builtins.str]] = None,
                 app_port: Optional[pulumi.Input[builtins.int]] = None,
                 enable_api_logging: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 http_max_request_size: Optional[pulumi.Input[builtins.int]] = None,
                 http_read_buffer_size: Optional[pulumi.Input[builtins.int]] = None,
                 log_level: Optional[pulumi.Input[Union[builtins.str, 'DaprLogLevel']]] = None):
        """
        App Dapr configuration.
        :param pulumi.Input[builtins.str] app_id: Dapr application identifier
        :param pulumi.Input[builtins.int] app_port: Tells Dapr which port your application is listening on
        :param pulumi.Input[builtins.bool] enable_api_logging: Enables API logging for the Dapr sidecar
        :param pulumi.Input[builtins.bool] enabled: Boolean indicating if the Dapr side car is enabled
        :param pulumi.Input[builtins.int] http_max_request_size: Increasing max size of request body http servers parameter in MB to handle uploading of big files. Default is 4 MB.
        :param pulumi.Input[builtins.int] http_read_buffer_size: Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        :param pulumi.Input[Union[builtins.str, 'DaprLogLevel']] log_level: Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_port is not None:
            pulumi.set(__self__, "app_port", app_port)
        if enable_api_logging is not None:
            pulumi.set(__self__, "enable_api_logging", enable_api_logging)
        if enabled is None:
            enabled = False
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if http_max_request_size is not None:
            pulumi.set(__self__, "http_max_request_size", http_max_request_size)
        if http_read_buffer_size is not None:
            pulumi.set(__self__, "http_read_buffer_size", http_read_buffer_size)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Dapr application identifier
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appPort")
    def app_port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Tells Dapr which port your application is listening on
        """
        return pulumi.get(self, "app_port")

    @app_port.setter
    def app_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "app_port", value)

    @property
    @pulumi.getter(name="enableApiLogging")
    def enable_api_logging(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables API logging for the Dapr sidecar
        """
        return pulumi.get(self, "enable_api_logging")

    @enable_api_logging.setter
    def enable_api_logging(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_api_logging", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Boolean indicating if the Dapr side car is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="httpMaxRequestSize")
    def http_max_request_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Increasing max size of request body http servers parameter in MB to handle uploading of big files. Default is 4 MB.
        """
        return pulumi.get(self, "http_max_request_size")

    @http_max_request_size.setter
    def http_max_request_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "http_max_request_size", value)

    @property
    @pulumi.getter(name="httpReadBufferSize")
    def http_read_buffer_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        """
        return pulumi.get(self, "http_read_buffer_size")

    @http_read_buffer_size.setter
    def http_read_buffer_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "http_read_buffer_size", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[Union[builtins.str, 'DaprLogLevel']]]:
        """
        Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[Union[builtins.str, 'DaprLogLevel']]]):
        pulumi.set(self, "log_level", value)


if not MYPY:
    class DatabaseBackupSettingDict(TypedDict):
        """
        Database backup settings.
        """
        database_type: Union[builtins.str, 'DatabaseType']
        """
        Database type (e.g. SqlAzure / MySql).
        """
        connection_string: NotRequired[builtins.str]
        """
        Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        """
        connection_string_name: NotRequired[builtins.str]
        """
        Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
        This is used during restore with overwrite connection strings options.
        """
        name: NotRequired[builtins.str]
elif False:
    DatabaseBackupSettingDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseBackupSetting:
    def __init__(__self__, *,
                 database_type: Union[builtins.str, 'DatabaseType'],
                 connection_string: Optional[builtins.str] = None,
                 connection_string_name: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        """
        Database backup settings.
        :param Union[builtins.str, 'DatabaseType'] database_type: Database type (e.g. SqlAzure / MySql).
        :param builtins.str connection_string: Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        :param builtins.str connection_string_name: Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
               This is used during restore with overwrite connection strings options.
        """
        pulumi.set(__self__, "database_type", database_type)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if connection_string_name is not None:
            pulumi.set(__self__, "connection_string_name", connection_string_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> Union[builtins.str, 'DatabaseType']:
        """
        Database type (e.g. SqlAzure / MySql).
        """
        return pulumi.get(self, "database_type")

    @database_type.setter
    def database_type(self, value: Union[builtins.str, 'DatabaseType']):
        pulumi.set(self, "database_type", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[builtins.str]:
        """
        Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[builtins.str]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter(name="connectionStringName")
    def connection_string_name(self) -> Optional[builtins.str]:
        """
        Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
        This is used during restore with overwrite connection strings options.
        """
        return pulumi.get(self, "connection_string_name")

    @connection_string_name.setter
    def connection_string_name(self, value: Optional[builtins.str]):
        pulumi.set(self, "connection_string_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DatabaseBackupSettingArgsDict(TypedDict):
        """
        Database backup settings.
        """
        database_type: pulumi.Input[Union[builtins.str, 'DatabaseType']]
        """
        Database type (e.g. SqlAzure / MySql).
        """
        connection_string: NotRequired[pulumi.Input[builtins.str]]
        """
        Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        """
        connection_string_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
        This is used during restore with overwrite connection strings options.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DatabaseBackupSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseBackupSettingArgs:
    def __init__(__self__, *,
                 database_type: pulumi.Input[Union[builtins.str, 'DatabaseType']],
                 connection_string: Optional[pulumi.Input[builtins.str]] = None,
                 connection_string_name: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Database backup settings.
        :param pulumi.Input[Union[builtins.str, 'DatabaseType']] database_type: Database type (e.g. SqlAzure / MySql).
        :param pulumi.Input[builtins.str] connection_string: Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        :param pulumi.Input[builtins.str] connection_string_name: Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
               This is used during restore with overwrite connection strings options.
        """
        pulumi.set(__self__, "database_type", database_type)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if connection_string_name is not None:
            pulumi.set(__self__, "connection_string_name", connection_string_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> pulumi.Input[Union[builtins.str, 'DatabaseType']]:
        """
        Database type (e.g. SqlAzure / MySql).
        """
        return pulumi.get(self, "database_type")

    @database_type.setter
    def database_type(self, value: pulumi.Input[Union[builtins.str, 'DatabaseType']]):
        pulumi.set(self, "database_type", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Contains a connection string to a database which is being backed up or restored. If the restore should happen to a new database, the database name inside is the new one.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter(name="connectionStringName")
    def connection_string_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Contains a connection string name that is linked to the SiteConfig.ConnectionStrings.
        This is used during restore with overwrite connection strings options.
        """
        return pulumi.get(self, "connection_string_name")

    @connection_string_name.setter
    def connection_string_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connection_string_name", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DefaultAuthorizationPolicyArgsDict(TypedDict):
        """
        The configuration settings of the Azure Active Directory default authorization policy.
        """
        allowed_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The configuration settings of the Azure Active Directory allowed applications.
        """
        allowed_principals: NotRequired[pulumi.Input['AllowedPrincipalsArgsDict']]
        """
        The configuration settings of the Azure Active Directory allowed principals.
        """
elif False:
    DefaultAuthorizationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefaultAuthorizationPolicyArgs:
    def __init__(__self__, *,
                 allowed_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 allowed_principals: Optional[pulumi.Input['AllowedPrincipalsArgs']] = None):
        """
        The configuration settings of the Azure Active Directory default authorization policy.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_applications: The configuration settings of the Azure Active Directory allowed applications.
        :param pulumi.Input['AllowedPrincipalsArgs'] allowed_principals: The configuration settings of the Azure Active Directory allowed principals.
        """
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_principals is not None:
            pulumi.set(__self__, "allowed_principals", allowed_principals)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The configuration settings of the Azure Active Directory allowed applications.
        """
        return pulumi.get(self, "allowed_applications")

    @allowed_applications.setter
    def allowed_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_applications", value)

    @property
    @pulumi.getter(name="allowedPrincipals")
    def allowed_principals(self) -> Optional[pulumi.Input['AllowedPrincipalsArgs']]:
        """
        The configuration settings of the Azure Active Directory allowed principals.
        """
        return pulumi.get(self, "allowed_principals")

    @allowed_principals.setter
    def allowed_principals(self, value: Optional[pulumi.Input['AllowedPrincipalsArgs']]):
        pulumi.set(self, "allowed_principals", value)


if not MYPY:
    class EnabledConfigArgsDict(TypedDict):
        """
        Enabled configuration.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
elif False:
    EnabledConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnabledConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Enabled configuration.
        :param pulumi.Input[builtins.bool] enabled: True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class EnvironmentVariableArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Environment variable name
        """
        value: pulumi.Input[builtins.str]
        """
        Environment variable value
        """
elif False:
    EnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] name: Environment variable name
        :param pulumi.Input[builtins.str] value: Environment variable value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Environment variable name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Environment variable value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ExperimentsArgsDict(TypedDict):
        """
        Routing rules in production experiments.
        """
        ramp_up_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['RampUpRuleArgsDict']]]]
        """
        List of ramp-up rules.
        """
elif False:
    ExperimentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExperimentsArgs:
    def __init__(__self__, *,
                 ramp_up_rules: Optional[pulumi.Input[Sequence[pulumi.Input['RampUpRuleArgs']]]] = None):
        """
        Routing rules in production experiments.
        :param pulumi.Input[Sequence[pulumi.Input['RampUpRuleArgs']]] ramp_up_rules: List of ramp-up rules.
        """
        if ramp_up_rules is not None:
            pulumi.set(__self__, "ramp_up_rules", ramp_up_rules)

    @property
    @pulumi.getter(name="rampUpRules")
    def ramp_up_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RampUpRuleArgs']]]]:
        """
        List of ramp-up rules.
        """
        return pulumi.get(self, "ramp_up_rules")

    @ramp_up_rules.setter
    def ramp_up_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RampUpRuleArgs']]]]):
        pulumi.set(self, "ramp_up_rules", value)


if not MYPY:
    class ExtendedLocationArgsDict(TypedDict):
        """
        Extended Location.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of extended location.
        """
elif False:
    ExtendedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtendedLocationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Extended Location.
        :param pulumi.Input[builtins.str] name: Name of extended location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of extended location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FacebookArgsDict(TypedDict):
        """
        The configuration settings of the Facebook provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        graph_api_version: NotRequired[pulumi.Input[builtins.str]]
        """
        The version of the Facebook api to be used while logging in.
        """
        login: NotRequired[pulumi.Input['LoginScopesArgsDict']]
        """
        The configuration settings of the login flow.
        """
        registration: NotRequired[pulumi.Input['AppRegistrationArgsDict']]
        """
        The configuration settings of the app registration for the Facebook provider.
        """
elif False:
    FacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FacebookArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 graph_api_version: Optional[pulumi.Input[builtins.str]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['AppRegistrationArgs']] = None):
        """
        The configuration settings of the Facebook provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input[builtins.str] graph_api_version: The version of the Facebook api to be used while logging in.
        :param pulumi.Input['LoginScopesArgs'] login: The configuration settings of the login flow.
        :param pulumi.Input['AppRegistrationArgs'] registration: The configuration settings of the app registration for the Facebook provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The version of the Facebook api to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @graph_api_version.setter
    def graph_api_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "graph_api_version", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AppRegistrationArgs']]:
        """
        The configuration settings of the app registration for the Facebook provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AppRegistrationArgs']]):
        pulumi.set(self, "registration", value)


if not MYPY:
    class FileSystemApplicationLogsConfigArgsDict(TypedDict):
        """
        Application logs to file system configuration.
        """
        level: NotRequired[pulumi.Input['LogLevel']]
        """
        Log level.
        """
elif False:
    FileSystemApplicationLogsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileSystemApplicationLogsConfigArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input['LogLevel']] = None):
        """
        Application logs to file system configuration.
        :param pulumi.Input['LogLevel'] level: Log level.
        """
        if level is None:
            level = 'Off'
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input['LogLevel']]:
        """
        Log level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input['LogLevel']]):
        pulumi.set(self, "level", value)


if not MYPY:
    class FileSystemHttpLogsConfigArgsDict(TypedDict):
        """
        Http logs to file system configuration.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        retention_in_days: NotRequired[pulumi.Input[builtins.int]]
        """
        Retention in days.
        Remove files older than X days.
        0 or lower means no retention.
        """
        retention_in_mb: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum size in megabytes that http log files can use.
        When reached old log files will be removed to make space for new ones.
        Value can range between 25 and 100.
        """
elif False:
    FileSystemHttpLogsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileSystemHttpLogsConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 retention_in_days: Optional[pulumi.Input[builtins.int]] = None,
                 retention_in_mb: Optional[pulumi.Input[builtins.int]] = None):
        """
        Http logs to file system configuration.
        :param pulumi.Input[builtins.bool] enabled: True if configuration is enabled, false if it is disabled and null if configuration is not set.
        :param pulumi.Input[builtins.int] retention_in_days: Retention in days.
               Remove files older than X days.
               0 or lower means no retention.
        :param pulumi.Input[builtins.int] retention_in_mb: Maximum size in megabytes that http log files can use.
               When reached old log files will be removed to make space for new ones.
               Value can range between 25 and 100.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if retention_in_mb is not None:
            pulumi.set(__self__, "retention_in_mb", retention_in_mb)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        True if configuration is enabled, false if it is disabled and null if configuration is not set.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Retention in days.
        Remove files older than X days.
        0 or lower means no retention.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="retentionInMb")
    def retention_in_mb(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum size in megabytes that http log files can use.
        When reached old log files will be removed to make space for new ones.
        Value can range between 25 and 100.
        """
        return pulumi.get(self, "retention_in_mb")

    @retention_in_mb.setter
    def retention_in_mb(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retention_in_mb", value)


if not MYPY:
    class FileSystemTokenStoreArgsDict(TypedDict):
        """
        The configuration settings of the storage of the tokens if a file system is used.
        """
        directory: NotRequired[pulumi.Input[builtins.str]]
        """
        The directory in which the tokens will be stored.
        """
elif False:
    FileSystemTokenStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileSystemTokenStoreArgs:
    def __init__(__self__, *,
                 directory: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the storage of the tokens if a file system is used.
        :param pulumi.Input[builtins.str] directory: The directory in which the tokens will be stored.
        """
        if directory is not None:
            pulumi.set(__self__, "directory", directory)

    @property
    @pulumi.getter
    def directory(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The directory in which the tokens will be stored.
        """
        return pulumi.get(self, "directory")

    @directory.setter
    def directory(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "directory", value)


if not MYPY:
    class ForwardProxyArgsDict(TypedDict):
        """
        The configuration settings of a forward proxy used to make the requests.
        """
        convention: NotRequired[pulumi.Input['ForwardProxyConvention']]
        """
        The convention used to determine the url of the request made.
        """
        custom_host_header_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the header containing the host of the request.
        """
        custom_proto_header_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the header containing the scheme of the request.
        """
elif False:
    ForwardProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardProxyArgs:
    def __init__(__self__, *,
                 convention: Optional[pulumi.Input['ForwardProxyConvention']] = None,
                 custom_host_header_name: Optional[pulumi.Input[builtins.str]] = None,
                 custom_proto_header_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of a forward proxy used to make the requests.
        :param pulumi.Input['ForwardProxyConvention'] convention: The convention used to determine the url of the request made.
        :param pulumi.Input[builtins.str] custom_host_header_name: The name of the header containing the host of the request.
        :param pulumi.Input[builtins.str] custom_proto_header_name: The name of the header containing the scheme of the request.
        """
        if convention is not None:
            pulumi.set(__self__, "convention", convention)
        if custom_host_header_name is not None:
            pulumi.set(__self__, "custom_host_header_name", custom_host_header_name)
        if custom_proto_header_name is not None:
            pulumi.set(__self__, "custom_proto_header_name", custom_proto_header_name)

    @property
    @pulumi.getter
    def convention(self) -> Optional[pulumi.Input['ForwardProxyConvention']]:
        """
        The convention used to determine the url of the request made.
        """
        return pulumi.get(self, "convention")

    @convention.setter
    def convention(self, value: Optional[pulumi.Input['ForwardProxyConvention']]):
        pulumi.set(self, "convention", value)

    @property
    @pulumi.getter(name="customHostHeaderName")
    def custom_host_header_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the header containing the host of the request.
        """
        return pulumi.get(self, "custom_host_header_name")

    @custom_host_header_name.setter
    def custom_host_header_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_host_header_name", value)

    @property
    @pulumi.getter(name="customProtoHeaderName")
    def custom_proto_header_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the header containing the scheme of the request.
        """
        return pulumi.get(self, "custom_proto_header_name")

    @custom_proto_header_name.setter
    def custom_proto_header_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_proto_header_name", value)


if not MYPY:
    class FrontEndConfigurationArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input['FrontEndServiceType']]
elif False:
    FrontEndConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FrontEndConfigurationArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input['FrontEndServiceType']] = None):
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input['FrontEndServiceType']]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input['FrontEndServiceType']]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class FunctionAppConfigArgsDict(TypedDict):
        """
        Function app configuration.
        """
        deployment: NotRequired[pulumi.Input['FunctionsDeploymentArgsDict']]
        """
        Function app deployment configuration.
        """
        runtime: NotRequired[pulumi.Input['FunctionsRuntimeArgsDict']]
        """
        Function app runtime settings.
        """
        scale_and_concurrency: NotRequired[pulumi.Input['FunctionsScaleAndConcurrencyArgsDict']]
        """
        Function app scale and concurrency settings.
        """
elif False:
    FunctionAppConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAppConfigArgs:
    def __init__(__self__, *,
                 deployment: Optional[pulumi.Input['FunctionsDeploymentArgs']] = None,
                 runtime: Optional[pulumi.Input['FunctionsRuntimeArgs']] = None,
                 scale_and_concurrency: Optional[pulumi.Input['FunctionsScaleAndConcurrencyArgs']] = None):
        """
        Function app configuration.
        :param pulumi.Input['FunctionsDeploymentArgs'] deployment: Function app deployment configuration.
        :param pulumi.Input['FunctionsRuntimeArgs'] runtime: Function app runtime settings.
        :param pulumi.Input['FunctionsScaleAndConcurrencyArgs'] scale_and_concurrency: Function app scale and concurrency settings.
        """
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)
        if scale_and_concurrency is not None:
            pulumi.set(__self__, "scale_and_concurrency", scale_and_concurrency)

    @property
    @pulumi.getter
    def deployment(self) -> Optional[pulumi.Input['FunctionsDeploymentArgs']]:
        """
        Function app deployment configuration.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: Optional[pulumi.Input['FunctionsDeploymentArgs']]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter
    def runtime(self) -> Optional[pulumi.Input['FunctionsRuntimeArgs']]:
        """
        Function app runtime settings.
        """
        return pulumi.get(self, "runtime")

    @runtime.setter
    def runtime(self, value: Optional[pulumi.Input['FunctionsRuntimeArgs']]):
        pulumi.set(self, "runtime", value)

    @property
    @pulumi.getter(name="scaleAndConcurrency")
    def scale_and_concurrency(self) -> Optional[pulumi.Input['FunctionsScaleAndConcurrencyArgs']]:
        """
        Function app scale and concurrency settings.
        """
        return pulumi.get(self, "scale_and_concurrency")

    @scale_and_concurrency.setter
    def scale_and_concurrency(self, value: Optional[pulumi.Input['FunctionsScaleAndConcurrencyArgs']]):
        pulumi.set(self, "scale_and_concurrency", value)


if not MYPY:
    class FunctionsAlwaysReadyConfigArgsDict(TypedDict):
        """
        Sets the number of 'Always Ready' instances for a function group or a specific function.
        """
        instance_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Sets the number of 'Always Ready' instances for a given function group or a specific function. For additional information see https://aka.ms/flexconsumption/alwaysready.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Either a function group or a function name is required. For additional information see https://aka.ms/flexconsumption/alwaysready.
        """
elif False:
    FunctionsAlwaysReadyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionsAlwaysReadyConfigArgs:
    def __init__(__self__, *,
                 instance_count: Optional[pulumi.Input[builtins.int]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Sets the number of 'Always Ready' instances for a function group or a specific function.
        :param pulumi.Input[builtins.int] instance_count: Sets the number of 'Always Ready' instances for a given function group or a specific function. For additional information see https://aka.ms/flexconsumption/alwaysready.
        :param pulumi.Input[builtins.str] name: Either a function group or a function name is required. For additional information see https://aka.ms/flexconsumption/alwaysready.
        """
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Sets the number of 'Always Ready' instances for a given function group or a specific function. For additional information see https://aka.ms/flexconsumption/alwaysready.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Either a function group or a function name is required. For additional information see https://aka.ms/flexconsumption/alwaysready.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FunctionsDeploymentAuthenticationArgsDict(TypedDict):
        """
        Authentication method to access the storage account for deployment.
        """
        storage_account_connection_string_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Use this property for StorageAccountConnectionString. Set the name of the app setting that has the storage account connection string. Do not set a value for this property when using other authentication type.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'AuthenticationType']]]
        """
        Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity, UserAssignedIdentity, StorageAccountConnectionString.
        """
        user_assigned_identity_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Use this property for UserAssignedIdentity. Set the resource ID of the identity. Do not set a value for this property when using other authentication type.
        """
elif False:
    FunctionsDeploymentAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionsDeploymentAuthenticationArgs:
    def __init__(__self__, *,
                 storage_account_connection_string_name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'AuthenticationType']]] = None,
                 user_assigned_identity_resource_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Authentication method to access the storage account for deployment.
        :param pulumi.Input[builtins.str] storage_account_connection_string_name: Use this property for StorageAccountConnectionString. Set the name of the app setting that has the storage account connection string. Do not set a value for this property when using other authentication type.
        :param pulumi.Input[Union[builtins.str, 'AuthenticationType']] type: Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity, UserAssignedIdentity, StorageAccountConnectionString.
        :param pulumi.Input[builtins.str] user_assigned_identity_resource_id: Use this property for UserAssignedIdentity. Set the resource ID of the identity. Do not set a value for this property when using other authentication type.
        """
        if storage_account_connection_string_name is not None:
            pulumi.set(__self__, "storage_account_connection_string_name", storage_account_connection_string_name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identity_resource_id is not None:
            pulumi.set(__self__, "user_assigned_identity_resource_id", user_assigned_identity_resource_id)

    @property
    @pulumi.getter(name="storageAccountConnectionStringName")
    def storage_account_connection_string_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Use this property for StorageAccountConnectionString. Set the name of the app setting that has the storage account connection string. Do not set a value for this property when using other authentication type.
        """
        return pulumi.get(self, "storage_account_connection_string_name")

    @storage_account_connection_string_name.setter
    def storage_account_connection_string_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "storage_account_connection_string_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'AuthenticationType']]]:
        """
        Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity, UserAssignedIdentity, StorageAccountConnectionString.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'AuthenticationType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentityResourceId")
    def user_assigned_identity_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Use this property for UserAssignedIdentity. Set the resource ID of the identity. Do not set a value for this property when using other authentication type.
        """
        return pulumi.get(self, "user_assigned_identity_resource_id")

    @user_assigned_identity_resource_id.setter
    def user_assigned_identity_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_assigned_identity_resource_id", value)


if not MYPY:
    class FunctionsDeploymentStorageArgsDict(TypedDict):
        """
        Storage for deployed package used by the function app.
        """
        authentication: NotRequired[pulumi.Input['FunctionsDeploymentAuthenticationArgsDict']]
        """
        Authentication method to access the storage account for deployment.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'FunctionsDeploymentStorageType']]]
        """
        Property to select Azure Storage type. Available options: blobContainer.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Property to set the URL for the selected Azure Storage type. Example: For blobContainer, the value could be https://<storageAccountName>.blob.core.windows.net/<containerName>.
        """
elif False:
    FunctionsDeploymentStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionsDeploymentStorageArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['FunctionsDeploymentAuthenticationArgs']] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'FunctionsDeploymentStorageType']]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Storage for deployed package used by the function app.
        :param pulumi.Input['FunctionsDeploymentAuthenticationArgs'] authentication: Authentication method to access the storage account for deployment.
        :param pulumi.Input[Union[builtins.str, 'FunctionsDeploymentStorageType']] type: Property to select Azure Storage type. Available options: blobContainer.
        :param pulumi.Input[builtins.str] value: Property to set the URL for the selected Azure Storage type. Example: For blobContainer, the value could be https://<storageAccountName>.blob.core.windows.net/<containerName>.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['FunctionsDeploymentAuthenticationArgs']]:
        """
        Authentication method to access the storage account for deployment.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['FunctionsDeploymentAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'FunctionsDeploymentStorageType']]]:
        """
        Property to select Azure Storage type. Available options: blobContainer.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'FunctionsDeploymentStorageType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Property to set the URL for the selected Azure Storage type. Example: For blobContainer, the value could be https://<storageAccountName>.blob.core.windows.net/<containerName>.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FunctionsDeploymentArgsDict(TypedDict):
        """
        Configuration section for the function app deployment.
        """
        storage: NotRequired[pulumi.Input['FunctionsDeploymentStorageArgsDict']]
        """
        Storage for deployed package used by the function app.
        """
elif False:
    FunctionsDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionsDeploymentArgs:
    def __init__(__self__, *,
                 storage: Optional[pulumi.Input['FunctionsDeploymentStorageArgs']] = None):
        """
        Configuration section for the function app deployment.
        :param pulumi.Input['FunctionsDeploymentStorageArgs'] storage: Storage for deployed package used by the function app.
        """
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input['FunctionsDeploymentStorageArgs']]:
        """
        Storage for deployed package used by the function app.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input['FunctionsDeploymentStorageArgs']]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class FunctionsRuntimeArgsDict(TypedDict):
        """
        Function app runtime name and version.
        """
        name: NotRequired[pulumi.Input[Union[builtins.str, 'RuntimeName']]]
        """
        Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Function app runtime version. Example: 8 (for dotnet-isolated)
        """
elif False:
    FunctionsRuntimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionsRuntimeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[Union[builtins.str, 'RuntimeName']]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        Function app runtime name and version.
        :param pulumi.Input[Union[builtins.str, 'RuntimeName']] name: Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom
        :param pulumi.Input[builtins.str] version: Function app runtime version. Example: 8 (for dotnet-isolated)
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[Union[builtins.str, 'RuntimeName']]]:
        """
        Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[Union[builtins.str, 'RuntimeName']]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Function app runtime version. Example: 8 (for dotnet-isolated)
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class FunctionsScaleAndConcurrencyHttpArgsDict(TypedDict):
        """
        Scale and concurrency settings for the HTTP trigger.
        """
        per_instance_concurrency: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of concurrent HTTP trigger invocations per instance.
        """
elif False:
    FunctionsScaleAndConcurrencyHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionsScaleAndConcurrencyHttpArgs:
    def __init__(__self__, *,
                 per_instance_concurrency: Optional[pulumi.Input[builtins.int]] = None):
        """
        Scale and concurrency settings for the HTTP trigger.
        :param pulumi.Input[builtins.int] per_instance_concurrency: The maximum number of concurrent HTTP trigger invocations per instance.
        """
        if per_instance_concurrency is not None:
            pulumi.set(__self__, "per_instance_concurrency", per_instance_concurrency)

    @property
    @pulumi.getter(name="perInstanceConcurrency")
    def per_instance_concurrency(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of concurrent HTTP trigger invocations per instance.
        """
        return pulumi.get(self, "per_instance_concurrency")

    @per_instance_concurrency.setter
    def per_instance_concurrency(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "per_instance_concurrency", value)


if not MYPY:
    class FunctionsScaleAndConcurrencyTriggersArgsDict(TypedDict):
        """
        Scale and concurrency settings for the function app triggers.
        """
        http: NotRequired[pulumi.Input['FunctionsScaleAndConcurrencyHttpArgsDict']]
        """
        Scale and concurrency settings for the HTTP trigger.
        """
elif False:
    FunctionsScaleAndConcurrencyTriggersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionsScaleAndConcurrencyTriggersArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input['FunctionsScaleAndConcurrencyHttpArgs']] = None):
        """
        Scale and concurrency settings for the function app triggers.
        :param pulumi.Input['FunctionsScaleAndConcurrencyHttpArgs'] http: Scale and concurrency settings for the HTTP trigger.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['FunctionsScaleAndConcurrencyHttpArgs']]:
        """
        Scale and concurrency settings for the HTTP trigger.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['FunctionsScaleAndConcurrencyHttpArgs']]):
        pulumi.set(self, "http", value)


if not MYPY:
    class FunctionsScaleAndConcurrencyArgsDict(TypedDict):
        """
        Scale and concurrency settings for the function app.
        """
        always_ready: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionsAlwaysReadyConfigArgsDict']]]]
        """
        'Always Ready' configuration for the function app.
        """
        instance_memory_mb: NotRequired[pulumi.Input[builtins.int]]
        """
        Set the amount of memory allocated to each instance of the function app in MB. CPU and network bandwidth are allocated proportionally.
        """
        maximum_instance_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of instances for the function app.
        """
        triggers: NotRequired[pulumi.Input['FunctionsScaleAndConcurrencyTriggersArgsDict']]
        """
        Scale and concurrency settings for the function app triggers.
        """
elif False:
    FunctionsScaleAndConcurrencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionsScaleAndConcurrencyArgs:
    def __init__(__self__, *,
                 always_ready: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionsAlwaysReadyConfigArgs']]]] = None,
                 instance_memory_mb: Optional[pulumi.Input[builtins.int]] = None,
                 maximum_instance_count: Optional[pulumi.Input[builtins.int]] = None,
                 triggers: Optional[pulumi.Input['FunctionsScaleAndConcurrencyTriggersArgs']] = None):
        """
        Scale and concurrency settings for the function app.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionsAlwaysReadyConfigArgs']]] always_ready: 'Always Ready' configuration for the function app.
        :param pulumi.Input[builtins.int] instance_memory_mb: Set the amount of memory allocated to each instance of the function app in MB. CPU and network bandwidth are allocated proportionally.
        :param pulumi.Input[builtins.int] maximum_instance_count: The maximum number of instances for the function app.
        :param pulumi.Input['FunctionsScaleAndConcurrencyTriggersArgs'] triggers: Scale and concurrency settings for the function app triggers.
        """
        if always_ready is not None:
            pulumi.set(__self__, "always_ready", always_ready)
        if instance_memory_mb is not None:
            pulumi.set(__self__, "instance_memory_mb", instance_memory_mb)
        if maximum_instance_count is not None:
            pulumi.set(__self__, "maximum_instance_count", maximum_instance_count)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @property
    @pulumi.getter(name="alwaysReady")
    def always_ready(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionsAlwaysReadyConfigArgs']]]]:
        """
        'Always Ready' configuration for the function app.
        """
        return pulumi.get(self, "always_ready")

    @always_ready.setter
    def always_ready(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionsAlwaysReadyConfigArgs']]]]):
        pulumi.set(self, "always_ready", value)

    @property
    @pulumi.getter(name="instanceMemoryMB")
    def instance_memory_mb(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Set the amount of memory allocated to each instance of the function app in MB. CPU and network bandwidth are allocated proportionally.
        """
        return pulumi.get(self, "instance_memory_mb")

    @instance_memory_mb.setter
    def instance_memory_mb(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "instance_memory_mb", value)

    @property
    @pulumi.getter(name="maximumInstanceCount")
    def maximum_instance_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of instances for the function app.
        """
        return pulumi.get(self, "maximum_instance_count")

    @maximum_instance_count.setter
    def maximum_instance_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "maximum_instance_count", value)

    @property
    @pulumi.getter
    def triggers(self) -> Optional[pulumi.Input['FunctionsScaleAndConcurrencyTriggersArgs']]:
        """
        Scale and concurrency settings for the function app triggers.
        """
        return pulumi.get(self, "triggers")

    @triggers.setter
    def triggers(self, value: Optional[pulumi.Input['FunctionsScaleAndConcurrencyTriggersArgs']]):
        pulumi.set(self, "triggers", value)


if not MYPY:
    class GitHubActionCodeConfigurationArgsDict(TypedDict):
        """
        The GitHub action code configuration.
        """
        runtime_stack: NotRequired[pulumi.Input[builtins.str]]
        """
        Runtime stack is used to determine the workflow file content for code base apps.
        """
        runtime_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Runtime version is used to determine what build version to set in the workflow file.
        """
elif False:
    GitHubActionCodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitHubActionCodeConfigurationArgs:
    def __init__(__self__, *,
                 runtime_stack: Optional[pulumi.Input[builtins.str]] = None,
                 runtime_version: Optional[pulumi.Input[builtins.str]] = None):
        """
        The GitHub action code configuration.
        :param pulumi.Input[builtins.str] runtime_stack: Runtime stack is used to determine the workflow file content for code base apps.
        :param pulumi.Input[builtins.str] runtime_version: Runtime version is used to determine what build version to set in the workflow file.
        """
        if runtime_stack is not None:
            pulumi.set(__self__, "runtime_stack", runtime_stack)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="runtimeStack")
    def runtime_stack(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Runtime stack is used to determine the workflow file content for code base apps.
        """
        return pulumi.get(self, "runtime_stack")

    @runtime_stack.setter
    def runtime_stack(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "runtime_stack", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Runtime version is used to determine what build version to set in the workflow file.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "runtime_version", value)


if not MYPY:
    class GitHubActionConfigurationArgsDict(TypedDict):
        """
        The GitHub action configuration.
        """
        code_configuration: NotRequired[pulumi.Input['GitHubActionCodeConfigurationArgsDict']]
        """
        GitHub Action code configuration.
        """
        container_configuration: NotRequired[pulumi.Input['GitHubActionContainerConfigurationArgsDict']]
        """
        GitHub Action container configuration.
        """
        generate_workflow_file: NotRequired[pulumi.Input[builtins.bool]]
        """
        Workflow option to determine whether the workflow file should be generated and written to the repository.
        """
        is_linux: NotRequired[pulumi.Input[builtins.bool]]
        """
        This will help determine the workflow configuration to select.
        """
elif False:
    GitHubActionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitHubActionConfigurationArgs:
    def __init__(__self__, *,
                 code_configuration: Optional[pulumi.Input['GitHubActionCodeConfigurationArgs']] = None,
                 container_configuration: Optional[pulumi.Input['GitHubActionContainerConfigurationArgs']] = None,
                 generate_workflow_file: Optional[pulumi.Input[builtins.bool]] = None,
                 is_linux: Optional[pulumi.Input[builtins.bool]] = None):
        """
        The GitHub action configuration.
        :param pulumi.Input['GitHubActionCodeConfigurationArgs'] code_configuration: GitHub Action code configuration.
        :param pulumi.Input['GitHubActionContainerConfigurationArgs'] container_configuration: GitHub Action container configuration.
        :param pulumi.Input[builtins.bool] generate_workflow_file: Workflow option to determine whether the workflow file should be generated and written to the repository.
        :param pulumi.Input[builtins.bool] is_linux: This will help determine the workflow configuration to select.
        """
        if code_configuration is not None:
            pulumi.set(__self__, "code_configuration", code_configuration)
        if container_configuration is not None:
            pulumi.set(__self__, "container_configuration", container_configuration)
        if generate_workflow_file is not None:
            pulumi.set(__self__, "generate_workflow_file", generate_workflow_file)
        if is_linux is not None:
            pulumi.set(__self__, "is_linux", is_linux)

    @property
    @pulumi.getter(name="codeConfiguration")
    def code_configuration(self) -> Optional[pulumi.Input['GitHubActionCodeConfigurationArgs']]:
        """
        GitHub Action code configuration.
        """
        return pulumi.get(self, "code_configuration")

    @code_configuration.setter
    def code_configuration(self, value: Optional[pulumi.Input['GitHubActionCodeConfigurationArgs']]):
        pulumi.set(self, "code_configuration", value)

    @property
    @pulumi.getter(name="containerConfiguration")
    def container_configuration(self) -> Optional[pulumi.Input['GitHubActionContainerConfigurationArgs']]:
        """
        GitHub Action container configuration.
        """
        return pulumi.get(self, "container_configuration")

    @container_configuration.setter
    def container_configuration(self, value: Optional[pulumi.Input['GitHubActionContainerConfigurationArgs']]):
        pulumi.set(self, "container_configuration", value)

    @property
    @pulumi.getter(name="generateWorkflowFile")
    def generate_workflow_file(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Workflow option to determine whether the workflow file should be generated and written to the repository.
        """
        return pulumi.get(self, "generate_workflow_file")

    @generate_workflow_file.setter
    def generate_workflow_file(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "generate_workflow_file", value)

    @property
    @pulumi.getter(name="isLinux")
    def is_linux(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This will help determine the workflow configuration to select.
        """
        return pulumi.get(self, "is_linux")

    @is_linux.setter
    def is_linux(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_linux", value)


if not MYPY:
    class GitHubActionContainerConfigurationArgsDict(TypedDict):
        """
        The GitHub action container configuration.
        """
        image_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The image name for the build.
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        The password used to upload the image to the container registry.
        """
        server_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The server URL for the container registry where the build will be hosted.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        The username used to upload the image to the container registry.
        """
elif False:
    GitHubActionContainerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitHubActionContainerConfigurationArgs:
    def __init__(__self__, *,
                 image_name: Optional[pulumi.Input[builtins.str]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 server_url: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        The GitHub action container configuration.
        :param pulumi.Input[builtins.str] image_name: The image name for the build.
        :param pulumi.Input[builtins.str] password: The password used to upload the image to the container registry.
        :param pulumi.Input[builtins.str] server_url: The server URL for the container registry where the build will be hosted.
        :param pulumi.Input[builtins.str] username: The username used to upload the image to the container registry.
        """
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The image name for the build.
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The password used to upload the image to the container registry.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The server URL for the container registry where the build will be hosted.
        """
        return pulumi.get(self, "server_url")

    @server_url.setter
    def server_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The username used to upload the image to the container registry.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class GitHubArgsDict(TypedDict):
        """
        The configuration settings of the GitHub provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        login: NotRequired[pulumi.Input['LoginScopesArgsDict']]
        """
        The configuration settings of the login flow.
        """
        registration: NotRequired[pulumi.Input['ClientRegistrationArgsDict']]
        """
        The configuration settings of the app registration for the GitHub provider.
        """
elif False:
    GitHubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitHubArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['ClientRegistrationArgs']] = None):
        """
        The configuration settings of the GitHub provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['LoginScopesArgs'] login: The configuration settings of the login flow.
        :param pulumi.Input['ClientRegistrationArgs'] registration: The configuration settings of the app registration for the GitHub provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['ClientRegistrationArgs']]:
        """
        The configuration settings of the app registration for the GitHub provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['ClientRegistrationArgs']]):
        pulumi.set(self, "registration", value)


if not MYPY:
    class GlobalValidationArgsDict(TypedDict):
        """
        The configuration settings that determines the validation flow of users using App Service Authentication/Authorization.
        """
        excluded_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The paths for which unauthenticated flow would not be redirected to the login page.
        """
        redirect_to_provider: NotRequired[pulumi.Input[builtins.str]]
        """
        The default authentication provider to use when multiple providers are configured.
        This setting is only needed if multiple providers are configured and the unauthenticated client
        action is set to "RedirectToLoginPage".
        """
        require_authentication: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if the authentication flow is required any request is made; otherwise, <code>false</code>.
        """
        unauthenticated_client_action: NotRequired[pulumi.Input['UnauthenticatedClientActionV2']]
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
elif False:
    GlobalValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalValidationArgs:
    def __init__(__self__, *,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 redirect_to_provider: Optional[pulumi.Input[builtins.str]] = None,
                 require_authentication: Optional[pulumi.Input[builtins.bool]] = None,
                 unauthenticated_client_action: Optional[pulumi.Input['UnauthenticatedClientActionV2']] = None):
        """
        The configuration settings that determines the validation flow of users using App Service Authentication/Authorization.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excluded_paths: The paths for which unauthenticated flow would not be redirected to the login page.
        :param pulumi.Input[builtins.str] redirect_to_provider: The default authentication provider to use when multiple providers are configured.
               This setting is only needed if multiple providers are configured and the unauthenticated client
               action is set to "RedirectToLoginPage".
        :param pulumi.Input[builtins.bool] require_authentication: <code>true</code> if the authentication flow is required any request is made; otherwise, <code>false</code>.
        :param pulumi.Input['UnauthenticatedClientActionV2'] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app.
        """
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if redirect_to_provider is not None:
            pulumi.set(__self__, "redirect_to_provider", redirect_to_provider)
        if require_authentication is not None:
            pulumi.set(__self__, "require_authentication", require_authentication)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The paths for which unauthenticated flow would not be redirected to the login page.
        """
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter(name="redirectToProvider")
    def redirect_to_provider(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The default authentication provider to use when multiple providers are configured.
        This setting is only needed if multiple providers are configured and the unauthenticated client
        action is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "redirect_to_provider")

    @redirect_to_provider.setter
    def redirect_to_provider(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_to_provider", value)

    @property
    @pulumi.getter(name="requireAuthentication")
    def require_authentication(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if the authentication flow is required any request is made; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "require_authentication")

    @require_authentication.setter
    def require_authentication(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_authentication", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input['UnauthenticatedClientActionV2']]:
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input['UnauthenticatedClientActionV2']]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class GoogleArgsDict(TypedDict):
        """
        The configuration settings of the Google provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        login: NotRequired[pulumi.Input['LoginScopesArgsDict']]
        """
        The configuration settings of the login flow.
        """
        registration: NotRequired[pulumi.Input['ClientRegistrationArgsDict']]
        """
        The configuration settings of the app registration for the Google provider.
        """
        validation: NotRequired[pulumi.Input['AllowedAudiencesValidationArgsDict']]
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
elif False:
    GoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GoogleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['ClientRegistrationArgs']] = None,
                 validation: Optional[pulumi.Input['AllowedAudiencesValidationArgs']] = None):
        """
        The configuration settings of the Google provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['LoginScopesArgs'] login: The configuration settings of the login flow.
        :param pulumi.Input['ClientRegistrationArgs'] registration: The configuration settings of the app registration for the Google provider.
        :param pulumi.Input['AllowedAudiencesValidationArgs'] validation: The configuration settings of the Azure Active Directory token validation flow.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['ClientRegistrationArgs']]:
        """
        The configuration settings of the app registration for the Google provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['ClientRegistrationArgs']]):
        pulumi.set(self, "registration", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input['AllowedAudiencesValidationArgs']]:
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input['AllowedAudiencesValidationArgs']]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class HandlerMappingArgsDict(TypedDict):
        """
        The IIS handler mappings used to define which handler processes HTTP requests with certain extension. 
        For example, it is used to configure php-cgi.exe process to handle all HTTP requests with *.php extension.
        """
        arguments: NotRequired[pulumi.Input[builtins.str]]
        """
        Command-line arguments to be passed to the script processor.
        """
        extension: NotRequired[pulumi.Input[builtins.str]]
        """
        Requests with this extension will be handled using the specified FastCGI application.
        """
        script_processor: NotRequired[pulumi.Input[builtins.str]]
        """
        The absolute path to the FastCGI application.
        """
elif False:
    HandlerMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HandlerMappingArgs:
    def __init__(__self__, *,
                 arguments: Optional[pulumi.Input[builtins.str]] = None,
                 extension: Optional[pulumi.Input[builtins.str]] = None,
                 script_processor: Optional[pulumi.Input[builtins.str]] = None):
        """
        The IIS handler mappings used to define which handler processes HTTP requests with certain extension. 
        For example, it is used to configure php-cgi.exe process to handle all HTTP requests with *.php extension.
        :param pulumi.Input[builtins.str] arguments: Command-line arguments to be passed to the script processor.
        :param pulumi.Input[builtins.str] extension: Requests with this extension will be handled using the specified FastCGI application.
        :param pulumi.Input[builtins.str] script_processor: The absolute path to the FastCGI application.
        """
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if extension is not None:
            pulumi.set(__self__, "extension", extension)
        if script_processor is not None:
            pulumi.set(__self__, "script_processor", script_processor)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Command-line arguments to be passed to the script processor.
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "arguments", value)

    @property
    @pulumi.getter
    def extension(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Requests with this extension will be handled using the specified FastCGI application.
        """
        return pulumi.get(self, "extension")

    @extension.setter
    def extension(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "extension", value)

    @property
    @pulumi.getter(name="scriptProcessor")
    def script_processor(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The absolute path to the FastCGI application.
        """
        return pulumi.get(self, "script_processor")

    @script_processor.setter
    def script_processor(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "script_processor", value)


if not MYPY:
    class HostNameSslStateArgsDict(TypedDict):
        """
        SSL-enabled hostname.
        """
        host_type: NotRequired[pulumi.Input['HostType']]
        """
        Indicates whether the hostname is a standard or repository hostname.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Hostname.
        """
        ssl_state: NotRequired[pulumi.Input['SslState']]
        """
        SSL type.
        """
        thumbprint: NotRequired[pulumi.Input[builtins.str]]
        """
        SSL certificate thumbprint.
        """
        to_update: NotRequired[pulumi.Input[builtins.bool]]
        """
        Set to <code>true</code> to update existing hostname.
        """
        virtual_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Virtual IP address assigned to the hostname if IP based SSL is enabled.
        """
elif False:
    HostNameSslStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostNameSslStateArgs:
    def __init__(__self__, *,
                 host_type: Optional[pulumi.Input['HostType']] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_state: Optional[pulumi.Input['SslState']] = None,
                 thumbprint: Optional[pulumi.Input[builtins.str]] = None,
                 to_update: Optional[pulumi.Input[builtins.bool]] = None,
                 virtual_ip: Optional[pulumi.Input[builtins.str]] = None):
        """
        SSL-enabled hostname.
        :param pulumi.Input['HostType'] host_type: Indicates whether the hostname is a standard or repository hostname.
        :param pulumi.Input[builtins.str] name: Hostname.
        :param pulumi.Input['SslState'] ssl_state: SSL type.
        :param pulumi.Input[builtins.str] thumbprint: SSL certificate thumbprint.
        :param pulumi.Input[builtins.bool] to_update: Set to <code>true</code> to update existing hostname.
        :param pulumi.Input[builtins.str] virtual_ip: Virtual IP address assigned to the hostname if IP based SSL is enabled.
        """
        if host_type is not None:
            pulumi.set(__self__, "host_type", host_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ssl_state is not None:
            pulumi.set(__self__, "ssl_state", ssl_state)
        if thumbprint is not None:
            pulumi.set(__self__, "thumbprint", thumbprint)
        if to_update is not None:
            pulumi.set(__self__, "to_update", to_update)
        if virtual_ip is not None:
            pulumi.set(__self__, "virtual_ip", virtual_ip)

    @property
    @pulumi.getter(name="hostType")
    def host_type(self) -> Optional[pulumi.Input['HostType']]:
        """
        Indicates whether the hostname is a standard or repository hostname.
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: Optional[pulumi.Input['HostType']]):
        pulumi.set(self, "host_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hostname.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sslState")
    def ssl_state(self) -> Optional[pulumi.Input['SslState']]:
        """
        SSL type.
        """
        return pulumi.get(self, "ssl_state")

    @ssl_state.setter
    def ssl_state(self, value: Optional[pulumi.Input['SslState']]):
        pulumi.set(self, "ssl_state", value)

    @property
    @pulumi.getter
    def thumbprint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SSL certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @thumbprint.setter
    def thumbprint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "thumbprint", value)

    @property
    @pulumi.getter(name="toUpdate")
    def to_update(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Set to <code>true</code> to update existing hostname.
        """
        return pulumi.get(self, "to_update")

    @to_update.setter
    def to_update(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "to_update", value)

    @property
    @pulumi.getter(name="virtualIP")
    def virtual_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Virtual IP address assigned to the hostname if IP based SSL is enabled.
        """
        return pulumi.get(self, "virtual_ip")

    @virtual_ip.setter
    def virtual_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "virtual_ip", value)


if not MYPY:
    class HostingEnvironmentProfileArgsDict(TypedDict):
        """
        Specification for an App Service Environment to use for this resource.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ID of the App Service Environment.
        """
elif False:
    HostingEnvironmentProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HostingEnvironmentProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Specification for an App Service Environment to use for this resource.
        :param pulumi.Input[builtins.str] id: Resource ID of the App Service Environment.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ID of the App Service Environment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class HttpLogsConfigArgsDict(TypedDict):
        """
        Http logs configuration.
        """
        azure_blob_storage: NotRequired[pulumi.Input['AzureBlobStorageHttpLogsConfigArgsDict']]
        """
        Http logs to azure blob storage configuration.
        """
        file_system: NotRequired[pulumi.Input['FileSystemHttpLogsConfigArgsDict']]
        """
        Http logs to file system configuration.
        """
elif False:
    HttpLogsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpLogsConfigArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['AzureBlobStorageHttpLogsConfigArgs']] = None,
                 file_system: Optional[pulumi.Input['FileSystemHttpLogsConfigArgs']] = None):
        """
        Http logs configuration.
        :param pulumi.Input['AzureBlobStorageHttpLogsConfigArgs'] azure_blob_storage: Http logs to azure blob storage configuration.
        :param pulumi.Input['FileSystemHttpLogsConfigArgs'] file_system: Http logs to file system configuration.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['AzureBlobStorageHttpLogsConfigArgs']]:
        """
        Http logs to azure blob storage configuration.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['AzureBlobStorageHttpLogsConfigArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input['FileSystemHttpLogsConfigArgs']]:
        """
        Http logs to file system configuration.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input['FileSystemHttpLogsConfigArgs']]):
        pulumi.set(self, "file_system", value)


if not MYPY:
    class HttpSettingsRoutesArgsDict(TypedDict):
        """
        The configuration settings of the paths HTTP requests.
        """
        api_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        The prefix that should precede all the authentication/authorization paths.
        """
elif False:
    HttpSettingsRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpSettingsRoutesArgs:
    def __init__(__self__, *,
                 api_prefix: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the paths HTTP requests.
        :param pulumi.Input[builtins.str] api_prefix: The prefix that should precede all the authentication/authorization paths.
        """
        if api_prefix is not None:
            pulumi.set(__self__, "api_prefix", api_prefix)

    @property
    @pulumi.getter(name="apiPrefix")
    def api_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The prefix that should precede all the authentication/authorization paths.
        """
        return pulumi.get(self, "api_prefix")

    @api_prefix.setter
    def api_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_prefix", value)


if not MYPY:
    class HttpSettingsArgsDict(TypedDict):
        """
        The configuration settings of the HTTP requests for authentication and authorization requests made against App Service Authentication/Authorization.
        """
        forward_proxy: NotRequired[pulumi.Input['ForwardProxyArgsDict']]
        """
        The configuration settings of a forward proxy used to make the requests.
        """
        require_https: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        """
        routes: NotRequired[pulumi.Input['HttpSettingsRoutesArgsDict']]
        """
        The configuration settings of the paths HTTP requests.
        """
elif False:
    HttpSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpSettingsArgs:
    def __init__(__self__, *,
                 forward_proxy: Optional[pulumi.Input['ForwardProxyArgs']] = None,
                 require_https: Optional[pulumi.Input[builtins.bool]] = None,
                 routes: Optional[pulumi.Input['HttpSettingsRoutesArgs']] = None):
        """
        The configuration settings of the HTTP requests for authentication and authorization requests made against App Service Authentication/Authorization.
        :param pulumi.Input['ForwardProxyArgs'] forward_proxy: The configuration settings of a forward proxy used to make the requests.
        :param pulumi.Input[builtins.bool] require_https: <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        :param pulumi.Input['HttpSettingsRoutesArgs'] routes: The configuration settings of the paths HTTP requests.
        """
        if forward_proxy is not None:
            pulumi.set(__self__, "forward_proxy", forward_proxy)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @property
    @pulumi.getter(name="forwardProxy")
    def forward_proxy(self) -> Optional[pulumi.Input['ForwardProxyArgs']]:
        """
        The configuration settings of a forward proxy used to make the requests.
        """
        return pulumi.get(self, "forward_proxy")

    @forward_proxy.setter
    def forward_proxy(self, value: Optional[pulumi.Input['ForwardProxyArgs']]):
        pulumi.set(self, "forward_proxy", value)

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "require_https")

    @require_https.setter
    def require_https(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_https", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input['HttpSettingsRoutesArgs']]:
        """
        The configuration settings of the paths HTTP requests.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input['HttpSettingsRoutesArgs']]):
        pulumi.set(self, "routes", value)


if not MYPY:
    class IdentityProvidersArgsDict(TypedDict):
        """
        The configuration settings of each of the identity providers used to configure App Service Authentication/Authorization.
        """
        apple: NotRequired[pulumi.Input['AppleArgsDict']]
        """
        The configuration settings of the Apple provider.
        """
        azure_active_directory: NotRequired[pulumi.Input['AzureActiveDirectoryArgsDict']]
        """
        The configuration settings of the Azure Active directory provider.
        """
        azure_static_web_apps: NotRequired[pulumi.Input['AzureStaticWebAppsArgsDict']]
        """
        The configuration settings of the Azure Static Web Apps provider.
        """
        custom_open_id_connect_providers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgsDict']]]]
        """
        The map of the name of the alias of each custom Open ID Connect provider to the
        configuration settings of the custom Open ID Connect provider.
        """
        facebook: NotRequired[pulumi.Input['FacebookArgsDict']]
        """
        The configuration settings of the Facebook provider.
        """
        git_hub: NotRequired[pulumi.Input['GitHubArgsDict']]
        """
        The configuration settings of the GitHub provider.
        """
        google: NotRequired[pulumi.Input['GoogleArgsDict']]
        """
        The configuration settings of the Google provider.
        """
        legacy_microsoft_account: NotRequired[pulumi.Input['LegacyMicrosoftAccountArgsDict']]
        """
        The configuration settings of the legacy Microsoft Account provider.
        """
        twitter: NotRequired[pulumi.Input['TwitterArgsDict']]
        """
        The configuration settings of the Twitter provider.
        """
elif False:
    IdentityProvidersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityProvidersArgs:
    def __init__(__self__, *,
                 apple: Optional[pulumi.Input['AppleArgs']] = None,
                 azure_active_directory: Optional[pulumi.Input['AzureActiveDirectoryArgs']] = None,
                 azure_static_web_apps: Optional[pulumi.Input['AzureStaticWebAppsArgs']] = None,
                 custom_open_id_connect_providers: Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]] = None,
                 facebook: Optional[pulumi.Input['FacebookArgs']] = None,
                 git_hub: Optional[pulumi.Input['GitHubArgs']] = None,
                 google: Optional[pulumi.Input['GoogleArgs']] = None,
                 legacy_microsoft_account: Optional[pulumi.Input['LegacyMicrosoftAccountArgs']] = None,
                 twitter: Optional[pulumi.Input['TwitterArgs']] = None):
        """
        The configuration settings of each of the identity providers used to configure App Service Authentication/Authorization.
        :param pulumi.Input['AppleArgs'] apple: The configuration settings of the Apple provider.
        :param pulumi.Input['AzureActiveDirectoryArgs'] azure_active_directory: The configuration settings of the Azure Active directory provider.
        :param pulumi.Input['AzureStaticWebAppsArgs'] azure_static_web_apps: The configuration settings of the Azure Static Web Apps provider.
        :param pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]] custom_open_id_connect_providers: The map of the name of the alias of each custom Open ID Connect provider to the
               configuration settings of the custom Open ID Connect provider.
        :param pulumi.Input['FacebookArgs'] facebook: The configuration settings of the Facebook provider.
        :param pulumi.Input['GitHubArgs'] git_hub: The configuration settings of the GitHub provider.
        :param pulumi.Input['GoogleArgs'] google: The configuration settings of the Google provider.
        :param pulumi.Input['LegacyMicrosoftAccountArgs'] legacy_microsoft_account: The configuration settings of the legacy Microsoft Account provider.
        :param pulumi.Input['TwitterArgs'] twitter: The configuration settings of the Twitter provider.
        """
        if apple is not None:
            pulumi.set(__self__, "apple", apple)
        if azure_active_directory is not None:
            pulumi.set(__self__, "azure_active_directory", azure_active_directory)
        if azure_static_web_apps is not None:
            pulumi.set(__self__, "azure_static_web_apps", azure_static_web_apps)
        if custom_open_id_connect_providers is not None:
            pulumi.set(__self__, "custom_open_id_connect_providers", custom_open_id_connect_providers)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if git_hub is not None:
            pulumi.set(__self__, "git_hub", git_hub)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if legacy_microsoft_account is not None:
            pulumi.set(__self__, "legacy_microsoft_account", legacy_microsoft_account)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)

    @property
    @pulumi.getter
    def apple(self) -> Optional[pulumi.Input['AppleArgs']]:
        """
        The configuration settings of the Apple provider.
        """
        return pulumi.get(self, "apple")

    @apple.setter
    def apple(self, value: Optional[pulumi.Input['AppleArgs']]):
        pulumi.set(self, "apple", value)

    @property
    @pulumi.getter(name="azureActiveDirectory")
    def azure_active_directory(self) -> Optional[pulumi.Input['AzureActiveDirectoryArgs']]:
        """
        The configuration settings of the Azure Active directory provider.
        """
        return pulumi.get(self, "azure_active_directory")

    @azure_active_directory.setter
    def azure_active_directory(self, value: Optional[pulumi.Input['AzureActiveDirectoryArgs']]):
        pulumi.set(self, "azure_active_directory", value)

    @property
    @pulumi.getter(name="azureStaticWebApps")
    def azure_static_web_apps(self) -> Optional[pulumi.Input['AzureStaticWebAppsArgs']]:
        """
        The configuration settings of the Azure Static Web Apps provider.
        """
        return pulumi.get(self, "azure_static_web_apps")

    @azure_static_web_apps.setter
    def azure_static_web_apps(self, value: Optional[pulumi.Input['AzureStaticWebAppsArgs']]):
        pulumi.set(self, "azure_static_web_apps", value)

    @property
    @pulumi.getter(name="customOpenIdConnectProviders")
    def custom_open_id_connect_providers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]]:
        """
        The map of the name of the alias of each custom Open ID Connect provider to the
        configuration settings of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "custom_open_id_connect_providers")

    @custom_open_id_connect_providers.setter
    def custom_open_id_connect_providers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]]):
        pulumi.set(self, "custom_open_id_connect_providers", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['FacebookArgs']]:
        """
        The configuration settings of the Facebook provider.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['FacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter(name="gitHub")
    def git_hub(self) -> Optional[pulumi.Input['GitHubArgs']]:
        """
        The configuration settings of the GitHub provider.
        """
        return pulumi.get(self, "git_hub")

    @git_hub.setter
    def git_hub(self, value: Optional[pulumi.Input['GitHubArgs']]):
        pulumi.set(self, "git_hub", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['GoogleArgs']]:
        """
        The configuration settings of the Google provider.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['GoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter(name="legacyMicrosoftAccount")
    def legacy_microsoft_account(self) -> Optional[pulumi.Input['LegacyMicrosoftAccountArgs']]:
        """
        The configuration settings of the legacy Microsoft Account provider.
        """
        return pulumi.get(self, "legacy_microsoft_account")

    @legacy_microsoft_account.setter
    def legacy_microsoft_account(self, value: Optional[pulumi.Input['LegacyMicrosoftAccountArgs']]):
        pulumi.set(self, "legacy_microsoft_account", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['TwitterArgs']]:
        """
        The configuration settings of the Twitter provider.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['TwitterArgs']]):
        pulumi.set(self, "twitter", value)


if not MYPY:
    class IpSecurityRestrictionArgsDict(TypedDict):
        """
        IP security restriction on an app.
        """
        action: NotRequired[pulumi.Input[builtins.str]]
        """
        Allow or Deny access for this IP range.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        IP restriction rule description.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]]]
        """
        IP restriction rule headers.
        X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples). 
        The matching logic is ..
        - If the property is null or empty (default), all hosts(or lack of) are allowed.
        - A value is compared using ordinal-ignore-case (excluding port number).
        - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain foo.contoso.com
         but not the root domain contoso.com or multi-level foo.bar.contoso.com
        - Unicode host names are allowed but are converted to Punycode for matching.

        X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
        The matching logic is ..
        - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
        - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.

        X-Azure-FDID and X-FD-HealthProbe.
        The matching logic is exact match.
        """
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        IP address the security restriction is valid for.
        It can be in form of pure ipv4 address (required SubnetMask property) or
        CIDR notation such as ipv4/mask (leading bit match). For CIDR,
        SubnetMask property must not be specified.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        IP restriction rule name.
        """
        priority: NotRequired[pulumi.Input[builtins.int]]
        """
        Priority of IP restriction rule.
        """
        subnet_mask: NotRequired[pulumi.Input[builtins.str]]
        """
        Subnet mask for the range of IP addresses the restriction is valid for.
        """
        subnet_traffic_tag: NotRequired[pulumi.Input[builtins.int]]
        """
        (internal) Subnet traffic tag
        """
        tag: NotRequired[pulumi.Input[Union[builtins.str, 'IpFilterTag']]]
        """
        Defines what this IP filter will be used for. This is to support IP filtering on proxies.
        """
        vnet_subnet_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Virtual network resource id
        """
        vnet_traffic_tag: NotRequired[pulumi.Input[builtins.int]]
        """
        (internal) Vnet traffic tag
        """
elif False:
    IpSecurityRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpSecurityRestrictionArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]]] = None,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 priority: Optional[pulumi.Input[builtins.int]] = None,
                 subnet_mask: Optional[pulumi.Input[builtins.str]] = None,
                 subnet_traffic_tag: Optional[pulumi.Input[builtins.int]] = None,
                 tag: Optional[pulumi.Input[Union[builtins.str, 'IpFilterTag']]] = None,
                 vnet_subnet_resource_id: Optional[pulumi.Input[builtins.str]] = None,
                 vnet_traffic_tag: Optional[pulumi.Input[builtins.int]] = None):
        """
        IP security restriction on an app.
        :param pulumi.Input[builtins.str] action: Allow or Deny access for this IP range.
        :param pulumi.Input[builtins.str] description: IP restriction rule description.
        :param pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]] headers: IP restriction rule headers.
               X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples). 
               The matching logic is ..
               - If the property is null or empty (default), all hosts(or lack of) are allowed.
               - A value is compared using ordinal-ignore-case (excluding port number).
               - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain foo.contoso.com
                but not the root domain contoso.com or multi-level foo.bar.contoso.com
               - Unicode host names are allowed but are converted to Punycode for matching.
               
               X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
               The matching logic is ..
               - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
               - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.
               
               X-Azure-FDID and X-FD-HealthProbe.
               The matching logic is exact match.
        :param pulumi.Input[builtins.str] ip_address: IP address the security restriction is valid for.
               It can be in form of pure ipv4 address (required SubnetMask property) or
               CIDR notation such as ipv4/mask (leading bit match). For CIDR,
               SubnetMask property must not be specified.
        :param pulumi.Input[builtins.str] name: IP restriction rule name.
        :param pulumi.Input[builtins.int] priority: Priority of IP restriction rule.
        :param pulumi.Input[builtins.str] subnet_mask: Subnet mask for the range of IP addresses the restriction is valid for.
        :param pulumi.Input[builtins.int] subnet_traffic_tag: (internal) Subnet traffic tag
        :param pulumi.Input[Union[builtins.str, 'IpFilterTag']] tag: Defines what this IP filter will be used for. This is to support IP filtering on proxies.
        :param pulumi.Input[builtins.str] vnet_subnet_resource_id: Virtual network resource id
        :param pulumi.Input[builtins.int] vnet_traffic_tag: (internal) Vnet traffic tag
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)
        if subnet_traffic_tag is not None:
            pulumi.set(__self__, "subnet_traffic_tag", subnet_traffic_tag)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if vnet_subnet_resource_id is not None:
            pulumi.set(__self__, "vnet_subnet_resource_id", vnet_subnet_resource_id)
        if vnet_traffic_tag is not None:
            pulumi.set(__self__, "vnet_traffic_tag", vnet_traffic_tag)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Allow or Deny access for this IP range.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IP restriction rule description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]]]:
        """
        IP restriction rule headers.
        X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples). 
        The matching logic is ..
        - If the property is null or empty (default), all hosts(or lack of) are allowed.
        - A value is compared using ordinal-ignore-case (excluding port number).
        - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain foo.contoso.com
         but not the root domain contoso.com or multi-level foo.bar.contoso.com
        - Unicode host names are allowed but are converted to Punycode for matching.

        X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
        The matching logic is ..
        - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
        - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.

        X-Azure-FDID and X-FD-HealthProbe.
        The matching logic is exact match.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IP address the security restriction is valid for.
        It can be in form of pure ipv4 address (required SubnetMask property) or
        CIDR notation such as ipv4/mask (leading bit match). For CIDR,
        SubnetMask property must not be specified.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IP restriction rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Priority of IP restriction rule.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subnet mask for the range of IP addresses the restriction is valid for.
        """
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subnet_mask", value)

    @property
    @pulumi.getter(name="subnetTrafficTag")
    def subnet_traffic_tag(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (internal) Subnet traffic tag
        """
        return pulumi.get(self, "subnet_traffic_tag")

    @subnet_traffic_tag.setter
    def subnet_traffic_tag(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "subnet_traffic_tag", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[Union[builtins.str, 'IpFilterTag']]]:
        """
        Defines what this IP filter will be used for. This is to support IP filtering on proxies.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[Union[builtins.str, 'IpFilterTag']]]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter(name="vnetSubnetResourceId")
    def vnet_subnet_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Virtual network resource id
        """
        return pulumi.get(self, "vnet_subnet_resource_id")

    @vnet_subnet_resource_id.setter
    def vnet_subnet_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vnet_subnet_resource_id", value)

    @property
    @pulumi.getter(name="vnetTrafficTag")
    def vnet_traffic_tag(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (internal) Vnet traffic tag
        """
        return pulumi.get(self, "vnet_traffic_tag")

    @vnet_traffic_tag.setter
    def vnet_traffic_tag(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "vnet_traffic_tag", value)


if not MYPY:
    class JwtClaimChecksArgsDict(TypedDict):
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        allowed_client_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of the allowed client applications.
        """
        allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of the allowed groups.
        """
elif False:
    JwtClaimChecksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JwtClaimChecksArgs:
    def __init__(__self__, *,
                 allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_client_applications: The list of the allowed client applications.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_groups: The list of the allowed groups.
        """
        if allowed_client_applications is not None:
            pulumi.set(__self__, "allowed_client_applications", allowed_client_applications)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)

    @property
    @pulumi.getter(name="allowedClientApplications")
    def allowed_client_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of the allowed client applications.
        """
        return pulumi.get(self, "allowed_client_applications")

    @allowed_client_applications.setter
    def allowed_client_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_client_applications", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of the allowed groups.
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_groups", value)


if not MYPY:
    class KubeEnvironmentProfileArgsDict(TypedDict):
        """
        Specification for a Kubernetes Environment to use for this resource.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ID of the Kubernetes Environment.
        """
elif False:
    KubeEnvironmentProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubeEnvironmentProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Specification for a Kubernetes Environment to use for this resource.
        :param pulumi.Input[builtins.str] id: Resource ID of the Kubernetes Environment.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ID of the Kubernetes Environment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LegacyMicrosoftAccountArgsDict(TypedDict):
        """
        The configuration settings of the legacy Microsoft Account provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the legacy Microsoft Account provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        login: NotRequired[pulumi.Input['LoginScopesArgsDict']]
        """
        The configuration settings of the login flow.
        """
        registration: NotRequired[pulumi.Input['ClientRegistrationArgsDict']]
        """
        The configuration settings of the app registration for the legacy Microsoft Account provider.
        """
        validation: NotRequired[pulumi.Input['AllowedAudiencesValidationArgsDict']]
        """
        The configuration settings of the legacy Microsoft Account provider token validation flow.
        """
elif False:
    LegacyMicrosoftAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LegacyMicrosoftAccountArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['ClientRegistrationArgs']] = None,
                 validation: Optional[pulumi.Input['AllowedAudiencesValidationArgs']] = None):
        """
        The configuration settings of the legacy Microsoft Account provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the legacy Microsoft Account provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['LoginScopesArgs'] login: The configuration settings of the login flow.
        :param pulumi.Input['ClientRegistrationArgs'] registration: The configuration settings of the app registration for the legacy Microsoft Account provider.
        :param pulumi.Input['AllowedAudiencesValidationArgs'] validation: The configuration settings of the legacy Microsoft Account provider token validation flow.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the legacy Microsoft Account provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['ClientRegistrationArgs']]:
        """
        The configuration settings of the app registration for the legacy Microsoft Account provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['ClientRegistrationArgs']]):
        pulumi.set(self, "registration", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input['AllowedAudiencesValidationArgs']]:
        """
        The configuration settings of the legacy Microsoft Account provider token validation flow.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input['AllowedAudiencesValidationArgs']]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class LogAnalyticsConfigurationArgsDict(TypedDict):
        customer_id: NotRequired[pulumi.Input[builtins.str]]
        shared_key: NotRequired[pulumi.Input[builtins.str]]
elif False:
    LogAnalyticsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsConfigurationArgs:
    def __init__(__self__, *,
                 customer_id: Optional[pulumi.Input[builtins.str]] = None,
                 shared_key: Optional[pulumi.Input[builtins.str]] = None):
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)
        if shared_key is not None:
            pulumi.set(__self__, "shared_key", shared_key)

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "customer_id")

    @customer_id.setter
    def customer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "customer_id", value)

    @property
    @pulumi.getter(name="sharedKey")
    def shared_key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "shared_key")

    @shared_key.setter
    def shared_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "shared_key", value)


if not MYPY:
    class LoginRoutesArgsDict(TypedDict):
        """
        The routes that specify the endpoints used for login and logout requests.
        """
        logout_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The endpoint at which a logout request should be made.
        """
elif False:
    LoginRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoginRoutesArgs:
    def __init__(__self__, *,
                 logout_endpoint: Optional[pulumi.Input[builtins.str]] = None):
        """
        The routes that specify the endpoints used for login and logout requests.
        :param pulumi.Input[builtins.str] logout_endpoint: The endpoint at which a logout request should be made.
        """
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The endpoint at which a logout request should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @logout_endpoint.setter
    def logout_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logout_endpoint", value)


if not MYPY:
    class LoginScopesArgsDict(TypedDict):
        """
        The configuration settings of the login flow, including the scopes that should be requested.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of the scopes that should be requested while authenticating.
        """
elif False:
    LoginScopesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoginScopesArgs:
    def __init__(__self__, *,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The configuration settings of the login flow, including the scopes that should be requested.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: A list of the scopes that should be requested while authenticating.
        """
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class LoginArgsDict(TypedDict):
        """
        The configuration settings of the login flow of users using App Service Authentication/Authorization.
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
        This is an advanced setting typically only needed by Windows Store application backends.
        Note that URLs within the current domain are always implicitly allowed.
        """
        cookie_expiration: NotRequired[pulumi.Input['CookieExpirationArgsDict']]
        """
        The configuration settings of the session cookie's expiration.
        """
        nonce: NotRequired[pulumi.Input['NonceArgsDict']]
        """
        The configuration settings of the nonce used in the login flow.
        """
        preserve_url_fragments_for_logins: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        """
        routes: NotRequired[pulumi.Input['LoginRoutesArgsDict']]
        """
        The routes that specify the endpoints used for login and logout requests.
        """
        token_store: NotRequired[pulumi.Input['TokenStoreArgsDict']]
        """
        The configuration settings of the token store.
        """
elif False:
    LoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoginArgs:
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 cookie_expiration: Optional[pulumi.Input['CookieExpirationArgs']] = None,
                 nonce: Optional[pulumi.Input['NonceArgs']] = None,
                 preserve_url_fragments_for_logins: Optional[pulumi.Input[builtins.bool]] = None,
                 routes: Optional[pulumi.Input['LoginRoutesArgs']] = None,
                 token_store: Optional[pulumi.Input['TokenStoreArgs']] = None):
        """
        The configuration settings of the login flow of users using App Service Authentication/Authorization.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
               This is an advanced setting typically only needed by Windows Store application backends.
               Note that URLs within the current domain are always implicitly allowed.
        :param pulumi.Input['CookieExpirationArgs'] cookie_expiration: The configuration settings of the session cookie's expiration.
        :param pulumi.Input['NonceArgs'] nonce: The configuration settings of the nonce used in the login flow.
        :param pulumi.Input[builtins.bool] preserve_url_fragments_for_logins: <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        :param pulumi.Input['LoginRoutesArgs'] routes: The routes that specify the endpoints used for login and logout requests.
        :param pulumi.Input['TokenStoreArgs'] token_store: The configuration settings of the token store.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration is not None:
            pulumi.set(__self__, "cookie_expiration", cookie_expiration)
        if nonce is not None:
            pulumi.set(__self__, "nonce", nonce)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if token_store is not None:
            pulumi.set(__self__, "token_store", token_store)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
        This is an advanced setting typically only needed by Windows Store application backends.
        Note that URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="cookieExpiration")
    def cookie_expiration(self) -> Optional[pulumi.Input['CookieExpirationArgs']]:
        """
        The configuration settings of the session cookie's expiration.
        """
        return pulumi.get(self, "cookie_expiration")

    @cookie_expiration.setter
    def cookie_expiration(self, value: Optional[pulumi.Input['CookieExpirationArgs']]):
        pulumi.set(self, "cookie_expiration", value)

    @property
    @pulumi.getter
    def nonce(self) -> Optional[pulumi.Input['NonceArgs']]:
        """
        The configuration settings of the nonce used in the login flow.
        """
        return pulumi.get(self, "nonce")

    @nonce.setter
    def nonce(self, value: Optional[pulumi.Input['NonceArgs']]):
        pulumi.set(self, "nonce", value)

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @preserve_url_fragments_for_logins.setter
    def preserve_url_fragments_for_logins(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "preserve_url_fragments_for_logins", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input['LoginRoutesArgs']]:
        """
        The routes that specify the endpoints used for login and logout requests.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input['LoginRoutesArgs']]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter(name="tokenStore")
    def token_store(self) -> Optional[pulumi.Input['TokenStoreArgs']]:
        """
        The configuration settings of the token store.
        """
        return pulumi.get(self, "token_store")

    @token_store.setter
    def token_store(self, value: Optional[pulumi.Input['TokenStoreArgs']]):
        pulumi.set(self, "token_store", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity.
        """
        type: NotRequired[pulumi.Input['ManagedServiceIdentityType']]
        """
        Type of managed service identity.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ManagedServiceIdentityType']] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Managed service identity.
        :param pulumi.Input['ManagedServiceIdentityType'] type: Type of managed service identity.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_assigned_identities: The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ManagedServiceIdentityType']]:
        """
        Type of managed service identity.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class NameValuePairArgsDict(TypedDict):
        """
        Name value pair.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Pair name.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Pair value.
        """
elif False:
    NameValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NameValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Name value pair.
        :param pulumi.Input[builtins.str] name: Pair name.
        :param pulumi.Input[builtins.str] value: Pair value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Pair name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Pair value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NonceArgsDict(TypedDict):
        """
        The configuration settings of the nonce used in the login flow.
        """
        nonce_expiration_interval: NotRequired[pulumi.Input[builtins.str]]
        """
        The time after the request is made when the nonce should expire.
        """
        validate_nonce: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
elif False:
    NonceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NonceArgs:
    def __init__(__self__, *,
                 nonce_expiration_interval: Optional[pulumi.Input[builtins.str]] = None,
                 validate_nonce: Optional[pulumi.Input[builtins.bool]] = None):
        """
        The configuration settings of the nonce used in the login flow.
        :param pulumi.Input[builtins.str] nonce_expiration_interval: The time after the request is made when the nonce should expire.
        :param pulumi.Input[builtins.bool] validate_nonce: <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
        if nonce_expiration_interval is not None:
            pulumi.set(__self__, "nonce_expiration_interval", nonce_expiration_interval)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="nonceExpirationInterval")
    def nonce_expiration_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The time after the request is made when the nonce should expire.
        """
        return pulumi.get(self, "nonce_expiration_interval")

    @nonce_expiration_interval.setter
    def nonce_expiration_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nonce_expiration_interval", value)

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "validate_nonce")

    @validate_nonce.setter
    def validate_nonce(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "validate_nonce", value)


if not MYPY:
    class OpenIdConnectClientCredentialArgsDict(TypedDict):
        """
        The authentication client credentials of the custom Open ID Connect provider.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The app setting that contains the client secret for the custom Open ID Connect provider.
        """
        method: NotRequired[pulumi.Input['ClientCredentialMethod']]
        """
        The method that should be used to authenticate the user.
        """
elif False:
    OpenIdConnectClientCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenIdConnectClientCredentialArgs:
    def __init__(__self__, *,
                 client_secret_setting_name: Optional[pulumi.Input[builtins.str]] = None,
                 method: Optional[pulumi.Input['ClientCredentialMethod']] = None):
        """
        The authentication client credentials of the custom Open ID Connect provider.
        :param pulumi.Input[builtins.str] client_secret_setting_name: The app setting that contains the client secret for the custom Open ID Connect provider.
        :param pulumi.Input['ClientCredentialMethod'] method: The method that should be used to authenticate the user.
        """
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The app setting that contains the client secret for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['ClientCredentialMethod']]:
        """
        The method that should be used to authenticate the user.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['ClientCredentialMethod']]):
        pulumi.set(self, "method", value)


if not MYPY:
    class OpenIdConnectConfigArgsDict(TypedDict):
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        authorization_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The endpoint to be used to make an authorization request.
        """
        certification_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        The endpoint that provides the keys necessary to validate the token.
        """
        issuer: NotRequired[pulumi.Input[builtins.str]]
        """
        The endpoint that issues the token.
        """
        token_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The endpoint to be used to request a token.
        """
        well_known_open_id_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        The endpoint that contains all the configuration endpoints for the provider.
        """
elif False:
    OpenIdConnectConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenIdConnectConfigArgs:
    def __init__(__self__, *,
                 authorization_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 certification_uri: Optional[pulumi.Input[builtins.str]] = None,
                 issuer: Optional[pulumi.Input[builtins.str]] = None,
                 token_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 well_known_open_id_configuration: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        :param pulumi.Input[builtins.str] authorization_endpoint: The endpoint to be used to make an authorization request.
        :param pulumi.Input[builtins.str] certification_uri: The endpoint that provides the keys necessary to validate the token.
        :param pulumi.Input[builtins.str] issuer: The endpoint that issues the token.
        :param pulumi.Input[builtins.str] token_endpoint: The endpoint to be used to request a token.
        :param pulumi.Input[builtins.str] well_known_open_id_configuration: The endpoint that contains all the configuration endpoints for the provider.
        """
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if well_known_open_id_configuration is not None:
            pulumi.set(__self__, "well_known_open_id_configuration", well_known_open_id_configuration)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The endpoint to be used to make an authorization request.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The endpoint that provides the keys necessary to validate the token.
        """
        return pulumi.get(self, "certification_uri")

    @certification_uri.setter
    def certification_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certification_uri", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The endpoint that issues the token.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The endpoint to be used to request a token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="wellKnownOpenIdConfiguration")
    def well_known_open_id_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The endpoint that contains all the configuration endpoints for the provider.
        """
        return pulumi.get(self, "well_known_open_id_configuration")

    @well_known_open_id_configuration.setter
    def well_known_open_id_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "well_known_open_id_configuration", value)


if not MYPY:
    class OpenIdConnectLoginArgsDict(TypedDict):
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        """
        name_claim_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the claim that contains the users name.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of the scopes that should be requested while authenticating.
        """
elif False:
    OpenIdConnectLoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenIdConnectLoginArgs:
    def __init__(__self__, *,
                 name_claim_type: Optional[pulumi.Input[builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        :param pulumi.Input[builtins.str] name_claim_type: The name of the claim that contains the users name.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: A list of the scopes that should be requested while authenticating.
        """
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @name_claim_type.setter
    def name_claim_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name_claim_type", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class OpenIdConnectRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        client_credential: NotRequired[pulumi.Input['OpenIdConnectClientCredentialArgsDict']]
        """
        The authentication credentials of the custom Open ID Connect provider.
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client id of the custom Open ID Connect provider.
        """
        open_id_connect_configuration: NotRequired[pulumi.Input['OpenIdConnectConfigArgsDict']]
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
elif False:
    OpenIdConnectRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenIdConnectRegistrationArgs:
    def __init__(__self__, *,
                 client_credential: Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']] = None,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 open_id_connect_configuration: Optional[pulumi.Input['OpenIdConnectConfigArgs']] = None):
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        :param pulumi.Input['OpenIdConnectClientCredentialArgs'] client_credential: The authentication credentials of the custom Open ID Connect provider.
        :param pulumi.Input[builtins.str] client_id: The client id of the custom Open ID Connect provider.
        :param pulumi.Input['OpenIdConnectConfigArgs'] open_id_connect_configuration: The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        if client_credential is not None:
            pulumi.set(__self__, "client_credential", client_credential)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if open_id_connect_configuration is not None:
            pulumi.set(__self__, "open_id_connect_configuration", open_id_connect_configuration)

    @property
    @pulumi.getter(name="clientCredential")
    def client_credential(self) -> Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']]:
        """
        The authentication credentials of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_credential")

    @client_credential.setter
    def client_credential(self, value: Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']]):
        pulumi.set(self, "client_credential", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client id of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="openIdConnectConfiguration")
    def open_id_connect_configuration(self) -> Optional[pulumi.Input['OpenIdConnectConfigArgs']]:
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "open_id_connect_configuration")

    @open_id_connect_configuration.setter
    def open_id_connect_configuration(self, value: Optional[pulumi.Input['OpenIdConnectConfigArgs']]):
        pulumi.set(self, "open_id_connect_configuration", value)


if not MYPY:
    class PrivateLinkConnectionStateArgsDict(TypedDict):
        """
        The state of a private link connection
        """
        actions_required: NotRequired[pulumi.Input[builtins.str]]
        """
        ActionsRequired for a private link connection
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of a private link connection
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        Status of a private link connection
        """
elif False:
    PrivateLinkConnectionStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateLinkConnectionStateArgs:
    def __init__(__self__, *,
                 actions_required: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None):
        """
        The state of a private link connection
        :param pulumi.Input[builtins.str] actions_required: ActionsRequired for a private link connection
        :param pulumi.Input[builtins.str] description: Description of a private link connection
        :param pulumi.Input[builtins.str] status: Status of a private link connection
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ActionsRequired for a private link connection
        """
        return pulumi.get(self, "actions_required")

    @actions_required.setter
    def actions_required(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "actions_required", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of a private link connection
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Status of a private link connection
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PushSettingsArgsDict(TypedDict):
        """
        Push settings for the App.
        """
        is_push_enabled: pulumi.Input[builtins.bool]
        """
        Gets or sets a flag indicating whether the Push endpoint is enabled.
        """
        dynamic_tags_json: NotRequired[pulumi.Input[builtins.str]]
        """
        Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration endpoint.
        """
        kind: NotRequired[pulumi.Input[builtins.str]]
        """
        Kind of resource.
        """
        tag_whitelist_json: NotRequired[pulumi.Input[builtins.str]]
        """
        Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push registration endpoint.
        """
        tags_requiring_auth: NotRequired[pulumi.Input[builtins.str]]
        """
        Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration endpoint.
        Tags can consist of alphanumeric characters and the following:
        '_', '@', '#', '.', ':', '-'. 
        Validation should be performed at the PushRequestHandler.
        """
elif False:
    PushSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PushSettingsArgs:
    def __init__(__self__, *,
                 is_push_enabled: pulumi.Input[builtins.bool],
                 dynamic_tags_json: Optional[pulumi.Input[builtins.str]] = None,
                 kind: Optional[pulumi.Input[builtins.str]] = None,
                 tag_whitelist_json: Optional[pulumi.Input[builtins.str]] = None,
                 tags_requiring_auth: Optional[pulumi.Input[builtins.str]] = None):
        """
        Push settings for the App.
        :param pulumi.Input[builtins.bool] is_push_enabled: Gets or sets a flag indicating whether the Push endpoint is enabled.
        :param pulumi.Input[builtins.str] dynamic_tags_json: Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration endpoint.
        :param pulumi.Input[builtins.str] kind: Kind of resource.
        :param pulumi.Input[builtins.str] tag_whitelist_json: Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push registration endpoint.
        :param pulumi.Input[builtins.str] tags_requiring_auth: Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration endpoint.
               Tags can consist of alphanumeric characters and the following:
               '_', '@', '#', '.', ':', '-'. 
               Validation should be performed at the PushRequestHandler.
        """
        pulumi.set(__self__, "is_push_enabled", is_push_enabled)
        if dynamic_tags_json is not None:
            pulumi.set(__self__, "dynamic_tags_json", dynamic_tags_json)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if tag_whitelist_json is not None:
            pulumi.set(__self__, "tag_whitelist_json", tag_whitelist_json)
        if tags_requiring_auth is not None:
            pulumi.set(__self__, "tags_requiring_auth", tags_requiring_auth)

    @property
    @pulumi.getter(name="isPushEnabled")
    def is_push_enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Gets or sets a flag indicating whether the Push endpoint is enabled.
        """
        return pulumi.get(self, "is_push_enabled")

    @is_push_enabled.setter
    def is_push_enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "is_push_enabled", value)

    @property
    @pulumi.getter(name="dynamicTagsJson")
    def dynamic_tags_json(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration endpoint.
        """
        return pulumi.get(self, "dynamic_tags_json")

    @dynamic_tags_json.setter
    def dynamic_tags_json(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dynamic_tags_json", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kind of resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="tagWhitelistJson")
    def tag_whitelist_json(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push registration endpoint.
        """
        return pulumi.get(self, "tag_whitelist_json")

    @tag_whitelist_json.setter
    def tag_whitelist_json(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tag_whitelist_json", value)

    @property
    @pulumi.getter(name="tagsRequiringAuth")
    def tags_requiring_auth(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration endpoint.
        Tags can consist of alphanumeric characters and the following:
        '_', '@', '#', '.', ':', '-'. 
        Validation should be performed at the PushRequestHandler.
        """
        return pulumi.get(self, "tags_requiring_auth")

    @tags_requiring_auth.setter
    def tags_requiring_auth(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tags_requiring_auth", value)


if not MYPY:
    class RampUpRuleArgsDict(TypedDict):
        """
        Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to gradually change routing % based on performance.
        """
        action_host_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Hostname of a slot to which the traffic will be redirected if decided to. E.g. myapp-stage.azurewebsites.net.
        """
        change_decision_callback_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified.
        """
        change_interval_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies interval in minutes to reevaluate ReroutePercentage.
        """
        change_step: NotRequired[pulumi.Input[builtins.float]]
        """
        In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches \\n<code>MinReroutePercentage</code> or 
        <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in <code>ChangeIntervalInMinutes</code>.\\nCustom decision algorithm 
        can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
        """
        max_reroute_percentage: NotRequired[pulumi.Input[builtins.float]]
        """
        Specifies upper boundary below which ReroutePercentage will stay.
        """
        min_reroute_percentage: NotRequired[pulumi.Input[builtins.float]]
        """
        Specifies lower boundary above which ReroutePercentage will stay.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the experiment.
        """
        reroute_percentage: NotRequired[pulumi.Input[builtins.float]]
        """
        Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
        """
elif False:
    RampUpRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RampUpRuleArgs:
    def __init__(__self__, *,
                 action_host_name: Optional[pulumi.Input[builtins.str]] = None,
                 change_decision_callback_url: Optional[pulumi.Input[builtins.str]] = None,
                 change_interval_in_minutes: Optional[pulumi.Input[builtins.int]] = None,
                 change_step: Optional[pulumi.Input[builtins.float]] = None,
                 max_reroute_percentage: Optional[pulumi.Input[builtins.float]] = None,
                 min_reroute_percentage: Optional[pulumi.Input[builtins.float]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 reroute_percentage: Optional[pulumi.Input[builtins.float]] = None):
        """
        Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to gradually change routing % based on performance.
        :param pulumi.Input[builtins.str] action_host_name: Hostname of a slot to which the traffic will be redirected if decided to. E.g. myapp-stage.azurewebsites.net.
        :param pulumi.Input[builtins.str] change_decision_callback_url: Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified.
        :param pulumi.Input[builtins.int] change_interval_in_minutes: Specifies interval in minutes to reevaluate ReroutePercentage.
        :param pulumi.Input[builtins.float] change_step: In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches \\n<code>MinReroutePercentage</code> or 
               <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in <code>ChangeIntervalInMinutes</code>.\\nCustom decision algorithm 
               can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
        :param pulumi.Input[builtins.float] max_reroute_percentage: Specifies upper boundary below which ReroutePercentage will stay.
        :param pulumi.Input[builtins.float] min_reroute_percentage: Specifies lower boundary above which ReroutePercentage will stay.
        :param pulumi.Input[builtins.str] name: Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the experiment.
        :param pulumi.Input[builtins.float] reroute_percentage: Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
        """
        if action_host_name is not None:
            pulumi.set(__self__, "action_host_name", action_host_name)
        if change_decision_callback_url is not None:
            pulumi.set(__self__, "change_decision_callback_url", change_decision_callback_url)
        if change_interval_in_minutes is not None:
            pulumi.set(__self__, "change_interval_in_minutes", change_interval_in_minutes)
        if change_step is not None:
            pulumi.set(__self__, "change_step", change_step)
        if max_reroute_percentage is not None:
            pulumi.set(__self__, "max_reroute_percentage", max_reroute_percentage)
        if min_reroute_percentage is not None:
            pulumi.set(__self__, "min_reroute_percentage", min_reroute_percentage)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if reroute_percentage is not None:
            pulumi.set(__self__, "reroute_percentage", reroute_percentage)

    @property
    @pulumi.getter(name="actionHostName")
    def action_host_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hostname of a slot to which the traffic will be redirected if decided to. E.g. myapp-stage.azurewebsites.net.
        """
        return pulumi.get(self, "action_host_name")

    @action_host_name.setter
    def action_host_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action_host_name", value)

    @property
    @pulumi.getter(name="changeDecisionCallbackUrl")
    def change_decision_callback_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified.
        """
        return pulumi.get(self, "change_decision_callback_url")

    @change_decision_callback_url.setter
    def change_decision_callback_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "change_decision_callback_url", value)

    @property
    @pulumi.getter(name="changeIntervalInMinutes")
    def change_interval_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies interval in minutes to reevaluate ReroutePercentage.
        """
        return pulumi.get(self, "change_interval_in_minutes")

    @change_interval_in_minutes.setter
    def change_interval_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "change_interval_in_minutes", value)

    @property
    @pulumi.getter(name="changeStep")
    def change_step(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches \\n<code>MinReroutePercentage</code> or 
        <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in <code>ChangeIntervalInMinutes</code>.\\nCustom decision algorithm 
        can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
        """
        return pulumi.get(self, "change_step")

    @change_step.setter
    def change_step(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "change_step", value)

    @property
    @pulumi.getter(name="maxReroutePercentage")
    def max_reroute_percentage(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Specifies upper boundary below which ReroutePercentage will stay.
        """
        return pulumi.get(self, "max_reroute_percentage")

    @max_reroute_percentage.setter
    def max_reroute_percentage(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "max_reroute_percentage", value)

    @property
    @pulumi.getter(name="minReroutePercentage")
    def min_reroute_percentage(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Specifies lower boundary above which ReroutePercentage will stay.
        """
        return pulumi.get(self, "min_reroute_percentage")

    @min_reroute_percentage.setter
    def min_reroute_percentage(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "min_reroute_percentage", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the experiment.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="reroutePercentage")
    def reroute_percentage(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
        """
        return pulumi.get(self, "reroute_percentage")

    @reroute_percentage.setter
    def reroute_percentage(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "reroute_percentage", value)


if not MYPY:
    class RequestsBasedTriggerArgsDict(TypedDict):
        """
        Trigger based on total requests.
        """
        count: NotRequired[pulumi.Input[builtins.int]]
        """
        Request Count.
        """
        time_interval: NotRequired[pulumi.Input[builtins.str]]
        """
        Time interval.
        """
elif False:
    RequestsBasedTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RequestsBasedTriggerArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[builtins.int]] = None,
                 time_interval: Optional[pulumi.Input[builtins.str]] = None):
        """
        Trigger based on total requests.
        :param pulumi.Input[builtins.int] count: Request Count.
        :param pulumi.Input[builtins.str] time_interval: Time interval.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")

    @time_interval.setter
    def time_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_interval", value)


if not MYPY:
    class ResourceConfigArgsDict(TypedDict):
        """
        Function app resource requirements.
        """
        cpu: NotRequired[pulumi.Input[builtins.float]]
        """
        Required CPU in cores, e.g. 0.5
        """
        memory: NotRequired[pulumi.Input[builtins.str]]
        """
        Required memory, e.g. "1Gi"
        """
elif False:
    ResourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceConfigArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[builtins.float]] = None,
                 memory: Optional[pulumi.Input[builtins.str]] = None):
        """
        Function app resource requirements.
        :param pulumi.Input[builtins.float] cpu: Required CPU in cores, e.g. 0.5
        :param pulumi.Input[builtins.str] memory: Required memory, e.g. "1Gi"
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Required CPU in cores, e.g. 0.5
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required memory, e.g. "1Gi"
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class SiteConfigArgsDict(TypedDict):
        """
        Configuration of an App Service app.
        """
        acr_use_managed_identity_creds: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to use Managed Identity Creds for ACR pull
        """
        acr_user_managed_identity_id: NotRequired[pulumi.Input[builtins.str]]
        """
        If using user managed identity, the user managed identity ClientId
        """
        always_on: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
        """
        api_definition: NotRequired[pulumi.Input['ApiDefinitionInfoArgsDict']]
        """
        Information about the formal API definition for the app.
        """
        api_management_config: NotRequired[pulumi.Input['ApiManagementConfigArgsDict']]
        """
        Azure API management settings linked to the app.
        """
        app_command_line: NotRequired[pulumi.Input[builtins.str]]
        """
        App command line to launch.
        """
        app_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['NameValuePairArgsDict']]]]
        """
        Application settings.
        """
        auto_heal_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
        """
        auto_heal_rules: NotRequired[pulumi.Input['AutoHealRulesArgsDict']]
        """
        Auto Heal rules.
        """
        auto_swap_slot_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Auto-swap slot name.
        """
        azure_storage_accounts: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['AzureStorageInfoValueArgsDict']]]]
        """
        List of Azure Storage Accounts.
        """
        connection_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnStringInfoArgsDict']]]]
        """
        Connection strings.
        """
        cors: NotRequired[pulumi.Input['CorsSettingsArgsDict']]
        """
        Cross-Origin Resource Sharing (CORS) settings.
        """
        default_documents: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Default documents.
        """
        detailed_error_logging_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
        """
        document_root: NotRequired[pulumi.Input[builtins.str]]
        """
        Document root.
        """
        elastic_web_app_scale_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of workers that a site can scale out to.
        This setting only applies to apps in plans where ElasticScaleEnabled is <code>true</code>
        """
        experiments: NotRequired[pulumi.Input['ExperimentsArgsDict']]
        """
        This is work around for polymorphic types.
        """
        ftps_state: NotRequired[pulumi.Input[Union[builtins.str, 'FtpsState']]]
        """
        State of FTP / FTPS service
        """
        function_app_scale_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of workers that a site can scale out to.
        This setting only applies to the Consumption and Elastic Premium Plans
        """
        functions_runtime_scale_monitoring_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Gets or sets a value indicating whether functions runtime scale monitoring is enabled. When enabled,
        the ScaleController will not monitor event sources directly, but will instead call to the
        runtime to get scale status.
        """
        handler_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['HandlerMappingArgsDict']]]]
        """
        Handler mappings.
        """
        health_check_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Health check path
        """
        http20_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Http20Enabled: configures a web site to allow clients to connect over http2.0
        """
        http_logging_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
        """
        ip_security_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgsDict']]]]
        """
        IP security restrictions for main.
        """
        ip_security_restrictions_default_action: NotRequired[pulumi.Input[Union[builtins.str, 'DefaultAction']]]
        """
        Default action for main access restriction if no rules are matched.
        """
        java_container: NotRequired[pulumi.Input[builtins.str]]
        """
        Java container.
        """
        java_container_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Java container version.
        """
        java_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Java version.
        """
        key_vault_reference_identity: NotRequired[pulumi.Input[builtins.str]]
        """
        Identity to use for Key Vault Reference authentication.
        """
        limits: NotRequired[pulumi.Input['SiteLimitsArgsDict']]
        """
        Site limits.
        """
        linux_fx_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Linux App Framework and version
        """
        load_balancing: NotRequired[pulumi.Input['SiteLoadBalancing']]
        """
        Site load balancing.
        """
        local_my_sql_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
        """
        logs_directory_size_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        HTTP logs directory size limit.
        """
        managed_pipeline_mode: NotRequired[pulumi.Input['ManagedPipelineMode']]
        """
        Managed pipeline mode.
        """
        managed_service_identity_id: NotRequired[pulumi.Input[builtins.int]]
        """
        Managed Service Identity Id
        """
        metadata: NotRequired[pulumi.Input[Sequence[pulumi.Input['NameValuePairArgsDict']]]]
        """
        Application metadata. This property cannot be retrieved, since it may contain secrets.
        """
        min_tls_cipher_suite: NotRequired[pulumi.Input[Union[builtins.str, 'TlsCipherSuites']]]
        """
        The minimum strength TLS cipher suite allowed for an application
        """
        min_tls_version: NotRequired[pulumi.Input[Union[builtins.str, 'SupportedTlsVersions']]]
        """
        MinTlsVersion: configures the minimum version of TLS required for SSL requests
        """
        minimum_elastic_instance_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of minimum instance count for a site
        This setting only applies to the Elastic Plans
        """
        net_framework_version: NotRequired[pulumi.Input[builtins.str]]
        """
        .NET Framework version.
        """
        node_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of Node.js.
        """
        number_of_workers: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of workers.
        """
        php_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of PHP.
        """
        power_shell_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of PowerShell.
        """
        pre_warmed_instance_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of preWarmed instances.
        This setting only applies to the Consumption and Elastic Plans
        """
        public_network_access: NotRequired[pulumi.Input[builtins.str]]
        """
        Property to allow or block all public traffic.
        """
        publishing_username: NotRequired[pulumi.Input[builtins.str]]
        """
        Publishing user name.
        """
        push: NotRequired[pulumi.Input['PushSettingsArgsDict']]
        """
        Push endpoint settings.
        """
        python_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of Python.
        """
        remote_debugging_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
        """
        remote_debugging_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Remote debugging version.
        """
        request_tracing_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
        """
        request_tracing_expiration_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Request tracing expiration time.
        """
        scm_ip_security_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgsDict']]]]
        """
        IP security restrictions for scm.
        """
        scm_ip_security_restrictions_default_action: NotRequired[pulumi.Input[Union[builtins.str, 'DefaultAction']]]
        """
        Default action for scm access restriction if no rules are matched.
        """
        scm_ip_security_restrictions_use_main: NotRequired[pulumi.Input[builtins.bool]]
        """
        IP security restrictions for scm to use main.
        """
        scm_min_tls_version: NotRequired[pulumi.Input[Union[builtins.str, 'SupportedTlsVersions']]]
        """
        ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
        """
        scm_type: NotRequired[pulumi.Input[Union[builtins.str, 'ScmType']]]
        """
        SCM type.
        """
        tracing_options: NotRequired[pulumi.Input[builtins.str]]
        """
        Tracing options.
        """
        use32_bit_worker_process: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
        """
        virtual_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualApplicationArgsDict']]]]
        """
        Virtual applications.
        """
        vnet_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Virtual Network name.
        """
        vnet_private_ports_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of private ports assigned to this app. These will be assigned dynamically on runtime.
        """
        vnet_route_all_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied.
        """
        web_sockets_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
        """
        website_time_zone: NotRequired[pulumi.Input[builtins.str]]
        """
        Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App Service. Setting the WEBSITE_TIME_ZONE app setting takes precedence over this config. For Linux, expects tz database values https://www.iana.org/time-zones (for a quick reference see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time zones listed under HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones
        """
        windows_fx_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Xenon App Framework and version
        """
        x_managed_service_identity_id: NotRequired[pulumi.Input[builtins.int]]
        """
        Explicit Managed Service Identity Id
        """
elif False:
    SiteConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteConfigArgs:
    def __init__(__self__, *,
                 acr_use_managed_identity_creds: Optional[pulumi.Input[builtins.bool]] = None,
                 acr_user_managed_identity_id: Optional[pulumi.Input[builtins.str]] = None,
                 always_on: Optional[pulumi.Input[builtins.bool]] = None,
                 api_definition: Optional[pulumi.Input['ApiDefinitionInfoArgs']] = None,
                 api_management_config: Optional[pulumi.Input['ApiManagementConfigArgs']] = None,
                 app_command_line: Optional[pulumi.Input[builtins.str]] = None,
                 app_settings: Optional[pulumi.Input[Sequence[pulumi.Input['NameValuePairArgs']]]] = None,
                 auto_heal_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 auto_heal_rules: Optional[pulumi.Input['AutoHealRulesArgs']] = None,
                 auto_swap_slot_name: Optional[pulumi.Input[builtins.str]] = None,
                 azure_storage_accounts: Optional[pulumi.Input[Mapping[str, pulumi.Input['AzureStorageInfoValueArgs']]]] = None,
                 connection_strings: Optional[pulumi.Input[Sequence[pulumi.Input['ConnStringInfoArgs']]]] = None,
                 cors: Optional[pulumi.Input['CorsSettingsArgs']] = None,
                 default_documents: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 detailed_error_logging_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 document_root: Optional[pulumi.Input[builtins.str]] = None,
                 elastic_web_app_scale_limit: Optional[pulumi.Input[builtins.int]] = None,
                 experiments: Optional[pulumi.Input['ExperimentsArgs']] = None,
                 ftps_state: Optional[pulumi.Input[Union[builtins.str, 'FtpsState']]] = None,
                 function_app_scale_limit: Optional[pulumi.Input[builtins.int]] = None,
                 functions_runtime_scale_monitoring_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 handler_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['HandlerMappingArgs']]]] = None,
                 health_check_path: Optional[pulumi.Input[builtins.str]] = None,
                 http20_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 http_logging_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 ip_security_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]] = None,
                 ip_security_restrictions_default_action: Optional[pulumi.Input[Union[builtins.str, 'DefaultAction']]] = None,
                 java_container: Optional[pulumi.Input[builtins.str]] = None,
                 java_container_version: Optional[pulumi.Input[builtins.str]] = None,
                 java_version: Optional[pulumi.Input[builtins.str]] = None,
                 key_vault_reference_identity: Optional[pulumi.Input[builtins.str]] = None,
                 limits: Optional[pulumi.Input['SiteLimitsArgs']] = None,
                 linux_fx_version: Optional[pulumi.Input[builtins.str]] = None,
                 load_balancing: Optional[pulumi.Input['SiteLoadBalancing']] = None,
                 local_my_sql_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 logs_directory_size_limit: Optional[pulumi.Input[builtins.int]] = None,
                 managed_pipeline_mode: Optional[pulumi.Input['ManagedPipelineMode']] = None,
                 managed_service_identity_id: Optional[pulumi.Input[builtins.int]] = None,
                 metadata: Optional[pulumi.Input[Sequence[pulumi.Input['NameValuePairArgs']]]] = None,
                 min_tls_cipher_suite: Optional[pulumi.Input[Union[builtins.str, 'TlsCipherSuites']]] = None,
                 min_tls_version: Optional[pulumi.Input[Union[builtins.str, 'SupportedTlsVersions']]] = None,
                 minimum_elastic_instance_count: Optional[pulumi.Input[builtins.int]] = None,
                 net_framework_version: Optional[pulumi.Input[builtins.str]] = None,
                 node_version: Optional[pulumi.Input[builtins.str]] = None,
                 number_of_workers: Optional[pulumi.Input[builtins.int]] = None,
                 php_version: Optional[pulumi.Input[builtins.str]] = None,
                 power_shell_version: Optional[pulumi.Input[builtins.str]] = None,
                 pre_warmed_instance_count: Optional[pulumi.Input[builtins.int]] = None,
                 public_network_access: Optional[pulumi.Input[builtins.str]] = None,
                 publishing_username: Optional[pulumi.Input[builtins.str]] = None,
                 push: Optional[pulumi.Input['PushSettingsArgs']] = None,
                 python_version: Optional[pulumi.Input[builtins.str]] = None,
                 remote_debugging_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 remote_debugging_version: Optional[pulumi.Input[builtins.str]] = None,
                 request_tracing_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 request_tracing_expiration_time: Optional[pulumi.Input[builtins.str]] = None,
                 scm_ip_security_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]] = None,
                 scm_ip_security_restrictions_default_action: Optional[pulumi.Input[Union[builtins.str, 'DefaultAction']]] = None,
                 scm_ip_security_restrictions_use_main: Optional[pulumi.Input[builtins.bool]] = None,
                 scm_min_tls_version: Optional[pulumi.Input[Union[builtins.str, 'SupportedTlsVersions']]] = None,
                 scm_type: Optional[pulumi.Input[Union[builtins.str, 'ScmType']]] = None,
                 tracing_options: Optional[pulumi.Input[builtins.str]] = None,
                 use32_bit_worker_process: Optional[pulumi.Input[builtins.bool]] = None,
                 virtual_applications: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualApplicationArgs']]]] = None,
                 vnet_name: Optional[pulumi.Input[builtins.str]] = None,
                 vnet_private_ports_count: Optional[pulumi.Input[builtins.int]] = None,
                 vnet_route_all_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 web_sockets_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 website_time_zone: Optional[pulumi.Input[builtins.str]] = None,
                 windows_fx_version: Optional[pulumi.Input[builtins.str]] = None,
                 x_managed_service_identity_id: Optional[pulumi.Input[builtins.int]] = None):
        """
        Configuration of an App Service app.
        :param pulumi.Input[builtins.bool] acr_use_managed_identity_creds: Flag to use Managed Identity Creds for ACR pull
        :param pulumi.Input[builtins.str] acr_user_managed_identity_id: If using user managed identity, the user managed identity ClientId
        :param pulumi.Input[builtins.bool] always_on: <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
        :param pulumi.Input['ApiDefinitionInfoArgs'] api_definition: Information about the formal API definition for the app.
        :param pulumi.Input['ApiManagementConfigArgs'] api_management_config: Azure API management settings linked to the app.
        :param pulumi.Input[builtins.str] app_command_line: App command line to launch.
        :param pulumi.Input[Sequence[pulumi.Input['NameValuePairArgs']]] app_settings: Application settings.
        :param pulumi.Input[builtins.bool] auto_heal_enabled: <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
        :param pulumi.Input['AutoHealRulesArgs'] auto_heal_rules: Auto Heal rules.
        :param pulumi.Input[builtins.str] auto_swap_slot_name: Auto-swap slot name.
        :param pulumi.Input[Mapping[str, pulumi.Input['AzureStorageInfoValueArgs']]] azure_storage_accounts: List of Azure Storage Accounts.
        :param pulumi.Input[Sequence[pulumi.Input['ConnStringInfoArgs']]] connection_strings: Connection strings.
        :param pulumi.Input['CorsSettingsArgs'] cors: Cross-Origin Resource Sharing (CORS) settings.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] default_documents: Default documents.
        :param pulumi.Input[builtins.bool] detailed_error_logging_enabled: <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
        :param pulumi.Input[builtins.str] document_root: Document root.
        :param pulumi.Input[builtins.int] elastic_web_app_scale_limit: Maximum number of workers that a site can scale out to.
               This setting only applies to apps in plans where ElasticScaleEnabled is <code>true</code>
        :param pulumi.Input['ExperimentsArgs'] experiments: This is work around for polymorphic types.
        :param pulumi.Input[Union[builtins.str, 'FtpsState']] ftps_state: State of FTP / FTPS service
        :param pulumi.Input[builtins.int] function_app_scale_limit: Maximum number of workers that a site can scale out to.
               This setting only applies to the Consumption and Elastic Premium Plans
        :param pulumi.Input[builtins.bool] functions_runtime_scale_monitoring_enabled: Gets or sets a value indicating whether functions runtime scale monitoring is enabled. When enabled,
               the ScaleController will not monitor event sources directly, but will instead call to the
               runtime to get scale status.
        :param pulumi.Input[Sequence[pulumi.Input['HandlerMappingArgs']]] handler_mappings: Handler mappings.
        :param pulumi.Input[builtins.str] health_check_path: Health check path
        :param pulumi.Input[builtins.bool] http20_enabled: Http20Enabled: configures a web site to allow clients to connect over http2.0
        :param pulumi.Input[builtins.bool] http_logging_enabled: <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
        :param pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]] ip_security_restrictions: IP security restrictions for main.
        :param pulumi.Input[Union[builtins.str, 'DefaultAction']] ip_security_restrictions_default_action: Default action for main access restriction if no rules are matched.
        :param pulumi.Input[builtins.str] java_container: Java container.
        :param pulumi.Input[builtins.str] java_container_version: Java container version.
        :param pulumi.Input[builtins.str] java_version: Java version.
        :param pulumi.Input[builtins.str] key_vault_reference_identity: Identity to use for Key Vault Reference authentication.
        :param pulumi.Input['SiteLimitsArgs'] limits: Site limits.
        :param pulumi.Input[builtins.str] linux_fx_version: Linux App Framework and version
        :param pulumi.Input['SiteLoadBalancing'] load_balancing: Site load balancing.
        :param pulumi.Input[builtins.bool] local_my_sql_enabled: <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
        :param pulumi.Input[builtins.int] logs_directory_size_limit: HTTP logs directory size limit.
        :param pulumi.Input['ManagedPipelineMode'] managed_pipeline_mode: Managed pipeline mode.
        :param pulumi.Input[builtins.int] managed_service_identity_id: Managed Service Identity Id
        :param pulumi.Input[Sequence[pulumi.Input['NameValuePairArgs']]] metadata: Application metadata. This property cannot be retrieved, since it may contain secrets.
        :param pulumi.Input[Union[builtins.str, 'TlsCipherSuites']] min_tls_cipher_suite: The minimum strength TLS cipher suite allowed for an application
        :param pulumi.Input[Union[builtins.str, 'SupportedTlsVersions']] min_tls_version: MinTlsVersion: configures the minimum version of TLS required for SSL requests
        :param pulumi.Input[builtins.int] minimum_elastic_instance_count: Number of minimum instance count for a site
               This setting only applies to the Elastic Plans
        :param pulumi.Input[builtins.str] net_framework_version: .NET Framework version.
        :param pulumi.Input[builtins.str] node_version: Version of Node.js.
        :param pulumi.Input[builtins.int] number_of_workers: Number of workers.
        :param pulumi.Input[builtins.str] php_version: Version of PHP.
        :param pulumi.Input[builtins.str] power_shell_version: Version of PowerShell.
        :param pulumi.Input[builtins.int] pre_warmed_instance_count: Number of preWarmed instances.
               This setting only applies to the Consumption and Elastic Plans
        :param pulumi.Input[builtins.str] public_network_access: Property to allow or block all public traffic.
        :param pulumi.Input[builtins.str] publishing_username: Publishing user name.
        :param pulumi.Input['PushSettingsArgs'] push: Push endpoint settings.
        :param pulumi.Input[builtins.str] python_version: Version of Python.
        :param pulumi.Input[builtins.bool] remote_debugging_enabled: <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
        :param pulumi.Input[builtins.str] remote_debugging_version: Remote debugging version.
        :param pulumi.Input[builtins.bool] request_tracing_enabled: <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
        :param pulumi.Input[builtins.str] request_tracing_expiration_time: Request tracing expiration time.
        :param pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]] scm_ip_security_restrictions: IP security restrictions for scm.
        :param pulumi.Input[Union[builtins.str, 'DefaultAction']] scm_ip_security_restrictions_default_action: Default action for scm access restriction if no rules are matched.
        :param pulumi.Input[builtins.bool] scm_ip_security_restrictions_use_main: IP security restrictions for scm to use main.
        :param pulumi.Input[Union[builtins.str, 'SupportedTlsVersions']] scm_min_tls_version: ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
        :param pulumi.Input[Union[builtins.str, 'ScmType']] scm_type: SCM type.
        :param pulumi.Input[builtins.str] tracing_options: Tracing options.
        :param pulumi.Input[builtins.bool] use32_bit_worker_process: <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualApplicationArgs']]] virtual_applications: Virtual applications.
        :param pulumi.Input[builtins.str] vnet_name: Virtual Network name.
        :param pulumi.Input[builtins.int] vnet_private_ports_count: The number of private ports assigned to this app. These will be assigned dynamically on runtime.
        :param pulumi.Input[builtins.bool] vnet_route_all_enabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied.
        :param pulumi.Input[builtins.bool] web_sockets_enabled: <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
        :param pulumi.Input[builtins.str] website_time_zone: Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App Service. Setting the WEBSITE_TIME_ZONE app setting takes precedence over this config. For Linux, expects tz database values https://www.iana.org/time-zones (for a quick reference see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time zones listed under HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones
        :param pulumi.Input[builtins.str] windows_fx_version: Xenon App Framework and version
        :param pulumi.Input[builtins.int] x_managed_service_identity_id: Explicit Managed Service Identity Id
        """
        if acr_use_managed_identity_creds is not None:
            pulumi.set(__self__, "acr_use_managed_identity_creds", acr_use_managed_identity_creds)
        if acr_user_managed_identity_id is not None:
            pulumi.set(__self__, "acr_user_managed_identity_id", acr_user_managed_identity_id)
        if always_on is not None:
            pulumi.set(__self__, "always_on", always_on)
        if api_definition is not None:
            pulumi.set(__self__, "api_definition", api_definition)
        if api_management_config is not None:
            pulumi.set(__self__, "api_management_config", api_management_config)
        if app_command_line is not None:
            pulumi.set(__self__, "app_command_line", app_command_line)
        if app_settings is not None:
            pulumi.set(__self__, "app_settings", app_settings)
        if auto_heal_enabled is not None:
            pulumi.set(__self__, "auto_heal_enabled", auto_heal_enabled)
        if auto_heal_rules is not None:
            pulumi.set(__self__, "auto_heal_rules", auto_heal_rules)
        if auto_swap_slot_name is not None:
            pulumi.set(__self__, "auto_swap_slot_name", auto_swap_slot_name)
        if azure_storage_accounts is not None:
            pulumi.set(__self__, "azure_storage_accounts", azure_storage_accounts)
        if connection_strings is not None:
            pulumi.set(__self__, "connection_strings", connection_strings)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if default_documents is not None:
            pulumi.set(__self__, "default_documents", default_documents)
        if detailed_error_logging_enabled is not None:
            pulumi.set(__self__, "detailed_error_logging_enabled", detailed_error_logging_enabled)
        if document_root is not None:
            pulumi.set(__self__, "document_root", document_root)
        if elastic_web_app_scale_limit is not None:
            pulumi.set(__self__, "elastic_web_app_scale_limit", elastic_web_app_scale_limit)
        if experiments is not None:
            pulumi.set(__self__, "experiments", experiments)
        if ftps_state is not None:
            pulumi.set(__self__, "ftps_state", ftps_state)
        if function_app_scale_limit is not None:
            pulumi.set(__self__, "function_app_scale_limit", function_app_scale_limit)
        if functions_runtime_scale_monitoring_enabled is not None:
            pulumi.set(__self__, "functions_runtime_scale_monitoring_enabled", functions_runtime_scale_monitoring_enabled)
        if handler_mappings is not None:
            pulumi.set(__self__, "handler_mappings", handler_mappings)
        if health_check_path is not None:
            pulumi.set(__self__, "health_check_path", health_check_path)
        if http20_enabled is None:
            http20_enabled = True
        if http20_enabled is not None:
            pulumi.set(__self__, "http20_enabled", http20_enabled)
        if http_logging_enabled is not None:
            pulumi.set(__self__, "http_logging_enabled", http_logging_enabled)
        if ip_security_restrictions is not None:
            pulumi.set(__self__, "ip_security_restrictions", ip_security_restrictions)
        if ip_security_restrictions_default_action is not None:
            pulumi.set(__self__, "ip_security_restrictions_default_action", ip_security_restrictions_default_action)
        if java_container is not None:
            pulumi.set(__self__, "java_container", java_container)
        if java_container_version is not None:
            pulumi.set(__self__, "java_container_version", java_container_version)
        if java_version is not None:
            pulumi.set(__self__, "java_version", java_version)
        if key_vault_reference_identity is not None:
            pulumi.set(__self__, "key_vault_reference_identity", key_vault_reference_identity)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if linux_fx_version is not None:
            pulumi.set(__self__, "linux_fx_version", linux_fx_version)
        if load_balancing is not None:
            pulumi.set(__self__, "load_balancing", load_balancing)
        if local_my_sql_enabled is None:
            local_my_sql_enabled = False
        if local_my_sql_enabled is not None:
            pulumi.set(__self__, "local_my_sql_enabled", local_my_sql_enabled)
        if logs_directory_size_limit is not None:
            pulumi.set(__self__, "logs_directory_size_limit", logs_directory_size_limit)
        if managed_pipeline_mode is not None:
            pulumi.set(__self__, "managed_pipeline_mode", managed_pipeline_mode)
        if managed_service_identity_id is not None:
            pulumi.set(__self__, "managed_service_identity_id", managed_service_identity_id)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if min_tls_cipher_suite is not None:
            pulumi.set(__self__, "min_tls_cipher_suite", min_tls_cipher_suite)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if minimum_elastic_instance_count is not None:
            pulumi.set(__self__, "minimum_elastic_instance_count", minimum_elastic_instance_count)
        if net_framework_version is None:
            net_framework_version = 'v4.6'
        if net_framework_version is not None:
            pulumi.set(__self__, "net_framework_version", net_framework_version)
        if node_version is not None:
            pulumi.set(__self__, "node_version", node_version)
        if number_of_workers is not None:
            pulumi.set(__self__, "number_of_workers", number_of_workers)
        if php_version is not None:
            pulumi.set(__self__, "php_version", php_version)
        if power_shell_version is not None:
            pulumi.set(__self__, "power_shell_version", power_shell_version)
        if pre_warmed_instance_count is not None:
            pulumi.set(__self__, "pre_warmed_instance_count", pre_warmed_instance_count)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if publishing_username is not None:
            pulumi.set(__self__, "publishing_username", publishing_username)
        if push is not None:
            pulumi.set(__self__, "push", push)
        if python_version is not None:
            pulumi.set(__self__, "python_version", python_version)
        if remote_debugging_enabled is not None:
            pulumi.set(__self__, "remote_debugging_enabled", remote_debugging_enabled)
        if remote_debugging_version is not None:
            pulumi.set(__self__, "remote_debugging_version", remote_debugging_version)
        if request_tracing_enabled is not None:
            pulumi.set(__self__, "request_tracing_enabled", request_tracing_enabled)
        if request_tracing_expiration_time is not None:
            pulumi.set(__self__, "request_tracing_expiration_time", request_tracing_expiration_time)
        if scm_ip_security_restrictions is not None:
            pulumi.set(__self__, "scm_ip_security_restrictions", scm_ip_security_restrictions)
        if scm_ip_security_restrictions_default_action is not None:
            pulumi.set(__self__, "scm_ip_security_restrictions_default_action", scm_ip_security_restrictions_default_action)
        if scm_ip_security_restrictions_use_main is not None:
            pulumi.set(__self__, "scm_ip_security_restrictions_use_main", scm_ip_security_restrictions_use_main)
        if scm_min_tls_version is not None:
            pulumi.set(__self__, "scm_min_tls_version", scm_min_tls_version)
        if scm_type is not None:
            pulumi.set(__self__, "scm_type", scm_type)
        if tracing_options is not None:
            pulumi.set(__self__, "tracing_options", tracing_options)
        if use32_bit_worker_process is not None:
            pulumi.set(__self__, "use32_bit_worker_process", use32_bit_worker_process)
        if virtual_applications is not None:
            pulumi.set(__self__, "virtual_applications", virtual_applications)
        if vnet_name is not None:
            pulumi.set(__self__, "vnet_name", vnet_name)
        if vnet_private_ports_count is not None:
            pulumi.set(__self__, "vnet_private_ports_count", vnet_private_ports_count)
        if vnet_route_all_enabled is not None:
            pulumi.set(__self__, "vnet_route_all_enabled", vnet_route_all_enabled)
        if web_sockets_enabled is not None:
            pulumi.set(__self__, "web_sockets_enabled", web_sockets_enabled)
        if website_time_zone is not None:
            pulumi.set(__self__, "website_time_zone", website_time_zone)
        if windows_fx_version is not None:
            pulumi.set(__self__, "windows_fx_version", windows_fx_version)
        if x_managed_service_identity_id is not None:
            pulumi.set(__self__, "x_managed_service_identity_id", x_managed_service_identity_id)

    @property
    @pulumi.getter(name="acrUseManagedIdentityCreds")
    def acr_use_managed_identity_creds(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to use Managed Identity Creds for ACR pull
        """
        return pulumi.get(self, "acr_use_managed_identity_creds")

    @acr_use_managed_identity_creds.setter
    def acr_use_managed_identity_creds(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "acr_use_managed_identity_creds", value)

    @property
    @pulumi.getter(name="acrUserManagedIdentityID")
    def acr_user_managed_identity_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If using user managed identity, the user managed identity ClientId
        """
        return pulumi.get(self, "acr_user_managed_identity_id")

    @acr_user_managed_identity_id.setter
    def acr_user_managed_identity_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "acr_user_managed_identity_id", value)

    @property
    @pulumi.getter(name="alwaysOn")
    def always_on(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "always_on")

    @always_on.setter
    def always_on(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "always_on", value)

    @property
    @pulumi.getter(name="apiDefinition")
    def api_definition(self) -> Optional[pulumi.Input['ApiDefinitionInfoArgs']]:
        """
        Information about the formal API definition for the app.
        """
        return pulumi.get(self, "api_definition")

    @api_definition.setter
    def api_definition(self, value: Optional[pulumi.Input['ApiDefinitionInfoArgs']]):
        pulumi.set(self, "api_definition", value)

    @property
    @pulumi.getter(name="apiManagementConfig")
    def api_management_config(self) -> Optional[pulumi.Input['ApiManagementConfigArgs']]:
        """
        Azure API management settings linked to the app.
        """
        return pulumi.get(self, "api_management_config")

    @api_management_config.setter
    def api_management_config(self, value: Optional[pulumi.Input['ApiManagementConfigArgs']]):
        pulumi.set(self, "api_management_config", value)

    @property
    @pulumi.getter(name="appCommandLine")
    def app_command_line(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        App command line to launch.
        """
        return pulumi.get(self, "app_command_line")

    @app_command_line.setter
    def app_command_line(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "app_command_line", value)

    @property
    @pulumi.getter(name="appSettings")
    def app_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NameValuePairArgs']]]]:
        """
        Application settings.
        """
        return pulumi.get(self, "app_settings")

    @app_settings.setter
    def app_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NameValuePairArgs']]]]):
        pulumi.set(self, "app_settings", value)

    @property
    @pulumi.getter(name="autoHealEnabled")
    def auto_heal_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "auto_heal_enabled")

    @auto_heal_enabled.setter
    def auto_heal_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "auto_heal_enabled", value)

    @property
    @pulumi.getter(name="autoHealRules")
    def auto_heal_rules(self) -> Optional[pulumi.Input['AutoHealRulesArgs']]:
        """
        Auto Heal rules.
        """
        return pulumi.get(self, "auto_heal_rules")

    @auto_heal_rules.setter
    def auto_heal_rules(self, value: Optional[pulumi.Input['AutoHealRulesArgs']]):
        pulumi.set(self, "auto_heal_rules", value)

    @property
    @pulumi.getter(name="autoSwapSlotName")
    def auto_swap_slot_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Auto-swap slot name.
        """
        return pulumi.get(self, "auto_swap_slot_name")

    @auto_swap_slot_name.setter
    def auto_swap_slot_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auto_swap_slot_name", value)

    @property
    @pulumi.getter(name="azureStorageAccounts")
    def azure_storage_accounts(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['AzureStorageInfoValueArgs']]]]:
        """
        List of Azure Storage Accounts.
        """
        return pulumi.get(self, "azure_storage_accounts")

    @azure_storage_accounts.setter
    def azure_storage_accounts(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['AzureStorageInfoValueArgs']]]]):
        pulumi.set(self, "azure_storage_accounts", value)

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnStringInfoArgs']]]]:
        """
        Connection strings.
        """
        return pulumi.get(self, "connection_strings")

    @connection_strings.setter
    def connection_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnStringInfoArgs']]]]):
        pulumi.set(self, "connection_strings", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['CorsSettingsArgs']]:
        """
        Cross-Origin Resource Sharing (CORS) settings.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['CorsSettingsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="defaultDocuments")
    def default_documents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Default documents.
        """
        return pulumi.get(self, "default_documents")

    @default_documents.setter
    def default_documents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "default_documents", value)

    @property
    @pulumi.getter(name="detailedErrorLoggingEnabled")
    def detailed_error_logging_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "detailed_error_logging_enabled")

    @detailed_error_logging_enabled.setter
    def detailed_error_logging_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "detailed_error_logging_enabled", value)

    @property
    @pulumi.getter(name="documentRoot")
    def document_root(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Document root.
        """
        return pulumi.get(self, "document_root")

    @document_root.setter
    def document_root(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "document_root", value)

    @property
    @pulumi.getter(name="elasticWebAppScaleLimit")
    def elastic_web_app_scale_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of workers that a site can scale out to.
        This setting only applies to apps in plans where ElasticScaleEnabled is <code>true</code>
        """
        return pulumi.get(self, "elastic_web_app_scale_limit")

    @elastic_web_app_scale_limit.setter
    def elastic_web_app_scale_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "elastic_web_app_scale_limit", value)

    @property
    @pulumi.getter
    def experiments(self) -> Optional[pulumi.Input['ExperimentsArgs']]:
        """
        This is work around for polymorphic types.
        """
        return pulumi.get(self, "experiments")

    @experiments.setter
    def experiments(self, value: Optional[pulumi.Input['ExperimentsArgs']]):
        pulumi.set(self, "experiments", value)

    @property
    @pulumi.getter(name="ftpsState")
    def ftps_state(self) -> Optional[pulumi.Input[Union[builtins.str, 'FtpsState']]]:
        """
        State of FTP / FTPS service
        """
        return pulumi.get(self, "ftps_state")

    @ftps_state.setter
    def ftps_state(self, value: Optional[pulumi.Input[Union[builtins.str, 'FtpsState']]]):
        pulumi.set(self, "ftps_state", value)

    @property
    @pulumi.getter(name="functionAppScaleLimit")
    def function_app_scale_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of workers that a site can scale out to.
        This setting only applies to the Consumption and Elastic Premium Plans
        """
        return pulumi.get(self, "function_app_scale_limit")

    @function_app_scale_limit.setter
    def function_app_scale_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "function_app_scale_limit", value)

    @property
    @pulumi.getter(name="functionsRuntimeScaleMonitoringEnabled")
    def functions_runtime_scale_monitoring_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Gets or sets a value indicating whether functions runtime scale monitoring is enabled. When enabled,
        the ScaleController will not monitor event sources directly, but will instead call to the
        runtime to get scale status.
        """
        return pulumi.get(self, "functions_runtime_scale_monitoring_enabled")

    @functions_runtime_scale_monitoring_enabled.setter
    def functions_runtime_scale_monitoring_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "functions_runtime_scale_monitoring_enabled", value)

    @property
    @pulumi.getter(name="handlerMappings")
    def handler_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HandlerMappingArgs']]]]:
        """
        Handler mappings.
        """
        return pulumi.get(self, "handler_mappings")

    @handler_mappings.setter
    def handler_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HandlerMappingArgs']]]]):
        pulumi.set(self, "handler_mappings", value)

    @property
    @pulumi.getter(name="healthCheckPath")
    def health_check_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Health check path
        """
        return pulumi.get(self, "health_check_path")

    @health_check_path.setter
    def health_check_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "health_check_path", value)

    @property
    @pulumi.getter(name="http20Enabled")
    def http20_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Http20Enabled: configures a web site to allow clients to connect over http2.0
        """
        return pulumi.get(self, "http20_enabled")

    @http20_enabled.setter
    def http20_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "http20_enabled", value)

    @property
    @pulumi.getter(name="httpLoggingEnabled")
    def http_logging_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "http_logging_enabled")

    @http_logging_enabled.setter
    def http_logging_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "http_logging_enabled", value)

    @property
    @pulumi.getter(name="ipSecurityRestrictions")
    def ip_security_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]]:
        """
        IP security restrictions for main.
        """
        return pulumi.get(self, "ip_security_restrictions")

    @ip_security_restrictions.setter
    def ip_security_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]]):
        pulumi.set(self, "ip_security_restrictions", value)

    @property
    @pulumi.getter(name="ipSecurityRestrictionsDefaultAction")
    def ip_security_restrictions_default_action(self) -> Optional[pulumi.Input[Union[builtins.str, 'DefaultAction']]]:
        """
        Default action for main access restriction if no rules are matched.
        """
        return pulumi.get(self, "ip_security_restrictions_default_action")

    @ip_security_restrictions_default_action.setter
    def ip_security_restrictions_default_action(self, value: Optional[pulumi.Input[Union[builtins.str, 'DefaultAction']]]):
        pulumi.set(self, "ip_security_restrictions_default_action", value)

    @property
    @pulumi.getter(name="javaContainer")
    def java_container(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Java container.
        """
        return pulumi.get(self, "java_container")

    @java_container.setter
    def java_container(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "java_container", value)

    @property
    @pulumi.getter(name="javaContainerVersion")
    def java_container_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Java container version.
        """
        return pulumi.get(self, "java_container_version")

    @java_container_version.setter
    def java_container_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "java_container_version", value)

    @property
    @pulumi.getter(name="javaVersion")
    def java_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Java version.
        """
        return pulumi.get(self, "java_version")

    @java_version.setter
    def java_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "java_version", value)

    @property
    @pulumi.getter(name="keyVaultReferenceIdentity")
    def key_vault_reference_identity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identity to use for Key Vault Reference authentication.
        """
        return pulumi.get(self, "key_vault_reference_identity")

    @key_vault_reference_identity.setter
    def key_vault_reference_identity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_vault_reference_identity", value)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input['SiteLimitsArgs']]:
        """
        Site limits.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input['SiteLimitsArgs']]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter(name="linuxFxVersion")
    def linux_fx_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Linux App Framework and version
        """
        return pulumi.get(self, "linux_fx_version")

    @linux_fx_version.setter
    def linux_fx_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "linux_fx_version", value)

    @property
    @pulumi.getter(name="loadBalancing")
    def load_balancing(self) -> Optional[pulumi.Input['SiteLoadBalancing']]:
        """
        Site load balancing.
        """
        return pulumi.get(self, "load_balancing")

    @load_balancing.setter
    def load_balancing(self, value: Optional[pulumi.Input['SiteLoadBalancing']]):
        pulumi.set(self, "load_balancing", value)

    @property
    @pulumi.getter(name="localMySqlEnabled")
    def local_my_sql_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "local_my_sql_enabled")

    @local_my_sql_enabled.setter
    def local_my_sql_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "local_my_sql_enabled", value)

    @property
    @pulumi.getter(name="logsDirectorySizeLimit")
    def logs_directory_size_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        HTTP logs directory size limit.
        """
        return pulumi.get(self, "logs_directory_size_limit")

    @logs_directory_size_limit.setter
    def logs_directory_size_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "logs_directory_size_limit", value)

    @property
    @pulumi.getter(name="managedPipelineMode")
    def managed_pipeline_mode(self) -> Optional[pulumi.Input['ManagedPipelineMode']]:
        """
        Managed pipeline mode.
        """
        return pulumi.get(self, "managed_pipeline_mode")

    @managed_pipeline_mode.setter
    def managed_pipeline_mode(self, value: Optional[pulumi.Input['ManagedPipelineMode']]):
        pulumi.set(self, "managed_pipeline_mode", value)

    @property
    @pulumi.getter(name="managedServiceIdentityId")
    def managed_service_identity_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Managed Service Identity Id
        """
        return pulumi.get(self, "managed_service_identity_id")

    @managed_service_identity_id.setter
    def managed_service_identity_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "managed_service_identity_id", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NameValuePairArgs']]]]:
        """
        Application metadata. This property cannot be retrieved, since it may contain secrets.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NameValuePairArgs']]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="minTlsCipherSuite")
    def min_tls_cipher_suite(self) -> Optional[pulumi.Input[Union[builtins.str, 'TlsCipherSuites']]]:
        """
        The minimum strength TLS cipher suite allowed for an application
        """
        return pulumi.get(self, "min_tls_cipher_suite")

    @min_tls_cipher_suite.setter
    def min_tls_cipher_suite(self, value: Optional[pulumi.Input[Union[builtins.str, 'TlsCipherSuites']]]):
        pulumi.set(self, "min_tls_cipher_suite", value)

    @property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[Union[builtins.str, 'SupportedTlsVersions']]]:
        """
        MinTlsVersion: configures the minimum version of TLS required for SSL requests
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[Union[builtins.str, 'SupportedTlsVersions']]]):
        pulumi.set(self, "min_tls_version", value)

    @property
    @pulumi.getter(name="minimumElasticInstanceCount")
    def minimum_elastic_instance_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of minimum instance count for a site
        This setting only applies to the Elastic Plans
        """
        return pulumi.get(self, "minimum_elastic_instance_count")

    @minimum_elastic_instance_count.setter
    def minimum_elastic_instance_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "minimum_elastic_instance_count", value)

    @property
    @pulumi.getter(name="netFrameworkVersion")
    def net_framework_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        .NET Framework version.
        """
        return pulumi.get(self, "net_framework_version")

    @net_framework_version.setter
    def net_framework_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "net_framework_version", value)

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of Node.js.
        """
        return pulumi.get(self, "node_version")

    @node_version.setter
    def node_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "node_version", value)

    @property
    @pulumi.getter(name="numberOfWorkers")
    def number_of_workers(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of workers.
        """
        return pulumi.get(self, "number_of_workers")

    @number_of_workers.setter
    def number_of_workers(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "number_of_workers", value)

    @property
    @pulumi.getter(name="phpVersion")
    def php_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of PHP.
        """
        return pulumi.get(self, "php_version")

    @php_version.setter
    def php_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "php_version", value)

    @property
    @pulumi.getter(name="powerShellVersion")
    def power_shell_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of PowerShell.
        """
        return pulumi.get(self, "power_shell_version")

    @power_shell_version.setter
    def power_shell_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "power_shell_version", value)

    @property
    @pulumi.getter(name="preWarmedInstanceCount")
    def pre_warmed_instance_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of preWarmed instances.
        This setting only applies to the Consumption and Elastic Plans
        """
        return pulumi.get(self, "pre_warmed_instance_count")

    @pre_warmed_instance_count.setter
    def pre_warmed_instance_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "pre_warmed_instance_count", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Property to allow or block all public traffic.
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_network_access", value)

    @property
    @pulumi.getter(name="publishingUsername")
    def publishing_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Publishing user name.
        """
        return pulumi.get(self, "publishing_username")

    @publishing_username.setter
    def publishing_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "publishing_username", value)

    @property
    @pulumi.getter
    def push(self) -> Optional[pulumi.Input['PushSettingsArgs']]:
        """
        Push endpoint settings.
        """
        return pulumi.get(self, "push")

    @push.setter
    def push(self, value: Optional[pulumi.Input['PushSettingsArgs']]):
        pulumi.set(self, "push", value)

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of Python.
        """
        return pulumi.get(self, "python_version")

    @python_version.setter
    def python_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "python_version", value)

    @property
    @pulumi.getter(name="remoteDebuggingEnabled")
    def remote_debugging_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "remote_debugging_enabled")

    @remote_debugging_enabled.setter
    def remote_debugging_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "remote_debugging_enabled", value)

    @property
    @pulumi.getter(name="remoteDebuggingVersion")
    def remote_debugging_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Remote debugging version.
        """
        return pulumi.get(self, "remote_debugging_version")

    @remote_debugging_version.setter
    def remote_debugging_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "remote_debugging_version", value)

    @property
    @pulumi.getter(name="requestTracingEnabled")
    def request_tracing_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "request_tracing_enabled")

    @request_tracing_enabled.setter
    def request_tracing_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "request_tracing_enabled", value)

    @property
    @pulumi.getter(name="requestTracingExpirationTime")
    def request_tracing_expiration_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Request tracing expiration time.
        """
        return pulumi.get(self, "request_tracing_expiration_time")

    @request_tracing_expiration_time.setter
    def request_tracing_expiration_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "request_tracing_expiration_time", value)

    @property
    @pulumi.getter(name="scmIpSecurityRestrictions")
    def scm_ip_security_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]]:
        """
        IP security restrictions for scm.
        """
        return pulumi.get(self, "scm_ip_security_restrictions")

    @scm_ip_security_restrictions.setter
    def scm_ip_security_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionArgs']]]]):
        pulumi.set(self, "scm_ip_security_restrictions", value)

    @property
    @pulumi.getter(name="scmIpSecurityRestrictionsDefaultAction")
    def scm_ip_security_restrictions_default_action(self) -> Optional[pulumi.Input[Union[builtins.str, 'DefaultAction']]]:
        """
        Default action for scm access restriction if no rules are matched.
        """
        return pulumi.get(self, "scm_ip_security_restrictions_default_action")

    @scm_ip_security_restrictions_default_action.setter
    def scm_ip_security_restrictions_default_action(self, value: Optional[pulumi.Input[Union[builtins.str, 'DefaultAction']]]):
        pulumi.set(self, "scm_ip_security_restrictions_default_action", value)

    @property
    @pulumi.getter(name="scmIpSecurityRestrictionsUseMain")
    def scm_ip_security_restrictions_use_main(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        IP security restrictions for scm to use main.
        """
        return pulumi.get(self, "scm_ip_security_restrictions_use_main")

    @scm_ip_security_restrictions_use_main.setter
    def scm_ip_security_restrictions_use_main(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "scm_ip_security_restrictions_use_main", value)

    @property
    @pulumi.getter(name="scmMinTlsVersion")
    def scm_min_tls_version(self) -> Optional[pulumi.Input[Union[builtins.str, 'SupportedTlsVersions']]]:
        """
        ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
        """
        return pulumi.get(self, "scm_min_tls_version")

    @scm_min_tls_version.setter
    def scm_min_tls_version(self, value: Optional[pulumi.Input[Union[builtins.str, 'SupportedTlsVersions']]]):
        pulumi.set(self, "scm_min_tls_version", value)

    @property
    @pulumi.getter(name="scmType")
    def scm_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ScmType']]]:
        """
        SCM type.
        """
        return pulumi.get(self, "scm_type")

    @scm_type.setter
    def scm_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ScmType']]]):
        pulumi.set(self, "scm_type", value)

    @property
    @pulumi.getter(name="tracingOptions")
    def tracing_options(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Tracing options.
        """
        return pulumi.get(self, "tracing_options")

    @tracing_options.setter
    def tracing_options(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tracing_options", value)

    @property
    @pulumi.getter(name="use32BitWorkerProcess")
    def use32_bit_worker_process(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "use32_bit_worker_process")

    @use32_bit_worker_process.setter
    def use32_bit_worker_process(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use32_bit_worker_process", value)

    @property
    @pulumi.getter(name="virtualApplications")
    def virtual_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualApplicationArgs']]]]:
        """
        Virtual applications.
        """
        return pulumi.get(self, "virtual_applications")

    @virtual_applications.setter
    def virtual_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualApplicationArgs']]]]):
        pulumi.set(self, "virtual_applications", value)

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Virtual Network name.
        """
        return pulumi.get(self, "vnet_name")

    @vnet_name.setter
    def vnet_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vnet_name", value)

    @property
    @pulumi.getter(name="vnetPrivatePortsCount")
    def vnet_private_ports_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of private ports assigned to this app. These will be assigned dynamically on runtime.
        """
        return pulumi.get(self, "vnet_private_ports_count")

    @vnet_private_ports_count.setter
    def vnet_private_ports_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "vnet_private_ports_count", value)

    @property
    @pulumi.getter(name="vnetRouteAllEnabled")
    def vnet_route_all_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied.
        """
        return pulumi.get(self, "vnet_route_all_enabled")

    @vnet_route_all_enabled.setter
    def vnet_route_all_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "vnet_route_all_enabled", value)

    @property
    @pulumi.getter(name="webSocketsEnabled")
    def web_sockets_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "web_sockets_enabled")

    @web_sockets_enabled.setter
    def web_sockets_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "web_sockets_enabled", value)

    @property
    @pulumi.getter(name="websiteTimeZone")
    def website_time_zone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App Service. Setting the WEBSITE_TIME_ZONE app setting takes precedence over this config. For Linux, expects tz database values https://www.iana.org/time-zones (for a quick reference see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time zones listed under HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones
        """
        return pulumi.get(self, "website_time_zone")

    @website_time_zone.setter
    def website_time_zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "website_time_zone", value)

    @property
    @pulumi.getter(name="windowsFxVersion")
    def windows_fx_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Xenon App Framework and version
        """
        return pulumi.get(self, "windows_fx_version")

    @windows_fx_version.setter
    def windows_fx_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "windows_fx_version", value)

    @property
    @pulumi.getter(name="xManagedServiceIdentityId")
    def x_managed_service_identity_id(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Explicit Managed Service Identity Id
        """
        return pulumi.get(self, "x_managed_service_identity_id")

    @x_managed_service_identity_id.setter
    def x_managed_service_identity_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "x_managed_service_identity_id", value)


if not MYPY:
    class SiteDnsConfigArgsDict(TypedDict):
        dns_alt_server: NotRequired[pulumi.Input[builtins.str]]
        """
        Alternate DNS server to be used by apps. This property replicates the WEBSITE_DNS_ALT_SERVER app setting.
        """
        dns_max_cache_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Custom time for DNS to be cached in seconds. Allowed range: 0-60. Default is 30 seconds. 0 means caching disabled.
        """
        dns_retry_attempt_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Total number of retries for dns lookup. Allowed range: 1-5. Default is 3.
        """
        dns_retry_attempt_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Timeout for a single dns lookup in seconds. Allowed range: 1-30. Default is 3.
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of custom DNS servers to be used by an app for lookups. Maximum 5 dns servers can be set.
        """
elif False:
    SiteDnsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteDnsConfigArgs:
    def __init__(__self__, *,
                 dns_alt_server: Optional[pulumi.Input[builtins.str]] = None,
                 dns_max_cache_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 dns_retry_attempt_count: Optional[pulumi.Input[builtins.int]] = None,
                 dns_retry_attempt_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] dns_alt_server: Alternate DNS server to be used by apps. This property replicates the WEBSITE_DNS_ALT_SERVER app setting.
        :param pulumi.Input[builtins.int] dns_max_cache_timeout: Custom time for DNS to be cached in seconds. Allowed range: 0-60. Default is 30 seconds. 0 means caching disabled.
        :param pulumi.Input[builtins.int] dns_retry_attempt_count: Total number of retries for dns lookup. Allowed range: 1-5. Default is 3.
        :param pulumi.Input[builtins.int] dns_retry_attempt_timeout: Timeout for a single dns lookup in seconds. Allowed range: 1-30. Default is 3.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_servers: List of custom DNS servers to be used by an app for lookups. Maximum 5 dns servers can be set.
        """
        if dns_alt_server is not None:
            pulumi.set(__self__, "dns_alt_server", dns_alt_server)
        if dns_max_cache_timeout is not None:
            pulumi.set(__self__, "dns_max_cache_timeout", dns_max_cache_timeout)
        if dns_retry_attempt_count is not None:
            pulumi.set(__self__, "dns_retry_attempt_count", dns_retry_attempt_count)
        if dns_retry_attempt_timeout is not None:
            pulumi.set(__self__, "dns_retry_attempt_timeout", dns_retry_attempt_timeout)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)

    @property
    @pulumi.getter(name="dnsAltServer")
    def dns_alt_server(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Alternate DNS server to be used by apps. This property replicates the WEBSITE_DNS_ALT_SERVER app setting.
        """
        return pulumi.get(self, "dns_alt_server")

    @dns_alt_server.setter
    def dns_alt_server(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dns_alt_server", value)

    @property
    @pulumi.getter(name="dnsMaxCacheTimeout")
    def dns_max_cache_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Custom time for DNS to be cached in seconds. Allowed range: 0-60. Default is 30 seconds. 0 means caching disabled.
        """
        return pulumi.get(self, "dns_max_cache_timeout")

    @dns_max_cache_timeout.setter
    def dns_max_cache_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dns_max_cache_timeout", value)

    @property
    @pulumi.getter(name="dnsRetryAttemptCount")
    def dns_retry_attempt_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Total number of retries for dns lookup. Allowed range: 1-5. Default is 3.
        """
        return pulumi.get(self, "dns_retry_attempt_count")

    @dns_retry_attempt_count.setter
    def dns_retry_attempt_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dns_retry_attempt_count", value)

    @property
    @pulumi.getter(name="dnsRetryAttemptTimeout")
    def dns_retry_attempt_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Timeout for a single dns lookup in seconds. Allowed range: 1-30. Default is 3.
        """
        return pulumi.get(self, "dns_retry_attempt_timeout")

    @dns_retry_attempt_timeout.setter
    def dns_retry_attempt_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dns_retry_attempt_timeout", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of custom DNS servers to be used by an app for lookups. Maximum 5 dns servers can be set.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)


if not MYPY:
    class SiteLimitsArgsDict(TypedDict):
        """
        Metric limits set on an app.
        """
        max_disk_size_in_mb: NotRequired[pulumi.Input[builtins.float]]
        """
        Maximum allowed disk size usage in MB.
        """
        max_memory_in_mb: NotRequired[pulumi.Input[builtins.float]]
        """
        Maximum allowed memory usage in MB.
        """
        max_percentage_cpu: NotRequired[pulumi.Input[builtins.float]]
        """
        Maximum allowed CPU usage percentage.
        """
elif False:
    SiteLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SiteLimitsArgs:
    def __init__(__self__, *,
                 max_disk_size_in_mb: Optional[pulumi.Input[builtins.float]] = None,
                 max_memory_in_mb: Optional[pulumi.Input[builtins.float]] = None,
                 max_percentage_cpu: Optional[pulumi.Input[builtins.float]] = None):
        """
        Metric limits set on an app.
        :param pulumi.Input[builtins.float] max_disk_size_in_mb: Maximum allowed disk size usage in MB.
        :param pulumi.Input[builtins.float] max_memory_in_mb: Maximum allowed memory usage in MB.
        :param pulumi.Input[builtins.float] max_percentage_cpu: Maximum allowed CPU usage percentage.
        """
        if max_disk_size_in_mb is not None:
            pulumi.set(__self__, "max_disk_size_in_mb", max_disk_size_in_mb)
        if max_memory_in_mb is not None:
            pulumi.set(__self__, "max_memory_in_mb", max_memory_in_mb)
        if max_percentage_cpu is not None:
            pulumi.set(__self__, "max_percentage_cpu", max_percentage_cpu)

    @property
    @pulumi.getter(name="maxDiskSizeInMb")
    def max_disk_size_in_mb(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Maximum allowed disk size usage in MB.
        """
        return pulumi.get(self, "max_disk_size_in_mb")

    @max_disk_size_in_mb.setter
    def max_disk_size_in_mb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "max_disk_size_in_mb", value)

    @property
    @pulumi.getter(name="maxMemoryInMb")
    def max_memory_in_mb(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Maximum allowed memory usage in MB.
        """
        return pulumi.get(self, "max_memory_in_mb")

    @max_memory_in_mb.setter
    def max_memory_in_mb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "max_memory_in_mb", value)

    @property
    @pulumi.getter(name="maxPercentageCpu")
    def max_percentage_cpu(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Maximum allowed CPU usage percentage.
        """
        return pulumi.get(self, "max_percentage_cpu")

    @max_percentage_cpu.setter
    def max_percentage_cpu(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "max_percentage_cpu", value)


if not MYPY:
    class SkuCapacityArgsDict(TypedDict):
        """
        Description of the App Service plan scale options.
        """
        default: NotRequired[pulumi.Input[builtins.int]]
        """
        Default number of workers for this App Service plan SKU.
        """
        elastic_maximum: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of Elastic workers for this App Service plan SKU.
        """
        maximum: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of workers for this App Service plan SKU.
        """
        minimum: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum number of workers for this App Service plan SKU.
        """
        scale_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Available scale configurations for an App Service plan.
        """
elif False:
    SkuCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuCapacityArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[builtins.int]] = None,
                 elastic_maximum: Optional[pulumi.Input[builtins.int]] = None,
                 maximum: Optional[pulumi.Input[builtins.int]] = None,
                 minimum: Optional[pulumi.Input[builtins.int]] = None,
                 scale_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        Description of the App Service plan scale options.
        :param pulumi.Input[builtins.int] default: Default number of workers for this App Service plan SKU.
        :param pulumi.Input[builtins.int] elastic_maximum: Maximum number of Elastic workers for this App Service plan SKU.
        :param pulumi.Input[builtins.int] maximum: Maximum number of workers for this App Service plan SKU.
        :param pulumi.Input[builtins.int] minimum: Minimum number of workers for this App Service plan SKU.
        :param pulumi.Input[builtins.str] scale_type: Available scale configurations for an App Service plan.
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if elastic_maximum is not None:
            pulumi.set(__self__, "elastic_maximum", elastic_maximum)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if scale_type is not None:
            pulumi.set(__self__, "scale_type", scale_type)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Default number of workers for this App Service plan SKU.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter(name="elasticMaximum")
    def elastic_maximum(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of Elastic workers for this App Service plan SKU.
        """
        return pulumi.get(self, "elastic_maximum")

    @elastic_maximum.setter
    def elastic_maximum(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "elastic_maximum", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of workers for this App Service plan SKU.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum number of workers for this App Service plan SKU.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter(name="scaleType")
    def scale_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Available scale configurations for an App Service plan.
        """
        return pulumi.get(self, "scale_type")

    @scale_type.setter
    def scale_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scale_type", value)


if not MYPY:
    class SkuDescriptionArgsDict(TypedDict):
        """
        Description of a SKU for a scalable resource.
        """
        capabilities: NotRequired[pulumi.Input[Sequence[pulumi.Input['CapabilityArgsDict']]]]
        """
        Capabilities of the SKU, e.g., is traffic manager enabled?
        """
        capacity: NotRequired[pulumi.Input[builtins.int]]
        """
        Current number of instances assigned to the resource.
        """
        family: NotRequired[pulumi.Input[builtins.str]]
        """
        Family code of the resource SKU.
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Locations of the SKU.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the resource SKU.
        """
        size: NotRequired[pulumi.Input[builtins.str]]
        """
        Size specifier of the resource SKU.
        """
        sku_capacity: NotRequired[pulumi.Input['SkuCapacityArgsDict']]
        """
        Min, max, and default scale values of the SKU.
        """
        tier: NotRequired[pulumi.Input[builtins.str]]
        """
        Service tier of the resource SKU.
        """
elif False:
    SkuDescriptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuDescriptionArgs:
    def __init__(__self__, *,
                 capabilities: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]] = None,
                 capacity: Optional[pulumi.Input[builtins.int]] = None,
                 family: Optional[pulumi.Input[builtins.str]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.str]] = None,
                 sku_capacity: Optional[pulumi.Input['SkuCapacityArgs']] = None,
                 tier: Optional[pulumi.Input[builtins.str]] = None):
        """
        Description of a SKU for a scalable resource.
        :param pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]] capabilities: Capabilities of the SKU, e.g., is traffic manager enabled?
        :param pulumi.Input[builtins.int] capacity: Current number of instances assigned to the resource.
        :param pulumi.Input[builtins.str] family: Family code of the resource SKU.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] locations: Locations of the SKU.
        :param pulumi.Input[builtins.str] name: Name of the resource SKU.
        :param pulumi.Input[builtins.str] size: Size specifier of the resource SKU.
        :param pulumi.Input['SkuCapacityArgs'] sku_capacity: Min, max, and default scale values of the SKU.
        :param pulumi.Input[builtins.str] tier: Service tier of the resource SKU.
        """
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if sku_capacity is not None:
            pulumi.set(__self__, "sku_capacity", sku_capacity)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]]:
        """
        Capabilities of the SKU, e.g., is traffic manager enabled?
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CapabilityArgs']]]]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Current number of instances assigned to the resource.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Family code of the resource SKU.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Locations of the SKU.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the resource SKU.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Size specifier of the resource SKU.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="skuCapacity")
    def sku_capacity(self) -> Optional[pulumi.Input['SkuCapacityArgs']]:
        """
        Min, max, and default scale values of the SKU.
        """
        return pulumi.get(self, "sku_capacity")

    @sku_capacity.setter
    def sku_capacity(self, value: Optional[pulumi.Input['SkuCapacityArgs']]):
        pulumi.set(self, "sku_capacity", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Service tier of the resource SKU.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class SlowRequestsBasedTriggerArgsDict(TypedDict):
        """
        Trigger based on request execution time.
        """
        count: NotRequired[pulumi.Input[builtins.int]]
        """
        Request Count.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Request Path.
        """
        time_interval: NotRequired[pulumi.Input[builtins.str]]
        """
        Time interval.
        """
        time_taken: NotRequired[pulumi.Input[builtins.str]]
        """
        Time taken.
        """
elif False:
    SlowRequestsBasedTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlowRequestsBasedTriggerArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[builtins.int]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 time_interval: Optional[pulumi.Input[builtins.str]] = None,
                 time_taken: Optional[pulumi.Input[builtins.str]] = None):
        """
        Trigger based on request execution time.
        :param pulumi.Input[builtins.int] count: Request Count.
        :param pulumi.Input[builtins.str] path: Request Path.
        :param pulumi.Input[builtins.str] time_interval: Time interval.
        :param pulumi.Input[builtins.str] time_taken: Time taken.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)
        if time_taken is not None:
            pulumi.set(__self__, "time_taken", time_taken)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Request Path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")

    @time_interval.setter
    def time_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_interval", value)

    @property
    @pulumi.getter(name="timeTaken")
    def time_taken(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time taken.
        """
        return pulumi.get(self, "time_taken")

    @time_taken.setter
    def time_taken(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_taken", value)


if not MYPY:
    class StaticSiteBuildPropertiesArgsDict(TypedDict):
        """
        Build properties for the static site.
        """
        api_build_command: NotRequired[pulumi.Input[builtins.str]]
        """
        A custom command to run during deployment of the Azure Functions API application.
        """
        api_location: NotRequired[pulumi.Input[builtins.str]]
        """
        The path to the api code within the repository.
        """
        app_artifact_location: NotRequired[pulumi.Input[builtins.str]]
        """
        Deprecated: The path of the app artifacts after building (deprecated in favor of OutputLocation)
        """
        app_build_command: NotRequired[pulumi.Input[builtins.str]]
        """
        A custom command to run during deployment of the static content application.
        """
        app_location: NotRequired[pulumi.Input[builtins.str]]
        """
        The path to the app code within the repository.
        """
        github_action_secret_name_override: NotRequired[pulumi.Input[builtins.str]]
        """
        Github Action secret name override.
        """
        output_location: NotRequired[pulumi.Input[builtins.str]]
        """
        The output path of the app after building.
        """
        skip_github_action_workflow_generation: NotRequired[pulumi.Input[builtins.bool]]
        """
        Skip Github Action workflow generation.
        """
elif False:
    StaticSiteBuildPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StaticSiteBuildPropertiesArgs:
    def __init__(__self__, *,
                 api_build_command: Optional[pulumi.Input[builtins.str]] = None,
                 api_location: Optional[pulumi.Input[builtins.str]] = None,
                 app_artifact_location: Optional[pulumi.Input[builtins.str]] = None,
                 app_build_command: Optional[pulumi.Input[builtins.str]] = None,
                 app_location: Optional[pulumi.Input[builtins.str]] = None,
                 github_action_secret_name_override: Optional[pulumi.Input[builtins.str]] = None,
                 output_location: Optional[pulumi.Input[builtins.str]] = None,
                 skip_github_action_workflow_generation: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Build properties for the static site.
        :param pulumi.Input[builtins.str] api_build_command: A custom command to run during deployment of the Azure Functions API application.
        :param pulumi.Input[builtins.str] api_location: The path to the api code within the repository.
        :param pulumi.Input[builtins.str] app_artifact_location: Deprecated: The path of the app artifacts after building (deprecated in favor of OutputLocation)
        :param pulumi.Input[builtins.str] app_build_command: A custom command to run during deployment of the static content application.
        :param pulumi.Input[builtins.str] app_location: The path to the app code within the repository.
        :param pulumi.Input[builtins.str] github_action_secret_name_override: Github Action secret name override.
        :param pulumi.Input[builtins.str] output_location: The output path of the app after building.
        :param pulumi.Input[builtins.bool] skip_github_action_workflow_generation: Skip Github Action workflow generation.
        """
        if api_build_command is not None:
            pulumi.set(__self__, "api_build_command", api_build_command)
        if api_location is not None:
            pulumi.set(__self__, "api_location", api_location)
        if app_artifact_location is not None:
            pulumi.set(__self__, "app_artifact_location", app_artifact_location)
        if app_build_command is not None:
            pulumi.set(__self__, "app_build_command", app_build_command)
        if app_location is not None:
            pulumi.set(__self__, "app_location", app_location)
        if github_action_secret_name_override is not None:
            pulumi.set(__self__, "github_action_secret_name_override", github_action_secret_name_override)
        if output_location is not None:
            pulumi.set(__self__, "output_location", output_location)
        if skip_github_action_workflow_generation is not None:
            pulumi.set(__self__, "skip_github_action_workflow_generation", skip_github_action_workflow_generation)

    @property
    @pulumi.getter(name="apiBuildCommand")
    def api_build_command(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A custom command to run during deployment of the Azure Functions API application.
        """
        return pulumi.get(self, "api_build_command")

    @api_build_command.setter
    def api_build_command(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_build_command", value)

    @property
    @pulumi.getter(name="apiLocation")
    def api_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The path to the api code within the repository.
        """
        return pulumi.get(self, "api_location")

    @api_location.setter
    def api_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_location", value)

    @property
    @pulumi.getter(name="appArtifactLocation")
    def app_artifact_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Deprecated: The path of the app artifacts after building (deprecated in favor of OutputLocation)
        """
        return pulumi.get(self, "app_artifact_location")

    @app_artifact_location.setter
    def app_artifact_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "app_artifact_location", value)

    @property
    @pulumi.getter(name="appBuildCommand")
    def app_build_command(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A custom command to run during deployment of the static content application.
        """
        return pulumi.get(self, "app_build_command")

    @app_build_command.setter
    def app_build_command(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "app_build_command", value)

    @property
    @pulumi.getter(name="appLocation")
    def app_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The path to the app code within the repository.
        """
        return pulumi.get(self, "app_location")

    @app_location.setter
    def app_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "app_location", value)

    @property
    @pulumi.getter(name="githubActionSecretNameOverride")
    def github_action_secret_name_override(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Github Action secret name override.
        """
        return pulumi.get(self, "github_action_secret_name_override")

    @github_action_secret_name_override.setter
    def github_action_secret_name_override(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "github_action_secret_name_override", value)

    @property
    @pulumi.getter(name="outputLocation")
    def output_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The output path of the app after building.
        """
        return pulumi.get(self, "output_location")

    @output_location.setter
    def output_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "output_location", value)

    @property
    @pulumi.getter(name="skipGithubActionWorkflowGeneration")
    def skip_github_action_workflow_generation(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Skip Github Action workflow generation.
        """
        return pulumi.get(self, "skip_github_action_workflow_generation")

    @skip_github_action_workflow_generation.setter
    def skip_github_action_workflow_generation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "skip_github_action_workflow_generation", value)


if not MYPY:
    class StaticSiteTemplateOptionsArgsDict(TypedDict):
        """
        Template Options for the static site.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of the newly generated repository.
        """
        is_private: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether or not the newly generated repository is a private repository. Defaults to false (i.e. public).
        """
        owner: NotRequired[pulumi.Input[builtins.str]]
        """
        Owner of the newly generated repository.
        """
        repository_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the newly generated repository.
        """
        template_repository_url: NotRequired[pulumi.Input[builtins.str]]
        """
        URL of the template repository. The newly generated repository will be based on this one.
        """
elif False:
    StaticSiteTemplateOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StaticSiteTemplateOptionsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 is_private: Optional[pulumi.Input[builtins.bool]] = None,
                 owner: Optional[pulumi.Input[builtins.str]] = None,
                 repository_name: Optional[pulumi.Input[builtins.str]] = None,
                 template_repository_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        Template Options for the static site.
        :param pulumi.Input[builtins.str] description: Description of the newly generated repository.
        :param pulumi.Input[builtins.bool] is_private: Whether or not the newly generated repository is a private repository. Defaults to false (i.e. public).
        :param pulumi.Input[builtins.str] owner: Owner of the newly generated repository.
        :param pulumi.Input[builtins.str] repository_name: Name of the newly generated repository.
        :param pulumi.Input[builtins.str] template_repository_url: URL of the template repository. The newly generated repository will be based on this one.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if is_private is not None:
            pulumi.set(__self__, "is_private", is_private)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if repository_name is not None:
            pulumi.set(__self__, "repository_name", repository_name)
        if template_repository_url is not None:
            pulumi.set(__self__, "template_repository_url", template_repository_url)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of the newly generated repository.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="isPrivate")
    def is_private(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether or not the newly generated repository is a private repository. Defaults to false (i.e. public).
        """
        return pulumi.get(self, "is_private")

    @is_private.setter
    def is_private(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_private", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Owner of the newly generated repository.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the newly generated repository.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repository_name", value)

    @property
    @pulumi.getter(name="templateRepositoryUrl")
    def template_repository_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL of the template repository. The newly generated repository will be based on this one.
        """
        return pulumi.get(self, "template_repository_url")

    @template_repository_url.setter
    def template_repository_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "template_repository_url", value)


if not MYPY:
    class StatusCodesBasedTriggerArgsDict(TypedDict):
        """
        Trigger based on status code.
        """
        count: NotRequired[pulumi.Input[builtins.int]]
        """
        Request Count.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Request Path
        """
        status: NotRequired[pulumi.Input[builtins.int]]
        """
        HTTP status code.
        """
        sub_status: NotRequired[pulumi.Input[builtins.int]]
        """
        Request Sub Status.
        """
        time_interval: NotRequired[pulumi.Input[builtins.str]]
        """
        Time interval.
        """
        win32_status: NotRequired[pulumi.Input[builtins.int]]
        """
        Win32 error code.
        """
elif False:
    StatusCodesBasedTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatusCodesBasedTriggerArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[builtins.int]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.int]] = None,
                 sub_status: Optional[pulumi.Input[builtins.int]] = None,
                 time_interval: Optional[pulumi.Input[builtins.str]] = None,
                 win32_status: Optional[pulumi.Input[builtins.int]] = None):
        """
        Trigger based on status code.
        :param pulumi.Input[builtins.int] count: Request Count.
        :param pulumi.Input[builtins.str] path: Request Path
        :param pulumi.Input[builtins.int] status: HTTP status code.
        :param pulumi.Input[builtins.int] sub_status: Request Sub Status.
        :param pulumi.Input[builtins.str] time_interval: Time interval.
        :param pulumi.Input[builtins.int] win32_status: Win32 error code.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if sub_status is not None:
            pulumi.set(__self__, "sub_status", sub_status)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)
        if win32_status is not None:
            pulumi.set(__self__, "win32_status", win32_status)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Request Path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        HTTP status code.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="subStatus")
    def sub_status(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Request Sub Status.
        """
        return pulumi.get(self, "sub_status")

    @sub_status.setter
    def sub_status(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "sub_status", value)

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")

    @time_interval.setter
    def time_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_interval", value)

    @property
    @pulumi.getter(name="win32Status")
    def win32_status(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Win32 error code.
        """
        return pulumi.get(self, "win32_status")

    @win32_status.setter
    def win32_status(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "win32_status", value)


if not MYPY:
    class StatusCodesRangeBasedTriggerArgsDict(TypedDict):
        """
        Trigger based on range of status codes.
        """
        count: NotRequired[pulumi.Input[builtins.int]]
        """
        Request Count.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        status_codes: NotRequired[pulumi.Input[builtins.str]]
        """
        HTTP status code.
        """
        time_interval: NotRequired[pulumi.Input[builtins.str]]
        """
        Time interval.
        """
elif False:
    StatusCodesRangeBasedTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StatusCodesRangeBasedTriggerArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[builtins.int]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 status_codes: Optional[pulumi.Input[builtins.str]] = None,
                 time_interval: Optional[pulumi.Input[builtins.str]] = None):
        """
        Trigger based on range of status codes.
        :param pulumi.Input[builtins.int] count: Request Count.
        :param pulumi.Input[builtins.str] status_codes: HTTP status code.
        :param pulumi.Input[builtins.str] time_interval: Time interval.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)
        if time_interval is not None:
            pulumi.set(__self__, "time_interval", time_interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Request Count.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        HTTP status code.
        """
        return pulumi.get(self, "status_codes")

    @status_codes.setter
    def status_codes(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status_codes", value)

    @property
    @pulumi.getter(name="timeInterval")
    def time_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time interval.
        """
        return pulumi.get(self, "time_interval")

    @time_interval.setter
    def time_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_interval", value)


if not MYPY:
    class TokenStoreArgsDict(TypedDict):
        """
        The configuration settings of the token store.
        """
        azure_blob_storage: NotRequired[pulumi.Input['BlobStorageTokenStoreArgsDict']]
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
         The default is <code>false</code>.
        """
        file_system: NotRequired[pulumi.Input['FileSystemTokenStoreArgsDict']]
        """
        The configuration settings of the storage of the tokens if a file system is used.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[builtins.float]]
        """
        The number of hours after session token expiration that a session token can be used to
        call the token refresh API. The default is 72 hours.
        """
elif False:
    TokenStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TokenStoreArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['BlobStorageTokenStoreArgs']] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 file_system: Optional[pulumi.Input['FileSystemTokenStoreArgs']] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[builtins.float]] = None):
        """
        The configuration settings of the token store.
        :param pulumi.Input['BlobStorageTokenStoreArgs'] azure_blob_storage: The configuration settings of the storage of the tokens if blob storage is used.
        :param pulumi.Input[builtins.bool] enabled: <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
                The default is <code>false</code>.
        :param pulumi.Input['FileSystemTokenStoreArgs'] file_system: The configuration settings of the storage of the tokens if a file system is used.
        :param pulumi.Input[builtins.float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to
               call the token refresh API. The default is 72 hours.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['BlobStorageTokenStoreArgs']]:
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['BlobStorageTokenStoreArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
         The default is <code>false</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input['FileSystemTokenStoreArgs']]:
        """
        The configuration settings of the storage of the tokens if a file system is used.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input['FileSystemTokenStoreArgs']]):
        pulumi.set(self, "file_system", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The number of hours after session token expiration that a session token can be used to
        call the token refresh API. The default is 72 hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)


if not MYPY:
    class TwitterRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the app registration for the Twitter provider.
        """
        consumer_key: NotRequired[pulumi.Input[builtins.str]]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        This setting is required for enabling Twitter Sign-In.
        Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        """
        consumer_secret_setting_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
        application used for sign-in.
        """
elif False:
    TwitterRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwitterRegistrationArgs:
    def __init__(__self__, *,
                 consumer_key: Optional[pulumi.Input[builtins.str]] = None,
                 consumer_secret_setting_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the app registration for the Twitter provider.
        :param pulumi.Input[builtins.str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
               This setting is required for enabling Twitter Sign-In.
               Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        :param pulumi.Input[builtins.str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
               application used for sign-in.
        """
        if consumer_key is not None:
            pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        This setting is required for enabling Twitter Sign-In.
        Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
        application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class TwitterArgsDict(TypedDict):
        """
        The configuration settings of the Twitter provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        registration: NotRequired[pulumi.Input['TwitterRegistrationArgsDict']]
        """
        The configuration settings of the app registration for the Twitter provider.
        """
elif False:
    TwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwitterArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 registration: Optional[pulumi.Input['TwitterRegistrationArgs']] = None):
        """
        The configuration settings of the Twitter provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['TwitterRegistrationArgs'] registration: The configuration settings of the app registration for the Twitter provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['TwitterRegistrationArgs']]:
        """
        The configuration settings of the app registration for the Twitter provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['TwitterRegistrationArgs']]):
        pulumi.set(self, "registration", value)


if not MYPY:
    class VirtualApplicationArgsDict(TypedDict):
        """
        Virtual application in an app.
        """
        physical_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Physical path.
        """
        preload_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
        """
        virtual_directories: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualDirectoryArgsDict']]]]
        """
        Virtual directories for virtual application.
        """
        virtual_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Virtual path.
        """
elif False:
    VirtualApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualApplicationArgs:
    def __init__(__self__, *,
                 physical_path: Optional[pulumi.Input[builtins.str]] = None,
                 preload_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 virtual_directories: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualDirectoryArgs']]]] = None,
                 virtual_path: Optional[pulumi.Input[builtins.str]] = None):
        """
        Virtual application in an app.
        :param pulumi.Input[builtins.str] physical_path: Physical path.
        :param pulumi.Input[builtins.bool] preload_enabled: <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualDirectoryArgs']]] virtual_directories: Virtual directories for virtual application.
        :param pulumi.Input[builtins.str] virtual_path: Virtual path.
        """
        if physical_path is not None:
            pulumi.set(__self__, "physical_path", physical_path)
        if preload_enabled is not None:
            pulumi.set(__self__, "preload_enabled", preload_enabled)
        if virtual_directories is not None:
            pulumi.set(__self__, "virtual_directories", virtual_directories)
        if virtual_path is not None:
            pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Physical path.
        """
        return pulumi.get(self, "physical_path")

    @physical_path.setter
    def physical_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "physical_path", value)

    @property
    @pulumi.getter(name="preloadEnabled")
    def preload_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "preload_enabled")

    @preload_enabled.setter
    def preload_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "preload_enabled", value)

    @property
    @pulumi.getter(name="virtualDirectories")
    def virtual_directories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualDirectoryArgs']]]]:
        """
        Virtual directories for virtual application.
        """
        return pulumi.get(self, "virtual_directories")

    @virtual_directories.setter
    def virtual_directories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualDirectoryArgs']]]]):
        pulumi.set(self, "virtual_directories", value)

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Virtual path.
        """
        return pulumi.get(self, "virtual_path")

    @virtual_path.setter
    def virtual_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "virtual_path", value)


if not MYPY:
    class VirtualDirectoryArgsDict(TypedDict):
        """
        Directory for virtual application.
        """
        physical_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Physical path.
        """
        virtual_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path to virtual application.
        """
elif False:
    VirtualDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualDirectoryArgs:
    def __init__(__self__, *,
                 physical_path: Optional[pulumi.Input[builtins.str]] = None,
                 virtual_path: Optional[pulumi.Input[builtins.str]] = None):
        """
        Directory for virtual application.
        :param pulumi.Input[builtins.str] physical_path: Physical path.
        :param pulumi.Input[builtins.str] virtual_path: Path to virtual application.
        """
        if physical_path is not None:
            pulumi.set(__self__, "physical_path", physical_path)
        if virtual_path is not None:
            pulumi.set(__self__, "virtual_path", virtual_path)

    @property
    @pulumi.getter(name="physicalPath")
    def physical_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Physical path.
        """
        return pulumi.get(self, "physical_path")

    @physical_path.setter
    def physical_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "physical_path", value)

    @property
    @pulumi.getter(name="virtualPath")
    def virtual_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path to virtual application.
        """
        return pulumi.get(self, "virtual_path")

    @virtual_path.setter
    def virtual_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "virtual_path", value)


if not MYPY:
    class VirtualNetworkProfileArgsDict(TypedDict):
        """
        Specification for using a Virtual Network.
        """
        id: pulumi.Input[builtins.str]
        """
        Resource id of the Virtual Network.
        """
        subnet: NotRequired[pulumi.Input[builtins.str]]
        """
        Subnet within the Virtual Network.
        """
elif False:
    VirtualNetworkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkProfileArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 subnet: Optional[pulumi.Input[builtins.str]] = None):
        """
        Specification for using a Virtual Network.
        :param pulumi.Input[builtins.str] id: Resource id of the Virtual Network.
        :param pulumi.Input[builtins.str] subnet: Subnet within the Virtual Network.
        """
        pulumi.set(__self__, "id", id)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Resource id of the Virtual Network.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subnet within the Virtual Network.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class VolumeMountArgsDict(TypedDict):
        container_mount_path: pulumi.Input[builtins.str]
        """
        Target path on the container where volume is mounted on
        """
        volume_sub_path: pulumi.Input[builtins.str]
        """
        Sub path in the volume where volume is mounted from.
        """
        data: NotRequired[pulumi.Input[builtins.str]]
        """
        Config Data to be mounted on the volume
        """
        read_only: NotRequired[pulumi.Input[builtins.bool]]
        """
        Boolean to specify if the mount is read only on the container
        """
elif False:
    VolumeMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeMountArgs:
    def __init__(__self__, *,
                 container_mount_path: pulumi.Input[builtins.str],
                 volume_sub_path: pulumi.Input[builtins.str],
                 data: Optional[pulumi.Input[builtins.str]] = None,
                 read_only: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] container_mount_path: Target path on the container where volume is mounted on
        :param pulumi.Input[builtins.str] volume_sub_path: Sub path in the volume where volume is mounted from.
        :param pulumi.Input[builtins.str] data: Config Data to be mounted on the volume
        :param pulumi.Input[builtins.bool] read_only: Boolean to specify if the mount is read only on the container
        """
        pulumi.set(__self__, "container_mount_path", container_mount_path)
        pulumi.set(__self__, "volume_sub_path", volume_sub_path)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)

    @property
    @pulumi.getter(name="containerMountPath")
    def container_mount_path(self) -> pulumi.Input[builtins.str]:
        """
        Target path on the container where volume is mounted on
        """
        return pulumi.get(self, "container_mount_path")

    @container_mount_path.setter
    def container_mount_path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "container_mount_path", value)

    @property
    @pulumi.getter(name="volumeSubPath")
    def volume_sub_path(self) -> pulumi.Input[builtins.str]:
        """
        Sub path in the volume where volume is mounted from.
        """
        return pulumi.get(self, "volume_sub_path")

    @volume_sub_path.setter
    def volume_sub_path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "volume_sub_path", value)

    @property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Config Data to be mounted on the volume
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data", value)

    @property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Boolean to specify if the mount is read only on the container
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "read_only", value)


if not MYPY:
    class WsdlDefinitionArgsDict(TypedDict):
        """
        The WSDL definition
        """
        content: NotRequired[pulumi.Input[builtins.str]]
        """
        The WSDL content
        """
        import_method: NotRequired[pulumi.Input[Union[builtins.str, 'WsdlImportMethod']]]
        """
        The WSDL import method
        """
        service: NotRequired[pulumi.Input['WsdlServiceArgsDict']]
        """
        The service with name and endpoint names
        """
        url: NotRequired[pulumi.Input[builtins.str]]
        """
        The WSDL URL
        """
elif False:
    WsdlDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WsdlDefinitionArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[builtins.str]] = None,
                 import_method: Optional[pulumi.Input[Union[builtins.str, 'WsdlImportMethod']]] = None,
                 service: Optional[pulumi.Input['WsdlServiceArgs']] = None,
                 url: Optional[pulumi.Input[builtins.str]] = None):
        """
        The WSDL definition
        :param pulumi.Input[builtins.str] content: The WSDL content
        :param pulumi.Input[Union[builtins.str, 'WsdlImportMethod']] import_method: The WSDL import method
        :param pulumi.Input['WsdlServiceArgs'] service: The service with name and endpoint names
        :param pulumi.Input[builtins.str] url: The WSDL URL
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if import_method is not None:
            pulumi.set(__self__, "import_method", import_method)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The WSDL content
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="importMethod")
    def import_method(self) -> Optional[pulumi.Input[Union[builtins.str, 'WsdlImportMethod']]]:
        """
        The WSDL import method
        """
        return pulumi.get(self, "import_method")

    @import_method.setter
    def import_method(self, value: Optional[pulumi.Input[Union[builtins.str, 'WsdlImportMethod']]]):
        pulumi.set(self, "import_method", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['WsdlServiceArgs']]:
        """
        The service with name and endpoint names
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['WsdlServiceArgs']]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The WSDL URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class WsdlServiceDict(TypedDict):
        """
        The service with name and endpoint names
        """
        qualified_name: builtins.str
        """
        The service's qualified name
        """
        endpoint_qualified_names: NotRequired[Sequence[builtins.str]]
        """
        List of the endpoints' qualified names
        """
elif False:
    WsdlServiceDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WsdlService:
    def __init__(__self__, *,
                 qualified_name: builtins.str,
                 endpoint_qualified_names: Optional[Sequence[builtins.str]] = None):
        """
        The service with name and endpoint names
        :param builtins.str qualified_name: The service's qualified name
        :param Sequence[builtins.str] endpoint_qualified_names: List of the endpoints' qualified names
        """
        pulumi.set(__self__, "qualified_name", qualified_name)
        if endpoint_qualified_names is not None:
            pulumi.set(__self__, "endpoint_qualified_names", endpoint_qualified_names)

    @property
    @pulumi.getter(name="qualifiedName")
    def qualified_name(self) -> builtins.str:
        """
        The service's qualified name
        """
        return pulumi.get(self, "qualified_name")

    @qualified_name.setter
    def qualified_name(self, value: builtins.str):
        pulumi.set(self, "qualified_name", value)

    @property
    @pulumi.getter(name="endpointQualifiedNames")
    def endpoint_qualified_names(self) -> Optional[Sequence[builtins.str]]:
        """
        List of the endpoints' qualified names
        """
        return pulumi.get(self, "endpoint_qualified_names")

    @endpoint_qualified_names.setter
    def endpoint_qualified_names(self, value: Optional[Sequence[builtins.str]]):
        pulumi.set(self, "endpoint_qualified_names", value)


if not MYPY:
    class WsdlServiceArgsDict(TypedDict):
        """
        The service with name and endpoint names
        """
        qualified_name: pulumi.Input[builtins.str]
        """
        The service's qualified name
        """
        endpoint_qualified_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of the endpoints' qualified names
        """
elif False:
    WsdlServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WsdlServiceArgs:
    def __init__(__self__, *,
                 qualified_name: pulumi.Input[builtins.str],
                 endpoint_qualified_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The service with name and endpoint names
        :param pulumi.Input[builtins.str] qualified_name: The service's qualified name
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] endpoint_qualified_names: List of the endpoints' qualified names
        """
        pulumi.set(__self__, "qualified_name", qualified_name)
        if endpoint_qualified_names is not None:
            pulumi.set(__self__, "endpoint_qualified_names", endpoint_qualified_names)

    @property
    @pulumi.getter(name="qualifiedName")
    def qualified_name(self) -> pulumi.Input[builtins.str]:
        """
        The service's qualified name
        """
        return pulumi.get(self, "qualified_name")

    @qualified_name.setter
    def qualified_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "qualified_name", value)

    @property
    @pulumi.getter(name="endpointQualifiedNames")
    def endpoint_qualified_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of the endpoints' qualified names
        """
        return pulumi.get(self, "endpoint_qualified_names")

    @endpoint_qualified_names.setter
    def endpoint_qualified_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "endpoint_qualified_names", value)


