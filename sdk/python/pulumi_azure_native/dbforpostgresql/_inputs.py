# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AdminCredentialsArgs',
    'AdminCredentialsArgsDict',
    'AuthConfigArgs',
    'AuthConfigArgsDict',
    'BackupArgs',
    'BackupArgsDict',
    'DataEncryptionArgs',
    'DataEncryptionArgsDict',
    'HighAvailabilityArgs',
    'HighAvailabilityArgsDict',
    'IdentityPropertiesArgs',
    'IdentityPropertiesArgsDict',
    'MaintenanceWindowArgs',
    'MaintenanceWindowArgsDict',
    'MigrationSecretParametersArgs',
    'MigrationSecretParametersArgsDict',
    'NetworkArgs',
    'NetworkArgsDict',
    'PrivateLinkServiceConnectionStateArgs',
    'PrivateLinkServiceConnectionStateArgsDict',
    'ReplicaArgs',
    'ReplicaArgsDict',
    'ResourceIdentityArgs',
    'ResourceIdentityArgsDict',
    'ServerGroupClusterAuthConfigArgs',
    'ServerGroupClusterAuthConfigArgsDict',
    'ServerGroupClusterDataEncryptionArgs',
    'ServerGroupClusterDataEncryptionArgsDict',
    'ServerGroupClusterMaintenanceWindowArgs',
    'ServerGroupClusterMaintenanceWindowArgsDict',
    'ServerPropertiesForDefaultCreateArgs',
    'ServerPropertiesForDefaultCreateArgsDict',
    'ServerPropertiesForGeoRestoreArgs',
    'ServerPropertiesForGeoRestoreArgsDict',
    'ServerPropertiesForReplicaArgs',
    'ServerPropertiesForReplicaArgsDict',
    'ServerPropertiesForRestoreArgs',
    'ServerPropertiesForRestoreArgsDict',
    'SingleServerSkuArgs',
    'SingleServerSkuArgsDict',
    'SkuArgs',
    'SkuArgsDict',
    'StorageProfileArgs',
    'StorageProfileArgsDict',
    'StorageArgs',
    'StorageArgsDict',
    'UserAssignedIdentityArgs',
    'UserAssignedIdentityArgsDict',
    'UserIdentityArgs',
    'UserIdentityArgsDict',
]

MYPY = False

if not MYPY:
    class AdminCredentialsArgsDict(TypedDict):
        """
        Credentials of administrator users for source and target servers.
        """
        source_server_password: pulumi.Input[builtins.str]
        """
        Password for the user of the source server.
        """
        target_server_password: pulumi.Input[builtins.str]
        """
        Password for the user of the target server.
        """
elif False:
    AdminCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdminCredentialsArgs:
    def __init__(__self__, *,
                 source_server_password: pulumi.Input[builtins.str],
                 target_server_password: pulumi.Input[builtins.str]):
        """
        Credentials of administrator users for source and target servers.
        :param pulumi.Input[builtins.str] source_server_password: Password for the user of the source server.
        :param pulumi.Input[builtins.str] target_server_password: Password for the user of the target server.
        """
        pulumi.set(__self__, "source_server_password", source_server_password)
        pulumi.set(__self__, "target_server_password", target_server_password)

    @property
    @pulumi.getter(name="sourceServerPassword")
    def source_server_password(self) -> pulumi.Input[builtins.str]:
        """
        Password for the user of the source server.
        """
        return pulumi.get(self, "source_server_password")

    @source_server_password.setter
    def source_server_password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_server_password", value)

    @property
    @pulumi.getter(name="targetServerPassword")
    def target_server_password(self) -> pulumi.Input[builtins.str]:
        """
        Password for the user of the target server.
        """
        return pulumi.get(self, "target_server_password")

    @target_server_password.setter
    def target_server_password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target_server_password", value)


if not MYPY:
    class AuthConfigArgsDict(TypedDict):
        """
        Authentication configuration properties of a flexible server.
        """
        active_directory_auth: NotRequired[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuthEnum']]]
        """
        Indicates if the server supports Microsoft Entra authentication.
        """
        password_auth: NotRequired[pulumi.Input[Union[builtins.str, 'PasswordAuthEnum']]]
        """
        Indicates if the server supports password based authentication.
        """
        tenant_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the tenant of the delegated resource.
        """
elif False:
    AuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthConfigArgs:
    def __init__(__self__, *,
                 active_directory_auth: Optional[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuthEnum']]] = None,
                 password_auth: Optional[pulumi.Input[Union[builtins.str, 'PasswordAuthEnum']]] = None,
                 tenant_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Authentication configuration properties of a flexible server.
        :param pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuthEnum']] active_directory_auth: Indicates if the server supports Microsoft Entra authentication.
        :param pulumi.Input[Union[builtins.str, 'PasswordAuthEnum']] password_auth: Indicates if the server supports password based authentication.
        :param pulumi.Input[builtins.str] tenant_id: Identifier of the tenant of the delegated resource.
        """
        if active_directory_auth is not None:
            pulumi.set(__self__, "active_directory_auth", active_directory_auth)
        if password_auth is None:
            password_auth = 'Enabled'
        if password_auth is not None:
            pulumi.set(__self__, "password_auth", password_auth)
        if tenant_id is None:
            tenant_id = ''
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="activeDirectoryAuth")
    def active_directory_auth(self) -> Optional[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuthEnum']]]:
        """
        Indicates if the server supports Microsoft Entra authentication.
        """
        return pulumi.get(self, "active_directory_auth")

    @active_directory_auth.setter
    def active_directory_auth(self, value: Optional[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuthEnum']]]):
        pulumi.set(self, "active_directory_auth", value)

    @property
    @pulumi.getter(name="passwordAuth")
    def password_auth(self) -> Optional[pulumi.Input[Union[builtins.str, 'PasswordAuthEnum']]]:
        """
        Indicates if the server supports password based authentication.
        """
        return pulumi.get(self, "password_auth")

    @password_auth.setter
    def password_auth(self, value: Optional[pulumi.Input[Union[builtins.str, 'PasswordAuthEnum']]]):
        pulumi.set(self, "password_auth", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the tenant of the delegated resource.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class BackupArgsDict(TypedDict):
        """
        Backup properties of a flexible server.
        """
        backup_retention_days: NotRequired[pulumi.Input[builtins.int]]
        """
        Backup retention days for the flexible server.
        """
        geo_redundant_backup: NotRequired[pulumi.Input[Union[builtins.str, 'GeoRedundantBackupEnum']]]
        """
        Indicates if the server is configured to create geographically redundant backups.
        """
elif False:
    BackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupArgs:
    def __init__(__self__, *,
                 backup_retention_days: Optional[pulumi.Input[builtins.int]] = None,
                 geo_redundant_backup: Optional[pulumi.Input[Union[builtins.str, 'GeoRedundantBackupEnum']]] = None):
        """
        Backup properties of a flexible server.
        :param pulumi.Input[builtins.int] backup_retention_days: Backup retention days for the flexible server.
        :param pulumi.Input[Union[builtins.str, 'GeoRedundantBackupEnum']] geo_redundant_backup: Indicates if the server is configured to create geographically redundant backups.
        """
        if backup_retention_days is None:
            backup_retention_days = 7
        if backup_retention_days is not None:
            pulumi.set(__self__, "backup_retention_days", backup_retention_days)
        if geo_redundant_backup is None:
            geo_redundant_backup = 'Disabled'
        if geo_redundant_backup is not None:
            pulumi.set(__self__, "geo_redundant_backup", geo_redundant_backup)

    @property
    @pulumi.getter(name="backupRetentionDays")
    def backup_retention_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Backup retention days for the flexible server.
        """
        return pulumi.get(self, "backup_retention_days")

    @backup_retention_days.setter
    def backup_retention_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_retention_days", value)

    @property
    @pulumi.getter(name="geoRedundantBackup")
    def geo_redundant_backup(self) -> Optional[pulumi.Input[Union[builtins.str, 'GeoRedundantBackupEnum']]]:
        """
        Indicates if the server is configured to create geographically redundant backups.
        """
        return pulumi.get(self, "geo_redundant_backup")

    @geo_redundant_backup.setter
    def geo_redundant_backup(self, value: Optional[pulumi.Input[Union[builtins.str, 'GeoRedundantBackupEnum']]]):
        pulumi.set(self, "geo_redundant_backup", value)


if not MYPY:
    class DataEncryptionArgsDict(TypedDict):
        """
        Data encryption properties of a flexible server.
        """
        geo_backup_encryption_key_status: NotRequired[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]]
        """
        Status of key used by a flexible server configured with data encryption based on customer managed key, to encrypt the geographically redundant storage associated to the server when it is configured to support geographically redundant backups.
        """
        geo_backup_key_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the geographically redundant storage associated to a flexible server that is configured to support geographically redundant backups.
        """
        geo_backup_user_assigned_identity_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the geographically redundant storage associated to a flexible server that is configured to support geographically redundant backups.
        """
        primary_encryption_key_status: NotRequired[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]]
        """
        Status of key used by a flexible server configured with data encryption based on customer managed key, to encrypt the primary storage associated to the server.
        """
        primary_key_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        URI of the key in Azure Key Vault used for data encryption of the primary storage associated to a flexible server.
        """
        primary_user_assigned_identity_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the primary storage associated to a flexible server.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'ArmServerKeyType']]]
        """
        Data encryption type used by a flexible server.
        """
elif False:
    DataEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataEncryptionArgs:
    def __init__(__self__, *,
                 geo_backup_encryption_key_status: Optional[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]] = None,
                 geo_backup_key_uri: Optional[pulumi.Input[builtins.str]] = None,
                 geo_backup_user_assigned_identity_id: Optional[pulumi.Input[builtins.str]] = None,
                 primary_encryption_key_status: Optional[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]] = None,
                 primary_key_uri: Optional[pulumi.Input[builtins.str]] = None,
                 primary_user_assigned_identity_id: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'ArmServerKeyType']]] = None):
        """
        Data encryption properties of a flexible server.
        :param pulumi.Input[Union[builtins.str, 'KeyStatusEnum']] geo_backup_encryption_key_status: Status of key used by a flexible server configured with data encryption based on customer managed key, to encrypt the geographically redundant storage associated to the server when it is configured to support geographically redundant backups.
        :param pulumi.Input[builtins.str] geo_backup_key_uri: Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the geographically redundant storage associated to a flexible server that is configured to support geographically redundant backups.
        :param pulumi.Input[builtins.str] geo_backup_user_assigned_identity_id: Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the geographically redundant storage associated to a flexible server that is configured to support geographically redundant backups.
        :param pulumi.Input[Union[builtins.str, 'KeyStatusEnum']] primary_encryption_key_status: Status of key used by a flexible server configured with data encryption based on customer managed key, to encrypt the primary storage associated to the server.
        :param pulumi.Input[builtins.str] primary_key_uri: URI of the key in Azure Key Vault used for data encryption of the primary storage associated to a flexible server.
        :param pulumi.Input[builtins.str] primary_user_assigned_identity_id: Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the primary storage associated to a flexible server.
        :param pulumi.Input[Union[builtins.str, 'ArmServerKeyType']] type: Data encryption type used by a flexible server.
        """
        if geo_backup_encryption_key_status is not None:
            pulumi.set(__self__, "geo_backup_encryption_key_status", geo_backup_encryption_key_status)
        if geo_backup_key_uri is not None:
            pulumi.set(__self__, "geo_backup_key_uri", geo_backup_key_uri)
        if geo_backup_user_assigned_identity_id is not None:
            pulumi.set(__self__, "geo_backup_user_assigned_identity_id", geo_backup_user_assigned_identity_id)
        if primary_encryption_key_status is not None:
            pulumi.set(__self__, "primary_encryption_key_status", primary_encryption_key_status)
        if primary_key_uri is not None:
            pulumi.set(__self__, "primary_key_uri", primary_key_uri)
        if primary_user_assigned_identity_id is not None:
            pulumi.set(__self__, "primary_user_assigned_identity_id", primary_user_assigned_identity_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="geoBackupEncryptionKeyStatus")
    def geo_backup_encryption_key_status(self) -> Optional[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]]:
        """
        Status of key used by a flexible server configured with data encryption based on customer managed key, to encrypt the geographically redundant storage associated to the server when it is configured to support geographically redundant backups.
        """
        return pulumi.get(self, "geo_backup_encryption_key_status")

    @geo_backup_encryption_key_status.setter
    def geo_backup_encryption_key_status(self, value: Optional[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]]):
        pulumi.set(self, "geo_backup_encryption_key_status", value)

    @property
    @pulumi.getter(name="geoBackupKeyURI")
    def geo_backup_key_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the geographically redundant storage associated to a flexible server that is configured to support geographically redundant backups.
        """
        return pulumi.get(self, "geo_backup_key_uri")

    @geo_backup_key_uri.setter
    def geo_backup_key_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "geo_backup_key_uri", value)

    @property
    @pulumi.getter(name="geoBackupUserAssignedIdentityId")
    def geo_backup_user_assigned_identity_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the geographically redundant storage associated to a flexible server that is configured to support geographically redundant backups.
        """
        return pulumi.get(self, "geo_backup_user_assigned_identity_id")

    @geo_backup_user_assigned_identity_id.setter
    def geo_backup_user_assigned_identity_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "geo_backup_user_assigned_identity_id", value)

    @property
    @pulumi.getter(name="primaryEncryptionKeyStatus")
    def primary_encryption_key_status(self) -> Optional[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]]:
        """
        Status of key used by a flexible server configured with data encryption based on customer managed key, to encrypt the primary storage associated to the server.
        """
        return pulumi.get(self, "primary_encryption_key_status")

    @primary_encryption_key_status.setter
    def primary_encryption_key_status(self, value: Optional[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]]):
        pulumi.set(self, "primary_encryption_key_status", value)

    @property
    @pulumi.getter(name="primaryKeyURI")
    def primary_key_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI of the key in Azure Key Vault used for data encryption of the primary storage associated to a flexible server.
        """
        return pulumi.get(self, "primary_key_uri")

    @primary_key_uri.setter
    def primary_key_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "primary_key_uri", value)

    @property
    @pulumi.getter(name="primaryUserAssignedIdentityId")
    def primary_user_assigned_identity_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the primary storage associated to a flexible server.
        """
        return pulumi.get(self, "primary_user_assigned_identity_id")

    @primary_user_assigned_identity_id.setter
    def primary_user_assigned_identity_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "primary_user_assigned_identity_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ArmServerKeyType']]]:
        """
        Data encryption type used by a flexible server.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ArmServerKeyType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HighAvailabilityArgsDict(TypedDict):
        """
        High availability properties of a flexible server.
        """
        mode: NotRequired[pulumi.Input[Union[builtins.str, 'HighAvailabilityMode']]]
        """
        High availability mode for a flexible server.
        """
        standby_availability_zone: NotRequired[pulumi.Input[builtins.str]]
        """
        Availability zone associated to the standby server created when high availability is set to SameZone or ZoneRedundant.
        """
elif False:
    HighAvailabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HighAvailabilityArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[Union[builtins.str, 'HighAvailabilityMode']]] = None,
                 standby_availability_zone: Optional[pulumi.Input[builtins.str]] = None):
        """
        High availability properties of a flexible server.
        :param pulumi.Input[Union[builtins.str, 'HighAvailabilityMode']] mode: High availability mode for a flexible server.
        :param pulumi.Input[builtins.str] standby_availability_zone: Availability zone associated to the standby server created when high availability is set to SameZone or ZoneRedundant.
        """
        if mode is None:
            mode = 'Disabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if standby_availability_zone is None:
            standby_availability_zone = ''
        if standby_availability_zone is not None:
            pulumi.set(__self__, "standby_availability_zone", standby_availability_zone)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'HighAvailabilityMode']]]:
        """
        High availability mode for a flexible server.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'HighAvailabilityMode']]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="standbyAvailabilityZone")
    def standby_availability_zone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Availability zone associated to the standby server created when high availability is set to SameZone or ZoneRedundant.
        """
        return pulumi.get(self, "standby_availability_zone")

    @standby_availability_zone.setter
    def standby_availability_zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "standby_availability_zone", value)


if not MYPY:
    class IdentityPropertiesArgsDict(TypedDict):
        """
        Describes the identity of the cluster.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'IdentityType']]]
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    IdentityPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityPropertiesArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[builtins.str, 'IdentityType']]] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Describes the identity of the cluster.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'IdentityType']]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'IdentityType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class MaintenanceWindowArgsDict(TypedDict):
        """
        Maintenance window properties of a flexible server.
        """
        custom_window: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates whether custom window is enabled or disabled.
        """
        day_of_week: NotRequired[pulumi.Input[builtins.int]]
        """
        Day of the week to be used for maintenance window.
        """
        start_hour: NotRequired[pulumi.Input[builtins.int]]
        """
        Start hour to be used for maintenance window.
        """
        start_minute: NotRequired[pulumi.Input[builtins.int]]
        """
        Start minute to be used for maintenance window.
        """
elif False:
    MaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_window: Optional[pulumi.Input[builtins.str]] = None,
                 day_of_week: Optional[pulumi.Input[builtins.int]] = None,
                 start_hour: Optional[pulumi.Input[builtins.int]] = None,
                 start_minute: Optional[pulumi.Input[builtins.int]] = None):
        """
        Maintenance window properties of a flexible server.
        :param pulumi.Input[builtins.str] custom_window: Indicates whether custom window is enabled or disabled.
        :param pulumi.Input[builtins.int] day_of_week: Day of the week to be used for maintenance window.
        :param pulumi.Input[builtins.int] start_hour: Start hour to be used for maintenance window.
        :param pulumi.Input[builtins.int] start_minute: Start minute to be used for maintenance window.
        """
        if custom_window is None:
            custom_window = 'Disabled'
        if custom_window is not None:
            pulumi.set(__self__, "custom_window", custom_window)
        if day_of_week is None:
            day_of_week = 0
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if start_hour is None:
            start_hour = 0
        if start_hour is not None:
            pulumi.set(__self__, "start_hour", start_hour)
        if start_minute is None:
            start_minute = 0
        if start_minute is not None:
            pulumi.set(__self__, "start_minute", start_minute)

    @property
    @pulumi.getter(name="customWindow")
    def custom_window(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates whether custom window is enabled or disabled.
        """
        return pulumi.get(self, "custom_window")

    @custom_window.setter
    def custom_window(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_window", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Day of the week to be used for maintenance window.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Start hour to be used for maintenance window.
        """
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start_hour", value)

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Start minute to be used for maintenance window.
        """
        return pulumi.get(self, "start_minute")

    @start_minute.setter
    def start_minute(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start_minute", value)


if not MYPY:
    class MigrationSecretParametersArgsDict(TypedDict):
        """
        Migration secret parameters.
        """
        admin_credentials: pulumi.Input['AdminCredentialsArgsDict']
        """
        Credentials of administrator users for source and target servers.
        """
        source_server_username: NotRequired[pulumi.Input[builtins.str]]
        """
        Gets or sets the name of the user for the source server. This user doesn't need to be an administrator.
        """
        target_server_username: NotRequired[pulumi.Input[builtins.str]]
        """
        Gets or sets the name of the user for the target server. This user doesn't need to be an administrator.
        """
elif False:
    MigrationSecretParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MigrationSecretParametersArgs:
    def __init__(__self__, *,
                 admin_credentials: pulumi.Input['AdminCredentialsArgs'],
                 source_server_username: Optional[pulumi.Input[builtins.str]] = None,
                 target_server_username: Optional[pulumi.Input[builtins.str]] = None):
        """
        Migration secret parameters.
        :param pulumi.Input['AdminCredentialsArgs'] admin_credentials: Credentials of administrator users for source and target servers.
        :param pulumi.Input[builtins.str] source_server_username: Gets or sets the name of the user for the source server. This user doesn't need to be an administrator.
        :param pulumi.Input[builtins.str] target_server_username: Gets or sets the name of the user for the target server. This user doesn't need to be an administrator.
        """
        pulumi.set(__self__, "admin_credentials", admin_credentials)
        if source_server_username is not None:
            pulumi.set(__self__, "source_server_username", source_server_username)
        if target_server_username is not None:
            pulumi.set(__self__, "target_server_username", target_server_username)

    @property
    @pulumi.getter(name="adminCredentials")
    def admin_credentials(self) -> pulumi.Input['AdminCredentialsArgs']:
        """
        Credentials of administrator users for source and target servers.
        """
        return pulumi.get(self, "admin_credentials")

    @admin_credentials.setter
    def admin_credentials(self, value: pulumi.Input['AdminCredentialsArgs']):
        pulumi.set(self, "admin_credentials", value)

    @property
    @pulumi.getter(name="sourceServerUsername")
    def source_server_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Gets or sets the name of the user for the source server. This user doesn't need to be an administrator.
        """
        return pulumi.get(self, "source_server_username")

    @source_server_username.setter
    def source_server_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_server_username", value)

    @property
    @pulumi.getter(name="targetServerUsername")
    def target_server_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Gets or sets the name of the user for the target server. This user doesn't need to be an administrator.
        """
        return pulumi.get(self, "target_server_username")

    @target_server_username.setter
    def target_server_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target_server_username", value)


if not MYPY:
    class NetworkArgsDict(TypedDict):
        """
        Network properties of a flexible server.
        """
        delegated_subnet_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource identifier of the delegated subnet. Required during creation of a new server, in case you want the server to be integrated into your own virtual network. For an update operation, you only have to provide this property if you want to change the value assigned for the private DNS zone.
        """
        private_dns_zone_arm_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the private DNS zone. Required during creation of a new server, in case you want the server to be integrated into your own virtual network. For an update operation, you only have to provide this property if you want to change the value assigned for the private DNS zone.
        """
        public_network_access: NotRequired[pulumi.Input[Union[builtins.str, 'ServerPublicNetworkAccessState']]]
        """
        Indicates if public network access is enabled or not.
        """
elif False:
    NetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkArgs:
    def __init__(__self__, *,
                 delegated_subnet_resource_id: Optional[pulumi.Input[builtins.str]] = None,
                 private_dns_zone_arm_resource_id: Optional[pulumi.Input[builtins.str]] = None,
                 public_network_access: Optional[pulumi.Input[Union[builtins.str, 'ServerPublicNetworkAccessState']]] = None):
        """
        Network properties of a flexible server.
        :param pulumi.Input[builtins.str] delegated_subnet_resource_id: Resource identifier of the delegated subnet. Required during creation of a new server, in case you want the server to be integrated into your own virtual network. For an update operation, you only have to provide this property if you want to change the value assigned for the private DNS zone.
        :param pulumi.Input[builtins.str] private_dns_zone_arm_resource_id: Identifier of the private DNS zone. Required during creation of a new server, in case you want the server to be integrated into your own virtual network. For an update operation, you only have to provide this property if you want to change the value assigned for the private DNS zone.
        :param pulumi.Input[Union[builtins.str, 'ServerPublicNetworkAccessState']] public_network_access: Indicates if public network access is enabled or not.
        """
        if delegated_subnet_resource_id is not None:
            pulumi.set(__self__, "delegated_subnet_resource_id", delegated_subnet_resource_id)
        if private_dns_zone_arm_resource_id is not None:
            pulumi.set(__self__, "private_dns_zone_arm_resource_id", private_dns_zone_arm_resource_id)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)

    @property
    @pulumi.getter(name="delegatedSubnetResourceId")
    def delegated_subnet_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource identifier of the delegated subnet. Required during creation of a new server, in case you want the server to be integrated into your own virtual network. For an update operation, you only have to provide this property if you want to change the value assigned for the private DNS zone.
        """
        return pulumi.get(self, "delegated_subnet_resource_id")

    @delegated_subnet_resource_id.setter
    def delegated_subnet_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delegated_subnet_resource_id", value)

    @property
    @pulumi.getter(name="privateDnsZoneArmResourceId")
    def private_dns_zone_arm_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the private DNS zone. Required during creation of a new server, in case you want the server to be integrated into your own virtual network. For an update operation, you only have to provide this property if you want to change the value assigned for the private DNS zone.
        """
        return pulumi.get(self, "private_dns_zone_arm_resource_id")

    @private_dns_zone_arm_resource_id.setter
    def private_dns_zone_arm_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_dns_zone_arm_resource_id", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[builtins.str, 'ServerPublicNetworkAccessState']]]:
        """
        Indicates if public network access is enabled or not.
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[builtins.str, 'ServerPublicNetworkAccessState']]]):
        pulumi.set(self, "public_network_access", value)


if not MYPY:
    class PrivateLinkServiceConnectionStateArgsDict(TypedDict):
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        actions_required: NotRequired[pulumi.Input[builtins.str]]
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The reason for approval/rejection of the connection.
        """
        status: NotRequired[pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']]]
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
elif False:
    PrivateLinkServiceConnectionStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateLinkServiceConnectionStateArgs:
    def __init__(__self__, *,
                 actions_required: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']]] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param pulumi.Input[builtins.str] actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param pulumi.Input[builtins.str] description: The reason for approval/rejection of the connection.
        :param pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']] status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @actions_required.setter
    def actions_required(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "actions_required", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']]]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ReplicaArgsDict(TypedDict):
        """
        Replica properties of a flexible server.
        """
        promote_mode: NotRequired[pulumi.Input[Union[builtins.str, 'ReadReplicaPromoteMode']]]
        """
        Type of operation to apply on the read replica. This property is write only. Standalone means that the read replica will be promoted to a standalone server, and will become a completely independent entity from the replication set. Switchover means that the read replica will roles with the primary server.
        """
        promote_option: NotRequired[pulumi.Input[Union[builtins.str, 'ReplicationPromoteOption']]]
        """
        Data synchronization option to use when processing the operation specified in the promoteMode property This property is write only. Planned means that the operation will wait for data in the read replica to be fully synchronized with its source server before it initiates the operation. Forced means that the operation will not wait for data in the read replica to be synchronized with its source server before it initiates the operation.
        """
        role: NotRequired[pulumi.Input[Union[builtins.str, 'ReplicationRole']]]
        """
        Role of the server in a replication set.
        """
elif False:
    ReplicaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicaArgs:
    def __init__(__self__, *,
                 promote_mode: Optional[pulumi.Input[Union[builtins.str, 'ReadReplicaPromoteMode']]] = None,
                 promote_option: Optional[pulumi.Input[Union[builtins.str, 'ReplicationPromoteOption']]] = None,
                 role: Optional[pulumi.Input[Union[builtins.str, 'ReplicationRole']]] = None):
        """
        Replica properties of a flexible server.
        :param pulumi.Input[Union[builtins.str, 'ReadReplicaPromoteMode']] promote_mode: Type of operation to apply on the read replica. This property is write only. Standalone means that the read replica will be promoted to a standalone server, and will become a completely independent entity from the replication set. Switchover means that the read replica will roles with the primary server.
        :param pulumi.Input[Union[builtins.str, 'ReplicationPromoteOption']] promote_option: Data synchronization option to use when processing the operation specified in the promoteMode property This property is write only. Planned means that the operation will wait for data in the read replica to be fully synchronized with its source server before it initiates the operation. Forced means that the operation will not wait for data in the read replica to be synchronized with its source server before it initiates the operation.
        :param pulumi.Input[Union[builtins.str, 'ReplicationRole']] role: Role of the server in a replication set.
        """
        if promote_mode is not None:
            pulumi.set(__self__, "promote_mode", promote_mode)
        if promote_option is not None:
            pulumi.set(__self__, "promote_option", promote_option)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="promoteMode")
    def promote_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'ReadReplicaPromoteMode']]]:
        """
        Type of operation to apply on the read replica. This property is write only. Standalone means that the read replica will be promoted to a standalone server, and will become a completely independent entity from the replication set. Switchover means that the read replica will roles with the primary server.
        """
        return pulumi.get(self, "promote_mode")

    @promote_mode.setter
    def promote_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'ReadReplicaPromoteMode']]]):
        pulumi.set(self, "promote_mode", value)

    @property
    @pulumi.getter(name="promoteOption")
    def promote_option(self) -> Optional[pulumi.Input[Union[builtins.str, 'ReplicationPromoteOption']]]:
        """
        Data synchronization option to use when processing the operation specified in the promoteMode property This property is write only. Planned means that the operation will wait for data in the read replica to be fully synchronized with its source server before it initiates the operation. Forced means that the operation will not wait for data in the read replica to be synchronized with its source server before it initiates the operation.
        """
        return pulumi.get(self, "promote_option")

    @promote_option.setter
    def promote_option(self, value: Optional[pulumi.Input[Union[builtins.str, 'ReplicationPromoteOption']]]):
        pulumi.set(self, "promote_option", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[Union[builtins.str, 'ReplicationRole']]]:
        """
        Role of the server in a replication set.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[Union[builtins.str, 'ReplicationRole']]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class ResourceIdentityArgsDict(TypedDict):
        """
        Azure Active Directory identity configuration for a resource.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'SingleServerIdentityProperties']]]
        """
        The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
        """
elif False:
    ResourceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[builtins.str, 'SingleServerIdentityProperties']]] = None):
        """
        Azure Active Directory identity configuration for a resource.
        :param pulumi.Input[Union[builtins.str, 'SingleServerIdentityProperties']] type: The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'SingleServerIdentityProperties']]]:
        """
        The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'SingleServerIdentityProperties']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServerGroupClusterAuthConfigArgsDict(TypedDict):
        """
        Authentication configuration of a cluster.
        """
        active_directory_auth: NotRequired[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuth']]]
        password_auth: NotRequired[pulumi.Input[Union[builtins.str, 'PasswordAuth']]]
elif False:
    ServerGroupClusterAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerGroupClusterAuthConfigArgs:
    def __init__(__self__, *,
                 active_directory_auth: Optional[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuth']]] = None,
                 password_auth: Optional[pulumi.Input[Union[builtins.str, 'PasswordAuth']]] = None):
        """
        Authentication configuration of a cluster.
        """
        if active_directory_auth is not None:
            pulumi.set(__self__, "active_directory_auth", active_directory_auth)
        if password_auth is not None:
            pulumi.set(__self__, "password_auth", password_auth)

    @property
    @pulumi.getter(name="activeDirectoryAuth")
    def active_directory_auth(self) -> Optional[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuth']]]:
        return pulumi.get(self, "active_directory_auth")

    @active_directory_auth.setter
    def active_directory_auth(self, value: Optional[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuth']]]):
        pulumi.set(self, "active_directory_auth", value)

    @property
    @pulumi.getter(name="passwordAuth")
    def password_auth(self) -> Optional[pulumi.Input[Union[builtins.str, 'PasswordAuth']]]:
        return pulumi.get(self, "password_auth")

    @password_auth.setter
    def password_auth(self, value: Optional[pulumi.Input[Union[builtins.str, 'PasswordAuth']]]):
        pulumi.set(self, "password_auth", value)


if not MYPY:
    class ServerGroupClusterDataEncryptionArgsDict(TypedDict):
        """
        The data encryption properties of a cluster.
        """
        primary_key_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        URI for the key in keyvault for data encryption of the primary server.
        """
        primary_user_assigned_identity_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource Id for the User assigned identity to be used for data encryption of the primary server.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'DataEncryptionType']]]
elif False:
    ServerGroupClusterDataEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerGroupClusterDataEncryptionArgs:
    def __init__(__self__, *,
                 primary_key_uri: Optional[pulumi.Input[builtins.str]] = None,
                 primary_user_assigned_identity_id: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'DataEncryptionType']]] = None):
        """
        The data encryption properties of a cluster.
        :param pulumi.Input[builtins.str] primary_key_uri: URI for the key in keyvault for data encryption of the primary server.
        :param pulumi.Input[builtins.str] primary_user_assigned_identity_id: Resource Id for the User assigned identity to be used for data encryption of the primary server.
        """
        if primary_key_uri is not None:
            pulumi.set(__self__, "primary_key_uri", primary_key_uri)
        if primary_user_assigned_identity_id is not None:
            pulumi.set(__self__, "primary_user_assigned_identity_id", primary_user_assigned_identity_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="primaryKeyUri")
    def primary_key_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI for the key in keyvault for data encryption of the primary server.
        """
        return pulumi.get(self, "primary_key_uri")

    @primary_key_uri.setter
    def primary_key_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "primary_key_uri", value)

    @property
    @pulumi.getter(name="primaryUserAssignedIdentityId")
    def primary_user_assigned_identity_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource Id for the User assigned identity to be used for data encryption of the primary server.
        """
        return pulumi.get(self, "primary_user_assigned_identity_id")

    @primary_user_assigned_identity_id.setter
    def primary_user_assigned_identity_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "primary_user_assigned_identity_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'DataEncryptionType']]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'DataEncryptionType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServerGroupClusterMaintenanceWindowArgsDict(TypedDict):
        """
        Schedule settings for regular cluster updates.
        """
        custom_window: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates whether custom maintenance window is enabled or not.
        """
        day_of_week: NotRequired[pulumi.Input[builtins.int]]
        """
        Preferred day of the week for maintenance window.
        """
        start_hour: NotRequired[pulumi.Input[builtins.int]]
        """
        Start hour within preferred day of the week for maintenance window.
        """
        start_minute: NotRequired[pulumi.Input[builtins.int]]
        """
        Start minute within the start hour for maintenance window.
        """
elif False:
    ServerGroupClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerGroupClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_window: Optional[pulumi.Input[builtins.str]] = None,
                 day_of_week: Optional[pulumi.Input[builtins.int]] = None,
                 start_hour: Optional[pulumi.Input[builtins.int]] = None,
                 start_minute: Optional[pulumi.Input[builtins.int]] = None):
        """
        Schedule settings for regular cluster updates.
        :param pulumi.Input[builtins.str] custom_window: Indicates whether custom maintenance window is enabled or not.
        :param pulumi.Input[builtins.int] day_of_week: Preferred day of the week for maintenance window.
        :param pulumi.Input[builtins.int] start_hour: Start hour within preferred day of the week for maintenance window.
        :param pulumi.Input[builtins.int] start_minute: Start minute within the start hour for maintenance window.
        """
        if custom_window is not None:
            pulumi.set(__self__, "custom_window", custom_window)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if start_hour is not None:
            pulumi.set(__self__, "start_hour", start_hour)
        if start_minute is not None:
            pulumi.set(__self__, "start_minute", start_minute)

    @property
    @pulumi.getter(name="customWindow")
    def custom_window(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates whether custom maintenance window is enabled or not.
        """
        return pulumi.get(self, "custom_window")

    @custom_window.setter
    def custom_window(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_window", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Preferred day of the week for maintenance window.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Start hour within preferred day of the week for maintenance window.
        """
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start_hour", value)

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Start minute within the start hour for maintenance window.
        """
        return pulumi.get(self, "start_minute")

    @start_minute.setter
    def start_minute(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start_minute", value)


if not MYPY:
    class ServerPropertiesForDefaultCreateArgsDict(TypedDict):
        """
        The properties used to create a new server.
        """
        administrator_login: pulumi.Input[builtins.str]
        """
        The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
        """
        administrator_login_password: pulumi.Input[builtins.str]
        """
        The password of the administrator login.
        """
        create_mode: pulumi.Input[builtins.str]
        """
        The mode to create a new server.
        Expected value is 'Default'.
        """
        infrastructure_encryption: NotRequired[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        minimal_tls_version: NotRequired[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]
        """
        Enforce a minimal Tls version for the server.
        """
        public_network_access: NotRequired[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        ssl_enforcement: NotRequired[pulumi.Input['SslEnforcementEnum']]
        """
        Enable ssl enforcement or not when connect to server.
        """
        storage_profile: NotRequired[pulumi.Input['StorageProfileArgsDict']]
        """
        Storage profile of a server.
        """
        version: NotRequired[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]
        """
        Server version.
        """
elif False:
    ServerPropertiesForDefaultCreateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerPropertiesForDefaultCreateArgs:
    def __init__(__self__, *,
                 administrator_login: pulumi.Input[builtins.str],
                 administrator_login_password: pulumi.Input[builtins.str],
                 create_mode: pulumi.Input[builtins.str],
                 infrastructure_encryption: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]] = None,
                 minimal_tls_version: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]] = None,
                 public_network_access: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]] = None,
                 ssl_enforcement: Optional[pulumi.Input['SslEnforcementEnum']] = None,
                 storage_profile: Optional[pulumi.Input['StorageProfileArgs']] = None,
                 version: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]] = None):
        """
        The properties used to create a new server.
        :param pulumi.Input[builtins.str] administrator_login: The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
        :param pulumi.Input[builtins.str] administrator_login_password: The password of the administrator login.
        :param pulumi.Input[builtins.str] create_mode: The mode to create a new server.
               Expected value is 'Default'.
        :param pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']] infrastructure_encryption: Status showing whether the server enabled infrastructure encryption.
        :param pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']] minimal_tls_version: Enforce a minimal Tls version for the server.
        :param pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']] public_network_access: Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        :param pulumi.Input['SslEnforcementEnum'] ssl_enforcement: Enable ssl enforcement or not when connect to server.
        :param pulumi.Input['StorageProfileArgs'] storage_profile: Storage profile of a server.
        :param pulumi.Input[Union[builtins.str, 'SingleServerVersion']] version: Server version.
        """
        pulumi.set(__self__, "administrator_login", administrator_login)
        pulumi.set(__self__, "administrator_login_password", administrator_login_password)
        pulumi.set(__self__, "create_mode", 'Default')
        if infrastructure_encryption is not None:
            pulumi.set(__self__, "infrastructure_encryption", infrastructure_encryption)
        if minimal_tls_version is not None:
            pulumi.set(__self__, "minimal_tls_version", minimal_tls_version)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if ssl_enforcement is not None:
            pulumi.set(__self__, "ssl_enforcement", ssl_enforcement)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="administratorLogin")
    def administrator_login(self) -> pulumi.Input[builtins.str]:
        """
        The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
        """
        return pulumi.get(self, "administrator_login")

    @administrator_login.setter
    def administrator_login(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "administrator_login", value)

    @property
    @pulumi.getter(name="administratorLoginPassword")
    def administrator_login_password(self) -> pulumi.Input[builtins.str]:
        """
        The password of the administrator login.
        """
        return pulumi.get(self, "administrator_login_password")

    @administrator_login_password.setter
    def administrator_login_password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "administrator_login_password", value)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> pulumi.Input[builtins.str]:
        """
        The mode to create a new server.
        Expected value is 'Default'.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="infrastructureEncryption")
    def infrastructure_encryption(self) -> Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]:
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        return pulumi.get(self, "infrastructure_encryption")

    @infrastructure_encryption.setter
    def infrastructure_encryption(self, value: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]):
        pulumi.set(self, "infrastructure_encryption", value)

    @property
    @pulumi.getter(name="minimalTlsVersion")
    def minimal_tls_version(self) -> Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]:
        """
        Enforce a minimal Tls version for the server.
        """
        return pulumi.get(self, "minimal_tls_version")

    @minimal_tls_version.setter
    def minimal_tls_version(self, value: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]):
        pulumi.set(self, "minimal_tls_version", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]:
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]):
        pulumi.set(self, "public_network_access", value)

    @property
    @pulumi.getter(name="sslEnforcement")
    def ssl_enforcement(self) -> Optional[pulumi.Input['SslEnforcementEnum']]:
        """
        Enable ssl enforcement or not when connect to server.
        """
        return pulumi.get(self, "ssl_enforcement")

    @ssl_enforcement.setter
    def ssl_enforcement(self, value: Optional[pulumi.Input['SslEnforcementEnum']]):
        pulumi.set(self, "ssl_enforcement", value)

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[pulumi.Input['StorageProfileArgs']]:
        """
        Storage profile of a server.
        """
        return pulumi.get(self, "storage_profile")

    @storage_profile.setter
    def storage_profile(self, value: Optional[pulumi.Input['StorageProfileArgs']]):
        pulumi.set(self, "storage_profile", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]:
        """
        Server version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ServerPropertiesForGeoRestoreArgsDict(TypedDict):
        """
        The properties used to create a new server by restoring to a different region from a geo replicated backup.
        """
        create_mode: pulumi.Input[builtins.str]
        """
        The mode to create a new server.
        Expected value is 'GeoRestore'.
        """
        source_server_id: pulumi.Input[builtins.str]
        """
        The source server id to restore from.
        """
        infrastructure_encryption: NotRequired[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        minimal_tls_version: NotRequired[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]
        """
        Enforce a minimal Tls version for the server.
        """
        public_network_access: NotRequired[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        ssl_enforcement: NotRequired[pulumi.Input['SslEnforcementEnum']]
        """
        Enable ssl enforcement or not when connect to server.
        """
        storage_profile: NotRequired[pulumi.Input['StorageProfileArgsDict']]
        """
        Storage profile of a server.
        """
        version: NotRequired[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]
        """
        Server version.
        """
elif False:
    ServerPropertiesForGeoRestoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerPropertiesForGeoRestoreArgs:
    def __init__(__self__, *,
                 create_mode: pulumi.Input[builtins.str],
                 source_server_id: pulumi.Input[builtins.str],
                 infrastructure_encryption: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]] = None,
                 minimal_tls_version: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]] = None,
                 public_network_access: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]] = None,
                 ssl_enforcement: Optional[pulumi.Input['SslEnforcementEnum']] = None,
                 storage_profile: Optional[pulumi.Input['StorageProfileArgs']] = None,
                 version: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]] = None):
        """
        The properties used to create a new server by restoring to a different region from a geo replicated backup.
        :param pulumi.Input[builtins.str] create_mode: The mode to create a new server.
               Expected value is 'GeoRestore'.
        :param pulumi.Input[builtins.str] source_server_id: The source server id to restore from.
        :param pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']] infrastructure_encryption: Status showing whether the server enabled infrastructure encryption.
        :param pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']] minimal_tls_version: Enforce a minimal Tls version for the server.
        :param pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']] public_network_access: Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        :param pulumi.Input['SslEnforcementEnum'] ssl_enforcement: Enable ssl enforcement or not when connect to server.
        :param pulumi.Input['StorageProfileArgs'] storage_profile: Storage profile of a server.
        :param pulumi.Input[Union[builtins.str, 'SingleServerVersion']] version: Server version.
        """
        pulumi.set(__self__, "create_mode", 'GeoRestore')
        pulumi.set(__self__, "source_server_id", source_server_id)
        if infrastructure_encryption is not None:
            pulumi.set(__self__, "infrastructure_encryption", infrastructure_encryption)
        if minimal_tls_version is not None:
            pulumi.set(__self__, "minimal_tls_version", minimal_tls_version)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if ssl_enforcement is not None:
            pulumi.set(__self__, "ssl_enforcement", ssl_enforcement)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> pulumi.Input[builtins.str]:
        """
        The mode to create a new server.
        Expected value is 'GeoRestore'.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="sourceServerId")
    def source_server_id(self) -> pulumi.Input[builtins.str]:
        """
        The source server id to restore from.
        """
        return pulumi.get(self, "source_server_id")

    @source_server_id.setter
    def source_server_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_server_id", value)

    @property
    @pulumi.getter(name="infrastructureEncryption")
    def infrastructure_encryption(self) -> Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]:
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        return pulumi.get(self, "infrastructure_encryption")

    @infrastructure_encryption.setter
    def infrastructure_encryption(self, value: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]):
        pulumi.set(self, "infrastructure_encryption", value)

    @property
    @pulumi.getter(name="minimalTlsVersion")
    def minimal_tls_version(self) -> Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]:
        """
        Enforce a minimal Tls version for the server.
        """
        return pulumi.get(self, "minimal_tls_version")

    @minimal_tls_version.setter
    def minimal_tls_version(self, value: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]):
        pulumi.set(self, "minimal_tls_version", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]:
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]):
        pulumi.set(self, "public_network_access", value)

    @property
    @pulumi.getter(name="sslEnforcement")
    def ssl_enforcement(self) -> Optional[pulumi.Input['SslEnforcementEnum']]:
        """
        Enable ssl enforcement or not when connect to server.
        """
        return pulumi.get(self, "ssl_enforcement")

    @ssl_enforcement.setter
    def ssl_enforcement(self, value: Optional[pulumi.Input['SslEnforcementEnum']]):
        pulumi.set(self, "ssl_enforcement", value)

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[pulumi.Input['StorageProfileArgs']]:
        """
        Storage profile of a server.
        """
        return pulumi.get(self, "storage_profile")

    @storage_profile.setter
    def storage_profile(self, value: Optional[pulumi.Input['StorageProfileArgs']]):
        pulumi.set(self, "storage_profile", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]:
        """
        Server version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ServerPropertiesForReplicaArgsDict(TypedDict):
        """
        The properties to create a new replica.
        """
        create_mode: pulumi.Input[builtins.str]
        """
        The mode to create a new server.
        Expected value is 'Replica'.
        """
        source_server_id: pulumi.Input[builtins.str]
        """
        The master server id to create replica from.
        """
        infrastructure_encryption: NotRequired[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        minimal_tls_version: NotRequired[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]
        """
        Enforce a minimal Tls version for the server.
        """
        public_network_access: NotRequired[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        ssl_enforcement: NotRequired[pulumi.Input['SslEnforcementEnum']]
        """
        Enable ssl enforcement or not when connect to server.
        """
        storage_profile: NotRequired[pulumi.Input['StorageProfileArgsDict']]
        """
        Storage profile of a server.
        """
        version: NotRequired[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]
        """
        Server version.
        """
elif False:
    ServerPropertiesForReplicaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerPropertiesForReplicaArgs:
    def __init__(__self__, *,
                 create_mode: pulumi.Input[builtins.str],
                 source_server_id: pulumi.Input[builtins.str],
                 infrastructure_encryption: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]] = None,
                 minimal_tls_version: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]] = None,
                 public_network_access: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]] = None,
                 ssl_enforcement: Optional[pulumi.Input['SslEnforcementEnum']] = None,
                 storage_profile: Optional[pulumi.Input['StorageProfileArgs']] = None,
                 version: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]] = None):
        """
        The properties to create a new replica.
        :param pulumi.Input[builtins.str] create_mode: The mode to create a new server.
               Expected value is 'Replica'.
        :param pulumi.Input[builtins.str] source_server_id: The master server id to create replica from.
        :param pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']] infrastructure_encryption: Status showing whether the server enabled infrastructure encryption.
        :param pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']] minimal_tls_version: Enforce a minimal Tls version for the server.
        :param pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']] public_network_access: Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        :param pulumi.Input['SslEnforcementEnum'] ssl_enforcement: Enable ssl enforcement or not when connect to server.
        :param pulumi.Input['StorageProfileArgs'] storage_profile: Storage profile of a server.
        :param pulumi.Input[Union[builtins.str, 'SingleServerVersion']] version: Server version.
        """
        pulumi.set(__self__, "create_mode", 'Replica')
        pulumi.set(__self__, "source_server_id", source_server_id)
        if infrastructure_encryption is not None:
            pulumi.set(__self__, "infrastructure_encryption", infrastructure_encryption)
        if minimal_tls_version is not None:
            pulumi.set(__self__, "minimal_tls_version", minimal_tls_version)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if ssl_enforcement is not None:
            pulumi.set(__self__, "ssl_enforcement", ssl_enforcement)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> pulumi.Input[builtins.str]:
        """
        The mode to create a new server.
        Expected value is 'Replica'.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="sourceServerId")
    def source_server_id(self) -> pulumi.Input[builtins.str]:
        """
        The master server id to create replica from.
        """
        return pulumi.get(self, "source_server_id")

    @source_server_id.setter
    def source_server_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_server_id", value)

    @property
    @pulumi.getter(name="infrastructureEncryption")
    def infrastructure_encryption(self) -> Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]:
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        return pulumi.get(self, "infrastructure_encryption")

    @infrastructure_encryption.setter
    def infrastructure_encryption(self, value: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]):
        pulumi.set(self, "infrastructure_encryption", value)

    @property
    @pulumi.getter(name="minimalTlsVersion")
    def minimal_tls_version(self) -> Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]:
        """
        Enforce a minimal Tls version for the server.
        """
        return pulumi.get(self, "minimal_tls_version")

    @minimal_tls_version.setter
    def minimal_tls_version(self, value: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]):
        pulumi.set(self, "minimal_tls_version", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]:
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]):
        pulumi.set(self, "public_network_access", value)

    @property
    @pulumi.getter(name="sslEnforcement")
    def ssl_enforcement(self) -> Optional[pulumi.Input['SslEnforcementEnum']]:
        """
        Enable ssl enforcement or not when connect to server.
        """
        return pulumi.get(self, "ssl_enforcement")

    @ssl_enforcement.setter
    def ssl_enforcement(self, value: Optional[pulumi.Input['SslEnforcementEnum']]):
        pulumi.set(self, "ssl_enforcement", value)

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[pulumi.Input['StorageProfileArgs']]:
        """
        Storage profile of a server.
        """
        return pulumi.get(self, "storage_profile")

    @storage_profile.setter
    def storage_profile(self, value: Optional[pulumi.Input['StorageProfileArgs']]):
        pulumi.set(self, "storage_profile", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]:
        """
        Server version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ServerPropertiesForRestoreArgsDict(TypedDict):
        """
        The properties used to create a new server by restoring from a backup.
        """
        create_mode: pulumi.Input[builtins.str]
        """
        The mode to create a new server.
        Expected value is 'PointInTimeRestore'.
        """
        restore_point_in_time: pulumi.Input[builtins.str]
        """
        Restore point creation time (ISO8601 format), specifying the time to restore from.
        """
        source_server_id: pulumi.Input[builtins.str]
        """
        The source server id to restore from.
        """
        infrastructure_encryption: NotRequired[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        minimal_tls_version: NotRequired[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]
        """
        Enforce a minimal Tls version for the server.
        """
        public_network_access: NotRequired[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        ssl_enforcement: NotRequired[pulumi.Input['SslEnforcementEnum']]
        """
        Enable ssl enforcement or not when connect to server.
        """
        storage_profile: NotRequired[pulumi.Input['StorageProfileArgsDict']]
        """
        Storage profile of a server.
        """
        version: NotRequired[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]
        """
        Server version.
        """
elif False:
    ServerPropertiesForRestoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerPropertiesForRestoreArgs:
    def __init__(__self__, *,
                 create_mode: pulumi.Input[builtins.str],
                 restore_point_in_time: pulumi.Input[builtins.str],
                 source_server_id: pulumi.Input[builtins.str],
                 infrastructure_encryption: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]] = None,
                 minimal_tls_version: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]] = None,
                 public_network_access: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]] = None,
                 ssl_enforcement: Optional[pulumi.Input['SslEnforcementEnum']] = None,
                 storage_profile: Optional[pulumi.Input['StorageProfileArgs']] = None,
                 version: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]] = None):
        """
        The properties used to create a new server by restoring from a backup.
        :param pulumi.Input[builtins.str] create_mode: The mode to create a new server.
               Expected value is 'PointInTimeRestore'.
        :param pulumi.Input[builtins.str] restore_point_in_time: Restore point creation time (ISO8601 format), specifying the time to restore from.
        :param pulumi.Input[builtins.str] source_server_id: The source server id to restore from.
        :param pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']] infrastructure_encryption: Status showing whether the server enabled infrastructure encryption.
        :param pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']] minimal_tls_version: Enforce a minimal Tls version for the server.
        :param pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']] public_network_access: Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        :param pulumi.Input['SslEnforcementEnum'] ssl_enforcement: Enable ssl enforcement or not when connect to server.
        :param pulumi.Input['StorageProfileArgs'] storage_profile: Storage profile of a server.
        :param pulumi.Input[Union[builtins.str, 'SingleServerVersion']] version: Server version.
        """
        pulumi.set(__self__, "create_mode", 'PointInTimeRestore')
        pulumi.set(__self__, "restore_point_in_time", restore_point_in_time)
        pulumi.set(__self__, "source_server_id", source_server_id)
        if infrastructure_encryption is not None:
            pulumi.set(__self__, "infrastructure_encryption", infrastructure_encryption)
        if minimal_tls_version is not None:
            pulumi.set(__self__, "minimal_tls_version", minimal_tls_version)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if ssl_enforcement is not None:
            pulumi.set(__self__, "ssl_enforcement", ssl_enforcement)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> pulumi.Input[builtins.str]:
        """
        The mode to create a new server.
        Expected value is 'PointInTimeRestore'.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="restorePointInTime")
    def restore_point_in_time(self) -> pulumi.Input[builtins.str]:
        """
        Restore point creation time (ISO8601 format), specifying the time to restore from.
        """
        return pulumi.get(self, "restore_point_in_time")

    @restore_point_in_time.setter
    def restore_point_in_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "restore_point_in_time", value)

    @property
    @pulumi.getter(name="sourceServerId")
    def source_server_id(self) -> pulumi.Input[builtins.str]:
        """
        The source server id to restore from.
        """
        return pulumi.get(self, "source_server_id")

    @source_server_id.setter
    def source_server_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_server_id", value)

    @property
    @pulumi.getter(name="infrastructureEncryption")
    def infrastructure_encryption(self) -> Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]:
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        return pulumi.get(self, "infrastructure_encryption")

    @infrastructure_encryption.setter
    def infrastructure_encryption(self, value: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]):
        pulumi.set(self, "infrastructure_encryption", value)

    @property
    @pulumi.getter(name="minimalTlsVersion")
    def minimal_tls_version(self) -> Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]:
        """
        Enforce a minimal Tls version for the server.
        """
        return pulumi.get(self, "minimal_tls_version")

    @minimal_tls_version.setter
    def minimal_tls_version(self, value: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]):
        pulumi.set(self, "minimal_tls_version", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]:
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]):
        pulumi.set(self, "public_network_access", value)

    @property
    @pulumi.getter(name="sslEnforcement")
    def ssl_enforcement(self) -> Optional[pulumi.Input['SslEnforcementEnum']]:
        """
        Enable ssl enforcement or not when connect to server.
        """
        return pulumi.get(self, "ssl_enforcement")

    @ssl_enforcement.setter
    def ssl_enforcement(self, value: Optional[pulumi.Input['SslEnforcementEnum']]):
        pulumi.set(self, "ssl_enforcement", value)

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[pulumi.Input['StorageProfileArgs']]:
        """
        Storage profile of a server.
        """
        return pulumi.get(self, "storage_profile")

    @storage_profile.setter
    def storage_profile(self, value: Optional[pulumi.Input['StorageProfileArgs']]):
        pulumi.set(self, "storage_profile", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]:
        """
        Server version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class SingleServerSkuArgsDict(TypedDict):
        """
        Billing information related properties of a server.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
        """
        capacity: NotRequired[pulumi.Input[builtins.int]]
        """
        The scale up/out capacity, representing server's compute units.
        """
        family: NotRequired[pulumi.Input[builtins.str]]
        """
        The family of hardware.
        """
        size: NotRequired[pulumi.Input[builtins.str]]
        """
        The size code, to be interpreted by resource as appropriate.
        """
        tier: NotRequired[pulumi.Input[Union[builtins.str, 'SingleServerSkuTier']]]
        """
        The tier of the particular SKU, e.g. Basic.
        """
elif False:
    SingleServerSkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SingleServerSkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 capacity: Optional[pulumi.Input[builtins.int]] = None,
                 family: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.str]] = None,
                 tier: Optional[pulumi.Input[Union[builtins.str, 'SingleServerSkuTier']]] = None):
        """
        Billing information related properties of a server.
        :param pulumi.Input[builtins.str] name: The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
        :param pulumi.Input[builtins.int] capacity: The scale up/out capacity, representing server's compute units.
        :param pulumi.Input[builtins.str] family: The family of hardware.
        :param pulumi.Input[builtins.str] size: The size code, to be interpreted by resource as appropriate.
        :param pulumi.Input[Union[builtins.str, 'SingleServerSkuTier']] tier: The tier of the particular SKU, e.g. Basic.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The scale up/out capacity, representing server's compute units.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The family of hardware.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The size code, to be interpreted by resource as appropriate.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[Union[builtins.str, 'SingleServerSkuTier']]]:
        """
        The tier of the particular SKU, e.g. Basic.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[Union[builtins.str, 'SingleServerSkuTier']]]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class SkuArgsDict(TypedDict):
        """
        Compute information of a flexible server.
        """
        name: pulumi.Input[builtins.str]
        """
        Name by which is known a given compute size assigned to a flexible server.
        """
        tier: pulumi.Input[Union[builtins.str, 'SkuTier']]
        """
        Tier of the compute assigned to a flexible server.
        """
elif False:
    SkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 tier: pulumi.Input[Union[builtins.str, 'SkuTier']]):
        """
        Compute information of a flexible server.
        :param pulumi.Input[builtins.str] name: Name by which is known a given compute size assigned to a flexible server.
        :param pulumi.Input[Union[builtins.str, 'SkuTier']] tier: Tier of the compute assigned to a flexible server.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name by which is known a given compute size assigned to a flexible server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tier(self) -> pulumi.Input[Union[builtins.str, 'SkuTier']]:
        """
        Tier of the compute assigned to a flexible server.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: pulumi.Input[Union[builtins.str, 'SkuTier']]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class StorageProfileArgsDict(TypedDict):
        """
        Storage Profile properties of a server
        """
        backup_retention_days: NotRequired[pulumi.Input[builtins.int]]
        """
        Backup retention days for the server.
        """
        geo_redundant_backup: NotRequired[pulumi.Input[Union[builtins.str, 'GeoRedundantBackup']]]
        """
        Enable Geo-redundant or not for server backup.
        """
        storage_autogrow: NotRequired[pulumi.Input[Union[builtins.str, 'StorageAutogrow']]]
        """
        Enable Storage Auto Grow.
        """
        storage_mb: NotRequired[pulumi.Input[builtins.int]]
        """
        Max storage allowed for a server.
        """
elif False:
    StorageProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageProfileArgs:
    def __init__(__self__, *,
                 backup_retention_days: Optional[pulumi.Input[builtins.int]] = None,
                 geo_redundant_backup: Optional[pulumi.Input[Union[builtins.str, 'GeoRedundantBackup']]] = None,
                 storage_autogrow: Optional[pulumi.Input[Union[builtins.str, 'StorageAutogrow']]] = None,
                 storage_mb: Optional[pulumi.Input[builtins.int]] = None):
        """
        Storage Profile properties of a server
        :param pulumi.Input[builtins.int] backup_retention_days: Backup retention days for the server.
        :param pulumi.Input[Union[builtins.str, 'GeoRedundantBackup']] geo_redundant_backup: Enable Geo-redundant or not for server backup.
        :param pulumi.Input[Union[builtins.str, 'StorageAutogrow']] storage_autogrow: Enable Storage Auto Grow.
        :param pulumi.Input[builtins.int] storage_mb: Max storage allowed for a server.
        """
        if backup_retention_days is not None:
            pulumi.set(__self__, "backup_retention_days", backup_retention_days)
        if geo_redundant_backup is not None:
            pulumi.set(__self__, "geo_redundant_backup", geo_redundant_backup)
        if storage_autogrow is not None:
            pulumi.set(__self__, "storage_autogrow", storage_autogrow)
        if storage_mb is not None:
            pulumi.set(__self__, "storage_mb", storage_mb)

    @property
    @pulumi.getter(name="backupRetentionDays")
    def backup_retention_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Backup retention days for the server.
        """
        return pulumi.get(self, "backup_retention_days")

    @backup_retention_days.setter
    def backup_retention_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_retention_days", value)

    @property
    @pulumi.getter(name="geoRedundantBackup")
    def geo_redundant_backup(self) -> Optional[pulumi.Input[Union[builtins.str, 'GeoRedundantBackup']]]:
        """
        Enable Geo-redundant or not for server backup.
        """
        return pulumi.get(self, "geo_redundant_backup")

    @geo_redundant_backup.setter
    def geo_redundant_backup(self, value: Optional[pulumi.Input[Union[builtins.str, 'GeoRedundantBackup']]]):
        pulumi.set(self, "geo_redundant_backup", value)

    @property
    @pulumi.getter(name="storageAutogrow")
    def storage_autogrow(self) -> Optional[pulumi.Input[Union[builtins.str, 'StorageAutogrow']]]:
        """
        Enable Storage Auto Grow.
        """
        return pulumi.get(self, "storage_autogrow")

    @storage_autogrow.setter
    def storage_autogrow(self, value: Optional[pulumi.Input[Union[builtins.str, 'StorageAutogrow']]]):
        pulumi.set(self, "storage_autogrow", value)

    @property
    @pulumi.getter(name="storageMB")
    def storage_mb(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Max storage allowed for a server.
        """
        return pulumi.get(self, "storage_mb")

    @storage_mb.setter
    def storage_mb(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "storage_mb", value)


if not MYPY:
    class StorageArgsDict(TypedDict):
        """
        Storage properties of a flexible server.
        """
        auto_grow: NotRequired[pulumi.Input[Union[builtins.str, 'StorageAutoGrow']]]
        """
        Flag to enable or disable the automatic growth of storage size of a flexible server when available space is nearing zero and conditions allow for automatically growing storage size.
        """
        iops: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum IOPS supported for storage. Required when type of storage is PremiumV2_LRS.
        """
        storage_size_gb: NotRequired[pulumi.Input[builtins.int]]
        """
        Size of storage assigned to a flexible server.
        """
        throughput: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum throughput supported for storage. Required when type of storage is PremiumV2_LRS.
        """
        tier: NotRequired[pulumi.Input[Union[builtins.str, 'AzureManagedDiskPerformanceTiers']]]
        """
        Storage tier of a flexible server.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'StorageType']]]
        """
        Type of storage assigned to a flexible server. Allowed values are Premium_LRS or PremiumV2_LRS. If not specified, it defaults to Premium_LRS.
        """
elif False:
    StorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageArgs:
    def __init__(__self__, *,
                 auto_grow: Optional[pulumi.Input[Union[builtins.str, 'StorageAutoGrow']]] = None,
                 iops: Optional[pulumi.Input[builtins.int]] = None,
                 storage_size_gb: Optional[pulumi.Input[builtins.int]] = None,
                 throughput: Optional[pulumi.Input[builtins.int]] = None,
                 tier: Optional[pulumi.Input[Union[builtins.str, 'AzureManagedDiskPerformanceTiers']]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'StorageType']]] = None):
        """
        Storage properties of a flexible server.
        :param pulumi.Input[Union[builtins.str, 'StorageAutoGrow']] auto_grow: Flag to enable or disable the automatic growth of storage size of a flexible server when available space is nearing zero and conditions allow for automatically growing storage size.
        :param pulumi.Input[builtins.int] iops: Maximum IOPS supported for storage. Required when type of storage is PremiumV2_LRS.
        :param pulumi.Input[builtins.int] storage_size_gb: Size of storage assigned to a flexible server.
        :param pulumi.Input[builtins.int] throughput: Maximum throughput supported for storage. Required when type of storage is PremiumV2_LRS.
        :param pulumi.Input[Union[builtins.str, 'AzureManagedDiskPerformanceTiers']] tier: Storage tier of a flexible server.
        :param pulumi.Input[Union[builtins.str, 'StorageType']] type: Type of storage assigned to a flexible server. Allowed values are Premium_LRS or PremiumV2_LRS. If not specified, it defaults to Premium_LRS.
        """
        if auto_grow is not None:
            pulumi.set(__self__, "auto_grow", auto_grow)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if storage_size_gb is not None:
            pulumi.set(__self__, "storage_size_gb", storage_size_gb)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="autoGrow")
    def auto_grow(self) -> Optional[pulumi.Input[Union[builtins.str, 'StorageAutoGrow']]]:
        """
        Flag to enable or disable the automatic growth of storage size of a flexible server when available space is nearing zero and conditions allow for automatically growing storage size.
        """
        return pulumi.get(self, "auto_grow")

    @auto_grow.setter
    def auto_grow(self, value: Optional[pulumi.Input[Union[builtins.str, 'StorageAutoGrow']]]):
        pulumi.set(self, "auto_grow", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum IOPS supported for storage. Required when type of storage is PremiumV2_LRS.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="storageSizeGB")
    def storage_size_gb(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Size of storage assigned to a flexible server.
        """
        return pulumi.get(self, "storage_size_gb")

    @storage_size_gb.setter
    def storage_size_gb(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "storage_size_gb", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum throughput supported for storage. Required when type of storage is PremiumV2_LRS.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[Union[builtins.str, 'AzureManagedDiskPerformanceTiers']]]:
        """
        Storage tier of a flexible server.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[Union[builtins.str, 'AzureManagedDiskPerformanceTiers']]]):
        pulumi.set(self, "tier", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'StorageType']]]:
        """
        Type of storage assigned to a flexible server. Allowed values are Premium_LRS or PremiumV2_LRS. If not specified, it defaults to Premium_LRS.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'StorageType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class UserAssignedIdentityArgsDict(TypedDict):
        """
        Identities associated with a flexible server.
        """
        type: pulumi.Input[Union[builtins.str, 'IdentityType']]
        """
        Types of identities associated with a flexible server.
        """
        principal_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the object of the service principal associated to the user assigned managed identity.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityArgsDict']]]]
        """
        Map of user assigned managed identities.
        """
elif False:
    UserAssignedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserAssignedIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[builtins.str, 'IdentityType']],
                 principal_id: Optional[pulumi.Input[builtins.str]] = None,
                 user_assigned_identities: Optional[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityArgs']]]] = None):
        """
        Identities associated with a flexible server.
        :param pulumi.Input[Union[builtins.str, 'IdentityType']] type: Types of identities associated with a flexible server.
        :param pulumi.Input[builtins.str] principal_id: Identifier of the object of the service principal associated to the user assigned managed identity.
        :param pulumi.Input[Mapping[str, pulumi.Input['UserIdentityArgs']]] user_assigned_identities: Map of user assigned managed identities.
        """
        pulumi.set(__self__, "type", type)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[builtins.str, 'IdentityType']]:
        """
        Types of identities associated with a flexible server.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[builtins.str, 'IdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the object of the service principal associated to the user assigned managed identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityArgs']]]]:
        """
        Map of user assigned managed identities.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityArgs']]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class UserIdentityArgsDict(TypedDict):
        """
        User assigned managed identity associated with a flexible server.
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the client of the service principal associated to the user assigned managed identity.
        """
        principal_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the object of the service principal associated to the user assigned managed identity.
        """
elif False:
    UserIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserIdentityArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 principal_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        User assigned managed identity associated with a flexible server.
        :param pulumi.Input[builtins.str] client_id: Identifier of the client of the service principal associated to the user assigned managed identity.
        :param pulumi.Input[builtins.str] principal_id: Identifier of the object of the service principal associated to the user assigned managed identity.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the client of the service principal associated to the user assigned managed identity.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the object of the service principal associated to the user assigned managed identity.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "principal_id", value)


