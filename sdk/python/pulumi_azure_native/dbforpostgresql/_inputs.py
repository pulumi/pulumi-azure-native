# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AdminCredentialsArgs',
    'AdminCredentialsArgsDict',
    'AuthConfigArgs',
    'AuthConfigArgsDict',
    'BackupArgs',
    'BackupArgsDict',
    'DataEncryptionArgs',
    'DataEncryptionArgsDict',
    'HighAvailabilityArgs',
    'HighAvailabilityArgsDict',
    'IdentityPropertiesArgs',
    'IdentityPropertiesArgsDict',
    'MaintenanceWindowArgs',
    'MaintenanceWindowArgsDict',
    'MigrationSecretParametersArgs',
    'MigrationSecretParametersArgsDict',
    'NetworkArgs',
    'NetworkArgsDict',
    'PrivateLinkServiceConnectionStateArgs',
    'PrivateLinkServiceConnectionStateArgsDict',
    'ReplicaArgs',
    'ReplicaArgsDict',
    'ResourceIdentityArgs',
    'ResourceIdentityArgsDict',
    'ServerGroupClusterAuthConfigArgs',
    'ServerGroupClusterAuthConfigArgsDict',
    'ServerGroupClusterDataEncryptionArgs',
    'ServerGroupClusterDataEncryptionArgsDict',
    'ServerGroupClusterMaintenanceWindowArgs',
    'ServerGroupClusterMaintenanceWindowArgsDict',
    'ServerPropertiesForDefaultCreateArgs',
    'ServerPropertiesForDefaultCreateArgsDict',
    'ServerPropertiesForGeoRestoreArgs',
    'ServerPropertiesForGeoRestoreArgsDict',
    'ServerPropertiesForReplicaArgs',
    'ServerPropertiesForReplicaArgsDict',
    'ServerPropertiesForRestoreArgs',
    'ServerPropertiesForRestoreArgsDict',
    'SingleServerSkuArgs',
    'SingleServerSkuArgsDict',
    'SkuArgs',
    'SkuArgsDict',
    'StorageProfileArgs',
    'StorageProfileArgsDict',
    'StorageArgs',
    'StorageArgsDict',
    'UserAssignedIdentityArgs',
    'UserAssignedIdentityArgsDict',
    'UserIdentityArgs',
    'UserIdentityArgsDict',
]

MYPY = False

if not MYPY:
    class AdminCredentialsArgsDict(TypedDict):
        """
        Server admin credentials.
        """
        source_server_password: pulumi.Input[builtins.str]
        """
        Password for source server.
        """
        target_server_password: pulumi.Input[builtins.str]
        """
        Password for target server.
        """
elif False:
    AdminCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdminCredentialsArgs:
    def __init__(__self__, *,
                 source_server_password: pulumi.Input[builtins.str],
                 target_server_password: pulumi.Input[builtins.str]):
        """
        Server admin credentials.
        :param pulumi.Input[builtins.str] source_server_password: Password for source server.
        :param pulumi.Input[builtins.str] target_server_password: Password for target server.
        """
        pulumi.set(__self__, "source_server_password", source_server_password)
        pulumi.set(__self__, "target_server_password", target_server_password)

    @property
    @pulumi.getter(name="sourceServerPassword")
    def source_server_password(self) -> pulumi.Input[builtins.str]:
        """
        Password for source server.
        """
        return pulumi.get(self, "source_server_password")

    @source_server_password.setter
    def source_server_password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_server_password", value)

    @property
    @pulumi.getter(name="targetServerPassword")
    def target_server_password(self) -> pulumi.Input[builtins.str]:
        """
        Password for target server.
        """
        return pulumi.get(self, "target_server_password")

    @target_server_password.setter
    def target_server_password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target_server_password", value)


if not MYPY:
    class AuthConfigArgsDict(TypedDict):
        """
        Authentication configuration properties of a server
        """
        active_directory_auth: NotRequired[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuthEnum']]]
        """
        If Enabled, Azure Active Directory authentication is enabled.
        """
        password_auth: NotRequired[pulumi.Input[Union[builtins.str, 'PasswordAuthEnum']]]
        """
        If Enabled, Password authentication is enabled.
        """
        tenant_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Tenant id of the server.
        """
elif False:
    AuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthConfigArgs:
    def __init__(__self__, *,
                 active_directory_auth: Optional[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuthEnum']]] = None,
                 password_auth: Optional[pulumi.Input[Union[builtins.str, 'PasswordAuthEnum']]] = None,
                 tenant_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Authentication configuration properties of a server
        :param pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuthEnum']] active_directory_auth: If Enabled, Azure Active Directory authentication is enabled.
        :param pulumi.Input[Union[builtins.str, 'PasswordAuthEnum']] password_auth: If Enabled, Password authentication is enabled.
        :param pulumi.Input[builtins.str] tenant_id: Tenant id of the server.
        """
        if active_directory_auth is not None:
            pulumi.set(__self__, "active_directory_auth", active_directory_auth)
        if password_auth is None:
            password_auth = 'Enabled'
        if password_auth is not None:
            pulumi.set(__self__, "password_auth", password_auth)
        if tenant_id is None:
            tenant_id = ''
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="activeDirectoryAuth")
    def active_directory_auth(self) -> Optional[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuthEnum']]]:
        """
        If Enabled, Azure Active Directory authentication is enabled.
        """
        return pulumi.get(self, "active_directory_auth")

    @active_directory_auth.setter
    def active_directory_auth(self, value: Optional[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuthEnum']]]):
        pulumi.set(self, "active_directory_auth", value)

    @property
    @pulumi.getter(name="passwordAuth")
    def password_auth(self) -> Optional[pulumi.Input[Union[builtins.str, 'PasswordAuthEnum']]]:
        """
        If Enabled, Password authentication is enabled.
        """
        return pulumi.get(self, "password_auth")

    @password_auth.setter
    def password_auth(self, value: Optional[pulumi.Input[Union[builtins.str, 'PasswordAuthEnum']]]):
        pulumi.set(self, "password_auth", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Tenant id of the server.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class BackupArgsDict(TypedDict):
        """
        Backup properties of a server
        """
        backup_retention_days: NotRequired[pulumi.Input[builtins.int]]
        """
        Backup retention days for the server.
        """
        geo_redundant_backup: NotRequired[pulumi.Input[Union[builtins.str, 'GeoRedundantBackupEnum']]]
        """
        A value indicating whether Geo-Redundant backup is enabled on the server.
        """
elif False:
    BackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupArgs:
    def __init__(__self__, *,
                 backup_retention_days: Optional[pulumi.Input[builtins.int]] = None,
                 geo_redundant_backup: Optional[pulumi.Input[Union[builtins.str, 'GeoRedundantBackupEnum']]] = None):
        """
        Backup properties of a server
        :param pulumi.Input[builtins.int] backup_retention_days: Backup retention days for the server.
        :param pulumi.Input[Union[builtins.str, 'GeoRedundantBackupEnum']] geo_redundant_backup: A value indicating whether Geo-Redundant backup is enabled on the server.
        """
        if backup_retention_days is None:
            backup_retention_days = 7
        if backup_retention_days is not None:
            pulumi.set(__self__, "backup_retention_days", backup_retention_days)
        if geo_redundant_backup is None:
            geo_redundant_backup = 'Disabled'
        if geo_redundant_backup is not None:
            pulumi.set(__self__, "geo_redundant_backup", geo_redundant_backup)

    @property
    @pulumi.getter(name="backupRetentionDays")
    def backup_retention_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Backup retention days for the server.
        """
        return pulumi.get(self, "backup_retention_days")

    @backup_retention_days.setter
    def backup_retention_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_retention_days", value)

    @property
    @pulumi.getter(name="geoRedundantBackup")
    def geo_redundant_backup(self) -> Optional[pulumi.Input[Union[builtins.str, 'GeoRedundantBackupEnum']]]:
        """
        A value indicating whether Geo-Redundant backup is enabled on the server.
        """
        return pulumi.get(self, "geo_redundant_backup")

    @geo_redundant_backup.setter
    def geo_redundant_backup(self, value: Optional[pulumi.Input[Union[builtins.str, 'GeoRedundantBackupEnum']]]):
        pulumi.set(self, "geo_redundant_backup", value)


if not MYPY:
    class DataEncryptionArgsDict(TypedDict):
        """
        Data encryption properties of a server
        """
        geo_backup_encryption_key_status: NotRequired[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]]
        """
        Geo-backup encryption key status for Data encryption enabled server.
        """
        geo_backup_key_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        URI for the key in keyvault for data encryption for geo-backup of server.
        """
        geo_backup_user_assigned_identity_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource Id for the User assigned identity to be used for data encryption for geo-backup of server.
        """
        primary_encryption_key_status: NotRequired[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]]
        """
        Primary encryption key status for Data encryption enabled server.
        """
        primary_key_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        URI for the key in keyvault for data encryption of the primary server.
        """
        primary_user_assigned_identity_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource Id for the User assigned identity to be used for data encryption of the primary server.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'ArmServerKeyType']]]
        """
        Data encryption type to depict if it is System Managed vs Azure Key vault.
        """
elif False:
    DataEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataEncryptionArgs:
    def __init__(__self__, *,
                 geo_backup_encryption_key_status: Optional[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]] = None,
                 geo_backup_key_uri: Optional[pulumi.Input[builtins.str]] = None,
                 geo_backup_user_assigned_identity_id: Optional[pulumi.Input[builtins.str]] = None,
                 primary_encryption_key_status: Optional[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]] = None,
                 primary_key_uri: Optional[pulumi.Input[builtins.str]] = None,
                 primary_user_assigned_identity_id: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'ArmServerKeyType']]] = None):
        """
        Data encryption properties of a server
        :param pulumi.Input[Union[builtins.str, 'KeyStatusEnum']] geo_backup_encryption_key_status: Geo-backup encryption key status for Data encryption enabled server.
        :param pulumi.Input[builtins.str] geo_backup_key_uri: URI for the key in keyvault for data encryption for geo-backup of server.
        :param pulumi.Input[builtins.str] geo_backup_user_assigned_identity_id: Resource Id for the User assigned identity to be used for data encryption for geo-backup of server.
        :param pulumi.Input[Union[builtins.str, 'KeyStatusEnum']] primary_encryption_key_status: Primary encryption key status for Data encryption enabled server.
        :param pulumi.Input[builtins.str] primary_key_uri: URI for the key in keyvault for data encryption of the primary server.
        :param pulumi.Input[builtins.str] primary_user_assigned_identity_id: Resource Id for the User assigned identity to be used for data encryption of the primary server.
        :param pulumi.Input[Union[builtins.str, 'ArmServerKeyType']] type: Data encryption type to depict if it is System Managed vs Azure Key vault.
        """
        if geo_backup_encryption_key_status is not None:
            pulumi.set(__self__, "geo_backup_encryption_key_status", geo_backup_encryption_key_status)
        if geo_backup_key_uri is not None:
            pulumi.set(__self__, "geo_backup_key_uri", geo_backup_key_uri)
        if geo_backup_user_assigned_identity_id is not None:
            pulumi.set(__self__, "geo_backup_user_assigned_identity_id", geo_backup_user_assigned_identity_id)
        if primary_encryption_key_status is not None:
            pulumi.set(__self__, "primary_encryption_key_status", primary_encryption_key_status)
        if primary_key_uri is not None:
            pulumi.set(__self__, "primary_key_uri", primary_key_uri)
        if primary_user_assigned_identity_id is not None:
            pulumi.set(__self__, "primary_user_assigned_identity_id", primary_user_assigned_identity_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="geoBackupEncryptionKeyStatus")
    def geo_backup_encryption_key_status(self) -> Optional[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]]:
        """
        Geo-backup encryption key status for Data encryption enabled server.
        """
        return pulumi.get(self, "geo_backup_encryption_key_status")

    @geo_backup_encryption_key_status.setter
    def geo_backup_encryption_key_status(self, value: Optional[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]]):
        pulumi.set(self, "geo_backup_encryption_key_status", value)

    @property
    @pulumi.getter(name="geoBackupKeyURI")
    def geo_backup_key_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI for the key in keyvault for data encryption for geo-backup of server.
        """
        return pulumi.get(self, "geo_backup_key_uri")

    @geo_backup_key_uri.setter
    def geo_backup_key_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "geo_backup_key_uri", value)

    @property
    @pulumi.getter(name="geoBackupUserAssignedIdentityId")
    def geo_backup_user_assigned_identity_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource Id for the User assigned identity to be used for data encryption for geo-backup of server.
        """
        return pulumi.get(self, "geo_backup_user_assigned_identity_id")

    @geo_backup_user_assigned_identity_id.setter
    def geo_backup_user_assigned_identity_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "geo_backup_user_assigned_identity_id", value)

    @property
    @pulumi.getter(name="primaryEncryptionKeyStatus")
    def primary_encryption_key_status(self) -> Optional[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]]:
        """
        Primary encryption key status for Data encryption enabled server.
        """
        return pulumi.get(self, "primary_encryption_key_status")

    @primary_encryption_key_status.setter
    def primary_encryption_key_status(self, value: Optional[pulumi.Input[Union[builtins.str, 'KeyStatusEnum']]]):
        pulumi.set(self, "primary_encryption_key_status", value)

    @property
    @pulumi.getter(name="primaryKeyURI")
    def primary_key_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI for the key in keyvault for data encryption of the primary server.
        """
        return pulumi.get(self, "primary_key_uri")

    @primary_key_uri.setter
    def primary_key_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "primary_key_uri", value)

    @property
    @pulumi.getter(name="primaryUserAssignedIdentityId")
    def primary_user_assigned_identity_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource Id for the User assigned identity to be used for data encryption of the primary server.
        """
        return pulumi.get(self, "primary_user_assigned_identity_id")

    @primary_user_assigned_identity_id.setter
    def primary_user_assigned_identity_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "primary_user_assigned_identity_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ArmServerKeyType']]]:
        """
        Data encryption type to depict if it is System Managed vs Azure Key vault.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ArmServerKeyType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HighAvailabilityArgsDict(TypedDict):
        """
        High availability properties of a server
        """
        mode: NotRequired[pulumi.Input[Union[builtins.str, 'HighAvailabilityMode']]]
        """
        The HA mode for the server.
        """
        standby_availability_zone: NotRequired[pulumi.Input[builtins.str]]
        """
        availability zone information of the standby.
        """
elif False:
    HighAvailabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HighAvailabilityArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[Union[builtins.str, 'HighAvailabilityMode']]] = None,
                 standby_availability_zone: Optional[pulumi.Input[builtins.str]] = None):
        """
        High availability properties of a server
        :param pulumi.Input[Union[builtins.str, 'HighAvailabilityMode']] mode: The HA mode for the server.
        :param pulumi.Input[builtins.str] standby_availability_zone: availability zone information of the standby.
        """
        if mode is None:
            mode = 'Disabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if standby_availability_zone is None:
            standby_availability_zone = ''
        if standby_availability_zone is not None:
            pulumi.set(__self__, "standby_availability_zone", standby_availability_zone)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'HighAvailabilityMode']]]:
        """
        The HA mode for the server.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'HighAvailabilityMode']]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="standbyAvailabilityZone")
    def standby_availability_zone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        availability zone information of the standby.
        """
        return pulumi.get(self, "standby_availability_zone")

    @standby_availability_zone.setter
    def standby_availability_zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "standby_availability_zone", value)


if not MYPY:
    class IdentityPropertiesArgsDict(TypedDict):
        """
        Describes the identity of the cluster.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'IdentityType']]]
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    IdentityPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityPropertiesArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[builtins.str, 'IdentityType']]] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Describes the identity of the cluster.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'IdentityType']]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'IdentityType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class MaintenanceWindowArgsDict(TypedDict):
        """
        Maintenance window properties of a server.
        """
        custom_window: NotRequired[pulumi.Input[builtins.str]]
        """
        indicates whether custom window is enabled or disabled
        """
        day_of_week: NotRequired[pulumi.Input[builtins.int]]
        """
        day of week for maintenance window
        """
        start_hour: NotRequired[pulumi.Input[builtins.int]]
        """
        start hour for maintenance window
        """
        start_minute: NotRequired[pulumi.Input[builtins.int]]
        """
        start minute for maintenance window
        """
elif False:
    MaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_window: Optional[pulumi.Input[builtins.str]] = None,
                 day_of_week: Optional[pulumi.Input[builtins.int]] = None,
                 start_hour: Optional[pulumi.Input[builtins.int]] = None,
                 start_minute: Optional[pulumi.Input[builtins.int]] = None):
        """
        Maintenance window properties of a server.
        :param pulumi.Input[builtins.str] custom_window: indicates whether custom window is enabled or disabled
        :param pulumi.Input[builtins.int] day_of_week: day of week for maintenance window
        :param pulumi.Input[builtins.int] start_hour: start hour for maintenance window
        :param pulumi.Input[builtins.int] start_minute: start minute for maintenance window
        """
        if custom_window is None:
            custom_window = 'Disabled'
        if custom_window is not None:
            pulumi.set(__self__, "custom_window", custom_window)
        if day_of_week is None:
            day_of_week = 0
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if start_hour is None:
            start_hour = 0
        if start_hour is not None:
            pulumi.set(__self__, "start_hour", start_hour)
        if start_minute is None:
            start_minute = 0
        if start_minute is not None:
            pulumi.set(__self__, "start_minute", start_minute)

    @property
    @pulumi.getter(name="customWindow")
    def custom_window(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        indicates whether custom window is enabled or disabled
        """
        return pulumi.get(self, "custom_window")

    @custom_window.setter
    def custom_window(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_window", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        day of week for maintenance window
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        start hour for maintenance window
        """
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start_hour", value)

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        start minute for maintenance window
        """
        return pulumi.get(self, "start_minute")

    @start_minute.setter
    def start_minute(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start_minute", value)


if not MYPY:
    class MigrationSecretParametersArgsDict(TypedDict):
        """
        Migration secret parameters.
        """
        admin_credentials: pulumi.Input['AdminCredentialsArgsDict']
        """
        Admin credentials for source and target servers
        """
        source_server_username: NotRequired[pulumi.Input[builtins.str]]
        """
        Gets or sets the username for the source server. This user need not be an admin.
        """
        target_server_username: NotRequired[pulumi.Input[builtins.str]]
        """
        Gets or sets the username for the target server. This user need not be an admin.
        """
elif False:
    MigrationSecretParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MigrationSecretParametersArgs:
    def __init__(__self__, *,
                 admin_credentials: pulumi.Input['AdminCredentialsArgs'],
                 source_server_username: Optional[pulumi.Input[builtins.str]] = None,
                 target_server_username: Optional[pulumi.Input[builtins.str]] = None):
        """
        Migration secret parameters.
        :param pulumi.Input['AdminCredentialsArgs'] admin_credentials: Admin credentials for source and target servers
        :param pulumi.Input[builtins.str] source_server_username: Gets or sets the username for the source server. This user need not be an admin.
        :param pulumi.Input[builtins.str] target_server_username: Gets or sets the username for the target server. This user need not be an admin.
        """
        pulumi.set(__self__, "admin_credentials", admin_credentials)
        if source_server_username is not None:
            pulumi.set(__self__, "source_server_username", source_server_username)
        if target_server_username is not None:
            pulumi.set(__self__, "target_server_username", target_server_username)

    @property
    @pulumi.getter(name="adminCredentials")
    def admin_credentials(self) -> pulumi.Input['AdminCredentialsArgs']:
        """
        Admin credentials for source and target servers
        """
        return pulumi.get(self, "admin_credentials")

    @admin_credentials.setter
    def admin_credentials(self, value: pulumi.Input['AdminCredentialsArgs']):
        pulumi.set(self, "admin_credentials", value)

    @property
    @pulumi.getter(name="sourceServerUsername")
    def source_server_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Gets or sets the username for the source server. This user need not be an admin.
        """
        return pulumi.get(self, "source_server_username")

    @source_server_username.setter
    def source_server_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_server_username", value)

    @property
    @pulumi.getter(name="targetServerUsername")
    def target_server_username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Gets or sets the username for the target server. This user need not be an admin.
        """
        return pulumi.get(self, "target_server_username")

    @target_server_username.setter
    def target_server_username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target_server_username", value)


if not MYPY:
    class NetworkArgsDict(TypedDict):
        """
        Network properties of a server.
        """
        delegated_subnet_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Delegated subnet arm resource id. This is required to be passed during create, in case we want the server to be VNET injected, i.e. Private access server. During update, pass this only if we want to update the value for Private DNS zone.
        """
        private_dns_zone_arm_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Private dns zone arm resource id. This is required to be passed during create, in case we want the server to be VNET injected, i.e. Private access server. During update, pass this only if we want to update the value for Private DNS zone.
        """
        public_network_access: NotRequired[pulumi.Input[Union[builtins.str, 'ServerPublicNetworkAccessState']]]
        """
        public network access is enabled or not
        """
elif False:
    NetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkArgs:
    def __init__(__self__, *,
                 delegated_subnet_resource_id: Optional[pulumi.Input[builtins.str]] = None,
                 private_dns_zone_arm_resource_id: Optional[pulumi.Input[builtins.str]] = None,
                 public_network_access: Optional[pulumi.Input[Union[builtins.str, 'ServerPublicNetworkAccessState']]] = None):
        """
        Network properties of a server.
        :param pulumi.Input[builtins.str] delegated_subnet_resource_id: Delegated subnet arm resource id. This is required to be passed during create, in case we want the server to be VNET injected, i.e. Private access server. During update, pass this only if we want to update the value for Private DNS zone.
        :param pulumi.Input[builtins.str] private_dns_zone_arm_resource_id: Private dns zone arm resource id. This is required to be passed during create, in case we want the server to be VNET injected, i.e. Private access server. During update, pass this only if we want to update the value for Private DNS zone.
        :param pulumi.Input[Union[builtins.str, 'ServerPublicNetworkAccessState']] public_network_access: public network access is enabled or not
        """
        if delegated_subnet_resource_id is not None:
            pulumi.set(__self__, "delegated_subnet_resource_id", delegated_subnet_resource_id)
        if private_dns_zone_arm_resource_id is not None:
            pulumi.set(__self__, "private_dns_zone_arm_resource_id", private_dns_zone_arm_resource_id)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)

    @property
    @pulumi.getter(name="delegatedSubnetResourceId")
    def delegated_subnet_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Delegated subnet arm resource id. This is required to be passed during create, in case we want the server to be VNET injected, i.e. Private access server. During update, pass this only if we want to update the value for Private DNS zone.
        """
        return pulumi.get(self, "delegated_subnet_resource_id")

    @delegated_subnet_resource_id.setter
    def delegated_subnet_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delegated_subnet_resource_id", value)

    @property
    @pulumi.getter(name="privateDnsZoneArmResourceId")
    def private_dns_zone_arm_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Private dns zone arm resource id. This is required to be passed during create, in case we want the server to be VNET injected, i.e. Private access server. During update, pass this only if we want to update the value for Private DNS zone.
        """
        return pulumi.get(self, "private_dns_zone_arm_resource_id")

    @private_dns_zone_arm_resource_id.setter
    def private_dns_zone_arm_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_dns_zone_arm_resource_id", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[builtins.str, 'ServerPublicNetworkAccessState']]]:
        """
        public network access is enabled or not
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[builtins.str, 'ServerPublicNetworkAccessState']]]):
        pulumi.set(self, "public_network_access", value)


if not MYPY:
    class PrivateLinkServiceConnectionStateArgsDict(TypedDict):
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        actions_required: NotRequired[pulumi.Input[builtins.str]]
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The reason for approval/rejection of the connection.
        """
        status: NotRequired[pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']]]
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
elif False:
    PrivateLinkServiceConnectionStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateLinkServiceConnectionStateArgs:
    def __init__(__self__, *,
                 actions_required: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']]] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param pulumi.Input[builtins.str] actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param pulumi.Input[builtins.str] description: The reason for approval/rejection of the connection.
        :param pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']] status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @actions_required.setter
    def actions_required(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "actions_required", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']]]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ReplicaArgsDict(TypedDict):
        """
        Replica properties of a server
        """
        promote_mode: NotRequired[pulumi.Input[Union[builtins.str, 'ReadReplicaPromoteMode']]]
        """
        Sets the promote mode for a replica server. This is a write only property.
        """
        promote_option: NotRequired[pulumi.Input[Union[builtins.str, 'ReplicationPromoteOption']]]
        """
        Sets the promote options for a replica server. This is a write only property.
        """
        role: NotRequired[pulumi.Input[Union[builtins.str, 'ReplicationRole']]]
        """
        Used to indicate role of the server in replication set.
        """
elif False:
    ReplicaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicaArgs:
    def __init__(__self__, *,
                 promote_mode: Optional[pulumi.Input[Union[builtins.str, 'ReadReplicaPromoteMode']]] = None,
                 promote_option: Optional[pulumi.Input[Union[builtins.str, 'ReplicationPromoteOption']]] = None,
                 role: Optional[pulumi.Input[Union[builtins.str, 'ReplicationRole']]] = None):
        """
        Replica properties of a server
        :param pulumi.Input[Union[builtins.str, 'ReadReplicaPromoteMode']] promote_mode: Sets the promote mode for a replica server. This is a write only property.
        :param pulumi.Input[Union[builtins.str, 'ReplicationPromoteOption']] promote_option: Sets the promote options for a replica server. This is a write only property.
        :param pulumi.Input[Union[builtins.str, 'ReplicationRole']] role: Used to indicate role of the server in replication set.
        """
        if promote_mode is not None:
            pulumi.set(__self__, "promote_mode", promote_mode)
        if promote_option is not None:
            pulumi.set(__self__, "promote_option", promote_option)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="promoteMode")
    def promote_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'ReadReplicaPromoteMode']]]:
        """
        Sets the promote mode for a replica server. This is a write only property.
        """
        return pulumi.get(self, "promote_mode")

    @promote_mode.setter
    def promote_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'ReadReplicaPromoteMode']]]):
        pulumi.set(self, "promote_mode", value)

    @property
    @pulumi.getter(name="promoteOption")
    def promote_option(self) -> Optional[pulumi.Input[Union[builtins.str, 'ReplicationPromoteOption']]]:
        """
        Sets the promote options for a replica server. This is a write only property.
        """
        return pulumi.get(self, "promote_option")

    @promote_option.setter
    def promote_option(self, value: Optional[pulumi.Input[Union[builtins.str, 'ReplicationPromoteOption']]]):
        pulumi.set(self, "promote_option", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[Union[builtins.str, 'ReplicationRole']]]:
        """
        Used to indicate role of the server in replication set.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[Union[builtins.str, 'ReplicationRole']]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class ResourceIdentityArgsDict(TypedDict):
        """
        Azure Active Directory identity configuration for a resource.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'SingleServerIdentityProperties']]]
        """
        The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
        """
elif False:
    ResourceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[builtins.str, 'SingleServerIdentityProperties']]] = None):
        """
        Azure Active Directory identity configuration for a resource.
        :param pulumi.Input[Union[builtins.str, 'SingleServerIdentityProperties']] type: The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'SingleServerIdentityProperties']]]:
        """
        The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'SingleServerIdentityProperties']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServerGroupClusterAuthConfigArgsDict(TypedDict):
        """
        Authentication configuration of a cluster.
        """
        active_directory_auth: NotRequired[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuth']]]
        password_auth: NotRequired[pulumi.Input[Union[builtins.str, 'PasswordAuth']]]
elif False:
    ServerGroupClusterAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerGroupClusterAuthConfigArgs:
    def __init__(__self__, *,
                 active_directory_auth: Optional[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuth']]] = None,
                 password_auth: Optional[pulumi.Input[Union[builtins.str, 'PasswordAuth']]] = None):
        """
        Authentication configuration of a cluster.
        """
        if active_directory_auth is not None:
            pulumi.set(__self__, "active_directory_auth", active_directory_auth)
        if password_auth is not None:
            pulumi.set(__self__, "password_auth", password_auth)

    @property
    @pulumi.getter(name="activeDirectoryAuth")
    def active_directory_auth(self) -> Optional[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuth']]]:
        return pulumi.get(self, "active_directory_auth")

    @active_directory_auth.setter
    def active_directory_auth(self, value: Optional[pulumi.Input[Union[builtins.str, 'ActiveDirectoryAuth']]]):
        pulumi.set(self, "active_directory_auth", value)

    @property
    @pulumi.getter(name="passwordAuth")
    def password_auth(self) -> Optional[pulumi.Input[Union[builtins.str, 'PasswordAuth']]]:
        return pulumi.get(self, "password_auth")

    @password_auth.setter
    def password_auth(self, value: Optional[pulumi.Input[Union[builtins.str, 'PasswordAuth']]]):
        pulumi.set(self, "password_auth", value)


if not MYPY:
    class ServerGroupClusterDataEncryptionArgsDict(TypedDict):
        """
        The data encryption properties of a cluster.
        """
        primary_key_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        URI for the key in keyvault for data encryption of the primary server.
        """
        primary_user_assigned_identity_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource Id for the User assigned identity to be used for data encryption of the primary server.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'DataEncryptionType']]]
elif False:
    ServerGroupClusterDataEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerGroupClusterDataEncryptionArgs:
    def __init__(__self__, *,
                 primary_key_uri: Optional[pulumi.Input[builtins.str]] = None,
                 primary_user_assigned_identity_id: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'DataEncryptionType']]] = None):
        """
        The data encryption properties of a cluster.
        :param pulumi.Input[builtins.str] primary_key_uri: URI for the key in keyvault for data encryption of the primary server.
        :param pulumi.Input[builtins.str] primary_user_assigned_identity_id: Resource Id for the User assigned identity to be used for data encryption of the primary server.
        """
        if primary_key_uri is not None:
            pulumi.set(__self__, "primary_key_uri", primary_key_uri)
        if primary_user_assigned_identity_id is not None:
            pulumi.set(__self__, "primary_user_assigned_identity_id", primary_user_assigned_identity_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="primaryKeyUri")
    def primary_key_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URI for the key in keyvault for data encryption of the primary server.
        """
        return pulumi.get(self, "primary_key_uri")

    @primary_key_uri.setter
    def primary_key_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "primary_key_uri", value)

    @property
    @pulumi.getter(name="primaryUserAssignedIdentityId")
    def primary_user_assigned_identity_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource Id for the User assigned identity to be used for data encryption of the primary server.
        """
        return pulumi.get(self, "primary_user_assigned_identity_id")

    @primary_user_assigned_identity_id.setter
    def primary_user_assigned_identity_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "primary_user_assigned_identity_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'DataEncryptionType']]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'DataEncryptionType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServerGroupClusterMaintenanceWindowArgsDict(TypedDict):
        """
        Schedule settings for regular cluster updates.
        """
        custom_window: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates whether custom maintenance window is enabled or not.
        """
        day_of_week: NotRequired[pulumi.Input[builtins.int]]
        """
        Preferred day of the week for maintenance window.
        """
        start_hour: NotRequired[pulumi.Input[builtins.int]]
        """
        Start hour within preferred day of the week for maintenance window.
        """
        start_minute: NotRequired[pulumi.Input[builtins.int]]
        """
        Start minute within the start hour for maintenance window.
        """
elif False:
    ServerGroupClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerGroupClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 custom_window: Optional[pulumi.Input[builtins.str]] = None,
                 day_of_week: Optional[pulumi.Input[builtins.int]] = None,
                 start_hour: Optional[pulumi.Input[builtins.int]] = None,
                 start_minute: Optional[pulumi.Input[builtins.int]] = None):
        """
        Schedule settings for regular cluster updates.
        :param pulumi.Input[builtins.str] custom_window: Indicates whether custom maintenance window is enabled or not.
        :param pulumi.Input[builtins.int] day_of_week: Preferred day of the week for maintenance window.
        :param pulumi.Input[builtins.int] start_hour: Start hour within preferred day of the week for maintenance window.
        :param pulumi.Input[builtins.int] start_minute: Start minute within the start hour for maintenance window.
        """
        if custom_window is not None:
            pulumi.set(__self__, "custom_window", custom_window)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if start_hour is not None:
            pulumi.set(__self__, "start_hour", start_hour)
        if start_minute is not None:
            pulumi.set(__self__, "start_minute", start_minute)

    @property
    @pulumi.getter(name="customWindow")
    def custom_window(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates whether custom maintenance window is enabled or not.
        """
        return pulumi.get(self, "custom_window")

    @custom_window.setter
    def custom_window(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_window", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Preferred day of the week for maintenance window.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Start hour within preferred day of the week for maintenance window.
        """
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start_hour", value)

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Start minute within the start hour for maintenance window.
        """
        return pulumi.get(self, "start_minute")

    @start_minute.setter
    def start_minute(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start_minute", value)


if not MYPY:
    class ServerPropertiesForDefaultCreateArgsDict(TypedDict):
        """
        The properties used to create a new server.
        """
        administrator_login: pulumi.Input[builtins.str]
        """
        The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
        """
        administrator_login_password: pulumi.Input[builtins.str]
        """
        The password of the administrator login.
        """
        create_mode: pulumi.Input[builtins.str]
        """
        The mode to create a new server.
        Expected value is 'Default'.
        """
        infrastructure_encryption: NotRequired[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        minimal_tls_version: NotRequired[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]
        """
        Enforce a minimal Tls version for the server.
        """
        public_network_access: NotRequired[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        ssl_enforcement: NotRequired[pulumi.Input['SslEnforcementEnum']]
        """
        Enable ssl enforcement or not when connect to server.
        """
        storage_profile: NotRequired[pulumi.Input['StorageProfileArgsDict']]
        """
        Storage profile of a server.
        """
        version: NotRequired[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]
        """
        Server version.
        """
elif False:
    ServerPropertiesForDefaultCreateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerPropertiesForDefaultCreateArgs:
    def __init__(__self__, *,
                 administrator_login: pulumi.Input[builtins.str],
                 administrator_login_password: pulumi.Input[builtins.str],
                 create_mode: pulumi.Input[builtins.str],
                 infrastructure_encryption: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]] = None,
                 minimal_tls_version: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]] = None,
                 public_network_access: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]] = None,
                 ssl_enforcement: Optional[pulumi.Input['SslEnforcementEnum']] = None,
                 storage_profile: Optional[pulumi.Input['StorageProfileArgs']] = None,
                 version: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]] = None):
        """
        The properties used to create a new server.
        :param pulumi.Input[builtins.str] administrator_login: The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
        :param pulumi.Input[builtins.str] administrator_login_password: The password of the administrator login.
        :param pulumi.Input[builtins.str] create_mode: The mode to create a new server.
               Expected value is 'Default'.
        :param pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']] infrastructure_encryption: Status showing whether the server enabled infrastructure encryption.
        :param pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']] minimal_tls_version: Enforce a minimal Tls version for the server.
        :param pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']] public_network_access: Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        :param pulumi.Input['SslEnforcementEnum'] ssl_enforcement: Enable ssl enforcement or not when connect to server.
        :param pulumi.Input['StorageProfileArgs'] storage_profile: Storage profile of a server.
        :param pulumi.Input[Union[builtins.str, 'SingleServerVersion']] version: Server version.
        """
        pulumi.set(__self__, "administrator_login", administrator_login)
        pulumi.set(__self__, "administrator_login_password", administrator_login_password)
        pulumi.set(__self__, "create_mode", 'Default')
        if infrastructure_encryption is not None:
            pulumi.set(__self__, "infrastructure_encryption", infrastructure_encryption)
        if minimal_tls_version is not None:
            pulumi.set(__self__, "minimal_tls_version", minimal_tls_version)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if ssl_enforcement is not None:
            pulumi.set(__self__, "ssl_enforcement", ssl_enforcement)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="administratorLogin")
    def administrator_login(self) -> pulumi.Input[builtins.str]:
        """
        The administrator's login name of a server. Can only be specified when the server is being created (and is required for creation).
        """
        return pulumi.get(self, "administrator_login")

    @administrator_login.setter
    def administrator_login(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "administrator_login", value)

    @property
    @pulumi.getter(name="administratorLoginPassword")
    def administrator_login_password(self) -> pulumi.Input[builtins.str]:
        """
        The password of the administrator login.
        """
        return pulumi.get(self, "administrator_login_password")

    @administrator_login_password.setter
    def administrator_login_password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "administrator_login_password", value)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> pulumi.Input[builtins.str]:
        """
        The mode to create a new server.
        Expected value is 'Default'.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="infrastructureEncryption")
    def infrastructure_encryption(self) -> Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]:
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        return pulumi.get(self, "infrastructure_encryption")

    @infrastructure_encryption.setter
    def infrastructure_encryption(self, value: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]):
        pulumi.set(self, "infrastructure_encryption", value)

    @property
    @pulumi.getter(name="minimalTlsVersion")
    def minimal_tls_version(self) -> Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]:
        """
        Enforce a minimal Tls version for the server.
        """
        return pulumi.get(self, "minimal_tls_version")

    @minimal_tls_version.setter
    def minimal_tls_version(self, value: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]):
        pulumi.set(self, "minimal_tls_version", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]:
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]):
        pulumi.set(self, "public_network_access", value)

    @property
    @pulumi.getter(name="sslEnforcement")
    def ssl_enforcement(self) -> Optional[pulumi.Input['SslEnforcementEnum']]:
        """
        Enable ssl enforcement or not when connect to server.
        """
        return pulumi.get(self, "ssl_enforcement")

    @ssl_enforcement.setter
    def ssl_enforcement(self, value: Optional[pulumi.Input['SslEnforcementEnum']]):
        pulumi.set(self, "ssl_enforcement", value)

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[pulumi.Input['StorageProfileArgs']]:
        """
        Storage profile of a server.
        """
        return pulumi.get(self, "storage_profile")

    @storage_profile.setter
    def storage_profile(self, value: Optional[pulumi.Input['StorageProfileArgs']]):
        pulumi.set(self, "storage_profile", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]:
        """
        Server version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ServerPropertiesForGeoRestoreArgsDict(TypedDict):
        """
        The properties used to create a new server by restoring to a different region from a geo replicated backup.
        """
        create_mode: pulumi.Input[builtins.str]
        """
        The mode to create a new server.
        Expected value is 'GeoRestore'.
        """
        source_server_id: pulumi.Input[builtins.str]
        """
        The source server id to restore from.
        """
        infrastructure_encryption: NotRequired[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        minimal_tls_version: NotRequired[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]
        """
        Enforce a minimal Tls version for the server.
        """
        public_network_access: NotRequired[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        ssl_enforcement: NotRequired[pulumi.Input['SslEnforcementEnum']]
        """
        Enable ssl enforcement or not when connect to server.
        """
        storage_profile: NotRequired[pulumi.Input['StorageProfileArgsDict']]
        """
        Storage profile of a server.
        """
        version: NotRequired[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]
        """
        Server version.
        """
elif False:
    ServerPropertiesForGeoRestoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerPropertiesForGeoRestoreArgs:
    def __init__(__self__, *,
                 create_mode: pulumi.Input[builtins.str],
                 source_server_id: pulumi.Input[builtins.str],
                 infrastructure_encryption: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]] = None,
                 minimal_tls_version: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]] = None,
                 public_network_access: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]] = None,
                 ssl_enforcement: Optional[pulumi.Input['SslEnforcementEnum']] = None,
                 storage_profile: Optional[pulumi.Input['StorageProfileArgs']] = None,
                 version: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]] = None):
        """
        The properties used to create a new server by restoring to a different region from a geo replicated backup.
        :param pulumi.Input[builtins.str] create_mode: The mode to create a new server.
               Expected value is 'GeoRestore'.
        :param pulumi.Input[builtins.str] source_server_id: The source server id to restore from.
        :param pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']] infrastructure_encryption: Status showing whether the server enabled infrastructure encryption.
        :param pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']] minimal_tls_version: Enforce a minimal Tls version for the server.
        :param pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']] public_network_access: Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        :param pulumi.Input['SslEnforcementEnum'] ssl_enforcement: Enable ssl enforcement or not when connect to server.
        :param pulumi.Input['StorageProfileArgs'] storage_profile: Storage profile of a server.
        :param pulumi.Input[Union[builtins.str, 'SingleServerVersion']] version: Server version.
        """
        pulumi.set(__self__, "create_mode", 'GeoRestore')
        pulumi.set(__self__, "source_server_id", source_server_id)
        if infrastructure_encryption is not None:
            pulumi.set(__self__, "infrastructure_encryption", infrastructure_encryption)
        if minimal_tls_version is not None:
            pulumi.set(__self__, "minimal_tls_version", minimal_tls_version)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if ssl_enforcement is not None:
            pulumi.set(__self__, "ssl_enforcement", ssl_enforcement)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> pulumi.Input[builtins.str]:
        """
        The mode to create a new server.
        Expected value is 'GeoRestore'.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="sourceServerId")
    def source_server_id(self) -> pulumi.Input[builtins.str]:
        """
        The source server id to restore from.
        """
        return pulumi.get(self, "source_server_id")

    @source_server_id.setter
    def source_server_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_server_id", value)

    @property
    @pulumi.getter(name="infrastructureEncryption")
    def infrastructure_encryption(self) -> Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]:
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        return pulumi.get(self, "infrastructure_encryption")

    @infrastructure_encryption.setter
    def infrastructure_encryption(self, value: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]):
        pulumi.set(self, "infrastructure_encryption", value)

    @property
    @pulumi.getter(name="minimalTlsVersion")
    def minimal_tls_version(self) -> Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]:
        """
        Enforce a minimal Tls version for the server.
        """
        return pulumi.get(self, "minimal_tls_version")

    @minimal_tls_version.setter
    def minimal_tls_version(self, value: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]):
        pulumi.set(self, "minimal_tls_version", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]:
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]):
        pulumi.set(self, "public_network_access", value)

    @property
    @pulumi.getter(name="sslEnforcement")
    def ssl_enforcement(self) -> Optional[pulumi.Input['SslEnforcementEnum']]:
        """
        Enable ssl enforcement or not when connect to server.
        """
        return pulumi.get(self, "ssl_enforcement")

    @ssl_enforcement.setter
    def ssl_enforcement(self, value: Optional[pulumi.Input['SslEnforcementEnum']]):
        pulumi.set(self, "ssl_enforcement", value)

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[pulumi.Input['StorageProfileArgs']]:
        """
        Storage profile of a server.
        """
        return pulumi.get(self, "storage_profile")

    @storage_profile.setter
    def storage_profile(self, value: Optional[pulumi.Input['StorageProfileArgs']]):
        pulumi.set(self, "storage_profile", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]:
        """
        Server version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ServerPropertiesForReplicaArgsDict(TypedDict):
        """
        The properties to create a new replica.
        """
        create_mode: pulumi.Input[builtins.str]
        """
        The mode to create a new server.
        Expected value is 'Replica'.
        """
        source_server_id: pulumi.Input[builtins.str]
        """
        The master server id to create replica from.
        """
        infrastructure_encryption: NotRequired[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        minimal_tls_version: NotRequired[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]
        """
        Enforce a minimal Tls version for the server.
        """
        public_network_access: NotRequired[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        ssl_enforcement: NotRequired[pulumi.Input['SslEnforcementEnum']]
        """
        Enable ssl enforcement or not when connect to server.
        """
        storage_profile: NotRequired[pulumi.Input['StorageProfileArgsDict']]
        """
        Storage profile of a server.
        """
        version: NotRequired[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]
        """
        Server version.
        """
elif False:
    ServerPropertiesForReplicaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerPropertiesForReplicaArgs:
    def __init__(__self__, *,
                 create_mode: pulumi.Input[builtins.str],
                 source_server_id: pulumi.Input[builtins.str],
                 infrastructure_encryption: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]] = None,
                 minimal_tls_version: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]] = None,
                 public_network_access: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]] = None,
                 ssl_enforcement: Optional[pulumi.Input['SslEnforcementEnum']] = None,
                 storage_profile: Optional[pulumi.Input['StorageProfileArgs']] = None,
                 version: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]] = None):
        """
        The properties to create a new replica.
        :param pulumi.Input[builtins.str] create_mode: The mode to create a new server.
               Expected value is 'Replica'.
        :param pulumi.Input[builtins.str] source_server_id: The master server id to create replica from.
        :param pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']] infrastructure_encryption: Status showing whether the server enabled infrastructure encryption.
        :param pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']] minimal_tls_version: Enforce a minimal Tls version for the server.
        :param pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']] public_network_access: Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        :param pulumi.Input['SslEnforcementEnum'] ssl_enforcement: Enable ssl enforcement or not when connect to server.
        :param pulumi.Input['StorageProfileArgs'] storage_profile: Storage profile of a server.
        :param pulumi.Input[Union[builtins.str, 'SingleServerVersion']] version: Server version.
        """
        pulumi.set(__self__, "create_mode", 'Replica')
        pulumi.set(__self__, "source_server_id", source_server_id)
        if infrastructure_encryption is not None:
            pulumi.set(__self__, "infrastructure_encryption", infrastructure_encryption)
        if minimal_tls_version is not None:
            pulumi.set(__self__, "minimal_tls_version", minimal_tls_version)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if ssl_enforcement is not None:
            pulumi.set(__self__, "ssl_enforcement", ssl_enforcement)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> pulumi.Input[builtins.str]:
        """
        The mode to create a new server.
        Expected value is 'Replica'.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="sourceServerId")
    def source_server_id(self) -> pulumi.Input[builtins.str]:
        """
        The master server id to create replica from.
        """
        return pulumi.get(self, "source_server_id")

    @source_server_id.setter
    def source_server_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_server_id", value)

    @property
    @pulumi.getter(name="infrastructureEncryption")
    def infrastructure_encryption(self) -> Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]:
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        return pulumi.get(self, "infrastructure_encryption")

    @infrastructure_encryption.setter
    def infrastructure_encryption(self, value: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]):
        pulumi.set(self, "infrastructure_encryption", value)

    @property
    @pulumi.getter(name="minimalTlsVersion")
    def minimal_tls_version(self) -> Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]:
        """
        Enforce a minimal Tls version for the server.
        """
        return pulumi.get(self, "minimal_tls_version")

    @minimal_tls_version.setter
    def minimal_tls_version(self, value: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]):
        pulumi.set(self, "minimal_tls_version", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]:
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]):
        pulumi.set(self, "public_network_access", value)

    @property
    @pulumi.getter(name="sslEnforcement")
    def ssl_enforcement(self) -> Optional[pulumi.Input['SslEnforcementEnum']]:
        """
        Enable ssl enforcement or not when connect to server.
        """
        return pulumi.get(self, "ssl_enforcement")

    @ssl_enforcement.setter
    def ssl_enforcement(self, value: Optional[pulumi.Input['SslEnforcementEnum']]):
        pulumi.set(self, "ssl_enforcement", value)

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[pulumi.Input['StorageProfileArgs']]:
        """
        Storage profile of a server.
        """
        return pulumi.get(self, "storage_profile")

    @storage_profile.setter
    def storage_profile(self, value: Optional[pulumi.Input['StorageProfileArgs']]):
        pulumi.set(self, "storage_profile", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]:
        """
        Server version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ServerPropertiesForRestoreArgsDict(TypedDict):
        """
        The properties used to create a new server by restoring from a backup.
        """
        create_mode: pulumi.Input[builtins.str]
        """
        The mode to create a new server.
        Expected value is 'PointInTimeRestore'.
        """
        restore_point_in_time: pulumi.Input[builtins.str]
        """
        Restore point creation time (ISO8601 format), specifying the time to restore from.
        """
        source_server_id: pulumi.Input[builtins.str]
        """
        The source server id to restore from.
        """
        infrastructure_encryption: NotRequired[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        minimal_tls_version: NotRequired[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]
        """
        Enforce a minimal Tls version for the server.
        """
        public_network_access: NotRequired[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        ssl_enforcement: NotRequired[pulumi.Input['SslEnforcementEnum']]
        """
        Enable ssl enforcement or not when connect to server.
        """
        storage_profile: NotRequired[pulumi.Input['StorageProfileArgsDict']]
        """
        Storage profile of a server.
        """
        version: NotRequired[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]
        """
        Server version.
        """
elif False:
    ServerPropertiesForRestoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerPropertiesForRestoreArgs:
    def __init__(__self__, *,
                 create_mode: pulumi.Input[builtins.str],
                 restore_point_in_time: pulumi.Input[builtins.str],
                 source_server_id: pulumi.Input[builtins.str],
                 infrastructure_encryption: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]] = None,
                 minimal_tls_version: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]] = None,
                 public_network_access: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]] = None,
                 ssl_enforcement: Optional[pulumi.Input['SslEnforcementEnum']] = None,
                 storage_profile: Optional[pulumi.Input['StorageProfileArgs']] = None,
                 version: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]] = None):
        """
        The properties used to create a new server by restoring from a backup.
        :param pulumi.Input[builtins.str] create_mode: The mode to create a new server.
               Expected value is 'PointInTimeRestore'.
        :param pulumi.Input[builtins.str] restore_point_in_time: Restore point creation time (ISO8601 format), specifying the time to restore from.
        :param pulumi.Input[builtins.str] source_server_id: The source server id to restore from.
        :param pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']] infrastructure_encryption: Status showing whether the server enabled infrastructure encryption.
        :param pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']] minimal_tls_version: Enforce a minimal Tls version for the server.
        :param pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']] public_network_access: Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        :param pulumi.Input['SslEnforcementEnum'] ssl_enforcement: Enable ssl enforcement or not when connect to server.
        :param pulumi.Input['StorageProfileArgs'] storage_profile: Storage profile of a server.
        :param pulumi.Input[Union[builtins.str, 'SingleServerVersion']] version: Server version.
        """
        pulumi.set(__self__, "create_mode", 'PointInTimeRestore')
        pulumi.set(__self__, "restore_point_in_time", restore_point_in_time)
        pulumi.set(__self__, "source_server_id", source_server_id)
        if infrastructure_encryption is not None:
            pulumi.set(__self__, "infrastructure_encryption", infrastructure_encryption)
        if minimal_tls_version is not None:
            pulumi.set(__self__, "minimal_tls_version", minimal_tls_version)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if ssl_enforcement is not None:
            pulumi.set(__self__, "ssl_enforcement", ssl_enforcement)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> pulumi.Input[builtins.str]:
        """
        The mode to create a new server.
        Expected value is 'PointInTimeRestore'.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="restorePointInTime")
    def restore_point_in_time(self) -> pulumi.Input[builtins.str]:
        """
        Restore point creation time (ISO8601 format), specifying the time to restore from.
        """
        return pulumi.get(self, "restore_point_in_time")

    @restore_point_in_time.setter
    def restore_point_in_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "restore_point_in_time", value)

    @property
    @pulumi.getter(name="sourceServerId")
    def source_server_id(self) -> pulumi.Input[builtins.str]:
        """
        The source server id to restore from.
        """
        return pulumi.get(self, "source_server_id")

    @source_server_id.setter
    def source_server_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_server_id", value)

    @property
    @pulumi.getter(name="infrastructureEncryption")
    def infrastructure_encryption(self) -> Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]:
        """
        Status showing whether the server enabled infrastructure encryption.
        """
        return pulumi.get(self, "infrastructure_encryption")

    @infrastructure_encryption.setter
    def infrastructure_encryption(self, value: Optional[pulumi.Input[Union[builtins.str, 'InfrastructureEncryption']]]):
        pulumi.set(self, "infrastructure_encryption", value)

    @property
    @pulumi.getter(name="minimalTlsVersion")
    def minimal_tls_version(self) -> Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]:
        """
        Enforce a minimal Tls version for the server.
        """
        return pulumi.get(self, "minimal_tls_version")

    @minimal_tls_version.setter
    def minimal_tls_version(self, value: Optional[pulumi.Input[Union[builtins.str, 'MinimalTlsVersionEnum']]]):
        pulumi.set(self, "minimal_tls_version", value)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]:
        """
        Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled' or 'Disabled'
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessEnum']]]):
        pulumi.set(self, "public_network_access", value)

    @property
    @pulumi.getter(name="sslEnforcement")
    def ssl_enforcement(self) -> Optional[pulumi.Input['SslEnforcementEnum']]:
        """
        Enable ssl enforcement or not when connect to server.
        """
        return pulumi.get(self, "ssl_enforcement")

    @ssl_enforcement.setter
    def ssl_enforcement(self, value: Optional[pulumi.Input['SslEnforcementEnum']]):
        pulumi.set(self, "ssl_enforcement", value)

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[pulumi.Input['StorageProfileArgs']]:
        """
        Storage profile of a server.
        """
        return pulumi.get(self, "storage_profile")

    @storage_profile.setter
    def storage_profile(self, value: Optional[pulumi.Input['StorageProfileArgs']]):
        pulumi.set(self, "storage_profile", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]:
        """
        Server version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[Union[builtins.str, 'SingleServerVersion']]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class SingleServerSkuArgsDict(TypedDict):
        """
        Billing information related properties of a server.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
        """
        capacity: NotRequired[pulumi.Input[builtins.int]]
        """
        The scale up/out capacity, representing server's compute units.
        """
        family: NotRequired[pulumi.Input[builtins.str]]
        """
        The family of hardware.
        """
        size: NotRequired[pulumi.Input[builtins.str]]
        """
        The size code, to be interpreted by resource as appropriate.
        """
        tier: NotRequired[pulumi.Input[Union[builtins.str, 'SingleServerSkuTier']]]
        """
        The tier of the particular SKU, e.g. Basic.
        """
elif False:
    SingleServerSkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SingleServerSkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 capacity: Optional[pulumi.Input[builtins.int]] = None,
                 family: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.str]] = None,
                 tier: Optional[pulumi.Input[Union[builtins.str, 'SingleServerSkuTier']]] = None):
        """
        Billing information related properties of a server.
        :param pulumi.Input[builtins.str] name: The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
        :param pulumi.Input[builtins.int] capacity: The scale up/out capacity, representing server's compute units.
        :param pulumi.Input[builtins.str] family: The family of hardware.
        :param pulumi.Input[builtins.str] size: The size code, to be interpreted by resource as appropriate.
        :param pulumi.Input[Union[builtins.str, 'SingleServerSkuTier']] tier: The tier of the particular SKU, e.g. Basic.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The scale up/out capacity, representing server's compute units.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The family of hardware.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The size code, to be interpreted by resource as appropriate.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[Union[builtins.str, 'SingleServerSkuTier']]]:
        """
        The tier of the particular SKU, e.g. Basic.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[Union[builtins.str, 'SingleServerSkuTier']]]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class SkuArgsDict(TypedDict):
        """
        Sku information related properties of a server.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.
        """
        tier: pulumi.Input[Union[builtins.str, 'SkuTier']]
        """
        The tier of the particular SKU, e.g. Burstable.
        """
elif False:
    SkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 tier: pulumi.Input[Union[builtins.str, 'SkuTier']]):
        """
        Sku information related properties of a server.
        :param pulumi.Input[builtins.str] name: The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.
        :param pulumi.Input[Union[builtins.str, 'SkuTier']] tier: The tier of the particular SKU, e.g. Burstable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the sku, typically, tier + family + cores, e.g. Standard_D4s_v3.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tier(self) -> pulumi.Input[Union[builtins.str, 'SkuTier']]:
        """
        The tier of the particular SKU, e.g. Burstable.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: pulumi.Input[Union[builtins.str, 'SkuTier']]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class StorageProfileArgsDict(TypedDict):
        """
        Storage Profile properties of a server
        """
        backup_retention_days: NotRequired[pulumi.Input[builtins.int]]
        """
        Backup retention days for the server.
        """
        geo_redundant_backup: NotRequired[pulumi.Input[Union[builtins.str, 'GeoRedundantBackup']]]
        """
        Enable Geo-redundant or not for server backup.
        """
        storage_autogrow: NotRequired[pulumi.Input[Union[builtins.str, 'StorageAutogrow']]]
        """
        Enable Storage Auto Grow.
        """
        storage_mb: NotRequired[pulumi.Input[builtins.int]]
        """
        Max storage allowed for a server.
        """
elif False:
    StorageProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageProfileArgs:
    def __init__(__self__, *,
                 backup_retention_days: Optional[pulumi.Input[builtins.int]] = None,
                 geo_redundant_backup: Optional[pulumi.Input[Union[builtins.str, 'GeoRedundantBackup']]] = None,
                 storage_autogrow: Optional[pulumi.Input[Union[builtins.str, 'StorageAutogrow']]] = None,
                 storage_mb: Optional[pulumi.Input[builtins.int]] = None):
        """
        Storage Profile properties of a server
        :param pulumi.Input[builtins.int] backup_retention_days: Backup retention days for the server.
        :param pulumi.Input[Union[builtins.str, 'GeoRedundantBackup']] geo_redundant_backup: Enable Geo-redundant or not for server backup.
        :param pulumi.Input[Union[builtins.str, 'StorageAutogrow']] storage_autogrow: Enable Storage Auto Grow.
        :param pulumi.Input[builtins.int] storage_mb: Max storage allowed for a server.
        """
        if backup_retention_days is not None:
            pulumi.set(__self__, "backup_retention_days", backup_retention_days)
        if geo_redundant_backup is not None:
            pulumi.set(__self__, "geo_redundant_backup", geo_redundant_backup)
        if storage_autogrow is not None:
            pulumi.set(__self__, "storage_autogrow", storage_autogrow)
        if storage_mb is not None:
            pulumi.set(__self__, "storage_mb", storage_mb)

    @property
    @pulumi.getter(name="backupRetentionDays")
    def backup_retention_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Backup retention days for the server.
        """
        return pulumi.get(self, "backup_retention_days")

    @backup_retention_days.setter
    def backup_retention_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_retention_days", value)

    @property
    @pulumi.getter(name="geoRedundantBackup")
    def geo_redundant_backup(self) -> Optional[pulumi.Input[Union[builtins.str, 'GeoRedundantBackup']]]:
        """
        Enable Geo-redundant or not for server backup.
        """
        return pulumi.get(self, "geo_redundant_backup")

    @geo_redundant_backup.setter
    def geo_redundant_backup(self, value: Optional[pulumi.Input[Union[builtins.str, 'GeoRedundantBackup']]]):
        pulumi.set(self, "geo_redundant_backup", value)

    @property
    @pulumi.getter(name="storageAutogrow")
    def storage_autogrow(self) -> Optional[pulumi.Input[Union[builtins.str, 'StorageAutogrow']]]:
        """
        Enable Storage Auto Grow.
        """
        return pulumi.get(self, "storage_autogrow")

    @storage_autogrow.setter
    def storage_autogrow(self, value: Optional[pulumi.Input[Union[builtins.str, 'StorageAutogrow']]]):
        pulumi.set(self, "storage_autogrow", value)

    @property
    @pulumi.getter(name="storageMB")
    def storage_mb(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Max storage allowed for a server.
        """
        return pulumi.get(self, "storage_mb")

    @storage_mb.setter
    def storage_mb(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "storage_mb", value)


if not MYPY:
    class StorageArgsDict(TypedDict):
        """
        Storage properties of a server
        """
        auto_grow: NotRequired[pulumi.Input[Union[builtins.str, 'StorageAutoGrow']]]
        """
        Flag to enable / disable Storage Auto grow for flexible server.
        """
        iops: NotRequired[pulumi.Input[builtins.int]]
        """
        Storage tier IOPS quantity. This property is required to be set for storage Type PremiumV2_LRS
        """
        storage_size_gb: NotRequired[pulumi.Input[builtins.int]]
        """
        Max storage allowed for a server.
        """
        throughput: NotRequired[pulumi.Input[builtins.int]]
        """
        Storage throughput for the server. This is required to be set for storage Type PremiumV2_LRS
        """
        tier: NotRequired[pulumi.Input[Union[builtins.str, 'AzureManagedDiskPerformanceTiers']]]
        """
        Name of storage tier for IOPS.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'StorageType']]]
        """
        Storage type for the server. Allowed values are Premium_LRS and PremiumV2_LRS, and default is Premium_LRS if not specified
        """
elif False:
    StorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageArgs:
    def __init__(__self__, *,
                 auto_grow: Optional[pulumi.Input[Union[builtins.str, 'StorageAutoGrow']]] = None,
                 iops: Optional[pulumi.Input[builtins.int]] = None,
                 storage_size_gb: Optional[pulumi.Input[builtins.int]] = None,
                 throughput: Optional[pulumi.Input[builtins.int]] = None,
                 tier: Optional[pulumi.Input[Union[builtins.str, 'AzureManagedDiskPerformanceTiers']]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'StorageType']]] = None):
        """
        Storage properties of a server
        :param pulumi.Input[Union[builtins.str, 'StorageAutoGrow']] auto_grow: Flag to enable / disable Storage Auto grow for flexible server.
        :param pulumi.Input[builtins.int] iops: Storage tier IOPS quantity. This property is required to be set for storage Type PremiumV2_LRS
        :param pulumi.Input[builtins.int] storage_size_gb: Max storage allowed for a server.
        :param pulumi.Input[builtins.int] throughput: Storage throughput for the server. This is required to be set for storage Type PremiumV2_LRS
        :param pulumi.Input[Union[builtins.str, 'AzureManagedDiskPerformanceTiers']] tier: Name of storage tier for IOPS.
        :param pulumi.Input[Union[builtins.str, 'StorageType']] type: Storage type for the server. Allowed values are Premium_LRS and PremiumV2_LRS, and default is Premium_LRS if not specified
        """
        if auto_grow is not None:
            pulumi.set(__self__, "auto_grow", auto_grow)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if storage_size_gb is not None:
            pulumi.set(__self__, "storage_size_gb", storage_size_gb)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="autoGrow")
    def auto_grow(self) -> Optional[pulumi.Input[Union[builtins.str, 'StorageAutoGrow']]]:
        """
        Flag to enable / disable Storage Auto grow for flexible server.
        """
        return pulumi.get(self, "auto_grow")

    @auto_grow.setter
    def auto_grow(self, value: Optional[pulumi.Input[Union[builtins.str, 'StorageAutoGrow']]]):
        pulumi.set(self, "auto_grow", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Storage tier IOPS quantity. This property is required to be set for storage Type PremiumV2_LRS
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="storageSizeGB")
    def storage_size_gb(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Max storage allowed for a server.
        """
        return pulumi.get(self, "storage_size_gb")

    @storage_size_gb.setter
    def storage_size_gb(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "storage_size_gb", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Storage throughput for the server. This is required to be set for storage Type PremiumV2_LRS
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[Union[builtins.str, 'AzureManagedDiskPerformanceTiers']]]:
        """
        Name of storage tier for IOPS.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[Union[builtins.str, 'AzureManagedDiskPerformanceTiers']]]):
        pulumi.set(self, "tier", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'StorageType']]]:
        """
        Storage type for the server. Allowed values are Premium_LRS and PremiumV2_LRS, and default is Premium_LRS if not specified
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'StorageType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class UserAssignedIdentityArgsDict(TypedDict):
        """
        Information describing the identities associated with this application.
        """
        type: pulumi.Input[Union[builtins.str, 'IdentityType']]
        """
        the types of identities associated with this resource
        """
        principal_id: NotRequired[pulumi.Input[builtins.str]]
        """
        the identity principal Id of the server.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityArgsDict']]]]
        """
        represents user assigned identities map.
        """
elif False:
    UserAssignedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserAssignedIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[builtins.str, 'IdentityType']],
                 principal_id: Optional[pulumi.Input[builtins.str]] = None,
                 user_assigned_identities: Optional[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityArgs']]]] = None):
        """
        Information describing the identities associated with this application.
        :param pulumi.Input[Union[builtins.str, 'IdentityType']] type: the types of identities associated with this resource
        :param pulumi.Input[builtins.str] principal_id: the identity principal Id of the server.
        :param pulumi.Input[Mapping[str, pulumi.Input['UserIdentityArgs']]] user_assigned_identities: represents user assigned identities map.
        """
        pulumi.set(__self__, "type", type)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[builtins.str, 'IdentityType']]:
        """
        the types of identities associated with this resource
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[builtins.str, 'IdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        the identity principal Id of the server.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "principal_id", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityArgs']]]]:
        """
        represents user assigned identities map.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['UserIdentityArgs']]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class UserIdentityArgsDict(TypedDict):
        """
        Describes a single user-assigned identity associated with the application.
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        the client identifier of the Service Principal which this identity represents.
        """
        principal_id: NotRequired[pulumi.Input[builtins.str]]
        """
        the object identifier of the Service Principal which this identity represents.
        """
elif False:
    UserIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserIdentityArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 principal_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Describes a single user-assigned identity associated with the application.
        :param pulumi.Input[builtins.str] client_id: the client identifier of the Service Principal which this identity represents.
        :param pulumi.Input[builtins.str] principal_id: the object identifier of the Service Principal which this identity represents.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        the client identifier of the Service Principal which this identity represents.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        the object identifier of the Service Principal which this identity represents.
        """
        return pulumi.get(self, "principal_id")

    @principal_id.setter
    def principal_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "principal_id", value)


