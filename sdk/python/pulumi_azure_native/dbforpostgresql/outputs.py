# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AuthConfigResponse',
    'BackupResponse',
    'DataEncryptionResponse',
    'DbLevelValidationStatusResponse',
    'DbMigrationStatusResponse',
    'DbServerMetadataResponse',
    'HighAvailabilityResponse',
    'IdentityPropertiesResponse',
    'MaintenanceWindowResponse',
    'MigrationStatusResponse',
    'MigrationSubStateDetailsResponse',
    'NetworkResponse',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointPropertyResponse',
    'PrivateEndpointResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'ReplicaResponse',
    'ResourceIdentityResponse',
    'ServerGroupClusterAuthConfigResponse',
    'ServerGroupClusterDataEncryptionResponse',
    'ServerGroupClusterMaintenanceWindowResponse',
    'ServerNameItemResponse',
    'ServerPrivateEndpointConnectionPropertiesResponse',
    'ServerPrivateEndpointConnectionResponse',
    'ServerPrivateLinkServiceConnectionStatePropertyResponse',
    'ServerSkuResponse',
    'SimplePrivateEndpointConnectionResponse',
    'SingleServerSkuResponse',
    'SkuResponse',
    'StorageProfileResponse',
    'StorageResponse',
    'SystemDataResponse',
    'UserAssignedIdentityResponse',
    'UserIdentityResponse',
    'ValidationDetailsResponse',
    'ValidationMessageResponse',
    'ValidationSummaryItemResponse',
]

@pulumi.output_type
class AuthConfigResponse(dict):
    """
    Authentication configuration properties of a flexible server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectoryAuth":
            suggest = "active_directory_auth"
        elif key == "passwordAuth":
            suggest = "password_auth"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_directory_auth: Optional[_builtins.str] = None,
                 password_auth: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        Authentication configuration properties of a flexible server.
        :param _builtins.str active_directory_auth: Indicates if the server supports Microsoft Entra authentication.
        :param _builtins.str password_auth: Indicates if the server supports password based authentication.
        :param _builtins.str tenant_id: Identifier of the tenant of the delegated resource.
        """
        if active_directory_auth is not None:
            pulumi.set(__self__, "active_directory_auth", active_directory_auth)
        if password_auth is None:
            password_auth = 'Enabled'
        if password_auth is not None:
            pulumi.set(__self__, "password_auth", password_auth)
        if tenant_id is None:
            tenant_id = ''
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="activeDirectoryAuth")
    def active_directory_auth(self) -> Optional[_builtins.str]:
        """
        Indicates if the server supports Microsoft Entra authentication.
        """
        return pulumi.get(self, "active_directory_auth")

    @_builtins.property
    @pulumi.getter(name="passwordAuth")
    def password_auth(self) -> Optional[_builtins.str]:
        """
        Indicates if the server supports password based authentication.
        """
        return pulumi.get(self, "password_auth")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the tenant of the delegated resource.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class BackupResponse(dict):
    """
    Backup properties of a flexible server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "earliestRestoreDate":
            suggest = "earliest_restore_date"
        elif key == "backupRetentionDays":
            suggest = "backup_retention_days"
        elif key == "geoRedundantBackup":
            suggest = "geo_redundant_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 earliest_restore_date: _builtins.str,
                 backup_retention_days: Optional[_builtins.int] = None,
                 geo_redundant_backup: Optional[_builtins.str] = None):
        """
        Backup properties of a flexible server.
        :param _builtins.str earliest_restore_date: Earliest restore point time (ISO8601 format) for a flexible server.
        :param _builtins.int backup_retention_days: Backup retention days for the flexible server.
        :param _builtins.str geo_redundant_backup: Indicates if the server is configured to create geographically redundant backups.
        """
        pulumi.set(__self__, "earliest_restore_date", earliest_restore_date)
        if backup_retention_days is None:
            backup_retention_days = 7
        if backup_retention_days is not None:
            pulumi.set(__self__, "backup_retention_days", backup_retention_days)
        if geo_redundant_backup is None:
            geo_redundant_backup = 'Disabled'
        if geo_redundant_backup is not None:
            pulumi.set(__self__, "geo_redundant_backup", geo_redundant_backup)

    @_builtins.property
    @pulumi.getter(name="earliestRestoreDate")
    def earliest_restore_date(self) -> _builtins.str:
        """
        Earliest restore point time (ISO8601 format) for a flexible server.
        """
        return pulumi.get(self, "earliest_restore_date")

    @_builtins.property
    @pulumi.getter(name="backupRetentionDays")
    def backup_retention_days(self) -> Optional[_builtins.int]:
        """
        Backup retention days for the flexible server.
        """
        return pulumi.get(self, "backup_retention_days")

    @_builtins.property
    @pulumi.getter(name="geoRedundantBackup")
    def geo_redundant_backup(self) -> Optional[_builtins.str]:
        """
        Indicates if the server is configured to create geographically redundant backups.
        """
        return pulumi.get(self, "geo_redundant_backup")


@pulumi.output_type
class DataEncryptionResponse(dict):
    """
    Data encryption properties of a flexible server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoBackupEncryptionKeyStatus":
            suggest = "geo_backup_encryption_key_status"
        elif key == "geoBackupKeyURI":
            suggest = "geo_backup_key_uri"
        elif key == "geoBackupUserAssignedIdentityId":
            suggest = "geo_backup_user_assigned_identity_id"
        elif key == "primaryEncryptionKeyStatus":
            suggest = "primary_encryption_key_status"
        elif key == "primaryKeyURI":
            suggest = "primary_key_uri"
        elif key == "primaryUserAssignedIdentityId":
            suggest = "primary_user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataEncryptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataEncryptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataEncryptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 geo_backup_encryption_key_status: Optional[_builtins.str] = None,
                 geo_backup_key_uri: Optional[_builtins.str] = None,
                 geo_backup_user_assigned_identity_id: Optional[_builtins.str] = None,
                 primary_encryption_key_status: Optional[_builtins.str] = None,
                 primary_key_uri: Optional[_builtins.str] = None,
                 primary_user_assigned_identity_id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Data encryption properties of a flexible server.
        :param _builtins.str geo_backup_encryption_key_status: Status of key used by a flexible server configured with data encryption based on customer managed key, to encrypt the geographically redundant storage associated to the server when it is configured to support geographically redundant backups.
        :param _builtins.str geo_backup_key_uri: Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the geographically redundant storage associated to a flexible server that is configured to support geographically redundant backups.
        :param _builtins.str geo_backup_user_assigned_identity_id: Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the geographically redundant storage associated to a flexible server that is configured to support geographically redundant backups.
        :param _builtins.str primary_encryption_key_status: Status of key used by a flexible server configured with data encryption based on customer managed key, to encrypt the primary storage associated to the server.
        :param _builtins.str primary_key_uri: URI of the key in Azure Key Vault used for data encryption of the primary storage associated to a flexible server.
        :param _builtins.str primary_user_assigned_identity_id: Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the primary storage associated to a flexible server.
        :param _builtins.str type: Data encryption type used by a flexible server.
        """
        if geo_backup_encryption_key_status is not None:
            pulumi.set(__self__, "geo_backup_encryption_key_status", geo_backup_encryption_key_status)
        if geo_backup_key_uri is not None:
            pulumi.set(__self__, "geo_backup_key_uri", geo_backup_key_uri)
        if geo_backup_user_assigned_identity_id is not None:
            pulumi.set(__self__, "geo_backup_user_assigned_identity_id", geo_backup_user_assigned_identity_id)
        if primary_encryption_key_status is not None:
            pulumi.set(__self__, "primary_encryption_key_status", primary_encryption_key_status)
        if primary_key_uri is not None:
            pulumi.set(__self__, "primary_key_uri", primary_key_uri)
        if primary_user_assigned_identity_id is not None:
            pulumi.set(__self__, "primary_user_assigned_identity_id", primary_user_assigned_identity_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="geoBackupEncryptionKeyStatus")
    def geo_backup_encryption_key_status(self) -> Optional[_builtins.str]:
        """
        Status of key used by a flexible server configured with data encryption based on customer managed key, to encrypt the geographically redundant storage associated to the server when it is configured to support geographically redundant backups.
        """
        return pulumi.get(self, "geo_backup_encryption_key_status")

    @_builtins.property
    @pulumi.getter(name="geoBackupKeyURI")
    def geo_backup_key_uri(self) -> Optional[_builtins.str]:
        """
        Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the geographically redundant storage associated to a flexible server that is configured to support geographically redundant backups.
        """
        return pulumi.get(self, "geo_backup_key_uri")

    @_builtins.property
    @pulumi.getter(name="geoBackupUserAssignedIdentityId")
    def geo_backup_user_assigned_identity_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the geographically redundant storage associated to a flexible server that is configured to support geographically redundant backups.
        """
        return pulumi.get(self, "geo_backup_user_assigned_identity_id")

    @_builtins.property
    @pulumi.getter(name="primaryEncryptionKeyStatus")
    def primary_encryption_key_status(self) -> Optional[_builtins.str]:
        """
        Status of key used by a flexible server configured with data encryption based on customer managed key, to encrypt the primary storage associated to the server.
        """
        return pulumi.get(self, "primary_encryption_key_status")

    @_builtins.property
    @pulumi.getter(name="primaryKeyURI")
    def primary_key_uri(self) -> Optional[_builtins.str]:
        """
        URI of the key in Azure Key Vault used for data encryption of the primary storage associated to a flexible server.
        """
        return pulumi.get(self, "primary_key_uri")

    @_builtins.property
    @pulumi.getter(name="primaryUserAssignedIdentityId")
    def primary_user_assigned_identity_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the user assigned managed identity used to access the key in Azure Key Vault for data encryption of the primary storage associated to a flexible server.
        """
        return pulumi.get(self, "primary_user_assigned_identity_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Data encryption type used by a flexible server.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DbLevelValidationStatusResponse(dict):
    """
    Validation status summary for a database.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbLevelValidationStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbLevelValidationStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbLevelValidationStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: Optional[_builtins.str] = None,
                 ended_on: Optional[_builtins.str] = None,
                 started_on: Optional[_builtins.str] = None,
                 summary: Optional[Sequence['outputs.ValidationSummaryItemResponse']] = None):
        """
        Validation status summary for a database.
        :param _builtins.str database_name: Name of database.
        :param _builtins.str ended_on: End time of a database level validation.
        :param _builtins.str started_on: Start time of a database level validation.
        :param Sequence['ValidationSummaryItemResponse'] summary: Summary of database level validations.
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)
        if summary is not None:
            pulumi.set(__self__, "summary", summary)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        Name of database.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[_builtins.str]:
        """
        End time of a database level validation.
        """
        return pulumi.get(self, "ended_on")

    @_builtins.property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[_builtins.str]:
        """
        Start time of a database level validation.
        """
        return pulumi.get(self, "started_on")

    @_builtins.property
    @pulumi.getter
    def summary(self) -> Optional[Sequence['outputs.ValidationSummaryItemResponse']]:
        """
        Summary of database level validations.
        """
        return pulumi.get(self, "summary")


@pulumi.output_type
class DbMigrationStatusResponse(dict):
    """
    Migration status of a database.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliedChanges":
            suggest = "applied_changes"
        elif key == "cdcDeleteCounter":
            suggest = "cdc_delete_counter"
        elif key == "cdcInsertCounter":
            suggest = "cdc_insert_counter"
        elif key == "cdcUpdateCounter":
            suggest = "cdc_update_counter"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "endedOn":
            suggest = "ended_on"
        elif key == "fullLoadCompletedTables":
            suggest = "full_load_completed_tables"
        elif key == "fullLoadErroredTables":
            suggest = "full_load_errored_tables"
        elif key == "fullLoadLoadingTables":
            suggest = "full_load_loading_tables"
        elif key == "fullLoadQueuedTables":
            suggest = "full_load_queued_tables"
        elif key == "incomingChanges":
            suggest = "incoming_changes"
        elif key == "migrationOperation":
            suggest = "migration_operation"
        elif key == "migrationState":
            suggest = "migration_state"
        elif key == "startedOn":
            suggest = "started_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbMigrationStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbMigrationStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbMigrationStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applied_changes: Optional[_builtins.int] = None,
                 cdc_delete_counter: Optional[_builtins.int] = None,
                 cdc_insert_counter: Optional[_builtins.int] = None,
                 cdc_update_counter: Optional[_builtins.int] = None,
                 database_name: Optional[_builtins.str] = None,
                 ended_on: Optional[_builtins.str] = None,
                 full_load_completed_tables: Optional[_builtins.int] = None,
                 full_load_errored_tables: Optional[_builtins.int] = None,
                 full_load_loading_tables: Optional[_builtins.int] = None,
                 full_load_queued_tables: Optional[_builtins.int] = None,
                 incoming_changes: Optional[_builtins.int] = None,
                 latency: Optional[_builtins.int] = None,
                 message: Optional[_builtins.str] = None,
                 migration_operation: Optional[_builtins.str] = None,
                 migration_state: Optional[_builtins.str] = None,
                 started_on: Optional[_builtins.str] = None):
        """
        Migration status of a database.
        :param _builtins.int applied_changes: Change Data Capture applied changes counter.
        :param _builtins.int cdc_delete_counter: Change Data Capture delete counter.
        :param _builtins.int cdc_insert_counter: Change Data Capture insert counter.
        :param _builtins.int cdc_update_counter: Change Data Capture update counter.
        :param _builtins.str database_name: Name of database.
        :param _builtins.str ended_on: End time of a migration state.
        :param _builtins.int full_load_completed_tables: Number of tables loaded during the migration of a database.
        :param _builtins.int full_load_errored_tables: Number of tables encountering errors during the migration of a database.
        :param _builtins.int full_load_loading_tables: Number of tables loading during the migration of a database.
        :param _builtins.int full_load_queued_tables: Number of tables queued for the migration of a database.
        :param _builtins.int incoming_changes: Change Data Capture incoming changes counter.
        :param _builtins.int latency: Lag in seconds between source and target during online phase.
        :param _builtins.str message: Error message, if any, for the migration state.
        :param _builtins.str migration_operation: Migration operation of a database.
        :param _builtins.str migration_state: Migration state of a database.
        :param _builtins.str started_on: Start time of a migration state.
        """
        if applied_changes is not None:
            pulumi.set(__self__, "applied_changes", applied_changes)
        if cdc_delete_counter is not None:
            pulumi.set(__self__, "cdc_delete_counter", cdc_delete_counter)
        if cdc_insert_counter is not None:
            pulumi.set(__self__, "cdc_insert_counter", cdc_insert_counter)
        if cdc_update_counter is not None:
            pulumi.set(__self__, "cdc_update_counter", cdc_update_counter)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if ended_on is not None:
            pulumi.set(__self__, "ended_on", ended_on)
        if full_load_completed_tables is not None:
            pulumi.set(__self__, "full_load_completed_tables", full_load_completed_tables)
        if full_load_errored_tables is not None:
            pulumi.set(__self__, "full_load_errored_tables", full_load_errored_tables)
        if full_load_loading_tables is not None:
            pulumi.set(__self__, "full_load_loading_tables", full_load_loading_tables)
        if full_load_queued_tables is not None:
            pulumi.set(__self__, "full_load_queued_tables", full_load_queued_tables)
        if incoming_changes is not None:
            pulumi.set(__self__, "incoming_changes", incoming_changes)
        if latency is not None:
            pulumi.set(__self__, "latency", latency)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if migration_operation is not None:
            pulumi.set(__self__, "migration_operation", migration_operation)
        if migration_state is not None:
            pulumi.set(__self__, "migration_state", migration_state)
        if started_on is not None:
            pulumi.set(__self__, "started_on", started_on)

    @_builtins.property
    @pulumi.getter(name="appliedChanges")
    def applied_changes(self) -> Optional[_builtins.int]:
        """
        Change Data Capture applied changes counter.
        """
        return pulumi.get(self, "applied_changes")

    @_builtins.property
    @pulumi.getter(name="cdcDeleteCounter")
    def cdc_delete_counter(self) -> Optional[_builtins.int]:
        """
        Change Data Capture delete counter.
        """
        return pulumi.get(self, "cdc_delete_counter")

    @_builtins.property
    @pulumi.getter(name="cdcInsertCounter")
    def cdc_insert_counter(self) -> Optional[_builtins.int]:
        """
        Change Data Capture insert counter.
        """
        return pulumi.get(self, "cdc_insert_counter")

    @_builtins.property
    @pulumi.getter(name="cdcUpdateCounter")
    def cdc_update_counter(self) -> Optional[_builtins.int]:
        """
        Change Data Capture update counter.
        """
        return pulumi.get(self, "cdc_update_counter")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        Name of database.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="endedOn")
    def ended_on(self) -> Optional[_builtins.str]:
        """
        End time of a migration state.
        """
        return pulumi.get(self, "ended_on")

    @_builtins.property
    @pulumi.getter(name="fullLoadCompletedTables")
    def full_load_completed_tables(self) -> Optional[_builtins.int]:
        """
        Number of tables loaded during the migration of a database.
        """
        return pulumi.get(self, "full_load_completed_tables")

    @_builtins.property
    @pulumi.getter(name="fullLoadErroredTables")
    def full_load_errored_tables(self) -> Optional[_builtins.int]:
        """
        Number of tables encountering errors during the migration of a database.
        """
        return pulumi.get(self, "full_load_errored_tables")

    @_builtins.property
    @pulumi.getter(name="fullLoadLoadingTables")
    def full_load_loading_tables(self) -> Optional[_builtins.int]:
        """
        Number of tables loading during the migration of a database.
        """
        return pulumi.get(self, "full_load_loading_tables")

    @_builtins.property
    @pulumi.getter(name="fullLoadQueuedTables")
    def full_load_queued_tables(self) -> Optional[_builtins.int]:
        """
        Number of tables queued for the migration of a database.
        """
        return pulumi.get(self, "full_load_queued_tables")

    @_builtins.property
    @pulumi.getter(name="incomingChanges")
    def incoming_changes(self) -> Optional[_builtins.int]:
        """
        Change Data Capture incoming changes counter.
        """
        return pulumi.get(self, "incoming_changes")

    @_builtins.property
    @pulumi.getter
    def latency(self) -> Optional[_builtins.int]:
        """
        Lag in seconds between source and target during online phase.
        """
        return pulumi.get(self, "latency")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Error message, if any, for the migration state.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="migrationOperation")
    def migration_operation(self) -> Optional[_builtins.str]:
        """
        Migration operation of a database.
        """
        return pulumi.get(self, "migration_operation")

    @_builtins.property
    @pulumi.getter(name="migrationState")
    def migration_state(self) -> Optional[_builtins.str]:
        """
        Migration state of a database.
        """
        return pulumi.get(self, "migration_state")

    @_builtins.property
    @pulumi.getter(name="startedOn")
    def started_on(self) -> Optional[_builtins.str]:
        """
        Start time of a migration state.
        """
        return pulumi.get(self, "started_on")


@pulumi.output_type
class DbServerMetadataResponse(dict):
    """
    Database server metadata.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageMb":
            suggest = "storage_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbServerMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbServerMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbServerMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: _builtins.str,
                 sku: Optional['outputs.ServerSkuResponse'] = None,
                 storage_mb: Optional[_builtins.int] = None,
                 version: Optional[_builtins.str] = None):
        """
        Database server metadata.
        :param _builtins.str location: Location of database server.
        :param 'ServerSkuResponse' sku: Compute tier and size of the database server. This object is empty for an Azure Database for PostgreSQL single server.
        :param _builtins.int storage_mb: Storage size (in MB) for database server.
        :param _builtins.str version: Major version of PostgreSQL database engine.
        """
        pulumi.set(__self__, "location", location)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if storage_mb is not None:
            pulumi.set(__self__, "storage_mb", storage_mb)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        Location of database server.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def sku(self) -> Optional['outputs.ServerSkuResponse']:
        """
        Compute tier and size of the database server. This object is empty for an Azure Database for PostgreSQL single server.
        """
        return pulumi.get(self, "sku")

    @_builtins.property
    @pulumi.getter(name="storageMb")
    def storage_mb(self) -> Optional[_builtins.int]:
        """
        Storage size (in MB) for database server.
        """
        return pulumi.get(self, "storage_mb")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Major version of PostgreSQL database engine.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class HighAvailabilityResponse(dict):
    """
    High availability properties of a flexible server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "standbyAvailabilityZone":
            suggest = "standby_availability_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HighAvailabilityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HighAvailabilityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HighAvailabilityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: _builtins.str,
                 mode: Optional[_builtins.str] = None,
                 standby_availability_zone: Optional[_builtins.str] = None):
        """
        High availability properties of a flexible server.
        :param _builtins.str state: Possible states of the standby server created when high availability is set to SameZone or ZoneRedundant.
        :param _builtins.str mode: High availability mode for a flexible server.
        :param _builtins.str standby_availability_zone: Availability zone associated to the standby server created when high availability is set to SameZone or ZoneRedundant.
        """
        pulumi.set(__self__, "state", state)
        if mode is None:
            mode = 'Disabled'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if standby_availability_zone is None:
            standby_availability_zone = ''
        if standby_availability_zone is not None:
            pulumi.set(__self__, "standby_availability_zone", standby_availability_zone)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Possible states of the standby server created when high availability is set to SameZone or ZoneRedundant.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        High availability mode for a flexible server.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="standbyAvailabilityZone")
    def standby_availability_zone(self) -> Optional[_builtins.str]:
        """
        Availability zone associated to the standby server created when high availability is set to SameZone or ZoneRedundant.
        """
        return pulumi.get(self, "standby_availability_zone")


@pulumi.output_type
class IdentityPropertiesResponse(dict):
    """
    Describes the identity of the cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Describes the identity of the cluster.
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MaintenanceWindowResponse(dict):
    """
    Maintenance window properties of a flexible server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customWindow":
            suggest = "custom_window"
        elif key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMinute":
            suggest = "start_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_window: Optional[_builtins.str] = None,
                 day_of_week: Optional[_builtins.int] = None,
                 start_hour: Optional[_builtins.int] = None,
                 start_minute: Optional[_builtins.int] = None):
        """
        Maintenance window properties of a flexible server.
        :param _builtins.str custom_window: Indicates whether custom window is enabled or disabled.
        :param _builtins.int day_of_week: Day of the week to be used for maintenance window.
        :param _builtins.int start_hour: Start hour to be used for maintenance window.
        :param _builtins.int start_minute: Start minute to be used for maintenance window.
        """
        if custom_window is None:
            custom_window = 'Disabled'
        if custom_window is not None:
            pulumi.set(__self__, "custom_window", custom_window)
        if day_of_week is None:
            day_of_week = 0
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if start_hour is None:
            start_hour = 0
        if start_hour is not None:
            pulumi.set(__self__, "start_hour", start_hour)
        if start_minute is None:
            start_minute = 0
        if start_minute is not None:
            pulumi.set(__self__, "start_minute", start_minute)

    @_builtins.property
    @pulumi.getter(name="customWindow")
    def custom_window(self) -> Optional[_builtins.str]:
        """
        Indicates whether custom window is enabled or disabled.
        """
        return pulumi.get(self, "custom_window")

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.int]:
        """
        Day of the week to be used for maintenance window.
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[_builtins.int]:
        """
        Start hour to be used for maintenance window.
        """
        return pulumi.get(self, "start_hour")

    @_builtins.property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> Optional[_builtins.int]:
        """
        Start minute to be used for maintenance window.
        """
        return pulumi.get(self, "start_minute")


@pulumi.output_type
class MigrationStatusResponse(dict):
    """
    State of migration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentSubStateDetails":
            suggest = "current_sub_state_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrationStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrationStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrationStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_sub_state_details: 'outputs.MigrationSubStateDetailsResponse',
                 error: _builtins.str,
                 state: _builtins.str):
        """
        State of migration.
        :param 'MigrationSubStateDetailsResponse' current_sub_state_details: Current migration sub state details.
        :param _builtins.str error: Error message, if any, for the migration state.
        :param _builtins.str state: State of migration.
        """
        pulumi.set(__self__, "current_sub_state_details", current_sub_state_details)
        pulumi.set(__self__, "error", error)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="currentSubStateDetails")
    def current_sub_state_details(self) -> 'outputs.MigrationSubStateDetailsResponse':
        """
        Current migration sub state details.
        """
        return pulumi.get(self, "current_sub_state_details")

    @_builtins.property
    @pulumi.getter
    def error(self) -> _builtins.str:
        """
        Error message, if any, for the migration state.
        """
        return pulumi.get(self, "error")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of migration.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MigrationSubStateDetailsResponse(dict):
    """
    Details of migration substate.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentSubState":
            suggest = "current_sub_state"
        elif key == "dbDetails":
            suggest = "db_details"
        elif key == "validationDetails":
            suggest = "validation_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrationSubStateDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrationSubStateDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrationSubStateDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_sub_state: _builtins.str,
                 db_details: Optional[Mapping[str, 'outputs.DbMigrationStatusResponse']] = None,
                 validation_details: Optional['outputs.ValidationDetailsResponse'] = None):
        """
        Details of migration substate.
        :param _builtins.str current_sub_state: Substate of migration.
        :param 'ValidationDetailsResponse' validation_details: Details for the validation for migration.
        """
        pulumi.set(__self__, "current_sub_state", current_sub_state)
        if db_details is not None:
            pulumi.set(__self__, "db_details", db_details)
        if validation_details is not None:
            pulumi.set(__self__, "validation_details", validation_details)

    @_builtins.property
    @pulumi.getter(name="currentSubState")
    def current_sub_state(self) -> _builtins.str:
        """
        Substate of migration.
        """
        return pulumi.get(self, "current_sub_state")

    @_builtins.property
    @pulumi.getter(name="dbDetails")
    def db_details(self) -> Optional[Mapping[str, 'outputs.DbMigrationStatusResponse']]:
        return pulumi.get(self, "db_details")

    @_builtins.property
    @pulumi.getter(name="validationDetails")
    def validation_details(self) -> Optional['outputs.ValidationDetailsResponse']:
        """
        Details for the validation for migration.
        """
        return pulumi.get(self, "validation_details")


@pulumi.output_type
class NetworkResponse(dict):
    """
    Network properties of a flexible server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delegatedSubnetResourceId":
            suggest = "delegated_subnet_resource_id"
        elif key == "privateDnsZoneArmResourceId":
            suggest = "private_dns_zone_arm_resource_id"
        elif key == "publicNetworkAccess":
            suggest = "public_network_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delegated_subnet_resource_id: Optional[_builtins.str] = None,
                 private_dns_zone_arm_resource_id: Optional[_builtins.str] = None,
                 public_network_access: Optional[_builtins.str] = None):
        """
        Network properties of a flexible server.
        :param _builtins.str delegated_subnet_resource_id: Resource identifier of the delegated subnet. Required during creation of a new server, in case you want the server to be integrated into your own virtual network. For an update operation, you only have to provide this property if you want to change the value assigned for the private DNS zone.
        :param _builtins.str private_dns_zone_arm_resource_id: Identifier of the private DNS zone. Required during creation of a new server, in case you want the server to be integrated into your own virtual network. For an update operation, you only have to provide this property if you want to change the value assigned for the private DNS zone.
        :param _builtins.str public_network_access: Indicates if public network access is enabled or not.
        """
        if delegated_subnet_resource_id is not None:
            pulumi.set(__self__, "delegated_subnet_resource_id", delegated_subnet_resource_id)
        if private_dns_zone_arm_resource_id is not None:
            pulumi.set(__self__, "private_dns_zone_arm_resource_id", private_dns_zone_arm_resource_id)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)

    @_builtins.property
    @pulumi.getter(name="delegatedSubnetResourceId")
    def delegated_subnet_resource_id(self) -> Optional[_builtins.str]:
        """
        Resource identifier of the delegated subnet. Required during creation of a new server, in case you want the server to be integrated into your own virtual network. For an update operation, you only have to provide this property if you want to change the value assigned for the private DNS zone.
        """
        return pulumi.get(self, "delegated_subnet_resource_id")

    @_builtins.property
    @pulumi.getter(name="privateDnsZoneArmResourceId")
    def private_dns_zone_arm_resource_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the private DNS zone. Required during creation of a new server, in case you want the server to be integrated into your own virtual network. For an update operation, you only have to provide this property if you want to change the value assigned for the private DNS zone.
        """
        return pulumi.get(self, "private_dns_zone_arm_resource_id")

    @_builtins.property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[_builtins.str]:
        """
        Indicates if public network access is enabled or not.
        """
        return pulumi.get(self, "public_network_access")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    """
    The private endpoint connection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "systemData":
            suggest = "system_data"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Sequence[_builtins.str],
                 id: _builtins.str,
                 name: _builtins.str,
                 private_link_service_connection_state: 'outputs.PrivateLinkServiceConnectionStateResponse',
                 provisioning_state: _builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: _builtins.str,
                 private_endpoint: Optional['outputs.PrivateEndpointResponse'] = None):
        """
        The private endpoint connection resource.
        :param Sequence[_builtins.str] group_ids: The group ids for the private endpoint resource.
        :param _builtins.str id: Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        :param _builtins.str name: The name of the resource
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: A collection of information about the state of the connection between service consumer and provider.
        :param _builtins.str provisioning_state: The provisioning state of the private endpoint connection resource.
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param _builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'PrivateEndpointResponse' private_endpoint: The private endpoint resource.
        """
        pulumi.set(__self__, "group_ids", group_ids)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)

    @_builtins.property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Sequence[_builtins.str]:
        """
        The group ids for the private endpoint resource.
        """
        return pulumi.get(self, "group_ids")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> 'outputs.PrivateLinkServiceConnectionStateResponse':
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the private endpoint connection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResponse']:
        """
        The private endpoint resource.
        """
        return pulumi.get(self, "private_endpoint")


@pulumi.output_type
class PrivateEndpointPropertyResponse(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Resource id of the private endpoint.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Resource id of the private endpoint.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    The private endpoint resource.
    """
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        The private endpoint resource.
        :param _builtins.str id: The ARM identifier for private endpoint.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ARM identifier for private endpoint.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    A collection of information about the state of the connection between service consumer and provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param _builtins.str actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param _builtins.str description: The reason for approval/rejection of the connection.
        :param _builtins.str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[_builtins.str]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ReplicaResponse(dict):
    """
    Replica properties of a flexible server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicationState":
            suggest = "replication_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity: _builtins.int,
                 replication_state: _builtins.str,
                 role: Optional[_builtins.str] = None):
        """
        Replica properties of a flexible server.
        :param _builtins.int capacity: Maximum number of read replicas allowed for a flexible server.
        :param _builtins.str replication_state: Indicates the replication state of a read replica. This property is returned only when the target flexible server is a read replica. Possible  values are Active, Broken, Catchup, Provisioning, Reconfiguring, and Updating
        :param _builtins.str role: Role of the server in a replication set.
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "replication_state", replication_state)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> _builtins.int:
        """
        Maximum number of read replicas allowed for a flexible server.
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter(name="replicationState")
    def replication_state(self) -> _builtins.str:
        """
        Indicates the replication state of a read replica. This property is returned only when the target flexible server is a read replica. Possible  values are Active, Broken, Catchup, Provisioning, Reconfiguring, and Updating
        """
        return pulumi.get(self, "replication_state")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Role of the server in a replication set.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class ResourceIdentityResponse(dict):
    """
    Azure Active Directory identity configuration for a resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: Optional[_builtins.str] = None):
        """
        Azure Active Directory identity configuration for a resource.
        :param _builtins.str principal_id: The Azure Active Directory principal id.
        :param _builtins.str tenant_id: The Azure Active Directory tenant id.
        :param _builtins.str type: The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The Azure Active Directory principal id.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The Azure Active Directory tenant id.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The identity type. Set this to 'SystemAssigned' in order to automatically create and assign an Azure Active Directory principal for the resource.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServerGroupClusterAuthConfigResponse(dict):
    """
    Authentication configuration of a cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectoryAuth":
            suggest = "active_directory_auth"
        elif key == "passwordAuth":
            suggest = "password_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerGroupClusterAuthConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerGroupClusterAuthConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerGroupClusterAuthConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_directory_auth: Optional[_builtins.str] = None,
                 password_auth: Optional[_builtins.str] = None):
        """
        Authentication configuration of a cluster.
        """
        if active_directory_auth is not None:
            pulumi.set(__self__, "active_directory_auth", active_directory_auth)
        if password_auth is not None:
            pulumi.set(__self__, "password_auth", password_auth)

    @_builtins.property
    @pulumi.getter(name="activeDirectoryAuth")
    def active_directory_auth(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "active_directory_auth")

    @_builtins.property
    @pulumi.getter(name="passwordAuth")
    def password_auth(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "password_auth")


@pulumi.output_type
class ServerGroupClusterDataEncryptionResponse(dict):
    """
    The data encryption properties of a cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryKeyUri":
            suggest = "primary_key_uri"
        elif key == "primaryUserAssignedIdentityId":
            suggest = "primary_user_assigned_identity_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerGroupClusterDataEncryptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerGroupClusterDataEncryptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerGroupClusterDataEncryptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_key_uri: Optional[_builtins.str] = None,
                 primary_user_assigned_identity_id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        The data encryption properties of a cluster.
        :param _builtins.str primary_key_uri: URI for the key in keyvault for data encryption of the primary server.
        :param _builtins.str primary_user_assigned_identity_id: Resource Id for the User assigned identity to be used for data encryption of the primary server.
        """
        if primary_key_uri is not None:
            pulumi.set(__self__, "primary_key_uri", primary_key_uri)
        if primary_user_assigned_identity_id is not None:
            pulumi.set(__self__, "primary_user_assigned_identity_id", primary_user_assigned_identity_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="primaryKeyUri")
    def primary_key_uri(self) -> Optional[_builtins.str]:
        """
        URI for the key in keyvault for data encryption of the primary server.
        """
        return pulumi.get(self, "primary_key_uri")

    @_builtins.property
    @pulumi.getter(name="primaryUserAssignedIdentityId")
    def primary_user_assigned_identity_id(self) -> Optional[_builtins.str]:
        """
        Resource Id for the User assigned identity to be used for data encryption of the primary server.
        """
        return pulumi.get(self, "primary_user_assigned_identity_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ServerGroupClusterMaintenanceWindowResponse(dict):
    """
    Schedule settings for regular cluster updates.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customWindow":
            suggest = "custom_window"
        elif key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMinute":
            suggest = "start_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerGroupClusterMaintenanceWindowResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerGroupClusterMaintenanceWindowResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerGroupClusterMaintenanceWindowResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_window: Optional[_builtins.str] = None,
                 day_of_week: Optional[_builtins.int] = None,
                 start_hour: Optional[_builtins.int] = None,
                 start_minute: Optional[_builtins.int] = None):
        """
        Schedule settings for regular cluster updates.
        :param _builtins.str custom_window: Indicates whether custom maintenance window is enabled or not.
        :param _builtins.int day_of_week: Preferred day of the week for maintenance window.
        :param _builtins.int start_hour: Start hour within preferred day of the week for maintenance window.
        :param _builtins.int start_minute: Start minute within the start hour for maintenance window.
        """
        if custom_window is not None:
            pulumi.set(__self__, "custom_window", custom_window)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if start_hour is not None:
            pulumi.set(__self__, "start_hour", start_hour)
        if start_minute is not None:
            pulumi.set(__self__, "start_minute", start_minute)

    @_builtins.property
    @pulumi.getter(name="customWindow")
    def custom_window(self) -> Optional[_builtins.str]:
        """
        Indicates whether custom maintenance window is enabled or not.
        """
        return pulumi.get(self, "custom_window")

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.int]:
        """
        Preferred day of the week for maintenance window.
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[_builtins.int]:
        """
        Start hour within preferred day of the week for maintenance window.
        """
        return pulumi.get(self, "start_hour")

    @_builtins.property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> Optional[_builtins.int]:
        """
        Start minute within the start hour for maintenance window.
        """
        return pulumi.get(self, "start_minute")


@pulumi.output_type
class ServerNameItemResponse(dict):
    """
    The name object for a server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullyQualifiedDomainName":
            suggest = "fully_qualified_domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerNameItemResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerNameItemResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerNameItemResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fully_qualified_domain_name: _builtins.str,
                 name: Optional[_builtins.str] = None):
        """
        The name object for a server.
        :param _builtins.str fully_qualified_domain_name: The fully qualified domain name of a server.
        :param _builtins.str name: The name of a server.
        """
        pulumi.set(__self__, "fully_qualified_domain_name", fully_qualified_domain_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="fullyQualifiedDomainName")
    def fully_qualified_domain_name(self) -> _builtins.str:
        """
        The fully qualified domain name of a server.
        """
        return pulumi.get(self, "fully_qualified_domain_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of a server.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ServerPrivateEndpointConnectionPropertiesResponse(dict):
    """
    Properties of a private endpoint connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerPrivateEndpointConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerPrivateEndpointConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerPrivateEndpointConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: _builtins.str,
                 private_endpoint: Optional['outputs.PrivateEndpointPropertyResponse'] = None,
                 private_link_service_connection_state: Optional['outputs.ServerPrivateLinkServiceConnectionStatePropertyResponse'] = None):
        """
        Properties of a private endpoint connection.
        :param _builtins.str provisioning_state: State of the private endpoint connection.
        :param 'PrivateEndpointPropertyResponse' private_endpoint: Private endpoint which the connection belongs to.
        :param 'ServerPrivateLinkServiceConnectionStatePropertyResponse' private_link_service_connection_state: Connection state of the private endpoint connection.
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if private_link_service_connection_state is not None:
            pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        State of the private endpoint connection.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointPropertyResponse']:
        """
        Private endpoint which the connection belongs to.
        """
        return pulumi.get(self, "private_endpoint")

    @_builtins.property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> Optional['outputs.ServerPrivateLinkServiceConnectionStatePropertyResponse']:
        """
        Connection state of the private endpoint connection.
        """
        return pulumi.get(self, "private_link_service_connection_state")


@pulumi.output_type
class ServerPrivateEndpointConnectionResponse(dict):
    """
    A private endpoint connection under a server
    """
    def __init__(__self__, *,
                 id: _builtins.str,
                 properties: 'outputs.ServerPrivateEndpointConnectionPropertiesResponse'):
        """
        A private endpoint connection under a server
        :param _builtins.str id: Resource ID of the Private Endpoint Connection.
        :param 'ServerPrivateEndpointConnectionPropertiesResponse' properties: Private endpoint connection properties
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Resource ID of the Private Endpoint Connection.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> 'outputs.ServerPrivateEndpointConnectionPropertiesResponse':
        """
        Private endpoint connection properties
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class ServerPrivateLinkServiceConnectionStatePropertyResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerPrivateLinkServiceConnectionStatePropertyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerPrivateLinkServiceConnectionStatePropertyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerPrivateLinkServiceConnectionStatePropertyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: _builtins.str,
                 description: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str actions_required: The actions required for private link service connection.
        :param _builtins.str description: The private link service connection description.
        :param _builtins.str status: The private link service connection status.
        """
        pulumi.set(__self__, "actions_required", actions_required)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> _builtins.str:
        """
        The actions required for private link service connection.
        """
        return pulumi.get(self, "actions_required")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The private link service connection description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The private link service connection status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ServerSkuResponse(dict):
    """
    Compute information of a flexible server.
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 tier: Optional[_builtins.str] = None):
        """
        Compute information of a flexible server.
        :param _builtins.str name: Compute tier and size of the database server. This object is empty for an Azure Database for PostgreSQL single server.
        :param _builtins.str tier: Tier of the compute assigned to a flexible server.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Compute tier and size of the database server. This object is empty for an Azure Database for PostgreSQL single server.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> Optional[_builtins.str]:
        """
        Tier of the compute assigned to a flexible server.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SimplePrivateEndpointConnectionResponse(dict):
    """
    A private endpoint connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemData":
            suggest = "system_data"
        elif key == "groupIds":
            suggest = "group_ids"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SimplePrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SimplePrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SimplePrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: _builtins.str,
                 group_ids: Optional[Sequence[_builtins.str]] = None,
                 private_endpoint: Optional['outputs.PrivateEndpointPropertyResponse'] = None,
                 private_link_service_connection_state: Optional['outputs.PrivateLinkServiceConnectionStateResponse'] = None):
        """
        A private endpoint connection.
        :param _builtins.str id: Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        :param _builtins.str name: The name of the resource
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param _builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param Sequence[_builtins.str] group_ids: Group ids of the private endpoint connection.
        :param 'PrivateEndpointPropertyResponse' private_endpoint: Private endpoint which the connection belongs to.
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: A collection of information about the state of the connection between service consumer and provider.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if group_ids is not None:
            pulumi.set(__self__, "group_ids", group_ids)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if private_link_service_connection_state is not None:
            pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Group ids of the private endpoint connection.
        """
        return pulumi.get(self, "group_ids")

    @_builtins.property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointPropertyResponse']:
        """
        Private endpoint which the connection belongs to.
        """
        return pulumi.get(self, "private_endpoint")

    @_builtins.property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> Optional['outputs.PrivateLinkServiceConnectionStateResponse']:
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        return pulumi.get(self, "private_link_service_connection_state")


@pulumi.output_type
class SingleServerSkuResponse(dict):
    """
    Billing information related properties of a server.
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 capacity: Optional[_builtins.int] = None,
                 family: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 tier: Optional[_builtins.str] = None):
        """
        Billing information related properties of a server.
        :param _builtins.str name: The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
        :param _builtins.int capacity: The scale up/out capacity, representing server's compute units.
        :param _builtins.str family: The family of hardware.
        :param _builtins.str size: The size code, to be interpreted by resource as appropriate.
        :param _builtins.str tier: The tier of the particular SKU, e.g. Basic.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> Optional[_builtins.int]:
        """
        The scale up/out capacity, representing server's compute units.
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[_builtins.str]:
        """
        The family of hardware.
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        The size code, to be interpreted by resource as appropriate.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> Optional[_builtins.str]:
        """
        The tier of the particular SKU, e.g. Basic.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SkuResponse(dict):
    """
    Compute information of a flexible server.
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 tier: _builtins.str):
        """
        Compute information of a flexible server.
        :param _builtins.str name: Name by which is known a given compute size assigned to a flexible server.
        :param _builtins.str tier: Tier of the compute assigned to a flexible server.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name by which is known a given compute size assigned to a flexible server.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> _builtins.str:
        """
        Tier of the compute assigned to a flexible server.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class StorageProfileResponse(dict):
    """
    Storage Profile properties of a server
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupRetentionDays":
            suggest = "backup_retention_days"
        elif key == "geoRedundantBackup":
            suggest = "geo_redundant_backup"
        elif key == "storageAutogrow":
            suggest = "storage_autogrow"
        elif key == "storageMB":
            suggest = "storage_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_retention_days: Optional[_builtins.int] = None,
                 geo_redundant_backup: Optional[_builtins.str] = None,
                 storage_autogrow: Optional[_builtins.str] = None,
                 storage_mb: Optional[_builtins.int] = None):
        """
        Storage Profile properties of a server
        :param _builtins.int backup_retention_days: Backup retention days for the server.
        :param _builtins.str geo_redundant_backup: Enable Geo-redundant or not for server backup.
        :param _builtins.str storage_autogrow: Enable Storage Auto Grow.
        :param _builtins.int storage_mb: Max storage allowed for a server.
        """
        if backup_retention_days is not None:
            pulumi.set(__self__, "backup_retention_days", backup_retention_days)
        if geo_redundant_backup is not None:
            pulumi.set(__self__, "geo_redundant_backup", geo_redundant_backup)
        if storage_autogrow is not None:
            pulumi.set(__self__, "storage_autogrow", storage_autogrow)
        if storage_mb is not None:
            pulumi.set(__self__, "storage_mb", storage_mb)

    @_builtins.property
    @pulumi.getter(name="backupRetentionDays")
    def backup_retention_days(self) -> Optional[_builtins.int]:
        """
        Backup retention days for the server.
        """
        return pulumi.get(self, "backup_retention_days")

    @_builtins.property
    @pulumi.getter(name="geoRedundantBackup")
    def geo_redundant_backup(self) -> Optional[_builtins.str]:
        """
        Enable Geo-redundant or not for server backup.
        """
        return pulumi.get(self, "geo_redundant_backup")

    @_builtins.property
    @pulumi.getter(name="storageAutogrow")
    def storage_autogrow(self) -> Optional[_builtins.str]:
        """
        Enable Storage Auto Grow.
        """
        return pulumi.get(self, "storage_autogrow")

    @_builtins.property
    @pulumi.getter(name="storageMB")
    def storage_mb(self) -> Optional[_builtins.int]:
        """
        Max storage allowed for a server.
        """
        return pulumi.get(self, "storage_mb")


@pulumi.output_type
class StorageResponse(dict):
    """
    Storage properties of a flexible server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoGrow":
            suggest = "auto_grow"
        elif key == "storageSizeGB":
            suggest = "storage_size_gb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_grow: Optional[_builtins.str] = None,
                 iops: Optional[_builtins.int] = None,
                 storage_size_gb: Optional[_builtins.int] = None,
                 throughput: Optional[_builtins.int] = None,
                 tier: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Storage properties of a flexible server.
        :param _builtins.str auto_grow: Flag to enable or disable the automatic growth of storage size of a flexible server when available space is nearing zero and conditions allow for automatically growing storage size.
        :param _builtins.int iops: Maximum IOPS supported for storage. Required when type of storage is PremiumV2_LRS.
        :param _builtins.int storage_size_gb: Size of storage assigned to a flexible server.
        :param _builtins.int throughput: Maximum throughput supported for storage. Required when type of storage is PremiumV2_LRS.
        :param _builtins.str tier: Storage tier of a flexible server.
        :param _builtins.str type: Type of storage assigned to a flexible server. Allowed values are Premium_LRS or PremiumV2_LRS. If not specified, it defaults to Premium_LRS.
        """
        if auto_grow is not None:
            pulumi.set(__self__, "auto_grow", auto_grow)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if storage_size_gb is not None:
            pulumi.set(__self__, "storage_size_gb", storage_size_gb)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="autoGrow")
    def auto_grow(self) -> Optional[_builtins.str]:
        """
        Flag to enable or disable the automatic growth of storage size of a flexible server when available space is nearing zero and conditions allow for automatically growing storage size.
        """
        return pulumi.get(self, "auto_grow")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        Maximum IOPS supported for storage. Required when type of storage is PremiumV2_LRS.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="storageSizeGB")
    def storage_size_gb(self) -> Optional[_builtins.int]:
        """
        Size of storage assigned to a flexible server.
        """
        return pulumi.get(self, "storage_size_gb")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        Maximum throughput supported for storage. Required when type of storage is PremiumV2_LRS.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> Optional[_builtins.str]:
        """
        Storage tier of a flexible server.
        """
        return pulumi.get(self, "tier")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of storage assigned to a flexible server. Allowed values are Premium_LRS or PremiumV2_LRS. If not specified, it defaults to Premium_LRS.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 principal_id: _builtins.str,
                 tenant_id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserIdentityResponse']] = None):
        """
        User assigned identity properties
        :param _builtins.str client_id: The client ID of the assigned identity.
        :param _builtins.str principal_id: The principal ID of the assigned identity.
        :param _builtins.str tenant_id: Identifier of the tenant of a flexible server.
        :param _builtins.str type: Types of identities associated with a flexible server.
        :param Mapping[str, 'UserIdentityResponse'] user_assigned_identities: Map of user assigned managed identities.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the tenant of a flexible server.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Types of identities associated with a flexible server.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserIdentityResponse']]:
        """
        Map of user assigned managed identities.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class UserIdentityResponse(dict):
    """
    User assigned managed identity associated with a flexible server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 principal_id: Optional[_builtins.str] = None):
        """
        User assigned managed identity associated with a flexible server.
        :param _builtins.str client_id: Identifier of the client of the service principal associated to the user assigned managed identity.
        :param _builtins.str principal_id: Identifier of the object of the service principal associated to the user assigned managed identity.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if principal_id is not None:
            pulumi.set(__self__, "principal_id", principal_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the client of the service principal associated to the user assigned managed identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> Optional[_builtins.str]:
        """
        Identifier of the object of the service principal associated to the user assigned managed identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class ValidationDetailsResponse(dict):
    """
    Details for the validation for migration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbLevelValidationDetails":
            suggest = "db_level_validation_details"
        elif key == "serverLevelValidationDetails":
            suggest = "server_level_validation_details"
        elif key == "validationEndTimeInUtc":
            suggest = "validation_end_time_in_utc"
        elif key == "validationStartTimeInUtc":
            suggest = "validation_start_time_in_utc"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidationDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidationDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidationDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_level_validation_details: Optional[Sequence['outputs.DbLevelValidationStatusResponse']] = None,
                 server_level_validation_details: Optional[Sequence['outputs.ValidationSummaryItemResponse']] = None,
                 status: Optional[_builtins.str] = None,
                 validation_end_time_in_utc: Optional[_builtins.str] = None,
                 validation_start_time_in_utc: Optional[_builtins.str] = None):
        """
        Details for the validation for migration.
        :param Sequence['DbLevelValidationStatusResponse'] db_level_validation_details: Details of server level validations.
        :param Sequence['ValidationSummaryItemResponse'] server_level_validation_details: Details of server level validations.
        :param _builtins.str status: Validation status for migration.
        :param _builtins.str validation_end_time_in_utc: End time (UTC) for validation.
        :param _builtins.str validation_start_time_in_utc: Start time (UTC) for validation.
        """
        if db_level_validation_details is not None:
            pulumi.set(__self__, "db_level_validation_details", db_level_validation_details)
        if server_level_validation_details is not None:
            pulumi.set(__self__, "server_level_validation_details", server_level_validation_details)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if validation_end_time_in_utc is not None:
            pulumi.set(__self__, "validation_end_time_in_utc", validation_end_time_in_utc)
        if validation_start_time_in_utc is not None:
            pulumi.set(__self__, "validation_start_time_in_utc", validation_start_time_in_utc)

    @_builtins.property
    @pulumi.getter(name="dbLevelValidationDetails")
    def db_level_validation_details(self) -> Optional[Sequence['outputs.DbLevelValidationStatusResponse']]:
        """
        Details of server level validations.
        """
        return pulumi.get(self, "db_level_validation_details")

    @_builtins.property
    @pulumi.getter(name="serverLevelValidationDetails")
    def server_level_validation_details(self) -> Optional[Sequence['outputs.ValidationSummaryItemResponse']]:
        """
        Details of server level validations.
        """
        return pulumi.get(self, "server_level_validation_details")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Validation status for migration.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="validationEndTimeInUtc")
    def validation_end_time_in_utc(self) -> Optional[_builtins.str]:
        """
        End time (UTC) for validation.
        """
        return pulumi.get(self, "validation_end_time_in_utc")

    @_builtins.property
    @pulumi.getter(name="validationStartTimeInUtc")
    def validation_start_time_in_utc(self) -> Optional[_builtins.str]:
        """
        Start time (UTC) for validation.
        """
        return pulumi.get(self, "validation_start_time_in_utc")


@pulumi.output_type
class ValidationMessageResponse(dict):
    """
    Validation message object.
    """
    def __init__(__self__, *,
                 message: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        Validation message object.
        :param _builtins.str message: Validation message string.
        :param _builtins.str state: Severity of validation message.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Validation message string.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Severity of validation message.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ValidationSummaryItemResponse(dict):
    """
    Validation summary object.
    """
    def __init__(__self__, *,
                 messages: Optional[Sequence['outputs.ValidationMessageResponse']] = None,
                 state: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Validation summary object.
        :param Sequence['ValidationMessageResponse'] messages: Validation messages.
        :param _builtins.str state: Validation status for migration.
        :param _builtins.str type: Validation type.
        """
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[Sequence['outputs.ValidationMessageResponse']]:
        """
        Validation messages.
        """
        return pulumi.get(self, "messages")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Validation status for migration.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Validation type.
        """
        return pulumi.get(self, "type")


