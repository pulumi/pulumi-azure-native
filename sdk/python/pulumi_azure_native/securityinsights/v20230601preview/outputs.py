# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ActivityEntityQueriesPropertiesResponseQueryDefinitions',
    'ActivityTimelineItemResponse',
    'AddIncidentTaskActionPropertiesResponse',
    'AlertDetailsOverrideResponse',
    'AlertPropertyMappingResponse',
    'AlertsDataTypeOfDataConnectorResponse',
    'AnomalyTimelineItemResponse',
    'AssignmentItemResponse',
    'AutomationRuleAddIncidentTaskActionResponse',
    'AutomationRuleBooleanConditionResponse',
    'AutomationRuleModifyPropertiesActionResponse',
    'AutomationRulePropertyArrayChangedValuesConditionResponse',
    'AutomationRulePropertyArrayValuesConditionResponse',
    'AutomationRulePropertyValuesChangedConditionResponse',
    'AutomationRulePropertyValuesConditionResponse',
    'AutomationRuleRunPlaybookActionResponse',
    'AutomationRuleTriggeringLogicResponse',
    'AvailabilityResponse',
    'AwsCloudTrailDataConnectorDataTypesResponse',
    'AwsCloudTrailDataConnectorDataTypesResponseLogs',
    'AwsS3DataConnectorDataTypesResponse',
    'AwsS3DataConnectorDataTypesResponseLogs',
    'BookmarkEntityMappingsResponse',
    'BookmarkTimelineItemResponse',
    'BooleanConditionPropertiesResponse',
    'ClientInfoResponse',
    'CodelessConnectorPollingAuthPropertiesResponse',
    'CodelessConnectorPollingConfigPropertiesResponse',
    'CodelessConnectorPollingPagingPropertiesResponse',
    'CodelessConnectorPollingRequestPropertiesResponse',
    'CodelessConnectorPollingResponsePropertiesResponse',
    'CodelessUiConnectorConfigPropertiesResponse',
    'CodelessUiConnectorConfigPropertiesResponseConnectivityCriteria',
    'CodelessUiConnectorConfigPropertiesResponseDataTypes',
    'CodelessUiConnectorConfigPropertiesResponseGraphQueries',
    'CodelessUiConnectorConfigPropertiesResponseInstructionSteps',
    'CodelessUiConnectorConfigPropertiesResponseSampleQueries',
    'DCRConfigurationResponse',
    'DataConnectorDataTypeCommonResponse',
    'Dynamics365DataConnectorDataTypesResponse',
    'Dynamics365DataConnectorDataTypesResponseDynamics365CdsActivities',
    'EntityFieldMappingResponse',
    'EntityInsightItemResponse',
    'EntityInsightItemResponseQueryTimeInterval',
    'EntityMappingResponse',
    'EventGroupingSettingsResponse',
    'FieldMappingResponse',
    'FileMetadataResponse',
    'FusionScenarioExclusionPatternResponse',
    'FusionSourceSettingsResponse',
    'FusionSourceSubTypeSettingResponse',
    'FusionSubTypeSeverityFilterResponse',
    'FusionSubTypeSeverityFiltersItemResponse',
    'GCPAuthPropertiesResponse',
    'GCPRequestPropertiesResponse',
    'GetInsightsErrorKindResponse',
    'GetInsightsResultsMetadataResponse',
    'GroupingConfigurationResponse',
    'HuntOwnerResponse',
    'IncidentAdditionalDataResponse',
    'IncidentConfigurationResponse',
    'IncidentInfoResponse',
    'IncidentLabelResponse',
    'IncidentOwnerInfoResponse',
    'IncidentPropertiesActionResponse',
    'InsightsTableResultResponse',
    'InsightsTableResultResponseColumns',
    'InstructionStepsResponseInstructions',
    'MCASDataConnectorDataTypesResponse',
    'MSTIDataConnectorDataTypesResponse',
    'MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed',
    'MTPDataConnectorDataTypesResponse',
    'MTPDataConnectorDataTypesResponseAlerts',
    'MTPDataConnectorDataTypesResponseIncidents',
    'MetadataAuthorResponse',
    'MetadataCategoriesResponse',
    'MetadataDependenciesResponse',
    'MetadataSourceResponse',
    'MetadataSupportResponse',
    'MicrosoftPurviewInformationProtectionConnectorDataTypesResponse',
    'MicrosoftPurviewInformationProtectionConnectorDataTypesResponseLogs',
    'MtpFilteredProvidersResponse',
    'Office365ProjectConnectorDataTypesResponse',
    'Office365ProjectConnectorDataTypesResponseLogs',
    'OfficeDataConnectorDataTypesResponse',
    'OfficeDataConnectorDataTypesResponseExchange',
    'OfficeDataConnectorDataTypesResponseSharePoint',
    'OfficeDataConnectorDataTypesResponseTeams',
    'OfficePowerBIConnectorDataTypesResponse',
    'OfficePowerBIConnectorDataTypesResponseLogs',
    'PermissionsResponse',
    'PermissionsResponseCustoms',
    'PermissionsResponseResourceProvider',
    'PlaybookActionPropertiesResponse',
    'PropertyArrayChangedConditionPropertiesResponse',
    'PropertyArrayConditionPropertiesResponse',
    'PropertyChangedConditionPropertiesResponse',
    'PropertyConditionPropertiesResponse',
    'RepoResponse',
    'RequiredPermissionsResponse',
    'SecurityAlertTimelineItemResponse',
    'SecurityMLAnalyticsSettingsDataSourceResponse',
    'SentinelEntityMappingResponse',
    'SystemDataResponse',
    'TIDataConnectorDataTypesResponse',
    'TIDataConnectorDataTypesResponseIndicators',
    'TeamInformationResponse',
    'TiTaxiiDataConnectorDataTypesResponse',
    'TiTaxiiDataConnectorDataTypesResponseTaxiiClient',
    'TimelineAggregationResponse',
    'TimelineErrorResponse',
    'TimelineResultsMetadataResponse',
    'UserInfoResponse',
    'ValidationErrorResponse',
    'WatchlistUserInfoResponse',
]

@pulumi.output_type
class ActivityEntityQueriesPropertiesResponseQueryDefinitions(dict):
    """
    The Activity query definitions
    """
    def __init__(__self__, *,
                 query: Optional[str] = None):
        """
        The Activity query definitions
        :param str query: The Activity query to run on a given entity
        """
        ActivityEntityQueriesPropertiesResponseQueryDefinitions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if query is not None:
            _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        The Activity query to run on a given entity
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class ActivityTimelineItemResponse(dict):
    """
    Represents Activity timeline item.
    """
    def __init__(__self__, *,
                 bucket_end_time_utc: str,
                 bucket_start_time_utc: str,
                 content: str,
                 first_activity_time_utc: str,
                 kind: str,
                 last_activity_time_utc: str,
                 query_id: str,
                 title: str):
        """
        Represents Activity timeline item.
        :param str bucket_end_time_utc: The grouping bucket end time.
        :param str bucket_start_time_utc: The grouping bucket start time.
        :param str content: The activity timeline content.
        :param str first_activity_time_utc: The time of the first activity in the grouping bucket.
        :param str kind: The entity query kind
               Expected value is 'Activity'.
        :param str last_activity_time_utc: The time of the last activity in the grouping bucket.
        :param str query_id: The activity query id.
        :param str title: The activity timeline title.
        """
        ActivityTimelineItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_end_time_utc=bucket_end_time_utc,
            bucket_start_time_utc=bucket_start_time_utc,
            content=content,
            first_activity_time_utc=first_activity_time_utc,
            kind=kind,
            last_activity_time_utc=last_activity_time_utc,
            query_id=query_id,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_end_time_utc: Optional[str] = None,
             bucket_start_time_utc: Optional[str] = None,
             content: Optional[str] = None,
             first_activity_time_utc: Optional[str] = None,
             kind: Optional[str] = None,
             last_activity_time_utc: Optional[str] = None,
             query_id: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_end_time_utc is None and 'bucketEndTimeUTC' in kwargs:
            bucket_end_time_utc = kwargs['bucketEndTimeUTC']
        if bucket_end_time_utc is None:
            raise TypeError("Missing 'bucket_end_time_utc' argument")
        if bucket_start_time_utc is None and 'bucketStartTimeUTC' in kwargs:
            bucket_start_time_utc = kwargs['bucketStartTimeUTC']
        if bucket_start_time_utc is None:
            raise TypeError("Missing 'bucket_start_time_utc' argument")
        if content is None:
            raise TypeError("Missing 'content' argument")
        if first_activity_time_utc is None and 'firstActivityTimeUTC' in kwargs:
            first_activity_time_utc = kwargs['firstActivityTimeUTC']
        if first_activity_time_utc is None:
            raise TypeError("Missing 'first_activity_time_utc' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if last_activity_time_utc is None and 'lastActivityTimeUTC' in kwargs:
            last_activity_time_utc = kwargs['lastActivityTimeUTC']
        if last_activity_time_utc is None:
            raise TypeError("Missing 'last_activity_time_utc' argument")
        if query_id is None and 'queryId' in kwargs:
            query_id = kwargs['queryId']
        if query_id is None:
            raise TypeError("Missing 'query_id' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("bucket_end_time_utc", bucket_end_time_utc)
        _setter("bucket_start_time_utc", bucket_start_time_utc)
        _setter("content", content)
        _setter("first_activity_time_utc", first_activity_time_utc)
        _setter("kind", 'Activity')
        _setter("last_activity_time_utc", last_activity_time_utc)
        _setter("query_id", query_id)
        _setter("title", title)

    @property
    @pulumi.getter(name="bucketEndTimeUTC")
    def bucket_end_time_utc(self) -> str:
        """
        The grouping bucket end time.
        """
        return pulumi.get(self, "bucket_end_time_utc")

    @property
    @pulumi.getter(name="bucketStartTimeUTC")
    def bucket_start_time_utc(self) -> str:
        """
        The grouping bucket start time.
        """
        return pulumi.get(self, "bucket_start_time_utc")

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The activity timeline content.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="firstActivityTimeUTC")
    def first_activity_time_utc(self) -> str:
        """
        The time of the first activity in the grouping bucket.
        """
        return pulumi.get(self, "first_activity_time_utc")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The entity query kind
        Expected value is 'Activity'.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="lastActivityTimeUTC")
    def last_activity_time_utc(self) -> str:
        """
        The time of the last activity in the grouping bucket.
        """
        return pulumi.get(self, "last_activity_time_utc")

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> str:
        """
        The activity query id.
        """
        return pulumi.get(self, "query_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The activity timeline title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class AddIncidentTaskActionPropertiesResponse(dict):
    def __init__(__self__, *,
                 title: str,
                 description: Optional[str] = None):
        """
        :param str title: The title of the task.
        :param str description: The description of the task.
        """
        AddIncidentTaskActionPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            title=title,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             title: Optional[str] = None,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("title", title)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The title of the task.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the task.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class AlertDetailsOverrideResponse(dict):
    """
    Settings for how to dynamically override alert static details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertDescriptionFormat":
            suggest = "alert_description_format"
        elif key == "alertDisplayNameFormat":
            suggest = "alert_display_name_format"
        elif key == "alertDynamicProperties":
            suggest = "alert_dynamic_properties"
        elif key == "alertSeverityColumnName":
            suggest = "alert_severity_column_name"
        elif key == "alertTacticsColumnName":
            suggest = "alert_tactics_column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertDetailsOverrideResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertDetailsOverrideResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertDetailsOverrideResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_description_format: Optional[str] = None,
                 alert_display_name_format: Optional[str] = None,
                 alert_dynamic_properties: Optional[Sequence['outputs.AlertPropertyMappingResponse']] = None,
                 alert_severity_column_name: Optional[str] = None,
                 alert_tactics_column_name: Optional[str] = None):
        """
        Settings for how to dynamically override alert static details
        :param str alert_description_format: the format containing columns name(s) to override the alert description
        :param str alert_display_name_format: the format containing columns name(s) to override the alert name
        :param Sequence['AlertPropertyMappingResponse'] alert_dynamic_properties: List of additional dynamic properties to override
        :param str alert_severity_column_name: the column name to take the alert severity from
        :param str alert_tactics_column_name: the column name to take the alert tactics from
        """
        AlertDetailsOverrideResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_description_format=alert_description_format,
            alert_display_name_format=alert_display_name_format,
            alert_dynamic_properties=alert_dynamic_properties,
            alert_severity_column_name=alert_severity_column_name,
            alert_tactics_column_name=alert_tactics_column_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_description_format: Optional[str] = None,
             alert_display_name_format: Optional[str] = None,
             alert_dynamic_properties: Optional[Sequence['outputs.AlertPropertyMappingResponse']] = None,
             alert_severity_column_name: Optional[str] = None,
             alert_tactics_column_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alert_description_format is None and 'alertDescriptionFormat' in kwargs:
            alert_description_format = kwargs['alertDescriptionFormat']
        if alert_display_name_format is None and 'alertDisplayNameFormat' in kwargs:
            alert_display_name_format = kwargs['alertDisplayNameFormat']
        if alert_dynamic_properties is None and 'alertDynamicProperties' in kwargs:
            alert_dynamic_properties = kwargs['alertDynamicProperties']
        if alert_severity_column_name is None and 'alertSeverityColumnName' in kwargs:
            alert_severity_column_name = kwargs['alertSeverityColumnName']
        if alert_tactics_column_name is None and 'alertTacticsColumnName' in kwargs:
            alert_tactics_column_name = kwargs['alertTacticsColumnName']

        if alert_description_format is not None:
            _setter("alert_description_format", alert_description_format)
        if alert_display_name_format is not None:
            _setter("alert_display_name_format", alert_display_name_format)
        if alert_dynamic_properties is not None:
            _setter("alert_dynamic_properties", alert_dynamic_properties)
        if alert_severity_column_name is not None:
            _setter("alert_severity_column_name", alert_severity_column_name)
        if alert_tactics_column_name is not None:
            _setter("alert_tactics_column_name", alert_tactics_column_name)

    @property
    @pulumi.getter(name="alertDescriptionFormat")
    def alert_description_format(self) -> Optional[str]:
        """
        the format containing columns name(s) to override the alert description
        """
        return pulumi.get(self, "alert_description_format")

    @property
    @pulumi.getter(name="alertDisplayNameFormat")
    def alert_display_name_format(self) -> Optional[str]:
        """
        the format containing columns name(s) to override the alert name
        """
        return pulumi.get(self, "alert_display_name_format")

    @property
    @pulumi.getter(name="alertDynamicProperties")
    def alert_dynamic_properties(self) -> Optional[Sequence['outputs.AlertPropertyMappingResponse']]:
        """
        List of additional dynamic properties to override
        """
        return pulumi.get(self, "alert_dynamic_properties")

    @property
    @pulumi.getter(name="alertSeverityColumnName")
    def alert_severity_column_name(self) -> Optional[str]:
        """
        the column name to take the alert severity from
        """
        return pulumi.get(self, "alert_severity_column_name")

    @property
    @pulumi.getter(name="alertTacticsColumnName")
    def alert_tactics_column_name(self) -> Optional[str]:
        """
        the column name to take the alert tactics from
        """
        return pulumi.get(self, "alert_tactics_column_name")


@pulumi.output_type
class AlertPropertyMappingResponse(dict):
    """
    A single alert property mapping to override
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertProperty":
            suggest = "alert_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertPropertyMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertPropertyMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertPropertyMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_property: Optional[str] = None,
                 value: Optional[str] = None):
        """
        A single alert property mapping to override
        :param str alert_property: The V3 alert property
        :param str value: the column name to use to override this property
        """
        AlertPropertyMappingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_property=alert_property,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_property: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alert_property is None and 'alertProperty' in kwargs:
            alert_property = kwargs['alertProperty']

        if alert_property is not None:
            _setter("alert_property", alert_property)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="alertProperty")
    def alert_property(self) -> Optional[str]:
        """
        The V3 alert property
        """
        return pulumi.get(self, "alert_property")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        the column name to use to override this property
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertsDataTypeOfDataConnectorResponse(dict):
    """
    Alerts data type for data connectors.
    """
    def __init__(__self__, *,
                 alerts: 'outputs.DataConnectorDataTypeCommonResponse'):
        """
        Alerts data type for data connectors.
        :param 'DataConnectorDataTypeCommonResponse' alerts: Alerts data type connection.
        """
        AlertsDataTypeOfDataConnectorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alerts=alerts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alerts: Optional['outputs.DataConnectorDataTypeCommonResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alerts is None:
            raise TypeError("Missing 'alerts' argument")

        _setter("alerts", alerts)

    @property
    @pulumi.getter
    def alerts(self) -> 'outputs.DataConnectorDataTypeCommonResponse':
        """
        Alerts data type connection.
        """
        return pulumi.get(self, "alerts")


@pulumi.output_type
class AnomalyTimelineItemResponse(dict):
    """
    Represents anomaly timeline item.
    """
    def __init__(__self__, *,
                 azure_resource_id: str,
                 display_name: str,
                 end_time_utc: str,
                 kind: str,
                 start_time_utc: str,
                 time_generated: str,
                 description: Optional[str] = None,
                 intent: Optional[str] = None,
                 product_name: Optional[str] = None,
                 reasons: Optional[Sequence[str]] = None,
                 techniques: Optional[Sequence[str]] = None,
                 vendor: Optional[str] = None):
        """
        Represents anomaly timeline item.
        :param str azure_resource_id: The anomaly azure resource id.
        :param str display_name: The anomaly name.
        :param str end_time_utc: The anomaly end time.
        :param str kind: The entity query kind
               Expected value is 'Anomaly'.
        :param str start_time_utc: The anomaly start time.
        :param str time_generated: The anomaly generated time.
        :param str description: The anomaly description.
        :param str intent: The intent of the anomaly.
        :param str product_name: The anomaly product name.
        :param Sequence[str] reasons: The reasons that cause the anomaly.
        :param Sequence[str] techniques: The techniques of the anomaly.
        :param str vendor: The name of the anomaly vendor.
        """
        AnomalyTimelineItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_resource_id=azure_resource_id,
            display_name=display_name,
            end_time_utc=end_time_utc,
            kind=kind,
            start_time_utc=start_time_utc,
            time_generated=time_generated,
            description=description,
            intent=intent,
            product_name=product_name,
            reasons=reasons,
            techniques=techniques,
            vendor=vendor,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_resource_id: Optional[str] = None,
             display_name: Optional[str] = None,
             end_time_utc: Optional[str] = None,
             kind: Optional[str] = None,
             start_time_utc: Optional[str] = None,
             time_generated: Optional[str] = None,
             description: Optional[str] = None,
             intent: Optional[str] = None,
             product_name: Optional[str] = None,
             reasons: Optional[Sequence[str]] = None,
             techniques: Optional[Sequence[str]] = None,
             vendor: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if azure_resource_id is None and 'azureResourceId' in kwargs:
            azure_resource_id = kwargs['azureResourceId']
        if azure_resource_id is None:
            raise TypeError("Missing 'azure_resource_id' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if end_time_utc is None and 'endTimeUtc' in kwargs:
            end_time_utc = kwargs['endTimeUtc']
        if end_time_utc is None:
            raise TypeError("Missing 'end_time_utc' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if start_time_utc is None and 'startTimeUtc' in kwargs:
            start_time_utc = kwargs['startTimeUtc']
        if start_time_utc is None:
            raise TypeError("Missing 'start_time_utc' argument")
        if time_generated is None and 'timeGenerated' in kwargs:
            time_generated = kwargs['timeGenerated']
        if time_generated is None:
            raise TypeError("Missing 'time_generated' argument")
        if product_name is None and 'productName' in kwargs:
            product_name = kwargs['productName']

        _setter("azure_resource_id", azure_resource_id)
        _setter("display_name", display_name)
        _setter("end_time_utc", end_time_utc)
        _setter("kind", 'Anomaly')
        _setter("start_time_utc", start_time_utc)
        _setter("time_generated", time_generated)
        if description is not None:
            _setter("description", description)
        if intent is not None:
            _setter("intent", intent)
        if product_name is not None:
            _setter("product_name", product_name)
        if reasons is not None:
            _setter("reasons", reasons)
        if techniques is not None:
            _setter("techniques", techniques)
        if vendor is not None:
            _setter("vendor", vendor)

    @property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> str:
        """
        The anomaly azure resource id.
        """
        return pulumi.get(self, "azure_resource_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The anomaly name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> str:
        """
        The anomaly end time.
        """
        return pulumi.get(self, "end_time_utc")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The entity query kind
        Expected value is 'Anomaly'.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> str:
        """
        The anomaly start time.
        """
        return pulumi.get(self, "start_time_utc")

    @property
    @pulumi.getter(name="timeGenerated")
    def time_generated(self) -> str:
        """
        The anomaly generated time.
        """
        return pulumi.get(self, "time_generated")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The anomaly description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def intent(self) -> Optional[str]:
        """
        The intent of the anomaly.
        """
        return pulumi.get(self, "intent")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        """
        The anomaly product name.
        """
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter
    def reasons(self) -> Optional[Sequence[str]]:
        """
        The reasons that cause the anomaly.
        """
        return pulumi.get(self, "reasons")

    @property
    @pulumi.getter
    def techniques(self) -> Optional[Sequence[str]]:
        """
        The techniques of the anomaly.
        """
        return pulumi.get(self, "techniques")

    @property
    @pulumi.getter
    def vendor(self) -> Optional[str]:
        """
        The name of the anomaly vendor.
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class AssignmentItemResponse(dict):
    """
    An entity describing a content item.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssignmentItemResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssignmentItemResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssignmentItemResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: Optional[str] = None):
        """
        An entity describing a content item.
        :param str resource_id: The resource id of the content item
        """
        AssignmentItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_id=resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_id is None and 'resourceId' in kwargs:
            resource_id = kwargs['resourceId']

        if resource_id is not None:
            _setter("resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        The resource id of the content item
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class AutomationRuleAddIncidentTaskActionResponse(dict):
    """
    Describes an automation rule action to add a task to an incident
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "actionConfiguration":
            suggest = "action_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleAddIncidentTaskActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleAddIncidentTaskActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleAddIncidentTaskActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 order: int,
                 action_configuration: Optional['outputs.AddIncidentTaskActionPropertiesResponse'] = None):
        """
        Describes an automation rule action to add a task to an incident
        :param str action_type: The type of the automation rule action.
               Expected value is 'AddIncidentTask'.
        """
        AutomationRuleAddIncidentTaskActionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_type=action_type,
            order=order,
            action_configuration=action_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_type: Optional[str] = None,
             order: Optional[int] = None,
             action_configuration: Optional['outputs.AddIncidentTaskActionPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_type is None and 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if action_type is None:
            raise TypeError("Missing 'action_type' argument")
        if order is None:
            raise TypeError("Missing 'order' argument")
        if action_configuration is None and 'actionConfiguration' in kwargs:
            action_configuration = kwargs['actionConfiguration']

        _setter("action_type", 'AddIncidentTask')
        _setter("order", order)
        if action_configuration is not None:
            _setter("action_configuration", action_configuration)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        The type of the automation rule action.
        Expected value is 'AddIncidentTask'.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional['outputs.AddIncidentTaskActionPropertiesResponse']:
        return pulumi.get(self, "action_configuration")


@pulumi.output_type
class AutomationRuleBooleanConditionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "innerConditions":
            suggest = "inner_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleBooleanConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleBooleanConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleBooleanConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inner_conditions: Optional[Sequence[Any]] = None,
                 operator: Optional[str] = None):
        AutomationRuleBooleanConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            inner_conditions=inner_conditions,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             inner_conditions: Optional[Sequence[Any]] = None,
             operator: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if inner_conditions is None and 'innerConditions' in kwargs:
            inner_conditions = kwargs['innerConditions']

        if inner_conditions is not None:
            _setter("inner_conditions", inner_conditions)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter(name="innerConditions")
    def inner_conditions(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "inner_conditions")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")


@pulumi.output_type
class AutomationRuleModifyPropertiesActionResponse(dict):
    """
    Describes an automation rule action to modify an object's properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "actionConfiguration":
            suggest = "action_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleModifyPropertiesActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleModifyPropertiesActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleModifyPropertiesActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 order: int,
                 action_configuration: Optional['outputs.IncidentPropertiesActionResponse'] = None):
        """
        Describes an automation rule action to modify an object's properties
        :param str action_type: The type of the automation rule action.
               Expected value is 'ModifyProperties'.
        """
        AutomationRuleModifyPropertiesActionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_type=action_type,
            order=order,
            action_configuration=action_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_type: Optional[str] = None,
             order: Optional[int] = None,
             action_configuration: Optional['outputs.IncidentPropertiesActionResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_type is None and 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if action_type is None:
            raise TypeError("Missing 'action_type' argument")
        if order is None:
            raise TypeError("Missing 'order' argument")
        if action_configuration is None and 'actionConfiguration' in kwargs:
            action_configuration = kwargs['actionConfiguration']

        _setter("action_type", 'ModifyProperties')
        _setter("order", order)
        if action_configuration is not None:
            _setter("action_configuration", action_configuration)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        The type of the automation rule action.
        Expected value is 'ModifyProperties'.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional['outputs.IncidentPropertiesActionResponse']:
        return pulumi.get(self, "action_configuration")


@pulumi.output_type
class AutomationRulePropertyArrayChangedValuesConditionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arrayType":
            suggest = "array_type"
        elif key == "changeType":
            suggest = "change_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRulePropertyArrayChangedValuesConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRulePropertyArrayChangedValuesConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRulePropertyArrayChangedValuesConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 array_type: Optional[str] = None,
                 change_type: Optional[str] = None):
        AutomationRulePropertyArrayChangedValuesConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            array_type=array_type,
            change_type=change_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             array_type: Optional[str] = None,
             change_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if array_type is None and 'arrayType' in kwargs:
            array_type = kwargs['arrayType']
        if change_type is None and 'changeType' in kwargs:
            change_type = kwargs['changeType']

        if array_type is not None:
            _setter("array_type", array_type)
        if change_type is not None:
            _setter("change_type", change_type)

    @property
    @pulumi.getter(name="arrayType")
    def array_type(self) -> Optional[str]:
        return pulumi.get(self, "array_type")

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        return pulumi.get(self, "change_type")


@pulumi.output_type
class AutomationRulePropertyArrayValuesConditionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arrayConditionType":
            suggest = "array_condition_type"
        elif key == "arrayType":
            suggest = "array_type"
        elif key == "itemConditions":
            suggest = "item_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRulePropertyArrayValuesConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRulePropertyArrayValuesConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRulePropertyArrayValuesConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 array_condition_type: Optional[str] = None,
                 array_type: Optional[str] = None,
                 item_conditions: Optional[Sequence[Any]] = None):
        AutomationRulePropertyArrayValuesConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            array_condition_type=array_condition_type,
            array_type=array_type,
            item_conditions=item_conditions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             array_condition_type: Optional[str] = None,
             array_type: Optional[str] = None,
             item_conditions: Optional[Sequence[Any]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if array_condition_type is None and 'arrayConditionType' in kwargs:
            array_condition_type = kwargs['arrayConditionType']
        if array_type is None and 'arrayType' in kwargs:
            array_type = kwargs['arrayType']
        if item_conditions is None and 'itemConditions' in kwargs:
            item_conditions = kwargs['itemConditions']

        if array_condition_type is not None:
            _setter("array_condition_type", array_condition_type)
        if array_type is not None:
            _setter("array_type", array_type)
        if item_conditions is not None:
            _setter("item_conditions", item_conditions)

    @property
    @pulumi.getter(name="arrayConditionType")
    def array_condition_type(self) -> Optional[str]:
        return pulumi.get(self, "array_condition_type")

    @property
    @pulumi.getter(name="arrayType")
    def array_type(self) -> Optional[str]:
        return pulumi.get(self, "array_type")

    @property
    @pulumi.getter(name="itemConditions")
    def item_conditions(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "item_conditions")


@pulumi.output_type
class AutomationRulePropertyValuesChangedConditionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changeType":
            suggest = "change_type"
        elif key == "propertyName":
            suggest = "property_name"
        elif key == "propertyValues":
            suggest = "property_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRulePropertyValuesChangedConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRulePropertyValuesChangedConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRulePropertyValuesChangedConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 change_type: Optional[str] = None,
                 operator: Optional[str] = None,
                 property_name: Optional[str] = None,
                 property_values: Optional[Sequence[str]] = None):
        AutomationRulePropertyValuesChangedConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            change_type=change_type,
            operator=operator,
            property_name=property_name,
            property_values=property_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             change_type: Optional[str] = None,
             operator: Optional[str] = None,
             property_name: Optional[str] = None,
             property_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if change_type is None and 'changeType' in kwargs:
            change_type = kwargs['changeType']
        if property_name is None and 'propertyName' in kwargs:
            property_name = kwargs['propertyName']
        if property_values is None and 'propertyValues' in kwargs:
            property_values = kwargs['propertyValues']

        if change_type is not None:
            _setter("change_type", change_type)
        if operator is not None:
            _setter("operator", operator)
        if property_name is not None:
            _setter("property_name", property_name)
        if property_values is not None:
            _setter("property_values", property_values)

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        return pulumi.get(self, "change_type")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[str]:
        return pulumi.get(self, "property_name")

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "property_values")


@pulumi.output_type
class AutomationRulePropertyValuesConditionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertyName":
            suggest = "property_name"
        elif key == "propertyValues":
            suggest = "property_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRulePropertyValuesConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRulePropertyValuesConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRulePropertyValuesConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 property_name: Optional[str] = None,
                 property_values: Optional[Sequence[str]] = None):
        """
        :param str property_name: The property to evaluate in an automation rule property condition.
        """
        AutomationRulePropertyValuesConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            property_name=property_name,
            property_values=property_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[str] = None,
             property_name: Optional[str] = None,
             property_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if property_name is None and 'propertyName' in kwargs:
            property_name = kwargs['propertyName']
        if property_values is None and 'propertyValues' in kwargs:
            property_values = kwargs['propertyValues']

        if operator is not None:
            _setter("operator", operator)
        if property_name is not None:
            _setter("property_name", property_name)
        if property_values is not None:
            _setter("property_values", property_values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[str]:
        """
        The property to evaluate in an automation rule property condition.
        """
        return pulumi.get(self, "property_name")

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "property_values")


@pulumi.output_type
class AutomationRuleRunPlaybookActionResponse(dict):
    """
    Describes an automation rule action to run a playbook
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "actionConfiguration":
            suggest = "action_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleRunPlaybookActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleRunPlaybookActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleRunPlaybookActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 order: int,
                 action_configuration: Optional['outputs.PlaybookActionPropertiesResponse'] = None):
        """
        Describes an automation rule action to run a playbook
        :param str action_type: The type of the automation rule action.
               Expected value is 'RunPlaybook'.
        """
        AutomationRuleRunPlaybookActionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_type=action_type,
            order=order,
            action_configuration=action_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_type: Optional[str] = None,
             order: Optional[int] = None,
             action_configuration: Optional['outputs.PlaybookActionPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action_type is None and 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if action_type is None:
            raise TypeError("Missing 'action_type' argument")
        if order is None:
            raise TypeError("Missing 'order' argument")
        if action_configuration is None and 'actionConfiguration' in kwargs:
            action_configuration = kwargs['actionConfiguration']

        _setter("action_type", 'RunPlaybook')
        _setter("order", order)
        if action_configuration is not None:
            _setter("action_configuration", action_configuration)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        The type of the automation rule action.
        Expected value is 'RunPlaybook'.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional['outputs.PlaybookActionPropertiesResponse']:
        return pulumi.get(self, "action_configuration")


@pulumi.output_type
class AutomationRuleTriggeringLogicResponse(dict):
    """
    Describes automation rule triggering logic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "triggersOn":
            suggest = "triggers_on"
        elif key == "triggersWhen":
            suggest = "triggers_when"
        elif key == "expirationTimeUtc":
            suggest = "expiration_time_utc"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleTriggeringLogicResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleTriggeringLogicResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleTriggeringLogicResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: bool,
                 triggers_on: str,
                 triggers_when: str,
                 conditions: Optional[Sequence[Any]] = None,
                 expiration_time_utc: Optional[str] = None):
        """
        Describes automation rule triggering logic.
        :param bool is_enabled: Determines whether the automation rule is enabled or disabled.
        :param Sequence[Union['BooleanConditionPropertiesResponse', 'PropertyArrayChangedConditionPropertiesResponse', 'PropertyArrayConditionPropertiesResponse', 'PropertyChangedConditionPropertiesResponse', 'PropertyConditionPropertiesResponse']] conditions: The conditions to evaluate to determine if the automation rule should be triggered on a given object.
        :param str expiration_time_utc: Determines when the automation rule should automatically expire and be disabled.
        """
        AutomationRuleTriggeringLogicResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
            triggers_on=triggers_on,
            triggers_when=triggers_when,
            conditions=conditions,
            expiration_time_utc=expiration_time_utc,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: Optional[bool] = None,
             triggers_on: Optional[str] = None,
             triggers_when: Optional[str] = None,
             conditions: Optional[Sequence[Any]] = None,
             expiration_time_utc: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_enabled is None and 'isEnabled' in kwargs:
            is_enabled = kwargs['isEnabled']
        if is_enabled is None:
            raise TypeError("Missing 'is_enabled' argument")
        if triggers_on is None and 'triggersOn' in kwargs:
            triggers_on = kwargs['triggersOn']
        if triggers_on is None:
            raise TypeError("Missing 'triggers_on' argument")
        if triggers_when is None and 'triggersWhen' in kwargs:
            triggers_when = kwargs['triggersWhen']
        if triggers_when is None:
            raise TypeError("Missing 'triggers_when' argument")
        if expiration_time_utc is None and 'expirationTimeUtc' in kwargs:
            expiration_time_utc = kwargs['expirationTimeUtc']

        _setter("is_enabled", is_enabled)
        _setter("triggers_on", triggers_on)
        _setter("triggers_when", triggers_when)
        if conditions is not None:
            _setter("conditions", conditions)
        if expiration_time_utc is not None:
            _setter("expiration_time_utc", expiration_time_utc)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Determines whether the automation rule is enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="triggersOn")
    def triggers_on(self) -> str:
        return pulumi.get(self, "triggers_on")

    @property
    @pulumi.getter(name="triggersWhen")
    def triggers_when(self) -> str:
        return pulumi.get(self, "triggers_when")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence[Any]]:
        """
        The conditions to evaluate to determine if the automation rule should be triggered on a given object.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="expirationTimeUtc")
    def expiration_time_utc(self) -> Optional[str]:
        """
        Determines when the automation rule should automatically expire and be disabled.
        """
        return pulumi.get(self, "expiration_time_utc")


@pulumi.output_type
class AvailabilityResponse(dict):
    """
    Connector Availability Status
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPreview":
            suggest = "is_preview"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AvailabilityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AvailabilityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AvailabilityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_preview: Optional[bool] = None,
                 status: Optional[int] = None):
        """
        Connector Availability Status
        :param bool is_preview: Set connector as preview
        :param int status: The connector Availability Status
        """
        AvailabilityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_preview=is_preview,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_preview: Optional[bool] = None,
             status: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_preview is None and 'isPreview' in kwargs:
            is_preview = kwargs['isPreview']

        if is_preview is not None:
            _setter("is_preview", is_preview)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="isPreview")
    def is_preview(self) -> Optional[bool]:
        """
        Set connector as preview
        """
        return pulumi.get(self, "is_preview")

    @property
    @pulumi.getter
    def status(self) -> Optional[int]:
        """
        The connector Availability Status
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class AwsCloudTrailDataConnectorDataTypesResponse(dict):
    """
    The available data types for Amazon Web Services CloudTrail data connector.
    """
    def __init__(__self__, *,
                 logs: 'outputs.AwsCloudTrailDataConnectorDataTypesResponseLogs'):
        """
        The available data types for Amazon Web Services CloudTrail data connector.
        :param 'AwsCloudTrailDataConnectorDataTypesResponseLogs' logs: Logs data type.
        """
        AwsCloudTrailDataConnectorDataTypesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            logs=logs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             logs: Optional['outputs.AwsCloudTrailDataConnectorDataTypesResponseLogs'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if logs is None:
            raise TypeError("Missing 'logs' argument")

        _setter("logs", logs)

    @property
    @pulumi.getter
    def logs(self) -> 'outputs.AwsCloudTrailDataConnectorDataTypesResponseLogs':
        """
        Logs data type.
        """
        return pulumi.get(self, "logs")


@pulumi.output_type
class AwsCloudTrailDataConnectorDataTypesResponseLogs(dict):
    """
    Logs data type.
    """
    def __init__(__self__, *,
                 state: str):
        """
        Logs data type.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        AwsCloudTrailDataConnectorDataTypesResponseLogs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class AwsS3DataConnectorDataTypesResponse(dict):
    """
    The available data types for Amazon Web Services S3 data connector.
    """
    def __init__(__self__, *,
                 logs: 'outputs.AwsS3DataConnectorDataTypesResponseLogs'):
        """
        The available data types for Amazon Web Services S3 data connector.
        :param 'AwsS3DataConnectorDataTypesResponseLogs' logs: Logs data type.
        """
        AwsS3DataConnectorDataTypesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            logs=logs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             logs: Optional['outputs.AwsS3DataConnectorDataTypesResponseLogs'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if logs is None:
            raise TypeError("Missing 'logs' argument")

        _setter("logs", logs)

    @property
    @pulumi.getter
    def logs(self) -> 'outputs.AwsS3DataConnectorDataTypesResponseLogs':
        """
        Logs data type.
        """
        return pulumi.get(self, "logs")


@pulumi.output_type
class AwsS3DataConnectorDataTypesResponseLogs(dict):
    """
    Logs data type.
    """
    def __init__(__self__, *,
                 state: str):
        """
        Logs data type.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        AwsS3DataConnectorDataTypesResponseLogs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class BookmarkEntityMappingsResponse(dict):
    """
    Describes the entity mappings of a single entity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "fieldMappings":
            suggest = "field_mappings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BookmarkEntityMappingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BookmarkEntityMappingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BookmarkEntityMappingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: Optional[str] = None,
                 field_mappings: Optional[Sequence['outputs.EntityFieldMappingResponse']] = None):
        """
        Describes the entity mappings of a single entity
        :param str entity_type: The entity type
        :param Sequence['EntityFieldMappingResponse'] field_mappings: Array of fields mapping for that entity type
        """
        BookmarkEntityMappingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_type=entity_type,
            field_mappings=field_mappings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_type: Optional[str] = None,
             field_mappings: Optional[Sequence['outputs.EntityFieldMappingResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if entity_type is None and 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if field_mappings is None and 'fieldMappings' in kwargs:
            field_mappings = kwargs['fieldMappings']

        if entity_type is not None:
            _setter("entity_type", entity_type)
        if field_mappings is not None:
            _setter("field_mappings", field_mappings)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[str]:
        """
        The entity type
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[Sequence['outputs.EntityFieldMappingResponse']]:
        """
        Array of fields mapping for that entity type
        """
        return pulumi.get(self, "field_mappings")


@pulumi.output_type
class BookmarkTimelineItemResponse(dict):
    """
    Represents bookmark timeline item.
    """
    def __init__(__self__, *,
                 azure_resource_id: str,
                 kind: str,
                 created_by: Optional['outputs.UserInfoResponse'] = None,
                 display_name: Optional[str] = None,
                 end_time_utc: Optional[str] = None,
                 event_time: Optional[str] = None,
                 labels: Optional[Sequence[str]] = None,
                 notes: Optional[str] = None,
                 start_time_utc: Optional[str] = None):
        """
        Represents bookmark timeline item.
        :param str azure_resource_id: The bookmark azure resource id.
        :param str kind: The entity query kind
               Expected value is 'Bookmark'.
        :param 'UserInfoResponse' created_by: Describes a user that created the bookmark
        :param str display_name: The bookmark display name.
        :param str end_time_utc: The bookmark end time.
        :param str event_time: The bookmark event time.
        :param Sequence[str] labels: List of labels relevant to this bookmark
        :param str notes: The notes of the bookmark
        :param str start_time_utc: The bookmark start time.
        """
        BookmarkTimelineItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_resource_id=azure_resource_id,
            kind=kind,
            created_by=created_by,
            display_name=display_name,
            end_time_utc=end_time_utc,
            event_time=event_time,
            labels=labels,
            notes=notes,
            start_time_utc=start_time_utc,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_resource_id: Optional[str] = None,
             kind: Optional[str] = None,
             created_by: Optional['outputs.UserInfoResponse'] = None,
             display_name: Optional[str] = None,
             end_time_utc: Optional[str] = None,
             event_time: Optional[str] = None,
             labels: Optional[Sequence[str]] = None,
             notes: Optional[str] = None,
             start_time_utc: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if azure_resource_id is None and 'azureResourceId' in kwargs:
            azure_resource_id = kwargs['azureResourceId']
        if azure_resource_id is None:
            raise TypeError("Missing 'azure_resource_id' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if end_time_utc is None and 'endTimeUtc' in kwargs:
            end_time_utc = kwargs['endTimeUtc']
        if event_time is None and 'eventTime' in kwargs:
            event_time = kwargs['eventTime']
        if start_time_utc is None and 'startTimeUtc' in kwargs:
            start_time_utc = kwargs['startTimeUtc']

        _setter("azure_resource_id", azure_resource_id)
        _setter("kind", 'Bookmark')
        if created_by is not None:
            _setter("created_by", created_by)
        if display_name is not None:
            _setter("display_name", display_name)
        if end_time_utc is not None:
            _setter("end_time_utc", end_time_utc)
        if event_time is not None:
            _setter("event_time", event_time)
        if labels is not None:
            _setter("labels", labels)
        if notes is not None:
            _setter("notes", notes)
        if start_time_utc is not None:
            _setter("start_time_utc", start_time_utc)

    @property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> str:
        """
        The bookmark azure resource id.
        """
        return pulumi.get(self, "azure_resource_id")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The entity query kind
        Expected value is 'Bookmark'.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional['outputs.UserInfoResponse']:
        """
        Describes a user that created the bookmark
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The bookmark display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> Optional[str]:
        """
        The bookmark end time.
        """
        return pulumi.get(self, "end_time_utc")

    @property
    @pulumi.getter(name="eventTime")
    def event_time(self) -> Optional[str]:
        """
        The bookmark event time.
        """
        return pulumi.get(self, "event_time")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        List of labels relevant to this bookmark
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def notes(self) -> Optional[str]:
        """
        The notes of the bookmark
        """
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> Optional[str]:
        """
        The bookmark start time.
        """
        return pulumi.get(self, "start_time_utc")


@pulumi.output_type
class BooleanConditionPropertiesResponse(dict):
    """
    Describes an automation rule condition that applies a boolean operator (e.g AND, OR) to conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"
        elif key == "conditionProperties":
            suggest = "condition_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BooleanConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BooleanConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BooleanConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: str,
                 condition_properties: Optional['outputs.AutomationRuleBooleanConditionResponse'] = None):
        """
        Describes an automation rule condition that applies a boolean operator (e.g AND, OR) to conditions
        :param str condition_type: 
               Expected value is 'Boolean'.
        """
        BooleanConditionPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_type=condition_type,
            condition_properties=condition_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_type: Optional[str] = None,
             condition_properties: Optional['outputs.AutomationRuleBooleanConditionResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if condition_type is None and 'conditionType' in kwargs:
            condition_type = kwargs['conditionType']
        if condition_type is None:
            raise TypeError("Missing 'condition_type' argument")
        if condition_properties is None and 'conditionProperties' in kwargs:
            condition_properties = kwargs['conditionProperties']

        _setter("condition_type", 'Boolean')
        if condition_properties is not None:
            _setter("condition_properties", condition_properties)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> str:
        """

        Expected value is 'Boolean'.
        """
        return pulumi.get(self, "condition_type")

    @property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional['outputs.AutomationRuleBooleanConditionResponse']:
        return pulumi.get(self, "condition_properties")


@pulumi.output_type
class ClientInfoResponse(dict):
    """
    Information on the client (user or application) that made some action
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectId":
            suggest = "object_id"
        elif key == "userPrincipalName":
            suggest = "user_principal_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: Optional[str] = None,
                 name: Optional[str] = None,
                 object_id: Optional[str] = None,
                 user_principal_name: Optional[str] = None):
        """
        Information on the client (user or application) that made some action
        :param str email: The email of the client.
        :param str name: The name of the client.
        :param str object_id: The object id of the client.
        :param str user_principal_name: The user principal name of the client.
        """
        ClientInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            name=name,
            object_id=object_id,
            user_principal_name=user_principal_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: Optional[str] = None,
             name: Optional[str] = None,
             object_id: Optional[str] = None,
             user_principal_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if object_id is None and 'objectId' in kwargs:
            object_id = kwargs['objectId']
        if user_principal_name is None and 'userPrincipalName' in kwargs:
            user_principal_name = kwargs['userPrincipalName']

        if email is not None:
            _setter("email", email)
        if name is not None:
            _setter("name", name)
        if object_id is not None:
            _setter("object_id", object_id)
        if user_principal_name is not None:
            _setter("user_principal_name", user_principal_name)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The email of the client.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the client.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[str]:
        """
        The object id of the client.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[str]:
        """
        The user principal name of the client.
        """
        return pulumi.get(self, "user_principal_name")


@pulumi.output_type
class CodelessConnectorPollingAuthPropertiesResponse(dict):
    """
    Describe the authentication properties needed to successfully authenticate with the server
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "apiKeyIdentifier":
            suggest = "api_key_identifier"
        elif key == "apiKeyName":
            suggest = "api_key_name"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "authorizationEndpointQueryParameters":
            suggest = "authorization_endpoint_query_parameters"
        elif key == "flowName":
            suggest = "flow_name"
        elif key == "isApiKeyInPostPayload":
            suggest = "is_api_key_in_post_payload"
        elif key == "isClientSecretInHeader":
            suggest = "is_client_secret_in_header"
        elif key == "redirectionEndpoint":
            suggest = "redirection_endpoint"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "tokenEndpointHeaders":
            suggest = "token_endpoint_headers"
        elif key == "tokenEndpointQueryParameters":
            suggest = "token_endpoint_query_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodelessConnectorPollingAuthPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodelessConnectorPollingAuthPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodelessConnectorPollingAuthPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: str,
                 api_key_identifier: Optional[str] = None,
                 api_key_name: Optional[str] = None,
                 authorization_endpoint: Optional[str] = None,
                 authorization_endpoint_query_parameters: Optional[Any] = None,
                 flow_name: Optional[str] = None,
                 is_api_key_in_post_payload: Optional[str] = None,
                 is_client_secret_in_header: Optional[bool] = None,
                 redirection_endpoint: Optional[str] = None,
                 scope: Optional[str] = None,
                 token_endpoint: Optional[str] = None,
                 token_endpoint_headers: Optional[Any] = None,
                 token_endpoint_query_parameters: Optional[Any] = None):
        """
        Describe the authentication properties needed to successfully authenticate with the server
        :param str auth_type: The authentication type
        :param str api_key_identifier: A prefix send in the header before the actual token
        :param str api_key_name: The header name which the token is sent with
        :param str authorization_endpoint: The endpoint used to authorize the user, used in Oauth 2.0 flow
        :param Any authorization_endpoint_query_parameters: The query parameters used in authorization request, used in Oauth 2.0 flow
        :param str flow_name: Describes the flow name, for example 'AuthCode' for Oauth 2.0
        :param str is_api_key_in_post_payload: Marks if the key should sent in header
        :param bool is_client_secret_in_header: Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow
        :param str redirection_endpoint: The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow
        :param str scope: The OAuth token scope
        :param str token_endpoint: The endpoint used to issue a token, used in Oauth 2.0 flow
        :param Any token_endpoint_headers: The query headers used in token request, used in Oauth 2.0 flow
        :param Any token_endpoint_query_parameters: The query parameters used in token request, used in Oauth 2.0 flow
        """
        CodelessConnectorPollingAuthPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_type=auth_type,
            api_key_identifier=api_key_identifier,
            api_key_name=api_key_name,
            authorization_endpoint=authorization_endpoint,
            authorization_endpoint_query_parameters=authorization_endpoint_query_parameters,
            flow_name=flow_name,
            is_api_key_in_post_payload=is_api_key_in_post_payload,
            is_client_secret_in_header=is_client_secret_in_header,
            redirection_endpoint=redirection_endpoint,
            scope=scope,
            token_endpoint=token_endpoint,
            token_endpoint_headers=token_endpoint_headers,
            token_endpoint_query_parameters=token_endpoint_query_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_type: Optional[str] = None,
             api_key_identifier: Optional[str] = None,
             api_key_name: Optional[str] = None,
             authorization_endpoint: Optional[str] = None,
             authorization_endpoint_query_parameters: Optional[Any] = None,
             flow_name: Optional[str] = None,
             is_api_key_in_post_payload: Optional[str] = None,
             is_client_secret_in_header: Optional[bool] = None,
             redirection_endpoint: Optional[str] = None,
             scope: Optional[str] = None,
             token_endpoint: Optional[str] = None,
             token_endpoint_headers: Optional[Any] = None,
             token_endpoint_query_parameters: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth_type is None and 'authType' in kwargs:
            auth_type = kwargs['authType']
        if auth_type is None:
            raise TypeError("Missing 'auth_type' argument")
        if api_key_identifier is None and 'apiKeyIdentifier' in kwargs:
            api_key_identifier = kwargs['apiKeyIdentifier']
        if api_key_name is None and 'apiKeyName' in kwargs:
            api_key_name = kwargs['apiKeyName']
        if authorization_endpoint is None and 'authorizationEndpoint' in kwargs:
            authorization_endpoint = kwargs['authorizationEndpoint']
        if authorization_endpoint_query_parameters is None and 'authorizationEndpointQueryParameters' in kwargs:
            authorization_endpoint_query_parameters = kwargs['authorizationEndpointQueryParameters']
        if flow_name is None and 'flowName' in kwargs:
            flow_name = kwargs['flowName']
        if is_api_key_in_post_payload is None and 'isApiKeyInPostPayload' in kwargs:
            is_api_key_in_post_payload = kwargs['isApiKeyInPostPayload']
        if is_client_secret_in_header is None and 'isClientSecretInHeader' in kwargs:
            is_client_secret_in_header = kwargs['isClientSecretInHeader']
        if redirection_endpoint is None and 'redirectionEndpoint' in kwargs:
            redirection_endpoint = kwargs['redirectionEndpoint']
        if token_endpoint is None and 'tokenEndpoint' in kwargs:
            token_endpoint = kwargs['tokenEndpoint']
        if token_endpoint_headers is None and 'tokenEndpointHeaders' in kwargs:
            token_endpoint_headers = kwargs['tokenEndpointHeaders']
        if token_endpoint_query_parameters is None and 'tokenEndpointQueryParameters' in kwargs:
            token_endpoint_query_parameters = kwargs['tokenEndpointQueryParameters']

        _setter("auth_type", auth_type)
        if api_key_identifier is not None:
            _setter("api_key_identifier", api_key_identifier)
        if api_key_name is not None:
            _setter("api_key_name", api_key_name)
        if authorization_endpoint is not None:
            _setter("authorization_endpoint", authorization_endpoint)
        if authorization_endpoint_query_parameters is not None:
            _setter("authorization_endpoint_query_parameters", authorization_endpoint_query_parameters)
        if flow_name is not None:
            _setter("flow_name", flow_name)
        if is_api_key_in_post_payload is not None:
            _setter("is_api_key_in_post_payload", is_api_key_in_post_payload)
        if is_client_secret_in_header is not None:
            _setter("is_client_secret_in_header", is_client_secret_in_header)
        if redirection_endpoint is not None:
            _setter("redirection_endpoint", redirection_endpoint)
        if scope is not None:
            _setter("scope", scope)
        if token_endpoint is not None:
            _setter("token_endpoint", token_endpoint)
        if token_endpoint_headers is not None:
            _setter("token_endpoint_headers", token_endpoint_headers)
        if token_endpoint_query_parameters is not None:
            _setter("token_endpoint_query_parameters", token_endpoint_query_parameters)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        """
        The authentication type
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="apiKeyIdentifier")
    def api_key_identifier(self) -> Optional[str]:
        """
        A prefix send in the header before the actual token
        """
        return pulumi.get(self, "api_key_identifier")

    @property
    @pulumi.getter(name="apiKeyName")
    def api_key_name(self) -> Optional[str]:
        """
        The header name which the token is sent with
        """
        return pulumi.get(self, "api_key_name")

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[str]:
        """
        The endpoint used to authorize the user, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "authorization_endpoint")

    @property
    @pulumi.getter(name="authorizationEndpointQueryParameters")
    def authorization_endpoint_query_parameters(self) -> Optional[Any]:
        """
        The query parameters used in authorization request, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "authorization_endpoint_query_parameters")

    @property
    @pulumi.getter(name="flowName")
    def flow_name(self) -> Optional[str]:
        """
        Describes the flow name, for example 'AuthCode' for Oauth 2.0
        """
        return pulumi.get(self, "flow_name")

    @property
    @pulumi.getter(name="isApiKeyInPostPayload")
    def is_api_key_in_post_payload(self) -> Optional[str]:
        """
        Marks if the key should sent in header
        """
        return pulumi.get(self, "is_api_key_in_post_payload")

    @property
    @pulumi.getter(name="isClientSecretInHeader")
    def is_client_secret_in_header(self) -> Optional[bool]:
        """
        Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "is_client_secret_in_header")

    @property
    @pulumi.getter(name="redirectionEndpoint")
    def redirection_endpoint(self) -> Optional[str]:
        """
        The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "redirection_endpoint")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        The OAuth token scope
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The endpoint used to issue a token, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "token_endpoint")

    @property
    @pulumi.getter(name="tokenEndpointHeaders")
    def token_endpoint_headers(self) -> Optional[Any]:
        """
        The query headers used in token request, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "token_endpoint_headers")

    @property
    @pulumi.getter(name="tokenEndpointQueryParameters")
    def token_endpoint_query_parameters(self) -> Optional[Any]:
        """
        The query parameters used in token request, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "token_endpoint_query_parameters")


@pulumi.output_type
class CodelessConnectorPollingConfigPropertiesResponse(dict):
    """
    Config to describe the polling config for API poller connector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isActive":
            suggest = "is_active"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodelessConnectorPollingConfigPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodelessConnectorPollingConfigPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodelessConnectorPollingConfigPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: 'outputs.CodelessConnectorPollingAuthPropertiesResponse',
                 request: 'outputs.CodelessConnectorPollingRequestPropertiesResponse',
                 is_active: Optional[bool] = None,
                 paging: Optional['outputs.CodelessConnectorPollingPagingPropertiesResponse'] = None,
                 response: Optional['outputs.CodelessConnectorPollingResponsePropertiesResponse'] = None):
        """
        Config to describe the polling config for API poller connector
        :param 'CodelessConnectorPollingAuthPropertiesResponse' auth: Describe the authentication type of the poller
        :param 'CodelessConnectorPollingRequestPropertiesResponse' request: Describe the poll request config parameters of the poller
        :param bool is_active: The poller active status
        :param 'CodelessConnectorPollingPagingPropertiesResponse' paging: Describe the poll request paging config of the poller
        :param 'CodelessConnectorPollingResponsePropertiesResponse' response: Describe the response config parameters of the poller
        """
        CodelessConnectorPollingConfigPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth=auth,
            request=request,
            is_active=is_active,
            paging=paging,
            response=response,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth: Optional['outputs.CodelessConnectorPollingAuthPropertiesResponse'] = None,
             request: Optional['outputs.CodelessConnectorPollingRequestPropertiesResponse'] = None,
             is_active: Optional[bool] = None,
             paging: Optional['outputs.CodelessConnectorPollingPagingPropertiesResponse'] = None,
             response: Optional['outputs.CodelessConnectorPollingResponsePropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if auth is None:
            raise TypeError("Missing 'auth' argument")
        if request is None:
            raise TypeError("Missing 'request' argument")
        if is_active is None and 'isActive' in kwargs:
            is_active = kwargs['isActive']

        _setter("auth", auth)
        _setter("request", request)
        if is_active is not None:
            _setter("is_active", is_active)
        if paging is not None:
            _setter("paging", paging)
        if response is not None:
            _setter("response", response)

    @property
    @pulumi.getter
    def auth(self) -> 'outputs.CodelessConnectorPollingAuthPropertiesResponse':
        """
        Describe the authentication type of the poller
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def request(self) -> 'outputs.CodelessConnectorPollingRequestPropertiesResponse':
        """
        Describe the poll request config parameters of the poller
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[bool]:
        """
        The poller active status
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter
    def paging(self) -> Optional['outputs.CodelessConnectorPollingPagingPropertiesResponse']:
        """
        Describe the poll request paging config of the poller
        """
        return pulumi.get(self, "paging")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.CodelessConnectorPollingResponsePropertiesResponse']:
        """
        Describe the response config parameters of the poller
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class CodelessConnectorPollingPagingPropertiesResponse(dict):
    """
    Describe the properties needed to make a pagination call
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagingType":
            suggest = "paging_type"
        elif key == "nextPageParaName":
            suggest = "next_page_para_name"
        elif key == "nextPageTokenJsonPath":
            suggest = "next_page_token_json_path"
        elif key == "pageCountAttributePath":
            suggest = "page_count_attribute_path"
        elif key == "pageSize":
            suggest = "page_size"
        elif key == "pageSizeParaName":
            suggest = "page_size_para_name"
        elif key == "pageTimeStampAttributePath":
            suggest = "page_time_stamp_attribute_path"
        elif key == "pageTotalCountAttributePath":
            suggest = "page_total_count_attribute_path"
        elif key == "searchTheLatestTimeStampFromEventsList":
            suggest = "search_the_latest_time_stamp_from_events_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodelessConnectorPollingPagingPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodelessConnectorPollingPagingPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodelessConnectorPollingPagingPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paging_type: str,
                 next_page_para_name: Optional[str] = None,
                 next_page_token_json_path: Optional[str] = None,
                 page_count_attribute_path: Optional[str] = None,
                 page_size: Optional[int] = None,
                 page_size_para_name: Optional[str] = None,
                 page_time_stamp_attribute_path: Optional[str] = None,
                 page_total_count_attribute_path: Optional[str] = None,
                 search_the_latest_time_stamp_from_events_list: Optional[str] = None):
        """
        Describe the properties needed to make a pagination call
        :param str paging_type: Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'
        :param str next_page_para_name: Defines the name of a next page attribute
        :param str next_page_token_json_path: Defines the path to a next page token JSON
        :param str page_count_attribute_path: Defines the path to a page count attribute
        :param int page_size: Defines the paging size
        :param str page_size_para_name: Defines the name of the page size parameter
        :param str page_time_stamp_attribute_path: Defines the path to a paging time stamp attribute
        :param str page_total_count_attribute_path: Defines the path to a page total count attribute
        :param str search_the_latest_time_stamp_from_events_list: Determines whether to search for the latest time stamp in the events list
        """
        CodelessConnectorPollingPagingPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            paging_type=paging_type,
            next_page_para_name=next_page_para_name,
            next_page_token_json_path=next_page_token_json_path,
            page_count_attribute_path=page_count_attribute_path,
            page_size=page_size,
            page_size_para_name=page_size_para_name,
            page_time_stamp_attribute_path=page_time_stamp_attribute_path,
            page_total_count_attribute_path=page_total_count_attribute_path,
            search_the_latest_time_stamp_from_events_list=search_the_latest_time_stamp_from_events_list,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             paging_type: Optional[str] = None,
             next_page_para_name: Optional[str] = None,
             next_page_token_json_path: Optional[str] = None,
             page_count_attribute_path: Optional[str] = None,
             page_size: Optional[int] = None,
             page_size_para_name: Optional[str] = None,
             page_time_stamp_attribute_path: Optional[str] = None,
             page_total_count_attribute_path: Optional[str] = None,
             search_the_latest_time_stamp_from_events_list: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if paging_type is None and 'pagingType' in kwargs:
            paging_type = kwargs['pagingType']
        if paging_type is None:
            raise TypeError("Missing 'paging_type' argument")
        if next_page_para_name is None and 'nextPageParaName' in kwargs:
            next_page_para_name = kwargs['nextPageParaName']
        if next_page_token_json_path is None and 'nextPageTokenJsonPath' in kwargs:
            next_page_token_json_path = kwargs['nextPageTokenJsonPath']
        if page_count_attribute_path is None and 'pageCountAttributePath' in kwargs:
            page_count_attribute_path = kwargs['pageCountAttributePath']
        if page_size is None and 'pageSize' in kwargs:
            page_size = kwargs['pageSize']
        if page_size_para_name is None and 'pageSizeParaName' in kwargs:
            page_size_para_name = kwargs['pageSizeParaName']
        if page_time_stamp_attribute_path is None and 'pageTimeStampAttributePath' in kwargs:
            page_time_stamp_attribute_path = kwargs['pageTimeStampAttributePath']
        if page_total_count_attribute_path is None and 'pageTotalCountAttributePath' in kwargs:
            page_total_count_attribute_path = kwargs['pageTotalCountAttributePath']
        if search_the_latest_time_stamp_from_events_list is None and 'searchTheLatestTimeStampFromEventsList' in kwargs:
            search_the_latest_time_stamp_from_events_list = kwargs['searchTheLatestTimeStampFromEventsList']

        _setter("paging_type", paging_type)
        if next_page_para_name is not None:
            _setter("next_page_para_name", next_page_para_name)
        if next_page_token_json_path is not None:
            _setter("next_page_token_json_path", next_page_token_json_path)
        if page_count_attribute_path is not None:
            _setter("page_count_attribute_path", page_count_attribute_path)
        if page_size is not None:
            _setter("page_size", page_size)
        if page_size_para_name is not None:
            _setter("page_size_para_name", page_size_para_name)
        if page_time_stamp_attribute_path is not None:
            _setter("page_time_stamp_attribute_path", page_time_stamp_attribute_path)
        if page_total_count_attribute_path is not None:
            _setter("page_total_count_attribute_path", page_total_count_attribute_path)
        if search_the_latest_time_stamp_from_events_list is not None:
            _setter("search_the_latest_time_stamp_from_events_list", search_the_latest_time_stamp_from_events_list)

    @property
    @pulumi.getter(name="pagingType")
    def paging_type(self) -> str:
        """
        Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'
        """
        return pulumi.get(self, "paging_type")

    @property
    @pulumi.getter(name="nextPageParaName")
    def next_page_para_name(self) -> Optional[str]:
        """
        Defines the name of a next page attribute
        """
        return pulumi.get(self, "next_page_para_name")

    @property
    @pulumi.getter(name="nextPageTokenJsonPath")
    def next_page_token_json_path(self) -> Optional[str]:
        """
        Defines the path to a next page token JSON
        """
        return pulumi.get(self, "next_page_token_json_path")

    @property
    @pulumi.getter(name="pageCountAttributePath")
    def page_count_attribute_path(self) -> Optional[str]:
        """
        Defines the path to a page count attribute
        """
        return pulumi.get(self, "page_count_attribute_path")

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[int]:
        """
        Defines the paging size
        """
        return pulumi.get(self, "page_size")

    @property
    @pulumi.getter(name="pageSizeParaName")
    def page_size_para_name(self) -> Optional[str]:
        """
        Defines the name of the page size parameter
        """
        return pulumi.get(self, "page_size_para_name")

    @property
    @pulumi.getter(name="pageTimeStampAttributePath")
    def page_time_stamp_attribute_path(self) -> Optional[str]:
        """
        Defines the path to a paging time stamp attribute
        """
        return pulumi.get(self, "page_time_stamp_attribute_path")

    @property
    @pulumi.getter(name="pageTotalCountAttributePath")
    def page_total_count_attribute_path(self) -> Optional[str]:
        """
        Defines the path to a page total count attribute
        """
        return pulumi.get(self, "page_total_count_attribute_path")

    @property
    @pulumi.getter(name="searchTheLatestTimeStampFromEventsList")
    def search_the_latest_time_stamp_from_events_list(self) -> Optional[str]:
        """
        Determines whether to search for the latest time stamp in the events list
        """
        return pulumi.get(self, "search_the_latest_time_stamp_from_events_list")


@pulumi.output_type
class CodelessConnectorPollingRequestPropertiesResponse(dict):
    """
    Describe the request properties needed to successfully pull from the server
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiEndpoint":
            suggest = "api_endpoint"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "queryTimeFormat":
            suggest = "query_time_format"
        elif key == "queryWindowInMin":
            suggest = "query_window_in_min"
        elif key == "endTimeAttributeName":
            suggest = "end_time_attribute_name"
        elif key == "queryParameters":
            suggest = "query_parameters"
        elif key == "queryParametersTemplate":
            suggest = "query_parameters_template"
        elif key == "rateLimitQps":
            suggest = "rate_limit_qps"
        elif key == "retryCount":
            suggest = "retry_count"
        elif key == "startTimeAttributeName":
            suggest = "start_time_attribute_name"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodelessConnectorPollingRequestPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodelessConnectorPollingRequestPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodelessConnectorPollingRequestPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_endpoint: str,
                 http_method: str,
                 query_time_format: str,
                 query_window_in_min: int,
                 end_time_attribute_name: Optional[str] = None,
                 headers: Optional[Any] = None,
                 query_parameters: Optional[Any] = None,
                 query_parameters_template: Optional[str] = None,
                 rate_limit_qps: Optional[int] = None,
                 retry_count: Optional[int] = None,
                 start_time_attribute_name: Optional[str] = None,
                 timeout_in_seconds: Optional[int] = None):
        """
        Describe the request properties needed to successfully pull from the server
        :param str api_endpoint: Describe the endpoint we should pull the data from
        :param str http_method: The http method type we will use in the poll request, GET or POST
        :param str query_time_format: The time format will be used the query events in a specific window
        :param int query_window_in_min: The window interval we will use the pull the data
        :param str end_time_attribute_name: This will be used the query events from the end of the time window
        :param Any headers: Describe the headers sent in the poll request
        :param Any query_parameters: Describe the query parameters sent in the poll request
        :param str query_parameters_template: For advanced scenarios for example user name/password embedded in nested JSON payload
        :param int rate_limit_qps: Defines the rate limit QPS
        :param int retry_count: Describe the amount of time we should try and poll the data in case of failure
        :param str start_time_attribute_name: This will be used the query events from a start of the time window
        :param int timeout_in_seconds: The number of seconds we will consider as a request timeout
        """
        CodelessConnectorPollingRequestPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_endpoint=api_endpoint,
            http_method=http_method,
            query_time_format=query_time_format,
            query_window_in_min=query_window_in_min,
            end_time_attribute_name=end_time_attribute_name,
            headers=headers,
            query_parameters=query_parameters,
            query_parameters_template=query_parameters_template,
            rate_limit_qps=rate_limit_qps,
            retry_count=retry_count,
            start_time_attribute_name=start_time_attribute_name,
            timeout_in_seconds=timeout_in_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_endpoint: Optional[str] = None,
             http_method: Optional[str] = None,
             query_time_format: Optional[str] = None,
             query_window_in_min: Optional[int] = None,
             end_time_attribute_name: Optional[str] = None,
             headers: Optional[Any] = None,
             query_parameters: Optional[Any] = None,
             query_parameters_template: Optional[str] = None,
             rate_limit_qps: Optional[int] = None,
             retry_count: Optional[int] = None,
             start_time_attribute_name: Optional[str] = None,
             timeout_in_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if api_endpoint is None and 'apiEndpoint' in kwargs:
            api_endpoint = kwargs['apiEndpoint']
        if api_endpoint is None:
            raise TypeError("Missing 'api_endpoint' argument")
        if http_method is None and 'httpMethod' in kwargs:
            http_method = kwargs['httpMethod']
        if http_method is None:
            raise TypeError("Missing 'http_method' argument")
        if query_time_format is None and 'queryTimeFormat' in kwargs:
            query_time_format = kwargs['queryTimeFormat']
        if query_time_format is None:
            raise TypeError("Missing 'query_time_format' argument")
        if query_window_in_min is None and 'queryWindowInMin' in kwargs:
            query_window_in_min = kwargs['queryWindowInMin']
        if query_window_in_min is None:
            raise TypeError("Missing 'query_window_in_min' argument")
        if end_time_attribute_name is None and 'endTimeAttributeName' in kwargs:
            end_time_attribute_name = kwargs['endTimeAttributeName']
        if query_parameters is None and 'queryParameters' in kwargs:
            query_parameters = kwargs['queryParameters']
        if query_parameters_template is None and 'queryParametersTemplate' in kwargs:
            query_parameters_template = kwargs['queryParametersTemplate']
        if rate_limit_qps is None and 'rateLimitQps' in kwargs:
            rate_limit_qps = kwargs['rateLimitQps']
        if retry_count is None and 'retryCount' in kwargs:
            retry_count = kwargs['retryCount']
        if start_time_attribute_name is None and 'startTimeAttributeName' in kwargs:
            start_time_attribute_name = kwargs['startTimeAttributeName']
        if timeout_in_seconds is None and 'timeoutInSeconds' in kwargs:
            timeout_in_seconds = kwargs['timeoutInSeconds']

        _setter("api_endpoint", api_endpoint)
        _setter("http_method", http_method)
        _setter("query_time_format", query_time_format)
        _setter("query_window_in_min", query_window_in_min)
        if end_time_attribute_name is not None:
            _setter("end_time_attribute_name", end_time_attribute_name)
        if headers is not None:
            _setter("headers", headers)
        if query_parameters is not None:
            _setter("query_parameters", query_parameters)
        if query_parameters_template is not None:
            _setter("query_parameters_template", query_parameters_template)
        if rate_limit_qps is not None:
            _setter("rate_limit_qps", rate_limit_qps)
        if retry_count is not None:
            _setter("retry_count", retry_count)
        if start_time_attribute_name is not None:
            _setter("start_time_attribute_name", start_time_attribute_name)
        if timeout_in_seconds is not None:
            _setter("timeout_in_seconds", timeout_in_seconds)

    @property
    @pulumi.getter(name="apiEndpoint")
    def api_endpoint(self) -> str:
        """
        Describe the endpoint we should pull the data from
        """
        return pulumi.get(self, "api_endpoint")

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> str:
        """
        The http method type we will use in the poll request, GET or POST
        """
        return pulumi.get(self, "http_method")

    @property
    @pulumi.getter(name="queryTimeFormat")
    def query_time_format(self) -> str:
        """
        The time format will be used the query events in a specific window
        """
        return pulumi.get(self, "query_time_format")

    @property
    @pulumi.getter(name="queryWindowInMin")
    def query_window_in_min(self) -> int:
        """
        The window interval we will use the pull the data
        """
        return pulumi.get(self, "query_window_in_min")

    @property
    @pulumi.getter(name="endTimeAttributeName")
    def end_time_attribute_name(self) -> Optional[str]:
        """
        This will be used the query events from the end of the time window
        """
        return pulumi.get(self, "end_time_attribute_name")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Any]:
        """
        Describe the headers sent in the poll request
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Any]:
        """
        Describe the query parameters sent in the poll request
        """
        return pulumi.get(self, "query_parameters")

    @property
    @pulumi.getter(name="queryParametersTemplate")
    def query_parameters_template(self) -> Optional[str]:
        """
        For advanced scenarios for example user name/password embedded in nested JSON payload
        """
        return pulumi.get(self, "query_parameters_template")

    @property
    @pulumi.getter(name="rateLimitQps")
    def rate_limit_qps(self) -> Optional[int]:
        """
        Defines the rate limit QPS
        """
        return pulumi.get(self, "rate_limit_qps")

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[int]:
        """
        Describe the amount of time we should try and poll the data in case of failure
        """
        return pulumi.get(self, "retry_count")

    @property
    @pulumi.getter(name="startTimeAttributeName")
    def start_time_attribute_name(self) -> Optional[str]:
        """
        This will be used the query events from a start of the time window
        """
        return pulumi.get(self, "start_time_attribute_name")

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[int]:
        """
        The number of seconds we will consider as a request timeout
        """
        return pulumi.get(self, "timeout_in_seconds")


@pulumi.output_type
class CodelessConnectorPollingResponsePropertiesResponse(dict):
    """
    Describes the response from the external server
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventsJsonPaths":
            suggest = "events_json_paths"
        elif key == "isGzipCompressed":
            suggest = "is_gzip_compressed"
        elif key == "successStatusJsonPath":
            suggest = "success_status_json_path"
        elif key == "successStatusValue":
            suggest = "success_status_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodelessConnectorPollingResponsePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodelessConnectorPollingResponsePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodelessConnectorPollingResponsePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 events_json_paths: Sequence[str],
                 is_gzip_compressed: Optional[bool] = None,
                 success_status_json_path: Optional[str] = None,
                 success_status_value: Optional[str] = None):
        """
        Describes the response from the external server
        :param Sequence[str] events_json_paths: Describes the path we should extract the data in the response
        :param bool is_gzip_compressed: Describes if the data in the response is Gzip
        :param str success_status_json_path: Describes the path we should extract the status code in the response
        :param str success_status_value: Describes the path we should extract the status value in the response
        """
        CodelessConnectorPollingResponsePropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            events_json_paths=events_json_paths,
            is_gzip_compressed=is_gzip_compressed,
            success_status_json_path=success_status_json_path,
            success_status_value=success_status_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             events_json_paths: Optional[Sequence[str]] = None,
             is_gzip_compressed: Optional[bool] = None,
             success_status_json_path: Optional[str] = None,
             success_status_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if events_json_paths is None and 'eventsJsonPaths' in kwargs:
            events_json_paths = kwargs['eventsJsonPaths']
        if events_json_paths is None:
            raise TypeError("Missing 'events_json_paths' argument")
        if is_gzip_compressed is None and 'isGzipCompressed' in kwargs:
            is_gzip_compressed = kwargs['isGzipCompressed']
        if success_status_json_path is None and 'successStatusJsonPath' in kwargs:
            success_status_json_path = kwargs['successStatusJsonPath']
        if success_status_value is None and 'successStatusValue' in kwargs:
            success_status_value = kwargs['successStatusValue']

        _setter("events_json_paths", events_json_paths)
        if is_gzip_compressed is not None:
            _setter("is_gzip_compressed", is_gzip_compressed)
        if success_status_json_path is not None:
            _setter("success_status_json_path", success_status_json_path)
        if success_status_value is not None:
            _setter("success_status_value", success_status_value)

    @property
    @pulumi.getter(name="eventsJsonPaths")
    def events_json_paths(self) -> Sequence[str]:
        """
        Describes the path we should extract the data in the response
        """
        return pulumi.get(self, "events_json_paths")

    @property
    @pulumi.getter(name="isGzipCompressed")
    def is_gzip_compressed(self) -> Optional[bool]:
        """
        Describes if the data in the response is Gzip
        """
        return pulumi.get(self, "is_gzip_compressed")

    @property
    @pulumi.getter(name="successStatusJsonPath")
    def success_status_json_path(self) -> Optional[str]:
        """
        Describes the path we should extract the status code in the response
        """
        return pulumi.get(self, "success_status_json_path")

    @property
    @pulumi.getter(name="successStatusValue")
    def success_status_value(self) -> Optional[str]:
        """
        Describes the path we should extract the status value in the response
        """
        return pulumi.get(self, "success_status_value")


@pulumi.output_type
class CodelessUiConnectorConfigPropertiesResponse(dict):
    """
    Config to describe the instructions blade
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectivityCriteria":
            suggest = "connectivity_criteria"
        elif key == "dataTypes":
            suggest = "data_types"
        elif key == "descriptionMarkdown":
            suggest = "description_markdown"
        elif key == "graphQueries":
            suggest = "graph_queries"
        elif key == "graphQueriesTableName":
            suggest = "graph_queries_table_name"
        elif key == "instructionSteps":
            suggest = "instruction_steps"
        elif key == "sampleQueries":
            suggest = "sample_queries"
        elif key == "customImage":
            suggest = "custom_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodelessUiConnectorConfigPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodelessUiConnectorConfigPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodelessUiConnectorConfigPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability: 'outputs.AvailabilityResponse',
                 connectivity_criteria: Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseConnectivityCriteria'],
                 data_types: Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseDataTypes'],
                 description_markdown: str,
                 graph_queries: Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseGraphQueries'],
                 graph_queries_table_name: str,
                 instruction_steps: Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseInstructionSteps'],
                 permissions: 'outputs.PermissionsResponse',
                 publisher: str,
                 sample_queries: Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseSampleQueries'],
                 title: str,
                 custom_image: Optional[str] = None):
        """
        Config to describe the instructions blade
        :param 'AvailabilityResponse' availability: Connector Availability Status
        :param Sequence['CodelessUiConnectorConfigPropertiesResponseConnectivityCriteria'] connectivity_criteria: Define the way the connector check connectivity
        :param Sequence['CodelessUiConnectorConfigPropertiesResponseDataTypes'] data_types: Data types to check for last data received
        :param str description_markdown: Connector description
        :param Sequence['CodelessUiConnectorConfigPropertiesResponseGraphQueries'] graph_queries: The graph query to show the current data status
        :param str graph_queries_table_name: Name of the table the connector will insert the data to
        :param Sequence['CodelessUiConnectorConfigPropertiesResponseInstructionSteps'] instruction_steps: Instruction steps to enable the connector
        :param 'PermissionsResponse' permissions: Permissions required for the connector
        :param str publisher: Connector publisher name
        :param Sequence['CodelessUiConnectorConfigPropertiesResponseSampleQueries'] sample_queries: The sample queries for the connector
        :param str title: Connector blade title
        :param str custom_image: An optional custom image to be used when displaying the connector within Azure Sentinel's connector's gallery
        """
        CodelessUiConnectorConfigPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability=availability,
            connectivity_criteria=connectivity_criteria,
            data_types=data_types,
            description_markdown=description_markdown,
            graph_queries=graph_queries,
            graph_queries_table_name=graph_queries_table_name,
            instruction_steps=instruction_steps,
            permissions=permissions,
            publisher=publisher,
            sample_queries=sample_queries,
            title=title,
            custom_image=custom_image,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability: Optional['outputs.AvailabilityResponse'] = None,
             connectivity_criteria: Optional[Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseConnectivityCriteria']] = None,
             data_types: Optional[Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseDataTypes']] = None,
             description_markdown: Optional[str] = None,
             graph_queries: Optional[Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseGraphQueries']] = None,
             graph_queries_table_name: Optional[str] = None,
             instruction_steps: Optional[Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseInstructionSteps']] = None,
             permissions: Optional['outputs.PermissionsResponse'] = None,
             publisher: Optional[str] = None,
             sample_queries: Optional[Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseSampleQueries']] = None,
             title: Optional[str] = None,
             custom_image: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if availability is None:
            raise TypeError("Missing 'availability' argument")
        if connectivity_criteria is None and 'connectivityCriteria' in kwargs:
            connectivity_criteria = kwargs['connectivityCriteria']
        if connectivity_criteria is None:
            raise TypeError("Missing 'connectivity_criteria' argument")
        if data_types is None and 'dataTypes' in kwargs:
            data_types = kwargs['dataTypes']
        if data_types is None:
            raise TypeError("Missing 'data_types' argument")
        if description_markdown is None and 'descriptionMarkdown' in kwargs:
            description_markdown = kwargs['descriptionMarkdown']
        if description_markdown is None:
            raise TypeError("Missing 'description_markdown' argument")
        if graph_queries is None and 'graphQueries' in kwargs:
            graph_queries = kwargs['graphQueries']
        if graph_queries is None:
            raise TypeError("Missing 'graph_queries' argument")
        if graph_queries_table_name is None and 'graphQueriesTableName' in kwargs:
            graph_queries_table_name = kwargs['graphQueriesTableName']
        if graph_queries_table_name is None:
            raise TypeError("Missing 'graph_queries_table_name' argument")
        if instruction_steps is None and 'instructionSteps' in kwargs:
            instruction_steps = kwargs['instructionSteps']
        if instruction_steps is None:
            raise TypeError("Missing 'instruction_steps' argument")
        if permissions is None:
            raise TypeError("Missing 'permissions' argument")
        if publisher is None:
            raise TypeError("Missing 'publisher' argument")
        if sample_queries is None and 'sampleQueries' in kwargs:
            sample_queries = kwargs['sampleQueries']
        if sample_queries is None:
            raise TypeError("Missing 'sample_queries' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")
        if custom_image is None and 'customImage' in kwargs:
            custom_image = kwargs['customImage']

        _setter("availability", availability)
        _setter("connectivity_criteria", connectivity_criteria)
        _setter("data_types", data_types)
        _setter("description_markdown", description_markdown)
        _setter("graph_queries", graph_queries)
        _setter("graph_queries_table_name", graph_queries_table_name)
        _setter("instruction_steps", instruction_steps)
        _setter("permissions", permissions)
        _setter("publisher", publisher)
        _setter("sample_queries", sample_queries)
        _setter("title", title)
        if custom_image is not None:
            _setter("custom_image", custom_image)

    @property
    @pulumi.getter
    def availability(self) -> 'outputs.AvailabilityResponse':
        """
        Connector Availability Status
        """
        return pulumi.get(self, "availability")

    @property
    @pulumi.getter(name="connectivityCriteria")
    def connectivity_criteria(self) -> Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseConnectivityCriteria']:
        """
        Define the way the connector check connectivity
        """
        return pulumi.get(self, "connectivity_criteria")

    @property
    @pulumi.getter(name="dataTypes")
    def data_types(self) -> Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseDataTypes']:
        """
        Data types to check for last data received
        """
        return pulumi.get(self, "data_types")

    @property
    @pulumi.getter(name="descriptionMarkdown")
    def description_markdown(self) -> str:
        """
        Connector description
        """
        return pulumi.get(self, "description_markdown")

    @property
    @pulumi.getter(name="graphQueries")
    def graph_queries(self) -> Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseGraphQueries']:
        """
        The graph query to show the current data status
        """
        return pulumi.get(self, "graph_queries")

    @property
    @pulumi.getter(name="graphQueriesTableName")
    def graph_queries_table_name(self) -> str:
        """
        Name of the table the connector will insert the data to
        """
        return pulumi.get(self, "graph_queries_table_name")

    @property
    @pulumi.getter(name="instructionSteps")
    def instruction_steps(self) -> Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseInstructionSteps']:
        """
        Instruction steps to enable the connector
        """
        return pulumi.get(self, "instruction_steps")

    @property
    @pulumi.getter
    def permissions(self) -> 'outputs.PermissionsResponse':
        """
        Permissions required for the connector
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Connector publisher name
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter(name="sampleQueries")
    def sample_queries(self) -> Sequence['outputs.CodelessUiConnectorConfigPropertiesResponseSampleQueries']:
        """
        The sample queries for the connector
        """
        return pulumi.get(self, "sample_queries")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        Connector blade title
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="customImage")
    def custom_image(self) -> Optional[str]:
        """
        An optional custom image to be used when displaying the connector within Azure Sentinel's connector's gallery
        """
        return pulumi.get(self, "custom_image")


@pulumi.output_type
class CodelessUiConnectorConfigPropertiesResponseConnectivityCriteria(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 value: Optional[Sequence[str]] = None):
        """
        :param str type: type of connectivity
        :param Sequence[str] value: Queries for checking connectivity
        """
        CodelessUiConnectorConfigPropertiesResponseConnectivityCriteria._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             value: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if type is not None:
            _setter("type", type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of connectivity
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[Sequence[str]]:
        """
        Queries for checking connectivity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CodelessUiConnectorConfigPropertiesResponseDataTypes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastDataReceivedQuery":
            suggest = "last_data_received_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodelessUiConnectorConfigPropertiesResponseDataTypes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodelessUiConnectorConfigPropertiesResponseDataTypes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodelessUiConnectorConfigPropertiesResponseDataTypes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_data_received_query: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str last_data_received_query: Query for indicate last data received
        :param str name: Name of the data type to show in the graph. can be use with {{graphQueriesTableName}} placeholder
        """
        CodelessUiConnectorConfigPropertiesResponseDataTypes._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            last_data_received_query=last_data_received_query,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             last_data_received_query: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if last_data_received_query is None and 'lastDataReceivedQuery' in kwargs:
            last_data_received_query = kwargs['lastDataReceivedQuery']

        if last_data_received_query is not None:
            _setter("last_data_received_query", last_data_received_query)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="lastDataReceivedQuery")
    def last_data_received_query(self) -> Optional[str]:
        """
        Query for indicate last data received
        """
        return pulumi.get(self, "last_data_received_query")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the data type to show in the graph. can be use with {{graphQueriesTableName}} placeholder
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CodelessUiConnectorConfigPropertiesResponseGraphQueries(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseQuery":
            suggest = "base_query"
        elif key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodelessUiConnectorConfigPropertiesResponseGraphQueries. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodelessUiConnectorConfigPropertiesResponseGraphQueries.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodelessUiConnectorConfigPropertiesResponseGraphQueries.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_query: Optional[str] = None,
                 legend: Optional[str] = None,
                 metric_name: Optional[str] = None):
        """
        :param str base_query: The base query for the graph
        :param str legend: The legend for the graph
        :param str metric_name: the metric that the query is checking
        """
        CodelessUiConnectorConfigPropertiesResponseGraphQueries._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base_query=base_query,
            legend=legend,
            metric_name=metric_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base_query: Optional[str] = None,
             legend: Optional[str] = None,
             metric_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if base_query is None and 'baseQuery' in kwargs:
            base_query = kwargs['baseQuery']
        if metric_name is None and 'metricName' in kwargs:
            metric_name = kwargs['metricName']

        if base_query is not None:
            _setter("base_query", base_query)
        if legend is not None:
            _setter("legend", legend)
        if metric_name is not None:
            _setter("metric_name", metric_name)

    @property
    @pulumi.getter(name="baseQuery")
    def base_query(self) -> Optional[str]:
        """
        The base query for the graph
        """
        return pulumi.get(self, "base_query")

    @property
    @pulumi.getter
    def legend(self) -> Optional[str]:
        """
        The legend for the graph
        """
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        the metric that the query is checking
        """
        return pulumi.get(self, "metric_name")


@pulumi.output_type
class CodelessUiConnectorConfigPropertiesResponseInstructionSteps(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 instructions: Optional[Sequence['outputs.InstructionStepsResponseInstructions']] = None,
                 title: Optional[str] = None):
        """
        :param str description: Instruction step description
        :param Sequence['InstructionStepsResponseInstructions'] instructions: Instruction step details
        :param str title: Instruction step title
        """
        CodelessUiConnectorConfigPropertiesResponseInstructionSteps._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            instructions=instructions,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             instructions: Optional[Sequence['outputs.InstructionStepsResponseInstructions']] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if description is not None:
            _setter("description", description)
        if instructions is not None:
            _setter("instructions", instructions)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Instruction step description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def instructions(self) -> Optional[Sequence['outputs.InstructionStepsResponseInstructions']]:
        """
        Instruction step details
        """
        return pulumi.get(self, "instructions")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Instruction step title
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class CodelessUiConnectorConfigPropertiesResponseSampleQueries(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 query: Optional[str] = None):
        """
        :param str description: The sample query description
        :param str query: the sample query
        """
        CodelessUiConnectorConfigPropertiesResponseSampleQueries._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if description is not None:
            _setter("description", description)
        if query is not None:
            _setter("query", query)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The sample query description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        the sample query
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DCRConfigurationResponse(dict):
    """
    The configuration of the destination of the data.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataCollectionEndpoint":
            suggest = "data_collection_endpoint"
        elif key == "dataCollectionRuleImmutableId":
            suggest = "data_collection_rule_immutable_id"
        elif key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DCRConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DCRConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DCRConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_collection_endpoint: str,
                 data_collection_rule_immutable_id: str,
                 stream_name: str):
        """
        The configuration of the destination of the data.
        :param str data_collection_endpoint: Represents the data collection ingestion endpoint in log analytics.
        :param str data_collection_rule_immutable_id: The data collection rule immutable id, the rule defines the transformation and data destination.
        :param str stream_name: The stream we are sending the data to.
        """
        DCRConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_collection_endpoint=data_collection_endpoint,
            data_collection_rule_immutable_id=data_collection_rule_immutable_id,
            stream_name=stream_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_collection_endpoint: Optional[str] = None,
             data_collection_rule_immutable_id: Optional[str] = None,
             stream_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_collection_endpoint is None and 'dataCollectionEndpoint' in kwargs:
            data_collection_endpoint = kwargs['dataCollectionEndpoint']
        if data_collection_endpoint is None:
            raise TypeError("Missing 'data_collection_endpoint' argument")
        if data_collection_rule_immutable_id is None and 'dataCollectionRuleImmutableId' in kwargs:
            data_collection_rule_immutable_id = kwargs['dataCollectionRuleImmutableId']
        if data_collection_rule_immutable_id is None:
            raise TypeError("Missing 'data_collection_rule_immutable_id' argument")
        if stream_name is None and 'streamName' in kwargs:
            stream_name = kwargs['streamName']
        if stream_name is None:
            raise TypeError("Missing 'stream_name' argument")

        _setter("data_collection_endpoint", data_collection_endpoint)
        _setter("data_collection_rule_immutable_id", data_collection_rule_immutable_id)
        _setter("stream_name", stream_name)

    @property
    @pulumi.getter(name="dataCollectionEndpoint")
    def data_collection_endpoint(self) -> str:
        """
        Represents the data collection ingestion endpoint in log analytics.
        """
        return pulumi.get(self, "data_collection_endpoint")

    @property
    @pulumi.getter(name="dataCollectionRuleImmutableId")
    def data_collection_rule_immutable_id(self) -> str:
        """
        The data collection rule immutable id, the rule defines the transformation and data destination.
        """
        return pulumi.get(self, "data_collection_rule_immutable_id")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        """
        The stream we are sending the data to.
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class DataConnectorDataTypeCommonResponse(dict):
    """
    Common field for data type in data connectors.
    """
    def __init__(__self__, *,
                 state: str):
        """
        Common field for data type in data connectors.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        DataConnectorDataTypeCommonResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class Dynamics365DataConnectorDataTypesResponse(dict):
    """
    The available data types for Dynamics365 data connector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamics365CdsActivities":
            suggest = "dynamics365_cds_activities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Dynamics365DataConnectorDataTypesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Dynamics365DataConnectorDataTypesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Dynamics365DataConnectorDataTypesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamics365_cds_activities: 'outputs.Dynamics365DataConnectorDataTypesResponseDynamics365CdsActivities'):
        """
        The available data types for Dynamics365 data connector.
        :param 'Dynamics365DataConnectorDataTypesResponseDynamics365CdsActivities' dynamics365_cds_activities: Common Data Service data type connection.
        """
        Dynamics365DataConnectorDataTypesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dynamics365_cds_activities=dynamics365_cds_activities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dynamics365_cds_activities: Optional['outputs.Dynamics365DataConnectorDataTypesResponseDynamics365CdsActivities'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if dynamics365_cds_activities is None and 'dynamics365CdsActivities' in kwargs:
            dynamics365_cds_activities = kwargs['dynamics365CdsActivities']
        if dynamics365_cds_activities is None:
            raise TypeError("Missing 'dynamics365_cds_activities' argument")

        _setter("dynamics365_cds_activities", dynamics365_cds_activities)

    @property
    @pulumi.getter(name="dynamics365CdsActivities")
    def dynamics365_cds_activities(self) -> 'outputs.Dynamics365DataConnectorDataTypesResponseDynamics365CdsActivities':
        """
        Common Data Service data type connection.
        """
        return pulumi.get(self, "dynamics365_cds_activities")


@pulumi.output_type
class Dynamics365DataConnectorDataTypesResponseDynamics365CdsActivities(dict):
    """
    Common Data Service data type connection.
    """
    def __init__(__self__, *,
                 state: str):
        """
        Common Data Service data type connection.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        Dynamics365DataConnectorDataTypesResponseDynamics365CdsActivities._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class EntityFieldMappingResponse(dict):
    """
    Map identifiers of a single entity
    """
    def __init__(__self__, *,
                 identifier: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Map identifiers of a single entity
        :param str identifier: Alert V3 identifier
        :param str value: The value of the identifier
        """
        EntityFieldMappingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identifier=identifier,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identifier: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if identifier is not None:
            _setter("identifier", identifier)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def identifier(self) -> Optional[str]:
        """
        Alert V3 identifier
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the identifier
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EntityInsightItemResponse(dict):
    """
    Entity insight Item.
    """
    def __init__(__self__, *,
                 chart_query_results: Optional[Sequence['outputs.InsightsTableResultResponse']] = None,
                 query_id: Optional[str] = None,
                 query_time_interval: Optional['outputs.EntityInsightItemResponseQueryTimeInterval'] = None,
                 table_query_results: Optional['outputs.InsightsTableResultResponse'] = None):
        """
        Entity insight Item.
        :param Sequence['InsightsTableResultResponse'] chart_query_results: Query results for table insights query.
        :param str query_id: The query id of the insight
        :param 'EntityInsightItemResponseQueryTimeInterval' query_time_interval: The Time interval that the query actually executed on.
        :param 'InsightsTableResultResponse' table_query_results: Query results for table insights query.
        """
        EntityInsightItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            chart_query_results=chart_query_results,
            query_id=query_id,
            query_time_interval=query_time_interval,
            table_query_results=table_query_results,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             chart_query_results: Optional[Sequence['outputs.InsightsTableResultResponse']] = None,
             query_id: Optional[str] = None,
             query_time_interval: Optional['outputs.EntityInsightItemResponseQueryTimeInterval'] = None,
             table_query_results: Optional['outputs.InsightsTableResultResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if chart_query_results is None and 'chartQueryResults' in kwargs:
            chart_query_results = kwargs['chartQueryResults']
        if query_id is None and 'queryId' in kwargs:
            query_id = kwargs['queryId']
        if query_time_interval is None and 'queryTimeInterval' in kwargs:
            query_time_interval = kwargs['queryTimeInterval']
        if table_query_results is None and 'tableQueryResults' in kwargs:
            table_query_results = kwargs['tableQueryResults']

        if chart_query_results is not None:
            _setter("chart_query_results", chart_query_results)
        if query_id is not None:
            _setter("query_id", query_id)
        if query_time_interval is not None:
            _setter("query_time_interval", query_time_interval)
        if table_query_results is not None:
            _setter("table_query_results", table_query_results)

    @property
    @pulumi.getter(name="chartQueryResults")
    def chart_query_results(self) -> Optional[Sequence['outputs.InsightsTableResultResponse']]:
        """
        Query results for table insights query.
        """
        return pulumi.get(self, "chart_query_results")

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> Optional[str]:
        """
        The query id of the insight
        """
        return pulumi.get(self, "query_id")

    @property
    @pulumi.getter(name="queryTimeInterval")
    def query_time_interval(self) -> Optional['outputs.EntityInsightItemResponseQueryTimeInterval']:
        """
        The Time interval that the query actually executed on.
        """
        return pulumi.get(self, "query_time_interval")

    @property
    @pulumi.getter(name="tableQueryResults")
    def table_query_results(self) -> Optional['outputs.InsightsTableResultResponse']:
        """
        Query results for table insights query.
        """
        return pulumi.get(self, "table_query_results")


@pulumi.output_type
class EntityInsightItemResponseQueryTimeInterval(dict):
    """
    The Time interval that the query actually executed on.
    """
    def __init__(__self__, *,
                 end_time: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        The Time interval that the query actually executed on.
        :param str end_time: Insight query end time
        :param str start_time: Insight query start time
        """
        EntityInsightItemResponseQueryTimeInterval._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_time=end_time,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_time: Optional[str] = None,
             start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end_time is None and 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']

        if end_time is not None:
            _setter("end_time", end_time)
        if start_time is not None:
            _setter("start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        Insight query end time
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Insight query start time
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class EntityMappingResponse(dict):
    """
    Single entity mapping for the alert rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "fieldMappings":
            suggest = "field_mappings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntityMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntityMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntityMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: Optional[str] = None,
                 field_mappings: Optional[Sequence['outputs.FieldMappingResponse']] = None):
        """
        Single entity mapping for the alert rule
        :param str entity_type: The V3 type of the mapped entity
        :param Sequence['FieldMappingResponse'] field_mappings: array of field mappings for the given entity mapping
        """
        EntityMappingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            entity_type=entity_type,
            field_mappings=field_mappings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             entity_type: Optional[str] = None,
             field_mappings: Optional[Sequence['outputs.FieldMappingResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if entity_type is None and 'entityType' in kwargs:
            entity_type = kwargs['entityType']
        if field_mappings is None and 'fieldMappings' in kwargs:
            field_mappings = kwargs['fieldMappings']

        if entity_type is not None:
            _setter("entity_type", entity_type)
        if field_mappings is not None:
            _setter("field_mappings", field_mappings)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[str]:
        """
        The V3 type of the mapped entity
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[Sequence['outputs.FieldMappingResponse']]:
        """
        array of field mappings for the given entity mapping
        """
        return pulumi.get(self, "field_mappings")


@pulumi.output_type
class EventGroupingSettingsResponse(dict):
    """
    Event grouping settings property bag.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationKind":
            suggest = "aggregation_kind"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventGroupingSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventGroupingSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventGroupingSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_kind: Optional[str] = None):
        """
        Event grouping settings property bag.
        :param str aggregation_kind: The event grouping aggregation kinds
        """
        EventGroupingSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation_kind=aggregation_kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation_kind: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aggregation_kind is None and 'aggregationKind' in kwargs:
            aggregation_kind = kwargs['aggregationKind']

        if aggregation_kind is not None:
            _setter("aggregation_kind", aggregation_kind)

    @property
    @pulumi.getter(name="aggregationKind")
    def aggregation_kind(self) -> Optional[str]:
        """
        The event grouping aggregation kinds
        """
        return pulumi.get(self, "aggregation_kind")


@pulumi.output_type
class FieldMappingResponse(dict):
    """
    A single field mapping of the mapped entity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FieldMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FieldMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FieldMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: Optional[str] = None,
                 identifier: Optional[str] = None):
        """
        A single field mapping of the mapped entity
        :param str column_name: the column name to be mapped to the identifier
        :param str identifier: the V3 identifier of the entity
        """
        FieldMappingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            identifier=identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']

        if column_name is not None:
            _setter("column_name", column_name)
        if identifier is not None:
            _setter("identifier", identifier)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[str]:
        """
        the column name to be mapped to the identifier
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def identifier(self) -> Optional[str]:
        """
        the V3 identifier of the entity
        """
        return pulumi.get(self, "identifier")


@pulumi.output_type
class FileMetadataResponse(dict):
    """
    Represents a file.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteStatus":
            suggest = "delete_status"
        elif key == "fileContentUri":
            suggest = "file_content_uri"
        elif key == "fileFormat":
            suggest = "file_format"
        elif key == "fileName":
            suggest = "file_name"
        elif key == "fileSize":
            suggest = "file_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_status: str,
                 file_content_uri: str,
                 file_format: Optional[str] = None,
                 file_name: Optional[str] = None,
                 file_size: Optional[int] = None):
        """
        Represents a file.
        :param str delete_status: Indicates whether the file was deleted from the storage account.
        :param str file_content_uri: A URI with a valid SAS token to allow uploading / downloading the file.
        :param str file_format: The format of the file
        :param str file_name: The name of the file.
        :param int file_size: The size of the file.
        """
        FileMetadataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_status=delete_status,
            file_content_uri=file_content_uri,
            file_format=file_format,
            file_name=file_name,
            file_size=file_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_status: Optional[str] = None,
             file_content_uri: Optional[str] = None,
             file_format: Optional[str] = None,
             file_name: Optional[str] = None,
             file_size: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if delete_status is None and 'deleteStatus' in kwargs:
            delete_status = kwargs['deleteStatus']
        if delete_status is None:
            raise TypeError("Missing 'delete_status' argument")
        if file_content_uri is None and 'fileContentUri' in kwargs:
            file_content_uri = kwargs['fileContentUri']
        if file_content_uri is None:
            raise TypeError("Missing 'file_content_uri' argument")
        if file_format is None and 'fileFormat' in kwargs:
            file_format = kwargs['fileFormat']
        if file_name is None and 'fileName' in kwargs:
            file_name = kwargs['fileName']
        if file_size is None and 'fileSize' in kwargs:
            file_size = kwargs['fileSize']

        _setter("delete_status", delete_status)
        _setter("file_content_uri", file_content_uri)
        if file_format is not None:
            _setter("file_format", file_format)
        if file_name is not None:
            _setter("file_name", file_name)
        if file_size is not None:
            _setter("file_size", file_size)

    @property
    @pulumi.getter(name="deleteStatus")
    def delete_status(self) -> str:
        """
        Indicates whether the file was deleted from the storage account.
        """
        return pulumi.get(self, "delete_status")

    @property
    @pulumi.getter(name="fileContentUri")
    def file_content_uri(self) -> str:
        """
        A URI with a valid SAS token to allow uploading / downloading the file.
        """
        return pulumi.get(self, "file_content_uri")

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[str]:
        """
        The format of the file
        """
        return pulumi.get(self, "file_format")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[str]:
        """
        The name of the file.
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter(name="fileSize")
    def file_size(self) -> Optional[int]:
        """
        The size of the file.
        """
        return pulumi.get(self, "file_size")


@pulumi.output_type
class FusionScenarioExclusionPatternResponse(dict):
    """
    Represents a Fusion scenario exclusion patterns in Fusion detection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateAddedInUTC":
            suggest = "date_added_in_utc"
        elif key == "exclusionPattern":
            suggest = "exclusion_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionScenarioExclusionPatternResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionScenarioExclusionPatternResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionScenarioExclusionPatternResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_added_in_utc: str,
                 exclusion_pattern: str):
        """
        Represents a Fusion scenario exclusion patterns in Fusion detection.
        :param str date_added_in_utc: DateTime when scenario exclusion pattern is added in UTC.
        :param str exclusion_pattern: Scenario exclusion pattern.
        """
        FusionScenarioExclusionPatternResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_added_in_utc=date_added_in_utc,
            exclusion_pattern=exclusion_pattern,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_added_in_utc: Optional[str] = None,
             exclusion_pattern: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if date_added_in_utc is None and 'dateAddedInUTC' in kwargs:
            date_added_in_utc = kwargs['dateAddedInUTC']
        if date_added_in_utc is None:
            raise TypeError("Missing 'date_added_in_utc' argument")
        if exclusion_pattern is None and 'exclusionPattern' in kwargs:
            exclusion_pattern = kwargs['exclusionPattern']
        if exclusion_pattern is None:
            raise TypeError("Missing 'exclusion_pattern' argument")

        _setter("date_added_in_utc", date_added_in_utc)
        _setter("exclusion_pattern", exclusion_pattern)

    @property
    @pulumi.getter(name="dateAddedInUTC")
    def date_added_in_utc(self) -> str:
        """
        DateTime when scenario exclusion pattern is added in UTC.
        """
        return pulumi.get(self, "date_added_in_utc")

    @property
    @pulumi.getter(name="exclusionPattern")
    def exclusion_pattern(self) -> str:
        """
        Scenario exclusion pattern.
        """
        return pulumi.get(self, "exclusion_pattern")


@pulumi.output_type
class FusionSourceSettingsResponse(dict):
    """
    Represents a supported source signal configuration in Fusion detection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceName":
            suggest = "source_name"
        elif key == "sourceSubTypes":
            suggest = "source_sub_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionSourceSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionSourceSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionSourceSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 source_name: str,
                 source_sub_types: Optional[Sequence['outputs.FusionSourceSubTypeSettingResponse']] = None):
        """
        Represents a supported source signal configuration in Fusion detection.
        :param bool enabled: Determines whether this source signal is enabled or disabled in Fusion detection.
        :param str source_name: Name of the Fusion source signal. Refer to Fusion alert rule template for supported values.
        :param Sequence['FusionSourceSubTypeSettingResponse'] source_sub_types: Configuration for all source subtypes under this source signal consumed in fusion detection.
        """
        FusionSourceSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            source_name=source_name,
            source_sub_types=source_sub_types,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             source_name: Optional[str] = None,
             source_sub_types: Optional[Sequence['outputs.FusionSourceSubTypeSettingResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if source_name is None and 'sourceName' in kwargs:
            source_name = kwargs['sourceName']
        if source_name is None:
            raise TypeError("Missing 'source_name' argument")
        if source_sub_types is None and 'sourceSubTypes' in kwargs:
            source_sub_types = kwargs['sourceSubTypes']

        _setter("enabled", enabled)
        _setter("source_name", source_name)
        if source_sub_types is not None:
            _setter("source_sub_types", source_sub_types)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Determines whether this source signal is enabled or disabled in Fusion detection.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> str:
        """
        Name of the Fusion source signal. Refer to Fusion alert rule template for supported values.
        """
        return pulumi.get(self, "source_name")

    @property
    @pulumi.getter(name="sourceSubTypes")
    def source_sub_types(self) -> Optional[Sequence['outputs.FusionSourceSubTypeSettingResponse']]:
        """
        Configuration for all source subtypes under this source signal consumed in fusion detection.
        """
        return pulumi.get(self, "source_sub_types")


@pulumi.output_type
class FusionSourceSubTypeSettingResponse(dict):
    """
    Represents a supported source subtype configuration under a source signal in Fusion detection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "severityFilters":
            suggest = "severity_filters"
        elif key == "sourceSubTypeDisplayName":
            suggest = "source_sub_type_display_name"
        elif key == "sourceSubTypeName":
            suggest = "source_sub_type_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionSourceSubTypeSettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionSourceSubTypeSettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionSourceSubTypeSettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 severity_filters: 'outputs.FusionSubTypeSeverityFilterResponse',
                 source_sub_type_display_name: str,
                 source_sub_type_name: str):
        """
        Represents a supported source subtype configuration under a source signal in Fusion detection.
        :param bool enabled: Determines whether this source subtype under source signal is enabled or disabled in Fusion detection.
        :param 'FusionSubTypeSeverityFilterResponse' severity_filters: Severity configuration for a source subtype consumed in fusion detection.
        :param str source_sub_type_display_name: The display name of source subtype under a source signal consumed in Fusion detection.
        :param str source_sub_type_name: The Name of the source subtype under a given source signal in Fusion detection. Refer to Fusion alert rule template for supported values.
        """
        FusionSourceSubTypeSettingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            severity_filters=severity_filters,
            source_sub_type_display_name=source_sub_type_display_name,
            source_sub_type_name=source_sub_type_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             severity_filters: Optional['outputs.FusionSubTypeSeverityFilterResponse'] = None,
             source_sub_type_display_name: Optional[str] = None,
             source_sub_type_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if severity_filters is None and 'severityFilters' in kwargs:
            severity_filters = kwargs['severityFilters']
        if severity_filters is None:
            raise TypeError("Missing 'severity_filters' argument")
        if source_sub_type_display_name is None and 'sourceSubTypeDisplayName' in kwargs:
            source_sub_type_display_name = kwargs['sourceSubTypeDisplayName']
        if source_sub_type_display_name is None:
            raise TypeError("Missing 'source_sub_type_display_name' argument")
        if source_sub_type_name is None and 'sourceSubTypeName' in kwargs:
            source_sub_type_name = kwargs['sourceSubTypeName']
        if source_sub_type_name is None:
            raise TypeError("Missing 'source_sub_type_name' argument")

        _setter("enabled", enabled)
        _setter("severity_filters", severity_filters)
        _setter("source_sub_type_display_name", source_sub_type_display_name)
        _setter("source_sub_type_name", source_sub_type_name)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Determines whether this source subtype under source signal is enabled or disabled in Fusion detection.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="severityFilters")
    def severity_filters(self) -> 'outputs.FusionSubTypeSeverityFilterResponse':
        """
        Severity configuration for a source subtype consumed in fusion detection.
        """
        return pulumi.get(self, "severity_filters")

    @property
    @pulumi.getter(name="sourceSubTypeDisplayName")
    def source_sub_type_display_name(self) -> str:
        """
        The display name of source subtype under a source signal consumed in Fusion detection.
        """
        return pulumi.get(self, "source_sub_type_display_name")

    @property
    @pulumi.getter(name="sourceSubTypeName")
    def source_sub_type_name(self) -> str:
        """
        The Name of the source subtype under a given source signal in Fusion detection. Refer to Fusion alert rule template for supported values.
        """
        return pulumi.get(self, "source_sub_type_name")


@pulumi.output_type
class FusionSubTypeSeverityFilterResponse(dict):
    """
    Represents severity configuration for a source subtype consumed in Fusion detection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSupported":
            suggest = "is_supported"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FusionSubTypeSeverityFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FusionSubTypeSeverityFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FusionSubTypeSeverityFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_supported: bool,
                 filters: Optional[Sequence['outputs.FusionSubTypeSeverityFiltersItemResponse']] = None):
        """
        Represents severity configuration for a source subtype consumed in Fusion detection.
        :param bool is_supported: Determines whether this source subtype supports severity configuration or not.
        :param Sequence['FusionSubTypeSeverityFiltersItemResponse'] filters: Individual Severity configuration settings for a given source subtype consumed in Fusion detection.
        """
        FusionSubTypeSeverityFilterResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_supported=is_supported,
            filters=filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_supported: Optional[bool] = None,
             filters: Optional[Sequence['outputs.FusionSubTypeSeverityFiltersItemResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if is_supported is None and 'isSupported' in kwargs:
            is_supported = kwargs['isSupported']
        if is_supported is None:
            raise TypeError("Missing 'is_supported' argument")

        _setter("is_supported", is_supported)
        if filters is not None:
            _setter("filters", filters)

    @property
    @pulumi.getter(name="isSupported")
    def is_supported(self) -> bool:
        """
        Determines whether this source subtype supports severity configuration or not.
        """
        return pulumi.get(self, "is_supported")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.FusionSubTypeSeverityFiltersItemResponse']]:
        """
        Individual Severity configuration settings for a given source subtype consumed in Fusion detection.
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class FusionSubTypeSeverityFiltersItemResponse(dict):
    """
    Represents a Severity filter setting for a given source subtype consumed in Fusion detection.
    """
    def __init__(__self__, *,
                 enabled: bool,
                 severity: str):
        """
        Represents a Severity filter setting for a given source subtype consumed in Fusion detection.
        :param bool enabled: Determines whether this severity is enabled or disabled for this source subtype consumed in Fusion detection.
        :param str severity: The Severity for a given source subtype consumed in Fusion detection.
        """
        FusionSubTypeSeverityFiltersItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            severity=severity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             severity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")

        _setter("enabled", enabled)
        _setter("severity", severity)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Determines whether this severity is enabled or disabled for this source subtype consumed in Fusion detection.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The Severity for a given source subtype consumed in Fusion detection.
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class GCPAuthPropertiesResponse(dict):
    """
    Google Cloud Platform auth section properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectNumber":
            suggest = "project_number"
        elif key == "serviceAccountEmail":
            suggest = "service_account_email"
        elif key == "workloadIdentityProviderId":
            suggest = "workload_identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GCPAuthPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GCPAuthPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GCPAuthPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_number: str,
                 service_account_email: str,
                 workload_identity_provider_id: str):
        """
        Google Cloud Platform auth section properties.
        :param str project_number: The GCP project number.
        :param str service_account_email: The service account that is used to access the GCP project.
        :param str workload_identity_provider_id: The workload identity provider id that is used to gain access to the GCP project.
        """
        GCPAuthPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project_number=project_number,
            service_account_email=service_account_email,
            workload_identity_provider_id=workload_identity_provider_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project_number: Optional[str] = None,
             service_account_email: Optional[str] = None,
             workload_identity_provider_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if project_number is None and 'projectNumber' in kwargs:
            project_number = kwargs['projectNumber']
        if project_number is None:
            raise TypeError("Missing 'project_number' argument")
        if service_account_email is None and 'serviceAccountEmail' in kwargs:
            service_account_email = kwargs['serviceAccountEmail']
        if service_account_email is None:
            raise TypeError("Missing 'service_account_email' argument")
        if workload_identity_provider_id is None and 'workloadIdentityProviderId' in kwargs:
            workload_identity_provider_id = kwargs['workloadIdentityProviderId']
        if workload_identity_provider_id is None:
            raise TypeError("Missing 'workload_identity_provider_id' argument")

        _setter("project_number", project_number)
        _setter("service_account_email", service_account_email)
        _setter("workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="projectNumber")
    def project_number(self) -> str:
        """
        The GCP project number.
        """
        return pulumi.get(self, "project_number")

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> str:
        """
        The service account that is used to access the GCP project.
        """
        return pulumi.get(self, "service_account_email")

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> str:
        """
        The workload identity provider id that is used to gain access to the GCP project.
        """
        return pulumi.get(self, "workload_identity_provider_id")


@pulumi.output_type
class GCPRequestPropertiesResponse(dict):
    """
    Google Cloud Platform request section properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"
        elif key == "subscriptionNames":
            suggest = "subscription_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GCPRequestPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GCPRequestPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GCPRequestPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str,
                 subscription_names: Sequence[str]):
        """
        Google Cloud Platform request section properties.
        :param str project_id: The GCP project id.
        :param Sequence[str] subscription_names: The GCP pub/sub subscription names.
        """
        GCPRequestPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project_id=project_id,
            subscription_names=subscription_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project_id: Optional[str] = None,
             subscription_names: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if project_id is None and 'projectId' in kwargs:
            project_id = kwargs['projectId']
        if project_id is None:
            raise TypeError("Missing 'project_id' argument")
        if subscription_names is None and 'subscriptionNames' in kwargs:
            subscription_names = kwargs['subscriptionNames']
        if subscription_names is None:
            raise TypeError("Missing 'subscription_names' argument")

        _setter("project_id", project_id)
        _setter("subscription_names", subscription_names)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The GCP project id.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="subscriptionNames")
    def subscription_names(self) -> Sequence[str]:
        """
        The GCP pub/sub subscription names.
        """
        return pulumi.get(self, "subscription_names")


@pulumi.output_type
class GetInsightsErrorKindResponse(dict):
    """
    GetInsights Query Errors.
    """
    def __init__(__self__, *,
                 error_message: str,
                 kind: str,
                 query_id: Optional[str] = None):
        """
        GetInsights Query Errors.
        :param str error_message: the error message
        :param str kind: the query kind
        :param str query_id: the query id
        """
        GetInsightsErrorKindResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error_message=error_message,
            kind=kind,
            query_id=query_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error_message: Optional[str] = None,
             kind: Optional[str] = None,
             query_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error_message is None and 'errorMessage' in kwargs:
            error_message = kwargs['errorMessage']
        if error_message is None:
            raise TypeError("Missing 'error_message' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if query_id is None and 'queryId' in kwargs:
            query_id = kwargs['queryId']

        _setter("error_message", error_message)
        _setter("kind", kind)
        if query_id is not None:
            _setter("query_id", query_id)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        the error message
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        the query kind
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> Optional[str]:
        """
        the query id
        """
        return pulumi.get(self, "query_id")


@pulumi.output_type
class GetInsightsResultsMetadataResponse(dict):
    """
    Get Insights result metadata.
    """
    def __init__(__self__, *,
                 total_count: int,
                 errors: Optional[Sequence['outputs.GetInsightsErrorKindResponse']] = None):
        """
        Get Insights result metadata.
        :param int total_count: the total items found for the insights request
        :param Sequence['GetInsightsErrorKindResponse'] errors: information about the failed queries
        """
        GetInsightsResultsMetadataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            total_count=total_count,
            errors=errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             total_count: Optional[int] = None,
             errors: Optional[Sequence['outputs.GetInsightsErrorKindResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if total_count is None and 'totalCount' in kwargs:
            total_count = kwargs['totalCount']
        if total_count is None:
            raise TypeError("Missing 'total_count' argument")

        _setter("total_count", total_count)
        if errors is not None:
            _setter("errors", errors)

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> int:
        """
        the total items found for the insights request
        """
        return pulumi.get(self, "total_count")

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.GetInsightsErrorKindResponse']]:
        """
        information about the failed queries
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class GroupingConfigurationResponse(dict):
    """
    Grouping configuration property bag.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookbackDuration":
            suggest = "lookback_duration"
        elif key == "matchingMethod":
            suggest = "matching_method"
        elif key == "reopenClosedIncident":
            suggest = "reopen_closed_incident"
        elif key == "groupByAlertDetails":
            suggest = "group_by_alert_details"
        elif key == "groupByCustomDetails":
            suggest = "group_by_custom_details"
        elif key == "groupByEntities":
            suggest = "group_by_entities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupingConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupingConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupingConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 lookback_duration: str,
                 matching_method: str,
                 reopen_closed_incident: bool,
                 group_by_alert_details: Optional[Sequence[str]] = None,
                 group_by_custom_details: Optional[Sequence[str]] = None,
                 group_by_entities: Optional[Sequence[str]] = None):
        """
        Grouping configuration property bag.
        :param bool enabled: Grouping enabled
        :param str lookback_duration: Limit the group to alerts created within the lookback duration (in ISO 8601 duration format)
        :param str matching_method: Grouping matching method. When method is Selected at least one of groupByEntities, groupByAlertDetails, groupByCustomDetails must be provided and not empty.
        :param bool reopen_closed_incident: Re-open closed matching incidents
        :param Sequence[str] group_by_alert_details: A list of alert details to group by (when matchingMethod is Selected)
        :param Sequence[str] group_by_custom_details: A list of custom details keys to group by (when matchingMethod is Selected). Only keys defined in the current alert rule may be used.
        :param Sequence[str] group_by_entities: A list of entity types to group by (when matchingMethod is Selected). Only entities defined in the current alert rule may be used.
        """
        GroupingConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            lookback_duration=lookback_duration,
            matching_method=matching_method,
            reopen_closed_incident=reopen_closed_incident,
            group_by_alert_details=group_by_alert_details,
            group_by_custom_details=group_by_custom_details,
            group_by_entities=group_by_entities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             lookback_duration: Optional[str] = None,
             matching_method: Optional[str] = None,
             reopen_closed_incident: Optional[bool] = None,
             group_by_alert_details: Optional[Sequence[str]] = None,
             group_by_custom_details: Optional[Sequence[str]] = None,
             group_by_entities: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if enabled is None:
            raise TypeError("Missing 'enabled' argument")
        if lookback_duration is None and 'lookbackDuration' in kwargs:
            lookback_duration = kwargs['lookbackDuration']
        if lookback_duration is None:
            raise TypeError("Missing 'lookback_duration' argument")
        if matching_method is None and 'matchingMethod' in kwargs:
            matching_method = kwargs['matchingMethod']
        if matching_method is None:
            raise TypeError("Missing 'matching_method' argument")
        if reopen_closed_incident is None and 'reopenClosedIncident' in kwargs:
            reopen_closed_incident = kwargs['reopenClosedIncident']
        if reopen_closed_incident is None:
            raise TypeError("Missing 'reopen_closed_incident' argument")
        if group_by_alert_details is None and 'groupByAlertDetails' in kwargs:
            group_by_alert_details = kwargs['groupByAlertDetails']
        if group_by_custom_details is None and 'groupByCustomDetails' in kwargs:
            group_by_custom_details = kwargs['groupByCustomDetails']
        if group_by_entities is None and 'groupByEntities' in kwargs:
            group_by_entities = kwargs['groupByEntities']

        _setter("enabled", enabled)
        _setter("lookback_duration", lookback_duration)
        _setter("matching_method", matching_method)
        _setter("reopen_closed_incident", reopen_closed_incident)
        if group_by_alert_details is not None:
            _setter("group_by_alert_details", group_by_alert_details)
        if group_by_custom_details is not None:
            _setter("group_by_custom_details", group_by_custom_details)
        if group_by_entities is not None:
            _setter("group_by_entities", group_by_entities)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Grouping enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="lookbackDuration")
    def lookback_duration(self) -> str:
        """
        Limit the group to alerts created within the lookback duration (in ISO 8601 duration format)
        """
        return pulumi.get(self, "lookback_duration")

    @property
    @pulumi.getter(name="matchingMethod")
    def matching_method(self) -> str:
        """
        Grouping matching method. When method is Selected at least one of groupByEntities, groupByAlertDetails, groupByCustomDetails must be provided and not empty.
        """
        return pulumi.get(self, "matching_method")

    @property
    @pulumi.getter(name="reopenClosedIncident")
    def reopen_closed_incident(self) -> bool:
        """
        Re-open closed matching incidents
        """
        return pulumi.get(self, "reopen_closed_incident")

    @property
    @pulumi.getter(name="groupByAlertDetails")
    def group_by_alert_details(self) -> Optional[Sequence[str]]:
        """
        A list of alert details to group by (when matchingMethod is Selected)
        """
        return pulumi.get(self, "group_by_alert_details")

    @property
    @pulumi.getter(name="groupByCustomDetails")
    def group_by_custom_details(self) -> Optional[Sequence[str]]:
        """
        A list of custom details keys to group by (when matchingMethod is Selected). Only keys defined in the current alert rule may be used.
        """
        return pulumi.get(self, "group_by_custom_details")

    @property
    @pulumi.getter(name="groupByEntities")
    def group_by_entities(self) -> Optional[Sequence[str]]:
        """
        A list of entity types to group by (when matchingMethod is Selected). Only entities defined in the current alert rule may be used.
        """
        return pulumi.get(self, "group_by_entities")


@pulumi.output_type
class HuntOwnerResponse(dict):
    """
    Describes a user that the hunt is assigned to
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignedTo":
            suggest = "assigned_to"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "ownerType":
            suggest = "owner_type"
        elif key == "userPrincipalName":
            suggest = "user_principal_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HuntOwnerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HuntOwnerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HuntOwnerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assigned_to: Optional[str] = None,
                 email: Optional[str] = None,
                 object_id: Optional[str] = None,
                 owner_type: Optional[str] = None,
                 user_principal_name: Optional[str] = None):
        """
        Describes a user that the hunt is assigned to
        :param str assigned_to: The name of the user the hunt is assigned to.
        :param str email: The email of the user the hunt is assigned to.
        :param str object_id: The object id of the user the hunt is assigned to.
        :param str owner_type: The type of the owner the hunt is assigned to.
        :param str user_principal_name: The user principal name of the user the hunt is assigned to.
        """
        HuntOwnerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assigned_to=assigned_to,
            email=email,
            object_id=object_id,
            owner_type=owner_type,
            user_principal_name=user_principal_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assigned_to: Optional[str] = None,
             email: Optional[str] = None,
             object_id: Optional[str] = None,
             owner_type: Optional[str] = None,
             user_principal_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if assigned_to is None and 'assignedTo' in kwargs:
            assigned_to = kwargs['assignedTo']
        if object_id is None and 'objectId' in kwargs:
            object_id = kwargs['objectId']
        if owner_type is None and 'ownerType' in kwargs:
            owner_type = kwargs['ownerType']
        if user_principal_name is None and 'userPrincipalName' in kwargs:
            user_principal_name = kwargs['userPrincipalName']

        if assigned_to is not None:
            _setter("assigned_to", assigned_to)
        if email is not None:
            _setter("email", email)
        if object_id is not None:
            _setter("object_id", object_id)
        if owner_type is not None:
            _setter("owner_type", owner_type)
        if user_principal_name is not None:
            _setter("user_principal_name", user_principal_name)

    @property
    @pulumi.getter(name="assignedTo")
    def assigned_to(self) -> Optional[str]:
        """
        The name of the user the hunt is assigned to.
        """
        return pulumi.get(self, "assigned_to")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The email of the user the hunt is assigned to.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[str]:
        """
        The object id of the user the hunt is assigned to.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="ownerType")
    def owner_type(self) -> Optional[str]:
        """
        The type of the owner the hunt is assigned to.
        """
        return pulumi.get(self, "owner_type")

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[str]:
        """
        The user principal name of the user the hunt is assigned to.
        """
        return pulumi.get(self, "user_principal_name")


@pulumi.output_type
class IncidentAdditionalDataResponse(dict):
    """
    Incident additional data property bag.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertProductNames":
            suggest = "alert_product_names"
        elif key == "alertsCount":
            suggest = "alerts_count"
        elif key == "bookmarksCount":
            suggest = "bookmarks_count"
        elif key == "commentsCount":
            suggest = "comments_count"
        elif key == "providerIncidentUrl":
            suggest = "provider_incident_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentAdditionalDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentAdditionalDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentAdditionalDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_product_names: Sequence[str],
                 alerts_count: int,
                 bookmarks_count: int,
                 comments_count: int,
                 provider_incident_url: str,
                 tactics: Sequence[str],
                 techniques: Sequence[str]):
        """
        Incident additional data property bag.
        :param Sequence[str] alert_product_names: List of product names of alerts in the incident
        :param int alerts_count: The number of alerts in the incident
        :param int bookmarks_count: The number of bookmarks in the incident
        :param int comments_count: The number of comments in the incident
        :param str provider_incident_url: The provider incident url to the incident in Microsoft 365 Defender portal
        :param Sequence[str] tactics: The tactics associated with incident
        :param Sequence[str] techniques: The techniques associated with incident's tactics
        """
        IncidentAdditionalDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_product_names=alert_product_names,
            alerts_count=alerts_count,
            bookmarks_count=bookmarks_count,
            comments_count=comments_count,
            provider_incident_url=provider_incident_url,
            tactics=tactics,
            techniques=techniques,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_product_names: Optional[Sequence[str]] = None,
             alerts_count: Optional[int] = None,
             bookmarks_count: Optional[int] = None,
             comments_count: Optional[int] = None,
             provider_incident_url: Optional[str] = None,
             tactics: Optional[Sequence[str]] = None,
             techniques: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alert_product_names is None and 'alertProductNames' in kwargs:
            alert_product_names = kwargs['alertProductNames']
        if alert_product_names is None:
            raise TypeError("Missing 'alert_product_names' argument")
        if alerts_count is None and 'alertsCount' in kwargs:
            alerts_count = kwargs['alertsCount']
        if alerts_count is None:
            raise TypeError("Missing 'alerts_count' argument")
        if bookmarks_count is None and 'bookmarksCount' in kwargs:
            bookmarks_count = kwargs['bookmarksCount']
        if bookmarks_count is None:
            raise TypeError("Missing 'bookmarks_count' argument")
        if comments_count is None and 'commentsCount' in kwargs:
            comments_count = kwargs['commentsCount']
        if comments_count is None:
            raise TypeError("Missing 'comments_count' argument")
        if provider_incident_url is None and 'providerIncidentUrl' in kwargs:
            provider_incident_url = kwargs['providerIncidentUrl']
        if provider_incident_url is None:
            raise TypeError("Missing 'provider_incident_url' argument")
        if tactics is None:
            raise TypeError("Missing 'tactics' argument")
        if techniques is None:
            raise TypeError("Missing 'techniques' argument")

        _setter("alert_product_names", alert_product_names)
        _setter("alerts_count", alerts_count)
        _setter("bookmarks_count", bookmarks_count)
        _setter("comments_count", comments_count)
        _setter("provider_incident_url", provider_incident_url)
        _setter("tactics", tactics)
        _setter("techniques", techniques)

    @property
    @pulumi.getter(name="alertProductNames")
    def alert_product_names(self) -> Sequence[str]:
        """
        List of product names of alerts in the incident
        """
        return pulumi.get(self, "alert_product_names")

    @property
    @pulumi.getter(name="alertsCount")
    def alerts_count(self) -> int:
        """
        The number of alerts in the incident
        """
        return pulumi.get(self, "alerts_count")

    @property
    @pulumi.getter(name="bookmarksCount")
    def bookmarks_count(self) -> int:
        """
        The number of bookmarks in the incident
        """
        return pulumi.get(self, "bookmarks_count")

    @property
    @pulumi.getter(name="commentsCount")
    def comments_count(self) -> int:
        """
        The number of comments in the incident
        """
        return pulumi.get(self, "comments_count")

    @property
    @pulumi.getter(name="providerIncidentUrl")
    def provider_incident_url(self) -> str:
        """
        The provider incident url to the incident in Microsoft 365 Defender portal
        """
        return pulumi.get(self, "provider_incident_url")

    @property
    @pulumi.getter
    def tactics(self) -> Sequence[str]:
        """
        The tactics associated with incident
        """
        return pulumi.get(self, "tactics")

    @property
    @pulumi.getter
    def techniques(self) -> Sequence[str]:
        """
        The techniques associated with incident's tactics
        """
        return pulumi.get(self, "techniques")


@pulumi.output_type
class IncidentConfigurationResponse(dict):
    """
    Incident Configuration property bag.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createIncident":
            suggest = "create_incident"
        elif key == "groupingConfiguration":
            suggest = "grouping_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_incident: bool,
                 grouping_configuration: Optional['outputs.GroupingConfigurationResponse'] = None):
        """
        Incident Configuration property bag.
        :param bool create_incident: Create incidents from alerts triggered by this analytics rule
        :param 'GroupingConfigurationResponse' grouping_configuration: Set how the alerts that are triggered by this analytics rule, are grouped into incidents
        """
        IncidentConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_incident=create_incident,
            grouping_configuration=grouping_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_incident: Optional[bool] = None,
             grouping_configuration: Optional['outputs.GroupingConfigurationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if create_incident is None and 'createIncident' in kwargs:
            create_incident = kwargs['createIncident']
        if create_incident is None:
            raise TypeError("Missing 'create_incident' argument")
        if grouping_configuration is None and 'groupingConfiguration' in kwargs:
            grouping_configuration = kwargs['groupingConfiguration']

        _setter("create_incident", create_incident)
        if grouping_configuration is not None:
            _setter("grouping_configuration", grouping_configuration)

    @property
    @pulumi.getter(name="createIncident")
    def create_incident(self) -> bool:
        """
        Create incidents from alerts triggered by this analytics rule
        """
        return pulumi.get(self, "create_incident")

    @property
    @pulumi.getter(name="groupingConfiguration")
    def grouping_configuration(self) -> Optional['outputs.GroupingConfigurationResponse']:
        """
        Set how the alerts that are triggered by this analytics rule, are grouped into incidents
        """
        return pulumi.get(self, "grouping_configuration")


@pulumi.output_type
class IncidentInfoResponse(dict):
    """
    Describes related incident information for the bookmark
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentId":
            suggest = "incident_id"
        elif key == "relationName":
            suggest = "relation_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_id: Optional[str] = None,
                 relation_name: Optional[str] = None,
                 severity: Optional[str] = None,
                 title: Optional[str] = None):
        """
        Describes related incident information for the bookmark
        :param str incident_id: Incident Id
        :param str relation_name: Relation Name
        :param str severity: The severity of the incident
        :param str title: The title of the incident
        """
        IncidentInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            incident_id=incident_id,
            relation_name=relation_name,
            severity=severity,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             incident_id: Optional[str] = None,
             relation_name: Optional[str] = None,
             severity: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if incident_id is None and 'incidentId' in kwargs:
            incident_id = kwargs['incidentId']
        if relation_name is None and 'relationName' in kwargs:
            relation_name = kwargs['relationName']

        if incident_id is not None:
            _setter("incident_id", incident_id)
        if relation_name is not None:
            _setter("relation_name", relation_name)
        if severity is not None:
            _setter("severity", severity)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter(name="incidentId")
    def incident_id(self) -> Optional[str]:
        """
        Incident Id
        """
        return pulumi.get(self, "incident_id")

    @property
    @pulumi.getter(name="relationName")
    def relation_name(self) -> Optional[str]:
        """
        Relation Name
        """
        return pulumi.get(self, "relation_name")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        The severity of the incident
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the incident
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class IncidentLabelResponse(dict):
    """
    Represents an incident label
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelName":
            suggest = "label_name"
        elif key == "labelType":
            suggest = "label_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentLabelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentLabelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentLabelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_name: str,
                 label_type: str):
        """
        Represents an incident label
        :param str label_name: The name of the label
        :param str label_type: The type of the label
        """
        IncidentLabelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_name=label_name,
            label_type=label_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_name: Optional[str] = None,
             label_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if label_name is None and 'labelName' in kwargs:
            label_name = kwargs['labelName']
        if label_name is None:
            raise TypeError("Missing 'label_name' argument")
        if label_type is None and 'labelType' in kwargs:
            label_type = kwargs['labelType']
        if label_type is None:
            raise TypeError("Missing 'label_type' argument")

        _setter("label_name", label_name)
        _setter("label_type", label_type)

    @property
    @pulumi.getter(name="labelName")
    def label_name(self) -> str:
        """
        The name of the label
        """
        return pulumi.get(self, "label_name")

    @property
    @pulumi.getter(name="labelType")
    def label_type(self) -> str:
        """
        The type of the label
        """
        return pulumi.get(self, "label_type")


@pulumi.output_type
class IncidentOwnerInfoResponse(dict):
    """
    Information on the user an incident is assigned to
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignedTo":
            suggest = "assigned_to"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "ownerType":
            suggest = "owner_type"
        elif key == "userPrincipalName":
            suggest = "user_principal_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentOwnerInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentOwnerInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentOwnerInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assigned_to: Optional[str] = None,
                 email: Optional[str] = None,
                 object_id: Optional[str] = None,
                 owner_type: Optional[str] = None,
                 user_principal_name: Optional[str] = None):
        """
        Information on the user an incident is assigned to
        :param str assigned_to: The name of the user the incident is assigned to.
        :param str email: The email of the user the incident is assigned to.
        :param str object_id: The object id of the user the incident is assigned to.
        :param str owner_type: The type of the owner the incident is assigned to.
        :param str user_principal_name: The user principal name of the user the incident is assigned to.
        """
        IncidentOwnerInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assigned_to=assigned_to,
            email=email,
            object_id=object_id,
            owner_type=owner_type,
            user_principal_name=user_principal_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assigned_to: Optional[str] = None,
             email: Optional[str] = None,
             object_id: Optional[str] = None,
             owner_type: Optional[str] = None,
             user_principal_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if assigned_to is None and 'assignedTo' in kwargs:
            assigned_to = kwargs['assignedTo']
        if object_id is None and 'objectId' in kwargs:
            object_id = kwargs['objectId']
        if owner_type is None and 'ownerType' in kwargs:
            owner_type = kwargs['ownerType']
        if user_principal_name is None and 'userPrincipalName' in kwargs:
            user_principal_name = kwargs['userPrincipalName']

        if assigned_to is not None:
            _setter("assigned_to", assigned_to)
        if email is not None:
            _setter("email", email)
        if object_id is not None:
            _setter("object_id", object_id)
        if owner_type is not None:
            _setter("owner_type", owner_type)
        if user_principal_name is not None:
            _setter("user_principal_name", user_principal_name)

    @property
    @pulumi.getter(name="assignedTo")
    def assigned_to(self) -> Optional[str]:
        """
        The name of the user the incident is assigned to.
        """
        return pulumi.get(self, "assigned_to")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The email of the user the incident is assigned to.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[str]:
        """
        The object id of the user the incident is assigned to.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="ownerType")
    def owner_type(self) -> Optional[str]:
        """
        The type of the owner the incident is assigned to.
        """
        return pulumi.get(self, "owner_type")

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[str]:
        """
        The user principal name of the user the incident is assigned to.
        """
        return pulumi.get(self, "user_principal_name")


@pulumi.output_type
class IncidentPropertiesActionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classificationComment":
            suggest = "classification_comment"
        elif key == "classificationReason":
            suggest = "classification_reason"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentPropertiesActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentPropertiesActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentPropertiesActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification: Optional[str] = None,
                 classification_comment: Optional[str] = None,
                 classification_reason: Optional[str] = None,
                 labels: Optional[Sequence['outputs.IncidentLabelResponse']] = None,
                 owner: Optional['outputs.IncidentOwnerInfoResponse'] = None,
                 severity: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str classification: The reason the incident was closed
        :param str classification_comment: Describes the reason the incident was closed.
        :param str classification_reason: The classification reason the incident was closed with
        :param Sequence['IncidentLabelResponse'] labels: List of labels to add to the incident.
        :param 'IncidentOwnerInfoResponse' owner: Information on the user an incident is assigned to
        :param str severity: The severity of the incident
        :param str status: The status of the incident
        """
        IncidentPropertiesActionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            classification=classification,
            classification_comment=classification_comment,
            classification_reason=classification_reason,
            labels=labels,
            owner=owner,
            severity=severity,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             classification: Optional[str] = None,
             classification_comment: Optional[str] = None,
             classification_reason: Optional[str] = None,
             labels: Optional[Sequence['outputs.IncidentLabelResponse']] = None,
             owner: Optional['outputs.IncidentOwnerInfoResponse'] = None,
             severity: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if classification_comment is None and 'classificationComment' in kwargs:
            classification_comment = kwargs['classificationComment']
        if classification_reason is None and 'classificationReason' in kwargs:
            classification_reason = kwargs['classificationReason']

        if classification is not None:
            _setter("classification", classification)
        if classification_comment is not None:
            _setter("classification_comment", classification_comment)
        if classification_reason is not None:
            _setter("classification_reason", classification_reason)
        if labels is not None:
            _setter("labels", labels)
        if owner is not None:
            _setter("owner", owner)
        if severity is not None:
            _setter("severity", severity)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def classification(self) -> Optional[str]:
        """
        The reason the incident was closed
        """
        return pulumi.get(self, "classification")

    @property
    @pulumi.getter(name="classificationComment")
    def classification_comment(self) -> Optional[str]:
        """
        Describes the reason the incident was closed.
        """
        return pulumi.get(self, "classification_comment")

    @property
    @pulumi.getter(name="classificationReason")
    def classification_reason(self) -> Optional[str]:
        """
        The classification reason the incident was closed with
        """
        return pulumi.get(self, "classification_reason")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.IncidentLabelResponse']]:
        """
        List of labels to add to the incident.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def owner(self) -> Optional['outputs.IncidentOwnerInfoResponse']:
        """
        Information on the user an incident is assigned to
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        The severity of the incident
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the incident
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class InsightsTableResultResponse(dict):
    """
    Query results for table insights query.
    """
    def __init__(__self__, *,
                 columns: Optional[Sequence['outputs.InsightsTableResultResponseColumns']] = None,
                 rows: Optional[Sequence[Sequence[str]]] = None):
        """
        Query results for table insights query.
        :param Sequence['InsightsTableResultResponseColumns'] columns: Columns Metadata of the table
        :param Sequence[Sequence[str]] rows: Rows data of the table
        """
        InsightsTableResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            rows=rows,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence['outputs.InsightsTableResultResponseColumns']] = None,
             rows: Optional[Sequence[Sequence[str]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if columns is not None:
            _setter("columns", columns)
        if rows is not None:
            _setter("rows", rows)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.InsightsTableResultResponseColumns']]:
        """
        Columns Metadata of the table
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def rows(self) -> Optional[Sequence[Sequence[str]]]:
        """
        Rows data of the table
        """
        return pulumi.get(self, "rows")


@pulumi.output_type
class InsightsTableResultResponseColumns(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: the name of the colum
        :param str type: the type of the colum
        """
        InsightsTableResultResponseColumns._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the name of the colum
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        the type of the colum
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InstructionStepsResponseInstructions(dict):
    def __init__(__self__, *,
                 type: str,
                 parameters: Optional[Any] = None):
        """
        :param str type: The kind of the setting
        :param Any parameters: The parameters for the setting
        """
        InstructionStepsResponseInstructions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             parameters: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", type)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The kind of the setting
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        """
        The parameters for the setting
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class MCASDataConnectorDataTypesResponse(dict):
    """
    The available data types for MCAS (Microsoft Cloud App Security) data connector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discoveryLogs":
            suggest = "discovery_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MCASDataConnectorDataTypesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MCASDataConnectorDataTypesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MCASDataConnectorDataTypesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alerts: 'outputs.DataConnectorDataTypeCommonResponse',
                 discovery_logs: Optional['outputs.DataConnectorDataTypeCommonResponse'] = None):
        """
        The available data types for MCAS (Microsoft Cloud App Security) data connector.
        :param 'DataConnectorDataTypeCommonResponse' alerts: Alerts data type connection.
        :param 'DataConnectorDataTypeCommonResponse' discovery_logs: Discovery log data type connection.
        """
        MCASDataConnectorDataTypesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alerts=alerts,
            discovery_logs=discovery_logs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alerts: Optional['outputs.DataConnectorDataTypeCommonResponse'] = None,
             discovery_logs: Optional['outputs.DataConnectorDataTypeCommonResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alerts is None:
            raise TypeError("Missing 'alerts' argument")
        if discovery_logs is None and 'discoveryLogs' in kwargs:
            discovery_logs = kwargs['discoveryLogs']

        _setter("alerts", alerts)
        if discovery_logs is not None:
            _setter("discovery_logs", discovery_logs)

    @property
    @pulumi.getter
    def alerts(self) -> 'outputs.DataConnectorDataTypeCommonResponse':
        """
        Alerts data type connection.
        """
        return pulumi.get(self, "alerts")

    @property
    @pulumi.getter(name="discoveryLogs")
    def discovery_logs(self) -> Optional['outputs.DataConnectorDataTypeCommonResponse']:
        """
        Discovery log data type connection.
        """
        return pulumi.get(self, "discovery_logs")


@pulumi.output_type
class MSTIDataConnectorDataTypesResponse(dict):
    """
    The available data types for Microsoft Threat Intelligence Platforms data connector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "microsoftEmergingThreatFeed":
            suggest = "microsoft_emerging_threat_feed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MSTIDataConnectorDataTypesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MSTIDataConnectorDataTypesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MSTIDataConnectorDataTypesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 microsoft_emerging_threat_feed: 'outputs.MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed'):
        """
        The available data types for Microsoft Threat Intelligence Platforms data connector.
        :param 'MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed' microsoft_emerging_threat_feed: Data type for Microsoft Threat Intelligence Platforms data connector.
        """
        MSTIDataConnectorDataTypesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            microsoft_emerging_threat_feed=microsoft_emerging_threat_feed,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             microsoft_emerging_threat_feed: Optional['outputs.MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if microsoft_emerging_threat_feed is None and 'microsoftEmergingThreatFeed' in kwargs:
            microsoft_emerging_threat_feed = kwargs['microsoftEmergingThreatFeed']
        if microsoft_emerging_threat_feed is None:
            raise TypeError("Missing 'microsoft_emerging_threat_feed' argument")

        _setter("microsoft_emerging_threat_feed", microsoft_emerging_threat_feed)

    @property
    @pulumi.getter(name="microsoftEmergingThreatFeed")
    def microsoft_emerging_threat_feed(self) -> 'outputs.MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed':
        """
        Data type for Microsoft Threat Intelligence Platforms data connector.
        """
        return pulumi.get(self, "microsoft_emerging_threat_feed")


@pulumi.output_type
class MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed(dict):
    """
    Data type for Microsoft Threat Intelligence Platforms data connector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookbackPeriod":
            suggest = "lookback_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookback_period: str,
                 state: str):
        """
        Data type for Microsoft Threat Intelligence Platforms data connector.
        :param str lookback_period: The lookback period for the feed to be imported.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lookback_period=lookback_period,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lookback_period: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if lookback_period is None and 'lookbackPeriod' in kwargs:
            lookback_period = kwargs['lookbackPeriod']
        if lookback_period is None:
            raise TypeError("Missing 'lookback_period' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("lookback_period", lookback_period)
        _setter("state", state)

    @property
    @pulumi.getter(name="lookbackPeriod")
    def lookback_period(self) -> str:
        """
        The lookback period for the feed to be imported.
        """
        return pulumi.get(self, "lookback_period")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MTPDataConnectorDataTypesResponse(dict):
    """
    The available data types for Microsoft Threat Protection Platforms data connector.
    """
    def __init__(__self__, *,
                 incidents: 'outputs.MTPDataConnectorDataTypesResponseIncidents',
                 alerts: Optional['outputs.MTPDataConnectorDataTypesResponseAlerts'] = None):
        """
        The available data types for Microsoft Threat Protection Platforms data connector.
        :param 'MTPDataConnectorDataTypesResponseIncidents' incidents: Incidents data type for Microsoft Threat Protection Platforms data connector.
        :param 'MTPDataConnectorDataTypesResponseAlerts' alerts: Alerts data type for Microsoft Threat Protection Platforms data connector.
        """
        MTPDataConnectorDataTypesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            incidents=incidents,
            alerts=alerts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             incidents: Optional['outputs.MTPDataConnectorDataTypesResponseIncidents'] = None,
             alerts: Optional['outputs.MTPDataConnectorDataTypesResponseAlerts'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if incidents is None:
            raise TypeError("Missing 'incidents' argument")

        _setter("incidents", incidents)
        if alerts is not None:
            _setter("alerts", alerts)

    @property
    @pulumi.getter
    def incidents(self) -> 'outputs.MTPDataConnectorDataTypesResponseIncidents':
        """
        Incidents data type for Microsoft Threat Protection Platforms data connector.
        """
        return pulumi.get(self, "incidents")

    @property
    @pulumi.getter
    def alerts(self) -> Optional['outputs.MTPDataConnectorDataTypesResponseAlerts']:
        """
        Alerts data type for Microsoft Threat Protection Platforms data connector.
        """
        return pulumi.get(self, "alerts")


@pulumi.output_type
class MTPDataConnectorDataTypesResponseAlerts(dict):
    """
    Alerts data type for Microsoft Threat Protection Platforms data connector.
    """
    def __init__(__self__, *,
                 state: str):
        """
        Alerts data type for Microsoft Threat Protection Platforms data connector.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        MTPDataConnectorDataTypesResponseAlerts._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MTPDataConnectorDataTypesResponseIncidents(dict):
    """
    Incidents data type for Microsoft Threat Protection Platforms data connector.
    """
    def __init__(__self__, *,
                 state: str):
        """
        Incidents data type for Microsoft Threat Protection Platforms data connector.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        MTPDataConnectorDataTypesResponseIncidents._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MetadataAuthorResponse(dict):
    """
    Publisher or creator of the content item.
    """
    def __init__(__self__, *,
                 email: Optional[str] = None,
                 link: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Publisher or creator of the content item.
        :param str email: Email of author contact
        :param str link: Link for author/vendor page
        :param str name: Name of the author. Company or person.
        """
        MetadataAuthorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            link=link,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: Optional[str] = None,
             link: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if email is not None:
            _setter("email", email)
        if link is not None:
            _setter("link", link)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Email of author contact
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        Link for author/vendor page
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the author. Company or person.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MetadataCategoriesResponse(dict):
    """
    ies for the solution content item
    """
    def __init__(__self__, *,
                 domains: Optional[Sequence[str]] = None,
                 verticals: Optional[Sequence[str]] = None):
        """
        ies for the solution content item
        :param Sequence[str] domains: domain for the solution content item
        :param Sequence[str] verticals: Industry verticals for the solution content item
        """
        MetadataCategoriesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domains=domains,
            verticals=verticals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domains: Optional[Sequence[str]] = None,
             verticals: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if domains is not None:
            _setter("domains", domains)
        if verticals is not None:
            _setter("verticals", verticals)

    @property
    @pulumi.getter
    def domains(self) -> Optional[Sequence[str]]:
        """
        domain for the solution content item
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter
    def verticals(self) -> Optional[Sequence[str]]:
        """
        Industry verticals for the solution content item
        """
        return pulumi.get(self, "verticals")


@pulumi.output_type
class MetadataDependenciesResponse(dict):
    """
    Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex dependencies.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentId":
            suggest = "content_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataDependenciesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataDependenciesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataDependenciesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_id: Optional[str] = None,
                 criteria: Optional[Sequence['outputs.MetadataDependenciesResponse']] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 operator: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex dependencies.
        :param str content_id: Id of the content item we depend on
        :param Sequence['MetadataDependenciesResponse'] criteria: This is the list of dependencies we must fulfill, according to the AND/OR operator
        :param str kind: Type of the content item we depend on
        :param str name: Name of the content item
        :param str operator: Operator used for list of dependencies in criteria array.
        :param str version: Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        """
        MetadataDependenciesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content_id=content_id,
            criteria=criteria,
            kind=kind,
            name=name,
            operator=operator,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content_id: Optional[str] = None,
             criteria: Optional[Sequence['outputs.MetadataDependenciesResponse']] = None,
             kind: Optional[str] = None,
             name: Optional[str] = None,
             operator: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if content_id is None and 'contentId' in kwargs:
            content_id = kwargs['contentId']

        if content_id is not None:
            _setter("content_id", content_id)
        if criteria is not None:
            _setter("criteria", criteria)
        if kind is not None:
            _setter("kind", kind)
        if name is not None:
            _setter("name", name)
        if operator is not None:
            _setter("operator", operator)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="contentId")
    def content_id(self) -> Optional[str]:
        """
        Id of the content item we depend on
        """
        return pulumi.get(self, "content_id")

    @property
    @pulumi.getter
    def criteria(self) -> Optional[Sequence['outputs.MetadataDependenciesResponse']]:
        """
        This is the list of dependencies we must fulfill, according to the AND/OR operator
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Type of the content item we depend on
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the content item
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator used for list of dependencies in criteria array.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MetadataSourceResponse(dict):
    """
    The original source of the content item, where it comes from.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceId":
            suggest = "source_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: str,
                 name: Optional[str] = None,
                 source_id: Optional[str] = None):
        """
        The original source of the content item, where it comes from.
        :param str kind: Source type of the content
        :param str name: Name of the content source.  The repo name, solution name, LA workspace name etc.
        :param str source_id: ID of the content source.  The solution ID, workspace ID, etc
        """
        MetadataSourceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
            name=name,
            source_id=source_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: Optional[str] = None,
             name: Optional[str] = None,
             source_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if source_id is None and 'sourceId' in kwargs:
            source_id = kwargs['sourceId']

        _setter("kind", kind)
        if name is not None:
            _setter("name", name)
        if source_id is not None:
            _setter("source_id", source_id)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Source type of the content
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the content source.  The repo name, solution name, LA workspace name etc.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[str]:
        """
        ID of the content source.  The solution ID, workspace ID, etc
        """
        return pulumi.get(self, "source_id")


@pulumi.output_type
class MetadataSupportResponse(dict):
    """
    Support information for the content item.
    """
    def __init__(__self__, *,
                 tier: str,
                 email: Optional[str] = None,
                 link: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Support information for the content item.
        :param str tier: Type of support for content item
        :param str email: Email of support contact
        :param str link: Link for support help, like to support page to open a ticket etc.
        :param str name: Name of the support contact. Company or person.
        """
        MetadataSupportResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tier=tier,
            email=email,
            link=link,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tier: Optional[str] = None,
             email: Optional[str] = None,
             link: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if tier is None:
            raise TypeError("Missing 'tier' argument")

        _setter("tier", tier)
        if email is not None:
            _setter("email", email)
        if link is not None:
            _setter("link", link)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        Type of support for content item
        """
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Email of support contact
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        Link for support help, like to support page to open a ticket etc.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the support contact. Company or person.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MicrosoftPurviewInformationProtectionConnectorDataTypesResponse(dict):
    """
    The available data types for Microsoft Purview Information Protection data connector.
    """
    def __init__(__self__, *,
                 logs: 'outputs.MicrosoftPurviewInformationProtectionConnectorDataTypesResponseLogs'):
        """
        The available data types for Microsoft Purview Information Protection data connector.
        :param 'MicrosoftPurviewInformationProtectionConnectorDataTypesResponseLogs' logs: Logs data type.
        """
        MicrosoftPurviewInformationProtectionConnectorDataTypesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            logs=logs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             logs: Optional['outputs.MicrosoftPurviewInformationProtectionConnectorDataTypesResponseLogs'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if logs is None:
            raise TypeError("Missing 'logs' argument")

        _setter("logs", logs)

    @property
    @pulumi.getter
    def logs(self) -> 'outputs.MicrosoftPurviewInformationProtectionConnectorDataTypesResponseLogs':
        """
        Logs data type.
        """
        return pulumi.get(self, "logs")


@pulumi.output_type
class MicrosoftPurviewInformationProtectionConnectorDataTypesResponseLogs(dict):
    """
    Logs data type.
    """
    def __init__(__self__, *,
                 state: str):
        """
        Logs data type.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        MicrosoftPurviewInformationProtectionConnectorDataTypesResponseLogs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MtpFilteredProvidersResponse(dict):
    """
    Represents the connector's Filtered providers
    """
    def __init__(__self__, *,
                 alerts: Sequence[str]):
        """
        Represents the connector's Filtered providers
        :param Sequence[str] alerts: Alerts filtered providers. When filters are not applied, all alerts will stream through the MTP pipeline, still in private preview for all products EXCEPT MDA and MDI, which are in GA state.
        """
        MtpFilteredProvidersResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alerts=alerts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alerts: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alerts is None:
            raise TypeError("Missing 'alerts' argument")

        _setter("alerts", alerts)

    @property
    @pulumi.getter
    def alerts(self) -> Sequence[str]:
        """
        Alerts filtered providers. When filters are not applied, all alerts will stream through the MTP pipeline, still in private preview for all products EXCEPT MDA and MDI, which are in GA state.
        """
        return pulumi.get(self, "alerts")


@pulumi.output_type
class Office365ProjectConnectorDataTypesResponse(dict):
    """
    The available data types for Office Microsoft Project data connector.
    """
    def __init__(__self__, *,
                 logs: 'outputs.Office365ProjectConnectorDataTypesResponseLogs'):
        """
        The available data types for Office Microsoft Project data connector.
        :param 'Office365ProjectConnectorDataTypesResponseLogs' logs: Logs data type.
        """
        Office365ProjectConnectorDataTypesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            logs=logs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             logs: Optional['outputs.Office365ProjectConnectorDataTypesResponseLogs'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if logs is None:
            raise TypeError("Missing 'logs' argument")

        _setter("logs", logs)

    @property
    @pulumi.getter
    def logs(self) -> 'outputs.Office365ProjectConnectorDataTypesResponseLogs':
        """
        Logs data type.
        """
        return pulumi.get(self, "logs")


@pulumi.output_type
class Office365ProjectConnectorDataTypesResponseLogs(dict):
    """
    Logs data type.
    """
    def __init__(__self__, *,
                 state: str):
        """
        Logs data type.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        Office365ProjectConnectorDataTypesResponseLogs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class OfficeDataConnectorDataTypesResponse(dict):
    """
    The available data types for office data connector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sharePoint":
            suggest = "share_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OfficeDataConnectorDataTypesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OfficeDataConnectorDataTypesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OfficeDataConnectorDataTypesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exchange: 'outputs.OfficeDataConnectorDataTypesResponseExchange',
                 share_point: 'outputs.OfficeDataConnectorDataTypesResponseSharePoint',
                 teams: 'outputs.OfficeDataConnectorDataTypesResponseTeams'):
        """
        The available data types for office data connector.
        :param 'OfficeDataConnectorDataTypesResponseExchange' exchange: Exchange data type connection.
        :param 'OfficeDataConnectorDataTypesResponseSharePoint' share_point: SharePoint data type connection.
        :param 'OfficeDataConnectorDataTypesResponseTeams' teams: Teams data type connection.
        """
        OfficeDataConnectorDataTypesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exchange=exchange,
            share_point=share_point,
            teams=teams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exchange: Optional['outputs.OfficeDataConnectorDataTypesResponseExchange'] = None,
             share_point: Optional['outputs.OfficeDataConnectorDataTypesResponseSharePoint'] = None,
             teams: Optional['outputs.OfficeDataConnectorDataTypesResponseTeams'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if exchange is None:
            raise TypeError("Missing 'exchange' argument")
        if share_point is None and 'sharePoint' in kwargs:
            share_point = kwargs['sharePoint']
        if share_point is None:
            raise TypeError("Missing 'share_point' argument")
        if teams is None:
            raise TypeError("Missing 'teams' argument")

        _setter("exchange", exchange)
        _setter("share_point", share_point)
        _setter("teams", teams)

    @property
    @pulumi.getter
    def exchange(self) -> 'outputs.OfficeDataConnectorDataTypesResponseExchange':
        """
        Exchange data type connection.
        """
        return pulumi.get(self, "exchange")

    @property
    @pulumi.getter(name="sharePoint")
    def share_point(self) -> 'outputs.OfficeDataConnectorDataTypesResponseSharePoint':
        """
        SharePoint data type connection.
        """
        return pulumi.get(self, "share_point")

    @property
    @pulumi.getter
    def teams(self) -> 'outputs.OfficeDataConnectorDataTypesResponseTeams':
        """
        Teams data type connection.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class OfficeDataConnectorDataTypesResponseExchange(dict):
    """
    Exchange data type connection.
    """
    def __init__(__self__, *,
                 state: str):
        """
        Exchange data type connection.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        OfficeDataConnectorDataTypesResponseExchange._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class OfficeDataConnectorDataTypesResponseSharePoint(dict):
    """
    SharePoint data type connection.
    """
    def __init__(__self__, *,
                 state: str):
        """
        SharePoint data type connection.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        OfficeDataConnectorDataTypesResponseSharePoint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class OfficeDataConnectorDataTypesResponseTeams(dict):
    """
    Teams data type connection.
    """
    def __init__(__self__, *,
                 state: str):
        """
        Teams data type connection.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        OfficeDataConnectorDataTypesResponseTeams._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class OfficePowerBIConnectorDataTypesResponse(dict):
    """
    The available data types for Office Microsoft PowerBI data connector.
    """
    def __init__(__self__, *,
                 logs: 'outputs.OfficePowerBIConnectorDataTypesResponseLogs'):
        """
        The available data types for Office Microsoft PowerBI data connector.
        :param 'OfficePowerBIConnectorDataTypesResponseLogs' logs: Logs data type.
        """
        OfficePowerBIConnectorDataTypesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            logs=logs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             logs: Optional['outputs.OfficePowerBIConnectorDataTypesResponseLogs'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if logs is None:
            raise TypeError("Missing 'logs' argument")

        _setter("logs", logs)

    @property
    @pulumi.getter
    def logs(self) -> 'outputs.OfficePowerBIConnectorDataTypesResponseLogs':
        """
        Logs data type.
        """
        return pulumi.get(self, "logs")


@pulumi.output_type
class OfficePowerBIConnectorDataTypesResponseLogs(dict):
    """
    Logs data type.
    """
    def __init__(__self__, *,
                 state: str):
        """
        Logs data type.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        OfficePowerBIConnectorDataTypesResponseLogs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class PermissionsResponse(dict):
    """
    Permissions required for the connector
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceProvider":
            suggest = "resource_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customs: Optional[Sequence['outputs.PermissionsResponseCustoms']] = None,
                 resource_provider: Optional[Sequence['outputs.PermissionsResponseResourceProvider']] = None):
        """
        Permissions required for the connector
        :param Sequence['PermissionsResponseCustoms'] customs: Customs permissions required for the connector
        :param Sequence['PermissionsResponseResourceProvider'] resource_provider: Resource provider permissions required for the connector
        """
        PermissionsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            customs=customs,
            resource_provider=resource_provider,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             customs: Optional[Sequence['outputs.PermissionsResponseCustoms']] = None,
             resource_provider: Optional[Sequence['outputs.PermissionsResponseResourceProvider']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_provider is None and 'resourceProvider' in kwargs:
            resource_provider = kwargs['resourceProvider']

        if customs is not None:
            _setter("customs", customs)
        if resource_provider is not None:
            _setter("resource_provider", resource_provider)

    @property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.PermissionsResponseCustoms']]:
        """
        Customs permissions required for the connector
        """
        return pulumi.get(self, "customs")

    @property
    @pulumi.getter(name="resourceProvider")
    def resource_provider(self) -> Optional[Sequence['outputs.PermissionsResponseResourceProvider']]:
        """
        Resource provider permissions required for the connector
        """
        return pulumi.get(self, "resource_provider")


@pulumi.output_type
class PermissionsResponseCustoms(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str description: Customs permissions description
        :param str name: Customs permissions name
        """
        PermissionsResponseCustoms._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if description is not None:
            _setter("description", description)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Customs permissions description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Customs permissions name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PermissionsResponseResourceProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionsDisplayText":
            suggest = "permissions_display_text"
        elif key == "providerDisplayName":
            suggest = "provider_display_name"
        elif key == "requiredPermissions":
            suggest = "required_permissions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PermissionsResponseResourceProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PermissionsResponseResourceProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PermissionsResponseResourceProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permissions_display_text: Optional[str] = None,
                 provider: Optional[str] = None,
                 provider_display_name: Optional[str] = None,
                 required_permissions: Optional['outputs.RequiredPermissionsResponse'] = None,
                 scope: Optional[str] = None):
        """
        :param str permissions_display_text: Permission description text
        :param str provider: Provider name
        :param str provider_display_name: Permission provider display name
        :param 'RequiredPermissionsResponse' required_permissions: Required permissions for the connector
        :param str scope: Permission provider scope
        """
        PermissionsResponseResourceProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            permissions_display_text=permissions_display_text,
            provider=provider,
            provider_display_name=provider_display_name,
            required_permissions=required_permissions,
            scope=scope,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             permissions_display_text: Optional[str] = None,
             provider: Optional[str] = None,
             provider_display_name: Optional[str] = None,
             required_permissions: Optional['outputs.RequiredPermissionsResponse'] = None,
             scope: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if permissions_display_text is None and 'permissionsDisplayText' in kwargs:
            permissions_display_text = kwargs['permissionsDisplayText']
        if provider_display_name is None and 'providerDisplayName' in kwargs:
            provider_display_name = kwargs['providerDisplayName']
        if required_permissions is None and 'requiredPermissions' in kwargs:
            required_permissions = kwargs['requiredPermissions']

        if permissions_display_text is not None:
            _setter("permissions_display_text", permissions_display_text)
        if provider is not None:
            _setter("provider", provider)
        if provider_display_name is not None:
            _setter("provider_display_name", provider_display_name)
        if required_permissions is not None:
            _setter("required_permissions", required_permissions)
        if scope is not None:
            _setter("scope", scope)

    @property
    @pulumi.getter(name="permissionsDisplayText")
    def permissions_display_text(self) -> Optional[str]:
        """
        Permission description text
        """
        return pulumi.get(self, "permissions_display_text")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Provider name
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="providerDisplayName")
    def provider_display_name(self) -> Optional[str]:
        """
        Permission provider display name
        """
        return pulumi.get(self, "provider_display_name")

    @property
    @pulumi.getter(name="requiredPermissions")
    def required_permissions(self) -> Optional['outputs.RequiredPermissionsResponse']:
        """
        Required permissions for the connector
        """
        return pulumi.get(self, "required_permissions")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        Permission provider scope
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class PlaybookActionPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logicAppResourceId":
            suggest = "logic_app_resource_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlaybookActionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlaybookActionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlaybookActionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logic_app_resource_id: str,
                 tenant_id: Optional[str] = None):
        """
        :param str logic_app_resource_id: The resource id of the playbook resource.
        :param str tenant_id: The tenant id of the playbook resource.
        """
        PlaybookActionPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            logic_app_resource_id=logic_app_resource_id,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             logic_app_resource_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if logic_app_resource_id is None and 'logicAppResourceId' in kwargs:
            logic_app_resource_id = kwargs['logicAppResourceId']
        if logic_app_resource_id is None:
            raise TypeError("Missing 'logic_app_resource_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']

        _setter("logic_app_resource_id", logic_app_resource_id)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter(name="logicAppResourceId")
    def logic_app_resource_id(self) -> str:
        """
        The resource id of the playbook resource.
        """
        return pulumi.get(self, "logic_app_resource_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The tenant id of the playbook resource.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class PropertyArrayChangedConditionPropertiesResponse(dict):
    """
    Describes an automation rule condition that evaluates an array property's value change
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"
        elif key == "conditionProperties":
            suggest = "condition_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyArrayChangedConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyArrayChangedConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyArrayChangedConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: str,
                 condition_properties: Optional['outputs.AutomationRulePropertyArrayChangedValuesConditionResponse'] = None):
        """
        Describes an automation rule condition that evaluates an array property's value change
        :param str condition_type: 
               Expected value is 'PropertyArrayChanged'.
        """
        PropertyArrayChangedConditionPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_type=condition_type,
            condition_properties=condition_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_type: Optional[str] = None,
             condition_properties: Optional['outputs.AutomationRulePropertyArrayChangedValuesConditionResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if condition_type is None and 'conditionType' in kwargs:
            condition_type = kwargs['conditionType']
        if condition_type is None:
            raise TypeError("Missing 'condition_type' argument")
        if condition_properties is None and 'conditionProperties' in kwargs:
            condition_properties = kwargs['conditionProperties']

        _setter("condition_type", 'PropertyArrayChanged')
        if condition_properties is not None:
            _setter("condition_properties", condition_properties)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> str:
        """

        Expected value is 'PropertyArrayChanged'.
        """
        return pulumi.get(self, "condition_type")

    @property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional['outputs.AutomationRulePropertyArrayChangedValuesConditionResponse']:
        return pulumi.get(self, "condition_properties")


@pulumi.output_type
class PropertyArrayConditionPropertiesResponse(dict):
    """
    Describes an automation rule condition that evaluates an array property's value
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"
        elif key == "conditionProperties":
            suggest = "condition_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyArrayConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyArrayConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyArrayConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: str,
                 condition_properties: Optional['outputs.AutomationRulePropertyArrayValuesConditionResponse'] = None):
        """
        Describes an automation rule condition that evaluates an array property's value
        :param str condition_type: 
               Expected value is 'PropertyArray'.
        """
        PropertyArrayConditionPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_type=condition_type,
            condition_properties=condition_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_type: Optional[str] = None,
             condition_properties: Optional['outputs.AutomationRulePropertyArrayValuesConditionResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if condition_type is None and 'conditionType' in kwargs:
            condition_type = kwargs['conditionType']
        if condition_type is None:
            raise TypeError("Missing 'condition_type' argument")
        if condition_properties is None and 'conditionProperties' in kwargs:
            condition_properties = kwargs['conditionProperties']

        _setter("condition_type", 'PropertyArray')
        if condition_properties is not None:
            _setter("condition_properties", condition_properties)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> str:
        """

        Expected value is 'PropertyArray'.
        """
        return pulumi.get(self, "condition_type")

    @property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional['outputs.AutomationRulePropertyArrayValuesConditionResponse']:
        return pulumi.get(self, "condition_properties")


@pulumi.output_type
class PropertyChangedConditionPropertiesResponse(dict):
    """
    Describes an automation rule condition that evaluates a property's value change
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"
        elif key == "conditionProperties":
            suggest = "condition_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyChangedConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyChangedConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyChangedConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: str,
                 condition_properties: Optional['outputs.AutomationRulePropertyValuesChangedConditionResponse'] = None):
        """
        Describes an automation rule condition that evaluates a property's value change
        :param str condition_type: 
               Expected value is 'PropertyChanged'.
        """
        PropertyChangedConditionPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_type=condition_type,
            condition_properties=condition_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_type: Optional[str] = None,
             condition_properties: Optional['outputs.AutomationRulePropertyValuesChangedConditionResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if condition_type is None and 'conditionType' in kwargs:
            condition_type = kwargs['conditionType']
        if condition_type is None:
            raise TypeError("Missing 'condition_type' argument")
        if condition_properties is None and 'conditionProperties' in kwargs:
            condition_properties = kwargs['conditionProperties']

        _setter("condition_type", 'PropertyChanged')
        if condition_properties is not None:
            _setter("condition_properties", condition_properties)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> str:
        """

        Expected value is 'PropertyChanged'.
        """
        return pulumi.get(self, "condition_type")

    @property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional['outputs.AutomationRulePropertyValuesChangedConditionResponse']:
        return pulumi.get(self, "condition_properties")


@pulumi.output_type
class PropertyConditionPropertiesResponse(dict):
    """
    Describes an automation rule condition that evaluates a property's value
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"
        elif key == "conditionProperties":
            suggest = "condition_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: str,
                 condition_properties: Optional['outputs.AutomationRulePropertyValuesConditionResponse'] = None):
        """
        Describes an automation rule condition that evaluates a property's value
        :param str condition_type: 
               Expected value is 'Property'.
        """
        PropertyConditionPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_type=condition_type,
            condition_properties=condition_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_type: Optional[str] = None,
             condition_properties: Optional['outputs.AutomationRulePropertyValuesConditionResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if condition_type is None and 'conditionType' in kwargs:
            condition_type = kwargs['conditionType']
        if condition_type is None:
            raise TypeError("Missing 'condition_type' argument")
        if condition_properties is None and 'conditionProperties' in kwargs:
            condition_properties = kwargs['conditionProperties']

        _setter("condition_type", 'Property')
        if condition_properties is not None:
            _setter("condition_properties", condition_properties)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> str:
        """

        Expected value is 'Property'.
        """
        return pulumi.get(self, "condition_type")

    @property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional['outputs.AutomationRulePropertyValuesConditionResponse']:
        return pulumi.get(self, "condition_properties")


@pulumi.output_type
class RepoResponse(dict):
    """
    Represents a repository.
    """
    def __init__(__self__, *,
                 branches: Optional[Sequence[str]] = None,
                 full_name: Optional[str] = None,
                 url: Optional[str] = None):
        """
        Represents a repository.
        :param Sequence[str] branches: Array of branches.
        :param str full_name: The name of the repository.
        :param str url: The url to access the repository.
        """
        RepoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            branches=branches,
            full_name=full_name,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             branches: Optional[Sequence[str]] = None,
             full_name: Optional[str] = None,
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if full_name is None and 'fullName' in kwargs:
            full_name = kwargs['fullName']

        if branches is not None:
            _setter("branches", branches)
        if full_name is not None:
            _setter("full_name", full_name)
        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter
    def branches(self) -> Optional[Sequence[str]]:
        """
        Array of branches.
        """
        return pulumi.get(self, "branches")

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[str]:
        """
        The name of the repository.
        """
        return pulumi.get(self, "full_name")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The url to access the repository.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class RequiredPermissionsResponse(dict):
    """
    Required permissions for the connector
    """
    def __init__(__self__, *,
                 action: Optional[bool] = None,
                 delete: Optional[bool] = None,
                 read: Optional[bool] = None,
                 write: Optional[bool] = None):
        """
        Required permissions for the connector
        :param bool action: action permission
        :param bool delete: delete permission
        :param bool read: read permission
        :param bool write: write permission
        """
        RequiredPermissionsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            delete=delete,
            read=read,
            write=write,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[bool] = None,
             delete: Optional[bool] = None,
             read: Optional[bool] = None,
             write: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if action is not None:
            _setter("action", action)
        if delete is not None:
            _setter("delete", delete)
        if read is not None:
            _setter("read", read)
        if write is not None:
            _setter("write", write)

    @property
    @pulumi.getter
    def action(self) -> Optional[bool]:
        """
        action permission
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def delete(self) -> Optional[bool]:
        """
        delete permission
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[bool]:
        """
        read permission
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def write(self) -> Optional[bool]:
        """
        write permission
        """
        return pulumi.get(self, "write")


@pulumi.output_type
class SecurityAlertTimelineItemResponse(dict):
    """
    Represents security alert timeline item.
    """
    def __init__(__self__, *,
                 alert_type: str,
                 azure_resource_id: str,
                 display_name: str,
                 end_time_utc: str,
                 intent: str,
                 kind: str,
                 severity: str,
                 start_time_utc: str,
                 time_generated: str,
                 description: Optional[str] = None,
                 product_name: Optional[str] = None,
                 techniques: Optional[Sequence[str]] = None):
        """
        Represents security alert timeline item.
        :param str alert_type: The name of the alert type.
        :param str azure_resource_id: The alert azure resource id.
        :param str display_name: The alert name.
        :param str end_time_utc: The alert end time.
        :param str intent: The intent of the alert.
        :param str kind: The entity query kind
               Expected value is 'SecurityAlert'.
        :param str severity: The alert severity.
        :param str start_time_utc: The alert start time.
        :param str time_generated: The alert generated time.
        :param str description: The alert description.
        :param str product_name: The alert product name.
        :param Sequence[str] techniques: The techniques of the alert.
        """
        SecurityAlertTimelineItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_type=alert_type,
            azure_resource_id=azure_resource_id,
            display_name=display_name,
            end_time_utc=end_time_utc,
            intent=intent,
            kind=kind,
            severity=severity,
            start_time_utc=start_time_utc,
            time_generated=time_generated,
            description=description,
            product_name=product_name,
            techniques=techniques,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_type: Optional[str] = None,
             azure_resource_id: Optional[str] = None,
             display_name: Optional[str] = None,
             end_time_utc: Optional[str] = None,
             intent: Optional[str] = None,
             kind: Optional[str] = None,
             severity: Optional[str] = None,
             start_time_utc: Optional[str] = None,
             time_generated: Optional[str] = None,
             description: Optional[str] = None,
             product_name: Optional[str] = None,
             techniques: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alert_type is None and 'alertType' in kwargs:
            alert_type = kwargs['alertType']
        if alert_type is None:
            raise TypeError("Missing 'alert_type' argument")
        if azure_resource_id is None and 'azureResourceId' in kwargs:
            azure_resource_id = kwargs['azureResourceId']
        if azure_resource_id is None:
            raise TypeError("Missing 'azure_resource_id' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if end_time_utc is None and 'endTimeUtc' in kwargs:
            end_time_utc = kwargs['endTimeUtc']
        if end_time_utc is None:
            raise TypeError("Missing 'end_time_utc' argument")
        if intent is None:
            raise TypeError("Missing 'intent' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if start_time_utc is None and 'startTimeUtc' in kwargs:
            start_time_utc = kwargs['startTimeUtc']
        if start_time_utc is None:
            raise TypeError("Missing 'start_time_utc' argument")
        if time_generated is None and 'timeGenerated' in kwargs:
            time_generated = kwargs['timeGenerated']
        if time_generated is None:
            raise TypeError("Missing 'time_generated' argument")
        if product_name is None and 'productName' in kwargs:
            product_name = kwargs['productName']

        _setter("alert_type", alert_type)
        _setter("azure_resource_id", azure_resource_id)
        _setter("display_name", display_name)
        _setter("end_time_utc", end_time_utc)
        _setter("intent", intent)
        _setter("kind", 'SecurityAlert')
        _setter("severity", severity)
        _setter("start_time_utc", start_time_utc)
        _setter("time_generated", time_generated)
        if description is not None:
            _setter("description", description)
        if product_name is not None:
            _setter("product_name", product_name)
        if techniques is not None:
            _setter("techniques", techniques)

    @property
    @pulumi.getter(name="alertType")
    def alert_type(self) -> str:
        """
        The name of the alert type.
        """
        return pulumi.get(self, "alert_type")

    @property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> str:
        """
        The alert azure resource id.
        """
        return pulumi.get(self, "azure_resource_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The alert name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> str:
        """
        The alert end time.
        """
        return pulumi.get(self, "end_time_utc")

    @property
    @pulumi.getter
    def intent(self) -> str:
        """
        The intent of the alert.
        """
        return pulumi.get(self, "intent")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The entity query kind
        Expected value is 'SecurityAlert'.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The alert severity.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> str:
        """
        The alert start time.
        """
        return pulumi.get(self, "start_time_utc")

    @property
    @pulumi.getter(name="timeGenerated")
    def time_generated(self) -> str:
        """
        The alert generated time.
        """
        return pulumi.get(self, "time_generated")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The alert description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        """
        The alert product name.
        """
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter
    def techniques(self) -> Optional[Sequence[str]]:
        """
        The techniques of the alert.
        """
        return pulumi.get(self, "techniques")


@pulumi.output_type
class SecurityMLAnalyticsSettingsDataSourceResponse(dict):
    """
    security ml analytics settings data sources
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorId":
            suggest = "connector_id"
        elif key == "dataTypes":
            suggest = "data_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMLAnalyticsSettingsDataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMLAnalyticsSettingsDataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMLAnalyticsSettingsDataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_id: Optional[str] = None,
                 data_types: Optional[Sequence[str]] = None):
        """
        security ml analytics settings data sources
        :param str connector_id: The connector id that provides the following data types
        :param Sequence[str] data_types: The data types used by the security ml analytics settings
        """
        SecurityMLAnalyticsSettingsDataSourceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connector_id=connector_id,
            data_types=data_types,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connector_id: Optional[str] = None,
             data_types: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if connector_id is None and 'connectorId' in kwargs:
            connector_id = kwargs['connectorId']
        if data_types is None and 'dataTypes' in kwargs:
            data_types = kwargs['dataTypes']

        if connector_id is not None:
            _setter("connector_id", connector_id)
        if data_types is not None:
            _setter("data_types", data_types)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[str]:
        """
        The connector id that provides the following data types
        """
        return pulumi.get(self, "connector_id")

    @property
    @pulumi.getter(name="dataTypes")
    def data_types(self) -> Optional[Sequence[str]]:
        """
        The data types used by the security ml analytics settings
        """
        return pulumi.get(self, "data_types")


@pulumi.output_type
class SentinelEntityMappingResponse(dict):
    """
    A single sentinel entity mapping
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SentinelEntityMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SentinelEntityMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SentinelEntityMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: Optional[str] = None):
        """
        A single sentinel entity mapping
        :param str column_name: the column name to be mapped to the SentinelEntities
        """
        SentinelEntityMappingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']

        if column_name is not None:
            _setter("column_name", column_name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[str]:
        """
        the column name to be mapped to the SentinelEntities
        """
        return pulumi.get(self, "column_name")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TIDataConnectorDataTypesResponse(dict):
    """
    The available data types for TI (Threat Intelligence) data connector.
    """
    def __init__(__self__, *,
                 indicators: 'outputs.TIDataConnectorDataTypesResponseIndicators'):
        """
        The available data types for TI (Threat Intelligence) data connector.
        :param 'TIDataConnectorDataTypesResponseIndicators' indicators: Data type for indicators connection.
        """
        TIDataConnectorDataTypesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            indicators=indicators,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             indicators: Optional['outputs.TIDataConnectorDataTypesResponseIndicators'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if indicators is None:
            raise TypeError("Missing 'indicators' argument")

        _setter("indicators", indicators)

    @property
    @pulumi.getter
    def indicators(self) -> 'outputs.TIDataConnectorDataTypesResponseIndicators':
        """
        Data type for indicators connection.
        """
        return pulumi.get(self, "indicators")


@pulumi.output_type
class TIDataConnectorDataTypesResponseIndicators(dict):
    """
    Data type for indicators connection.
    """
    def __init__(__self__, *,
                 state: str):
        """
        Data type for indicators connection.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        TIDataConnectorDataTypesResponseIndicators._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class TeamInformationResponse(dict):
    """
    Describes team information
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryChannelUrl":
            suggest = "primary_channel_url"
        elif key == "teamCreationTimeUtc":
            suggest = "team_creation_time_utc"
        elif key == "teamId":
            suggest = "team_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 name: str,
                 primary_channel_url: str,
                 team_creation_time_utc: str,
                 team_id: str):
        """
        Describes team information
        :param str description: The description of the team
        :param str name: The name of the team
        :param str primary_channel_url: The primary channel URL of the team
        :param str team_creation_time_utc: The time the team was created
        :param str team_id: Team ID
        """
        TeamInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            name=name,
            primary_channel_url=primary_channel_url,
            team_creation_time_utc=team_creation_time_utc,
            team_id=team_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             name: Optional[str] = None,
             primary_channel_url: Optional[str] = None,
             team_creation_time_utc: Optional[str] = None,
             team_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if primary_channel_url is None and 'primaryChannelUrl' in kwargs:
            primary_channel_url = kwargs['primaryChannelUrl']
        if primary_channel_url is None:
            raise TypeError("Missing 'primary_channel_url' argument")
        if team_creation_time_utc is None and 'teamCreationTimeUtc' in kwargs:
            team_creation_time_utc = kwargs['teamCreationTimeUtc']
        if team_creation_time_utc is None:
            raise TypeError("Missing 'team_creation_time_utc' argument")
        if team_id is None and 'teamId' in kwargs:
            team_id = kwargs['teamId']
        if team_id is None:
            raise TypeError("Missing 'team_id' argument")

        _setter("description", description)
        _setter("name", name)
        _setter("primary_channel_url", primary_channel_url)
        _setter("team_creation_time_utc", team_creation_time_utc)
        _setter("team_id", team_id)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the team
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryChannelUrl")
    def primary_channel_url(self) -> str:
        """
        The primary channel URL of the team
        """
        return pulumi.get(self, "primary_channel_url")

    @property
    @pulumi.getter(name="teamCreationTimeUtc")
    def team_creation_time_utc(self) -> str:
        """
        The time the team was created
        """
        return pulumi.get(self, "team_creation_time_utc")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        Team ID
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class TiTaxiiDataConnectorDataTypesResponse(dict):
    """
    The available data types for Threat Intelligence TAXII data connector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taxiiClient":
            suggest = "taxii_client"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TiTaxiiDataConnectorDataTypesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TiTaxiiDataConnectorDataTypesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TiTaxiiDataConnectorDataTypesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 taxii_client: 'outputs.TiTaxiiDataConnectorDataTypesResponseTaxiiClient'):
        """
        The available data types for Threat Intelligence TAXII data connector.
        :param 'TiTaxiiDataConnectorDataTypesResponseTaxiiClient' taxii_client: Data type for TAXII connector.
        """
        TiTaxiiDataConnectorDataTypesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            taxii_client=taxii_client,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             taxii_client: Optional['outputs.TiTaxiiDataConnectorDataTypesResponseTaxiiClient'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if taxii_client is None and 'taxiiClient' in kwargs:
            taxii_client = kwargs['taxiiClient']
        if taxii_client is None:
            raise TypeError("Missing 'taxii_client' argument")

        _setter("taxii_client", taxii_client)

    @property
    @pulumi.getter(name="taxiiClient")
    def taxii_client(self) -> 'outputs.TiTaxiiDataConnectorDataTypesResponseTaxiiClient':
        """
        Data type for TAXII connector.
        """
        return pulumi.get(self, "taxii_client")


@pulumi.output_type
class TiTaxiiDataConnectorDataTypesResponseTaxiiClient(dict):
    """
    Data type for TAXII connector.
    """
    def __init__(__self__, *,
                 state: str):
        """
        Data type for TAXII connector.
        :param str state: Describe whether this data type connection is enabled or not.
        """
        TiTaxiiDataConnectorDataTypesResponseTaxiiClient._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("state", state)

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class TimelineAggregationResponse(dict):
    """
    timeline aggregation information per kind
    """
    def __init__(__self__, *,
                 count: int,
                 kind: str):
        """
        timeline aggregation information per kind
        :param int count: the total items found for a kind
        :param str kind: the query kind
        """
        TimelineAggregationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             kind: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")

        _setter("count", count)
        _setter("kind", kind)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        the total items found for a kind
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        the query kind
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class TimelineErrorResponse(dict):
    """
    Timeline Query Errors.
    """
    def __init__(__self__, *,
                 error_message: str,
                 kind: str,
                 query_id: Optional[str] = None):
        """
        Timeline Query Errors.
        :param str error_message: the error message
        :param str kind: the query kind
        :param str query_id: the query id
        """
        TimelineErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error_message=error_message,
            kind=kind,
            query_id=query_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error_message: Optional[str] = None,
             kind: Optional[str] = None,
             query_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error_message is None and 'errorMessage' in kwargs:
            error_message = kwargs['errorMessage']
        if error_message is None:
            raise TypeError("Missing 'error_message' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if query_id is None and 'queryId' in kwargs:
            query_id = kwargs['queryId']

        _setter("error_message", error_message)
        _setter("kind", kind)
        if query_id is not None:
            _setter("query_id", query_id)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        the error message
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        the query kind
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> Optional[str]:
        """
        the query id
        """
        return pulumi.get(self, "query_id")


@pulumi.output_type
class TimelineResultsMetadataResponse(dict):
    """
    Expansion result metadata.
    """
    def __init__(__self__, *,
                 aggregations: Sequence['outputs.TimelineAggregationResponse'],
                 total_count: int,
                 errors: Optional[Sequence['outputs.TimelineErrorResponse']] = None):
        """
        Expansion result metadata.
        :param Sequence['TimelineAggregationResponse'] aggregations: timeline aggregation per kind
        :param int total_count: the total items found for the timeline request
        :param Sequence['TimelineErrorResponse'] errors: information about the failure queries
        """
        TimelineResultsMetadataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregations=aggregations,
            total_count=total_count,
            errors=errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregations: Optional[Sequence['outputs.TimelineAggregationResponse']] = None,
             total_count: Optional[int] = None,
             errors: Optional[Sequence['outputs.TimelineErrorResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aggregations is None:
            raise TypeError("Missing 'aggregations' argument")
        if total_count is None and 'totalCount' in kwargs:
            total_count = kwargs['totalCount']
        if total_count is None:
            raise TypeError("Missing 'total_count' argument")

        _setter("aggregations", aggregations)
        _setter("total_count", total_count)
        if errors is not None:
            _setter("errors", errors)

    @property
    @pulumi.getter
    def aggregations(self) -> Sequence['outputs.TimelineAggregationResponse']:
        """
        timeline aggregation per kind
        """
        return pulumi.get(self, "aggregations")

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> int:
        """
        the total items found for the timeline request
        """
        return pulumi.get(self, "total_count")

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.TimelineErrorResponse']]:
        """
        information about the failure queries
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class UserInfoResponse(dict):
    """
    User information that made some action
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectId":
            suggest = "object_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 name: str,
                 object_id: Optional[str] = None):
        """
        User information that made some action
        :param str email: The email of the user.
        :param str name: The name of the user.
        :param str object_id: The object id of the user.
        """
        UserInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            name=name,
            object_id=object_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: Optional[str] = None,
             name: Optional[str] = None,
             object_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if email is None:
            raise TypeError("Missing 'email' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if object_id is None and 'objectId' in kwargs:
            object_id = kwargs['objectId']

        _setter("email", email)
        _setter("name", name)
        if object_id is not None:
            _setter("object_id", object_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[str]:
        """
        The object id of the user.
        """
        return pulumi.get(self, "object_id")


@pulumi.output_type
class ValidationErrorResponse(dict):
    """
    Describes an error encountered in the file during validation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessages":
            suggest = "error_messages"
        elif key == "recordIndex":
            suggest = "record_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidationErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidationErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidationErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_messages: Sequence[str],
                 record_index: Optional[int] = None):
        """
        Describes an error encountered in the file during validation.
        :param Sequence[str] error_messages: A list of descriptions of the error.
        :param int record_index: The number of the record that has the error.
        """
        ValidationErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error_messages=error_messages,
            record_index=record_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error_messages: Optional[Sequence[str]] = None,
             record_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error_messages is None and 'errorMessages' in kwargs:
            error_messages = kwargs['errorMessages']
        if error_messages is None:
            raise TypeError("Missing 'error_messages' argument")
        if record_index is None and 'recordIndex' in kwargs:
            record_index = kwargs['recordIndex']

        _setter("error_messages", error_messages)
        if record_index is not None:
            _setter("record_index", record_index)

    @property
    @pulumi.getter(name="errorMessages")
    def error_messages(self) -> Sequence[str]:
        """
        A list of descriptions of the error.
        """
        return pulumi.get(self, "error_messages")

    @property
    @pulumi.getter(name="recordIndex")
    def record_index(self) -> Optional[int]:
        """
        The number of the record that has the error.
        """
        return pulumi.get(self, "record_index")


@pulumi.output_type
class WatchlistUserInfoResponse(dict):
    """
    User information that made some action
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectId":
            suggest = "object_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WatchlistUserInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WatchlistUserInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WatchlistUserInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 name: str,
                 object_id: Optional[str] = None):
        """
        User information that made some action
        :param str email: The email of the user.
        :param str name: The name of the user.
        :param str object_id: The object id of the user.
        """
        WatchlistUserInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            name=name,
            object_id=object_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: Optional[str] = None,
             name: Optional[str] = None,
             object_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if email is None:
            raise TypeError("Missing 'email' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if object_id is None and 'objectId' in kwargs:
            object_id = kwargs['objectId']

        _setter("email", email)
        _setter("name", name)
        if object_id is not None:
            _setter("object_id", object_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[str]:
        """
        The object id of the user.
        """
        return pulumi.get(self, "object_id")


