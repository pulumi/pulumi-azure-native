# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ActivityEntityQueriesPropertiesQueryDefinitionsArgs',
    'ActivityEntityQueriesPropertiesQueryDefinitionsArgsDict',
    'AlertDetailsOverrideArgs',
    'AlertDetailsOverrideArgsDict',
    'AlertPropertyMappingArgs',
    'AlertPropertyMappingArgsDict',
    'AlertsDataTypeOfDataConnectorArgs',
    'AlertsDataTypeOfDataConnectorArgsDict',
    'AssignmentItemArgs',
    'AssignmentItemArgsDict',
    'AutomationRuleModifyPropertiesActionArgs',
    'AutomationRuleModifyPropertiesActionArgsDict',
    'AutomationRulePropertyArrayChangedValuesConditionArgs',
    'AutomationRulePropertyArrayChangedValuesConditionArgsDict',
    'AutomationRulePropertyValuesChangedConditionArgs',
    'AutomationRulePropertyValuesChangedConditionArgsDict',
    'AutomationRulePropertyValuesConditionArgs',
    'AutomationRulePropertyValuesConditionArgsDict',
    'AutomationRuleRunPlaybookActionArgs',
    'AutomationRuleRunPlaybookActionArgsDict',
    'AutomationRuleTriggeringLogicArgs',
    'AutomationRuleTriggeringLogicArgsDict',
    'AwsCloudTrailDataConnectorDataTypesLogsArgs',
    'AwsCloudTrailDataConnectorDataTypesLogsArgsDict',
    'AwsCloudTrailDataConnectorDataTypesArgs',
    'AwsCloudTrailDataConnectorDataTypesArgsDict',
    'AzureDevOpsResourceInfoArgs',
    'AzureDevOpsResourceInfoArgsDict',
    'ClientInfoArgs',
    'ClientInfoArgsDict',
    'ConnectivityCriterionArgs',
    'ConnectivityCriterionArgsDict',
    'ConnectorDataTypeArgs',
    'ConnectorDataTypeArgsDict',
    'ConnectorDefinitionsAvailabilityArgs',
    'ConnectorDefinitionsAvailabilityArgsDict',
    'ConnectorDefinitionsPermissionsArgs',
    'ConnectorDefinitionsPermissionsArgsDict',
    'ConnectorDefinitionsResourceProviderArgs',
    'ConnectorDefinitionsResourceProviderArgsDict',
    'ContentPathMapArgs',
    'ContentPathMapArgsDict',
    'CustomPermissionDetailsArgs',
    'CustomPermissionDetailsArgsDict',
    'CustomizableConnectionsConfigArgs',
    'CustomizableConnectionsConfigArgsDict',
    'CustomizableConnectorUiConfigArgs',
    'CustomizableConnectorUiConfigArgsDict',
    'DataConnectorDataTypeCommonArgs',
    'DataConnectorDataTypeCommonArgsDict',
    'DeploymentInfoArgs',
    'DeploymentInfoArgsDict',
    'DeploymentArgs',
    'DeploymentArgsDict',
    'EntityMappingArgs',
    'EntityMappingArgsDict',
    'EventGroupingSettingsArgs',
    'EventGroupingSettingsArgsDict',
    'FieldMappingArgs',
    'FieldMappingArgsDict',
    'FileMetadataArgs',
    'FileMetadataArgsDict',
    'GitHubResourceInfoArgs',
    'GitHubResourceInfoArgsDict',
    'GraphQueryArgs',
    'GraphQueryArgsDict',
    'GroupingConfigurationArgs',
    'GroupingConfigurationArgsDict',
    'HuntOwnerArgs',
    'HuntOwnerArgsDict',
    'IncidentConfigurationArgs',
    'IncidentConfigurationArgsDict',
    'IncidentInfoArgs',
    'IncidentInfoArgsDict',
    'IncidentLabelArgs',
    'IncidentLabelArgsDict',
    'IncidentOwnerInfoArgs',
    'IncidentOwnerInfoArgsDict',
    'IncidentPropertiesActionArgs',
    'IncidentPropertiesActionArgsDict',
    'InstructionStepDetailsArgs',
    'InstructionStepDetailsArgsDict',
    'InstructionStepArgs',
    'InstructionStepArgsDict',
    'LogArgs',
    'LogArgsDict',
    'MCASDataConnectorDataTypesArgs',
    'MCASDataConnectorDataTypesArgsDict',
    'MetadataAuthorArgs',
    'MetadataAuthorArgsDict',
    'MetadataCategoriesArgs',
    'MetadataCategoriesArgsDict',
    'MetadataDependenciesArgs',
    'MetadataDependenciesArgsDict',
    'MetadataSourceArgs',
    'MetadataSourceArgsDict',
    'MetadataSupportArgs',
    'MetadataSupportArgsDict',
    'OfficeDataConnectorDataTypesExchangeArgs',
    'OfficeDataConnectorDataTypesExchangeArgsDict',
    'OfficeDataConnectorDataTypesSharePointArgs',
    'OfficeDataConnectorDataTypesSharePointArgsDict',
    'OfficeDataConnectorDataTypesTeamsArgs',
    'OfficeDataConnectorDataTypesTeamsArgsDict',
    'OfficeDataConnectorDataTypesArgs',
    'OfficeDataConnectorDataTypesArgsDict',
    'PlaybookActionPropertiesArgs',
    'PlaybookActionPropertiesArgsDict',
    'PropertyArrayChangedConditionPropertiesArgs',
    'PropertyArrayChangedConditionPropertiesArgsDict',
    'PropertyChangedConditionPropertiesArgs',
    'PropertyChangedConditionPropertiesArgsDict',
    'PropertyConditionPropertiesArgs',
    'PropertyConditionPropertiesArgsDict',
    'RepositoryResourceInfoArgs',
    'RepositoryResourceInfoArgsDict',
    'RepositoryArgs',
    'RepositoryArgsDict',
    'ResourceProviderRequiredPermissionsArgs',
    'ResourceProviderRequiredPermissionsArgsDict',
    'RfcConnectorArgs',
    'RfcConnectorArgsDict',
    'SampleQueryArgs',
    'SampleQueryArgsDict',
    'SapAgentConfigurationArgs',
    'SapAgentConfigurationArgsDict',
    'SapControlConnectorArgs',
    'SapControlConnectorArgsDict',
    'SapSystemsConfigurationArgs',
    'SapSystemsConfigurationArgsDict',
    'SecurityMLAnalyticsSettingsDataSourceArgs',
    'SecurityMLAnalyticsSettingsDataSourceArgsDict',
    'TIDataConnectorDataTypesIndicatorsArgs',
    'TIDataConnectorDataTypesIndicatorsArgsDict',
    'TIDataConnectorDataTypesArgs',
    'TIDataConnectorDataTypesArgsDict',
    'ThreatIntelligenceExternalReferenceArgs',
    'ThreatIntelligenceExternalReferenceArgsDict',
    'ThreatIntelligenceGranularMarkingModelArgs',
    'ThreatIntelligenceGranularMarkingModelArgsDict',
    'ThreatIntelligenceKillChainPhaseArgs',
    'ThreatIntelligenceKillChainPhaseArgsDict',
    'ThreatIntelligenceParsedPatternTypeValueArgs',
    'ThreatIntelligenceParsedPatternTypeValueArgsDict',
    'ThreatIntelligenceParsedPatternArgs',
    'ThreatIntelligenceParsedPatternArgsDict',
    'UserInfoArgs',
    'UserInfoArgsDict',
    'WatchlistUserInfoArgs',
    'WatchlistUserInfoArgsDict',
    'WebhookArgs',
    'WebhookArgsDict',
]

MYPY = False

if not MYPY:
    class ActivityEntityQueriesPropertiesQueryDefinitionsArgsDict(TypedDict):
        """
        The Activity query definitions
        """
        query: NotRequired[pulumi.Input[str]]
        """
        The Activity query to run on a given entity
        """
elif False:
    ActivityEntityQueriesPropertiesQueryDefinitionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActivityEntityQueriesPropertiesQueryDefinitionsArgs:
    def __init__(__self__, *,
                 query: Optional[pulumi.Input[str]] = None):
        """
        The Activity query definitions
        :param pulumi.Input[str] query: The Activity query to run on a given entity
        """
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        The Activity query to run on a given entity
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


if not MYPY:
    class AlertDetailsOverrideArgsDict(TypedDict):
        """
        Settings for how to dynamically override alert static details
        """
        alert_description_format: NotRequired[pulumi.Input[str]]
        """
        the format containing columns name(s) to override the alert description
        """
        alert_display_name_format: NotRequired[pulumi.Input[str]]
        """
        the format containing columns name(s) to override the alert name
        """
        alert_dynamic_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertPropertyMappingArgsDict']]]]
        """
        List of additional dynamic properties to override
        """
        alert_severity_column_name: NotRequired[pulumi.Input[str]]
        """
        the column name to take the alert severity from
        """
        alert_tactics_column_name: NotRequired[pulumi.Input[str]]
        """
        the column name to take the alert tactics from
        """
elif False:
    AlertDetailsOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertDetailsOverrideArgs:
    def __init__(__self__, *,
                 alert_description_format: Optional[pulumi.Input[str]] = None,
                 alert_display_name_format: Optional[pulumi.Input[str]] = None,
                 alert_dynamic_properties: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPropertyMappingArgs']]]] = None,
                 alert_severity_column_name: Optional[pulumi.Input[str]] = None,
                 alert_tactics_column_name: Optional[pulumi.Input[str]] = None):
        """
        Settings for how to dynamically override alert static details
        :param pulumi.Input[str] alert_description_format: the format containing columns name(s) to override the alert description
        :param pulumi.Input[str] alert_display_name_format: the format containing columns name(s) to override the alert name
        :param pulumi.Input[Sequence[pulumi.Input['AlertPropertyMappingArgs']]] alert_dynamic_properties: List of additional dynamic properties to override
        :param pulumi.Input[str] alert_severity_column_name: the column name to take the alert severity from
        :param pulumi.Input[str] alert_tactics_column_name: the column name to take the alert tactics from
        """
        if alert_description_format is not None:
            pulumi.set(__self__, "alert_description_format", alert_description_format)
        if alert_display_name_format is not None:
            pulumi.set(__self__, "alert_display_name_format", alert_display_name_format)
        if alert_dynamic_properties is not None:
            pulumi.set(__self__, "alert_dynamic_properties", alert_dynamic_properties)
        if alert_severity_column_name is not None:
            pulumi.set(__self__, "alert_severity_column_name", alert_severity_column_name)
        if alert_tactics_column_name is not None:
            pulumi.set(__self__, "alert_tactics_column_name", alert_tactics_column_name)

    @property
    @pulumi.getter(name="alertDescriptionFormat")
    def alert_description_format(self) -> Optional[pulumi.Input[str]]:
        """
        the format containing columns name(s) to override the alert description
        """
        return pulumi.get(self, "alert_description_format")

    @alert_description_format.setter
    def alert_description_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alert_description_format", value)

    @property
    @pulumi.getter(name="alertDisplayNameFormat")
    def alert_display_name_format(self) -> Optional[pulumi.Input[str]]:
        """
        the format containing columns name(s) to override the alert name
        """
        return pulumi.get(self, "alert_display_name_format")

    @alert_display_name_format.setter
    def alert_display_name_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alert_display_name_format", value)

    @property
    @pulumi.getter(name="alertDynamicProperties")
    def alert_dynamic_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertPropertyMappingArgs']]]]:
        """
        List of additional dynamic properties to override
        """
        return pulumi.get(self, "alert_dynamic_properties")

    @alert_dynamic_properties.setter
    def alert_dynamic_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPropertyMappingArgs']]]]):
        pulumi.set(self, "alert_dynamic_properties", value)

    @property
    @pulumi.getter(name="alertSeverityColumnName")
    def alert_severity_column_name(self) -> Optional[pulumi.Input[str]]:
        """
        the column name to take the alert severity from
        """
        return pulumi.get(self, "alert_severity_column_name")

    @alert_severity_column_name.setter
    def alert_severity_column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alert_severity_column_name", value)

    @property
    @pulumi.getter(name="alertTacticsColumnName")
    def alert_tactics_column_name(self) -> Optional[pulumi.Input[str]]:
        """
        the column name to take the alert tactics from
        """
        return pulumi.get(self, "alert_tactics_column_name")

    @alert_tactics_column_name.setter
    def alert_tactics_column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alert_tactics_column_name", value)


if not MYPY:
    class AlertPropertyMappingArgsDict(TypedDict):
        """
        A single alert property mapping to override
        """
        alert_property: NotRequired[pulumi.Input[Union[str, 'AlertProperty']]]
        """
        The V3 alert property
        """
        value: NotRequired[pulumi.Input[str]]
        """
        the column name to use to override this property
        """
elif False:
    AlertPropertyMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPropertyMappingArgs:
    def __init__(__self__, *,
                 alert_property: Optional[pulumi.Input[Union[str, 'AlertProperty']]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        A single alert property mapping to override
        :param pulumi.Input[Union[str, 'AlertProperty']] alert_property: The V3 alert property
        :param pulumi.Input[str] value: the column name to use to override this property
        """
        if alert_property is not None:
            pulumi.set(__self__, "alert_property", alert_property)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="alertProperty")
    def alert_property(self) -> Optional[pulumi.Input[Union[str, 'AlertProperty']]]:
        """
        The V3 alert property
        """
        return pulumi.get(self, "alert_property")

    @alert_property.setter
    def alert_property(self, value: Optional[pulumi.Input[Union[str, 'AlertProperty']]]):
        pulumi.set(self, "alert_property", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        the column name to use to override this property
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlertsDataTypeOfDataConnectorArgsDict(TypedDict):
        """
        Alerts data type for data connectors.
        """
        alerts: NotRequired[pulumi.Input['DataConnectorDataTypeCommonArgsDict']]
        """
        Alerts data type connection.
        """
elif False:
    AlertsDataTypeOfDataConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertsDataTypeOfDataConnectorArgs:
    def __init__(__self__, *,
                 alerts: Optional[pulumi.Input['DataConnectorDataTypeCommonArgs']] = None):
        """
        Alerts data type for data connectors.
        :param pulumi.Input['DataConnectorDataTypeCommonArgs'] alerts: Alerts data type connection.
        """
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)

    @property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input['DataConnectorDataTypeCommonArgs']]:
        """
        Alerts data type connection.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input['DataConnectorDataTypeCommonArgs']]):
        pulumi.set(self, "alerts", value)


if not MYPY:
    class AssignmentItemArgsDict(TypedDict):
        """
        An entity describing a content item.
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        The resource id of the content item
        """
elif False:
    AssignmentItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssignmentItemArgs:
    def __init__(__self__, *,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        An entity describing a content item.
        :param pulumi.Input[str] resource_id: The resource id of the content item
        """
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource id of the content item
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


if not MYPY:
    class AutomationRuleModifyPropertiesActionArgsDict(TypedDict):
        """
        Describes an automation rule action to modify an object's properties
        """
        action_type: pulumi.Input[str]
        """
        The type of the automation rule action.
        Expected value is 'ModifyProperties'.
        """
        order: pulumi.Input[int]
        action_configuration: NotRequired[pulumi.Input['IncidentPropertiesActionArgsDict']]
elif False:
    AutomationRuleModifyPropertiesActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleModifyPropertiesActionArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 order: pulumi.Input[int],
                 action_configuration: Optional[pulumi.Input['IncidentPropertiesActionArgs']] = None):
        """
        Describes an automation rule action to modify an object's properties
        :param pulumi.Input[str] action_type: The type of the automation rule action.
               Expected value is 'ModifyProperties'.
        """
        pulumi.set(__self__, "action_type", 'ModifyProperties')
        pulumi.set(__self__, "order", order)
        if action_configuration is not None:
            pulumi.set(__self__, "action_configuration", action_configuration)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        The type of the automation rule action.
        Expected value is 'ModifyProperties'.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional[pulumi.Input['IncidentPropertiesActionArgs']]:
        return pulumi.get(self, "action_configuration")

    @action_configuration.setter
    def action_configuration(self, value: Optional[pulumi.Input['IncidentPropertiesActionArgs']]):
        pulumi.set(self, "action_configuration", value)


if not MYPY:
    class AutomationRulePropertyArrayChangedValuesConditionArgsDict(TypedDict):
        array_type: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedArrayType']]]
        change_type: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedChangeType']]]
elif False:
    AutomationRulePropertyArrayChangedValuesConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRulePropertyArrayChangedValuesConditionArgs:
    def __init__(__self__, *,
                 array_type: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedArrayType']]] = None,
                 change_type: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedChangeType']]] = None):
        if array_type is not None:
            pulumi.set(__self__, "array_type", array_type)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)

    @property
    @pulumi.getter(name="arrayType")
    def array_type(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedArrayType']]]:
        return pulumi.get(self, "array_type")

    @array_type.setter
    def array_type(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedArrayType']]]):
        pulumi.set(self, "array_type", value)

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedChangeType']]]:
        return pulumi.get(self, "change_type")

    @change_type.setter
    def change_type(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedChangeType']]]):
        pulumi.set(self, "change_type", value)


if not MYPY:
    class AutomationRulePropertyValuesChangedConditionArgsDict(TypedDict):
        change_type: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedChangedType']]]
        operator: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]]
        property_name: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedPropertyType']]]
        property_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    AutomationRulePropertyValuesChangedConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRulePropertyValuesChangedConditionArgs:
    def __init__(__self__, *,
                 change_type: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedChangedType']]] = None,
                 operator: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]] = None,
                 property_name: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedPropertyType']]] = None,
                 property_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if property_values is not None:
            pulumi.set(__self__, "property_values", property_values)

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedChangedType']]]:
        return pulumi.get(self, "change_type")

    @change_type.setter
    def change_type(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedChangedType']]]):
        pulumi.set(self, "change_type", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedPropertyType']]]:
        return pulumi.get(self, "property_name")

    @property_name.setter
    def property_name(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedPropertyType']]]):
        pulumi.set(self, "property_name", value)

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "property_values")

    @property_values.setter
    def property_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "property_values", value)


if not MYPY:
    class AutomationRulePropertyValuesConditionArgsDict(TypedDict):
        operator: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]]
        property_name: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedProperty']]]
        """
        The property to evaluate in an automation rule property condition.
        """
        property_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    AutomationRulePropertyValuesConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRulePropertyValuesConditionArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]] = None,
                 property_name: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedProperty']]] = None,
                 property_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedProperty']] property_name: The property to evaluate in an automation rule property condition.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if property_values is not None:
            pulumi.set(__self__, "property_values", property_values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedProperty']]]:
        """
        The property to evaluate in an automation rule property condition.
        """
        return pulumi.get(self, "property_name")

    @property_name.setter
    def property_name(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedProperty']]]):
        pulumi.set(self, "property_name", value)

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "property_values")

    @property_values.setter
    def property_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "property_values", value)


if not MYPY:
    class AutomationRuleRunPlaybookActionArgsDict(TypedDict):
        """
        Describes an automation rule action to run a playbook
        """
        action_type: pulumi.Input[str]
        """
        The type of the automation rule action.
        Expected value is 'RunPlaybook'.
        """
        order: pulumi.Input[int]
        action_configuration: NotRequired[pulumi.Input['PlaybookActionPropertiesArgsDict']]
elif False:
    AutomationRuleRunPlaybookActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleRunPlaybookActionArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 order: pulumi.Input[int],
                 action_configuration: Optional[pulumi.Input['PlaybookActionPropertiesArgs']] = None):
        """
        Describes an automation rule action to run a playbook
        :param pulumi.Input[str] action_type: The type of the automation rule action.
               Expected value is 'RunPlaybook'.
        """
        pulumi.set(__self__, "action_type", 'RunPlaybook')
        pulumi.set(__self__, "order", order)
        if action_configuration is not None:
            pulumi.set(__self__, "action_configuration", action_configuration)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        The type of the automation rule action.
        Expected value is 'RunPlaybook'.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional[pulumi.Input['PlaybookActionPropertiesArgs']]:
        return pulumi.get(self, "action_configuration")

    @action_configuration.setter
    def action_configuration(self, value: Optional[pulumi.Input['PlaybookActionPropertiesArgs']]):
        pulumi.set(self, "action_configuration", value)


if not MYPY:
    class AutomationRuleTriggeringLogicArgsDict(TypedDict):
        """
        Describes automation rule triggering logic.
        """
        is_enabled: pulumi.Input[bool]
        """
        Determines whether the automation rule is enabled or disabled.
        """
        triggers_on: pulumi.Input[Union[str, 'TriggersOn']]
        triggers_when: pulumi.Input[Union[str, 'TriggersWhen']]
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['PropertyArrayChangedConditionPropertiesArgsDict', 'PropertyChangedConditionPropertiesArgsDict', 'PropertyConditionPropertiesArgsDict']]]]]
        """
        The conditions to evaluate to determine if the automation rule should be triggered on a given object.
        """
        expiration_time_utc: NotRequired[pulumi.Input[str]]
        """
        Determines when the automation rule should automatically expire and be disabled.
        """
elif False:
    AutomationRuleTriggeringLogicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleTriggeringLogicArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool],
                 triggers_on: pulumi.Input[Union[str, 'TriggersOn']],
                 triggers_when: pulumi.Input[Union[str, 'TriggersWhen']],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['PropertyArrayChangedConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]]] = None,
                 expiration_time_utc: Optional[pulumi.Input[str]] = None):
        """
        Describes automation rule triggering logic.
        :param pulumi.Input[bool] is_enabled: Determines whether the automation rule is enabled or disabled.
        :param pulumi.Input[Sequence[pulumi.Input[Union['PropertyArrayChangedConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]] conditions: The conditions to evaluate to determine if the automation rule should be triggered on a given object.
        :param pulumi.Input[str] expiration_time_utc: Determines when the automation rule should automatically expire and be disabled.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "triggers_on", triggers_on)
        pulumi.set(__self__, "triggers_when", triggers_when)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if expiration_time_utc is not None:
            pulumi.set(__self__, "expiration_time_utc", expiration_time_utc)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Determines whether the automation rule is enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="triggersOn")
    def triggers_on(self) -> pulumi.Input[Union[str, 'TriggersOn']]:
        return pulumi.get(self, "triggers_on")

    @triggers_on.setter
    def triggers_on(self, value: pulumi.Input[Union[str, 'TriggersOn']]):
        pulumi.set(self, "triggers_on", value)

    @property
    @pulumi.getter(name="triggersWhen")
    def triggers_when(self) -> pulumi.Input[Union[str, 'TriggersWhen']]:
        return pulumi.get(self, "triggers_when")

    @triggers_when.setter
    def triggers_when(self, value: pulumi.Input[Union[str, 'TriggersWhen']]):
        pulumi.set(self, "triggers_when", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['PropertyArrayChangedConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]]]:
        """
        The conditions to evaluate to determine if the automation rule should be triggered on a given object.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['PropertyArrayChangedConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="expirationTimeUtc")
    def expiration_time_utc(self) -> Optional[pulumi.Input[str]]:
        """
        Determines when the automation rule should automatically expire and be disabled.
        """
        return pulumi.get(self, "expiration_time_utc")

    @expiration_time_utc.setter
    def expiration_time_utc(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration_time_utc", value)


if not MYPY:
    class AwsCloudTrailDataConnectorDataTypesLogsArgsDict(TypedDict):
        """
        Logs data type.
        """
        state: NotRequired[pulumi.Input[Union[str, 'DataTypeState']]]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    AwsCloudTrailDataConnectorDataTypesLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsCloudTrailDataConnectorDataTypesLogsArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[Union[str, 'DataTypeState']]] = None):
        """
        Logs data type.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'DataTypeState']]]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'DataTypeState']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class AwsCloudTrailDataConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for Amazon Web Services CloudTrail data connector.
        """
        logs: NotRequired[pulumi.Input['AwsCloudTrailDataConnectorDataTypesLogsArgsDict']]
        """
        Logs data type.
        """
elif False:
    AwsCloudTrailDataConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsCloudTrailDataConnectorDataTypesArgs:
    def __init__(__self__, *,
                 logs: Optional[pulumi.Input['AwsCloudTrailDataConnectorDataTypesLogsArgs']] = None):
        """
        The available data types for Amazon Web Services CloudTrail data connector.
        :param pulumi.Input['AwsCloudTrailDataConnectorDataTypesLogsArgs'] logs: Logs data type.
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)

    @property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input['AwsCloudTrailDataConnectorDataTypesLogsArgs']]:
        """
        Logs data type.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input['AwsCloudTrailDataConnectorDataTypesLogsArgs']]):
        pulumi.set(self, "logs", value)


if not MYPY:
    class AzureDevOpsResourceInfoArgsDict(TypedDict):
        """
        Resources created in Azure DevOps repository.
        """
        pipeline_id: NotRequired[pulumi.Input[str]]
        """
        Id of the pipeline created for the source-control.
        """
        service_connection_id: NotRequired[pulumi.Input[str]]
        """
        Id of the service-connection created for the source-control.
        """
elif False:
    AzureDevOpsResourceInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureDevOpsResourceInfoArgs:
    def __init__(__self__, *,
                 pipeline_id: Optional[pulumi.Input[str]] = None,
                 service_connection_id: Optional[pulumi.Input[str]] = None):
        """
        Resources created in Azure DevOps repository.
        :param pulumi.Input[str] pipeline_id: Id of the pipeline created for the source-control.
        :param pulumi.Input[str] service_connection_id: Id of the service-connection created for the source-control.
        """
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if service_connection_id is not None:
            pulumi.set(__self__, "service_connection_id", service_connection_id)

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the pipeline created for the source-control.
        """
        return pulumi.get(self, "pipeline_id")

    @pipeline_id.setter
    def pipeline_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pipeline_id", value)

    @property
    @pulumi.getter(name="serviceConnectionId")
    def service_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the service-connection created for the source-control.
        """
        return pulumi.get(self, "service_connection_id")

    @service_connection_id.setter
    def service_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_connection_id", value)


if not MYPY:
    class ClientInfoArgsDict(TypedDict):
        """
        Information on the client (user or application) that made some action
        """
        email: NotRequired[pulumi.Input[str]]
        """
        The email of the client.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the client.
        """
        object_id: NotRequired[pulumi.Input[str]]
        """
        The object id of the client.
        """
        user_principal_name: NotRequired[pulumi.Input[str]]
        """
        The user principal name of the client.
        """
elif False:
    ClientInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientInfoArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 user_principal_name: Optional[pulumi.Input[str]] = None):
        """
        Information on the client (user or application) that made some action
        :param pulumi.Input[str] email: The email of the client.
        :param pulumi.Input[str] name: The name of the client.
        :param pulumi.Input[str] object_id: The object id of the client.
        :param pulumi.Input[str] user_principal_name: The user principal name of the client.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_principal_name is not None:
            pulumi.set(__self__, "user_principal_name", user_principal_name)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The email of the client.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the client.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The object id of the client.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        The user principal name of the client.
        """
        return pulumi.get(self, "user_principal_name")

    @user_principal_name.setter
    def user_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_principal_name", value)


if not MYPY:
    class ConnectivityCriterionArgsDict(TypedDict):
        """
        The criteria by which we determine whether the connector is connected or not.
        For Example, use a KQL query to check if  the expected data type is flowing).
        """
        type: pulumi.Input[str]
        """
        Gets or sets the type of connectivity.
        """
        value: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Gets or sets the queries for checking connectivity.
        """
elif False:
    ConnectivityCriterionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectivityCriterionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The criteria by which we determine whether the connector is connected or not.
        For Example, use a KQL query to check if  the expected data type is flowing).
        :param pulumi.Input[str] type: Gets or sets the type of connectivity.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] value: Gets or sets the queries for checking connectivity.
        """
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Gets or sets the type of connectivity.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Gets or sets the queries for checking connectivity.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConnectorDataTypeArgsDict(TypedDict):
        """
        The data type which is created by the connector,
        including a query indicated when was the last time that data type was received in the workspace.
        """
        last_data_received_query: pulumi.Input[str]
        """
        Gets or sets the query to indicate when relevant data was last received in the workspace.
        """
        name: pulumi.Input[str]
        """
        Gets or sets the name of the data type to show in the graph.
        """
elif False:
    ConnectorDataTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorDataTypeArgs:
    def __init__(__self__, *,
                 last_data_received_query: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        The data type which is created by the connector,
        including a query indicated when was the last time that data type was received in the workspace.
        :param pulumi.Input[str] last_data_received_query: Gets or sets the query to indicate when relevant data was last received in the workspace.
        :param pulumi.Input[str] name: Gets or sets the name of the data type to show in the graph.
        """
        pulumi.set(__self__, "last_data_received_query", last_data_received_query)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lastDataReceivedQuery")
    def last_data_received_query(self) -> pulumi.Input[str]:
        """
        Gets or sets the query to indicate when relevant data was last received in the workspace.
        """
        return pulumi.get(self, "last_data_received_query")

    @last_data_received_query.setter
    def last_data_received_query(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_data_received_query", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Gets or sets the name of the data type to show in the graph.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ConnectorDefinitionsAvailabilityArgsDict(TypedDict):
        """
        The exposure status of the connector to the customers.
        """
        is_preview: NotRequired[pulumi.Input[bool]]
        """
        Gets or sets a value indicating whether the connector is preview.
        """
        status: NotRequired[pulumi.Input[int]]
        """
        The exposure status of the connector to the customers. Available values are 0-4 (0=None, 1=Available, 2=FeatureFlag, 3=Internal).
        """
elif False:
    ConnectorDefinitionsAvailabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorDefinitionsAvailabilityArgs:
    def __init__(__self__, *,
                 is_preview: Optional[pulumi.Input[bool]] = None,
                 status: Optional[pulumi.Input[int]] = None):
        """
        The exposure status of the connector to the customers.
        :param pulumi.Input[bool] is_preview: Gets or sets a value indicating whether the connector is preview.
        :param pulumi.Input[int] status: The exposure status of the connector to the customers. Available values are 0-4 (0=None, 1=Available, 2=FeatureFlag, 3=Internal).
        """
        if is_preview is not None:
            pulumi.set(__self__, "is_preview", is_preview)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="isPreview")
    def is_preview(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets or sets a value indicating whether the connector is preview.
        """
        return pulumi.get(self, "is_preview")

    @is_preview.setter
    def is_preview(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_preview", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[int]]:
        """
        The exposure status of the connector to the customers. Available values are 0-4 (0=None, 1=Available, 2=FeatureFlag, 3=Internal).
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ConnectorDefinitionsPermissionsArgsDict(TypedDict):
        """
        The required Permissions for the connector.
        """
        customs: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomPermissionDetailsArgsDict']]]]
        """
        Gets or sets the customs permissions required for the user to create connections.
        """
        licenses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Gets or sets the required licenses for the user to create connections.
        """
        resource_provider: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectorDefinitionsResourceProviderArgsDict']]]]
        """
        Gets or sets the resource provider permissions required for the user to create connections.
        """
        tenant: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Gets or sets the required tenant permissions for the connector.
        """
elif False:
    ConnectorDefinitionsPermissionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorDefinitionsPermissionsArgs:
    def __init__(__self__, *,
                 customs: Optional[pulumi.Input[Sequence[pulumi.Input['CustomPermissionDetailsArgs']]]] = None,
                 licenses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_provider: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorDefinitionsResourceProviderArgs']]]] = None,
                 tenant: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The required Permissions for the connector.
        :param pulumi.Input[Sequence[pulumi.Input['CustomPermissionDetailsArgs']]] customs: Gets or sets the customs permissions required for the user to create connections.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] licenses: Gets or sets the required licenses for the user to create connections.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectorDefinitionsResourceProviderArgs']]] resource_provider: Gets or sets the resource provider permissions required for the user to create connections.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tenant: Gets or sets the required tenant permissions for the connector.
        """
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if licenses is not None:
            pulumi.set(__self__, "licenses", licenses)
        if resource_provider is not None:
            pulumi.set(__self__, "resource_provider", resource_provider)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter
    def customs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomPermissionDetailsArgs']]]]:
        """
        Gets or sets the customs permissions required for the user to create connections.
        """
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomPermissionDetailsArgs']]]]):
        pulumi.set(self, "customs", value)

    @property
    @pulumi.getter
    def licenses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Gets or sets the required licenses for the user to create connections.
        """
        return pulumi.get(self, "licenses")

    @licenses.setter
    def licenses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "licenses", value)

    @property
    @pulumi.getter(name="resourceProvider")
    def resource_provider(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorDefinitionsResourceProviderArgs']]]]:
        """
        Gets or sets the resource provider permissions required for the user to create connections.
        """
        return pulumi.get(self, "resource_provider")

    @resource_provider.setter
    def resource_provider(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorDefinitionsResourceProviderArgs']]]]):
        pulumi.set(self, "resource_provider", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Gets or sets the required tenant permissions for the connector.
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tenant", value)


if not MYPY:
    class ConnectorDefinitionsResourceProviderArgsDict(TypedDict):
        """
        The resource provider details include the required permissions for the user to create connections.
        The user should have the required permissions(Read\\Write, ..) in the specified scope ProviderPermissionsScope against the specified resource provider.
        """
        permissions_display_text: pulumi.Input[str]
        """
        Gets or sets the permissions description text.
        """
        provider: pulumi.Input[str]
        """
        Gets or sets the provider name.
        """
        provider_display_name: pulumi.Input[str]
        """
        Gets or sets the permissions provider display name.
        """
        required_permissions: pulumi.Input['ResourceProviderRequiredPermissionsArgsDict']
        """
        Required permissions for the connector resource provider that define in ResourceProviders.
        For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
        """
        scope: pulumi.Input[Union[str, 'ProviderPermissionsScope']]
        """
        The scope on which the user should have permissions, in order to be able to create connections.
        """
elif False:
    ConnectorDefinitionsResourceProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorDefinitionsResourceProviderArgs:
    def __init__(__self__, *,
                 permissions_display_text: pulumi.Input[str],
                 provider: pulumi.Input[str],
                 provider_display_name: pulumi.Input[str],
                 required_permissions: pulumi.Input['ResourceProviderRequiredPermissionsArgs'],
                 scope: pulumi.Input[Union[str, 'ProviderPermissionsScope']]):
        """
        The resource provider details include the required permissions for the user to create connections.
        The user should have the required permissions(Read\\Write, ..) in the specified scope ProviderPermissionsScope against the specified resource provider.
        :param pulumi.Input[str] permissions_display_text: Gets or sets the permissions description text.
        :param pulumi.Input[str] provider: Gets or sets the provider name.
        :param pulumi.Input[str] provider_display_name: Gets or sets the permissions provider display name.
        :param pulumi.Input['ResourceProviderRequiredPermissionsArgs'] required_permissions: Required permissions for the connector resource provider that define in ResourceProviders.
               For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
        :param pulumi.Input[Union[str, 'ProviderPermissionsScope']] scope: The scope on which the user should have permissions, in order to be able to create connections.
        """
        pulumi.set(__self__, "permissions_display_text", permissions_display_text)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "provider_display_name", provider_display_name)
        pulumi.set(__self__, "required_permissions", required_permissions)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="permissionsDisplayText")
    def permissions_display_text(self) -> pulumi.Input[str]:
        """
        Gets or sets the permissions description text.
        """
        return pulumi.get(self, "permissions_display_text")

    @permissions_display_text.setter
    def permissions_display_text(self, value: pulumi.Input[str]):
        pulumi.set(self, "permissions_display_text", value)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input[str]:
        """
        Gets or sets the provider name.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter(name="providerDisplayName")
    def provider_display_name(self) -> pulumi.Input[str]:
        """
        Gets or sets the permissions provider display name.
        """
        return pulumi.get(self, "provider_display_name")

    @provider_display_name.setter
    def provider_display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider_display_name", value)

    @property
    @pulumi.getter(name="requiredPermissions")
    def required_permissions(self) -> pulumi.Input['ResourceProviderRequiredPermissionsArgs']:
        """
        Required permissions for the connector resource provider that define in ResourceProviders.
        For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
        """
        return pulumi.get(self, "required_permissions")

    @required_permissions.setter
    def required_permissions(self, value: pulumi.Input['ResourceProviderRequiredPermissionsArgs']):
        pulumi.set(self, "required_permissions", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[Union[str, 'ProviderPermissionsScope']]:
        """
        The scope on which the user should have permissions, in order to be able to create connections.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[Union[str, 'ProviderPermissionsScope']]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class ContentPathMapArgsDict(TypedDict):
        """
        The mapping of content type to a repo path.
        """
        content_type: NotRequired[pulumi.Input[Union[str, 'ContentType']]]
        """
        Content type.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path to the content.
        """
elif False:
    ContentPathMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContentPathMapArgs:
    def __init__(__self__, *,
                 content_type: Optional[pulumi.Input[Union[str, 'ContentType']]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        The mapping of content type to a repo path.
        :param pulumi.Input[Union[str, 'ContentType']] content_type: Content type.
        :param pulumi.Input[str] path: The path to the content.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[Union[str, 'ContentType']]]:
        """
        Content type.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[Union[str, 'ContentType']]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the content.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class CustomPermissionDetailsArgsDict(TypedDict):
        """
        The Custom permissions required for the connector.
        """
        description: pulumi.Input[str]
        """
        Gets or sets the custom permissions description.
        """
        name: pulumi.Input[str]
        """
        Gets or sets the custom permissions name.
        """
elif False:
    CustomPermissionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomPermissionDetailsArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        The Custom permissions required for the connector.
        :param pulumi.Input[str] description: Gets or sets the custom permissions description.
        :param pulumi.Input[str] name: Gets or sets the custom permissions name.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> pulumi.Input[str]:
        """
        Gets or sets the custom permissions description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Gets or sets the custom permissions name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CustomizableConnectionsConfigArgsDict(TypedDict):
        """
        The UiConfig for 'Customizable' connector definition kind.
        """
        template_spec_name: pulumi.Input[str]
        """
        Gets or sets the template name. The template includes ARM templates that can be created by the connector, usually it will be the dataConnectors ARM templates.
        """
        template_spec_version: pulumi.Input[str]
        """
        Gets or sets the template version.
        """
elif False:
    CustomizableConnectionsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomizableConnectionsConfigArgs:
    def __init__(__self__, *,
                 template_spec_name: pulumi.Input[str],
                 template_spec_version: pulumi.Input[str]):
        """
        The UiConfig for 'Customizable' connector definition kind.
        :param pulumi.Input[str] template_spec_name: Gets or sets the template name. The template includes ARM templates that can be created by the connector, usually it will be the dataConnectors ARM templates.
        :param pulumi.Input[str] template_spec_version: Gets or sets the template version.
        """
        pulumi.set(__self__, "template_spec_name", template_spec_name)
        pulumi.set(__self__, "template_spec_version", template_spec_version)

    @property
    @pulumi.getter(name="templateSpecName")
    def template_spec_name(self) -> pulumi.Input[str]:
        """
        Gets or sets the template name. The template includes ARM templates that can be created by the connector, usually it will be the dataConnectors ARM templates.
        """
        return pulumi.get(self, "template_spec_name")

    @template_spec_name.setter
    def template_spec_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "template_spec_name", value)

    @property
    @pulumi.getter(name="templateSpecVersion")
    def template_spec_version(self) -> pulumi.Input[str]:
        """
        Gets or sets the template version.
        """
        return pulumi.get(self, "template_spec_version")

    @template_spec_version.setter
    def template_spec_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "template_spec_version", value)


if not MYPY:
    class CustomizableConnectorUiConfigArgsDict(TypedDict):
        """
        The UiConfig for 'Customizable' connector definition kind.
        """
        connectivity_criteria: pulumi.Input[Sequence[pulumi.Input['ConnectivityCriterionArgsDict']]]
        """
        Gets or sets the way the connector checks whether the connector is connected.
        """
        data_types: pulumi.Input[Sequence[pulumi.Input['ConnectorDataTypeArgsDict']]]
        """
        Gets or sets the data types to check for last data received.
        """
        description_markdown: pulumi.Input[str]
        """
        Gets or sets the connector description in markdown format.
        """
        graph_queries: pulumi.Input[Sequence[pulumi.Input['GraphQueryArgsDict']]]
        """
        Gets or sets the graph queries to show the current data volume over time.
        """
        instruction_steps: pulumi.Input[Sequence[pulumi.Input['InstructionStepArgsDict']]]
        """
        Gets or sets the instruction steps to enable the connector.
        """
        permissions: pulumi.Input['ConnectorDefinitionsPermissionsArgsDict']
        """
        The required Permissions for the connector.
        """
        publisher: pulumi.Input[str]
        """
        Gets or sets the connector publisher name.
        """
        sample_queries: pulumi.Input[Sequence[pulumi.Input['SampleQueryArgsDict']]]
        """
        Gets or sets the sample queries for the connector.
        """
        title: pulumi.Input[str]
        """
        Gets or sets the connector blade title.
        """
        availability: NotRequired[pulumi.Input['ConnectorDefinitionsAvailabilityArgsDict']]
        """
        The exposure status of the connector to the customers.
        """
        graph_queries_table_name: NotRequired[pulumi.Input[str]]
        """
        Gets or sets the name of the table the connector will insert the data to.
        This name can be used in other queries by specifying {{graphQueriesTableName}} placeholder
         in Query and LastDataReceivedQuery values.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Gets or sets custom connector id. optional field.
        """
        is_connectivity_criterias_match_some: NotRequired[pulumi.Input[bool]]
        """
        Gets or sets a value indicating whether to use 'OR'(SOME) or 'AND' between ConnectivityCriteria items.
        """
        logo: NotRequired[pulumi.Input[str]]
        """
        Gets or sets the connector logo to be used when displaying the connector within Azure Sentinel's connector's gallery.
        The logo value should be in SVG format.
        """
elif False:
    CustomizableConnectorUiConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomizableConnectorUiConfigArgs:
    def __init__(__self__, *,
                 connectivity_criteria: pulumi.Input[Sequence[pulumi.Input['ConnectivityCriterionArgs']]],
                 data_types: pulumi.Input[Sequence[pulumi.Input['ConnectorDataTypeArgs']]],
                 description_markdown: pulumi.Input[str],
                 graph_queries: pulumi.Input[Sequence[pulumi.Input['GraphQueryArgs']]],
                 instruction_steps: pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]],
                 permissions: pulumi.Input['ConnectorDefinitionsPermissionsArgs'],
                 publisher: pulumi.Input[str],
                 sample_queries: pulumi.Input[Sequence[pulumi.Input['SampleQueryArgs']]],
                 title: pulumi.Input[str],
                 availability: Optional[pulumi.Input['ConnectorDefinitionsAvailabilityArgs']] = None,
                 graph_queries_table_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_connectivity_criterias_match_some: Optional[pulumi.Input[bool]] = None,
                 logo: Optional[pulumi.Input[str]] = None):
        """
        The UiConfig for 'Customizable' connector definition kind.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectivityCriterionArgs']]] connectivity_criteria: Gets or sets the way the connector checks whether the connector is connected.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectorDataTypeArgs']]] data_types: Gets or sets the data types to check for last data received.
        :param pulumi.Input[str] description_markdown: Gets or sets the connector description in markdown format.
        :param pulumi.Input[Sequence[pulumi.Input['GraphQueryArgs']]] graph_queries: Gets or sets the graph queries to show the current data volume over time.
        :param pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]] instruction_steps: Gets or sets the instruction steps to enable the connector.
        :param pulumi.Input['ConnectorDefinitionsPermissionsArgs'] permissions: The required Permissions for the connector.
        :param pulumi.Input[str] publisher: Gets or sets the connector publisher name.
        :param pulumi.Input[Sequence[pulumi.Input['SampleQueryArgs']]] sample_queries: Gets or sets the sample queries for the connector.
        :param pulumi.Input[str] title: Gets or sets the connector blade title.
        :param pulumi.Input['ConnectorDefinitionsAvailabilityArgs'] availability: The exposure status of the connector to the customers.
        :param pulumi.Input[str] graph_queries_table_name: Gets or sets the name of the table the connector will insert the data to.
               This name can be used in other queries by specifying {{graphQueriesTableName}} placeholder
                in Query and LastDataReceivedQuery values.
        :param pulumi.Input[str] id: Gets or sets custom connector id. optional field.
        :param pulumi.Input[bool] is_connectivity_criterias_match_some: Gets or sets a value indicating whether to use 'OR'(SOME) or 'AND' between ConnectivityCriteria items.
        :param pulumi.Input[str] logo: Gets or sets the connector logo to be used when displaying the connector within Azure Sentinel's connector's gallery.
               The logo value should be in SVG format.
        """
        pulumi.set(__self__, "connectivity_criteria", connectivity_criteria)
        pulumi.set(__self__, "data_types", data_types)
        pulumi.set(__self__, "description_markdown", description_markdown)
        pulumi.set(__self__, "graph_queries", graph_queries)
        pulumi.set(__self__, "instruction_steps", instruction_steps)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sample_queries", sample_queries)
        pulumi.set(__self__, "title", title)
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if graph_queries_table_name is not None:
            pulumi.set(__self__, "graph_queries_table_name", graph_queries_table_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_connectivity_criterias_match_some is not None:
            pulumi.set(__self__, "is_connectivity_criterias_match_some", is_connectivity_criterias_match_some)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)

    @property
    @pulumi.getter(name="connectivityCriteria")
    def connectivity_criteria(self) -> pulumi.Input[Sequence[pulumi.Input['ConnectivityCriterionArgs']]]:
        """
        Gets or sets the way the connector checks whether the connector is connected.
        """
        return pulumi.get(self, "connectivity_criteria")

    @connectivity_criteria.setter
    def connectivity_criteria(self, value: pulumi.Input[Sequence[pulumi.Input['ConnectivityCriterionArgs']]]):
        pulumi.set(self, "connectivity_criteria", value)

    @property
    @pulumi.getter(name="dataTypes")
    def data_types(self) -> pulumi.Input[Sequence[pulumi.Input['ConnectorDataTypeArgs']]]:
        """
        Gets or sets the data types to check for last data received.
        """
        return pulumi.get(self, "data_types")

    @data_types.setter
    def data_types(self, value: pulumi.Input[Sequence[pulumi.Input['ConnectorDataTypeArgs']]]):
        pulumi.set(self, "data_types", value)

    @property
    @pulumi.getter(name="descriptionMarkdown")
    def description_markdown(self) -> pulumi.Input[str]:
        """
        Gets or sets the connector description in markdown format.
        """
        return pulumi.get(self, "description_markdown")

    @description_markdown.setter
    def description_markdown(self, value: pulumi.Input[str]):
        pulumi.set(self, "description_markdown", value)

    @property
    @pulumi.getter(name="graphQueries")
    def graph_queries(self) -> pulumi.Input[Sequence[pulumi.Input['GraphQueryArgs']]]:
        """
        Gets or sets the graph queries to show the current data volume over time.
        """
        return pulumi.get(self, "graph_queries")

    @graph_queries.setter
    def graph_queries(self, value: pulumi.Input[Sequence[pulumi.Input['GraphQueryArgs']]]):
        pulumi.set(self, "graph_queries", value)

    @property
    @pulumi.getter(name="instructionSteps")
    def instruction_steps(self) -> pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]]:
        """
        Gets or sets the instruction steps to enable the connector.
        """
        return pulumi.get(self, "instruction_steps")

    @instruction_steps.setter
    def instruction_steps(self, value: pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]]):
        pulumi.set(self, "instruction_steps", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input['ConnectorDefinitionsPermissionsArgs']:
        """
        The required Permissions for the connector.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input['ConnectorDefinitionsPermissionsArgs']):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Gets or sets the connector publisher name.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter(name="sampleQueries")
    def sample_queries(self) -> pulumi.Input[Sequence[pulumi.Input['SampleQueryArgs']]]:
        """
        Gets or sets the sample queries for the connector.
        """
        return pulumi.get(self, "sample_queries")

    @sample_queries.setter
    def sample_queries(self, value: pulumi.Input[Sequence[pulumi.Input['SampleQueryArgs']]]):
        pulumi.set(self, "sample_queries", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        """
        Gets or sets the connector blade title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input['ConnectorDefinitionsAvailabilityArgs']]:
        """
        The exposure status of the connector to the customers.
        """
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input['ConnectorDefinitionsAvailabilityArgs']]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="graphQueriesTableName")
    def graph_queries_table_name(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the name of the table the connector will insert the data to.
        This name can be used in other queries by specifying {{graphQueriesTableName}} placeholder
         in Query and LastDataReceivedQuery values.
        """
        return pulumi.get(self, "graph_queries_table_name")

    @graph_queries_table_name.setter
    def graph_queries_table_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_queries_table_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets custom connector id. optional field.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isConnectivityCriteriasMatchSome")
    def is_connectivity_criterias_match_some(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets or sets a value indicating whether to use 'OR'(SOME) or 'AND' between ConnectivityCriteria items.
        """
        return pulumi.get(self, "is_connectivity_criterias_match_some")

    @is_connectivity_criterias_match_some.setter
    def is_connectivity_criterias_match_some(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_connectivity_criterias_match_some", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the connector logo to be used when displaying the connector within Azure Sentinel's connector's gallery.
        The logo value should be in SVG format.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo", value)


if not MYPY:
    class DataConnectorDataTypeCommonArgsDict(TypedDict):
        """
        Common field for data type in data connectors.
        """
        state: NotRequired[pulumi.Input[Union[str, 'DataTypeState']]]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    DataConnectorDataTypeCommonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataConnectorDataTypeCommonArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[Union[str, 'DataTypeState']]] = None):
        """
        Common field for data type in data connectors.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'DataTypeState']]]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'DataTypeState']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class DeploymentInfoArgsDict(TypedDict):
        """
        Information regarding a deployment.
        """
        deployment: NotRequired[pulumi.Input['DeploymentArgsDict']]
        """
        Deployment information.
        """
        deployment_fetch_status: NotRequired[pulumi.Input[Union[str, 'DeploymentFetchStatus']]]
        """
        Status while fetching the last deployment.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        Additional details about the deployment that can be shown to the user.
        """
elif False:
    DeploymentInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentInfoArgs:
    def __init__(__self__, *,
                 deployment: Optional[pulumi.Input['DeploymentArgs']] = None,
                 deployment_fetch_status: Optional[pulumi.Input[Union[str, 'DeploymentFetchStatus']]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        """
        Information regarding a deployment.
        :param pulumi.Input['DeploymentArgs'] deployment: Deployment information.
        :param pulumi.Input[Union[str, 'DeploymentFetchStatus']] deployment_fetch_status: Status while fetching the last deployment.
        :param pulumi.Input[str] message: Additional details about the deployment that can be shown to the user.
        """
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if deployment_fetch_status is not None:
            pulumi.set(__self__, "deployment_fetch_status", deployment_fetch_status)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def deployment(self) -> Optional[pulumi.Input['DeploymentArgs']]:
        """
        Deployment information.
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: Optional[pulumi.Input['DeploymentArgs']]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="deploymentFetchStatus")
    def deployment_fetch_status(self) -> Optional[pulumi.Input[Union[str, 'DeploymentFetchStatus']]]:
        """
        Status while fetching the last deployment.
        """
        return pulumi.get(self, "deployment_fetch_status")

    @deployment_fetch_status.setter
    def deployment_fetch_status(self, value: Optional[pulumi.Input[Union[str, 'DeploymentFetchStatus']]]):
        pulumi.set(self, "deployment_fetch_status", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Additional details about the deployment that can be shown to the user.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class DeploymentArgsDict(TypedDict):
        """
        Description about a deployment.
        """
        deployment_id: NotRequired[pulumi.Input[str]]
        """
        Deployment identifier.
        """
        deployment_logs_url: NotRequired[pulumi.Input[str]]
        """
        Url to access repository action logs.
        """
        deployment_result: NotRequired[pulumi.Input[Union[str, 'DeploymentResult']]]
        """
        The outcome of the deployment.
        """
        deployment_state: NotRequired[pulumi.Input[Union[str, 'DeploymentState']]]
        """
        Current status of the deployment.
        """
        deployment_time: NotRequired[pulumi.Input[str]]
        """
        The time when the deployment finished.
        """
elif False:
    DeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentArgs:
    def __init__(__self__, *,
                 deployment_id: Optional[pulumi.Input[str]] = None,
                 deployment_logs_url: Optional[pulumi.Input[str]] = None,
                 deployment_result: Optional[pulumi.Input[Union[str, 'DeploymentResult']]] = None,
                 deployment_state: Optional[pulumi.Input[Union[str, 'DeploymentState']]] = None,
                 deployment_time: Optional[pulumi.Input[str]] = None):
        """
        Description about a deployment.
        :param pulumi.Input[str] deployment_id: Deployment identifier.
        :param pulumi.Input[str] deployment_logs_url: Url to access repository action logs.
        :param pulumi.Input[Union[str, 'DeploymentResult']] deployment_result: The outcome of the deployment.
        :param pulumi.Input[Union[str, 'DeploymentState']] deployment_state: Current status of the deployment.
        :param pulumi.Input[str] deployment_time: The time when the deployment finished.
        """
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if deployment_logs_url is not None:
            pulumi.set(__self__, "deployment_logs_url", deployment_logs_url)
        if deployment_result is not None:
            pulumi.set(__self__, "deployment_result", deployment_result)
        if deployment_state is not None:
            pulumi.set(__self__, "deployment_state", deployment_state)
        if deployment_time is not None:
            pulumi.set(__self__, "deployment_time", deployment_time)

    @property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[pulumi.Input[str]]:
        """
        Deployment identifier.
        """
        return pulumi.get(self, "deployment_id")

    @deployment_id.setter
    def deployment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deployment_id", value)

    @property
    @pulumi.getter(name="deploymentLogsUrl")
    def deployment_logs_url(self) -> Optional[pulumi.Input[str]]:
        """
        Url to access repository action logs.
        """
        return pulumi.get(self, "deployment_logs_url")

    @deployment_logs_url.setter
    def deployment_logs_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deployment_logs_url", value)

    @property
    @pulumi.getter(name="deploymentResult")
    def deployment_result(self) -> Optional[pulumi.Input[Union[str, 'DeploymentResult']]]:
        """
        The outcome of the deployment.
        """
        return pulumi.get(self, "deployment_result")

    @deployment_result.setter
    def deployment_result(self, value: Optional[pulumi.Input[Union[str, 'DeploymentResult']]]):
        pulumi.set(self, "deployment_result", value)

    @property
    @pulumi.getter(name="deploymentState")
    def deployment_state(self) -> Optional[pulumi.Input[Union[str, 'DeploymentState']]]:
        """
        Current status of the deployment.
        """
        return pulumi.get(self, "deployment_state")

    @deployment_state.setter
    def deployment_state(self, value: Optional[pulumi.Input[Union[str, 'DeploymentState']]]):
        pulumi.set(self, "deployment_state", value)

    @property
    @pulumi.getter(name="deploymentTime")
    def deployment_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time when the deployment finished.
        """
        return pulumi.get(self, "deployment_time")

    @deployment_time.setter
    def deployment_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deployment_time", value)


if not MYPY:
    class EntityMappingArgsDict(TypedDict):
        """
        Single entity mapping for the alert rule
        """
        entity_type: NotRequired[pulumi.Input[Union[str, 'EntityMappingType']]]
        """
        The V3 type of the mapped entity
        """
        field_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['FieldMappingArgsDict']]]]
        """
        array of field mappings for the given entity mapping
        """
elif False:
    EntityMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityMappingArgs:
    def __init__(__self__, *,
                 entity_type: Optional[pulumi.Input[Union[str, 'EntityMappingType']]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['FieldMappingArgs']]]] = None):
        """
        Single entity mapping for the alert rule
        :param pulumi.Input[Union[str, 'EntityMappingType']] entity_type: The V3 type of the mapped entity
        :param pulumi.Input[Sequence[pulumi.Input['FieldMappingArgs']]] field_mappings: array of field mappings for the given entity mapping
        """
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[Union[str, 'EntityMappingType']]]:
        """
        The V3 type of the mapped entity
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[Union[str, 'EntityMappingType']]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FieldMappingArgs']]]]:
        """
        array of field mappings for the given entity mapping
        """
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)


if not MYPY:
    class EventGroupingSettingsArgsDict(TypedDict):
        """
        Event grouping settings property bag.
        """
        aggregation_kind: NotRequired[pulumi.Input[Union[str, 'EventGroupingAggregationKind']]]
        """
        The event grouping aggregation kinds
        """
elif False:
    EventGroupingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventGroupingSettingsArgs:
    def __init__(__self__, *,
                 aggregation_kind: Optional[pulumi.Input[Union[str, 'EventGroupingAggregationKind']]] = None):
        """
        Event grouping settings property bag.
        :param pulumi.Input[Union[str, 'EventGroupingAggregationKind']] aggregation_kind: The event grouping aggregation kinds
        """
        if aggregation_kind is not None:
            pulumi.set(__self__, "aggregation_kind", aggregation_kind)

    @property
    @pulumi.getter(name="aggregationKind")
    def aggregation_kind(self) -> Optional[pulumi.Input[Union[str, 'EventGroupingAggregationKind']]]:
        """
        The event grouping aggregation kinds
        """
        return pulumi.get(self, "aggregation_kind")

    @aggregation_kind.setter
    def aggregation_kind(self, value: Optional[pulumi.Input[Union[str, 'EventGroupingAggregationKind']]]):
        pulumi.set(self, "aggregation_kind", value)


if not MYPY:
    class FieldMappingArgsDict(TypedDict):
        """
        A single field mapping of the mapped entity
        """
        column_name: NotRequired[pulumi.Input[str]]
        """
        the column name to be mapped to the identifier
        """
        identifier: NotRequired[pulumi.Input[str]]
        """
        the V3 identifier of the entity
        """
elif False:
    FieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FieldMappingArgs:
    def __init__(__self__, *,
                 column_name: Optional[pulumi.Input[str]] = None,
                 identifier: Optional[pulumi.Input[str]] = None):
        """
        A single field mapping of the mapped entity
        :param pulumi.Input[str] column_name: the column name to be mapped to the identifier
        :param pulumi.Input[str] identifier: the V3 identifier of the entity
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[str]]:
        """
        the column name to be mapped to the identifier
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter
    def identifier(self) -> Optional[pulumi.Input[str]]:
        """
        the V3 identifier of the entity
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class FileMetadataArgsDict(TypedDict):
        """
        Represents a file.
        """
        file_format: NotRequired[pulumi.Input[Union[str, 'FileFormat']]]
        """
        The format of the file
        """
        file_name: NotRequired[pulumi.Input[str]]
        """
        The name of the file.
        """
        file_size: NotRequired[pulumi.Input[int]]
        """
        The size of the file.
        """
elif False:
    FileMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileMetadataArgs:
    def __init__(__self__, *,
                 file_format: Optional[pulumi.Input[Union[str, 'FileFormat']]] = None,
                 file_name: Optional[pulumi.Input[str]] = None,
                 file_size: Optional[pulumi.Input[int]] = None):
        """
        Represents a file.
        :param pulumi.Input[Union[str, 'FileFormat']] file_format: The format of the file
        :param pulumi.Input[str] file_name: The name of the file.
        :param pulumi.Input[int] file_size: The size of the file.
        """
        if file_format is not None:
            pulumi.set(__self__, "file_format", file_format)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if file_size is not None:
            pulumi.set(__self__, "file_size", file_size)

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[pulumi.Input[Union[str, 'FileFormat']]]:
        """
        The format of the file
        """
        return pulumi.get(self, "file_format")

    @file_format.setter
    def file_format(self, value: Optional[pulumi.Input[Union[str, 'FileFormat']]]):
        pulumi.set(self, "file_format", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the file.
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="fileSize")
    def file_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the file.
        """
        return pulumi.get(self, "file_size")

    @file_size.setter
    def file_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "file_size", value)


if not MYPY:
    class GitHubResourceInfoArgsDict(TypedDict):
        """
        Resources created in GitHub repository.
        """
        app_installation_id: NotRequired[pulumi.Input[str]]
        """
        GitHub application installation id.
        """
elif False:
    GitHubResourceInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitHubResourceInfoArgs:
    def __init__(__self__, *,
                 app_installation_id: Optional[pulumi.Input[str]] = None):
        """
        Resources created in GitHub repository.
        :param pulumi.Input[str] app_installation_id: GitHub application installation id.
        """
        if app_installation_id is not None:
            pulumi.set(__self__, "app_installation_id", app_installation_id)

    @property
    @pulumi.getter(name="appInstallationId")
    def app_installation_id(self) -> Optional[pulumi.Input[str]]:
        """
        GitHub application installation id.
        """
        return pulumi.get(self, "app_installation_id")

    @app_installation_id.setter
    def app_installation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_installation_id", value)


if not MYPY:
    class GraphQueryArgsDict(TypedDict):
        """
        The graph query to show the volume of data arriving into the workspace over time.
        """
        base_query: pulumi.Input[str]
        """
        Gets or sets the base query for the graph.
        The base query is wrapped by Sentinel UI infra with a KQL query, that measures the volume over time.
        """
        legend: pulumi.Input[str]
        """
        Gets or sets the legend for the graph.
        """
        metric_name: pulumi.Input[str]
        """
        Gets or sets the metric name that the query is checking. For example: 'Total data receive'.
        """
elif False:
    GraphQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GraphQueryArgs:
    def __init__(__self__, *,
                 base_query: pulumi.Input[str],
                 legend: pulumi.Input[str],
                 metric_name: pulumi.Input[str]):
        """
        The graph query to show the volume of data arriving into the workspace over time.
        :param pulumi.Input[str] base_query: Gets or sets the base query for the graph.
               The base query is wrapped by Sentinel UI infra with a KQL query, that measures the volume over time.
        :param pulumi.Input[str] legend: Gets or sets the legend for the graph.
        :param pulumi.Input[str] metric_name: Gets or sets the metric name that the query is checking. For example: 'Total data receive'.
        """
        pulumi.set(__self__, "base_query", base_query)
        pulumi.set(__self__, "legend", legend)
        pulumi.set(__self__, "metric_name", metric_name)

    @property
    @pulumi.getter(name="baseQuery")
    def base_query(self) -> pulumi.Input[str]:
        """
        Gets or sets the base query for the graph.
        The base query is wrapped by Sentinel UI infra with a KQL query, that measures the volume over time.
        """
        return pulumi.get(self, "base_query")

    @base_query.setter
    def base_query(self, value: pulumi.Input[str]):
        pulumi.set(self, "base_query", value)

    @property
    @pulumi.getter
    def legend(self) -> pulumi.Input[str]:
        """
        Gets or sets the legend for the graph.
        """
        return pulumi.get(self, "legend")

    @legend.setter
    def legend(self, value: pulumi.Input[str]):
        pulumi.set(self, "legend", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        Gets or sets the metric name that the query is checking. For example: 'Total data receive'.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)


if not MYPY:
    class GroupingConfigurationArgsDict(TypedDict):
        """
        Grouping configuration property bag.
        """
        enabled: pulumi.Input[bool]
        """
        Grouping enabled
        """
        lookback_duration: pulumi.Input[str]
        """
        Limit the group to alerts created within the lookback duration (in ISO 8601 duration format)
        """
        matching_method: pulumi.Input[Union[str, 'MatchingMethod']]
        """
        Grouping matching method. When method is Selected at least one of groupByEntities, groupByAlertDetails, groupByCustomDetails must be provided and not empty.
        """
        reopen_closed_incident: pulumi.Input[bool]
        """
        Re-open closed matching incidents
        """
        group_by_alert_details: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AlertDetail']]]]]
        """
        A list of alert details to group by (when matchingMethod is Selected)
        """
        group_by_custom_details: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of custom details keys to group by (when matchingMethod is Selected). Only keys defined in the current alert rule may be used.
        """
        group_by_entities: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'EntityMappingType']]]]]
        """
        A list of entity types to group by (when matchingMethod is Selected). Only entities defined in the current alert rule may be used.
        """
elif False:
    GroupingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupingConfigurationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 lookback_duration: pulumi.Input[str],
                 matching_method: pulumi.Input[Union[str, 'MatchingMethod']],
                 reopen_closed_incident: pulumi.Input[bool],
                 group_by_alert_details: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AlertDetail']]]]] = None,
                 group_by_custom_details: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_by_entities: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'EntityMappingType']]]]] = None):
        """
        Grouping configuration property bag.
        :param pulumi.Input[bool] enabled: Grouping enabled
        :param pulumi.Input[str] lookback_duration: Limit the group to alerts created within the lookback duration (in ISO 8601 duration format)
        :param pulumi.Input[Union[str, 'MatchingMethod']] matching_method: Grouping matching method. When method is Selected at least one of groupByEntities, groupByAlertDetails, groupByCustomDetails must be provided and not empty.
        :param pulumi.Input[bool] reopen_closed_incident: Re-open closed matching incidents
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'AlertDetail']]]] group_by_alert_details: A list of alert details to group by (when matchingMethod is Selected)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_by_custom_details: A list of custom details keys to group by (when matchingMethod is Selected). Only keys defined in the current alert rule may be used.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'EntityMappingType']]]] group_by_entities: A list of entity types to group by (when matchingMethod is Selected). Only entities defined in the current alert rule may be used.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "lookback_duration", lookback_duration)
        pulumi.set(__self__, "matching_method", matching_method)
        pulumi.set(__self__, "reopen_closed_incident", reopen_closed_incident)
        if group_by_alert_details is not None:
            pulumi.set(__self__, "group_by_alert_details", group_by_alert_details)
        if group_by_custom_details is not None:
            pulumi.set(__self__, "group_by_custom_details", group_by_custom_details)
        if group_by_entities is not None:
            pulumi.set(__self__, "group_by_entities", group_by_entities)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Grouping enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="lookbackDuration")
    def lookback_duration(self) -> pulumi.Input[str]:
        """
        Limit the group to alerts created within the lookback duration (in ISO 8601 duration format)
        """
        return pulumi.get(self, "lookback_duration")

    @lookback_duration.setter
    def lookback_duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "lookback_duration", value)

    @property
    @pulumi.getter(name="matchingMethod")
    def matching_method(self) -> pulumi.Input[Union[str, 'MatchingMethod']]:
        """
        Grouping matching method. When method is Selected at least one of groupByEntities, groupByAlertDetails, groupByCustomDetails must be provided and not empty.
        """
        return pulumi.get(self, "matching_method")

    @matching_method.setter
    def matching_method(self, value: pulumi.Input[Union[str, 'MatchingMethod']]):
        pulumi.set(self, "matching_method", value)

    @property
    @pulumi.getter(name="reopenClosedIncident")
    def reopen_closed_incident(self) -> pulumi.Input[bool]:
        """
        Re-open closed matching incidents
        """
        return pulumi.get(self, "reopen_closed_incident")

    @reopen_closed_incident.setter
    def reopen_closed_incident(self, value: pulumi.Input[bool]):
        pulumi.set(self, "reopen_closed_incident", value)

    @property
    @pulumi.getter(name="groupByAlertDetails")
    def group_by_alert_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AlertDetail']]]]]:
        """
        A list of alert details to group by (when matchingMethod is Selected)
        """
        return pulumi.get(self, "group_by_alert_details")

    @group_by_alert_details.setter
    def group_by_alert_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AlertDetail']]]]]):
        pulumi.set(self, "group_by_alert_details", value)

    @property
    @pulumi.getter(name="groupByCustomDetails")
    def group_by_custom_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of custom details keys to group by (when matchingMethod is Selected). Only keys defined in the current alert rule may be used.
        """
        return pulumi.get(self, "group_by_custom_details")

    @group_by_custom_details.setter
    def group_by_custom_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_by_custom_details", value)

    @property
    @pulumi.getter(name="groupByEntities")
    def group_by_entities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'EntityMappingType']]]]]:
        """
        A list of entity types to group by (when matchingMethod is Selected). Only entities defined in the current alert rule may be used.
        """
        return pulumi.get(self, "group_by_entities")

    @group_by_entities.setter
    def group_by_entities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'EntityMappingType']]]]]):
        pulumi.set(self, "group_by_entities", value)


if not MYPY:
    class HuntOwnerArgsDict(TypedDict):
        """
        Describes a user that the hunt is assigned to
        """
        assigned_to: NotRequired[pulumi.Input[str]]
        """
        The name of the user the hunt is assigned to.
        """
        email: NotRequired[pulumi.Input[str]]
        """
        The email of the user the hunt is assigned to.
        """
        object_id: NotRequired[pulumi.Input[str]]
        """
        The object id of the user the hunt is assigned to.
        """
        owner_type: NotRequired[pulumi.Input[Union[str, 'OwnerType']]]
        """
        The type of the owner the hunt is assigned to.
        """
        user_principal_name: NotRequired[pulumi.Input[str]]
        """
        The user principal name of the user the hunt is assigned to.
        """
elif False:
    HuntOwnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HuntOwnerArgs:
    def __init__(__self__, *,
                 assigned_to: Optional[pulumi.Input[str]] = None,
                 email: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 owner_type: Optional[pulumi.Input[Union[str, 'OwnerType']]] = None,
                 user_principal_name: Optional[pulumi.Input[str]] = None):
        """
        Describes a user that the hunt is assigned to
        :param pulumi.Input[str] assigned_to: The name of the user the hunt is assigned to.
        :param pulumi.Input[str] email: The email of the user the hunt is assigned to.
        :param pulumi.Input[str] object_id: The object id of the user the hunt is assigned to.
        :param pulumi.Input[Union[str, 'OwnerType']] owner_type: The type of the owner the hunt is assigned to.
        :param pulumi.Input[str] user_principal_name: The user principal name of the user the hunt is assigned to.
        """
        if assigned_to is not None:
            pulumi.set(__self__, "assigned_to", assigned_to)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if owner_type is not None:
            pulumi.set(__self__, "owner_type", owner_type)
        if user_principal_name is not None:
            pulumi.set(__self__, "user_principal_name", user_principal_name)

    @property
    @pulumi.getter(name="assignedTo")
    def assigned_to(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the user the hunt is assigned to.
        """
        return pulumi.get(self, "assigned_to")

    @assigned_to.setter
    def assigned_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assigned_to", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The email of the user the hunt is assigned to.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The object id of the user the hunt is assigned to.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="ownerType")
    def owner_type(self) -> Optional[pulumi.Input[Union[str, 'OwnerType']]]:
        """
        The type of the owner the hunt is assigned to.
        """
        return pulumi.get(self, "owner_type")

    @owner_type.setter
    def owner_type(self, value: Optional[pulumi.Input[Union[str, 'OwnerType']]]):
        pulumi.set(self, "owner_type", value)

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        The user principal name of the user the hunt is assigned to.
        """
        return pulumi.get(self, "user_principal_name")

    @user_principal_name.setter
    def user_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_principal_name", value)


if not MYPY:
    class IncidentConfigurationArgsDict(TypedDict):
        """
        Incident Configuration property bag.
        """
        create_incident: pulumi.Input[bool]
        """
        Create incidents from alerts triggered by this analytics rule
        """
        grouping_configuration: NotRequired[pulumi.Input['GroupingConfigurationArgsDict']]
        """
        Set how the alerts that are triggered by this analytics rule, are grouped into incidents
        """
elif False:
    IncidentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentConfigurationArgs:
    def __init__(__self__, *,
                 create_incident: pulumi.Input[bool],
                 grouping_configuration: Optional[pulumi.Input['GroupingConfigurationArgs']] = None):
        """
        Incident Configuration property bag.
        :param pulumi.Input[bool] create_incident: Create incidents from alerts triggered by this analytics rule
        :param pulumi.Input['GroupingConfigurationArgs'] grouping_configuration: Set how the alerts that are triggered by this analytics rule, are grouped into incidents
        """
        pulumi.set(__self__, "create_incident", create_incident)
        if grouping_configuration is not None:
            pulumi.set(__self__, "grouping_configuration", grouping_configuration)

    @property
    @pulumi.getter(name="createIncident")
    def create_incident(self) -> pulumi.Input[bool]:
        """
        Create incidents from alerts triggered by this analytics rule
        """
        return pulumi.get(self, "create_incident")

    @create_incident.setter
    def create_incident(self, value: pulumi.Input[bool]):
        pulumi.set(self, "create_incident", value)

    @property
    @pulumi.getter(name="groupingConfiguration")
    def grouping_configuration(self) -> Optional[pulumi.Input['GroupingConfigurationArgs']]:
        """
        Set how the alerts that are triggered by this analytics rule, are grouped into incidents
        """
        return pulumi.get(self, "grouping_configuration")

    @grouping_configuration.setter
    def grouping_configuration(self, value: Optional[pulumi.Input['GroupingConfigurationArgs']]):
        pulumi.set(self, "grouping_configuration", value)


if not MYPY:
    class IncidentInfoArgsDict(TypedDict):
        """
        Describes related incident information for the bookmark
        """
        incident_id: NotRequired[pulumi.Input[str]]
        """
        Incident Id
        """
        relation_name: NotRequired[pulumi.Input[str]]
        """
        Relation Name
        """
        severity: NotRequired[pulumi.Input[Union[str, 'IncidentSeverity']]]
        """
        The severity of the incident
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The title of the incident
        """
elif False:
    IncidentInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentInfoArgs:
    def __init__(__self__, *,
                 incident_id: Optional[pulumi.Input[str]] = None,
                 relation_name: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[Union[str, 'IncidentSeverity']]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        Describes related incident information for the bookmark
        :param pulumi.Input[str] incident_id: Incident Id
        :param pulumi.Input[str] relation_name: Relation Name
        :param pulumi.Input[Union[str, 'IncidentSeverity']] severity: The severity of the incident
        :param pulumi.Input[str] title: The title of the incident
        """
        if incident_id is not None:
            pulumi.set(__self__, "incident_id", incident_id)
        if relation_name is not None:
            pulumi.set(__self__, "relation_name", relation_name)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="incidentId")
    def incident_id(self) -> Optional[pulumi.Input[str]]:
        """
        Incident Id
        """
        return pulumi.get(self, "incident_id")

    @incident_id.setter
    def incident_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "incident_id", value)

    @property
    @pulumi.getter(name="relationName")
    def relation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Relation Name
        """
        return pulumi.get(self, "relation_name")

    @relation_name.setter
    def relation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relation_name", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[Union[str, 'IncidentSeverity']]]:
        """
        The severity of the incident
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[Union[str, 'IncidentSeverity']]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the incident
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class IncidentLabelArgsDict(TypedDict):
        """
        Represents an incident label
        """
        label_name: pulumi.Input[str]
        """
        The name of the label
        """
elif False:
    IncidentLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentLabelArgs:
    def __init__(__self__, *,
                 label_name: pulumi.Input[str]):
        """
        Represents an incident label
        :param pulumi.Input[str] label_name: The name of the label
        """
        pulumi.set(__self__, "label_name", label_name)

    @property
    @pulumi.getter(name="labelName")
    def label_name(self) -> pulumi.Input[str]:
        """
        The name of the label
        """
        return pulumi.get(self, "label_name")

    @label_name.setter
    def label_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "label_name", value)


if not MYPY:
    class IncidentOwnerInfoArgsDict(TypedDict):
        """
        Information on the user an incident is assigned to
        """
        assigned_to: NotRequired[pulumi.Input[str]]
        """
        The name of the user the incident is assigned to.
        """
        email: NotRequired[pulumi.Input[str]]
        """
        The email of the user the incident is assigned to.
        """
        object_id: NotRequired[pulumi.Input[str]]
        """
        The object id of the user the incident is assigned to.
        """
        owner_type: NotRequired[pulumi.Input[Union[str, 'OwnerType']]]
        """
        The type of the owner the incident is assigned to.
        """
        user_principal_name: NotRequired[pulumi.Input[str]]
        """
        The user principal name of the user the incident is assigned to.
        """
elif False:
    IncidentOwnerInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentOwnerInfoArgs:
    def __init__(__self__, *,
                 assigned_to: Optional[pulumi.Input[str]] = None,
                 email: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 owner_type: Optional[pulumi.Input[Union[str, 'OwnerType']]] = None,
                 user_principal_name: Optional[pulumi.Input[str]] = None):
        """
        Information on the user an incident is assigned to
        :param pulumi.Input[str] assigned_to: The name of the user the incident is assigned to.
        :param pulumi.Input[str] email: The email of the user the incident is assigned to.
        :param pulumi.Input[str] object_id: The object id of the user the incident is assigned to.
        :param pulumi.Input[Union[str, 'OwnerType']] owner_type: The type of the owner the incident is assigned to.
        :param pulumi.Input[str] user_principal_name: The user principal name of the user the incident is assigned to.
        """
        if assigned_to is not None:
            pulumi.set(__self__, "assigned_to", assigned_to)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if owner_type is not None:
            pulumi.set(__self__, "owner_type", owner_type)
        if user_principal_name is not None:
            pulumi.set(__self__, "user_principal_name", user_principal_name)

    @property
    @pulumi.getter(name="assignedTo")
    def assigned_to(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the user the incident is assigned to.
        """
        return pulumi.get(self, "assigned_to")

    @assigned_to.setter
    def assigned_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assigned_to", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The email of the user the incident is assigned to.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The object id of the user the incident is assigned to.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="ownerType")
    def owner_type(self) -> Optional[pulumi.Input[Union[str, 'OwnerType']]]:
        """
        The type of the owner the incident is assigned to.
        """
        return pulumi.get(self, "owner_type")

    @owner_type.setter
    def owner_type(self, value: Optional[pulumi.Input[Union[str, 'OwnerType']]]):
        pulumi.set(self, "owner_type", value)

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        The user principal name of the user the incident is assigned to.
        """
        return pulumi.get(self, "user_principal_name")

    @user_principal_name.setter
    def user_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_principal_name", value)


if not MYPY:
    class IncidentPropertiesActionArgsDict(TypedDict):
        classification: NotRequired[pulumi.Input[Union[str, 'IncidentClassification']]]
        """
        The reason the incident was closed
        """
        classification_comment: NotRequired[pulumi.Input[str]]
        """
        Describes the reason the incident was closed.
        """
        classification_reason: NotRequired[pulumi.Input[Union[str, 'IncidentClassificationReason']]]
        """
        The classification reason the incident was closed with
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['IncidentLabelArgsDict']]]]
        """
        List of labels to add to the incident.
        """
        owner: NotRequired[pulumi.Input['IncidentOwnerInfoArgsDict']]
        """
        Information on the user an incident is assigned to
        """
        severity: NotRequired[pulumi.Input[Union[str, 'IncidentSeverity']]]
        """
        The severity of the incident
        """
        status: NotRequired[pulumi.Input[Union[str, 'IncidentStatus']]]
        """
        The status of the incident
        """
elif False:
    IncidentPropertiesActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentPropertiesActionArgs:
    def __init__(__self__, *,
                 classification: Optional[pulumi.Input[Union[str, 'IncidentClassification']]] = None,
                 classification_comment: Optional[pulumi.Input[str]] = None,
                 classification_reason: Optional[pulumi.Input[Union[str, 'IncidentClassificationReason']]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentLabelArgs']]]] = None,
                 owner: Optional[pulumi.Input['IncidentOwnerInfoArgs']] = None,
                 severity: Optional[pulumi.Input[Union[str, 'IncidentSeverity']]] = None,
                 status: Optional[pulumi.Input[Union[str, 'IncidentStatus']]] = None):
        """
        :param pulumi.Input[Union[str, 'IncidentClassification']] classification: The reason the incident was closed
        :param pulumi.Input[str] classification_comment: Describes the reason the incident was closed.
        :param pulumi.Input[Union[str, 'IncidentClassificationReason']] classification_reason: The classification reason the incident was closed with
        :param pulumi.Input[Sequence[pulumi.Input['IncidentLabelArgs']]] labels: List of labels to add to the incident.
        :param pulumi.Input['IncidentOwnerInfoArgs'] owner: Information on the user an incident is assigned to
        :param pulumi.Input[Union[str, 'IncidentSeverity']] severity: The severity of the incident
        :param pulumi.Input[Union[str, 'IncidentStatus']] status: The status of the incident
        """
        if classification is not None:
            pulumi.set(__self__, "classification", classification)
        if classification_comment is not None:
            pulumi.set(__self__, "classification_comment", classification_comment)
        if classification_reason is not None:
            pulumi.set(__self__, "classification_reason", classification_reason)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def classification(self) -> Optional[pulumi.Input[Union[str, 'IncidentClassification']]]:
        """
        The reason the incident was closed
        """
        return pulumi.get(self, "classification")

    @classification.setter
    def classification(self, value: Optional[pulumi.Input[Union[str, 'IncidentClassification']]]):
        pulumi.set(self, "classification", value)

    @property
    @pulumi.getter(name="classificationComment")
    def classification_comment(self) -> Optional[pulumi.Input[str]]:
        """
        Describes the reason the incident was closed.
        """
        return pulumi.get(self, "classification_comment")

    @classification_comment.setter
    def classification_comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "classification_comment", value)

    @property
    @pulumi.getter(name="classificationReason")
    def classification_reason(self) -> Optional[pulumi.Input[Union[str, 'IncidentClassificationReason']]]:
        """
        The classification reason the incident was closed with
        """
        return pulumi.get(self, "classification_reason")

    @classification_reason.setter
    def classification_reason(self, value: Optional[pulumi.Input[Union[str, 'IncidentClassificationReason']]]):
        pulumi.set(self, "classification_reason", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IncidentLabelArgs']]]]:
        """
        List of labels to add to the incident.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentLabelArgs']]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input['IncidentOwnerInfoArgs']]:
        """
        Information on the user an incident is assigned to
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input['IncidentOwnerInfoArgs']]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[Union[str, 'IncidentSeverity']]]:
        """
        The severity of the incident
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[Union[str, 'IncidentSeverity']]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'IncidentStatus']]]:
        """
        The status of the incident
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'IncidentStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class InstructionStepDetailsArgsDict(TypedDict):
        """
        Instruction step details, to be displayed in the Instructions steps section in the connector's page in Sentinel Portal.
        """
        parameters: Any
        """
        Gets or sets the instruction type parameters settings.
        """
        type: pulumi.Input[str]
        """
        Gets or sets the instruction type name.
        """
elif False:
    InstructionStepDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstructionStepDetailsArgs:
    def __init__(__self__, *,
                 parameters: Any,
                 type: pulumi.Input[str]):
        """
        Instruction step details, to be displayed in the Instructions steps section in the connector's page in Sentinel Portal.
        :param Any parameters: Gets or sets the instruction type parameters settings.
        :param pulumi.Input[str] type: Gets or sets the instruction type name.
        """
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def parameters(self) -> Any:
        """
        Gets or sets the instruction type parameters settings.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Any):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Gets or sets the instruction type name.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class InstructionStepArgsDict(TypedDict):
        """
        Instruction steps to enable the connector.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Gets or sets the instruction step description.
        """
        inner_steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstructionStepArgsDict']]]]
        """
        Gets or sets the inner instruction steps details.
        Foe Example: instruction step 1 might contain inner instruction steps: [instruction step 1.1, instruction step 1.2].
        """
        instructions: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstructionStepDetailsArgsDict']]]]
        """
        Gets or sets the instruction step details.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Gets or sets the instruction step title.
        """
elif False:
    InstructionStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstructionStepArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 inner_steps: Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]]] = None,
                 instructions: Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepDetailsArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        Instruction steps to enable the connector.
        :param pulumi.Input[str] description: Gets or sets the instruction step description.
        :param pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]] inner_steps: Gets or sets the inner instruction steps details.
               Foe Example: instruction step 1 might contain inner instruction steps: [instruction step 1.1, instruction step 1.2].
        :param pulumi.Input[Sequence[pulumi.Input['InstructionStepDetailsArgs']]] instructions: Gets or sets the instruction step details.
        :param pulumi.Input[str] title: Gets or sets the instruction step title.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if inner_steps is not None:
            pulumi.set(__self__, "inner_steps", inner_steps)
        if instructions is not None:
            pulumi.set(__self__, "instructions", instructions)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the instruction step description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="innerSteps")
    def inner_steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]]]:
        """
        Gets or sets the inner instruction steps details.
        Foe Example: instruction step 1 might contain inner instruction steps: [instruction step 1.1, instruction step 1.2].
        """
        return pulumi.get(self, "inner_steps")

    @inner_steps.setter
    def inner_steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]]]):
        pulumi.set(self, "inner_steps", value)

    @property
    @pulumi.getter
    def instructions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepDetailsArgs']]]]:
        """
        Gets or sets the instruction step details.
        """
        return pulumi.get(self, "instructions")

    @instructions.setter
    def instructions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepDetailsArgs']]]]):
        pulumi.set(self, "instructions", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the instruction step title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class LogArgsDict(TypedDict):
        """
        Describes a log.
        """
        type: pulumi.Input[Union[str, 'LogType']]
        """
        Types of logs and tables.
        """
        bulk_size: NotRequired[pulumi.Input[int]]
        """
        The bulk size for the log.
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The filters for the log.
        """
        ingestion_type: NotRequired[pulumi.Input[Union[str, 'IngestionType']]]
        """
        Types of ingestion.
        """
        schedule_interval: NotRequired[pulumi.Input[int]]
        """
        The schedule interval in seconds.
        """
        status: NotRequired[pulumi.Input[Union[str, 'LogStatusType']]]
        """
        Types of log status.
        """
elif False:
    LogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'LogType']],
                 bulk_size: Optional[pulumi.Input[int]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ingestion_type: Optional[pulumi.Input[Union[str, 'IngestionType']]] = None,
                 schedule_interval: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[Union[str, 'LogStatusType']]] = None):
        """
        Describes a log.
        :param pulumi.Input[Union[str, 'LogType']] type: Types of logs and tables.
        :param pulumi.Input[int] bulk_size: The bulk size for the log.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] filters: The filters for the log.
        :param pulumi.Input[Union[str, 'IngestionType']] ingestion_type: Types of ingestion.
        :param pulumi.Input[int] schedule_interval: The schedule interval in seconds.
        :param pulumi.Input[Union[str, 'LogStatusType']] status: Types of log status.
        """
        pulumi.set(__self__, "type", type)
        if bulk_size is not None:
            pulumi.set(__self__, "bulk_size", bulk_size)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if ingestion_type is not None:
            pulumi.set(__self__, "ingestion_type", ingestion_type)
        if schedule_interval is not None:
            pulumi.set(__self__, "schedule_interval", schedule_interval)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'LogType']]:
        """
        Types of logs and tables.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'LogType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bulkSize")
    def bulk_size(self) -> Optional[pulumi.Input[int]]:
        """
        The bulk size for the log.
        """
        return pulumi.get(self, "bulk_size")

    @bulk_size.setter
    def bulk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bulk_size", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The filters for the log.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter(name="ingestionType")
    def ingestion_type(self) -> Optional[pulumi.Input[Union[str, 'IngestionType']]]:
        """
        Types of ingestion.
        """
        return pulumi.get(self, "ingestion_type")

    @ingestion_type.setter
    def ingestion_type(self, value: Optional[pulumi.Input[Union[str, 'IngestionType']]]):
        pulumi.set(self, "ingestion_type", value)

    @property
    @pulumi.getter(name="scheduleInterval")
    def schedule_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The schedule interval in seconds.
        """
        return pulumi.get(self, "schedule_interval")

    @schedule_interval.setter
    def schedule_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "schedule_interval", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'LogStatusType']]]:
        """
        Types of log status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'LogStatusType']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class MCASDataConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for MCAS (Microsoft Cloud App Security) data connector.
        """
        alerts: NotRequired[pulumi.Input['DataConnectorDataTypeCommonArgsDict']]
        """
        Alerts data type connection.
        """
        discovery_logs: NotRequired[pulumi.Input['DataConnectorDataTypeCommonArgsDict']]
        """
        Discovery log data type connection.
        """
elif False:
    MCASDataConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MCASDataConnectorDataTypesArgs:
    def __init__(__self__, *,
                 alerts: Optional[pulumi.Input['DataConnectorDataTypeCommonArgs']] = None,
                 discovery_logs: Optional[pulumi.Input['DataConnectorDataTypeCommonArgs']] = None):
        """
        The available data types for MCAS (Microsoft Cloud App Security) data connector.
        :param pulumi.Input['DataConnectorDataTypeCommonArgs'] alerts: Alerts data type connection.
        :param pulumi.Input['DataConnectorDataTypeCommonArgs'] discovery_logs: Discovery log data type connection.
        """
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if discovery_logs is not None:
            pulumi.set(__self__, "discovery_logs", discovery_logs)

    @property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input['DataConnectorDataTypeCommonArgs']]:
        """
        Alerts data type connection.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input['DataConnectorDataTypeCommonArgs']]):
        pulumi.set(self, "alerts", value)

    @property
    @pulumi.getter(name="discoveryLogs")
    def discovery_logs(self) -> Optional[pulumi.Input['DataConnectorDataTypeCommonArgs']]:
        """
        Discovery log data type connection.
        """
        return pulumi.get(self, "discovery_logs")

    @discovery_logs.setter
    def discovery_logs(self, value: Optional[pulumi.Input['DataConnectorDataTypeCommonArgs']]):
        pulumi.set(self, "discovery_logs", value)


if not MYPY:
    class MetadataAuthorArgsDict(TypedDict):
        """
        Publisher or creator of the content item.
        """
        email: NotRequired[pulumi.Input[str]]
        """
        Email of author contact
        """
        link: NotRequired[pulumi.Input[str]]
        """
        Link for author/vendor page
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the author. Company or person.
        """
elif False:
    MetadataAuthorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataAuthorArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Publisher or creator of the content item.
        :param pulumi.Input[str] email: Email of author contact
        :param pulumi.Input[str] link: Link for author/vendor page
        :param pulumi.Input[str] name: Name of the author. Company or person.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        Email of author contact
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        Link for author/vendor page
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the author. Company or person.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class MetadataCategoriesArgsDict(TypedDict):
        """
        ies for the solution content item
        """
        domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        domain for the solution content item
        """
        verticals: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Industry verticals for the solution content item
        """
elif False:
    MetadataCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataCategoriesArgs:
    def __init__(__self__, *,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verticals: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        ies for the solution content item
        :param pulumi.Input[Sequence[pulumi.Input[str]]] domains: domain for the solution content item
        :param pulumi.Input[Sequence[pulumi.Input[str]]] verticals: Industry verticals for the solution content item
        """
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if verticals is not None:
            pulumi.set(__self__, "verticals", verticals)

    @property
    @pulumi.getter
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        domain for the solution content item
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "domains", value)

    @property
    @pulumi.getter
    def verticals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Industry verticals for the solution content item
        """
        return pulumi.get(self, "verticals")

    @verticals.setter
    def verticals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "verticals", value)


if not MYPY:
    class MetadataDependenciesArgsDict(TypedDict):
        """
        Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex dependencies.
        """
        content_id: NotRequired[pulumi.Input[str]]
        """
        Id of the content item we depend on
        """
        criteria: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetadataDependenciesArgsDict']]]]
        """
        This is the list of dependencies we must fulfill, according to the AND/OR operator
        """
        kind: NotRequired[pulumi.Input[Union[str, 'Kind']]]
        """
        Type of the content item we depend on
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the content item
        """
        operator: NotRequired[pulumi.Input[Union[str, 'Operator']]]
        """
        Operator used for list of dependencies in criteria array.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        """
elif False:
    MetadataDependenciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataDependenciesArgs:
    def __init__(__self__, *,
                 content_id: Optional[pulumi.Input[str]] = None,
                 criteria: Optional[pulumi.Input[Sequence[pulumi.Input['MetadataDependenciesArgs']]]] = None,
                 kind: Optional[pulumi.Input[Union[str, 'Kind']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[Union[str, 'Operator']]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex dependencies.
        :param pulumi.Input[str] content_id: Id of the content item we depend on
        :param pulumi.Input[Sequence[pulumi.Input['MetadataDependenciesArgs']]] criteria: This is the list of dependencies we must fulfill, according to the AND/OR operator
        :param pulumi.Input[Union[str, 'Kind']] kind: Type of the content item we depend on
        :param pulumi.Input[str] name: Name of the content item
        :param pulumi.Input[Union[str, 'Operator']] operator: Operator used for list of dependencies in criteria array.
        :param pulumi.Input[str] version: Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        """
        if content_id is not None:
            pulumi.set(__self__, "content_id", content_id)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="contentId")
    def content_id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the content item we depend on
        """
        return pulumi.get(self, "content_id")

    @content_id.setter
    def content_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_id", value)

    @property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetadataDependenciesArgs']]]]:
        """
        This is the list of dependencies we must fulfill, according to the AND/OR operator
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetadataDependenciesArgs']]]]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[Union[str, 'Kind']]]:
        """
        Type of the content item we depend on
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[Union[str, 'Kind']]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the content item
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[Union[str, 'Operator']]]:
        """
        Operator used for list of dependencies in criteria array.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[Union[str, 'Operator']]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class MetadataSourceArgsDict(TypedDict):
        """
        The original source of the content item, where it comes from.
        """
        kind: pulumi.Input[Union[str, 'SourceKind']]
        """
        Source type of the content
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the content source.  The repo name, solution name, LA workspace name etc.
        """
        source_id: NotRequired[pulumi.Input[str]]
        """
        ID of the content source.  The solution ID, workspace ID, etc
        """
elif False:
    MetadataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataSourceArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[Union[str, 'SourceKind']],
                 name: Optional[pulumi.Input[str]] = None,
                 source_id: Optional[pulumi.Input[str]] = None):
        """
        The original source of the content item, where it comes from.
        :param pulumi.Input[Union[str, 'SourceKind']] kind: Source type of the content
        :param pulumi.Input[str] name: Name of the content source.  The repo name, solution name, LA workspace name etc.
        :param pulumi.Input[str] source_id: ID of the content source.  The solution ID, workspace ID, etc
        """
        pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[Union[str, 'SourceKind']]:
        """
        Source type of the content
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[Union[str, 'SourceKind']]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the content source.  The repo name, solution name, LA workspace name etc.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the content source.  The solution ID, workspace ID, etc
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_id", value)


if not MYPY:
    class MetadataSupportArgsDict(TypedDict):
        """
        Support information for the content item.
        """
        tier: pulumi.Input[Union[str, 'SupportTier']]
        """
        Type of support for content item
        """
        email: NotRequired[pulumi.Input[str]]
        """
        Email of support contact
        """
        link: NotRequired[pulumi.Input[str]]
        """
        Link for support help, like to support page to open a ticket etc.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the support contact. Company or person.
        """
elif False:
    MetadataSupportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataSupportArgs:
    def __init__(__self__, *,
                 tier: pulumi.Input[Union[str, 'SupportTier']],
                 email: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Support information for the content item.
        :param pulumi.Input[Union[str, 'SupportTier']] tier: Type of support for content item
        :param pulumi.Input[str] email: Email of support contact
        :param pulumi.Input[str] link: Link for support help, like to support page to open a ticket etc.
        :param pulumi.Input[str] name: Name of the support contact. Company or person.
        """
        pulumi.set(__self__, "tier", tier)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def tier(self) -> pulumi.Input[Union[str, 'SupportTier']]:
        """
        Type of support for content item
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: pulumi.Input[Union[str, 'SupportTier']]):
        pulumi.set(self, "tier", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        Email of support contact
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        Link for support help, like to support page to open a ticket etc.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the support contact. Company or person.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class OfficeDataConnectorDataTypesExchangeArgsDict(TypedDict):
        """
        Exchange data type connection.
        """
        state: NotRequired[pulumi.Input[Union[str, 'DataTypeState']]]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    OfficeDataConnectorDataTypesExchangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OfficeDataConnectorDataTypesExchangeArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[Union[str, 'DataTypeState']]] = None):
        """
        Exchange data type connection.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'DataTypeState']]]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'DataTypeState']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class OfficeDataConnectorDataTypesSharePointArgsDict(TypedDict):
        """
        SharePoint data type connection.
        """
        state: NotRequired[pulumi.Input[Union[str, 'DataTypeState']]]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    OfficeDataConnectorDataTypesSharePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OfficeDataConnectorDataTypesSharePointArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[Union[str, 'DataTypeState']]] = None):
        """
        SharePoint data type connection.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'DataTypeState']]]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'DataTypeState']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class OfficeDataConnectorDataTypesTeamsArgsDict(TypedDict):
        """
        Teams data type connection.
        """
        state: NotRequired[pulumi.Input[Union[str, 'DataTypeState']]]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    OfficeDataConnectorDataTypesTeamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OfficeDataConnectorDataTypesTeamsArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[Union[str, 'DataTypeState']]] = None):
        """
        Teams data type connection.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'DataTypeState']]]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'DataTypeState']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class OfficeDataConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for office data connector.
        """
        exchange: NotRequired[pulumi.Input['OfficeDataConnectorDataTypesExchangeArgsDict']]
        """
        Exchange data type connection.
        """
        share_point: NotRequired[pulumi.Input['OfficeDataConnectorDataTypesSharePointArgsDict']]
        """
        SharePoint data type connection.
        """
        teams: NotRequired[pulumi.Input['OfficeDataConnectorDataTypesTeamsArgsDict']]
        """
        Teams data type connection.
        """
elif False:
    OfficeDataConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OfficeDataConnectorDataTypesArgs:
    def __init__(__self__, *,
                 exchange: Optional[pulumi.Input['OfficeDataConnectorDataTypesExchangeArgs']] = None,
                 share_point: Optional[pulumi.Input['OfficeDataConnectorDataTypesSharePointArgs']] = None,
                 teams: Optional[pulumi.Input['OfficeDataConnectorDataTypesTeamsArgs']] = None):
        """
        The available data types for office data connector.
        :param pulumi.Input['OfficeDataConnectorDataTypesExchangeArgs'] exchange: Exchange data type connection.
        :param pulumi.Input['OfficeDataConnectorDataTypesSharePointArgs'] share_point: SharePoint data type connection.
        :param pulumi.Input['OfficeDataConnectorDataTypesTeamsArgs'] teams: Teams data type connection.
        """
        if exchange is not None:
            pulumi.set(__self__, "exchange", exchange)
        if share_point is not None:
            pulumi.set(__self__, "share_point", share_point)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter
    def exchange(self) -> Optional[pulumi.Input['OfficeDataConnectorDataTypesExchangeArgs']]:
        """
        Exchange data type connection.
        """
        return pulumi.get(self, "exchange")

    @exchange.setter
    def exchange(self, value: Optional[pulumi.Input['OfficeDataConnectorDataTypesExchangeArgs']]):
        pulumi.set(self, "exchange", value)

    @property
    @pulumi.getter(name="sharePoint")
    def share_point(self) -> Optional[pulumi.Input['OfficeDataConnectorDataTypesSharePointArgs']]:
        """
        SharePoint data type connection.
        """
        return pulumi.get(self, "share_point")

    @share_point.setter
    def share_point(self, value: Optional[pulumi.Input['OfficeDataConnectorDataTypesSharePointArgs']]):
        pulumi.set(self, "share_point", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input['OfficeDataConnectorDataTypesTeamsArgs']]:
        """
        Teams data type connection.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input['OfficeDataConnectorDataTypesTeamsArgs']]):
        pulumi.set(self, "teams", value)


if not MYPY:
    class PlaybookActionPropertiesArgsDict(TypedDict):
        logic_app_resource_id: pulumi.Input[str]
        """
        The resource id of the playbook resource.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The tenant id of the playbook resource.
        """
elif False:
    PlaybookActionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlaybookActionPropertiesArgs:
    def __init__(__self__, *,
                 logic_app_resource_id: pulumi.Input[str],
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] logic_app_resource_id: The resource id of the playbook resource.
        :param pulumi.Input[str] tenant_id: The tenant id of the playbook resource.
        """
        pulumi.set(__self__, "logic_app_resource_id", logic_app_resource_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="logicAppResourceId")
    def logic_app_resource_id(self) -> pulumi.Input[str]:
        """
        The resource id of the playbook resource.
        """
        return pulumi.get(self, "logic_app_resource_id")

    @logic_app_resource_id.setter
    def logic_app_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "logic_app_resource_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The tenant id of the playbook resource.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class PropertyArrayChangedConditionPropertiesArgsDict(TypedDict):
        """
        Describes an automation rule condition that evaluates an array property's value change
        """
        condition_type: pulumi.Input[str]
        """

        Expected value is 'PropertyArrayChanged'.
        """
        condition_properties: NotRequired[pulumi.Input['AutomationRulePropertyArrayChangedValuesConditionArgsDict']]
elif False:
    PropertyArrayChangedConditionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyArrayChangedConditionPropertiesArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[str],
                 condition_properties: Optional[pulumi.Input['AutomationRulePropertyArrayChangedValuesConditionArgs']] = None):
        """
        Describes an automation rule condition that evaluates an array property's value change
        :param pulumi.Input[str] condition_type: 
               Expected value is 'PropertyArrayChanged'.
        """
        pulumi.set(__self__, "condition_type", 'PropertyArrayChanged')
        if condition_properties is not None:
            pulumi.set(__self__, "condition_properties", condition_properties)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[str]:
        """

        Expected value is 'PropertyArrayChanged'.
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition_type", value)

    @property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional[pulumi.Input['AutomationRulePropertyArrayChangedValuesConditionArgs']]:
        return pulumi.get(self, "condition_properties")

    @condition_properties.setter
    def condition_properties(self, value: Optional[pulumi.Input['AutomationRulePropertyArrayChangedValuesConditionArgs']]):
        pulumi.set(self, "condition_properties", value)


if not MYPY:
    class PropertyChangedConditionPropertiesArgsDict(TypedDict):
        """
        Describes an automation rule condition that evaluates a property's value change
        """
        condition_type: pulumi.Input[str]
        """

        Expected value is 'PropertyChanged'.
        """
        condition_properties: NotRequired[pulumi.Input['AutomationRulePropertyValuesChangedConditionArgsDict']]
elif False:
    PropertyChangedConditionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyChangedConditionPropertiesArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[str],
                 condition_properties: Optional[pulumi.Input['AutomationRulePropertyValuesChangedConditionArgs']] = None):
        """
        Describes an automation rule condition that evaluates a property's value change
        :param pulumi.Input[str] condition_type: 
               Expected value is 'PropertyChanged'.
        """
        pulumi.set(__self__, "condition_type", 'PropertyChanged')
        if condition_properties is not None:
            pulumi.set(__self__, "condition_properties", condition_properties)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[str]:
        """

        Expected value is 'PropertyChanged'.
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition_type", value)

    @property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional[pulumi.Input['AutomationRulePropertyValuesChangedConditionArgs']]:
        return pulumi.get(self, "condition_properties")

    @condition_properties.setter
    def condition_properties(self, value: Optional[pulumi.Input['AutomationRulePropertyValuesChangedConditionArgs']]):
        pulumi.set(self, "condition_properties", value)


if not MYPY:
    class PropertyConditionPropertiesArgsDict(TypedDict):
        """
        Describes an automation rule condition that evaluates a property's value
        """
        condition_type: pulumi.Input[str]
        """

        Expected value is 'Property'.
        """
        condition_properties: NotRequired[pulumi.Input['AutomationRulePropertyValuesConditionArgsDict']]
elif False:
    PropertyConditionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyConditionPropertiesArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[str],
                 condition_properties: Optional[pulumi.Input['AutomationRulePropertyValuesConditionArgs']] = None):
        """
        Describes an automation rule condition that evaluates a property's value
        :param pulumi.Input[str] condition_type: 
               Expected value is 'Property'.
        """
        pulumi.set(__self__, "condition_type", 'Property')
        if condition_properties is not None:
            pulumi.set(__self__, "condition_properties", condition_properties)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[str]:
        """

        Expected value is 'Property'.
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition_type", value)

    @property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional[pulumi.Input['AutomationRulePropertyValuesConditionArgs']]:
        return pulumi.get(self, "condition_properties")

    @condition_properties.setter
    def condition_properties(self, value: Optional[pulumi.Input['AutomationRulePropertyValuesConditionArgs']]):
        pulumi.set(self, "condition_properties", value)


if not MYPY:
    class RepositoryResourceInfoArgsDict(TypedDict):
        """
        Resources created in user's repository for the source-control.
        """
        azure_dev_ops_resource_info: NotRequired[pulumi.Input['AzureDevOpsResourceInfoArgsDict']]
        """
        Resources created in Azure DevOps for this source-control.
        """
        git_hub_resource_info: NotRequired[pulumi.Input['GitHubResourceInfoArgsDict']]
        """
        Resources created in GitHub for this source-control.
        """
        webhook: NotRequired[pulumi.Input['WebhookArgsDict']]
        """
        The webhook object created for the source-control.
        """
elif False:
    RepositoryResourceInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryResourceInfoArgs:
    def __init__(__self__, *,
                 azure_dev_ops_resource_info: Optional[pulumi.Input['AzureDevOpsResourceInfoArgs']] = None,
                 git_hub_resource_info: Optional[pulumi.Input['GitHubResourceInfoArgs']] = None,
                 webhook: Optional[pulumi.Input['WebhookArgs']] = None):
        """
        Resources created in user's repository for the source-control.
        :param pulumi.Input['AzureDevOpsResourceInfoArgs'] azure_dev_ops_resource_info: Resources created in Azure DevOps for this source-control.
        :param pulumi.Input['GitHubResourceInfoArgs'] git_hub_resource_info: Resources created in GitHub for this source-control.
        :param pulumi.Input['WebhookArgs'] webhook: The webhook object created for the source-control.
        """
        if azure_dev_ops_resource_info is not None:
            pulumi.set(__self__, "azure_dev_ops_resource_info", azure_dev_ops_resource_info)
        if git_hub_resource_info is not None:
            pulumi.set(__self__, "git_hub_resource_info", git_hub_resource_info)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @property
    @pulumi.getter(name="azureDevOpsResourceInfo")
    def azure_dev_ops_resource_info(self) -> Optional[pulumi.Input['AzureDevOpsResourceInfoArgs']]:
        """
        Resources created in Azure DevOps for this source-control.
        """
        return pulumi.get(self, "azure_dev_ops_resource_info")

    @azure_dev_ops_resource_info.setter
    def azure_dev_ops_resource_info(self, value: Optional[pulumi.Input['AzureDevOpsResourceInfoArgs']]):
        pulumi.set(self, "azure_dev_ops_resource_info", value)

    @property
    @pulumi.getter(name="gitHubResourceInfo")
    def git_hub_resource_info(self) -> Optional[pulumi.Input['GitHubResourceInfoArgs']]:
        """
        Resources created in GitHub for this source-control.
        """
        return pulumi.get(self, "git_hub_resource_info")

    @git_hub_resource_info.setter
    def git_hub_resource_info(self, value: Optional[pulumi.Input['GitHubResourceInfoArgs']]):
        pulumi.set(self, "git_hub_resource_info", value)

    @property
    @pulumi.getter
    def webhook(self) -> Optional[pulumi.Input['WebhookArgs']]:
        """
        The webhook object created for the source-control.
        """
        return pulumi.get(self, "webhook")

    @webhook.setter
    def webhook(self, value: Optional[pulumi.Input['WebhookArgs']]):
        pulumi.set(self, "webhook", value)


if not MYPY:
    class RepositoryArgsDict(TypedDict):
        """
        metadata of a repository.
        """
        branch: NotRequired[pulumi.Input[str]]
        """
        Branch name of repository.
        """
        deployment_logs_url: NotRequired[pulumi.Input[str]]
        """
        Url to access repository action logs.
        """
        display_url: NotRequired[pulumi.Input[str]]
        """
        Display url of repository.
        """
        path_mapping: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContentPathMapArgsDict']]]]
        """
        Dictionary of source control content type and path mapping.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        Url of repository.
        """
elif False:
    RepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 deployment_logs_url: Optional[pulumi.Input[str]] = None,
                 display_url: Optional[pulumi.Input[str]] = None,
                 path_mapping: Optional[pulumi.Input[Sequence[pulumi.Input['ContentPathMapArgs']]]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        metadata of a repository.
        :param pulumi.Input[str] branch: Branch name of repository.
        :param pulumi.Input[str] deployment_logs_url: Url to access repository action logs.
        :param pulumi.Input[str] display_url: Display url of repository.
        :param pulumi.Input[Sequence[pulumi.Input['ContentPathMapArgs']]] path_mapping: Dictionary of source control content type and path mapping.
        :param pulumi.Input[str] url: Url of repository.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deployment_logs_url is not None:
            pulumi.set(__self__, "deployment_logs_url", deployment_logs_url)
        if display_url is not None:
            pulumi.set(__self__, "display_url", display_url)
        if path_mapping is not None:
            pulumi.set(__self__, "path_mapping", path_mapping)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        Branch name of repository.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="deploymentLogsUrl")
    def deployment_logs_url(self) -> Optional[pulumi.Input[str]]:
        """
        Url to access repository action logs.
        """
        return pulumi.get(self, "deployment_logs_url")

    @deployment_logs_url.setter
    def deployment_logs_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deployment_logs_url", value)

    @property
    @pulumi.getter(name="displayUrl")
    def display_url(self) -> Optional[pulumi.Input[str]]:
        """
        Display url of repository.
        """
        return pulumi.get(self, "display_url")

    @display_url.setter
    def display_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_url", value)

    @property
    @pulumi.getter(name="pathMapping")
    def path_mapping(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContentPathMapArgs']]]]:
        """
        Dictionary of source control content type and path mapping.
        """
        return pulumi.get(self, "path_mapping")

    @path_mapping.setter
    def path_mapping(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContentPathMapArgs']]]]):
        pulumi.set(self, "path_mapping", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        Url of repository.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ResourceProviderRequiredPermissionsArgsDict(TypedDict):
        """
        Required permissions for the connector resource provider that define in ResourceProviders.
        For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
        """
        action: NotRequired[pulumi.Input[bool]]
        """
        Gets or sets a value indicating whether the permission is custom actions (POST).
        """
        delete: NotRequired[pulumi.Input[bool]]
        """
        Gets or sets a value indicating whether the permission is delete action (DELETE).
        """
        read: NotRequired[pulumi.Input[bool]]
        """
        Gets or sets a value indicating whether the permission is read action (GET).
        """
        write: NotRequired[pulumi.Input[bool]]
        """
        Gets or sets a value indicating whether the permission is write action (PUT or PATCH).
        """
elif False:
    ResourceProviderRequiredPermissionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceProviderRequiredPermissionsArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[bool]] = None,
                 delete: Optional[pulumi.Input[bool]] = None,
                 read: Optional[pulumi.Input[bool]] = None,
                 write: Optional[pulumi.Input[bool]] = None):
        """
        Required permissions for the connector resource provider that define in ResourceProviders.
        For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
        :param pulumi.Input[bool] action: Gets or sets a value indicating whether the permission is custom actions (POST).
        :param pulumi.Input[bool] delete: Gets or sets a value indicating whether the permission is delete action (DELETE).
        :param pulumi.Input[bool] read: Gets or sets a value indicating whether the permission is read action (GET).
        :param pulumi.Input[bool] write: Gets or sets a value indicating whether the permission is write action (PUT or PATCH).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if write is not None:
            pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets or sets a value indicating whether the permission is custom actions (POST).
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets or sets a value indicating whether the permission is delete action (DELETE).
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets or sets a value indicating whether the permission is read action (GET).
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def write(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets or sets a value indicating whether the permission is write action (PUT or PATCH).
        """
        return pulumi.get(self, "write")

    @write.setter
    def write(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write", value)


if not MYPY:
    class RfcConnectorArgsDict(TypedDict):
        """
        Describes the Rfc connector.
        """
        client: pulumi.Input[str]
        """
        Client number of the ABAP server.
        Example - 001
        """
        system_id: pulumi.Input[str]
        """
        System ID of the ABAP server.
        Example - A4H
        """
        system_number: pulumi.Input[str]
        """
        System number of the ABAP server.
        """
        type: pulumi.Input[str]
        """
        Represents the types of SAP systems.
        Expected value is 'Rfc'.
        """
        abap_server_host: NotRequired[pulumi.Input[str]]
        """
        FQDN, hostname, or IP address of the ABAP server.
        """
        authentication_type: NotRequired[pulumi.Input[Union[str, 'SapAuthenticationType']]]
        """
        The authentication type to SAP.
        """
        code_page: NotRequired[pulumi.Input[str]]
        """
        The SAP code page used for character encoding.
        Example - 1100
        """
        group: NotRequired[pulumi.Input[str]]
        """
        Logon group of the message server.
        """
        message_server_host: NotRequired[pulumi.Input[str]]
        """
        FQDN, hostname, or IP address of the Message server.
        """
        message_server_service: NotRequired[pulumi.Input[str]]
        """
        Port number, or service name (from /etc/services) of the message server.
        """
        snc_qop: NotRequired[pulumi.Input[str]]
        """
        SNC QOP.
        Options are 1, 2, 3, 8, 9.
        """
elif False:
    RfcConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RfcConnectorArgs:
    def __init__(__self__, *,
                 client: pulumi.Input[str],
                 system_id: pulumi.Input[str],
                 system_number: pulumi.Input[str],
                 type: pulumi.Input[str],
                 abap_server_host: Optional[pulumi.Input[str]] = None,
                 authentication_type: Optional[pulumi.Input[Union[str, 'SapAuthenticationType']]] = None,
                 code_page: Optional[pulumi.Input[str]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 message_server_host: Optional[pulumi.Input[str]] = None,
                 message_server_service: Optional[pulumi.Input[str]] = None,
                 snc_qop: Optional[pulumi.Input[str]] = None):
        """
        Describes the Rfc connector.
        :param pulumi.Input[str] client: Client number of the ABAP server.
               Example - 001
        :param pulumi.Input[str] system_id: System ID of the ABAP server.
               Example - A4H
        :param pulumi.Input[str] system_number: System number of the ABAP server.
        :param pulumi.Input[str] type: Represents the types of SAP systems.
               Expected value is 'Rfc'.
        :param pulumi.Input[str] abap_server_host: FQDN, hostname, or IP address of the ABAP server.
        :param pulumi.Input[Union[str, 'SapAuthenticationType']] authentication_type: The authentication type to SAP.
        :param pulumi.Input[str] code_page: The SAP code page used for character encoding.
               Example - 1100
        :param pulumi.Input[str] group: Logon group of the message server.
        :param pulumi.Input[str] message_server_host: FQDN, hostname, or IP address of the Message server.
        :param pulumi.Input[str] message_server_service: Port number, or service name (from /etc/services) of the message server.
        :param pulumi.Input[str] snc_qop: SNC QOP.
               Options are 1, 2, 3, 8, 9.
        """
        pulumi.set(__self__, "client", client)
        pulumi.set(__self__, "system_id", system_id)
        pulumi.set(__self__, "system_number", system_number)
        pulumi.set(__self__, "type", 'Rfc')
        if abap_server_host is not None:
            pulumi.set(__self__, "abap_server_host", abap_server_host)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if code_page is not None:
            pulumi.set(__self__, "code_page", code_page)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if message_server_host is not None:
            pulumi.set(__self__, "message_server_host", message_server_host)
        if message_server_service is not None:
            pulumi.set(__self__, "message_server_service", message_server_service)
        if snc_qop is not None:
            pulumi.set(__self__, "snc_qop", snc_qop)

    @property
    @pulumi.getter
    def client(self) -> pulumi.Input[str]:
        """
        Client number of the ABAP server.
        Example - 001
        """
        return pulumi.get(self, "client")

    @client.setter
    def client(self, value: pulumi.Input[str]):
        pulumi.set(self, "client", value)

    @property
    @pulumi.getter(name="systemId")
    def system_id(self) -> pulumi.Input[str]:
        """
        System ID of the ABAP server.
        Example - A4H
        """
        return pulumi.get(self, "system_id")

    @system_id.setter
    def system_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "system_id", value)

    @property
    @pulumi.getter(name="systemNumber")
    def system_number(self) -> pulumi.Input[str]:
        """
        System number of the ABAP server.
        """
        return pulumi.get(self, "system_number")

    @system_number.setter
    def system_number(self, value: pulumi.Input[str]):
        pulumi.set(self, "system_number", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Represents the types of SAP systems.
        Expected value is 'Rfc'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="abapServerHost")
    def abap_server_host(self) -> Optional[pulumi.Input[str]]:
        """
        FQDN, hostname, or IP address of the ABAP server.
        """
        return pulumi.get(self, "abap_server_host")

    @abap_server_host.setter
    def abap_server_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "abap_server_host", value)

    @property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[pulumi.Input[Union[str, 'SapAuthenticationType']]]:
        """
        The authentication type to SAP.
        """
        return pulumi.get(self, "authentication_type")

    @authentication_type.setter
    def authentication_type(self, value: Optional[pulumi.Input[Union[str, 'SapAuthenticationType']]]):
        pulumi.set(self, "authentication_type", value)

    @property
    @pulumi.getter(name="codePage")
    def code_page(self) -> Optional[pulumi.Input[str]]:
        """
        The SAP code page used for character encoding.
        Example - 1100
        """
        return pulumi.get(self, "code_page")

    @code_page.setter
    def code_page(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code_page", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Logon group of the message server.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter(name="messageServerHost")
    def message_server_host(self) -> Optional[pulumi.Input[str]]:
        """
        FQDN, hostname, or IP address of the Message server.
        """
        return pulumi.get(self, "message_server_host")

    @message_server_host.setter
    def message_server_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_server_host", value)

    @property
    @pulumi.getter(name="messageServerService")
    def message_server_service(self) -> Optional[pulumi.Input[str]]:
        """
        Port number, or service name (from /etc/services) of the message server.
        """
        return pulumi.get(self, "message_server_service")

    @message_server_service.setter
    def message_server_service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_server_service", value)

    @property
    @pulumi.getter(name="sncQop")
    def snc_qop(self) -> Optional[pulumi.Input[str]]:
        """
        SNC QOP.
        Options are 1, 2, 3, 8, 9.
        """
        return pulumi.get(self, "snc_qop")

    @snc_qop.setter
    def snc_qop(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snc_qop", value)


if not MYPY:
    class SampleQueryArgsDict(TypedDict):
        """
        The sample queries for the connector.
        """
        description: pulumi.Input[str]
        """
        Gets or sets the  sample query description.
        """
        query: pulumi.Input[str]
        """
        Gets or sets the KQL sample query.
        """
elif False:
    SampleQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SampleQueryArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[str],
                 query: pulumi.Input[str]):
        """
        The sample queries for the connector.
        :param pulumi.Input[str] description: Gets or sets the  sample query description.
        :param pulumi.Input[str] query: Gets or sets the KQL sample query.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def description(self) -> pulumi.Input[str]:
        """
        Gets or sets the  sample query description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Gets or sets the KQL sample query.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


if not MYPY:
    class SapAgentConfigurationArgsDict(TypedDict):
        """
        Describes the configuration of a SAP Docker agent.
        """
        type: pulumi.Input[str]
        """
        Type of the agent
        Expected value is 'SAP'.
        """
        agent_container_name: NotRequired[pulumi.Input[str]]
        """
        The name of the docker agent.
        only letters with numbers, underscores and hyphens are allowed
        example: "my-agent"
        """
        key_vault_authentication_mode: NotRequired[pulumi.Input[Union[str, 'KeyVaultAuthenticationMode']]]
        """
        The key mode of the agent.
        ManagedIdentity|ApplicationIdentity are the options
        """
        key_vault_resource_id: NotRequired[pulumi.Input[str]]
        """
        The key vault resource id to access the key vault.
        example: "/subscriptions/d0cfe6b2-9ac0-4464-9919-dccaee2e48c0/resourceGroups/myRg/providers/Microsoft.KeyVault/vaults/myVault"
        """
        sdk_path: NotRequired[pulumi.Input[str]]
        """
        The SDK path (a file not a folder) on the agent machine.
        example: "/path/to/nwrfc750P_8-70002755.zip"
        """
        secret_source: NotRequired[pulumi.Input[Union[str, 'SecretSource']]]
        """
        The secret source of the agent.
        AzureKeyVault is the option
        """
        snc_path: NotRequired[pulumi.Input[str]]
        """
        The SNC path (a folder not a file) on the agent machine.
        example: "/path/to/snc"
        """
elif False:
    SapAgentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SapAgentConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 agent_container_name: Optional[pulumi.Input[str]] = None,
                 key_vault_authentication_mode: Optional[pulumi.Input[Union[str, 'KeyVaultAuthenticationMode']]] = None,
                 key_vault_resource_id: Optional[pulumi.Input[str]] = None,
                 sdk_path: Optional[pulumi.Input[str]] = None,
                 secret_source: Optional[pulumi.Input[Union[str, 'SecretSource']]] = None,
                 snc_path: Optional[pulumi.Input[str]] = None):
        """
        Describes the configuration of a SAP Docker agent.
        :param pulumi.Input[str] type: Type of the agent
               Expected value is 'SAP'.
        :param pulumi.Input[str] agent_container_name: The name of the docker agent.
               only letters with numbers, underscores and hyphens are allowed
               example: "my-agent"
        :param pulumi.Input[Union[str, 'KeyVaultAuthenticationMode']] key_vault_authentication_mode: The key mode of the agent.
               ManagedIdentity|ApplicationIdentity are the options
        :param pulumi.Input[str] key_vault_resource_id: The key vault resource id to access the key vault.
               example: "/subscriptions/d0cfe6b2-9ac0-4464-9919-dccaee2e48c0/resourceGroups/myRg/providers/Microsoft.KeyVault/vaults/myVault"
        :param pulumi.Input[str] sdk_path: The SDK path (a file not a folder) on the agent machine.
               example: "/path/to/nwrfc750P_8-70002755.zip"
        :param pulumi.Input[Union[str, 'SecretSource']] secret_source: The secret source of the agent.
               AzureKeyVault is the option
        :param pulumi.Input[str] snc_path: The SNC path (a folder not a file) on the agent machine.
               example: "/path/to/snc"
        """
        pulumi.set(__self__, "type", 'SAP')
        if agent_container_name is not None:
            pulumi.set(__self__, "agent_container_name", agent_container_name)
        if key_vault_authentication_mode is not None:
            pulumi.set(__self__, "key_vault_authentication_mode", key_vault_authentication_mode)
        if key_vault_resource_id is not None:
            pulumi.set(__self__, "key_vault_resource_id", key_vault_resource_id)
        if sdk_path is not None:
            pulumi.set(__self__, "sdk_path", sdk_path)
        if secret_source is not None:
            pulumi.set(__self__, "secret_source", secret_source)
        if snc_path is not None:
            pulumi.set(__self__, "snc_path", snc_path)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the agent
        Expected value is 'SAP'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="agentContainerName")
    def agent_container_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the docker agent.
        only letters with numbers, underscores and hyphens are allowed
        example: "my-agent"
        """
        return pulumi.get(self, "agent_container_name")

    @agent_container_name.setter
    def agent_container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "agent_container_name", value)

    @property
    @pulumi.getter(name="keyVaultAuthenticationMode")
    def key_vault_authentication_mode(self) -> Optional[pulumi.Input[Union[str, 'KeyVaultAuthenticationMode']]]:
        """
        The key mode of the agent.
        ManagedIdentity|ApplicationIdentity are the options
        """
        return pulumi.get(self, "key_vault_authentication_mode")

    @key_vault_authentication_mode.setter
    def key_vault_authentication_mode(self, value: Optional[pulumi.Input[Union[str, 'KeyVaultAuthenticationMode']]]):
        pulumi.set(self, "key_vault_authentication_mode", value)

    @property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The key vault resource id to access the key vault.
        example: "/subscriptions/d0cfe6b2-9ac0-4464-9919-dccaee2e48c0/resourceGroups/myRg/providers/Microsoft.KeyVault/vaults/myVault"
        """
        return pulumi.get(self, "key_vault_resource_id")

    @key_vault_resource_id.setter
    def key_vault_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_resource_id", value)

    @property
    @pulumi.getter(name="sdkPath")
    def sdk_path(self) -> Optional[pulumi.Input[str]]:
        """
        The SDK path (a file not a folder) on the agent machine.
        example: "/path/to/nwrfc750P_8-70002755.zip"
        """
        return pulumi.get(self, "sdk_path")

    @sdk_path.setter
    def sdk_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sdk_path", value)

    @property
    @pulumi.getter(name="secretSource")
    def secret_source(self) -> Optional[pulumi.Input[Union[str, 'SecretSource']]]:
        """
        The secret source of the agent.
        AzureKeyVault is the option
        """
        return pulumi.get(self, "secret_source")

    @secret_source.setter
    def secret_source(self, value: Optional[pulumi.Input[Union[str, 'SecretSource']]]):
        pulumi.set(self, "secret_source", value)

    @property
    @pulumi.getter(name="sncPath")
    def snc_path(self) -> Optional[pulumi.Input[str]]:
        """
        The SNC path (a folder not a file) on the agent machine.
        example: "/path/to/snc"
        """
        return pulumi.get(self, "snc_path")

    @snc_path.setter
    def snc_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snc_path", value)


if not MYPY:
    class SapControlConnectorArgsDict(TypedDict):
        """
        Describes the SapControl connector configuration.
        """
        instance: pulumi.Input[str]
        """
        The instance number. Only 2 digits are allowed.
        """
        server: pulumi.Input[str]
        """
        The server name.
        FQDN or IP address.
        """
        type: pulumi.Input[str]
        """
        Represents the types of SAP systems.
        Expected value is 'SapControl'.
        """
        https_configuration: NotRequired[pulumi.Input[Union[str, 'HttpsConfigurationType']]]
        """
        Represents the types of HTTPS configuration to connect to the SapControl service.
        """
        port: NotRequired[pulumi.Input[str]]
        """
        The port of the SOAP connection to SAP Control.
        """
        timezone: NotRequired[pulumi.Input[str]]
        """
        The timezone.
        example: "GMT+0" or "GMT-8"
        default: "GMT+0"
        """
elif False:
    SapControlConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SapControlConnectorArgs:
    def __init__(__self__, *,
                 instance: pulumi.Input[str],
                 server: pulumi.Input[str],
                 type: pulumi.Input[str],
                 https_configuration: Optional[pulumi.Input[Union[str, 'HttpsConfigurationType']]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        Describes the SapControl connector configuration.
        :param pulumi.Input[str] instance: The instance number. Only 2 digits are allowed.
        :param pulumi.Input[str] server: The server name.
               FQDN or IP address.
        :param pulumi.Input[str] type: Represents the types of SAP systems.
               Expected value is 'SapControl'.
        :param pulumi.Input[Union[str, 'HttpsConfigurationType']] https_configuration: Represents the types of HTTPS configuration to connect to the SapControl service.
        :param pulumi.Input[str] port: The port of the SOAP connection to SAP Control.
        :param pulumi.Input[str] timezone: The timezone.
               example: "GMT+0" or "GMT-8"
               default: "GMT+0"
        """
        pulumi.set(__self__, "instance", instance)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "type", 'SapControl')
        if https_configuration is not None:
            pulumi.set(__self__, "https_configuration", https_configuration)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if timezone is None:
            timezone = 'GMT+0'
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def instance(self) -> pulumi.Input[str]:
        """
        The instance number. Only 2 digits are allowed.
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter
    def server(self) -> pulumi.Input[str]:
        """
        The server name.
        FQDN or IP address.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: pulumi.Input[str]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Represents the types of SAP systems.
        Expected value is 'SapControl'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="httpsConfiguration")
    def https_configuration(self) -> Optional[pulumi.Input[Union[str, 'HttpsConfigurationType']]]:
        """
        Represents the types of HTTPS configuration to connect to the SapControl service.
        """
        return pulumi.get(self, "https_configuration")

    @https_configuration.setter
    def https_configuration(self, value: Optional[pulumi.Input[Union[str, 'HttpsConfigurationType']]]):
        pulumi.set(self, "https_configuration", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        The port of the SOAP connection to SAP Control.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        The timezone.
        example: "GMT+0" or "GMT-8"
        default: "GMT+0"
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class SapSystemsConfigurationArgsDict(TypedDict):
        """
        Describes the SAP configuration.
        """
        connector: pulumi.Input[Union['RfcConnectorArgsDict', 'SapControlConnectorArgsDict']]
        """
        Base Model for SAP System Connector.
        """
        type: pulumi.Input[str]
        """
        Represents the types of configuration for a system.
        Expected value is 'SAP'.
        """
        azure_resource_id: NotRequired[pulumi.Input[str]]
        """
        azure resource id
        example: "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroup/providers/Microsoft.Compute/virtualMachines/myVM"
        """
        logs: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogArgsDict']]]]
        """
        The logs configuration.
        """
elif False:
    SapSystemsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SapSystemsConfigurationArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[Union['RfcConnectorArgs', 'SapControlConnectorArgs']],
                 type: pulumi.Input[str],
                 azure_resource_id: Optional[pulumi.Input[str]] = None,
                 logs: Optional[pulumi.Input[Sequence[pulumi.Input['LogArgs']]]] = None):
        """
        Describes the SAP configuration.
        :param pulumi.Input[Union['RfcConnectorArgs', 'SapControlConnectorArgs']] connector: Base Model for SAP System Connector.
        :param pulumi.Input[str] type: Represents the types of configuration for a system.
               Expected value is 'SAP'.
        :param pulumi.Input[str] azure_resource_id: azure resource id
               example: "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroup/providers/Microsoft.Compute/virtualMachines/myVM"
        :param pulumi.Input[Sequence[pulumi.Input['LogArgs']]] logs: The logs configuration.
        """
        pulumi.set(__self__, "connector", connector)
        pulumi.set(__self__, "type", 'SAP')
        if azure_resource_id is not None:
            pulumi.set(__self__, "azure_resource_id", azure_resource_id)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)

    @property
    @pulumi.getter
    def connector(self) -> pulumi.Input[Union['RfcConnectorArgs', 'SapControlConnectorArgs']]:
        """
        Base Model for SAP System Connector.
        """
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[Union['RfcConnectorArgs', 'SapControlConnectorArgs']]):
        pulumi.set(self, "connector", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Represents the types of configuration for a system.
        Expected value is 'SAP'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        azure resource id
        example: "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroup/providers/Microsoft.Compute/virtualMachines/myVM"
        """
        return pulumi.get(self, "azure_resource_id")

    @azure_resource_id.setter
    def azure_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_resource_id", value)

    @property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogArgs']]]]:
        """
        The logs configuration.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogArgs']]]]):
        pulumi.set(self, "logs", value)


if not MYPY:
    class SecurityMLAnalyticsSettingsDataSourceArgsDict(TypedDict):
        """
        security ml analytics settings data sources
        """
        connector_id: NotRequired[pulumi.Input[str]]
        """
        The connector id that provides the following data types
        """
        data_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The data types used by the security ml analytics settings
        """
elif False:
    SecurityMLAnalyticsSettingsDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityMLAnalyticsSettingsDataSourceArgs:
    def __init__(__self__, *,
                 connector_id: Optional[pulumi.Input[str]] = None,
                 data_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        security ml analytics settings data sources
        :param pulumi.Input[str] connector_id: The connector id that provides the following data types
        :param pulumi.Input[Sequence[pulumi.Input[str]]] data_types: The data types used by the security ml analytics settings
        """
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)
        if data_types is not None:
            pulumi.set(__self__, "data_types", data_types)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The connector id that provides the following data types
        """
        return pulumi.get(self, "connector_id")

    @connector_id.setter
    def connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connector_id", value)

    @property
    @pulumi.getter(name="dataTypes")
    def data_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The data types used by the security ml analytics settings
        """
        return pulumi.get(self, "data_types")

    @data_types.setter
    def data_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "data_types", value)


if not MYPY:
    class TIDataConnectorDataTypesIndicatorsArgsDict(TypedDict):
        """
        Data type for indicators connection.
        """
        state: NotRequired[pulumi.Input[Union[str, 'DataTypeState']]]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    TIDataConnectorDataTypesIndicatorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TIDataConnectorDataTypesIndicatorsArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[Union[str, 'DataTypeState']]] = None):
        """
        Data type for indicators connection.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'DataTypeState']]]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'DataTypeState']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class TIDataConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for TI (Threat Intelligence) data connector.
        """
        indicators: NotRequired[pulumi.Input['TIDataConnectorDataTypesIndicatorsArgsDict']]
        """
        Data type for indicators connection.
        """
elif False:
    TIDataConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TIDataConnectorDataTypesArgs:
    def __init__(__self__, *,
                 indicators: Optional[pulumi.Input['TIDataConnectorDataTypesIndicatorsArgs']] = None):
        """
        The available data types for TI (Threat Intelligence) data connector.
        :param pulumi.Input['TIDataConnectorDataTypesIndicatorsArgs'] indicators: Data type for indicators connection.
        """
        if indicators is not None:
            pulumi.set(__self__, "indicators", indicators)

    @property
    @pulumi.getter
    def indicators(self) -> Optional[pulumi.Input['TIDataConnectorDataTypesIndicatorsArgs']]:
        """
        Data type for indicators connection.
        """
        return pulumi.get(self, "indicators")

    @indicators.setter
    def indicators(self, value: Optional[pulumi.Input['TIDataConnectorDataTypesIndicatorsArgs']]):
        pulumi.set(self, "indicators", value)


if not MYPY:
    class ThreatIntelligenceExternalReferenceArgsDict(TypedDict):
        """
        Describes external reference
        """
        description: NotRequired[pulumi.Input[str]]
        """
        External reference description
        """
        external_id: NotRequired[pulumi.Input[str]]
        """
        External reference ID
        """
        hashes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        External reference hashes
        """
        source_name: NotRequired[pulumi.Input[str]]
        """
        External reference source name
        """
        url: NotRequired[pulumi.Input[str]]
        """
        External reference URL
        """
elif False:
    ThreatIntelligenceExternalReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThreatIntelligenceExternalReferenceArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 external_id: Optional[pulumi.Input[str]] = None,
                 hashes: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 source_name: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        Describes external reference
        :param pulumi.Input[str] description: External reference description
        :param pulumi.Input[str] external_id: External reference ID
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] hashes: External reference hashes
        :param pulumi.Input[str] source_name: External reference source name
        :param pulumi.Input[str] url: External reference URL
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if hashes is not None:
            pulumi.set(__self__, "hashes", hashes)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        External reference description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        """
        External reference ID
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter
    def hashes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        External reference hashes
        """
        return pulumi.get(self, "hashes")

    @hashes.setter
    def hashes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "hashes", value)

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[pulumi.Input[str]]:
        """
        External reference source name
        """
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_name", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        External reference URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ThreatIntelligenceGranularMarkingModelArgsDict(TypedDict):
        """
        Describes threat granular marking model entity
        """
        language: NotRequired[pulumi.Input[str]]
        """
        Language granular marking model
        """
        marking_ref: NotRequired[pulumi.Input[int]]
        """
        marking reference granular marking model
        """
        selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        granular marking model selectors
        """
elif False:
    ThreatIntelligenceGranularMarkingModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThreatIntelligenceGranularMarkingModelArgs:
    def __init__(__self__, *,
                 language: Optional[pulumi.Input[str]] = None,
                 marking_ref: Optional[pulumi.Input[int]] = None,
                 selectors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Describes threat granular marking model entity
        :param pulumi.Input[str] language: Language granular marking model
        :param pulumi.Input[int] marking_ref: marking reference granular marking model
        :param pulumi.Input[Sequence[pulumi.Input[str]]] selectors: granular marking model selectors
        """
        if language is not None:
            pulumi.set(__self__, "language", language)
        if marking_ref is not None:
            pulumi.set(__self__, "marking_ref", marking_ref)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)

    @property
    @pulumi.getter
    def language(self) -> Optional[pulumi.Input[str]]:
        """
        Language granular marking model
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language", value)

    @property
    @pulumi.getter(name="markingRef")
    def marking_ref(self) -> Optional[pulumi.Input[int]]:
        """
        marking reference granular marking model
        """
        return pulumi.get(self, "marking_ref")

    @marking_ref.setter
    def marking_ref(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "marking_ref", value)

    @property
    @pulumi.getter
    def selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        granular marking model selectors
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class ThreatIntelligenceKillChainPhaseArgsDict(TypedDict):
        """
        Describes threat kill chain phase entity
        """
        kill_chain_name: NotRequired[pulumi.Input[str]]
        """
        Kill chainName name
        """
        phase_name: NotRequired[pulumi.Input[str]]
        """
        Phase name
        """
elif False:
    ThreatIntelligenceKillChainPhaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThreatIntelligenceKillChainPhaseArgs:
    def __init__(__self__, *,
                 kill_chain_name: Optional[pulumi.Input[str]] = None,
                 phase_name: Optional[pulumi.Input[str]] = None):
        """
        Describes threat kill chain phase entity
        :param pulumi.Input[str] kill_chain_name: Kill chainName name
        :param pulumi.Input[str] phase_name: Phase name
        """
        if kill_chain_name is not None:
            pulumi.set(__self__, "kill_chain_name", kill_chain_name)
        if phase_name is not None:
            pulumi.set(__self__, "phase_name", phase_name)

    @property
    @pulumi.getter(name="killChainName")
    def kill_chain_name(self) -> Optional[pulumi.Input[str]]:
        """
        Kill chainName name
        """
        return pulumi.get(self, "kill_chain_name")

    @kill_chain_name.setter
    def kill_chain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kill_chain_name", value)

    @property
    @pulumi.getter(name="phaseName")
    def phase_name(self) -> Optional[pulumi.Input[str]]:
        """
        Phase name
        """
        return pulumi.get(self, "phase_name")

    @phase_name.setter
    def phase_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase_name", value)


if not MYPY:
    class ThreatIntelligenceParsedPatternTypeValueArgsDict(TypedDict):
        """
        Describes threat kill chain phase entity
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of parsed pattern
        """
        value_type: NotRequired[pulumi.Input[str]]
        """
        Type of the value
        """
elif False:
    ThreatIntelligenceParsedPatternTypeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThreatIntelligenceParsedPatternTypeValueArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None,
                 value_type: Optional[pulumi.Input[str]] = None):
        """
        Describes threat kill chain phase entity
        :param pulumi.Input[str] value: Value of parsed pattern
        :param pulumi.Input[str] value_type: Type of the value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of parsed pattern
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the value
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class ThreatIntelligenceParsedPatternArgsDict(TypedDict):
        """
        Describes parsed pattern entity
        """
        pattern_type_key: NotRequired[pulumi.Input[str]]
        """
        Pattern type key
        """
        pattern_type_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['ThreatIntelligenceParsedPatternTypeValueArgsDict']]]]
        """
        Pattern type keys
        """
elif False:
    ThreatIntelligenceParsedPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThreatIntelligenceParsedPatternArgs:
    def __init__(__self__, *,
                 pattern_type_key: Optional[pulumi.Input[str]] = None,
                 pattern_type_values: Optional[pulumi.Input[Sequence[pulumi.Input['ThreatIntelligenceParsedPatternTypeValueArgs']]]] = None):
        """
        Describes parsed pattern entity
        :param pulumi.Input[str] pattern_type_key: Pattern type key
        :param pulumi.Input[Sequence[pulumi.Input['ThreatIntelligenceParsedPatternTypeValueArgs']]] pattern_type_values: Pattern type keys
        """
        if pattern_type_key is not None:
            pulumi.set(__self__, "pattern_type_key", pattern_type_key)
        if pattern_type_values is not None:
            pulumi.set(__self__, "pattern_type_values", pattern_type_values)

    @property
    @pulumi.getter(name="patternTypeKey")
    def pattern_type_key(self) -> Optional[pulumi.Input[str]]:
        """
        Pattern type key
        """
        return pulumi.get(self, "pattern_type_key")

    @pattern_type_key.setter
    def pattern_type_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern_type_key", value)

    @property
    @pulumi.getter(name="patternTypeValues")
    def pattern_type_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ThreatIntelligenceParsedPatternTypeValueArgs']]]]:
        """
        Pattern type keys
        """
        return pulumi.get(self, "pattern_type_values")

    @pattern_type_values.setter
    def pattern_type_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ThreatIntelligenceParsedPatternTypeValueArgs']]]]):
        pulumi.set(self, "pattern_type_values", value)


if not MYPY:
    class UserInfoArgsDict(TypedDict):
        """
        User information that made some action
        """
        object_id: NotRequired[pulumi.Input[str]]
        """
        The object id of the user.
        """
elif False:
    UserInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserInfoArgs:
    def __init__(__self__, *,
                 object_id: Optional[pulumi.Input[str]] = None):
        """
        User information that made some action
        :param pulumi.Input[str] object_id: The object id of the user.
        """
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The object id of the user.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)


if not MYPY:
    class WatchlistUserInfoArgsDict(TypedDict):
        """
        User information that made some action
        """
        object_id: NotRequired[pulumi.Input[str]]
        """
        The object id of the user.
        """
elif False:
    WatchlistUserInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WatchlistUserInfoArgs:
    def __init__(__self__, *,
                 object_id: Optional[pulumi.Input[str]] = None):
        """
        User information that made some action
        :param pulumi.Input[str] object_id: The object id of the user.
        """
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The object id of the user.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)


if not MYPY:
    class WebhookArgsDict(TypedDict):
        """
        Detail about the webhook object.
        """
        rotate_webhook_secret: NotRequired[pulumi.Input[bool]]
        """
        A flag to instruct the backend service to rotate webhook secret.
        """
        webhook_id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier for the webhook.
        """
        webhook_secret_update_time: NotRequired[pulumi.Input[str]]
        """
        Time when the webhook secret was updated.
        """
        webhook_url: NotRequired[pulumi.Input[str]]
        """
        URL that gets invoked by the webhook.
        """
elif False:
    WebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookArgs:
    def __init__(__self__, *,
                 rotate_webhook_secret: Optional[pulumi.Input[bool]] = None,
                 webhook_id: Optional[pulumi.Input[str]] = None,
                 webhook_secret_update_time: Optional[pulumi.Input[str]] = None,
                 webhook_url: Optional[pulumi.Input[str]] = None):
        """
        Detail about the webhook object.
        :param pulumi.Input[bool] rotate_webhook_secret: A flag to instruct the backend service to rotate webhook secret.
        :param pulumi.Input[str] webhook_id: Unique identifier for the webhook.
        :param pulumi.Input[str] webhook_secret_update_time: Time when the webhook secret was updated.
        :param pulumi.Input[str] webhook_url: URL that gets invoked by the webhook.
        """
        if rotate_webhook_secret is not None:
            pulumi.set(__self__, "rotate_webhook_secret", rotate_webhook_secret)
        if webhook_id is not None:
            pulumi.set(__self__, "webhook_id", webhook_id)
        if webhook_secret_update_time is not None:
            pulumi.set(__self__, "webhook_secret_update_time", webhook_secret_update_time)
        if webhook_url is not None:
            pulumi.set(__self__, "webhook_url", webhook_url)

    @property
    @pulumi.getter(name="rotateWebhookSecret")
    def rotate_webhook_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to instruct the backend service to rotate webhook secret.
        """
        return pulumi.get(self, "rotate_webhook_secret")

    @rotate_webhook_secret.setter
    def rotate_webhook_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rotate_webhook_secret", value)

    @property
    @pulumi.getter(name="webhookId")
    def webhook_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the webhook.
        """
        return pulumi.get(self, "webhook_id")

    @webhook_id.setter
    def webhook_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webhook_id", value)

    @property
    @pulumi.getter(name="webhookSecretUpdateTime")
    def webhook_secret_update_time(self) -> Optional[pulumi.Input[str]]:
        """
        Time when the webhook secret was updated.
        """
        return pulumi.get(self, "webhook_secret_update_time")

    @webhook_secret_update_time.setter
    def webhook_secret_update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webhook_secret_update_time", value)

    @property
    @pulumi.getter(name="webhookUrl")
    def webhook_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL that gets invoked by the webhook.
        """
        return pulumi.get(self, "webhook_url")

    @webhook_url.setter
    def webhook_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webhook_url", value)


