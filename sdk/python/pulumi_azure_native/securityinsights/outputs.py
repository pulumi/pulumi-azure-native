# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AWSAuthModelResponse',
    'ActivityEntityQueriesPropertiesResponseQueryDefinitions',
    'ActivityTimelineItemResponse',
    'AddIncidentTaskActionPropertiesResponse',
    'AgentSystemResponse',
    'AlertDetailsOverrideResponse',
    'AlertPropertyMappingResponse',
    'AlertsDataTypeOfDataConnectorResponse',
    'AnomalyTimelineItemResponse',
    'ApiKeyAuthModelResponse',
    'AssignmentItemResponse',
    'AutomationRuleAddIncidentTaskActionResponse',
    'AutomationRuleBooleanConditionResponse',
    'AutomationRuleModifyPropertiesActionResponse',
    'AutomationRulePropertyArrayChangedValuesConditionResponse',
    'AutomationRulePropertyArrayValuesConditionResponse',
    'AutomationRulePropertyValuesChangedConditionResponse',
    'AutomationRulePropertyValuesConditionResponse',
    'AutomationRuleRunPlaybookActionResponse',
    'AutomationRuleTriggeringLogicResponse',
    'AwsCloudTrailDataConnectorDataTypesResponse',
    'AwsCloudTrailDataConnectorDataTypesResponseLogs',
    'AzureDevOpsResourceInfoResponse',
    'BasicAuthModelResponse',
    'BookmarkTimelineItemResponse',
    'BooleanConditionPropertiesResponse',
    'CcpResponseConfigResponse',
    'ClientInfoResponse',
    'ConnectivityCriterionResponse',
    'ConnectorDataTypeResponse',
    'ConnectorDefinitionsAvailabilityResponse',
    'ConnectorDefinitionsPermissionsResponse',
    'ConnectorDefinitionsResourceProviderResponse',
    'ContentPathMapResponse',
    'CustomPermissionDetailsResponse',
    'CustomizableConnectionsConfigResponse',
    'CustomizableConnectorUiConfigResponse',
    'DCRConfigurationResponse',
    'DataConnectorDataTypeCommonResponse',
    'DeploymentInfoResponse',
    'DeploymentResponse',
    'EnrichmentDomainWhoisContactResponse',
    'EnrichmentDomainWhoisContactsResponse',
    'EnrichmentDomainWhoisDetailsResponse',
    'EnrichmentDomainWhoisRegistrarDetailsResponse',
    'EntityInsightItemResponse',
    'EntityInsightItemResponseQueryTimeInterval',
    'EntityMappingResponse',
    'EventGroupingSettingsResponse',
    'FieldMappingResponse',
    'FileMetadataResponse',
    'GCPAuthModelResponse',
    'GenericBlobSbsAuthModelResponse',
    'GetInsightsErrorKindResponse',
    'GetInsightsResultsMetadataResponse',
    'GitHubAuthModelResponse',
    'GitHubResourceInfoResponse',
    'GraphQueryResponse',
    'GroupingConfigurationResponse',
    'HuntOwnerResponse',
    'IncidentAdditionalDataResponse',
    'IncidentConfigurationResponse',
    'IncidentInfoResponse',
    'IncidentLabelResponse',
    'IncidentOwnerInfoResponse',
    'IncidentPropertiesActionResponse',
    'InsightsTableResultResponse',
    'InsightsTableResultResponseColumns',
    'InstructionStepDetailsResponse',
    'InstructionStepResponse',
    'JwtAuthModelResponse',
    'LockUserActionResponse',
    'LogResponse',
    'MCASDataConnectorDataTypesResponse',
    'MSTIDataConnectorDataTypesResponse',
    'MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed',
    'MetadataAuthorResponse',
    'MetadataCategoriesResponse',
    'MetadataDependenciesResponse',
    'MetadataSourceResponse',
    'MetadataSupportResponse',
    'NoneAuthModelResponse',
    'OAuthModelResponse',
    'OfficeDataConnectorDataTypesResponse',
    'OfficeDataConnectorDataTypesResponseExchange',
    'OfficeDataConnectorDataTypesResponseSharePoint',
    'OfficeDataConnectorDataTypesResponseTeams',
    'OracleAuthModelResponse',
    'PlaybookActionPropertiesResponse',
    'PremiumMdtiDataConnectorDataTypesResponse',
    'PremiumMdtiDataConnectorDataTypesResponseConnector',
    'PropertyArrayChangedConditionPropertiesResponse',
    'PropertyArrayConditionPropertiesResponse',
    'PropertyChangedConditionPropertiesResponse',
    'PropertyConditionPropertiesResponse',
    'RepoResponse',
    'RepositoryResourceInfoResponse',
    'RepositoryResponse',
    'ResourceProviderRequiredPermissionsResponse',
    'RestApiPollerRequestConfigResponse',
    'RestApiPollerRequestPagingConfigResponse',
    'RfcConnectorResponse',
    'SapAgentConfigurationResponse',
    'SapControlConnectorResponse',
    'SapSystemsConfigurationResponse',
    'SecurityAlertTimelineItemResponse',
    'SecurityMLAnalyticsSettingsDataSourceResponse',
    'SessionAuthModelResponse',
    'SystemDataResponse',
    'TIDataConnectorDataTypesResponse',
    'TIDataConnectorDataTypesResponseIndicators',
    'TemplatePropertiesResponse',
    'TimelineAggregationResponse',
    'TimelineErrorResponse',
    'TimelineResultsMetadataResponse',
    'UnlockUserActionResponse',
    'UserInfoResponse',
    'ValidationErrorResponse',
    'WatchlistUserInfoResponse',
    'WebhookResponse',
]

@pulumi.output_type
class AWSAuthModelResponse(dict):
    """
    Model for API authentication with AWS.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AWSAuthModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AWSAuthModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AWSAuthModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str,
                 type: _builtins.str,
                 external_id: Optional[_builtins.str] = None):
        """
        Model for API authentication with AWS.
        :param _builtins.str role_arn: AWS STS assume role ARN
        :param _builtins.str type: Type of paging
               Expected value is 'AWS'.
        :param _builtins.str external_id: AWS STS assume role external ID. This is used to prevent the confused deputy problem: 'https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html'
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "type", 'AWS')
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        """
        AWS STS assume role ARN
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of paging
        Expected value is 'AWS'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        AWS STS assume role external ID. This is used to prevent the confused deputy problem: 'https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html'
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class ActivityEntityQueriesPropertiesResponseQueryDefinitions(dict):
    """
    The Activity query definitions
    """
    def __init__(__self__, *,
                 query: Optional[_builtins.str] = None):
        """
        The Activity query definitions
        :param _builtins.str query: The Activity query to run on a given entity
        """
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[_builtins.str]:
        """
        The Activity query to run on a given entity
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class ActivityTimelineItemResponse(dict):
    """
    Represents Activity timeline item.
    """
    def __init__(__self__, *,
                 bucket_end_time_utc: _builtins.str,
                 bucket_start_time_utc: _builtins.str,
                 content: _builtins.str,
                 first_activity_time_utc: _builtins.str,
                 kind: _builtins.str,
                 last_activity_time_utc: _builtins.str,
                 query_id: _builtins.str,
                 title: _builtins.str):
        """
        Represents Activity timeline item.
        :param _builtins.str bucket_end_time_utc: The grouping bucket end time.
        :param _builtins.str bucket_start_time_utc: The grouping bucket start time.
        :param _builtins.str content: The activity timeline content.
        :param _builtins.str first_activity_time_utc: The time of the first activity in the grouping bucket.
        :param _builtins.str kind: The entity query kind
               Expected value is 'Activity'.
        :param _builtins.str last_activity_time_utc: The time of the last activity in the grouping bucket.
        :param _builtins.str query_id: The activity query id.
        :param _builtins.str title: The activity timeline title.
        """
        pulumi.set(__self__, "bucket_end_time_utc", bucket_end_time_utc)
        pulumi.set(__self__, "bucket_start_time_utc", bucket_start_time_utc)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "first_activity_time_utc", first_activity_time_utc)
        pulumi.set(__self__, "kind", 'Activity')
        pulumi.set(__self__, "last_activity_time_utc", last_activity_time_utc)
        pulumi.set(__self__, "query_id", query_id)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="bucketEndTimeUTC")
    def bucket_end_time_utc(self) -> _builtins.str:
        """
        The grouping bucket end time.
        """
        return pulumi.get(self, "bucket_end_time_utc")

    @_builtins.property
    @pulumi.getter(name="bucketStartTimeUTC")
    def bucket_start_time_utc(self) -> _builtins.str:
        """
        The grouping bucket start time.
        """
        return pulumi.get(self, "bucket_start_time_utc")

    @_builtins.property
    @pulumi.getter
    def content(self) -> _builtins.str:
        """
        The activity timeline content.
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter(name="firstActivityTimeUTC")
    def first_activity_time_utc(self) -> _builtins.str:
        """
        The time of the first activity in the grouping bucket.
        """
        return pulumi.get(self, "first_activity_time_utc")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The entity query kind
        Expected value is 'Activity'.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="lastActivityTimeUTC")
    def last_activity_time_utc(self) -> _builtins.str:
        """
        The time of the last activity in the grouping bucket.
        """
        return pulumi.get(self, "last_activity_time_utc")

    @_builtins.property
    @pulumi.getter(name="queryId")
    def query_id(self) -> _builtins.str:
        """
        The activity query id.
        """
        return pulumi.get(self, "query_id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The activity timeline title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class AddIncidentTaskActionPropertiesResponse(dict):
    """
    Describes an automation rule action to add a task to an incident.
    """
    def __init__(__self__, *,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        Describes an automation rule action to add a task to an incident.
        :param _builtins.str title: The title of the task.
        :param _builtins.str description: The description of the task.
        """
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of the task.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the task.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class AgentSystemResponse(dict):
    """
    Describes the configuration of a system inside the agent.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemDisplayName":
            suggest = "system_display_name"
        elif key == "systemResourceName":
            suggest = "system_resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentSystemResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentSystemResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentSystemResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 system_display_name: Optional[_builtins.str] = None,
                 system_resource_name: Optional[_builtins.str] = None):
        """
        Describes the configuration of a system inside the agent.
        """
        if system_display_name is not None:
            pulumi.set(__self__, "system_display_name", system_display_name)
        if system_resource_name is not None:
            pulumi.set(__self__, "system_resource_name", system_resource_name)

    @_builtins.property
    @pulumi.getter(name="systemDisplayName")
    def system_display_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "system_display_name")

    @_builtins.property
    @pulumi.getter(name="systemResourceName")
    def system_resource_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "system_resource_name")


@pulumi.output_type
class AlertDetailsOverrideResponse(dict):
    """
    Settings for how to dynamically override alert static details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertDescriptionFormat":
            suggest = "alert_description_format"
        elif key == "alertDisplayNameFormat":
            suggest = "alert_display_name_format"
        elif key == "alertDynamicProperties":
            suggest = "alert_dynamic_properties"
        elif key == "alertSeverityColumnName":
            suggest = "alert_severity_column_name"
        elif key == "alertTacticsColumnName":
            suggest = "alert_tactics_column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertDetailsOverrideResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertDetailsOverrideResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertDetailsOverrideResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_description_format: Optional[_builtins.str] = None,
                 alert_display_name_format: Optional[_builtins.str] = None,
                 alert_dynamic_properties: Optional[Sequence['outputs.AlertPropertyMappingResponse']] = None,
                 alert_severity_column_name: Optional[_builtins.str] = None,
                 alert_tactics_column_name: Optional[_builtins.str] = None):
        """
        Settings for how to dynamically override alert static details
        :param _builtins.str alert_description_format: the format containing columns name(s) to override the alert description
        :param _builtins.str alert_display_name_format: the format containing columns name(s) to override the alert name
        :param Sequence['AlertPropertyMappingResponse'] alert_dynamic_properties: List of additional dynamic properties to override
        :param _builtins.str alert_severity_column_name: the column name to take the alert severity from
        :param _builtins.str alert_tactics_column_name: the column name to take the alert tactics from
        """
        if alert_description_format is not None:
            pulumi.set(__self__, "alert_description_format", alert_description_format)
        if alert_display_name_format is not None:
            pulumi.set(__self__, "alert_display_name_format", alert_display_name_format)
        if alert_dynamic_properties is not None:
            pulumi.set(__self__, "alert_dynamic_properties", alert_dynamic_properties)
        if alert_severity_column_name is not None:
            pulumi.set(__self__, "alert_severity_column_name", alert_severity_column_name)
        if alert_tactics_column_name is not None:
            pulumi.set(__self__, "alert_tactics_column_name", alert_tactics_column_name)

    @_builtins.property
    @pulumi.getter(name="alertDescriptionFormat")
    def alert_description_format(self) -> Optional[_builtins.str]:
        """
        the format containing columns name(s) to override the alert description
        """
        return pulumi.get(self, "alert_description_format")

    @_builtins.property
    @pulumi.getter(name="alertDisplayNameFormat")
    def alert_display_name_format(self) -> Optional[_builtins.str]:
        """
        the format containing columns name(s) to override the alert name
        """
        return pulumi.get(self, "alert_display_name_format")

    @_builtins.property
    @pulumi.getter(name="alertDynamicProperties")
    def alert_dynamic_properties(self) -> Optional[Sequence['outputs.AlertPropertyMappingResponse']]:
        """
        List of additional dynamic properties to override
        """
        return pulumi.get(self, "alert_dynamic_properties")

    @_builtins.property
    @pulumi.getter(name="alertSeverityColumnName")
    def alert_severity_column_name(self) -> Optional[_builtins.str]:
        """
        the column name to take the alert severity from
        """
        return pulumi.get(self, "alert_severity_column_name")

    @_builtins.property
    @pulumi.getter(name="alertTacticsColumnName")
    def alert_tactics_column_name(self) -> Optional[_builtins.str]:
        """
        the column name to take the alert tactics from
        """
        return pulumi.get(self, "alert_tactics_column_name")


@pulumi.output_type
class AlertPropertyMappingResponse(dict):
    """
    A single alert property mapping to override
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertProperty":
            suggest = "alert_property"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertPropertyMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertPropertyMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertPropertyMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_property: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        A single alert property mapping to override
        :param _builtins.str alert_property: The V3 alert property
        :param _builtins.str value: the column name to use to override this property
        """
        if alert_property is not None:
            pulumi.set(__self__, "alert_property", alert_property)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="alertProperty")
    def alert_property(self) -> Optional[_builtins.str]:
        """
        The V3 alert property
        """
        return pulumi.get(self, "alert_property")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        the column name to use to override this property
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertsDataTypeOfDataConnectorResponse(dict):
    """
    Alerts data type for data connectors.
    """
    def __init__(__self__, *,
                 alerts: Optional['outputs.DataConnectorDataTypeCommonResponse'] = None):
        """
        Alerts data type for data connectors.
        :param 'DataConnectorDataTypeCommonResponse' alerts: Alerts data type connection.
        """
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional['outputs.DataConnectorDataTypeCommonResponse']:
        """
        Alerts data type connection.
        """
        return pulumi.get(self, "alerts")


@pulumi.output_type
class AnomalyTimelineItemResponse(dict):
    """
    Represents anomaly timeline item.
    """
    def __init__(__self__, *,
                 azure_resource_id: _builtins.str,
                 display_name: _builtins.str,
                 end_time_utc: _builtins.str,
                 kind: _builtins.str,
                 start_time_utc: _builtins.str,
                 time_generated: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 intent: Optional[_builtins.str] = None,
                 product_name: Optional[_builtins.str] = None,
                 reasons: Optional[Sequence[_builtins.str]] = None,
                 techniques: Optional[Sequence[_builtins.str]] = None,
                 vendor: Optional[_builtins.str] = None):
        """
        Represents anomaly timeline item.
        :param _builtins.str azure_resource_id: The anomaly azure resource id.
        :param _builtins.str display_name: The anomaly name.
        :param _builtins.str end_time_utc: The anomaly end time.
        :param _builtins.str kind: The entity query kind
               Expected value is 'Anomaly'.
        :param _builtins.str start_time_utc: The anomaly start time.
        :param _builtins.str time_generated: The anomaly generated time.
        :param _builtins.str description: The anomaly description.
        :param _builtins.str intent: The intent of the anomaly.
        :param _builtins.str product_name: The anomaly product name.
        :param Sequence[_builtins.str] reasons: The reasons that cause the anomaly.
        :param Sequence[_builtins.str] techniques: The techniques of the anomaly.
        :param _builtins.str vendor: The name of the anomaly vendor.
        """
        pulumi.set(__self__, "azure_resource_id", azure_resource_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "end_time_utc", end_time_utc)
        pulumi.set(__self__, "kind", 'Anomaly')
        pulumi.set(__self__, "start_time_utc", start_time_utc)
        pulumi.set(__self__, "time_generated", time_generated)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if intent is not None:
            pulumi.set(__self__, "intent", intent)
        if product_name is not None:
            pulumi.set(__self__, "product_name", product_name)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if techniques is not None:
            pulumi.set(__self__, "techniques", techniques)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @_builtins.property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> _builtins.str:
        """
        The anomaly azure resource id.
        """
        return pulumi.get(self, "azure_resource_id")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The anomaly name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> _builtins.str:
        """
        The anomaly end time.
        """
        return pulumi.get(self, "end_time_utc")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The entity query kind
        Expected value is 'Anomaly'.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> _builtins.str:
        """
        The anomaly start time.
        """
        return pulumi.get(self, "start_time_utc")

    @_builtins.property
    @pulumi.getter(name="timeGenerated")
    def time_generated(self) -> _builtins.str:
        """
        The anomaly generated time.
        """
        return pulumi.get(self, "time_generated")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The anomaly description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def intent(self) -> Optional[_builtins.str]:
        """
        The intent of the anomaly.
        """
        return pulumi.get(self, "intent")

    @_builtins.property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[_builtins.str]:
        """
        The anomaly product name.
        """
        return pulumi.get(self, "product_name")

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[Sequence[_builtins.str]]:
        """
        The reasons that cause the anomaly.
        """
        return pulumi.get(self, "reasons")

    @_builtins.property
    @pulumi.getter
    def techniques(self) -> Optional[Sequence[_builtins.str]]:
        """
        The techniques of the anomaly.
        """
        return pulumi.get(self, "techniques")

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> Optional[_builtins.str]:
        """
        The name of the anomaly vendor.
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class ApiKeyAuthModelResponse(dict):
    """
    Model for authentication with the API Key. Will result in additional header on the request (default behavior) to the remote server: 'ApiKeyName: ApiKeyIdentifier ApiKey'. If 'IsApiKeyInPostPayload' is true it will send it in the body of the request and not the header.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "apiKeyName":
            suggest = "api_key_name"
        elif key == "apiKeyIdentifier":
            suggest = "api_key_identifier"
        elif key == "isApiKeyInPostPayload":
            suggest = "is_api_key_in_post_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApiKeyAuthModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApiKeyAuthModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApiKeyAuthModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 api_key_name: _builtins.str,
                 type: _builtins.str,
                 api_key_identifier: Optional[_builtins.str] = None,
                 is_api_key_in_post_payload: Optional[_builtins.bool] = None):
        """
        Model for authentication with the API Key. Will result in additional header on the request (default behavior) to the remote server: 'ApiKeyName: ApiKeyIdentifier ApiKey'. If 'IsApiKeyInPostPayload' is true it will send it in the body of the request and not the header.
        :param _builtins.str api_key: API Key for the user secret key credential
        :param _builtins.str api_key_name: API Key name
        :param _builtins.str type: Type of paging
               Expected value is 'APIKey'.
        :param _builtins.str api_key_identifier: API Key Identifier
        :param _builtins.bool is_api_key_in_post_payload: Flag to indicate if API key is set in HTTP POST payload
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_key_name", api_key_name)
        pulumi.set(__self__, "type", 'APIKey')
        if api_key_identifier is not None:
            pulumi.set(__self__, "api_key_identifier", api_key_identifier)
        if is_api_key_in_post_payload is not None:
            pulumi.set(__self__, "is_api_key_in_post_payload", is_api_key_in_post_payload)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        API Key for the user secret key credential
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="apiKeyName")
    def api_key_name(self) -> _builtins.str:
        """
        API Key name
        """
        return pulumi.get(self, "api_key_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of paging
        Expected value is 'APIKey'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="apiKeyIdentifier")
    def api_key_identifier(self) -> Optional[_builtins.str]:
        """
        API Key Identifier
        """
        return pulumi.get(self, "api_key_identifier")

    @_builtins.property
    @pulumi.getter(name="isApiKeyInPostPayload")
    def is_api_key_in_post_payload(self) -> Optional[_builtins.bool]:
        """
        Flag to indicate if API key is set in HTTP POST payload
        """
        return pulumi.get(self, "is_api_key_in_post_payload")


@pulumi.output_type
class AssignmentItemResponse(dict):
    """
    An entity describing a content item.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssignmentItemResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssignmentItemResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssignmentItemResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: Optional[_builtins.str] = None):
        """
        An entity describing a content item.
        :param _builtins.str resource_id: The resource id of the content item
        """
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        """
        The resource id of the content item
        """
        return pulumi.get(self, "resource_id")


@pulumi.output_type
class AutomationRuleAddIncidentTaskActionResponse(dict):
    """
    Describes an automation rule action to add a task to an incident
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "actionConfiguration":
            suggest = "action_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleAddIncidentTaskActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleAddIncidentTaskActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleAddIncidentTaskActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: _builtins.str,
                 order: _builtins.int,
                 action_configuration: Optional['outputs.AddIncidentTaskActionPropertiesResponse'] = None):
        """
        Describes an automation rule action to add a task to an incident
        :param _builtins.str action_type: The type of the automation rule action.
               Expected value is 'AddIncidentTask'.
        :param 'AddIncidentTaskActionPropertiesResponse' action_configuration: Describes an automation rule action to add a task to an incident.
        """
        pulumi.set(__self__, "action_type", 'AddIncidentTask')
        pulumi.set(__self__, "order", order)
        if action_configuration is not None:
            pulumi.set(__self__, "action_configuration", action_configuration)

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> _builtins.str:
        """
        The type of the automation rule action.
        Expected value is 'AddIncidentTask'.
        """
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.int:
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional['outputs.AddIncidentTaskActionPropertiesResponse']:
        """
        Describes an automation rule action to add a task to an incident.
        """
        return pulumi.get(self, "action_configuration")


@pulumi.output_type
class AutomationRuleBooleanConditionResponse(dict):
    """
    Describes an automation rule condition with boolean operators.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "innerConditions":
            suggest = "inner_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleBooleanConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleBooleanConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleBooleanConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inner_conditions: Optional[Sequence[Any]] = None,
                 operator: Optional[_builtins.str] = None):
        """
        Describes an automation rule condition with boolean operators.
        :param _builtins.str operator: Describes a boolean condition operator.
        """
        if inner_conditions is not None:
            pulumi.set(__self__, "inner_conditions", inner_conditions)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="innerConditions")
    def inner_conditions(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "inner_conditions")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Describes a boolean condition operator.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class AutomationRuleModifyPropertiesActionResponse(dict):
    """
    Describes an automation rule action to modify an object's properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "actionConfiguration":
            suggest = "action_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleModifyPropertiesActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleModifyPropertiesActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleModifyPropertiesActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: _builtins.str,
                 order: _builtins.int,
                 action_configuration: Optional['outputs.IncidentPropertiesActionResponse'] = None):
        """
        Describes an automation rule action to modify an object's properties
        :param _builtins.str action_type: The type of the automation rule action.
               Expected value is 'ModifyProperties'.
        """
        pulumi.set(__self__, "action_type", 'ModifyProperties')
        pulumi.set(__self__, "order", order)
        if action_configuration is not None:
            pulumi.set(__self__, "action_configuration", action_configuration)

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> _builtins.str:
        """
        The type of the automation rule action.
        Expected value is 'ModifyProperties'.
        """
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.int:
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional['outputs.IncidentPropertiesActionResponse']:
        return pulumi.get(self, "action_configuration")


@pulumi.output_type
class AutomationRulePropertyArrayChangedValuesConditionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arrayType":
            suggest = "array_type"
        elif key == "changeType":
            suggest = "change_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRulePropertyArrayChangedValuesConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRulePropertyArrayChangedValuesConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRulePropertyArrayChangedValuesConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 array_type: Optional[_builtins.str] = None,
                 change_type: Optional[_builtins.str] = None):
        if array_type is not None:
            pulumi.set(__self__, "array_type", array_type)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)

    @_builtins.property
    @pulumi.getter(name="arrayType")
    def array_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "array_type")

    @_builtins.property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "change_type")


@pulumi.output_type
class AutomationRulePropertyArrayValuesConditionResponse(dict):
    """
    Describes an automation rule condition on array properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arrayConditionType":
            suggest = "array_condition_type"
        elif key == "arrayType":
            suggest = "array_type"
        elif key == "itemConditions":
            suggest = "item_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRulePropertyArrayValuesConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRulePropertyArrayValuesConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRulePropertyArrayValuesConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 array_condition_type: Optional[_builtins.str] = None,
                 array_type: Optional[_builtins.str] = None,
                 item_conditions: Optional[Sequence[Any]] = None):
        """
        Describes an automation rule condition on array properties.
        :param _builtins.str array_condition_type: Describes an array condition evaluation type.
        :param _builtins.str array_type: Describes an array condition evaluated array type.
        """
        if array_condition_type is not None:
            pulumi.set(__self__, "array_condition_type", array_condition_type)
        if array_type is not None:
            pulumi.set(__self__, "array_type", array_type)
        if item_conditions is not None:
            pulumi.set(__self__, "item_conditions", item_conditions)

    @_builtins.property
    @pulumi.getter(name="arrayConditionType")
    def array_condition_type(self) -> Optional[_builtins.str]:
        """
        Describes an array condition evaluation type.
        """
        return pulumi.get(self, "array_condition_type")

    @_builtins.property
    @pulumi.getter(name="arrayType")
    def array_type(self) -> Optional[_builtins.str]:
        """
        Describes an array condition evaluated array type.
        """
        return pulumi.get(self, "array_type")

    @_builtins.property
    @pulumi.getter(name="itemConditions")
    def item_conditions(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "item_conditions")


@pulumi.output_type
class AutomationRulePropertyValuesChangedConditionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changeType":
            suggest = "change_type"
        elif key == "propertyName":
            suggest = "property_name"
        elif key == "propertyValues":
            suggest = "property_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRulePropertyValuesChangedConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRulePropertyValuesChangedConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRulePropertyValuesChangedConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 change_type: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 property_name: Optional[_builtins.str] = None,
                 property_values: Optional[Sequence[_builtins.str]] = None):
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if property_values is not None:
            pulumi.set(__self__, "property_values", property_values)

    @_builtins.property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "change_type")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "property_name")

    @_builtins.property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "property_values")


@pulumi.output_type
class AutomationRulePropertyValuesConditionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertyName":
            suggest = "property_name"
        elif key == "propertyValues":
            suggest = "property_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRulePropertyValuesConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRulePropertyValuesConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRulePropertyValuesConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: Optional[_builtins.str] = None,
                 property_name: Optional[_builtins.str] = None,
                 property_values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str property_name: The property to evaluate in an automation rule property condition.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if property_values is not None:
            pulumi.set(__self__, "property_values", property_values)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[_builtins.str]:
        """
        The property to evaluate in an automation rule property condition.
        """
        return pulumi.get(self, "property_name")

    @_builtins.property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "property_values")


@pulumi.output_type
class AutomationRuleRunPlaybookActionResponse(dict):
    """
    Describes an automation rule action to run a playbook
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "actionConfiguration":
            suggest = "action_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleRunPlaybookActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleRunPlaybookActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleRunPlaybookActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: _builtins.str,
                 order: _builtins.int,
                 action_configuration: Optional['outputs.PlaybookActionPropertiesResponse'] = None):
        """
        Describes an automation rule action to run a playbook
        :param _builtins.str action_type: The type of the automation rule action.
               Expected value is 'RunPlaybook'.
        """
        pulumi.set(__self__, "action_type", 'RunPlaybook')
        pulumi.set(__self__, "order", order)
        if action_configuration is not None:
            pulumi.set(__self__, "action_configuration", action_configuration)

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> _builtins.str:
        """
        The type of the automation rule action.
        Expected value is 'RunPlaybook'.
        """
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.int:
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional['outputs.PlaybookActionPropertiesResponse']:
        return pulumi.get(self, "action_configuration")


@pulumi.output_type
class AutomationRuleTriggeringLogicResponse(dict):
    """
    Describes automation rule triggering logic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "triggersOn":
            suggest = "triggers_on"
        elif key == "triggersWhen":
            suggest = "triggers_when"
        elif key == "expirationTimeUtc":
            suggest = "expiration_time_utc"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationRuleTriggeringLogicResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationRuleTriggeringLogicResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationRuleTriggeringLogicResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: _builtins.bool,
                 triggers_on: _builtins.str,
                 triggers_when: _builtins.str,
                 conditions: Optional[Sequence[Any]] = None,
                 expiration_time_utc: Optional[_builtins.str] = None):
        """
        Describes automation rule triggering logic.
        :param _builtins.bool is_enabled: Determines whether the automation rule is enabled or disabled.
        :param Sequence[Union['BooleanConditionPropertiesResponse', 'PropertyArrayChangedConditionPropertiesResponse', 'PropertyArrayConditionPropertiesResponse', 'PropertyChangedConditionPropertiesResponse', 'PropertyConditionPropertiesResponse']] conditions: The conditions to evaluate to determine if the automation rule should be triggered on a given object.
        :param _builtins.str expiration_time_utc: Determines when the automation rule should automatically expire and be disabled.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "triggers_on", triggers_on)
        pulumi.set(__self__, "triggers_when", triggers_when)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if expiration_time_utc is not None:
            pulumi.set(__self__, "expiration_time_utc", expiration_time_utc)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        Determines whether the automation rule is enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @_builtins.property
    @pulumi.getter(name="triggersOn")
    def triggers_on(self) -> _builtins.str:
        return pulumi.get(self, "triggers_on")

    @_builtins.property
    @pulumi.getter(name="triggersWhen")
    def triggers_when(self) -> _builtins.str:
        return pulumi.get(self, "triggers_when")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence[Any]]:
        """
        The conditions to evaluate to determine if the automation rule should be triggered on a given object.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter(name="expirationTimeUtc")
    def expiration_time_utc(self) -> Optional[_builtins.str]:
        """
        Determines when the automation rule should automatically expire and be disabled.
        """
        return pulumi.get(self, "expiration_time_utc")


@pulumi.output_type
class AwsCloudTrailDataConnectorDataTypesResponse(dict):
    """
    The available data types for Amazon Web Services CloudTrail data connector.
    """
    def __init__(__self__, *,
                 logs: Optional['outputs.AwsCloudTrailDataConnectorDataTypesResponseLogs'] = None):
        """
        The available data types for Amazon Web Services CloudTrail data connector.
        :param 'AwsCloudTrailDataConnectorDataTypesResponseLogs' logs: Logs data type.
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> Optional['outputs.AwsCloudTrailDataConnectorDataTypesResponseLogs']:
        """
        Logs data type.
        """
        return pulumi.get(self, "logs")


@pulumi.output_type
class AwsCloudTrailDataConnectorDataTypesResponseLogs(dict):
    """
    Logs data type.
    """
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        Logs data type.
        :param _builtins.str state: Describe whether this data type connection is enabled or not.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class AzureDevOpsResourceInfoResponse(dict):
    """
    Resources created in Azure DevOps repository.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineId":
            suggest = "pipeline_id"
        elif key == "serviceConnectionId":
            suggest = "service_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureDevOpsResourceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureDevOpsResourceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureDevOpsResourceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_id: Optional[_builtins.str] = None,
                 service_connection_id: Optional[_builtins.str] = None):
        """
        Resources created in Azure DevOps repository.
        :param _builtins.str pipeline_id: Id of the pipeline created for the source-control.
        :param _builtins.str service_connection_id: Id of the service-connection created for the source-control.
        """
        if pipeline_id is not None:
            pulumi.set(__self__, "pipeline_id", pipeline_id)
        if service_connection_id is not None:
            pulumi.set(__self__, "service_connection_id", service_connection_id)

    @_builtins.property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> Optional[_builtins.str]:
        """
        Id of the pipeline created for the source-control.
        """
        return pulumi.get(self, "pipeline_id")

    @_builtins.property
    @pulumi.getter(name="serviceConnectionId")
    def service_connection_id(self) -> Optional[_builtins.str]:
        """
        Id of the service-connection created for the source-control.
        """
        return pulumi.get(self, "service_connection_id")


@pulumi.output_type
class BasicAuthModelResponse(dict):
    """
    Model for API authentication with basic flow - user name + password.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BasicAuthModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BasicAuthModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BasicAuthModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: _builtins.str,
                 type: _builtins.str,
                 user_name: _builtins.str):
        """
        Model for API authentication with basic flow - user name + password.
        :param _builtins.str password: The password
        :param _builtins.str type: Type of paging
               Expected value is 'Basic'.
        :param _builtins.str user_name: The user name.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "type", 'Basic')
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of paging
        Expected value is 'Basic'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        The user name.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class BookmarkTimelineItemResponse(dict):
    """
    Represents bookmark timeline item.
    """
    def __init__(__self__, *,
                 azure_resource_id: _builtins.str,
                 kind: _builtins.str,
                 created_by: Optional['outputs.UserInfoResponse'] = None,
                 display_name: Optional[_builtins.str] = None,
                 end_time_utc: Optional[_builtins.str] = None,
                 event_time: Optional[_builtins.str] = None,
                 labels: Optional[Sequence[_builtins.str]] = None,
                 notes: Optional[_builtins.str] = None,
                 start_time_utc: Optional[_builtins.str] = None):
        """
        Represents bookmark timeline item.
        :param _builtins.str azure_resource_id: The bookmark azure resource id.
        :param _builtins.str kind: The entity query kind
               Expected value is 'Bookmark'.
        :param 'UserInfoResponse' created_by: Describes a user that created the bookmark
        :param _builtins.str display_name: The bookmark display name.
        :param _builtins.str end_time_utc: The bookmark end time.
        :param _builtins.str event_time: The bookmark event time.
        :param Sequence[_builtins.str] labels: List of labels relevant to this bookmark
        :param _builtins.str notes: The notes of the bookmark
        :param _builtins.str start_time_utc: The bookmark start time.
        """
        pulumi.set(__self__, "azure_resource_id", azure_resource_id)
        pulumi.set(__self__, "kind", 'Bookmark')
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if end_time_utc is not None:
            pulumi.set(__self__, "end_time_utc", end_time_utc)
        if event_time is not None:
            pulumi.set(__self__, "event_time", event_time)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if start_time_utc is not None:
            pulumi.set(__self__, "start_time_utc", start_time_utc)

    @_builtins.property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> _builtins.str:
        """
        The bookmark azure resource id.
        """
        return pulumi.get(self, "azure_resource_id")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The entity query kind
        Expected value is 'Bookmark'.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional['outputs.UserInfoResponse']:
        """
        Describes a user that created the bookmark
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The bookmark display name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> Optional[_builtins.str]:
        """
        The bookmark end time.
        """
        return pulumi.get(self, "end_time_utc")

    @_builtins.property
    @pulumi.getter(name="eventTime")
    def event_time(self) -> Optional[_builtins.str]:
        """
        The bookmark event time.
        """
        return pulumi.get(self, "event_time")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of labels relevant to this bookmark
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[_builtins.str]:
        """
        The notes of the bookmark
        """
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> Optional[_builtins.str]:
        """
        The bookmark start time.
        """
        return pulumi.get(self, "start_time_utc")


@pulumi.output_type
class BooleanConditionPropertiesResponse(dict):
    """
    Describes an automation rule condition that applies a boolean operator (e.g AND, OR) to conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"
        elif key == "conditionProperties":
            suggest = "condition_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BooleanConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BooleanConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BooleanConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: _builtins.str,
                 condition_properties: Optional['outputs.AutomationRuleBooleanConditionResponse'] = None):
        """
        Describes an automation rule condition that applies a boolean operator (e.g AND, OR) to conditions
        :param _builtins.str condition_type: 
               Expected value is 'Boolean'.
        :param 'AutomationRuleBooleanConditionResponse' condition_properties: Describes an automation rule condition with boolean operators.
        """
        pulumi.set(__self__, "condition_type", 'Boolean')
        if condition_properties is not None:
            pulumi.set(__self__, "condition_properties", condition_properties)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> _builtins.str:
        """

        Expected value is 'Boolean'.
        """
        return pulumi.get(self, "condition_type")

    @_builtins.property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional['outputs.AutomationRuleBooleanConditionResponse']:
        """
        Describes an automation rule condition with boolean operators.
        """
        return pulumi.get(self, "condition_properties")


@pulumi.output_type
class CcpResponseConfigResponse(dict):
    """
    A custom response configuration for a rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventsJsonPaths":
            suggest = "events_json_paths"
        elif key == "compressionAlgo":
            suggest = "compression_algo"
        elif key == "convertChildPropertiesToArray":
            suggest = "convert_child_properties_to_array"
        elif key == "csvDelimiter":
            suggest = "csv_delimiter"
        elif key == "csvEscape":
            suggest = "csv_escape"
        elif key == "hasCsvBoundary":
            suggest = "has_csv_boundary"
        elif key == "hasCsvHeader":
            suggest = "has_csv_header"
        elif key == "isGzipCompressed":
            suggest = "is_gzip_compressed"
        elif key == "successStatusJsonPath":
            suggest = "success_status_json_path"
        elif key == "successStatusValue":
            suggest = "success_status_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CcpResponseConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CcpResponseConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CcpResponseConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 events_json_paths: Sequence[_builtins.str],
                 compression_algo: Optional[_builtins.str] = None,
                 convert_child_properties_to_array: Optional[_builtins.bool] = None,
                 csv_delimiter: Optional[_builtins.str] = None,
                 csv_escape: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None,
                 has_csv_boundary: Optional[_builtins.bool] = None,
                 has_csv_header: Optional[_builtins.bool] = None,
                 is_gzip_compressed: Optional[_builtins.bool] = None,
                 success_status_json_path: Optional[_builtins.str] = None,
                 success_status_value: Optional[_builtins.str] = None):
        """
        A custom response configuration for a rule.
        :param Sequence[_builtins.str] events_json_paths: The json paths, '$' char is the json root.
        :param _builtins.str compression_algo: The compression algorithm. For Example: 'gzip', 'multi-gzip', 'deflate'.
        :param _builtins.bool convert_child_properties_to_array: The value indicating whether the response isn't an array of events / logs.  By setting this flag to true it means the remote server will response with an object which each property has as a value an array of events / logs.
        :param _builtins.str csv_delimiter: The csv delimiter, in case the response format is CSV.
        :param _builtins.str csv_escape: The character used to escape characters in CSV.
        :param _builtins.str format: The response format. possible values are json,csv,xml
        :param _builtins.bool has_csv_boundary: The value indicating whether the response has CSV boundary in case the response in CSV format.
        :param _builtins.bool has_csv_header: The value indicating whether the response has headers in case the response in CSV format.
        :param _builtins.bool is_gzip_compressed: The value indicating whether the remote server support Gzip and we should expect Gzip response.
        :param _builtins.str success_status_json_path: The value where the status message/code should appear in the response.
        :param _builtins.str success_status_value: The status value.
        """
        pulumi.set(__self__, "events_json_paths", events_json_paths)
        if compression_algo is None:
            compression_algo = 'gzip'
        if compression_algo is not None:
            pulumi.set(__self__, "compression_algo", compression_algo)
        if convert_child_properties_to_array is not None:
            pulumi.set(__self__, "convert_child_properties_to_array", convert_child_properties_to_array)
        if csv_delimiter is not None:
            pulumi.set(__self__, "csv_delimiter", csv_delimiter)
        if csv_escape is None:
            csv_escape = '"'
        if csv_escape is not None:
            pulumi.set(__self__, "csv_escape", csv_escape)
        if format is None:
            format = 'json'
        if format is not None:
            pulumi.set(__self__, "format", format)
        if has_csv_boundary is not None:
            pulumi.set(__self__, "has_csv_boundary", has_csv_boundary)
        if has_csv_header is not None:
            pulumi.set(__self__, "has_csv_header", has_csv_header)
        if is_gzip_compressed is not None:
            pulumi.set(__self__, "is_gzip_compressed", is_gzip_compressed)
        if success_status_json_path is not None:
            pulumi.set(__self__, "success_status_json_path", success_status_json_path)
        if success_status_value is not None:
            pulumi.set(__self__, "success_status_value", success_status_value)

    @_builtins.property
    @pulumi.getter(name="eventsJsonPaths")
    def events_json_paths(self) -> Sequence[_builtins.str]:
        """
        The json paths, '$' char is the json root.
        """
        return pulumi.get(self, "events_json_paths")

    @_builtins.property
    @pulumi.getter(name="compressionAlgo")
    def compression_algo(self) -> Optional[_builtins.str]:
        """
        The compression algorithm. For Example: 'gzip', 'multi-gzip', 'deflate'.
        """
        return pulumi.get(self, "compression_algo")

    @_builtins.property
    @pulumi.getter(name="convertChildPropertiesToArray")
    def convert_child_properties_to_array(self) -> Optional[_builtins.bool]:
        """
        The value indicating whether the response isn't an array of events / logs.  By setting this flag to true it means the remote server will response with an object which each property has as a value an array of events / logs.
        """
        return pulumi.get(self, "convert_child_properties_to_array")

    @_builtins.property
    @pulumi.getter(name="csvDelimiter")
    def csv_delimiter(self) -> Optional[_builtins.str]:
        """
        The csv delimiter, in case the response format is CSV.
        """
        return pulumi.get(self, "csv_delimiter")

    @_builtins.property
    @pulumi.getter(name="csvEscape")
    def csv_escape(self) -> Optional[_builtins.str]:
        """
        The character used to escape characters in CSV.
        """
        return pulumi.get(self, "csv_escape")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        The response format. possible values are json,csv,xml
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="hasCsvBoundary")
    def has_csv_boundary(self) -> Optional[_builtins.bool]:
        """
        The value indicating whether the response has CSV boundary in case the response in CSV format.
        """
        return pulumi.get(self, "has_csv_boundary")

    @_builtins.property
    @pulumi.getter(name="hasCsvHeader")
    def has_csv_header(self) -> Optional[_builtins.bool]:
        """
        The value indicating whether the response has headers in case the response in CSV format.
        """
        return pulumi.get(self, "has_csv_header")

    @_builtins.property
    @pulumi.getter(name="isGzipCompressed")
    def is_gzip_compressed(self) -> Optional[_builtins.bool]:
        """
        The value indicating whether the remote server support Gzip and we should expect Gzip response.
        """
        return pulumi.get(self, "is_gzip_compressed")

    @_builtins.property
    @pulumi.getter(name="successStatusJsonPath")
    def success_status_json_path(self) -> Optional[_builtins.str]:
        """
        The value where the status message/code should appear in the response.
        """
        return pulumi.get(self, "success_status_json_path")

    @_builtins.property
    @pulumi.getter(name="successStatusValue")
    def success_status_value(self) -> Optional[_builtins.str]:
        """
        The status value.
        """
        return pulumi.get(self, "success_status_value")


@pulumi.output_type
class ClientInfoResponse(dict):
    """
    Information on the client (user or application) that made some action
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectId":
            suggest = "object_id"
        elif key == "userPrincipalName":
            suggest = "user_principal_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 object_id: Optional[_builtins.str] = None,
                 user_principal_name: Optional[_builtins.str] = None):
        """
        Information on the client (user or application) that made some action
        :param _builtins.str email: The email of the client.
        :param _builtins.str name: The name of the client.
        :param _builtins.str object_id: The object id of the client.
        :param _builtins.str user_principal_name: The user principal name of the client.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_principal_name is not None:
            pulumi.set(__self__, "user_principal_name", user_principal_name)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The email of the client.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the client.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[_builtins.str]:
        """
        The object id of the client.
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[_builtins.str]:
        """
        The user principal name of the client.
        """
        return pulumi.get(self, "user_principal_name")


@pulumi.output_type
class ConnectivityCriterionResponse(dict):
    """
    The criteria by which we determine whether the connector is connected or not.
    For Example, use a KQL query to check if  the expected data type is flowing).
    """
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: Optional[Sequence[_builtins.str]] = None):
        """
        The criteria by which we determine whether the connector is connected or not.
        For Example, use a KQL query to check if  the expected data type is flowing).
        :param _builtins.str type: Gets or sets the type of connectivity.
        :param Sequence[_builtins.str] value: Gets or sets the queries for checking connectivity.
        """
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Gets or sets the type of connectivity.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[Sequence[_builtins.str]]:
        """
        Gets or sets the queries for checking connectivity.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ConnectorDataTypeResponse(dict):
    """
    The data type which is created by the connector,
    including a query indicated when was the last time that data type was received in the workspace.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastDataReceivedQuery":
            suggest = "last_data_received_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorDataTypeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorDataTypeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorDataTypeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_data_received_query: _builtins.str,
                 name: _builtins.str):
        """
        The data type which is created by the connector,
        including a query indicated when was the last time that data type was received in the workspace.
        :param _builtins.str last_data_received_query: Gets or sets the query to indicate when relevant data was last received in the workspace.
        :param _builtins.str name: Gets or sets the name of the data type to show in the graph.
        """
        pulumi.set(__self__, "last_data_received_query", last_data_received_query)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="lastDataReceivedQuery")
    def last_data_received_query(self) -> _builtins.str:
        """
        Gets or sets the query to indicate when relevant data was last received in the workspace.
        """
        return pulumi.get(self, "last_data_received_query")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Gets or sets the name of the data type to show in the graph.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ConnectorDefinitionsAvailabilityResponse(dict):
    """
    The exposure status of the connector to the customers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isPreview":
            suggest = "is_preview"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorDefinitionsAvailabilityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorDefinitionsAvailabilityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorDefinitionsAvailabilityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_preview: Optional[_builtins.bool] = None,
                 status: Optional[_builtins.int] = None):
        """
        The exposure status of the connector to the customers.
        :param _builtins.bool is_preview: Gets or sets a value indicating whether the connector is preview.
        :param _builtins.int status: The exposure status of the connector to the customers. Available values are 0-4 (0=None, 1=Available, 2=FeatureFlag, 3=Internal).
        """
        if is_preview is not None:
            pulumi.set(__self__, "is_preview", is_preview)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="isPreview")
    def is_preview(self) -> Optional[_builtins.bool]:
        """
        Gets or sets a value indicating whether the connector is preview.
        """
        return pulumi.get(self, "is_preview")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.int]:
        """
        The exposure status of the connector to the customers. Available values are 0-4 (0=None, 1=Available, 2=FeatureFlag, 3=Internal).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ConnectorDefinitionsPermissionsResponse(dict):
    """
    The required Permissions for the connector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceProvider":
            suggest = "resource_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorDefinitionsPermissionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorDefinitionsPermissionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorDefinitionsPermissionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customs: Optional[Sequence['outputs.CustomPermissionDetailsResponse']] = None,
                 licenses: Optional[Sequence[_builtins.str]] = None,
                 resource_provider: Optional[Sequence['outputs.ConnectorDefinitionsResourceProviderResponse']] = None,
                 tenant: Optional[Sequence[_builtins.str]] = None):
        """
        The required Permissions for the connector.
        :param Sequence['CustomPermissionDetailsResponse'] customs: Gets or sets the customs permissions required for the user to create connections.
        :param Sequence[_builtins.str] licenses: Gets or sets the required licenses for the user to create connections.
        :param Sequence['ConnectorDefinitionsResourceProviderResponse'] resource_provider: Gets or sets the resource provider permissions required for the user to create connections.
        :param Sequence[_builtins.str] tenant: Gets or sets the required tenant permissions for the connector.
        """
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if licenses is not None:
            pulumi.set(__self__, "licenses", licenses)
        if resource_provider is not None:
            pulumi.set(__self__, "resource_provider", resource_provider)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @_builtins.property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.CustomPermissionDetailsResponse']]:
        """
        Gets or sets the customs permissions required for the user to create connections.
        """
        return pulumi.get(self, "customs")

    @_builtins.property
    @pulumi.getter
    def licenses(self) -> Optional[Sequence[_builtins.str]]:
        """
        Gets or sets the required licenses for the user to create connections.
        """
        return pulumi.get(self, "licenses")

    @_builtins.property
    @pulumi.getter(name="resourceProvider")
    def resource_provider(self) -> Optional[Sequence['outputs.ConnectorDefinitionsResourceProviderResponse']]:
        """
        Gets or sets the resource provider permissions required for the user to create connections.
        """
        return pulumi.get(self, "resource_provider")

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> Optional[Sequence[_builtins.str]]:
        """
        Gets or sets the required tenant permissions for the connector.
        """
        return pulumi.get(self, "tenant")


@pulumi.output_type
class ConnectorDefinitionsResourceProviderResponse(dict):
    """
    The resource provider details include the required permissions for the user to create connections.
    The user should have the required permissions(Read\\Write, ..) in the specified scope ProviderPermissionsScope against the specified resource provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionsDisplayText":
            suggest = "permissions_display_text"
        elif key == "providerDisplayName":
            suggest = "provider_display_name"
        elif key == "requiredPermissions":
            suggest = "required_permissions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorDefinitionsResourceProviderResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorDefinitionsResourceProviderResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorDefinitionsResourceProviderResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permissions_display_text: _builtins.str,
                 provider: _builtins.str,
                 provider_display_name: _builtins.str,
                 required_permissions: 'outputs.ResourceProviderRequiredPermissionsResponse',
                 scope: _builtins.str):
        """
        The resource provider details include the required permissions for the user to create connections.
        The user should have the required permissions(Read\\Write, ..) in the specified scope ProviderPermissionsScope against the specified resource provider.
        :param _builtins.str permissions_display_text: Gets or sets the permissions description text.
        :param _builtins.str provider: Gets or sets the provider name.
        :param _builtins.str provider_display_name: Gets or sets the permissions provider display name.
        :param 'ResourceProviderRequiredPermissionsResponse' required_permissions: Required permissions for the connector resource provider that define in ResourceProviders.
               For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
        :param _builtins.str scope: The scope on which the user should have permissions, in order to be able to create connections.
        """
        pulumi.set(__self__, "permissions_display_text", permissions_display_text)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "provider_display_name", provider_display_name)
        pulumi.set(__self__, "required_permissions", required_permissions)
        pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter(name="permissionsDisplayText")
    def permissions_display_text(self) -> _builtins.str:
        """
        Gets or sets the permissions description text.
        """
        return pulumi.get(self, "permissions_display_text")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        """
        Gets or sets the provider name.
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="providerDisplayName")
    def provider_display_name(self) -> _builtins.str:
        """
        Gets or sets the permissions provider display name.
        """
        return pulumi.get(self, "provider_display_name")

    @_builtins.property
    @pulumi.getter(name="requiredPermissions")
    def required_permissions(self) -> 'outputs.ResourceProviderRequiredPermissionsResponse':
        """
        Required permissions for the connector resource provider that define in ResourceProviders.
        For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
        """
        return pulumi.get(self, "required_permissions")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        The scope on which the user should have permissions, in order to be able to create connections.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class ContentPathMapResponse(dict):
    """
    The mapping of content type to a repo path.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContentPathMapResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContentPathMapResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContentPathMapResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None):
        """
        The mapping of content type to a repo path.
        :param _builtins.str content_type: Content type.
        :param _builtins.str path: The path to the content.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[_builtins.str]:
        """
        Content type.
        """
        return pulumi.get(self, "content_type")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        The path to the content.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class CustomPermissionDetailsResponse(dict):
    """
    The Custom permissions required for the connector.
    """
    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str):
        """
        The Custom permissions required for the connector.
        :param _builtins.str description: Gets or sets the custom permissions description.
        :param _builtins.str name: Gets or sets the custom permissions name.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Gets or sets the custom permissions description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Gets or sets the custom permissions name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CustomizableConnectionsConfigResponse(dict):
    """
    The UiConfig for 'Customizable' connector definition kind.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateSpecName":
            suggest = "template_spec_name"
        elif key == "templateSpecVersion":
            suggest = "template_spec_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomizableConnectionsConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomizableConnectionsConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomizableConnectionsConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_spec_name: _builtins.str,
                 template_spec_version: _builtins.str):
        """
        The UiConfig for 'Customizable' connector definition kind.
        :param _builtins.str template_spec_name: Gets or sets the template name. The template includes ARM templates that can be created by the connector, usually it will be the dataConnectors ARM templates.
        :param _builtins.str template_spec_version: Gets or sets the template version.
        """
        pulumi.set(__self__, "template_spec_name", template_spec_name)
        pulumi.set(__self__, "template_spec_version", template_spec_version)

    @_builtins.property
    @pulumi.getter(name="templateSpecName")
    def template_spec_name(self) -> _builtins.str:
        """
        Gets or sets the template name. The template includes ARM templates that can be created by the connector, usually it will be the dataConnectors ARM templates.
        """
        return pulumi.get(self, "template_spec_name")

    @_builtins.property
    @pulumi.getter(name="templateSpecVersion")
    def template_spec_version(self) -> _builtins.str:
        """
        Gets or sets the template version.
        """
        return pulumi.get(self, "template_spec_version")


@pulumi.output_type
class CustomizableConnectorUiConfigResponse(dict):
    """
    The UiConfig for 'Customizable' connector definition kind.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectivityCriteria":
            suggest = "connectivity_criteria"
        elif key == "dataTypes":
            suggest = "data_types"
        elif key == "descriptionMarkdown":
            suggest = "description_markdown"
        elif key == "graphQueries":
            suggest = "graph_queries"
        elif key == "instructionSteps":
            suggest = "instruction_steps"
        elif key == "isConnectivityCriteriasMatchSome":
            suggest = "is_connectivity_criterias_match_some"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomizableConnectorUiConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomizableConnectorUiConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomizableConnectorUiConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connectivity_criteria: Sequence['outputs.ConnectivityCriterionResponse'],
                 data_types: Sequence['outputs.ConnectorDataTypeResponse'],
                 description_markdown: _builtins.str,
                 graph_queries: Sequence['outputs.GraphQueryResponse'],
                 instruction_steps: Sequence['outputs.InstructionStepResponse'],
                 permissions: 'outputs.ConnectorDefinitionsPermissionsResponse',
                 publisher: _builtins.str,
                 title: _builtins.str,
                 availability: Optional['outputs.ConnectorDefinitionsAvailabilityResponse'] = None,
                 id: Optional[_builtins.str] = None,
                 is_connectivity_criterias_match_some: Optional[_builtins.bool] = None,
                 logo: Optional[_builtins.str] = None):
        """
        The UiConfig for 'Customizable' connector definition kind.
        :param Sequence['ConnectivityCriterionResponse'] connectivity_criteria: Gets or sets the way the connector checks whether the connector is connected.
        :param Sequence['ConnectorDataTypeResponse'] data_types: Gets or sets the data types to check for last data received.
        :param _builtins.str description_markdown: Gets or sets the connector description in markdown format.
        :param Sequence['GraphQueryResponse'] graph_queries: Gets or sets the graph queries to show the current data volume over time.
        :param Sequence['InstructionStepResponse'] instruction_steps: Gets or sets the instruction steps to enable the connector.
        :param 'ConnectorDefinitionsPermissionsResponse' permissions: The required Permissions for the connector.
        :param _builtins.str publisher: Gets or sets the connector publisher name.
        :param _builtins.str title: Gets or sets the connector blade title.
        :param 'ConnectorDefinitionsAvailabilityResponse' availability: The exposure status of the connector to the customers.
        :param _builtins.str id: Gets or sets custom connector id. optional field.
        :param _builtins.bool is_connectivity_criterias_match_some: Gets or sets a value indicating whether to use 'OR'(SOME) or 'AND' between ConnectivityCriteria items.
        :param _builtins.str logo: Gets or sets the connector logo to be used when displaying the connector within Azure Sentinel's connector's gallery.
               The logo value should be in SVG format.
        """
        pulumi.set(__self__, "connectivity_criteria", connectivity_criteria)
        pulumi.set(__self__, "data_types", data_types)
        pulumi.set(__self__, "description_markdown", description_markdown)
        pulumi.set(__self__, "graph_queries", graph_queries)
        pulumi.set(__self__, "instruction_steps", instruction_steps)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "title", title)
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_connectivity_criterias_match_some is not None:
            pulumi.set(__self__, "is_connectivity_criterias_match_some", is_connectivity_criterias_match_some)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)

    @_builtins.property
    @pulumi.getter(name="connectivityCriteria")
    def connectivity_criteria(self) -> Sequence['outputs.ConnectivityCriterionResponse']:
        """
        Gets or sets the way the connector checks whether the connector is connected.
        """
        return pulumi.get(self, "connectivity_criteria")

    @_builtins.property
    @pulumi.getter(name="dataTypes")
    def data_types(self) -> Sequence['outputs.ConnectorDataTypeResponse']:
        """
        Gets or sets the data types to check for last data received.
        """
        return pulumi.get(self, "data_types")

    @_builtins.property
    @pulumi.getter(name="descriptionMarkdown")
    def description_markdown(self) -> _builtins.str:
        """
        Gets or sets the connector description in markdown format.
        """
        return pulumi.get(self, "description_markdown")

    @_builtins.property
    @pulumi.getter(name="graphQueries")
    def graph_queries(self) -> Sequence['outputs.GraphQueryResponse']:
        """
        Gets or sets the graph queries to show the current data volume over time.
        """
        return pulumi.get(self, "graph_queries")

    @_builtins.property
    @pulumi.getter(name="instructionSteps")
    def instruction_steps(self) -> Sequence['outputs.InstructionStepResponse']:
        """
        Gets or sets the instruction steps to enable the connector.
        """
        return pulumi.get(self, "instruction_steps")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> 'outputs.ConnectorDefinitionsPermissionsResponse':
        """
        The required Permissions for the connector.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def publisher(self) -> _builtins.str:
        """
        Gets or sets the connector publisher name.
        """
        return pulumi.get(self, "publisher")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        Gets or sets the connector blade title.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def availability(self) -> Optional['outputs.ConnectorDefinitionsAvailabilityResponse']:
        """
        The exposure status of the connector to the customers.
        """
        return pulumi.get(self, "availability")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Gets or sets custom connector id. optional field.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isConnectivityCriteriasMatchSome")
    def is_connectivity_criterias_match_some(self) -> Optional[_builtins.bool]:
        """
        Gets or sets a value indicating whether to use 'OR'(SOME) or 'AND' between ConnectivityCriteria items.
        """
        return pulumi.get(self, "is_connectivity_criterias_match_some")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Gets or sets the connector logo to be used when displaying the connector within Azure Sentinel's connector's gallery.
        The logo value should be in SVG format.
        """
        return pulumi.get(self, "logo")


@pulumi.output_type
class DCRConfigurationResponse(dict):
    """
    The configuration of the destination of the data.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataCollectionEndpoint":
            suggest = "data_collection_endpoint"
        elif key == "dataCollectionRuleImmutableId":
            suggest = "data_collection_rule_immutable_id"
        elif key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DCRConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DCRConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DCRConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_collection_endpoint: _builtins.str,
                 data_collection_rule_immutable_id: _builtins.str,
                 stream_name: _builtins.str):
        """
        The configuration of the destination of the data.
        :param _builtins.str data_collection_endpoint: Represents the data collection ingestion endpoint in log analytics.
        :param _builtins.str data_collection_rule_immutable_id: The data collection rule immutable id, the rule defines the transformation and data destination.
        :param _builtins.str stream_name: The stream we are sending the data to.
        """
        pulumi.set(__self__, "data_collection_endpoint", data_collection_endpoint)
        pulumi.set(__self__, "data_collection_rule_immutable_id", data_collection_rule_immutable_id)
        pulumi.set(__self__, "stream_name", stream_name)

    @_builtins.property
    @pulumi.getter(name="dataCollectionEndpoint")
    def data_collection_endpoint(self) -> _builtins.str:
        """
        Represents the data collection ingestion endpoint in log analytics.
        """
        return pulumi.get(self, "data_collection_endpoint")

    @_builtins.property
    @pulumi.getter(name="dataCollectionRuleImmutableId")
    def data_collection_rule_immutable_id(self) -> _builtins.str:
        """
        The data collection rule immutable id, the rule defines the transformation and data destination.
        """
        return pulumi.get(self, "data_collection_rule_immutable_id")

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> _builtins.str:
        """
        The stream we are sending the data to.
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class DataConnectorDataTypeCommonResponse(dict):
    """
    Common field for data type in data connectors.
    """
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        Common field for data type in data connectors.
        :param _builtins.str state: Describe whether this data type connection is enabled or not.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DeploymentInfoResponse(dict):
    """
    Information regarding a deployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentFetchStatus":
            suggest = "deployment_fetch_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment: Optional['outputs.DeploymentResponse'] = None,
                 deployment_fetch_status: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None):
        """
        Information regarding a deployment.
        :param 'DeploymentResponse' deployment: Deployment information.
        :param _builtins.str deployment_fetch_status: Status while fetching the last deployment.
        :param _builtins.str message: Additional details about the deployment that can be shown to the user.
        """
        if deployment is not None:
            pulumi.set(__self__, "deployment", deployment)
        if deployment_fetch_status is not None:
            pulumi.set(__self__, "deployment_fetch_status", deployment_fetch_status)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def deployment(self) -> Optional['outputs.DeploymentResponse']:
        """
        Deployment information.
        """
        return pulumi.get(self, "deployment")

    @_builtins.property
    @pulumi.getter(name="deploymentFetchStatus")
    def deployment_fetch_status(self) -> Optional[_builtins.str]:
        """
        Status while fetching the last deployment.
        """
        return pulumi.get(self, "deployment_fetch_status")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Additional details about the deployment that can be shown to the user.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class DeploymentResponse(dict):
    """
    Description about a deployment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentId":
            suggest = "deployment_id"
        elif key == "deploymentLogsUrl":
            suggest = "deployment_logs_url"
        elif key == "deploymentResult":
            suggest = "deployment_result"
        elif key == "deploymentState":
            suggest = "deployment_state"
        elif key == "deploymentTime":
            suggest = "deployment_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_id: Optional[_builtins.str] = None,
                 deployment_logs_url: Optional[_builtins.str] = None,
                 deployment_result: Optional[_builtins.str] = None,
                 deployment_state: Optional[_builtins.str] = None,
                 deployment_time: Optional[_builtins.str] = None):
        """
        Description about a deployment.
        :param _builtins.str deployment_id: Deployment identifier.
        :param _builtins.str deployment_logs_url: Url to access repository action logs.
        :param _builtins.str deployment_result: The outcome of the deployment.
        :param _builtins.str deployment_state: Current status of the deployment.
        :param _builtins.str deployment_time: The time when the deployment finished.
        """
        if deployment_id is not None:
            pulumi.set(__self__, "deployment_id", deployment_id)
        if deployment_logs_url is not None:
            pulumi.set(__self__, "deployment_logs_url", deployment_logs_url)
        if deployment_result is not None:
            pulumi.set(__self__, "deployment_result", deployment_result)
        if deployment_state is not None:
            pulumi.set(__self__, "deployment_state", deployment_state)
        if deployment_time is not None:
            pulumi.set(__self__, "deployment_time", deployment_time)

    @_builtins.property
    @pulumi.getter(name="deploymentId")
    def deployment_id(self) -> Optional[_builtins.str]:
        """
        Deployment identifier.
        """
        return pulumi.get(self, "deployment_id")

    @_builtins.property
    @pulumi.getter(name="deploymentLogsUrl")
    def deployment_logs_url(self) -> Optional[_builtins.str]:
        """
        Url to access repository action logs.
        """
        return pulumi.get(self, "deployment_logs_url")

    @_builtins.property
    @pulumi.getter(name="deploymentResult")
    def deployment_result(self) -> Optional[_builtins.str]:
        """
        The outcome of the deployment.
        """
        return pulumi.get(self, "deployment_result")

    @_builtins.property
    @pulumi.getter(name="deploymentState")
    def deployment_state(self) -> Optional[_builtins.str]:
        """
        Current status of the deployment.
        """
        return pulumi.get(self, "deployment_state")

    @_builtins.property
    @pulumi.getter(name="deploymentTime")
    def deployment_time(self) -> Optional[_builtins.str]:
        """
        The time when the deployment finished.
        """
        return pulumi.get(self, "deployment_time")


@pulumi.output_type
class EnrichmentDomainWhoisContactResponse(dict):
    """
    An individual contact associated with this domain
    """
    def __init__(__self__, *,
                 city: Optional[_builtins.str] = None,
                 country: Optional[_builtins.str] = None,
                 email: Optional[_builtins.str] = None,
                 fax: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 org: Optional[_builtins.str] = None,
                 phone: Optional[_builtins.str] = None,
                 postal: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 street: Optional[Sequence[_builtins.str]] = None):
        """
        An individual contact associated with this domain
        :param _builtins.str city: The city for this contact
        :param _builtins.str country: The country for this contact
        :param _builtins.str email: The email address for this contact
        :param _builtins.str fax: The fax number for this contact
        :param _builtins.str name: The name of this contact
        :param _builtins.str org: The organization for this contact
        :param _builtins.str phone: The phone number for this contact
        :param _builtins.str postal: The postal code for this contact
        :param _builtins.str state: The state for this contact
        :param Sequence[_builtins.str] street: A list describing the street address for this contact
        """
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if fax is not None:
            pulumi.set(__self__, "fax", fax)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if org is not None:
            pulumi.set(__self__, "org", org)
        if phone is not None:
            pulumi.set(__self__, "phone", phone)
        if postal is not None:
            pulumi.set(__self__, "postal", postal)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if street is not None:
            pulumi.set(__self__, "street", street)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        The city for this contact
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[_builtins.str]:
        """
        The country for this contact
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The email address for this contact
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def fax(self) -> Optional[_builtins.str]:
        """
        The fax number for this contact
        """
        return pulumi.get(self, "fax")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of this contact
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def org(self) -> Optional[_builtins.str]:
        """
        The organization for this contact
        """
        return pulumi.get(self, "org")

    @_builtins.property
    @pulumi.getter
    def phone(self) -> Optional[_builtins.str]:
        """
        The phone number for this contact
        """
        return pulumi.get(self, "phone")

    @_builtins.property
    @pulumi.getter
    def postal(self) -> Optional[_builtins.str]:
        """
        The postal code for this contact
        """
        return pulumi.get(self, "postal")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The state for this contact
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def street(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list describing the street address for this contact
        """
        return pulumi.get(self, "street")


@pulumi.output_type
class EnrichmentDomainWhoisContactsResponse(dict):
    """
    The set of contacts associated with this domain
    """
    def __init__(__self__, *,
                 admin: Optional['outputs.EnrichmentDomainWhoisContactResponse'] = None,
                 billing: Optional['outputs.EnrichmentDomainWhoisContactResponse'] = None,
                 registrant: Optional['outputs.EnrichmentDomainWhoisContactResponse'] = None,
                 tech: Optional['outputs.EnrichmentDomainWhoisContactResponse'] = None):
        """
        The set of contacts associated with this domain
        :param 'EnrichmentDomainWhoisContactResponse' admin: The admin contact for this whois record
        :param 'EnrichmentDomainWhoisContactResponse' billing: The billing contact for this whois record
        :param 'EnrichmentDomainWhoisContactResponse' registrant: The registrant contact for this whois record
        :param 'EnrichmentDomainWhoisContactResponse' tech: The technical contact for this whois record
        """
        if admin is not None:
            pulumi.set(__self__, "admin", admin)
        if billing is not None:
            pulumi.set(__self__, "billing", billing)
        if registrant is not None:
            pulumi.set(__self__, "registrant", registrant)
        if tech is not None:
            pulumi.set(__self__, "tech", tech)

    @_builtins.property
    @pulumi.getter
    def admin(self) -> Optional['outputs.EnrichmentDomainWhoisContactResponse']:
        """
        The admin contact for this whois record
        """
        return pulumi.get(self, "admin")

    @_builtins.property
    @pulumi.getter
    def billing(self) -> Optional['outputs.EnrichmentDomainWhoisContactResponse']:
        """
        The billing contact for this whois record
        """
        return pulumi.get(self, "billing")

    @_builtins.property
    @pulumi.getter
    def registrant(self) -> Optional['outputs.EnrichmentDomainWhoisContactResponse']:
        """
        The registrant contact for this whois record
        """
        return pulumi.get(self, "registrant")

    @_builtins.property
    @pulumi.getter
    def tech(self) -> Optional['outputs.EnrichmentDomainWhoisContactResponse']:
        """
        The technical contact for this whois record
        """
        return pulumi.get(self, "tech")


@pulumi.output_type
class EnrichmentDomainWhoisDetailsResponse(dict):
    """
    The whois record for a given domain
    """
    def __init__(__self__, *,
                 contacts: Optional['outputs.EnrichmentDomainWhoisContactsResponse'] = None,
                 name_servers: Optional[Sequence[_builtins.str]] = None,
                 registrar: Optional['outputs.EnrichmentDomainWhoisRegistrarDetailsResponse'] = None,
                 statuses: Optional[Sequence[_builtins.str]] = None):
        """
        The whois record for a given domain
        :param 'EnrichmentDomainWhoisContactsResponse' contacts: The set of contacts associated with this domain
        :param Sequence[_builtins.str] name_servers: A list of name servers associated with this domain
        :param 'EnrichmentDomainWhoisRegistrarDetailsResponse' registrar: The registrar associated with this domain
        :param Sequence[_builtins.str] statuses: The set of status flags for this whois record
        """
        if contacts is not None:
            pulumi.set(__self__, "contacts", contacts)
        if name_servers is not None:
            pulumi.set(__self__, "name_servers", name_servers)
        if registrar is not None:
            pulumi.set(__self__, "registrar", registrar)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @_builtins.property
    @pulumi.getter
    def contacts(self) -> Optional['outputs.EnrichmentDomainWhoisContactsResponse']:
        """
        The set of contacts associated with this domain
        """
        return pulumi.get(self, "contacts")

    @_builtins.property
    @pulumi.getter(name="nameServers")
    def name_servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of name servers associated with this domain
        """
        return pulumi.get(self, "name_servers")

    @_builtins.property
    @pulumi.getter
    def registrar(self) -> Optional['outputs.EnrichmentDomainWhoisRegistrarDetailsResponse']:
        """
        The registrar associated with this domain
        """
        return pulumi.get(self, "registrar")

    @_builtins.property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of status flags for this whois record
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class EnrichmentDomainWhoisRegistrarDetailsResponse(dict):
    """
    The registrar associated with this domain
    """
    def __init__(__self__, *,
                 abuse_contact_email: Optional[_builtins.str] = None,
                 abuse_contact_phone: Optional[_builtins.str] = None,
                 iana_id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 whois_server: Optional[_builtins.str] = None):
        """
        The registrar associated with this domain
        :param _builtins.str abuse_contact_email: This registrar's abuse contact email
        :param _builtins.str abuse_contact_phone: This registrar's abuse contact phone number
        :param _builtins.str iana_id: This registrar's Internet Assigned Numbers Authority id
        :param _builtins.str name: The name of this registrar
        :param _builtins.str url: This registrar's URL
        :param _builtins.str whois_server: The hostname of this registrar's whois server
        """
        if abuse_contact_email is not None:
            pulumi.set(__self__, "abuse_contact_email", abuse_contact_email)
        if abuse_contact_phone is not None:
            pulumi.set(__self__, "abuse_contact_phone", abuse_contact_phone)
        if iana_id is not None:
            pulumi.set(__self__, "iana_id", iana_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if whois_server is not None:
            pulumi.set(__self__, "whois_server", whois_server)

    @_builtins.property
    @pulumi.getter(name="abuseContactEmail")
    def abuse_contact_email(self) -> Optional[_builtins.str]:
        """
        This registrar's abuse contact email
        """
        return pulumi.get(self, "abuse_contact_email")

    @_builtins.property
    @pulumi.getter(name="abuseContactPhone")
    def abuse_contact_phone(self) -> Optional[_builtins.str]:
        """
        This registrar's abuse contact phone number
        """
        return pulumi.get(self, "abuse_contact_phone")

    @_builtins.property
    @pulumi.getter(name="ianaId")
    def iana_id(self) -> Optional[_builtins.str]:
        """
        This registrar's Internet Assigned Numbers Authority id
        """
        return pulumi.get(self, "iana_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of this registrar
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        This registrar's URL
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="whoisServer")
    def whois_server(self) -> Optional[_builtins.str]:
        """
        The hostname of this registrar's whois server
        """
        return pulumi.get(self, "whois_server")


@pulumi.output_type
class EntityInsightItemResponse(dict):
    """
    Entity insight Item.
    """
    def __init__(__self__, *,
                 chart_query_results: Optional[Sequence['outputs.InsightsTableResultResponse']] = None,
                 query_id: Optional[_builtins.str] = None,
                 query_time_interval: Optional['outputs.EntityInsightItemResponseQueryTimeInterval'] = None,
                 table_query_results: Optional['outputs.InsightsTableResultResponse'] = None):
        """
        Entity insight Item.
        :param Sequence['InsightsTableResultResponse'] chart_query_results: Query results for table insights query.
        :param _builtins.str query_id: The query id of the insight
        :param 'EntityInsightItemResponseQueryTimeInterval' query_time_interval: The Time interval that the query actually executed on.
        :param 'InsightsTableResultResponse' table_query_results: Query results for table insights query.
        """
        if chart_query_results is not None:
            pulumi.set(__self__, "chart_query_results", chart_query_results)
        if query_id is not None:
            pulumi.set(__self__, "query_id", query_id)
        if query_time_interval is not None:
            pulumi.set(__self__, "query_time_interval", query_time_interval)
        if table_query_results is not None:
            pulumi.set(__self__, "table_query_results", table_query_results)

    @_builtins.property
    @pulumi.getter(name="chartQueryResults")
    def chart_query_results(self) -> Optional[Sequence['outputs.InsightsTableResultResponse']]:
        """
        Query results for table insights query.
        """
        return pulumi.get(self, "chart_query_results")

    @_builtins.property
    @pulumi.getter(name="queryId")
    def query_id(self) -> Optional[_builtins.str]:
        """
        The query id of the insight
        """
        return pulumi.get(self, "query_id")

    @_builtins.property
    @pulumi.getter(name="queryTimeInterval")
    def query_time_interval(self) -> Optional['outputs.EntityInsightItemResponseQueryTimeInterval']:
        """
        The Time interval that the query actually executed on.
        """
        return pulumi.get(self, "query_time_interval")

    @_builtins.property
    @pulumi.getter(name="tableQueryResults")
    def table_query_results(self) -> Optional['outputs.InsightsTableResultResponse']:
        """
        Query results for table insights query.
        """
        return pulumi.get(self, "table_query_results")


@pulumi.output_type
class EntityInsightItemResponseQueryTimeInterval(dict):
    """
    The Time interval that the query actually executed on.
    """
    def __init__(__self__, *,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        The Time interval that the query actually executed on.
        :param _builtins.str end_time: Insight query end time
        :param _builtins.str start_time: Insight query start time
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        Insight query end time
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Insight query start time
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class EntityMappingResponse(dict):
    """
    Single entity mapping for the alert rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "fieldMappings":
            suggest = "field_mappings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntityMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntityMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntityMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: Optional[_builtins.str] = None,
                 field_mappings: Optional[Sequence['outputs.FieldMappingResponse']] = None):
        """
        Single entity mapping for the alert rule
        :param _builtins.str entity_type: The V3 type of the mapped entity
        :param Sequence['FieldMappingResponse'] field_mappings: array of field mappings for the given entity mapping
        """
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)

    @_builtins.property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[_builtins.str]:
        """
        The V3 type of the mapped entity
        """
        return pulumi.get(self, "entity_type")

    @_builtins.property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[Sequence['outputs.FieldMappingResponse']]:
        """
        array of field mappings for the given entity mapping
        """
        return pulumi.get(self, "field_mappings")


@pulumi.output_type
class EventGroupingSettingsResponse(dict):
    """
    Event grouping settings property bag.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationKind":
            suggest = "aggregation_kind"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventGroupingSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventGroupingSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventGroupingSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_kind: Optional[_builtins.str] = None):
        """
        Event grouping settings property bag.
        :param _builtins.str aggregation_kind: The event grouping aggregation kinds
        """
        if aggregation_kind is not None:
            pulumi.set(__self__, "aggregation_kind", aggregation_kind)

    @_builtins.property
    @pulumi.getter(name="aggregationKind")
    def aggregation_kind(self) -> Optional[_builtins.str]:
        """
        The event grouping aggregation kinds
        """
        return pulumi.get(self, "aggregation_kind")


@pulumi.output_type
class FieldMappingResponse(dict):
    """
    A single field mapping of the mapped entity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FieldMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FieldMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FieldMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: Optional[_builtins.str] = None,
                 identifier: Optional[_builtins.str] = None):
        """
        A single field mapping of the mapped entity
        :param _builtins.str column_name: the column name to be mapped to the identifier
        :param _builtins.str identifier: the V3 identifier of the entity
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)

    @_builtins.property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[_builtins.str]:
        """
        the column name to be mapped to the identifier
        """
        return pulumi.get(self, "column_name")

    @_builtins.property
    @pulumi.getter
    def identifier(self) -> Optional[_builtins.str]:
        """
        the V3 identifier of the entity
        """
        return pulumi.get(self, "identifier")


@pulumi.output_type
class FileMetadataResponse(dict):
    """
    Represents a file.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteStatus":
            suggest = "delete_status"
        elif key == "fileContentUri":
            suggest = "file_content_uri"
        elif key == "fileFormat":
            suggest = "file_format"
        elif key == "fileName":
            suggest = "file_name"
        elif key == "fileSize":
            suggest = "file_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_status: _builtins.str,
                 file_content_uri: _builtins.str,
                 file_format: Optional[_builtins.str] = None,
                 file_name: Optional[_builtins.str] = None,
                 file_size: Optional[_builtins.int] = None):
        """
        Represents a file.
        :param _builtins.str delete_status: Indicates whether the file was deleted from the storage account.
        :param _builtins.str file_content_uri: A URI with a valid SAS token to allow uploading / downloading the file.
        :param _builtins.str file_format: The format of the file
        :param _builtins.str file_name: The name of the file.
        :param _builtins.int file_size: The size of the file.
        """
        pulumi.set(__self__, "delete_status", delete_status)
        pulumi.set(__self__, "file_content_uri", file_content_uri)
        if file_format is not None:
            pulumi.set(__self__, "file_format", file_format)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if file_size is not None:
            pulumi.set(__self__, "file_size", file_size)

    @_builtins.property
    @pulumi.getter(name="deleteStatus")
    def delete_status(self) -> _builtins.str:
        """
        Indicates whether the file was deleted from the storage account.
        """
        return pulumi.get(self, "delete_status")

    @_builtins.property
    @pulumi.getter(name="fileContentUri")
    def file_content_uri(self) -> _builtins.str:
        """
        A URI with a valid SAS token to allow uploading / downloading the file.
        """
        return pulumi.get(self, "file_content_uri")

    @_builtins.property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[_builtins.str]:
        """
        The format of the file
        """
        return pulumi.get(self, "file_format")

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[_builtins.str]:
        """
        The name of the file.
        """
        return pulumi.get(self, "file_name")

    @_builtins.property
    @pulumi.getter(name="fileSize")
    def file_size(self) -> Optional[_builtins.int]:
        """
        The size of the file.
        """
        return pulumi.get(self, "file_size")


@pulumi.output_type
class GCPAuthModelResponse(dict):
    """
    Model for API authentication for all GCP kind connectors.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectNumber":
            suggest = "project_number"
        elif key == "serviceAccountEmail":
            suggest = "service_account_email"
        elif key == "workloadIdentityProviderId":
            suggest = "workload_identity_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GCPAuthModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GCPAuthModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GCPAuthModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_number: _builtins.str,
                 service_account_email: _builtins.str,
                 type: _builtins.str,
                 workload_identity_provider_id: _builtins.str):
        """
        Model for API authentication for all GCP kind connectors.
        :param _builtins.str project_number: GCP Project Number
        :param _builtins.str service_account_email: GCP Service Account Email
        :param _builtins.str type: Type of paging
               Expected value is 'GCP'.
        :param _builtins.str workload_identity_provider_id: GCP Workload Identity Provider ID
        """
        pulumi.set(__self__, "project_number", project_number)
        pulumi.set(__self__, "service_account_email", service_account_email)
        pulumi.set(__self__, "type", 'GCP')
        pulumi.set(__self__, "workload_identity_provider_id", workload_identity_provider_id)

    @_builtins.property
    @pulumi.getter(name="projectNumber")
    def project_number(self) -> _builtins.str:
        """
        GCP Project Number
        """
        return pulumi.get(self, "project_number")

    @_builtins.property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> _builtins.str:
        """
        GCP Service Account Email
        """
        return pulumi.get(self, "service_account_email")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of paging
        Expected value is 'GCP'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> _builtins.str:
        """
        GCP Workload Identity Provider ID
        """
        return pulumi.get(self, "workload_identity_provider_id")


@pulumi.output_type
class GenericBlobSbsAuthModelResponse(dict):
    """
    Model for API authentication for working with service bus or storage account.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsConfig":
            suggest = "credentials_config"
        elif key == "storageAccountCredentialsConfig":
            suggest = "storage_account_credentials_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenericBlobSbsAuthModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenericBlobSbsAuthModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenericBlobSbsAuthModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 credentials_config: Optional[Mapping[str, _builtins.str]] = None,
                 storage_account_credentials_config: Optional[Mapping[str, _builtins.str]] = None):
        """
        Model for API authentication for working with service bus or storage account.
        :param _builtins.str type: Type of paging
               Expected value is 'ServiceBus'.
        :param Mapping[str, _builtins.str] credentials_config: Credentials for service bus namespace, keyvault uri for access key
        :param Mapping[str, _builtins.str] storage_account_credentials_config: Credentials for storage account, keyvault uri for access key
        """
        pulumi.set(__self__, "type", 'ServiceBus')
        if credentials_config is not None:
            pulumi.set(__self__, "credentials_config", credentials_config)
        if storage_account_credentials_config is not None:
            pulumi.set(__self__, "storage_account_credentials_config", storage_account_credentials_config)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of paging
        Expected value is 'ServiceBus'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="credentialsConfig")
    def credentials_config(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Credentials for service bus namespace, keyvault uri for access key
        """
        return pulumi.get(self, "credentials_config")

    @_builtins.property
    @pulumi.getter(name="storageAccountCredentialsConfig")
    def storage_account_credentials_config(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Credentials for storage account, keyvault uri for access key
        """
        return pulumi.get(self, "storage_account_credentials_config")


@pulumi.output_type
class GetInsightsErrorKindResponse(dict):
    """
    GetInsights Query Errors.
    """
    def __init__(__self__, *,
                 error_message: _builtins.str,
                 kind: _builtins.str,
                 query_id: Optional[_builtins.str] = None):
        """
        GetInsights Query Errors.
        :param _builtins.str error_message: the error message
        :param _builtins.str kind: the query kind
        :param _builtins.str query_id: the query id
        """
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "kind", kind)
        if query_id is not None:
            pulumi.set(__self__, "query_id", query_id)

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> _builtins.str:
        """
        the error message
        """
        return pulumi.get(self, "error_message")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        the query kind
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="queryId")
    def query_id(self) -> Optional[_builtins.str]:
        """
        the query id
        """
        return pulumi.get(self, "query_id")


@pulumi.output_type
class GetInsightsResultsMetadataResponse(dict):
    """
    Get Insights result metadata.
    """
    def __init__(__self__, *,
                 total_count: _builtins.int,
                 errors: Optional[Sequence['outputs.GetInsightsErrorKindResponse']] = None):
        """
        Get Insights result metadata.
        :param _builtins.int total_count: the total items found for the insights request
        :param Sequence['GetInsightsErrorKindResponse'] errors: information about the failed queries
        """
        pulumi.set(__self__, "total_count", total_count)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.int:
        """
        the total items found for the insights request
        """
        return pulumi.get(self, "total_count")

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.GetInsightsErrorKindResponse']]:
        """
        information about the failed queries
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class GitHubAuthModelResponse(dict):
    """
    Model for API authentication for GitHub. For this authentication first we need to approve the Router app (Microsoft Security DevOps) to access the GitHub account, Then we only need the InstallationId to get the access token from https://api.github.com/app/installations/{installId}/access_tokens.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "installationId":
            suggest = "installation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitHubAuthModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitHubAuthModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitHubAuthModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 installation_id: Optional[_builtins.str] = None):
        """
        Model for API authentication for GitHub. For this authentication first we need to approve the Router app (Microsoft Security DevOps) to access the GitHub account, Then we only need the InstallationId to get the access token from https://api.github.com/app/installations/{installId}/access_tokens.
        :param _builtins.str type: Type of paging
               Expected value is 'GitHub'.
        :param _builtins.str installation_id: The GitHubApp auth installation id.
        """
        pulumi.set(__self__, "type", 'GitHub')
        if installation_id is not None:
            pulumi.set(__self__, "installation_id", installation_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of paging
        Expected value is 'GitHub'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="installationId")
    def installation_id(self) -> Optional[_builtins.str]:
        """
        The GitHubApp auth installation id.
        """
        return pulumi.get(self, "installation_id")


@pulumi.output_type
class GitHubResourceInfoResponse(dict):
    """
    Resources created in GitHub repository.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appInstallationId":
            suggest = "app_installation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitHubResourceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitHubResourceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitHubResourceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_installation_id: Optional[_builtins.str] = None):
        """
        Resources created in GitHub repository.
        :param _builtins.str app_installation_id: GitHub application installation id.
        """
        if app_installation_id is not None:
            pulumi.set(__self__, "app_installation_id", app_installation_id)

    @_builtins.property
    @pulumi.getter(name="appInstallationId")
    def app_installation_id(self) -> Optional[_builtins.str]:
        """
        GitHub application installation id.
        """
        return pulumi.get(self, "app_installation_id")


@pulumi.output_type
class GraphQueryResponse(dict):
    """
    The graph query to show the volume of data arriving into the workspace over time.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseQuery":
            suggest = "base_query"
        elif key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GraphQueryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GraphQueryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GraphQueryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_query: _builtins.str,
                 legend: _builtins.str,
                 metric_name: _builtins.str):
        """
        The graph query to show the volume of data arriving into the workspace over time.
        :param _builtins.str base_query: Gets or sets the base query for the graph.
               The base query is wrapped by Sentinel UI infra with a KQL query, that measures the volume over time.
        :param _builtins.str legend: Gets or sets the legend for the graph.
        :param _builtins.str metric_name: Gets or sets the metric name that the query is checking. For example: 'Total data receive'.
        """
        pulumi.set(__self__, "base_query", base_query)
        pulumi.set(__self__, "legend", legend)
        pulumi.set(__self__, "metric_name", metric_name)

    @_builtins.property
    @pulumi.getter(name="baseQuery")
    def base_query(self) -> _builtins.str:
        """
        Gets or sets the base query for the graph.
        The base query is wrapped by Sentinel UI infra with a KQL query, that measures the volume over time.
        """
        return pulumi.get(self, "base_query")

    @_builtins.property
    @pulumi.getter
    def legend(self) -> _builtins.str:
        """
        Gets or sets the legend for the graph.
        """
        return pulumi.get(self, "legend")

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        Gets or sets the metric name that the query is checking. For example: 'Total data receive'.
        """
        return pulumi.get(self, "metric_name")


@pulumi.output_type
class GroupingConfigurationResponse(dict):
    """
    Grouping configuration property bag.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookbackDuration":
            suggest = "lookback_duration"
        elif key == "matchingMethod":
            suggest = "matching_method"
        elif key == "reopenClosedIncident":
            suggest = "reopen_closed_incident"
        elif key == "groupByAlertDetails":
            suggest = "group_by_alert_details"
        elif key == "groupByCustomDetails":
            suggest = "group_by_custom_details"
        elif key == "groupByEntities":
            suggest = "group_by_entities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupingConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupingConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupingConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 lookback_duration: _builtins.str,
                 matching_method: _builtins.str,
                 reopen_closed_incident: _builtins.bool,
                 group_by_alert_details: Optional[Sequence[_builtins.str]] = None,
                 group_by_custom_details: Optional[Sequence[_builtins.str]] = None,
                 group_by_entities: Optional[Sequence[_builtins.str]] = None):
        """
        Grouping configuration property bag.
        :param _builtins.bool enabled: Grouping enabled
        :param _builtins.str lookback_duration: Limit the group to alerts created within the lookback duration (in ISO 8601 duration format)
        :param _builtins.str matching_method: Grouping matching method. When method is Selected at least one of groupByEntities, groupByAlertDetails, groupByCustomDetails must be provided and not empty.
        :param _builtins.bool reopen_closed_incident: Re-open closed matching incidents
        :param Sequence[_builtins.str] group_by_alert_details: A list of alert details to group by (when matchingMethod is Selected)
        :param Sequence[_builtins.str] group_by_custom_details: A list of custom details keys to group by (when matchingMethod is Selected). Only keys defined in the current alert rule may be used.
        :param Sequence[_builtins.str] group_by_entities: A list of entity types to group by (when matchingMethod is Selected). Only entities defined in the current alert rule may be used.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "lookback_duration", lookback_duration)
        pulumi.set(__self__, "matching_method", matching_method)
        pulumi.set(__self__, "reopen_closed_incident", reopen_closed_incident)
        if group_by_alert_details is not None:
            pulumi.set(__self__, "group_by_alert_details", group_by_alert_details)
        if group_by_custom_details is not None:
            pulumi.set(__self__, "group_by_custom_details", group_by_custom_details)
        if group_by_entities is not None:
            pulumi.set(__self__, "group_by_entities", group_by_entities)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Grouping enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="lookbackDuration")
    def lookback_duration(self) -> _builtins.str:
        """
        Limit the group to alerts created within the lookback duration (in ISO 8601 duration format)
        """
        return pulumi.get(self, "lookback_duration")

    @_builtins.property
    @pulumi.getter(name="matchingMethod")
    def matching_method(self) -> _builtins.str:
        """
        Grouping matching method. When method is Selected at least one of groupByEntities, groupByAlertDetails, groupByCustomDetails must be provided and not empty.
        """
        return pulumi.get(self, "matching_method")

    @_builtins.property
    @pulumi.getter(name="reopenClosedIncident")
    def reopen_closed_incident(self) -> _builtins.bool:
        """
        Re-open closed matching incidents
        """
        return pulumi.get(self, "reopen_closed_incident")

    @_builtins.property
    @pulumi.getter(name="groupByAlertDetails")
    def group_by_alert_details(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of alert details to group by (when matchingMethod is Selected)
        """
        return pulumi.get(self, "group_by_alert_details")

    @_builtins.property
    @pulumi.getter(name="groupByCustomDetails")
    def group_by_custom_details(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of custom details keys to group by (when matchingMethod is Selected). Only keys defined in the current alert rule may be used.
        """
        return pulumi.get(self, "group_by_custom_details")

    @_builtins.property
    @pulumi.getter(name="groupByEntities")
    def group_by_entities(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of entity types to group by (when matchingMethod is Selected). Only entities defined in the current alert rule may be used.
        """
        return pulumi.get(self, "group_by_entities")


@pulumi.output_type
class HuntOwnerResponse(dict):
    """
    Describes a user that the hunt is assigned to
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignedTo":
            suggest = "assigned_to"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "ownerType":
            suggest = "owner_type"
        elif key == "userPrincipalName":
            suggest = "user_principal_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HuntOwnerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HuntOwnerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HuntOwnerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assigned_to: Optional[_builtins.str] = None,
                 email: Optional[_builtins.str] = None,
                 object_id: Optional[_builtins.str] = None,
                 owner_type: Optional[_builtins.str] = None,
                 user_principal_name: Optional[_builtins.str] = None):
        """
        Describes a user that the hunt is assigned to
        :param _builtins.str assigned_to: The name of the user the hunt is assigned to.
        :param _builtins.str email: The email of the user the hunt is assigned to.
        :param _builtins.str object_id: The object id of the user the hunt is assigned to.
        :param _builtins.str owner_type: The type of the owner the hunt is assigned to.
        :param _builtins.str user_principal_name: The user principal name of the user the hunt is assigned to.
        """
        if assigned_to is not None:
            pulumi.set(__self__, "assigned_to", assigned_to)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if owner_type is not None:
            pulumi.set(__self__, "owner_type", owner_type)
        if user_principal_name is not None:
            pulumi.set(__self__, "user_principal_name", user_principal_name)

    @_builtins.property
    @pulumi.getter(name="assignedTo")
    def assigned_to(self) -> Optional[_builtins.str]:
        """
        The name of the user the hunt is assigned to.
        """
        return pulumi.get(self, "assigned_to")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The email of the user the hunt is assigned to.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[_builtins.str]:
        """
        The object id of the user the hunt is assigned to.
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="ownerType")
    def owner_type(self) -> Optional[_builtins.str]:
        """
        The type of the owner the hunt is assigned to.
        """
        return pulumi.get(self, "owner_type")

    @_builtins.property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[_builtins.str]:
        """
        The user principal name of the user the hunt is assigned to.
        """
        return pulumi.get(self, "user_principal_name")


@pulumi.output_type
class IncidentAdditionalDataResponse(dict):
    """
    Incident additional data property bag.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertProductNames":
            suggest = "alert_product_names"
        elif key == "alertsCount":
            suggest = "alerts_count"
        elif key == "bookmarksCount":
            suggest = "bookmarks_count"
        elif key == "commentsCount":
            suggest = "comments_count"
        elif key == "providerIncidentUrl":
            suggest = "provider_incident_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentAdditionalDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentAdditionalDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentAdditionalDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_product_names: Sequence[_builtins.str],
                 alerts_count: _builtins.int,
                 bookmarks_count: _builtins.int,
                 comments_count: _builtins.int,
                 provider_incident_url: _builtins.str,
                 tactics: Sequence[_builtins.str]):
        """
        Incident additional data property bag.
        :param Sequence[_builtins.str] alert_product_names: List of product names of alerts in the incident
        :param _builtins.int alerts_count: The number of alerts in the incident
        :param _builtins.int bookmarks_count: The number of bookmarks in the incident
        :param _builtins.int comments_count: The number of comments in the incident
        :param _builtins.str provider_incident_url: The provider incident url to the incident in Microsoft 365 Defender portal
        :param Sequence[_builtins.str] tactics: The tactics associated with incident
        """
        pulumi.set(__self__, "alert_product_names", alert_product_names)
        pulumi.set(__self__, "alerts_count", alerts_count)
        pulumi.set(__self__, "bookmarks_count", bookmarks_count)
        pulumi.set(__self__, "comments_count", comments_count)
        pulumi.set(__self__, "provider_incident_url", provider_incident_url)
        pulumi.set(__self__, "tactics", tactics)

    @_builtins.property
    @pulumi.getter(name="alertProductNames")
    def alert_product_names(self) -> Sequence[_builtins.str]:
        """
        List of product names of alerts in the incident
        """
        return pulumi.get(self, "alert_product_names")

    @_builtins.property
    @pulumi.getter(name="alertsCount")
    def alerts_count(self) -> _builtins.int:
        """
        The number of alerts in the incident
        """
        return pulumi.get(self, "alerts_count")

    @_builtins.property
    @pulumi.getter(name="bookmarksCount")
    def bookmarks_count(self) -> _builtins.int:
        """
        The number of bookmarks in the incident
        """
        return pulumi.get(self, "bookmarks_count")

    @_builtins.property
    @pulumi.getter(name="commentsCount")
    def comments_count(self) -> _builtins.int:
        """
        The number of comments in the incident
        """
        return pulumi.get(self, "comments_count")

    @_builtins.property
    @pulumi.getter(name="providerIncidentUrl")
    def provider_incident_url(self) -> _builtins.str:
        """
        The provider incident url to the incident in Microsoft 365 Defender portal
        """
        return pulumi.get(self, "provider_incident_url")

    @_builtins.property
    @pulumi.getter
    def tactics(self) -> Sequence[_builtins.str]:
        """
        The tactics associated with incident
        """
        return pulumi.get(self, "tactics")


@pulumi.output_type
class IncidentConfigurationResponse(dict):
    """
    Incident Configuration property bag.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createIncident":
            suggest = "create_incident"
        elif key == "groupingConfiguration":
            suggest = "grouping_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_incident: _builtins.bool,
                 grouping_configuration: Optional['outputs.GroupingConfigurationResponse'] = None):
        """
        Incident Configuration property bag.
        :param _builtins.bool create_incident: Create incidents from alerts triggered by this analytics rule
        :param 'GroupingConfigurationResponse' grouping_configuration: Set how the alerts that are triggered by this analytics rule, are grouped into incidents
        """
        pulumi.set(__self__, "create_incident", create_incident)
        if grouping_configuration is not None:
            pulumi.set(__self__, "grouping_configuration", grouping_configuration)

    @_builtins.property
    @pulumi.getter(name="createIncident")
    def create_incident(self) -> _builtins.bool:
        """
        Create incidents from alerts triggered by this analytics rule
        """
        return pulumi.get(self, "create_incident")

    @_builtins.property
    @pulumi.getter(name="groupingConfiguration")
    def grouping_configuration(self) -> Optional['outputs.GroupingConfigurationResponse']:
        """
        Set how the alerts that are triggered by this analytics rule, are grouped into incidents
        """
        return pulumi.get(self, "grouping_configuration")


@pulumi.output_type
class IncidentInfoResponse(dict):
    """
    Describes related incident information for the bookmark
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentId":
            suggest = "incident_id"
        elif key == "relationName":
            suggest = "relation_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_id: Optional[_builtins.str] = None,
                 relation_name: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None,
                 title: Optional[_builtins.str] = None):
        """
        Describes related incident information for the bookmark
        :param _builtins.str incident_id: Incident Id
        :param _builtins.str relation_name: Relation Name
        :param _builtins.str severity: The severity of the incident
        :param _builtins.str title: The title of the incident
        """
        if incident_id is not None:
            pulumi.set(__self__, "incident_id", incident_id)
        if relation_name is not None:
            pulumi.set(__self__, "relation_name", relation_name)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="incidentId")
    def incident_id(self) -> Optional[_builtins.str]:
        """
        Incident Id
        """
        return pulumi.get(self, "incident_id")

    @_builtins.property
    @pulumi.getter(name="relationName")
    def relation_name(self) -> Optional[_builtins.str]:
        """
        Relation Name
        """
        return pulumi.get(self, "relation_name")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        The severity of the incident
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The title of the incident
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class IncidentLabelResponse(dict):
    """
    Represents an incident label
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelName":
            suggest = "label_name"
        elif key == "labelType":
            suggest = "label_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentLabelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentLabelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentLabelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_name: _builtins.str,
                 label_type: _builtins.str):
        """
        Represents an incident label
        :param _builtins.str label_name: The name of the label
        :param _builtins.str label_type: The type of the label
        """
        pulumi.set(__self__, "label_name", label_name)
        pulumi.set(__self__, "label_type", label_type)

    @_builtins.property
    @pulumi.getter(name="labelName")
    def label_name(self) -> _builtins.str:
        """
        The name of the label
        """
        return pulumi.get(self, "label_name")

    @_builtins.property
    @pulumi.getter(name="labelType")
    def label_type(self) -> _builtins.str:
        """
        The type of the label
        """
        return pulumi.get(self, "label_type")


@pulumi.output_type
class IncidentOwnerInfoResponse(dict):
    """
    Information on the user an incident is assigned to
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignedTo":
            suggest = "assigned_to"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "ownerType":
            suggest = "owner_type"
        elif key == "userPrincipalName":
            suggest = "user_principal_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentOwnerInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentOwnerInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentOwnerInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assigned_to: Optional[_builtins.str] = None,
                 email: Optional[_builtins.str] = None,
                 object_id: Optional[_builtins.str] = None,
                 owner_type: Optional[_builtins.str] = None,
                 user_principal_name: Optional[_builtins.str] = None):
        """
        Information on the user an incident is assigned to
        :param _builtins.str assigned_to: The name of the user the incident is assigned to.
        :param _builtins.str email: The email of the user the incident is assigned to.
        :param _builtins.str object_id: The object id of the user the incident is assigned to.
        :param _builtins.str owner_type: The type of the owner the incident is assigned to.
        :param _builtins.str user_principal_name: The user principal name of the user the incident is assigned to.
        """
        if assigned_to is not None:
            pulumi.set(__self__, "assigned_to", assigned_to)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if owner_type is not None:
            pulumi.set(__self__, "owner_type", owner_type)
        if user_principal_name is not None:
            pulumi.set(__self__, "user_principal_name", user_principal_name)

    @_builtins.property
    @pulumi.getter(name="assignedTo")
    def assigned_to(self) -> Optional[_builtins.str]:
        """
        The name of the user the incident is assigned to.
        """
        return pulumi.get(self, "assigned_to")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        The email of the user the incident is assigned to.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[_builtins.str]:
        """
        The object id of the user the incident is assigned to.
        """
        return pulumi.get(self, "object_id")

    @_builtins.property
    @pulumi.getter(name="ownerType")
    def owner_type(self) -> Optional[_builtins.str]:
        """
        The type of the owner the incident is assigned to.
        """
        return pulumi.get(self, "owner_type")

    @_builtins.property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[_builtins.str]:
        """
        The user principal name of the user the incident is assigned to.
        """
        return pulumi.get(self, "user_principal_name")


@pulumi.output_type
class IncidentPropertiesActionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classificationComment":
            suggest = "classification_comment"
        elif key == "classificationReason":
            suggest = "classification_reason"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentPropertiesActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentPropertiesActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentPropertiesActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification: Optional[_builtins.str] = None,
                 classification_comment: Optional[_builtins.str] = None,
                 classification_reason: Optional[_builtins.str] = None,
                 labels: Optional[Sequence['outputs.IncidentLabelResponse']] = None,
                 owner: Optional['outputs.IncidentOwnerInfoResponse'] = None,
                 severity: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str classification: The reason the incident was closed
        :param _builtins.str classification_comment: Describes the reason the incident was closed.
        :param _builtins.str classification_reason: The classification reason the incident was closed with
        :param Sequence['IncidentLabelResponse'] labels: List of labels to add to the incident.
        :param 'IncidentOwnerInfoResponse' owner: Information on the user an incident is assigned to
        :param _builtins.str severity: The severity of the incident
        :param _builtins.str status: The status of the incident
        """
        if classification is not None:
            pulumi.set(__self__, "classification", classification)
        if classification_comment is not None:
            pulumi.set(__self__, "classification_comment", classification_comment)
        if classification_reason is not None:
            pulumi.set(__self__, "classification_reason", classification_reason)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> Optional[_builtins.str]:
        """
        The reason the incident was closed
        """
        return pulumi.get(self, "classification")

    @_builtins.property
    @pulumi.getter(name="classificationComment")
    def classification_comment(self) -> Optional[_builtins.str]:
        """
        Describes the reason the incident was closed.
        """
        return pulumi.get(self, "classification_comment")

    @_builtins.property
    @pulumi.getter(name="classificationReason")
    def classification_reason(self) -> Optional[_builtins.str]:
        """
        The classification reason the incident was closed with
        """
        return pulumi.get(self, "classification_reason")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Sequence['outputs.IncidentLabelResponse']]:
        """
        List of labels to add to the incident.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def owner(self) -> Optional['outputs.IncidentOwnerInfoResponse']:
        """
        Information on the user an incident is assigned to
        """
        return pulumi.get(self, "owner")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        The severity of the incident
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status of the incident
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class InsightsTableResultResponse(dict):
    """
    Query results for table insights query.
    """
    def __init__(__self__, *,
                 columns: Optional[Sequence['outputs.InsightsTableResultResponseColumns']] = None,
                 rows: Optional[Sequence[Sequence[_builtins.str]]] = None):
        """
        Query results for table insights query.
        :param Sequence['InsightsTableResultResponseColumns'] columns: Columns Metadata of the table
        :param Sequence[Sequence[_builtins.str]] rows: Rows data of the table
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if rows is not None:
            pulumi.set(__self__, "rows", rows)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.InsightsTableResultResponseColumns']]:
        """
        Columns Metadata of the table
        """
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def rows(self) -> Optional[Sequence[Sequence[_builtins.str]]]:
        """
        Rows data of the table
        """
        return pulumi.get(self, "rows")


@pulumi.output_type
class InsightsTableResultResponseColumns(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: the name of the colum
        :param _builtins.str type: the type of the colum
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        the name of the colum
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        the type of the colum
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InstructionStepDetailsResponse(dict):
    """
    Instruction step details, to be displayed in the Instructions steps section in the connector's page in Sentinel Portal.
    """
    def __init__(__self__, *,
                 parameters: Any,
                 type: _builtins.str):
        """
        Instruction step details, to be displayed in the Instructions steps section in the connector's page in Sentinel Portal.
        :param Any parameters: Gets or sets the instruction type parameters settings.
        :param _builtins.str type: Gets or sets the instruction type name.
        """
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Any:
        """
        Gets or sets the instruction type parameters settings.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Gets or sets the instruction type name.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InstructionStepResponse(dict):
    """
    Instruction steps to enable the connector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "innerSteps":
            suggest = "inner_steps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstructionStepResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstructionStepResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstructionStepResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 inner_steps: Optional[Sequence['outputs.InstructionStepResponse']] = None,
                 instructions: Optional[Sequence['outputs.InstructionStepDetailsResponse']] = None,
                 title: Optional[_builtins.str] = None):
        """
        Instruction steps to enable the connector.
        :param _builtins.str description: Gets or sets the instruction step description.
        :param Sequence['InstructionStepResponse'] inner_steps: Gets or sets the inner instruction steps details.
               For Example: instruction step 1 might contain inner instruction steps: [instruction step 1.1, instruction step 1.2].
        :param Sequence['InstructionStepDetailsResponse'] instructions: Gets or sets the instruction step details.
        :param _builtins.str title: Gets or sets the instruction step title.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if inner_steps is not None:
            pulumi.set(__self__, "inner_steps", inner_steps)
        if instructions is not None:
            pulumi.set(__self__, "instructions", instructions)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Gets or sets the instruction step description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="innerSteps")
    def inner_steps(self) -> Optional[Sequence['outputs.InstructionStepResponse']]:
        """
        Gets or sets the inner instruction steps details.
        For Example: instruction step 1 might contain inner instruction steps: [instruction step 1.1, instruction step 1.2].
        """
        return pulumi.get(self, "inner_steps")

    @_builtins.property
    @pulumi.getter
    def instructions(self) -> Optional[Sequence['outputs.InstructionStepDetailsResponse']]:
        """
        Gets or sets the instruction step details.
        """
        return pulumi.get(self, "instructions")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Gets or sets the instruction step title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class JwtAuthModelResponse(dict):
    """
    Model for API authentication with JWT. Simple exchange between user name + password to access token.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "userName":
            suggest = "user_name"
        elif key == "isCredentialsInHeaders":
            suggest = "is_credentials_in_headers"
        elif key == "isJsonRequest":
            suggest = "is_json_request"
        elif key == "queryParameters":
            suggest = "query_parameters"
        elif key == "requestTimeoutInSeconds":
            suggest = "request_timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JwtAuthModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JwtAuthModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JwtAuthModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: Mapping[str, _builtins.str],
                 token_endpoint: _builtins.str,
                 type: _builtins.str,
                 user_name: Mapping[str, _builtins.str],
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 is_credentials_in_headers: Optional[_builtins.bool] = None,
                 is_json_request: Optional[_builtins.bool] = None,
                 query_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 request_timeout_in_seconds: Optional[_builtins.int] = None):
        """
        Model for API authentication with JWT. Simple exchange between user name + password to access token.
        :param Mapping[str, _builtins.str] password: The password
        :param _builtins.str token_endpoint: Token endpoint to request JWT
        :param _builtins.str type: Type of paging
               Expected value is 'JwtToken'.
        :param Mapping[str, _builtins.str] user_name: The user name. If user name and password sent in header request we only need to populate the `value` property with the user name (Same as basic auth). If user name and password sent in body request we need to specify the `Key` and `Value`.
        :param Mapping[str, _builtins.str] headers: The custom headers we want to add once we send request to token endpoint.
        :param _builtins.bool is_credentials_in_headers: Flag indicating whether we want to send the user name and password to token endpoint in the headers.
        :param _builtins.bool is_json_request: Flag indicating whether the body request is JSON (header Content-Type = application/json), meaning its a Form URL encoded request (header Content-Type = application/x-www-form-urlencoded).
        :param Mapping[str, _builtins.str] query_parameters: The custom query parameter we want to add once we send request to token endpoint.
        :param _builtins.int request_timeout_in_seconds: Request timeout in seconds.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        pulumi.set(__self__, "type", 'JwtToken')
        pulumi.set(__self__, "user_name", user_name)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if is_credentials_in_headers is not None:
            pulumi.set(__self__, "is_credentials_in_headers", is_credentials_in_headers)
        if is_json_request is None:
            is_json_request = False
        if is_json_request is not None:
            pulumi.set(__self__, "is_json_request", is_json_request)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if request_timeout_in_seconds is None:
            request_timeout_in_seconds = 100
        if request_timeout_in_seconds is not None:
            pulumi.set(__self__, "request_timeout_in_seconds", request_timeout_in_seconds)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Mapping[str, _builtins.str]:
        """
        The password
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> _builtins.str:
        """
        Token endpoint to request JWT
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of paging
        Expected value is 'JwtToken'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Mapping[str, _builtins.str]:
        """
        The user name. If user name and password sent in header request we only need to populate the `value` property with the user name (Same as basic auth). If user name and password sent in body request we need to specify the `Key` and `Value`.
        """
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The custom headers we want to add once we send request to token endpoint.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="isCredentialsInHeaders")
    def is_credentials_in_headers(self) -> Optional[_builtins.bool]:
        """
        Flag indicating whether we want to send the user name and password to token endpoint in the headers.
        """
        return pulumi.get(self, "is_credentials_in_headers")

    @_builtins.property
    @pulumi.getter(name="isJsonRequest")
    def is_json_request(self) -> Optional[_builtins.bool]:
        """
        Flag indicating whether the body request is JSON (header Content-Type = application/json), meaning its a Form URL encoded request (header Content-Type = application/x-www-form-urlencoded).
        """
        return pulumi.get(self, "is_json_request")

    @_builtins.property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The custom query parameter we want to add once we send request to token endpoint.
        """
        return pulumi.get(self, "query_parameters")

    @_builtins.property
    @pulumi.getter(name="requestTimeoutInSeconds")
    def request_timeout_in_seconds(self) -> Optional[_builtins.int]:
        """
        Request timeout in seconds.
        """
        return pulumi.get(self, "request_timeout_in_seconds")


@pulumi.output_type
class LockUserActionResponse(dict):
    """
    Represents lock user action.
    """
    def __init__(__self__, *,
                 kind: _builtins.str,
                 failure_reason: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        Represents lock user action.
        :param _builtins.str kind: The kind of the action
               Expected value is 'LockUser'.
        :param _builtins.str failure_reason: The reason of the failure of the action. Empty if the action is successful.
        :param _builtins.str user: The user to lock
        """
        pulumi.set(__self__, "kind", 'LockUser')
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The kind of the action
        Expected value is 'LockUser'.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[_builtins.str]:
        """
        The reason of the failure of the action. Empty if the action is successful.
        """
        return pulumi.get(self, "failure_reason")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        The user to lock
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class LogResponse(dict):
    """
    Describes a log.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bulkSize":
            suggest = "bulk_size"
        elif key == "ingestionType":
            suggest = "ingestion_type"
        elif key == "scheduleInterval":
            suggest = "schedule_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 bulk_size: Optional[_builtins.int] = None,
                 filters: Optional[Sequence[_builtins.str]] = None,
                 ingestion_type: Optional[_builtins.str] = None,
                 schedule_interval: Optional[_builtins.int] = None,
                 status: Optional[_builtins.str] = None):
        """
        Describes a log.
        :param _builtins.str type: Types of logs and tables.
        :param _builtins.int bulk_size: The bulk size for the log.
        :param Sequence[_builtins.str] filters: The filters for the log.
        :param _builtins.str ingestion_type: Types of ingestion.
        :param _builtins.int schedule_interval: The schedule interval in seconds.
        :param _builtins.str status: Types of log status.
        """
        pulumi.set(__self__, "type", type)
        if bulk_size is not None:
            pulumi.set(__self__, "bulk_size", bulk_size)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if ingestion_type is not None:
            pulumi.set(__self__, "ingestion_type", ingestion_type)
        if schedule_interval is not None:
            pulumi.set(__self__, "schedule_interval", schedule_interval)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Types of logs and tables.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="bulkSize")
    def bulk_size(self) -> Optional[_builtins.int]:
        """
        The bulk size for the log.
        """
        return pulumi.get(self, "bulk_size")

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[Sequence[_builtins.str]]:
        """
        The filters for the log.
        """
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter(name="ingestionType")
    def ingestion_type(self) -> Optional[_builtins.str]:
        """
        Types of ingestion.
        """
        return pulumi.get(self, "ingestion_type")

    @_builtins.property
    @pulumi.getter(name="scheduleInterval")
    def schedule_interval(self) -> Optional[_builtins.int]:
        """
        The schedule interval in seconds.
        """
        return pulumi.get(self, "schedule_interval")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Types of log status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class MCASDataConnectorDataTypesResponse(dict):
    """
    The available data types for MCAS (Microsoft Cloud App Security) data connector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discoveryLogs":
            suggest = "discovery_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MCASDataConnectorDataTypesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MCASDataConnectorDataTypesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MCASDataConnectorDataTypesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alerts: Optional['outputs.DataConnectorDataTypeCommonResponse'] = None,
                 discovery_logs: Optional['outputs.DataConnectorDataTypeCommonResponse'] = None):
        """
        The available data types for MCAS (Microsoft Cloud App Security) data connector.
        :param 'DataConnectorDataTypeCommonResponse' alerts: Alerts data type connection.
        :param 'DataConnectorDataTypeCommonResponse' discovery_logs: Discovery log data type connection.
        """
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if discovery_logs is not None:
            pulumi.set(__self__, "discovery_logs", discovery_logs)

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional['outputs.DataConnectorDataTypeCommonResponse']:
        """
        Alerts data type connection.
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter(name="discoveryLogs")
    def discovery_logs(self) -> Optional['outputs.DataConnectorDataTypeCommonResponse']:
        """
        Discovery log data type connection.
        """
        return pulumi.get(self, "discovery_logs")


@pulumi.output_type
class MSTIDataConnectorDataTypesResponse(dict):
    """
    The available data types for Microsoft Threat Intelligence data connector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "microsoftEmergingThreatFeed":
            suggest = "microsoft_emerging_threat_feed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MSTIDataConnectorDataTypesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MSTIDataConnectorDataTypesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MSTIDataConnectorDataTypesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 microsoft_emerging_threat_feed: 'outputs.MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed'):
        """
        The available data types for Microsoft Threat Intelligence data connector.
        :param 'MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed' microsoft_emerging_threat_feed: Data type for Microsoft Threat Intelligence data connector.
        """
        pulumi.set(__self__, "microsoft_emerging_threat_feed", microsoft_emerging_threat_feed)

    @_builtins.property
    @pulumi.getter(name="microsoftEmergingThreatFeed")
    def microsoft_emerging_threat_feed(self) -> 'outputs.MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed':
        """
        Data type for Microsoft Threat Intelligence data connector.
        """
        return pulumi.get(self, "microsoft_emerging_threat_feed")


@pulumi.output_type
class MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed(dict):
    """
    Data type for Microsoft Threat Intelligence data connector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookbackPeriod":
            suggest = "lookback_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MSTIDataConnectorDataTypesResponseMicrosoftEmergingThreatFeed.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookback_period: _builtins.str,
                 state: Optional[_builtins.str] = None):
        """
        Data type for Microsoft Threat Intelligence data connector.
        :param _builtins.str lookback_period: The lookback period for the feed to be imported. The date-time to begin importing the feed from, for example: 2024-01-01T00:00:00.000Z.
        :param _builtins.str state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "lookback_period", lookback_period)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="lookbackPeriod")
    def lookback_period(self) -> _builtins.str:
        """
        The lookback period for the feed to be imported. The date-time to begin importing the feed from, for example: 2024-01-01T00:00:00.000Z.
        """
        return pulumi.get(self, "lookback_period")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MetadataAuthorResponse(dict):
    """
    Publisher or creator of the content item.
    """
    def __init__(__self__, *,
                 email: Optional[_builtins.str] = None,
                 link: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        Publisher or creator of the content item.
        :param _builtins.str email: Email of author contact
        :param _builtins.str link: Link for author/vendor page
        :param _builtins.str name: Name of the author. Company or person.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        Email of author contact
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def link(self) -> Optional[_builtins.str]:
        """
        Link for author/vendor page
        """
        return pulumi.get(self, "link")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the author. Company or person.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MetadataCategoriesResponse(dict):
    """
    ies for the solution content item
    """
    def __init__(__self__, *,
                 domains: Optional[Sequence[_builtins.str]] = None,
                 verticals: Optional[Sequence[_builtins.str]] = None):
        """
        ies for the solution content item
        :param Sequence[_builtins.str] domains: domain for the solution content item
        :param Sequence[_builtins.str] verticals: Industry verticals for the solution content item
        """
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if verticals is not None:
            pulumi.set(__self__, "verticals", verticals)

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        domain for the solution content item
        """
        return pulumi.get(self, "domains")

    @_builtins.property
    @pulumi.getter
    def verticals(self) -> Optional[Sequence[_builtins.str]]:
        """
        Industry verticals for the solution content item
        """
        return pulumi.get(self, "verticals")


@pulumi.output_type
class MetadataDependenciesResponse(dict):
    """
    Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex dependencies.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentId":
            suggest = "content_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataDependenciesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataDependenciesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataDependenciesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_id: Optional[_builtins.str] = None,
                 criteria: Optional[Sequence['outputs.MetadataDependenciesResponse']] = None,
                 kind: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex dependencies.
        :param _builtins.str content_id: Id of the content item we depend on
        :param Sequence['MetadataDependenciesResponse'] criteria: This is the list of dependencies we must fulfill, according to the AND/OR operator
        :param _builtins.str kind: Type of the content item we depend on
        :param _builtins.str name: Name of the content item
        :param _builtins.str operator: Operator used for list of dependencies in criteria array.
        :param _builtins.str version: Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        """
        if content_id is not None:
            pulumi.set(__self__, "content_id", content_id)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="contentId")
    def content_id(self) -> Optional[_builtins.str]:
        """
        Id of the content item we depend on
        """
        return pulumi.get(self, "content_id")

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[Sequence['outputs.MetadataDependenciesResponse']]:
        """
        This is the list of dependencies we must fulfill, according to the AND/OR operator
        """
        return pulumi.get(self, "criteria")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Type of the content item we depend on
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the content item
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Operator used for list of dependencies in criteria array.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MetadataSourceResponse(dict):
    """
    The original source of the content item, where it comes from.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceId":
            suggest = "source_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 source_id: Optional[_builtins.str] = None):
        """
        The original source of the content item, where it comes from.
        :param _builtins.str kind: Source type of the content
        :param _builtins.str name: Name of the content source.  The repo name, solution name, LA workspace name etc.
        :param _builtins.str source_id: ID of the content source.  The solution ID, workspace ID, etc
        """
        pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        Source type of the content
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the content source.  The repo name, solution name, LA workspace name etc.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[_builtins.str]:
        """
        ID of the content source.  The solution ID, workspace ID, etc
        """
        return pulumi.get(self, "source_id")


@pulumi.output_type
class MetadataSupportResponse(dict):
    """
    Support information for the content item.
    """
    def __init__(__self__, *,
                 tier: _builtins.str,
                 email: Optional[_builtins.str] = None,
                 link: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        Support information for the content item.
        :param _builtins.str tier: Type of support for content item
        :param _builtins.str email: Email of support contact
        :param _builtins.str link: Link for support help, like to support page to open a ticket etc.
        :param _builtins.str name: Name of the support contact. Company or person.
        """
        pulumi.set(__self__, "tier", tier)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def tier(self) -> _builtins.str:
        """
        Type of support for content item
        """
        return pulumi.get(self, "tier")

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[_builtins.str]:
        """
        Email of support contact
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def link(self) -> Optional[_builtins.str]:
        """
        Link for support help, like to support page to open a ticket etc.
        """
        return pulumi.get(self, "link")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the support contact. Company or person.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NoneAuthModelResponse(dict):
    """
    Model for API authentication with no authentication method - public API.
    """
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        Model for API authentication with no authentication method - public API.
        :param _builtins.str type: Type of paging
               Expected value is 'None'.
        """
        pulumi.set(__self__, "type", 'None')

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of paging
        Expected value is 'None'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class OAuthModelResponse(dict):
    """
    Model for API authentication with OAuth2.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "grantType":
            suggest = "grant_type"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "accessTokenPrepend":
            suggest = "access_token_prepend"
        elif key == "authorizationCode":
            suggest = "authorization_code"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "authorizationEndpointHeaders":
            suggest = "authorization_endpoint_headers"
        elif key == "authorizationEndpointQueryParameters":
            suggest = "authorization_endpoint_query_parameters"
        elif key == "isCredentialsInHeaders":
            suggest = "is_credentials_in_headers"
        elif key == "isJwtBearerFlow":
            suggest = "is_jwt_bearer_flow"
        elif key == "redirectUri":
            suggest = "redirect_uri"
        elif key == "tokenEndpointHeaders":
            suggest = "token_endpoint_headers"
        elif key == "tokenEndpointQueryParameters":
            suggest = "token_endpoint_query_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OAuthModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OAuthModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OAuthModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 client_secret: _builtins.str,
                 grant_type: _builtins.str,
                 token_endpoint: _builtins.str,
                 type: _builtins.str,
                 access_token_prepend: Optional[_builtins.str] = None,
                 authorization_code: Optional[_builtins.str] = None,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 authorization_endpoint_headers: Optional[Mapping[str, _builtins.str]] = None,
                 authorization_endpoint_query_parameters: Optional[Mapping[str, _builtins.str]] = None,
                 is_credentials_in_headers: Optional[_builtins.bool] = None,
                 is_jwt_bearer_flow: Optional[_builtins.bool] = None,
                 redirect_uri: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 token_endpoint_headers: Optional[Mapping[str, _builtins.str]] = None,
                 token_endpoint_query_parameters: Optional[Mapping[str, _builtins.str]] = None):
        """
        Model for API authentication with OAuth2.
        :param _builtins.str client_id: The Application (client) ID that the OAuth provider assigned to your app.
        :param _builtins.str client_secret: The Application (client) secret that the OAuth provider assigned to your app.
        :param _builtins.str grant_type: The grant type, usually will be 'authorization code'.
        :param _builtins.str token_endpoint: The token endpoint. Defines the OAuth2 refresh token.
        :param _builtins.str type: Type of paging
               Expected value is 'OAuth2'.
        :param _builtins.str access_token_prepend: Access token prepend. Default is 'Bearer'.
        :param _builtins.str authorization_code: The user's authorization code.
        :param _builtins.str authorization_endpoint: The authorization endpoint.
        :param Mapping[str, _builtins.str] authorization_endpoint_headers: The authorization endpoint headers.
        :param Mapping[str, _builtins.str] authorization_endpoint_query_parameters: The authorization endpoint query parameters.
        :param _builtins.bool is_credentials_in_headers: Indicating whether we want to send the clientId and clientSecret to token endpoint in the headers.
        :param _builtins.bool is_jwt_bearer_flow: A value indicating whether it's a JWT flow.
        :param _builtins.str redirect_uri: The Application redirect url that the user config in the OAuth provider.
        :param _builtins.str scope: The Application (client) Scope that the OAuth provider assigned to your app.
        :param Mapping[str, _builtins.str] token_endpoint_headers: The token endpoint headers.
        :param Mapping[str, _builtins.str] token_endpoint_query_parameters: The token endpoint query parameters.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "grant_type", grant_type)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        pulumi.set(__self__, "type", 'OAuth2')
        if access_token_prepend is not None:
            pulumi.set(__self__, "access_token_prepend", access_token_prepend)
        if authorization_code is not None:
            pulumi.set(__self__, "authorization_code", authorization_code)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if authorization_endpoint_headers is not None:
            pulumi.set(__self__, "authorization_endpoint_headers", authorization_endpoint_headers)
        if authorization_endpoint_query_parameters is not None:
            pulumi.set(__self__, "authorization_endpoint_query_parameters", authorization_endpoint_query_parameters)
        if is_credentials_in_headers is None:
            is_credentials_in_headers = False
        if is_credentials_in_headers is not None:
            pulumi.set(__self__, "is_credentials_in_headers", is_credentials_in_headers)
        if is_jwt_bearer_flow is not None:
            pulumi.set(__self__, "is_jwt_bearer_flow", is_jwt_bearer_flow)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if token_endpoint_headers is not None:
            pulumi.set(__self__, "token_endpoint_headers", token_endpoint_headers)
        if token_endpoint_query_parameters is not None:
            pulumi.set(__self__, "token_endpoint_query_parameters", token_endpoint_query_parameters)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The Application (client) ID that the OAuth provider assigned to your app.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        The Application (client) secret that the OAuth provider assigned to your app.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter(name="grantType")
    def grant_type(self) -> _builtins.str:
        """
        The grant type, usually will be 'authorization code'.
        """
        return pulumi.get(self, "grant_type")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> _builtins.str:
        """
        The token endpoint. Defines the OAuth2 refresh token.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of paging
        Expected value is 'OAuth2'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="accessTokenPrepend")
    def access_token_prepend(self) -> Optional[_builtins.str]:
        """
        Access token prepend. Default is 'Bearer'.
        """
        return pulumi.get(self, "access_token_prepend")

    @_builtins.property
    @pulumi.getter(name="authorizationCode")
    def authorization_code(self) -> Optional[_builtins.str]:
        """
        The user's authorization code.
        """
        return pulumi.get(self, "authorization_code")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The authorization endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpointHeaders")
    def authorization_endpoint_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The authorization endpoint headers.
        """
        return pulumi.get(self, "authorization_endpoint_headers")

    @_builtins.property
    @pulumi.getter(name="authorizationEndpointQueryParameters")
    def authorization_endpoint_query_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The authorization endpoint query parameters.
        """
        return pulumi.get(self, "authorization_endpoint_query_parameters")

    @_builtins.property
    @pulumi.getter(name="isCredentialsInHeaders")
    def is_credentials_in_headers(self) -> Optional[_builtins.bool]:
        """
        Indicating whether we want to send the clientId and clientSecret to token endpoint in the headers.
        """
        return pulumi.get(self, "is_credentials_in_headers")

    @_builtins.property
    @pulumi.getter(name="isJwtBearerFlow")
    def is_jwt_bearer_flow(self) -> Optional[_builtins.bool]:
        """
        A value indicating whether it's a JWT flow.
        """
        return pulumi.get(self, "is_jwt_bearer_flow")

    @_builtins.property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[_builtins.str]:
        """
        The Application redirect url that the user config in the OAuth provider.
        """
        return pulumi.get(self, "redirect_uri")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The Application (client) Scope that the OAuth provider assigned to your app.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="tokenEndpointHeaders")
    def token_endpoint_headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The token endpoint headers.
        """
        return pulumi.get(self, "token_endpoint_headers")

    @_builtins.property
    @pulumi.getter(name="tokenEndpointQueryParameters")
    def token_endpoint_query_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The token endpoint query parameters.
        """
        return pulumi.get(self, "token_endpoint_query_parameters")


@pulumi.output_type
class OfficeDataConnectorDataTypesResponse(dict):
    """
    The available data types for office data connector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sharePoint":
            suggest = "share_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OfficeDataConnectorDataTypesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OfficeDataConnectorDataTypesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OfficeDataConnectorDataTypesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exchange: Optional['outputs.OfficeDataConnectorDataTypesResponseExchange'] = None,
                 share_point: Optional['outputs.OfficeDataConnectorDataTypesResponseSharePoint'] = None,
                 teams: Optional['outputs.OfficeDataConnectorDataTypesResponseTeams'] = None):
        """
        The available data types for office data connector.
        :param 'OfficeDataConnectorDataTypesResponseExchange' exchange: Exchange data type connection.
        :param 'OfficeDataConnectorDataTypesResponseSharePoint' share_point: SharePoint data type connection.
        :param 'OfficeDataConnectorDataTypesResponseTeams' teams: Teams data type connection.
        """
        if exchange is not None:
            pulumi.set(__self__, "exchange", exchange)
        if share_point is not None:
            pulumi.set(__self__, "share_point", share_point)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)

    @_builtins.property
    @pulumi.getter
    def exchange(self) -> Optional['outputs.OfficeDataConnectorDataTypesResponseExchange']:
        """
        Exchange data type connection.
        """
        return pulumi.get(self, "exchange")

    @_builtins.property
    @pulumi.getter(name="sharePoint")
    def share_point(self) -> Optional['outputs.OfficeDataConnectorDataTypesResponseSharePoint']:
        """
        SharePoint data type connection.
        """
        return pulumi.get(self, "share_point")

    @_builtins.property
    @pulumi.getter
    def teams(self) -> Optional['outputs.OfficeDataConnectorDataTypesResponseTeams']:
        """
        Teams data type connection.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class OfficeDataConnectorDataTypesResponseExchange(dict):
    """
    Exchange data type connection.
    """
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        Exchange data type connection.
        :param _builtins.str state: Describe whether this data type connection is enabled or not.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class OfficeDataConnectorDataTypesResponseSharePoint(dict):
    """
    SharePoint data type connection.
    """
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        SharePoint data type connection.
        :param _builtins.str state: Describe whether this data type connection is enabled or not.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class OfficeDataConnectorDataTypesResponseTeams(dict):
    """
    Teams data type connection.
    """
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        Teams data type connection.
        :param _builtins.str state: Describe whether this data type connection is enabled or not.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class OracleAuthModelResponse(dict):
    """
    Model for API authentication for Oracle.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pemFile":
            suggest = "pem_file"
        elif key == "publicFingerprint":
            suggest = "public_fingerprint"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OracleAuthModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OracleAuthModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OracleAuthModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pem_file: _builtins.str,
                 public_fingerprint: _builtins.str,
                 tenant_id: _builtins.str,
                 type: _builtins.str,
                 user_id: _builtins.str):
        """
        Model for API authentication for Oracle.
        :param _builtins.str pem_file: Content of the PRM file
        :param _builtins.str public_fingerprint: Public Fingerprint
        :param _builtins.str tenant_id: Oracle tenant ID
        :param _builtins.str type: Type of paging
               Expected value is 'Oracle'.
        :param _builtins.str user_id: Oracle user ID
        """
        pulumi.set(__self__, "pem_file", pem_file)
        pulumi.set(__self__, "public_fingerprint", public_fingerprint)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", 'Oracle')
        pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="pemFile")
    def pem_file(self) -> _builtins.str:
        """
        Content of the PRM file
        """
        return pulumi.get(self, "pem_file")

    @_builtins.property
    @pulumi.getter(name="publicFingerprint")
    def public_fingerprint(self) -> _builtins.str:
        """
        Public Fingerprint
        """
        return pulumi.get(self, "public_fingerprint")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        Oracle tenant ID
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of paging
        Expected value is 'Oracle'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        Oracle user ID
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class PlaybookActionPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logicAppResourceId":
            suggest = "logic_app_resource_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PlaybookActionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PlaybookActionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PlaybookActionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logic_app_resource_id: _builtins.str,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str logic_app_resource_id: The resource id of the playbook resource.
        :param _builtins.str tenant_id: The tenant id of the playbook resource.
        """
        pulumi.set(__self__, "logic_app_resource_id", logic_app_resource_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="logicAppResourceId")
    def logic_app_resource_id(self) -> _builtins.str:
        """
        The resource id of the playbook resource.
        """
        return pulumi.get(self, "logic_app_resource_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The tenant id of the playbook resource.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class PremiumMdtiDataConnectorDataTypesResponse(dict):
    """
    The available data types for Premium Microsoft Defender for Threat Intelligence data connector.
    """
    def __init__(__self__, *,
                 connector: 'outputs.PremiumMdtiDataConnectorDataTypesResponseConnector'):
        """
        The available data types for Premium Microsoft Defender for Threat Intelligence data connector.
        :param 'PremiumMdtiDataConnectorDataTypesResponseConnector' connector: Data type for Premium Microsoft Defender for Threat Intelligence data connector.
        """
        pulumi.set(__self__, "connector", connector)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> 'outputs.PremiumMdtiDataConnectorDataTypesResponseConnector':
        """
        Data type for Premium Microsoft Defender for Threat Intelligence data connector.
        """
        return pulumi.get(self, "connector")


@pulumi.output_type
class PremiumMdtiDataConnectorDataTypesResponseConnector(dict):
    """
    Data type for Premium Microsoft Defender for Threat Intelligence data connector.
    """
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        Data type for Premium Microsoft Defender for Threat Intelligence data connector.
        :param _builtins.str state: Describe whether this data type connection is enabled or not.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class PropertyArrayChangedConditionPropertiesResponse(dict):
    """
    Describes an automation rule condition that evaluates an array property's value change
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"
        elif key == "conditionProperties":
            suggest = "condition_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyArrayChangedConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyArrayChangedConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyArrayChangedConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: _builtins.str,
                 condition_properties: Optional['outputs.AutomationRulePropertyArrayChangedValuesConditionResponse'] = None):
        """
        Describes an automation rule condition that evaluates an array property's value change
        :param _builtins.str condition_type: 
               Expected value is 'PropertyArrayChanged'.
        """
        pulumi.set(__self__, "condition_type", 'PropertyArrayChanged')
        if condition_properties is not None:
            pulumi.set(__self__, "condition_properties", condition_properties)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> _builtins.str:
        """

        Expected value is 'PropertyArrayChanged'.
        """
        return pulumi.get(self, "condition_type")

    @_builtins.property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional['outputs.AutomationRulePropertyArrayChangedValuesConditionResponse']:
        return pulumi.get(self, "condition_properties")


@pulumi.output_type
class PropertyArrayConditionPropertiesResponse(dict):
    """
    Describes an automation rule condition that evaluates an array property's value
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"
        elif key == "conditionProperties":
            suggest = "condition_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyArrayConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyArrayConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyArrayConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: _builtins.str,
                 condition_properties: Optional['outputs.AutomationRulePropertyArrayValuesConditionResponse'] = None):
        """
        Describes an automation rule condition that evaluates an array property's value
        :param _builtins.str condition_type: 
               Expected value is 'PropertyArray'.
        :param 'AutomationRulePropertyArrayValuesConditionResponse' condition_properties: Describes an automation rule condition on array properties.
        """
        pulumi.set(__self__, "condition_type", 'PropertyArray')
        if condition_properties is not None:
            pulumi.set(__self__, "condition_properties", condition_properties)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> _builtins.str:
        """

        Expected value is 'PropertyArray'.
        """
        return pulumi.get(self, "condition_type")

    @_builtins.property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional['outputs.AutomationRulePropertyArrayValuesConditionResponse']:
        """
        Describes an automation rule condition on array properties.
        """
        return pulumi.get(self, "condition_properties")


@pulumi.output_type
class PropertyChangedConditionPropertiesResponse(dict):
    """
    Describes an automation rule condition that evaluates a property's value change
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"
        elif key == "conditionProperties":
            suggest = "condition_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyChangedConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyChangedConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyChangedConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: _builtins.str,
                 condition_properties: Optional['outputs.AutomationRulePropertyValuesChangedConditionResponse'] = None):
        """
        Describes an automation rule condition that evaluates a property's value change
        :param _builtins.str condition_type: 
               Expected value is 'PropertyChanged'.
        """
        pulumi.set(__self__, "condition_type", 'PropertyChanged')
        if condition_properties is not None:
            pulumi.set(__self__, "condition_properties", condition_properties)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> _builtins.str:
        """

        Expected value is 'PropertyChanged'.
        """
        return pulumi.get(self, "condition_type")

    @_builtins.property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional['outputs.AutomationRulePropertyValuesChangedConditionResponse']:
        return pulumi.get(self, "condition_properties")


@pulumi.output_type
class PropertyConditionPropertiesResponse(dict):
    """
    Describes an automation rule condition that evaluates a property's value
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionType":
            suggest = "condition_type"
        elif key == "conditionProperties":
            suggest = "condition_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PropertyConditionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PropertyConditionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PropertyConditionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_type: _builtins.str,
                 condition_properties: Optional['outputs.AutomationRulePropertyValuesConditionResponse'] = None):
        """
        Describes an automation rule condition that evaluates a property's value
        :param _builtins.str condition_type: 
               Expected value is 'Property'.
        """
        pulumi.set(__self__, "condition_type", 'Property')
        if condition_properties is not None:
            pulumi.set(__self__, "condition_properties", condition_properties)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> _builtins.str:
        """

        Expected value is 'Property'.
        """
        return pulumi.get(self, "condition_type")

    @_builtins.property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional['outputs.AutomationRulePropertyValuesConditionResponse']:
        return pulumi.get(self, "condition_properties")


@pulumi.output_type
class RepoResponse(dict):
    """
    Represents a repository.
    """
    def __init__(__self__, *,
                 branches: Optional[Sequence[_builtins.str]] = None,
                 full_name: Optional[_builtins.str] = None,
                 installation_id: Optional[_builtins.float] = None,
                 url: Optional[_builtins.str] = None):
        """
        Represents a repository.
        :param Sequence[_builtins.str] branches: Array of branches.
        :param _builtins.str full_name: The name of the repository.
        :param _builtins.float installation_id: The installation id of the repository.
        :param _builtins.str url: The url to access the repository.
        """
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if installation_id is not None:
            pulumi.set(__self__, "installation_id", installation_id)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def branches(self) -> Optional[Sequence[_builtins.str]]:
        """
        Array of branches.
        """
        return pulumi.get(self, "branches")

    @_builtins.property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[_builtins.str]:
        """
        The name of the repository.
        """
        return pulumi.get(self, "full_name")

    @_builtins.property
    @pulumi.getter(name="installationId")
    def installation_id(self) -> Optional[_builtins.float]:
        """
        The installation id of the repository.
        """
        return pulumi.get(self, "installation_id")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The url to access the repository.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class RepositoryResourceInfoResponse(dict):
    """
    Resources created in user's repository for the source-control.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureDevOpsResourceInfo":
            suggest = "azure_dev_ops_resource_info"
        elif key == "gitHubResourceInfo":
            suggest = "git_hub_resource_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RepositoryResourceInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RepositoryResourceInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RepositoryResourceInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_dev_ops_resource_info: Optional['outputs.AzureDevOpsResourceInfoResponse'] = None,
                 git_hub_resource_info: Optional['outputs.GitHubResourceInfoResponse'] = None,
                 webhook: Optional['outputs.WebhookResponse'] = None):
        """
        Resources created in user's repository for the source-control.
        :param 'AzureDevOpsResourceInfoResponse' azure_dev_ops_resource_info: Resources created in Azure DevOps for this source-control.
        :param 'GitHubResourceInfoResponse' git_hub_resource_info: Resources created in GitHub for this source-control.
        :param 'WebhookResponse' webhook: The webhook object created for the source-control.
        """
        if azure_dev_ops_resource_info is not None:
            pulumi.set(__self__, "azure_dev_ops_resource_info", azure_dev_ops_resource_info)
        if git_hub_resource_info is not None:
            pulumi.set(__self__, "git_hub_resource_info", git_hub_resource_info)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter(name="azureDevOpsResourceInfo")
    def azure_dev_ops_resource_info(self) -> Optional['outputs.AzureDevOpsResourceInfoResponse']:
        """
        Resources created in Azure DevOps for this source-control.
        """
        return pulumi.get(self, "azure_dev_ops_resource_info")

    @_builtins.property
    @pulumi.getter(name="gitHubResourceInfo")
    def git_hub_resource_info(self) -> Optional['outputs.GitHubResourceInfoResponse']:
        """
        Resources created in GitHub for this source-control.
        """
        return pulumi.get(self, "git_hub_resource_info")

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> Optional['outputs.WebhookResponse']:
        """
        The webhook object created for the source-control.
        """
        return pulumi.get(self, "webhook")


@pulumi.output_type
class RepositoryResponse(dict):
    """
    metadata of a repository.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentLogsUrl":
            suggest = "deployment_logs_url"
        elif key == "displayUrl":
            suggest = "display_url"
        elif key == "pathMapping":
            suggest = "path_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RepositoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RepositoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RepositoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deployment_logs_url: Optional[_builtins.str] = None,
                 display_url: Optional[_builtins.str] = None,
                 path_mapping: Optional[Sequence['outputs.ContentPathMapResponse']] = None,
                 url: Optional[_builtins.str] = None):
        """
        metadata of a repository.
        :param _builtins.str branch: Branch name of repository.
        :param _builtins.str deployment_logs_url: Url to access repository action logs.
        :param _builtins.str display_url: Display url of repository.
        :param Sequence['ContentPathMapResponse'] path_mapping: Dictionary of source control content type and path mapping.
        :param _builtins.str url: Url of repository.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deployment_logs_url is not None:
            pulumi.set(__self__, "deployment_logs_url", deployment_logs_url)
        if display_url is not None:
            pulumi.set(__self__, "display_url", display_url)
        if path_mapping is not None:
            pulumi.set(__self__, "path_mapping", path_mapping)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        Branch name of repository.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deploymentLogsUrl")
    def deployment_logs_url(self) -> Optional[_builtins.str]:
        """
        Url to access repository action logs.
        """
        return pulumi.get(self, "deployment_logs_url")

    @_builtins.property
    @pulumi.getter(name="displayUrl")
    def display_url(self) -> Optional[_builtins.str]:
        """
        Display url of repository.
        """
        return pulumi.get(self, "display_url")

    @_builtins.property
    @pulumi.getter(name="pathMapping")
    def path_mapping(self) -> Optional[Sequence['outputs.ContentPathMapResponse']]:
        """
        Dictionary of source control content type and path mapping.
        """
        return pulumi.get(self, "path_mapping")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of repository.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ResourceProviderRequiredPermissionsResponse(dict):
    """
    Required permissions for the connector resource provider that define in ResourceProviders.
    For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
    """
    def __init__(__self__, *,
                 action: Optional[_builtins.bool] = None,
                 delete: Optional[_builtins.bool] = None,
                 read: Optional[_builtins.bool] = None,
                 write: Optional[_builtins.bool] = None):
        """
        Required permissions for the connector resource provider that define in ResourceProviders.
        For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
        :param _builtins.bool action: Gets or sets a value indicating whether the permission is custom actions (POST).
        :param _builtins.bool delete: Gets or sets a value indicating whether the permission is delete action (DELETE).
        :param _builtins.bool read: Gets or sets a value indicating whether the permission is read action (GET).
        :param _builtins.bool write: Gets or sets a value indicating whether the permission is write action (PUT or PATCH).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if write is not None:
            pulumi.set(__self__, "write", write)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.bool]:
        """
        Gets or sets a value indicating whether the permission is custom actions (POST).
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.bool]:
        """
        Gets or sets a value indicating whether the permission is delete action (DELETE).
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[_builtins.bool]:
        """
        Gets or sets a value indicating whether the permission is read action (GET).
        """
        return pulumi.get(self, "read")

    @_builtins.property
    @pulumi.getter
    def write(self) -> Optional[_builtins.bool]:
        """
        Gets or sets a value indicating whether the permission is write action (PUT or PATCH).
        """
        return pulumi.get(self, "write")


@pulumi.output_type
class RestApiPollerRequestConfigResponse(dict):
    """
    The request configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiEndpoint":
            suggest = "api_endpoint"
        elif key == "endTimeAttributeName":
            suggest = "end_time_attribute_name"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "isPostPayloadJson":
            suggest = "is_post_payload_json"
        elif key == "queryParameters":
            suggest = "query_parameters"
        elif key == "queryParametersTemplate":
            suggest = "query_parameters_template"
        elif key == "queryTimeFormat":
            suggest = "query_time_format"
        elif key == "queryTimeIntervalAttributeName":
            suggest = "query_time_interval_attribute_name"
        elif key == "queryTimeIntervalDelimiter":
            suggest = "query_time_interval_delimiter"
        elif key == "queryTimeIntervalPrepend":
            suggest = "query_time_interval_prepend"
        elif key == "queryWindowInMin":
            suggest = "query_window_in_min"
        elif key == "rateLimitQPS":
            suggest = "rate_limit_qps"
        elif key == "retryCount":
            suggest = "retry_count"
        elif key == "startTimeAttributeName":
            suggest = "start_time_attribute_name"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RestApiPollerRequestConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RestApiPollerRequestConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RestApiPollerRequestConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_endpoint: _builtins.str,
                 end_time_attribute_name: Optional[_builtins.str] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 http_method: Optional[_builtins.str] = None,
                 is_post_payload_json: Optional[_builtins.bool] = None,
                 query_parameters: Optional[Any] = None,
                 query_parameters_template: Optional[_builtins.str] = None,
                 query_time_format: Optional[_builtins.str] = None,
                 query_time_interval_attribute_name: Optional[_builtins.str] = None,
                 query_time_interval_delimiter: Optional[_builtins.str] = None,
                 query_time_interval_prepend: Optional[_builtins.str] = None,
                 query_window_in_min: Optional[_builtins.int] = None,
                 rate_limit_qps: Optional[_builtins.int] = None,
                 retry_count: Optional[_builtins.int] = None,
                 start_time_attribute_name: Optional[_builtins.str] = None,
                 timeout_in_seconds: Optional[_builtins.int] = None):
        """
        The request configuration.
        :param _builtins.str api_endpoint: The API endpoint.
        :param _builtins.str end_time_attribute_name: The query parameter name which the remote server expect to end query. This property goes hand to hand with `startTimeAttributeName`
        :param Mapping[str, _builtins.str] headers: The header for the request for the remote server.
        :param _builtins.str http_method: The HTTP method, default value GET.
        :param _builtins.bool is_post_payload_json: Flag to indicate if HTTP POST payload is in JSON format (vs form-urlencoded).
        :param Any query_parameters: The HTTP query parameters to RESTful API.
        :param _builtins.str query_parameters_template: the query parameters template. Defines the query parameters template to use when passing query parameters in advanced scenarios.
        :param _builtins.str query_time_format: The query time format. A remote server can have a query to pull data from range 'start' to 'end'. This property indicate what is the expected time format the remote server know to parse.
        :param _builtins.str query_time_interval_attribute_name: The query parameter name which we need to send the server for query logs in time interval. Should be defined with `queryTimeIntervalPrepend` and `queryTimeIntervalDelimiter`
        :param _builtins.str query_time_interval_delimiter: The delimiter string between 2 QueryTimeFormat in the query parameter `queryTimeIntervalAttributeName`.
        :param _builtins.str query_time_interval_prepend: The string prepend to the value of the query parameter in `queryTimeIntervalAttributeName`.
        :param _builtins.int query_window_in_min: The query window in minutes for the request.
        :param _builtins.int rate_limit_qps: The Rate limit queries per second for the request..
        :param _builtins.int retry_count: The retry count.
        :param _builtins.str start_time_attribute_name: The query parameter name which the remote server expect to start query. This property goes hand to hand with `endTimeAttributeName`.
        :param _builtins.int timeout_in_seconds: The timeout in seconds.
        """
        pulumi.set(__self__, "api_endpoint", api_endpoint)
        if end_time_attribute_name is not None:
            pulumi.set(__self__, "end_time_attribute_name", end_time_attribute_name)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if is_post_payload_json is not None:
            pulumi.set(__self__, "is_post_payload_json", is_post_payload_json)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if query_parameters_template is not None:
            pulumi.set(__self__, "query_parameters_template", query_parameters_template)
        if query_time_format is not None:
            pulumi.set(__self__, "query_time_format", query_time_format)
        if query_time_interval_attribute_name is not None:
            pulumi.set(__self__, "query_time_interval_attribute_name", query_time_interval_attribute_name)
        if query_time_interval_delimiter is not None:
            pulumi.set(__self__, "query_time_interval_delimiter", query_time_interval_delimiter)
        if query_time_interval_prepend is not None:
            pulumi.set(__self__, "query_time_interval_prepend", query_time_interval_prepend)
        if query_window_in_min is not None:
            pulumi.set(__self__, "query_window_in_min", query_window_in_min)
        if rate_limit_qps is not None:
            pulumi.set(__self__, "rate_limit_qps", rate_limit_qps)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if start_time_attribute_name is not None:
            pulumi.set(__self__, "start_time_attribute_name", start_time_attribute_name)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @_builtins.property
    @pulumi.getter(name="apiEndpoint")
    def api_endpoint(self) -> _builtins.str:
        """
        The API endpoint.
        """
        return pulumi.get(self, "api_endpoint")

    @_builtins.property
    @pulumi.getter(name="endTimeAttributeName")
    def end_time_attribute_name(self) -> Optional[_builtins.str]:
        """
        The query parameter name which the remote server expect to end query. This property goes hand to hand with `startTimeAttributeName`
        """
        return pulumi.get(self, "end_time_attribute_name")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The header for the request for the remote server.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[_builtins.str]:
        """
        The HTTP method, default value GET.
        """
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter(name="isPostPayloadJson")
    def is_post_payload_json(self) -> Optional[_builtins.bool]:
        """
        Flag to indicate if HTTP POST payload is in JSON format (vs form-urlencoded).
        """
        return pulumi.get(self, "is_post_payload_json")

    @_builtins.property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Any]:
        """
        The HTTP query parameters to RESTful API.
        """
        return pulumi.get(self, "query_parameters")

    @_builtins.property
    @pulumi.getter(name="queryParametersTemplate")
    def query_parameters_template(self) -> Optional[_builtins.str]:
        """
        the query parameters template. Defines the query parameters template to use when passing query parameters in advanced scenarios.
        """
        return pulumi.get(self, "query_parameters_template")

    @_builtins.property
    @pulumi.getter(name="queryTimeFormat")
    def query_time_format(self) -> Optional[_builtins.str]:
        """
        The query time format. A remote server can have a query to pull data from range 'start' to 'end'. This property indicate what is the expected time format the remote server know to parse.
        """
        return pulumi.get(self, "query_time_format")

    @_builtins.property
    @pulumi.getter(name="queryTimeIntervalAttributeName")
    def query_time_interval_attribute_name(self) -> Optional[_builtins.str]:
        """
        The query parameter name which we need to send the server for query logs in time interval. Should be defined with `queryTimeIntervalPrepend` and `queryTimeIntervalDelimiter`
        """
        return pulumi.get(self, "query_time_interval_attribute_name")

    @_builtins.property
    @pulumi.getter(name="queryTimeIntervalDelimiter")
    def query_time_interval_delimiter(self) -> Optional[_builtins.str]:
        """
        The delimiter string between 2 QueryTimeFormat in the query parameter `queryTimeIntervalAttributeName`.
        """
        return pulumi.get(self, "query_time_interval_delimiter")

    @_builtins.property
    @pulumi.getter(name="queryTimeIntervalPrepend")
    def query_time_interval_prepend(self) -> Optional[_builtins.str]:
        """
        The string prepend to the value of the query parameter in `queryTimeIntervalAttributeName`.
        """
        return pulumi.get(self, "query_time_interval_prepend")

    @_builtins.property
    @pulumi.getter(name="queryWindowInMin")
    def query_window_in_min(self) -> Optional[_builtins.int]:
        """
        The query window in minutes for the request.
        """
        return pulumi.get(self, "query_window_in_min")

    @_builtins.property
    @pulumi.getter(name="rateLimitQPS")
    def rate_limit_qps(self) -> Optional[_builtins.int]:
        """
        The Rate limit queries per second for the request..
        """
        return pulumi.get(self, "rate_limit_qps")

    @_builtins.property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[_builtins.int]:
        """
        The retry count.
        """
        return pulumi.get(self, "retry_count")

    @_builtins.property
    @pulumi.getter(name="startTimeAttributeName")
    def start_time_attribute_name(self) -> Optional[_builtins.str]:
        """
        The query parameter name which the remote server expect to start query. This property goes hand to hand with `endTimeAttributeName`.
        """
        return pulumi.get(self, "start_time_attribute_name")

    @_builtins.property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[_builtins.int]:
        """
        The timeout in seconds.
        """
        return pulumi.get(self, "timeout_in_seconds")


@pulumi.output_type
class RestApiPollerRequestPagingConfigResponse(dict):
    """
    The request paging configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pagingType":
            suggest = "paging_type"
        elif key == "pageSize":
            suggest = "page_size"
        elif key == "pageSizeParameterName":
            suggest = "page_size_parameter_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RestApiPollerRequestPagingConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RestApiPollerRequestPagingConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RestApiPollerRequestPagingConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paging_type: _builtins.str,
                 page_size: Optional[_builtins.int] = None,
                 page_size_parameter_name: Optional[_builtins.str] = None):
        """
        The request paging configuration.
        :param _builtins.str paging_type: Type of paging
        :param _builtins.int page_size: Page size
        :param _builtins.str page_size_parameter_name: Page size parameter name
        """
        pulumi.set(__self__, "paging_type", paging_type)
        if page_size is not None:
            pulumi.set(__self__, "page_size", page_size)
        if page_size_parameter_name is not None:
            pulumi.set(__self__, "page_size_parameter_name", page_size_parameter_name)

    @_builtins.property
    @pulumi.getter(name="pagingType")
    def paging_type(self) -> _builtins.str:
        """
        Type of paging
        """
        return pulumi.get(self, "paging_type")

    @_builtins.property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[_builtins.int]:
        """
        Page size
        """
        return pulumi.get(self, "page_size")

    @_builtins.property
    @pulumi.getter(name="pageSizeParameterName")
    def page_size_parameter_name(self) -> Optional[_builtins.str]:
        """
        Page size parameter name
        """
        return pulumi.get(self, "page_size_parameter_name")


@pulumi.output_type
class RfcConnectorResponse(dict):
    """
    Describes the Rfc connector.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemId":
            suggest = "system_id"
        elif key == "systemNumber":
            suggest = "system_number"
        elif key == "abapServerHost":
            suggest = "abap_server_host"
        elif key == "authenticationType":
            suggest = "authentication_type"
        elif key == "codePage":
            suggest = "code_page"
        elif key == "messageServerHost":
            suggest = "message_server_host"
        elif key == "messageServerService":
            suggest = "message_server_service"
        elif key == "sncQop":
            suggest = "snc_qop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RfcConnectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RfcConnectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RfcConnectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client: _builtins.str,
                 system_id: _builtins.str,
                 system_number: _builtins.str,
                 type: _builtins.str,
                 abap_server_host: Optional[_builtins.str] = None,
                 authentication_type: Optional[_builtins.str] = None,
                 code_page: Optional[_builtins.str] = None,
                 group: Optional[_builtins.str] = None,
                 message_server_host: Optional[_builtins.str] = None,
                 message_server_service: Optional[_builtins.str] = None,
                 snc_qop: Optional[_builtins.str] = None):
        """
        Describes the Rfc connector.
        :param _builtins.str client: Client number of the ABAP server.
               Example - 001
        :param _builtins.str system_id: System ID of the ABAP server.
               Example - A4H
        :param _builtins.str system_number: System number of the ABAP server.
        :param _builtins.str type: Represents the types of SAP systems.
               Expected value is 'Rfc'.
        :param _builtins.str abap_server_host: FQDN, hostname, or IP address of the ABAP server.
        :param _builtins.str authentication_type: The authentication type to SAP.
        :param _builtins.str code_page: The SAP code page used for character encoding.
               Example - 1100
        :param _builtins.str group: Logon group of the message server.
        :param _builtins.str message_server_host: FQDN, hostname, or IP address of the Message server.
        :param _builtins.str message_server_service: Port number, or service name (from /etc/services) of the message server.
        :param _builtins.str snc_qop: SNC QOP.
               Options are 1, 2, 3, 8, 9.
        """
        pulumi.set(__self__, "client", client)
        pulumi.set(__self__, "system_id", system_id)
        pulumi.set(__self__, "system_number", system_number)
        pulumi.set(__self__, "type", 'Rfc')
        if abap_server_host is not None:
            pulumi.set(__self__, "abap_server_host", abap_server_host)
        if authentication_type is not None:
            pulumi.set(__self__, "authentication_type", authentication_type)
        if code_page is not None:
            pulumi.set(__self__, "code_page", code_page)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if message_server_host is not None:
            pulumi.set(__self__, "message_server_host", message_server_host)
        if message_server_service is not None:
            pulumi.set(__self__, "message_server_service", message_server_service)
        if snc_qop is not None:
            pulumi.set(__self__, "snc_qop", snc_qop)

    @_builtins.property
    @pulumi.getter
    def client(self) -> _builtins.str:
        """
        Client number of the ABAP server.
        Example - 001
        """
        return pulumi.get(self, "client")

    @_builtins.property
    @pulumi.getter(name="systemId")
    def system_id(self) -> _builtins.str:
        """
        System ID of the ABAP server.
        Example - A4H
        """
        return pulumi.get(self, "system_id")

    @_builtins.property
    @pulumi.getter(name="systemNumber")
    def system_number(self) -> _builtins.str:
        """
        System number of the ABAP server.
        """
        return pulumi.get(self, "system_number")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Represents the types of SAP systems.
        Expected value is 'Rfc'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="abapServerHost")
    def abap_server_host(self) -> Optional[_builtins.str]:
        """
        FQDN, hostname, or IP address of the ABAP server.
        """
        return pulumi.get(self, "abap_server_host")

    @_builtins.property
    @pulumi.getter(name="authenticationType")
    def authentication_type(self) -> Optional[_builtins.str]:
        """
        The authentication type to SAP.
        """
        return pulumi.get(self, "authentication_type")

    @_builtins.property
    @pulumi.getter(name="codePage")
    def code_page(self) -> Optional[_builtins.str]:
        """
        The SAP code page used for character encoding.
        Example - 1100
        """
        return pulumi.get(self, "code_page")

    @_builtins.property
    @pulumi.getter
    def group(self) -> Optional[_builtins.str]:
        """
        Logon group of the message server.
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter(name="messageServerHost")
    def message_server_host(self) -> Optional[_builtins.str]:
        """
        FQDN, hostname, or IP address of the Message server.
        """
        return pulumi.get(self, "message_server_host")

    @_builtins.property
    @pulumi.getter(name="messageServerService")
    def message_server_service(self) -> Optional[_builtins.str]:
        """
        Port number, or service name (from /etc/services) of the message server.
        """
        return pulumi.get(self, "message_server_service")

    @_builtins.property
    @pulumi.getter(name="sncQop")
    def snc_qop(self) -> Optional[_builtins.str]:
        """
        SNC QOP.
        Options are 1, 2, 3, 8, 9.
        """
        return pulumi.get(self, "snc_qop")


@pulumi.output_type
class SapAgentConfigurationResponse(dict):
    """
    Describes the configuration of a SAP Docker agent.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentContainerName":
            suggest = "agent_container_name"
        elif key == "keyVaultAuthenticationMode":
            suggest = "key_vault_authentication_mode"
        elif key == "keyVaultResourceId":
            suggest = "key_vault_resource_id"
        elif key == "sdkPath":
            suggest = "sdk_path"
        elif key == "secretSource":
            suggest = "secret_source"
        elif key == "sncPath":
            suggest = "snc_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SapAgentConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SapAgentConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SapAgentConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 agent_container_name: Optional[_builtins.str] = None,
                 key_vault_authentication_mode: Optional[_builtins.str] = None,
                 key_vault_resource_id: Optional[_builtins.str] = None,
                 sdk_path: Optional[_builtins.str] = None,
                 secret_source: Optional[_builtins.str] = None,
                 snc_path: Optional[_builtins.str] = None):
        """
        Describes the configuration of a SAP Docker agent.
        :param _builtins.str type: Type of the agent
               Expected value is 'SAP'.
        :param _builtins.str agent_container_name: The name of the docker agent.
               only letters with numbers, underscores and hyphens are allowed
               example: "my-agent"
        :param _builtins.str key_vault_authentication_mode: The key mode of the agent.
               ManagedIdentity|ApplicationIdentity are the options
        :param _builtins.str key_vault_resource_id: The key vault resource id to access the key vault.
               example: "/subscriptions/d0cfe6b2-9ac0-4464-9919-dccaee2e48c0/resourceGroups/myRg/providers/Microsoft.KeyVault/vaults/myVault"
        :param _builtins.str sdk_path: The SDK path (a file not a folder) on the agent machine.
               example: "/path/to/nwrfc750P_8-70002755.zip"
        :param _builtins.str secret_source: The secret source of the agent.
               AzureKeyVault is the option
        :param _builtins.str snc_path: The SNC path (a folder not a file) on the agent machine.
               example: "/path/to/snc"
        """
        pulumi.set(__self__, "type", 'SAP')
        if agent_container_name is not None:
            pulumi.set(__self__, "agent_container_name", agent_container_name)
        if key_vault_authentication_mode is not None:
            pulumi.set(__self__, "key_vault_authentication_mode", key_vault_authentication_mode)
        if key_vault_resource_id is not None:
            pulumi.set(__self__, "key_vault_resource_id", key_vault_resource_id)
        if sdk_path is not None:
            pulumi.set(__self__, "sdk_path", sdk_path)
        if secret_source is not None:
            pulumi.set(__self__, "secret_source", secret_source)
        if snc_path is not None:
            pulumi.set(__self__, "snc_path", snc_path)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the agent
        Expected value is 'SAP'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="agentContainerName")
    def agent_container_name(self) -> Optional[_builtins.str]:
        """
        The name of the docker agent.
        only letters with numbers, underscores and hyphens are allowed
        example: "my-agent"
        """
        return pulumi.get(self, "agent_container_name")

    @_builtins.property
    @pulumi.getter(name="keyVaultAuthenticationMode")
    def key_vault_authentication_mode(self) -> Optional[_builtins.str]:
        """
        The key mode of the agent.
        ManagedIdentity|ApplicationIdentity are the options
        """
        return pulumi.get(self, "key_vault_authentication_mode")

    @_builtins.property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> Optional[_builtins.str]:
        """
        The key vault resource id to access the key vault.
        example: "/subscriptions/d0cfe6b2-9ac0-4464-9919-dccaee2e48c0/resourceGroups/myRg/providers/Microsoft.KeyVault/vaults/myVault"
        """
        return pulumi.get(self, "key_vault_resource_id")

    @_builtins.property
    @pulumi.getter(name="sdkPath")
    def sdk_path(self) -> Optional[_builtins.str]:
        """
        The SDK path (a file not a folder) on the agent machine.
        example: "/path/to/nwrfc750P_8-70002755.zip"
        """
        return pulumi.get(self, "sdk_path")

    @_builtins.property
    @pulumi.getter(name="secretSource")
    def secret_source(self) -> Optional[_builtins.str]:
        """
        The secret source of the agent.
        AzureKeyVault is the option
        """
        return pulumi.get(self, "secret_source")

    @_builtins.property
    @pulumi.getter(name="sncPath")
    def snc_path(self) -> Optional[_builtins.str]:
        """
        The SNC path (a folder not a file) on the agent machine.
        example: "/path/to/snc"
        """
        return pulumi.get(self, "snc_path")


@pulumi.output_type
class SapControlConnectorResponse(dict):
    """
    Describes the SapControl connector configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpsConfiguration":
            suggest = "https_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SapControlConnectorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SapControlConnectorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SapControlConnectorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance: _builtins.str,
                 server: _builtins.str,
                 type: _builtins.str,
                 https_configuration: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 timezone: Optional[_builtins.str] = None):
        """
        Describes the SapControl connector configuration.
        :param _builtins.str instance: The instance number. Only 2 digits are allowed.
        :param _builtins.str server: The server name.
               FQDN or IP address.
        :param _builtins.str type: Represents the types of SAP systems.
               Expected value is 'SapControl'.
        :param _builtins.str https_configuration: Represents the types of HTTPS configuration to connect to the SapControl service.
        :param _builtins.str port: The port of the SOAP connection to SAP Control.
        :param _builtins.str timezone: The timezone.
               example: "GMT+0" or "GMT-8"
               default: "GMT+0"
        """
        pulumi.set(__self__, "instance", instance)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "type", 'SapControl')
        if https_configuration is not None:
            pulumi.set(__self__, "https_configuration", https_configuration)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if timezone is None:
            timezone = 'GMT+0'
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter
    def instance(self) -> _builtins.str:
        """
        The instance number. Only 2 digits are allowed.
        """
        return pulumi.get(self, "instance")

    @_builtins.property
    @pulumi.getter
    def server(self) -> _builtins.str:
        """
        The server name.
        FQDN or IP address.
        """
        return pulumi.get(self, "server")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Represents the types of SAP systems.
        Expected value is 'SapControl'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="httpsConfiguration")
    def https_configuration(self) -> Optional[_builtins.str]:
        """
        Represents the types of HTTPS configuration to connect to the SapControl service.
        """
        return pulumi.get(self, "https_configuration")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        The port of the SOAP connection to SAP Control.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        The timezone.
        example: "GMT+0" or "GMT-8"
        default: "GMT+0"
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class SapSystemsConfigurationResponse(dict):
    """
    Describes the SAP configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureResourceId":
            suggest = "azure_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SapSystemsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SapSystemsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SapSystemsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector: Any,
                 type: _builtins.str,
                 azure_resource_id: Optional[_builtins.str] = None,
                 logs: Optional[Sequence['outputs.LogResponse']] = None):
        """
        Describes the SAP configuration.
        :param Union['RfcConnectorResponse', 'SapControlConnectorResponse'] connector: Base Model for SAP System Connector.
        :param _builtins.str type: Represents the types of configuration for a system.
               Expected value is 'SAP'.
        :param _builtins.str azure_resource_id: azure resource id
               example: "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroup/providers/Microsoft.Compute/virtualMachines/myVM"
        :param Sequence['LogResponse'] logs: The logs configuration.
        """
        pulumi.set(__self__, "connector", connector)
        pulumi.set(__self__, "type", 'SAP')
        if azure_resource_id is not None:
            pulumi.set(__self__, "azure_resource_id", azure_resource_id)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)

    @_builtins.property
    @pulumi.getter
    def connector(self) -> Any:
        """
        Base Model for SAP System Connector.
        """
        return pulumi.get(self, "connector")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Represents the types of configuration for a system.
        Expected value is 'SAP'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> Optional[_builtins.str]:
        """
        azure resource id
        example: "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/myResourceGroup/providers/Microsoft.Compute/virtualMachines/myVM"
        """
        return pulumi.get(self, "azure_resource_id")

    @_builtins.property
    @pulumi.getter
    def logs(self) -> Optional[Sequence['outputs.LogResponse']]:
        """
        The logs configuration.
        """
        return pulumi.get(self, "logs")


@pulumi.output_type
class SecurityAlertTimelineItemResponse(dict):
    """
    Represents security alert timeline item.
    """
    def __init__(__self__, *,
                 alert_type: _builtins.str,
                 azure_resource_id: _builtins.str,
                 display_name: _builtins.str,
                 end_time_utc: _builtins.str,
                 intent: _builtins.str,
                 kind: _builtins.str,
                 severity: _builtins.str,
                 start_time_utc: _builtins.str,
                 time_generated: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 product_name: Optional[_builtins.str] = None,
                 techniques: Optional[Sequence[_builtins.str]] = None):
        """
        Represents security alert timeline item.
        :param _builtins.str alert_type: The name of the alert type.
        :param _builtins.str azure_resource_id: The alert azure resource id.
        :param _builtins.str display_name: The alert name.
        :param _builtins.str end_time_utc: The alert end time.
        :param _builtins.str intent: The intent of the alert.
        :param _builtins.str kind: The entity query kind
               Expected value is 'SecurityAlert'.
        :param _builtins.str severity: The alert severity.
        :param _builtins.str start_time_utc: The alert start time.
        :param _builtins.str time_generated: The alert generated time.
        :param _builtins.str description: The alert description.
        :param _builtins.str product_name: The alert product name.
        :param Sequence[_builtins.str] techniques: The techniques of the alert.
        """
        pulumi.set(__self__, "alert_type", alert_type)
        pulumi.set(__self__, "azure_resource_id", azure_resource_id)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "end_time_utc", end_time_utc)
        pulumi.set(__self__, "intent", intent)
        pulumi.set(__self__, "kind", 'SecurityAlert')
        pulumi.set(__self__, "severity", severity)
        pulumi.set(__self__, "start_time_utc", start_time_utc)
        pulumi.set(__self__, "time_generated", time_generated)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if product_name is not None:
            pulumi.set(__self__, "product_name", product_name)
        if techniques is not None:
            pulumi.set(__self__, "techniques", techniques)

    @_builtins.property
    @pulumi.getter(name="alertType")
    def alert_type(self) -> _builtins.str:
        """
        The name of the alert type.
        """
        return pulumi.get(self, "alert_type")

    @_builtins.property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> _builtins.str:
        """
        The alert azure resource id.
        """
        return pulumi.get(self, "azure_resource_id")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The alert name.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> _builtins.str:
        """
        The alert end time.
        """
        return pulumi.get(self, "end_time_utc")

    @_builtins.property
    @pulumi.getter
    def intent(self) -> _builtins.str:
        """
        The intent of the alert.
        """
        return pulumi.get(self, "intent")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The entity query kind
        Expected value is 'SecurityAlert'.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> _builtins.str:
        """
        The alert severity.
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> _builtins.str:
        """
        The alert start time.
        """
        return pulumi.get(self, "start_time_utc")

    @_builtins.property
    @pulumi.getter(name="timeGenerated")
    def time_generated(self) -> _builtins.str:
        """
        The alert generated time.
        """
        return pulumi.get(self, "time_generated")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The alert description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[_builtins.str]:
        """
        The alert product name.
        """
        return pulumi.get(self, "product_name")

    @_builtins.property
    @pulumi.getter
    def techniques(self) -> Optional[Sequence[_builtins.str]]:
        """
        The techniques of the alert.
        """
        return pulumi.get(self, "techniques")


@pulumi.output_type
class SecurityMLAnalyticsSettingsDataSourceResponse(dict):
    """
    security ml analytics settings data sources
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorId":
            suggest = "connector_id"
        elif key == "dataTypes":
            suggest = "data_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMLAnalyticsSettingsDataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMLAnalyticsSettingsDataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMLAnalyticsSettingsDataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_id: Optional[_builtins.str] = None,
                 data_types: Optional[Sequence[_builtins.str]] = None):
        """
        security ml analytics settings data sources
        :param _builtins.str connector_id: The connector id that provides the following data types
        :param Sequence[_builtins.str] data_types: The data types used by the security ml analytics settings
        """
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)
        if data_types is not None:
            pulumi.set(__self__, "data_types", data_types)

    @_builtins.property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[_builtins.str]:
        """
        The connector id that provides the following data types
        """
        return pulumi.get(self, "connector_id")

    @_builtins.property
    @pulumi.getter(name="dataTypes")
    def data_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The data types used by the security ml analytics settings
        """
        return pulumi.get(self, "data_types")


@pulumi.output_type
class SessionAuthModelResponse(dict):
    """
    Model for API authentication with session cookie.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"
        elif key == "isPostPayloadJson":
            suggest = "is_post_payload_json"
        elif key == "queryParameters":
            suggest = "query_parameters"
        elif key == "sessionIdName":
            suggest = "session_id_name"
        elif key == "sessionLoginRequestUri":
            suggest = "session_login_request_uri"
        elif key == "sessionTimeoutInMinutes":
            suggest = "session_timeout_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionAuthModelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionAuthModelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionAuthModelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: Mapping[str, _builtins.str],
                 type: _builtins.str,
                 user_name: Mapping[str, _builtins.str],
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 is_post_payload_json: Optional[_builtins.bool] = None,
                 query_parameters: Optional[Any] = None,
                 session_id_name: Optional[_builtins.str] = None,
                 session_login_request_uri: Optional[_builtins.str] = None,
                 session_timeout_in_minutes: Optional[_builtins.int] = None):
        """
        Model for API authentication with session cookie.
        :param Mapping[str, _builtins.str] password: The password attribute name.
        :param _builtins.str type: Type of paging
               Expected value is 'Session'.
        :param Mapping[str, _builtins.str] user_name: The user name attribute key value.
        :param Mapping[str, _builtins.str] headers: HTTP request headers to session service endpoint.
        :param _builtins.bool is_post_payload_json: Indicating whether API key is set in HTTP POST payload.
        :param Any query_parameters: Query parameters to session service endpoint.
        :param _builtins.str session_id_name: Session id attribute name from HTTP response header.
        :param _builtins.str session_login_request_uri: HTTP request URL to session service endpoint.
        :param _builtins.int session_timeout_in_minutes: Session timeout in minutes.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "type", 'Session')
        pulumi.set(__self__, "user_name", user_name)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if is_post_payload_json is not None:
            pulumi.set(__self__, "is_post_payload_json", is_post_payload_json)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if session_id_name is not None:
            pulumi.set(__self__, "session_id_name", session_id_name)
        if session_login_request_uri is not None:
            pulumi.set(__self__, "session_login_request_uri", session_login_request_uri)
        if session_timeout_in_minutes is not None:
            pulumi.set(__self__, "session_timeout_in_minutes", session_timeout_in_minutes)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Mapping[str, _builtins.str]:
        """
        The password attribute name.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of paging
        Expected value is 'Session'.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> Mapping[str, _builtins.str]:
        """
        The user name attribute key value.
        """
        return pulumi.get(self, "user_name")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        HTTP request headers to session service endpoint.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="isPostPayloadJson")
    def is_post_payload_json(self) -> Optional[_builtins.bool]:
        """
        Indicating whether API key is set in HTTP POST payload.
        """
        return pulumi.get(self, "is_post_payload_json")

    @_builtins.property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Any]:
        """
        Query parameters to session service endpoint.
        """
        return pulumi.get(self, "query_parameters")

    @_builtins.property
    @pulumi.getter(name="sessionIdName")
    def session_id_name(self) -> Optional[_builtins.str]:
        """
        Session id attribute name from HTTP response header.
        """
        return pulumi.get(self, "session_id_name")

    @_builtins.property
    @pulumi.getter(name="sessionLoginRequestUri")
    def session_login_request_uri(self) -> Optional[_builtins.str]:
        """
        HTTP request URL to session service endpoint.
        """
        return pulumi.get(self, "session_login_request_uri")

    @_builtins.property
    @pulumi.getter(name="sessionTimeoutInMinutes")
    def session_timeout_in_minutes(self) -> Optional[_builtins.int]:
        """
        Session timeout in minutes.
        """
        return pulumi.get(self, "session_timeout_in_minutes")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TIDataConnectorDataTypesResponse(dict):
    """
    The available data types for TI (Threat Intelligence) data connector.
    """
    def __init__(__self__, *,
                 indicators: Optional['outputs.TIDataConnectorDataTypesResponseIndicators'] = None):
        """
        The available data types for TI (Threat Intelligence) data connector.
        :param 'TIDataConnectorDataTypesResponseIndicators' indicators: Data type for indicators connection.
        """
        if indicators is not None:
            pulumi.set(__self__, "indicators", indicators)

    @_builtins.property
    @pulumi.getter
    def indicators(self) -> Optional['outputs.TIDataConnectorDataTypesResponseIndicators']:
        """
        Data type for indicators connection.
        """
        return pulumi.get(self, "indicators")


@pulumi.output_type
class TIDataConnectorDataTypesResponseIndicators(dict):
    """
    Data type for indicators connection.
    """
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        Data type for indicators connection.
        :param _builtins.str state: Describe whether this data type connection is enabled or not.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class TemplatePropertiesResponse(dict):
    """
    Template property bag.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentId":
            suggest = "content_id"
        elif key == "contentKind":
            suggest = "content_kind"
        elif key == "contentProductId":
            suggest = "content_product_id"
        elif key == "dependantTemplates":
            suggest = "dependant_templates"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "isDeprecated":
            suggest = "is_deprecated"
        elif key == "packageId":
            suggest = "package_id"
        elif key == "packageVersion":
            suggest = "package_version"
        elif key == "contentSchemaVersion":
            suggest = "content_schema_version"
        elif key == "customVersion":
            suggest = "custom_version"
        elif key == "firstPublishDate":
            suggest = "first_publish_date"
        elif key == "lastPublishDate":
            suggest = "last_publish_date"
        elif key == "mainTemplate":
            suggest = "main_template"
        elif key == "packageKind":
            suggest = "package_kind"
        elif key == "packageName":
            suggest = "package_name"
        elif key == "previewImages":
            suggest = "preview_images"
        elif key == "previewImagesDark":
            suggest = "preview_images_dark"
        elif key == "threatAnalysisTactics":
            suggest = "threat_analysis_tactics"
        elif key == "threatAnalysisTechniques":
            suggest = "threat_analysis_techniques"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplatePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplatePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplatePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_id: _builtins.str,
                 content_kind: _builtins.str,
                 content_product_id: _builtins.str,
                 dependant_templates: Sequence['outputs.TemplatePropertiesResponse'],
                 display_name: _builtins.str,
                 is_deprecated: _builtins.str,
                 package_id: _builtins.str,
                 package_version: _builtins.str,
                 source: 'outputs.MetadataSourceResponse',
                 version: _builtins.str,
                 author: Optional['outputs.MetadataAuthorResponse'] = None,
                 categories: Optional['outputs.MetadataCategoriesResponse'] = None,
                 content_schema_version: Optional[_builtins.str] = None,
                 custom_version: Optional[_builtins.str] = None,
                 dependencies: Optional['outputs.MetadataDependenciesResponse'] = None,
                 first_publish_date: Optional[_builtins.str] = None,
                 icon: Optional[_builtins.str] = None,
                 last_publish_date: Optional[_builtins.str] = None,
                 main_template: Optional[Any] = None,
                 package_kind: Optional[_builtins.str] = None,
                 package_name: Optional[_builtins.str] = None,
                 preview_images: Optional[Sequence[_builtins.str]] = None,
                 preview_images_dark: Optional[Sequence[_builtins.str]] = None,
                 providers: Optional[Sequence[_builtins.str]] = None,
                 support: Optional['outputs.MetadataSupportResponse'] = None,
                 threat_analysis_tactics: Optional[Sequence[_builtins.str]] = None,
                 threat_analysis_techniques: Optional[Sequence[_builtins.str]] = None):
        """
        Template property bag.
        :param _builtins.str content_id: Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        :param _builtins.str content_kind: The kind of content the template is for.
        :param _builtins.str content_product_id: Unique ID for the content. It should be generated based on the contentId of the package, contentId of the template, contentKind of the template and the contentVersion of the template
        :param Sequence['TemplatePropertiesResponse'] dependant_templates: Dependant templates. Expandable.
        :param _builtins.str display_name: The display name of the template
        :param _builtins.str is_deprecated: Flag indicates if this template is deprecated
        :param _builtins.str package_id: the package Id contains this template
        :param _builtins.str package_version: Version of the package.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM metadata best practices.  Can also be any string, but then we cannot guarantee any version checks
        :param 'MetadataSourceResponse' source: Source of the content.  This is where/how it was created.
        :param _builtins.str version: Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM metadata best practices.  Can also be any string, but then we cannot guarantee any version checks
        :param 'MetadataAuthorResponse' author: The creator of the content item.
        :param 'MetadataCategoriesResponse' categories: Categories for the item
        :param _builtins.str content_schema_version: Schema version of the content. Can be used to distinguish between different flow based on the schema version
        :param _builtins.str custom_version: The custom version of the content. A optional free text
        :param 'MetadataDependenciesResponse' dependencies: Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        :param _builtins.str first_publish_date: first publish date content item
        :param _builtins.str icon: the icon identifier. this id can later be fetched from the content metadata
        :param _builtins.str last_publish_date: last publish date for the content item
        :param Any main_template: The JSON of the ARM template to deploy active content. Expandable.
        :param _builtins.str package_kind: the packageKind of the package contains this template
        :param _builtins.str package_name: the name of the package contains this template
        :param Sequence[_builtins.str] preview_images: preview image file names. These will be taken from the solution artifacts
        :param Sequence[_builtins.str] preview_images_dark: preview image file names. These will be taken from the solution artifacts. used for dark theme support
        :param Sequence[_builtins.str] providers: Providers for the content item
        :param 'MetadataSupportResponse' support: Support information for the template - type, name, contact information
        :param Sequence[_builtins.str] threat_analysis_tactics: the tactics the resource covers
        :param Sequence[_builtins.str] threat_analysis_techniques: the techniques the resource covers, these have to be aligned with the tactics being used
        """
        pulumi.set(__self__, "content_id", content_id)
        pulumi.set(__self__, "content_kind", content_kind)
        pulumi.set(__self__, "content_product_id", content_product_id)
        pulumi.set(__self__, "dependant_templates", dependant_templates)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "is_deprecated", is_deprecated)
        pulumi.set(__self__, "package_id", package_id)
        pulumi.set(__self__, "package_version", package_version)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "version", version)
        if author is not None:
            pulumi.set(__self__, "author", author)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if content_schema_version is not None:
            pulumi.set(__self__, "content_schema_version", content_schema_version)
        if custom_version is not None:
            pulumi.set(__self__, "custom_version", custom_version)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if first_publish_date is not None:
            pulumi.set(__self__, "first_publish_date", first_publish_date)
        if icon is not None:
            pulumi.set(__self__, "icon", icon)
        if last_publish_date is not None:
            pulumi.set(__self__, "last_publish_date", last_publish_date)
        if main_template is not None:
            pulumi.set(__self__, "main_template", main_template)
        if package_kind is not None:
            pulumi.set(__self__, "package_kind", package_kind)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if preview_images is not None:
            pulumi.set(__self__, "preview_images", preview_images)
        if preview_images_dark is not None:
            pulumi.set(__self__, "preview_images_dark", preview_images_dark)
        if providers is not None:
            pulumi.set(__self__, "providers", providers)
        if support is not None:
            pulumi.set(__self__, "support", support)
        if threat_analysis_tactics is not None:
            pulumi.set(__self__, "threat_analysis_tactics", threat_analysis_tactics)
        if threat_analysis_techniques is not None:
            pulumi.set(__self__, "threat_analysis_techniques", threat_analysis_techniques)

    @_builtins.property
    @pulumi.getter(name="contentId")
    def content_id(self) -> _builtins.str:
        """
        Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        """
        return pulumi.get(self, "content_id")

    @_builtins.property
    @pulumi.getter(name="contentKind")
    def content_kind(self) -> _builtins.str:
        """
        The kind of content the template is for.
        """
        return pulumi.get(self, "content_kind")

    @_builtins.property
    @pulumi.getter(name="contentProductId")
    def content_product_id(self) -> _builtins.str:
        """
        Unique ID for the content. It should be generated based on the contentId of the package, contentId of the template, contentKind of the template and the contentVersion of the template
        """
        return pulumi.get(self, "content_product_id")

    @_builtins.property
    @pulumi.getter(name="dependantTemplates")
    def dependant_templates(self) -> Sequence['outputs.TemplatePropertiesResponse']:
        """
        Dependant templates. Expandable.
        """
        return pulumi.get(self, "dependant_templates")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The display name of the template
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="isDeprecated")
    def is_deprecated(self) -> _builtins.str:
        """
        Flag indicates if this template is deprecated
        """
        return pulumi.get(self, "is_deprecated")

    @_builtins.property
    @pulumi.getter(name="packageId")
    def package_id(self) -> _builtins.str:
        """
        the package Id contains this template
        """
        return pulumi.get(self, "package_id")

    @_builtins.property
    @pulumi.getter(name="packageVersion")
    def package_version(self) -> _builtins.str:
        """
        Version of the package.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM metadata best practices.  Can also be any string, but then we cannot guarantee any version checks
        """
        return pulumi.get(self, "package_version")

    @_builtins.property
    @pulumi.getter
    def source(self) -> 'outputs.MetadataSourceResponse':
        """
        Source of the content.  This is where/how it was created.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM metadata best practices.  Can also be any string, but then we cannot guarantee any version checks
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def author(self) -> Optional['outputs.MetadataAuthorResponse']:
        """
        The creator of the content item.
        """
        return pulumi.get(self, "author")

    @_builtins.property
    @pulumi.getter
    def categories(self) -> Optional['outputs.MetadataCategoriesResponse']:
        """
        Categories for the item
        """
        return pulumi.get(self, "categories")

    @_builtins.property
    @pulumi.getter(name="contentSchemaVersion")
    def content_schema_version(self) -> Optional[_builtins.str]:
        """
        Schema version of the content. Can be used to distinguish between different flow based on the schema version
        """
        return pulumi.get(self, "content_schema_version")

    @_builtins.property
    @pulumi.getter(name="customVersion")
    def custom_version(self) -> Optional[_builtins.str]:
        """
        The custom version of the content. A optional free text
        """
        return pulumi.get(self, "custom_version")

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Optional['outputs.MetadataDependenciesResponse']:
        """
        Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        """
        return pulumi.get(self, "dependencies")

    @_builtins.property
    @pulumi.getter(name="firstPublishDate")
    def first_publish_date(self) -> Optional[_builtins.str]:
        """
        first publish date content item
        """
        return pulumi.get(self, "first_publish_date")

    @_builtins.property
    @pulumi.getter
    def icon(self) -> Optional[_builtins.str]:
        """
        the icon identifier. this id can later be fetched from the content metadata
        """
        return pulumi.get(self, "icon")

    @_builtins.property
    @pulumi.getter(name="lastPublishDate")
    def last_publish_date(self) -> Optional[_builtins.str]:
        """
        last publish date for the content item
        """
        return pulumi.get(self, "last_publish_date")

    @_builtins.property
    @pulumi.getter(name="mainTemplate")
    def main_template(self) -> Optional[Any]:
        """
        The JSON of the ARM template to deploy active content. Expandable.
        """
        return pulumi.get(self, "main_template")

    @_builtins.property
    @pulumi.getter(name="packageKind")
    def package_kind(self) -> Optional[_builtins.str]:
        """
        the packageKind of the package contains this template
        """
        return pulumi.get(self, "package_kind")

    @_builtins.property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[_builtins.str]:
        """
        the name of the package contains this template
        """
        return pulumi.get(self, "package_name")

    @_builtins.property
    @pulumi.getter(name="previewImages")
    def preview_images(self) -> Optional[Sequence[_builtins.str]]:
        """
        preview image file names. These will be taken from the solution artifacts
        """
        return pulumi.get(self, "preview_images")

    @_builtins.property
    @pulumi.getter(name="previewImagesDark")
    def preview_images_dark(self) -> Optional[Sequence[_builtins.str]]:
        """
        preview image file names. These will be taken from the solution artifacts. used for dark theme support
        """
        return pulumi.get(self, "preview_images_dark")

    @_builtins.property
    @pulumi.getter
    def providers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Providers for the content item
        """
        return pulumi.get(self, "providers")

    @_builtins.property
    @pulumi.getter
    def support(self) -> Optional['outputs.MetadataSupportResponse']:
        """
        Support information for the template - type, name, contact information
        """
        return pulumi.get(self, "support")

    @_builtins.property
    @pulumi.getter(name="threatAnalysisTactics")
    def threat_analysis_tactics(self) -> Optional[Sequence[_builtins.str]]:
        """
        the tactics the resource covers
        """
        return pulumi.get(self, "threat_analysis_tactics")

    @_builtins.property
    @pulumi.getter(name="threatAnalysisTechniques")
    def threat_analysis_techniques(self) -> Optional[Sequence[_builtins.str]]:
        """
        the techniques the resource covers, these have to be aligned with the tactics being used
        """
        return pulumi.get(self, "threat_analysis_techniques")


@pulumi.output_type
class TimelineAggregationResponse(dict):
    """
    timeline aggregation information per kind
    """
    def __init__(__self__, *,
                 count: _builtins.int,
                 kind: _builtins.str):
        """
        timeline aggregation information per kind
        :param _builtins.int count: the total items found for a kind
        :param _builtins.str kind: the query kind
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter
    def count(self) -> _builtins.int:
        """
        the total items found for a kind
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        the query kind
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class TimelineErrorResponse(dict):
    """
    Timeline Query Errors.
    """
    def __init__(__self__, *,
                 error_message: _builtins.str,
                 kind: _builtins.str,
                 query_id: Optional[_builtins.str] = None):
        """
        Timeline Query Errors.
        :param _builtins.str error_message: the error message
        :param _builtins.str kind: the query kind
        :param _builtins.str query_id: the query id
        """
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "kind", kind)
        if query_id is not None:
            pulumi.set(__self__, "query_id", query_id)

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> _builtins.str:
        """
        the error message
        """
        return pulumi.get(self, "error_message")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        the query kind
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="queryId")
    def query_id(self) -> Optional[_builtins.str]:
        """
        the query id
        """
        return pulumi.get(self, "query_id")


@pulumi.output_type
class TimelineResultsMetadataResponse(dict):
    """
    Expansion result metadata.
    """
    def __init__(__self__, *,
                 aggregations: Sequence['outputs.TimelineAggregationResponse'],
                 total_count: _builtins.int,
                 errors: Optional[Sequence['outputs.TimelineErrorResponse']] = None):
        """
        Expansion result metadata.
        :param Sequence['TimelineAggregationResponse'] aggregations: timeline aggregation per kind
        :param _builtins.int total_count: the total items found for the timeline request
        :param Sequence['TimelineErrorResponse'] errors: information about the failure queries
        """
        pulumi.set(__self__, "aggregations", aggregations)
        pulumi.set(__self__, "total_count", total_count)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)

    @_builtins.property
    @pulumi.getter
    def aggregations(self) -> Sequence['outputs.TimelineAggregationResponse']:
        """
        timeline aggregation per kind
        """
        return pulumi.get(self, "aggregations")

    @_builtins.property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> _builtins.int:
        """
        the total items found for the timeline request
        """
        return pulumi.get(self, "total_count")

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.TimelineErrorResponse']]:
        """
        information about the failure queries
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class UnlockUserActionResponse(dict):
    """
    Represents an unlock user action.
    """
    def __init__(__self__, *,
                 kind: _builtins.str,
                 failure_reason: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        Represents an unlock user action.
        :param _builtins.str kind: The kind of the action
               Expected value is 'UnlockUser'.
        :param _builtins.str failure_reason: The reason of the failure of the action. Empty if the action is successful.
        :param _builtins.str user: The user to unlock
        """
        pulumi.set(__self__, "kind", 'UnlockUser')
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        The kind of the action
        Expected value is 'UnlockUser'.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[_builtins.str]:
        """
        The reason of the failure of the action. Empty if the action is successful.
        """
        return pulumi.get(self, "failure_reason")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        The user to unlock
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class UserInfoResponse(dict):
    """
    User information that made some action
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectId":
            suggest = "object_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: _builtins.str,
                 name: _builtins.str,
                 object_id: Optional[_builtins.str] = None):
        """
        User information that made some action
        :param _builtins.str email: The email of the user.
        :param _builtins.str name: The name of the user.
        :param _builtins.str object_id: The object id of the user.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "name", name)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[_builtins.str]:
        """
        The object id of the user.
        """
        return pulumi.get(self, "object_id")


@pulumi.output_type
class ValidationErrorResponse(dict):
    """
    Describes an error encountered in the file during validation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessages":
            suggest = "error_messages"
        elif key == "recordIndex":
            suggest = "record_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ValidationErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ValidationErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ValidationErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_messages: Sequence[_builtins.str],
                 record_index: Optional[_builtins.int] = None):
        """
        Describes an error encountered in the file during validation.
        :param Sequence[_builtins.str] error_messages: A list of descriptions of the error.
        :param _builtins.int record_index: The number of the record that has the error.
        """
        pulumi.set(__self__, "error_messages", error_messages)
        if record_index is not None:
            pulumi.set(__self__, "record_index", record_index)

    @_builtins.property
    @pulumi.getter(name="errorMessages")
    def error_messages(self) -> Sequence[_builtins.str]:
        """
        A list of descriptions of the error.
        """
        return pulumi.get(self, "error_messages")

    @_builtins.property
    @pulumi.getter(name="recordIndex")
    def record_index(self) -> Optional[_builtins.int]:
        """
        The number of the record that has the error.
        """
        return pulumi.get(self, "record_index")


@pulumi.output_type
class WatchlistUserInfoResponse(dict):
    """
    User information that made some action
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectId":
            suggest = "object_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WatchlistUserInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WatchlistUserInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WatchlistUserInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: _builtins.str,
                 name: _builtins.str,
                 object_id: Optional[_builtins.str] = None):
        """
        User information that made some action
        :param _builtins.str email: The email of the user.
        :param _builtins.str name: The name of the user.
        :param _builtins.str object_id: The object id of the user.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "name", name)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[_builtins.str]:
        """
        The object id of the user.
        """
        return pulumi.get(self, "object_id")


@pulumi.output_type
class WebhookResponse(dict):
    """
    Detail about the webhook object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rotateWebhookSecret":
            suggest = "rotate_webhook_secret"
        elif key == "webhookId":
            suggest = "webhook_id"
        elif key == "webhookSecretUpdateTime":
            suggest = "webhook_secret_update_time"
        elif key == "webhookUrl":
            suggest = "webhook_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rotate_webhook_secret: Optional[_builtins.bool] = None,
                 webhook_id: Optional[_builtins.str] = None,
                 webhook_secret_update_time: Optional[_builtins.str] = None,
                 webhook_url: Optional[_builtins.str] = None):
        """
        Detail about the webhook object.
        :param _builtins.bool rotate_webhook_secret: A flag to instruct the backend service to rotate webhook secret.
        :param _builtins.str webhook_id: Unique identifier for the webhook.
        :param _builtins.str webhook_secret_update_time: Time when the webhook secret was updated.
        :param _builtins.str webhook_url: URL that gets invoked by the webhook.
        """
        if rotate_webhook_secret is not None:
            pulumi.set(__self__, "rotate_webhook_secret", rotate_webhook_secret)
        if webhook_id is not None:
            pulumi.set(__self__, "webhook_id", webhook_id)
        if webhook_secret_update_time is not None:
            pulumi.set(__self__, "webhook_secret_update_time", webhook_secret_update_time)
        if webhook_url is not None:
            pulumi.set(__self__, "webhook_url", webhook_url)

    @_builtins.property
    @pulumi.getter(name="rotateWebhookSecret")
    def rotate_webhook_secret(self) -> Optional[_builtins.bool]:
        """
        A flag to instruct the backend service to rotate webhook secret.
        """
        return pulumi.get(self, "rotate_webhook_secret")

    @_builtins.property
    @pulumi.getter(name="webhookId")
    def webhook_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier for the webhook.
        """
        return pulumi.get(self, "webhook_id")

    @_builtins.property
    @pulumi.getter(name="webhookSecretUpdateTime")
    def webhook_secret_update_time(self) -> Optional[_builtins.str]:
        """
        Time when the webhook secret was updated.
        """
        return pulumi.get(self, "webhook_secret_update_time")

    @_builtins.property
    @pulumi.getter(name="webhookUrl")
    def webhook_url(self) -> Optional[_builtins.str]:
        """
        URL that gets invoked by the webhook.
        """
        return pulumi.get(self, "webhook_url")


