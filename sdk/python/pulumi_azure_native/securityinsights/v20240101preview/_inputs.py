# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AWSAuthModelArgs',
    'AWSAuthModelArgsDict',
    'ActivityEntityQueriesPropertiesQueryDefinitionsArgs',
    'ActivityEntityQueriesPropertiesQueryDefinitionsArgsDict',
    'AddIncidentTaskActionPropertiesArgs',
    'AddIncidentTaskActionPropertiesArgsDict',
    'AlertDetailsOverrideArgs',
    'AlertDetailsOverrideArgsDict',
    'AlertPropertyMappingArgs',
    'AlertPropertyMappingArgsDict',
    'AlertsDataTypeOfDataConnectorArgs',
    'AlertsDataTypeOfDataConnectorArgsDict',
    'ApiKeyAuthModelArgs',
    'ApiKeyAuthModelArgsDict',
    'AssignmentItemArgs',
    'AssignmentItemArgsDict',
    'AutomationRuleAddIncidentTaskActionArgs',
    'AutomationRuleAddIncidentTaskActionArgsDict',
    'AutomationRuleBooleanConditionArgs',
    'AutomationRuleBooleanConditionArgsDict',
    'AutomationRuleModifyPropertiesActionArgs',
    'AutomationRuleModifyPropertiesActionArgsDict',
    'AutomationRulePropertyArrayChangedValuesConditionArgs',
    'AutomationRulePropertyArrayChangedValuesConditionArgsDict',
    'AutomationRulePropertyArrayValuesConditionArgs',
    'AutomationRulePropertyArrayValuesConditionArgsDict',
    'AutomationRulePropertyValuesChangedConditionArgs',
    'AutomationRulePropertyValuesChangedConditionArgsDict',
    'AutomationRulePropertyValuesConditionArgs',
    'AutomationRulePropertyValuesConditionArgsDict',
    'AutomationRuleRunPlaybookActionArgs',
    'AutomationRuleRunPlaybookActionArgsDict',
    'AutomationRuleTriggeringLogicArgs',
    'AutomationRuleTriggeringLogicArgsDict',
    'AvailabilityArgs',
    'AvailabilityArgsDict',
    'AwsCloudTrailDataConnectorDataTypesLogsArgs',
    'AwsCloudTrailDataConnectorDataTypesLogsArgsDict',
    'AwsCloudTrailDataConnectorDataTypesArgs',
    'AwsCloudTrailDataConnectorDataTypesArgsDict',
    'AwsS3DataConnectorDataTypesLogsArgs',
    'AwsS3DataConnectorDataTypesLogsArgsDict',
    'AwsS3DataConnectorDataTypesArgs',
    'AwsS3DataConnectorDataTypesArgsDict',
    'BasicAuthModelArgs',
    'BasicAuthModelArgsDict',
    'BookmarkEntityMappingsArgs',
    'BookmarkEntityMappingsArgsDict',
    'BooleanConditionPropertiesArgs',
    'BooleanConditionPropertiesArgsDict',
    'CcpResponseConfigArgs',
    'CcpResponseConfigArgsDict',
    'ClientInfoArgs',
    'ClientInfoArgsDict',
    'CodelessConnectorPollingAuthPropertiesArgs',
    'CodelessConnectorPollingAuthPropertiesArgsDict',
    'CodelessConnectorPollingConfigPropertiesArgs',
    'CodelessConnectorPollingConfigPropertiesArgsDict',
    'CodelessConnectorPollingPagingPropertiesArgs',
    'CodelessConnectorPollingPagingPropertiesArgsDict',
    'CodelessConnectorPollingRequestPropertiesArgs',
    'CodelessConnectorPollingRequestPropertiesArgsDict',
    'CodelessConnectorPollingResponsePropertiesArgs',
    'CodelessConnectorPollingResponsePropertiesArgsDict',
    'CodelessUiConnectorConfigPropertiesConnectivityCriteriaArgs',
    'CodelessUiConnectorConfigPropertiesConnectivityCriteriaArgsDict',
    'CodelessUiConnectorConfigPropertiesDataTypesArgs',
    'CodelessUiConnectorConfigPropertiesDataTypesArgsDict',
    'CodelessUiConnectorConfigPropertiesGraphQueriesArgs',
    'CodelessUiConnectorConfigPropertiesGraphQueriesArgsDict',
    'CodelessUiConnectorConfigPropertiesInstructionStepsArgs',
    'CodelessUiConnectorConfigPropertiesInstructionStepsArgsDict',
    'CodelessUiConnectorConfigPropertiesSampleQueriesArgs',
    'CodelessUiConnectorConfigPropertiesSampleQueriesArgsDict',
    'CodelessUiConnectorConfigPropertiesArgs',
    'CodelessUiConnectorConfigPropertiesArgsDict',
    'ConnectivityCriterionArgs',
    'ConnectivityCriterionArgsDict',
    'ConnectorDataTypeArgs',
    'ConnectorDataTypeArgsDict',
    'ConnectorDefinitionsAvailabilityArgs',
    'ConnectorDefinitionsAvailabilityArgsDict',
    'ConnectorDefinitionsPermissionsArgs',
    'ConnectorDefinitionsPermissionsArgsDict',
    'ConnectorDefinitionsResourceProviderArgs',
    'ConnectorDefinitionsResourceProviderArgsDict',
    'CustomPermissionDetailsArgs',
    'CustomPermissionDetailsArgsDict',
    'CustomizableConnectionsConfigArgs',
    'CustomizableConnectionsConfigArgsDict',
    'CustomizableConnectorUiConfigArgs',
    'CustomizableConnectorUiConfigArgsDict',
    'DCRConfigurationArgs',
    'DCRConfigurationArgsDict',
    'DataConnectorDataTypeCommonArgs',
    'DataConnectorDataTypeCommonArgsDict',
    'Dynamics365DataConnectorDataTypesDynamics365CdsActivitiesArgs',
    'Dynamics365DataConnectorDataTypesDynamics365CdsActivitiesArgsDict',
    'Dynamics365DataConnectorDataTypesArgs',
    'Dynamics365DataConnectorDataTypesArgsDict',
    'EntityFieldMappingArgs',
    'EntityFieldMappingArgsDict',
    'EntityMappingArgs',
    'EntityMappingArgsDict',
    'EventGroupingSettingsArgs',
    'EventGroupingSettingsArgsDict',
    'FieldMappingArgs',
    'FieldMappingArgsDict',
    'FileMetadataArgs',
    'FileMetadataArgsDict',
    'FusionScenarioExclusionPatternArgs',
    'FusionScenarioExclusionPatternArgsDict',
    'FusionSourceSettingsArgs',
    'FusionSourceSettingsArgsDict',
    'FusionSourceSubTypeSettingArgs',
    'FusionSourceSubTypeSettingArgsDict',
    'FusionSubTypeSeverityFiltersItemArgs',
    'FusionSubTypeSeverityFiltersItemArgsDict',
    'FusionSubTypeSeverityFilterArgs',
    'FusionSubTypeSeverityFilterArgsDict',
    'GCPAuthModelArgs',
    'GCPAuthModelArgsDict',
    'GCPAuthPropertiesArgs',
    'GCPAuthPropertiesArgsDict',
    'GCPRequestPropertiesArgs',
    'GCPRequestPropertiesArgsDict',
    'GenericBlobSbsAuthModelArgs',
    'GenericBlobSbsAuthModelArgsDict',
    'GitHubAuthModelArgs',
    'GitHubAuthModelArgsDict',
    'GraphQueryArgs',
    'GraphQueryArgsDict',
    'GroupingConfigurationArgs',
    'GroupingConfigurationArgsDict',
    'HuntOwnerArgs',
    'HuntOwnerArgsDict',
    'IncidentConfigurationArgs',
    'IncidentConfigurationArgsDict',
    'IncidentInfoArgs',
    'IncidentInfoArgsDict',
    'IncidentLabelArgs',
    'IncidentLabelArgsDict',
    'IncidentOwnerInfoArgs',
    'IncidentOwnerInfoArgsDict',
    'IncidentPropertiesActionArgs',
    'IncidentPropertiesActionArgsDict',
    'InstructionStepDetailsArgs',
    'InstructionStepDetailsArgsDict',
    'InstructionStepsInstructionsArgs',
    'InstructionStepsInstructionsArgsDict',
    'InstructionStepArgs',
    'InstructionStepArgsDict',
    'JwtAuthModelArgs',
    'JwtAuthModelArgsDict',
    'MCASDataConnectorDataTypesArgs',
    'MCASDataConnectorDataTypesArgsDict',
    'MSTIDataConnectorDataTypesMicrosoftEmergingThreatFeedArgs',
    'MSTIDataConnectorDataTypesMicrosoftEmergingThreatFeedArgsDict',
    'MSTIDataConnectorDataTypesArgs',
    'MSTIDataConnectorDataTypesArgsDict',
    'MTPDataConnectorDataTypesAlertsArgs',
    'MTPDataConnectorDataTypesAlertsArgsDict',
    'MTPDataConnectorDataTypesIncidentsArgs',
    'MTPDataConnectorDataTypesIncidentsArgsDict',
    'MTPDataConnectorDataTypesArgs',
    'MTPDataConnectorDataTypesArgsDict',
    'MetadataAuthorArgs',
    'MetadataAuthorArgsDict',
    'MetadataCategoriesArgs',
    'MetadataCategoriesArgsDict',
    'MetadataDependenciesArgs',
    'MetadataDependenciesArgsDict',
    'MetadataSourceArgs',
    'MetadataSourceArgsDict',
    'MetadataSupportArgs',
    'MetadataSupportArgsDict',
    'MicrosoftPurviewInformationProtectionConnectorDataTypesLogsArgs',
    'MicrosoftPurviewInformationProtectionConnectorDataTypesLogsArgsDict',
    'MicrosoftPurviewInformationProtectionConnectorDataTypesArgs',
    'MicrosoftPurviewInformationProtectionConnectorDataTypesArgsDict',
    'MtpFilteredProvidersArgs',
    'MtpFilteredProvidersArgsDict',
    'NoneAuthModelArgs',
    'NoneAuthModelArgsDict',
    'OAuthModelArgs',
    'OAuthModelArgsDict',
    'Office365ProjectConnectorDataTypesLogsArgs',
    'Office365ProjectConnectorDataTypesLogsArgsDict',
    'Office365ProjectConnectorDataTypesArgs',
    'Office365ProjectConnectorDataTypesArgsDict',
    'OfficeDataConnectorDataTypesExchangeArgs',
    'OfficeDataConnectorDataTypesExchangeArgsDict',
    'OfficeDataConnectorDataTypesSharePointArgs',
    'OfficeDataConnectorDataTypesSharePointArgsDict',
    'OfficeDataConnectorDataTypesTeamsArgs',
    'OfficeDataConnectorDataTypesTeamsArgsDict',
    'OfficeDataConnectorDataTypesArgs',
    'OfficeDataConnectorDataTypesArgsDict',
    'OfficePowerBIConnectorDataTypesLogsArgs',
    'OfficePowerBIConnectorDataTypesLogsArgsDict',
    'OfficePowerBIConnectorDataTypesArgs',
    'OfficePowerBIConnectorDataTypesArgsDict',
    'OracleAuthModelArgs',
    'OracleAuthModelArgsDict',
    'PermissionsCustomsArgs',
    'PermissionsCustomsArgsDict',
    'PermissionsResourceProviderArgs',
    'PermissionsResourceProviderArgsDict',
    'PermissionsArgs',
    'PermissionsArgsDict',
    'PlaybookActionPropertiesArgs',
    'PlaybookActionPropertiesArgsDict',
    'PropertyArrayChangedConditionPropertiesArgs',
    'PropertyArrayChangedConditionPropertiesArgsDict',
    'PropertyArrayConditionPropertiesArgs',
    'PropertyArrayConditionPropertiesArgsDict',
    'PropertyChangedConditionPropertiesArgs',
    'PropertyChangedConditionPropertiesArgsDict',
    'PropertyConditionPropertiesArgs',
    'PropertyConditionPropertiesArgsDict',
    'RequiredPermissionsArgs',
    'RequiredPermissionsArgsDict',
    'ResourceProviderRequiredPermissionsArgs',
    'ResourceProviderRequiredPermissionsArgsDict',
    'RestApiPollerRequestConfigArgs',
    'RestApiPollerRequestConfigArgsDict',
    'RestApiPollerRequestPagingConfigArgs',
    'RestApiPollerRequestPagingConfigArgsDict',
    'SecurityMLAnalyticsSettingsDataSourceArgs',
    'SecurityMLAnalyticsSettingsDataSourceArgsDict',
    'SentinelEntityMappingArgs',
    'SentinelEntityMappingArgsDict',
    'SessionAuthModelArgs',
    'SessionAuthModelArgsDict',
    'TIDataConnectorDataTypesIndicatorsArgs',
    'TIDataConnectorDataTypesIndicatorsArgsDict',
    'TIDataConnectorDataTypesArgs',
    'TIDataConnectorDataTypesArgsDict',
    'ThreatIntelligenceExternalReferenceArgs',
    'ThreatIntelligenceExternalReferenceArgsDict',
    'ThreatIntelligenceGranularMarkingModelArgs',
    'ThreatIntelligenceGranularMarkingModelArgsDict',
    'ThreatIntelligenceKillChainPhaseArgs',
    'ThreatIntelligenceKillChainPhaseArgsDict',
    'ThreatIntelligenceParsedPatternTypeValueArgs',
    'ThreatIntelligenceParsedPatternTypeValueArgsDict',
    'ThreatIntelligenceParsedPatternArgs',
    'ThreatIntelligenceParsedPatternArgsDict',
    'TiTaxiiDataConnectorDataTypesTaxiiClientArgs',
    'TiTaxiiDataConnectorDataTypesTaxiiClientArgsDict',
    'TiTaxiiDataConnectorDataTypesArgs',
    'TiTaxiiDataConnectorDataTypesArgsDict',
    'UserInfoArgs',
    'UserInfoArgsDict',
    'WatchlistUserInfoArgs',
    'WatchlistUserInfoArgsDict',
]

MYPY = False

if not MYPY:
    class AWSAuthModelArgsDict(TypedDict):
        """
        Model for API authentication with AWS.
        """
        role_arn: pulumi.Input[str]
        """
        AWS STS assume role ARN
        """
        type: pulumi.Input[str]
        """
        Type of paging
        Expected value is 'AWS'.
        """
        external_id: NotRequired[pulumi.Input[str]]
        """
        AWS STS assume role external ID. This is used to prevent the confused deputy problem: 'https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html'
        """
elif False:
    AWSAuthModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AWSAuthModelArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 type: pulumi.Input[str],
                 external_id: Optional[pulumi.Input[str]] = None):
        """
        Model for API authentication with AWS.
        :param pulumi.Input[str] role_arn: AWS STS assume role ARN
        :param pulumi.Input[str] type: Type of paging
               Expected value is 'AWS'.
        :param pulumi.Input[str] external_id: AWS STS assume role external ID. This is used to prevent the confused deputy problem: 'https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html'
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "type", 'AWS')
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        AWS STS assume role ARN
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of paging
        Expected value is 'AWS'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        """
        AWS STS assume role external ID. This is used to prevent the confused deputy problem: 'https://docs.aws.amazon.com/IAM/latest/UserGuide/confused-deputy.html'
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class ActivityEntityQueriesPropertiesQueryDefinitionsArgsDict(TypedDict):
        """
        The Activity query definitions
        """
        query: NotRequired[pulumi.Input[str]]
        """
        The Activity query to run on a given entity
        """
elif False:
    ActivityEntityQueriesPropertiesQueryDefinitionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActivityEntityQueriesPropertiesQueryDefinitionsArgs:
    def __init__(__self__, *,
                 query: Optional[pulumi.Input[str]] = None):
        """
        The Activity query definitions
        :param pulumi.Input[str] query: The Activity query to run on a given entity
        """
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        The Activity query to run on a given entity
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


if not MYPY:
    class AddIncidentTaskActionPropertiesArgsDict(TypedDict):
        title: pulumi.Input[str]
        """
        The title of the task.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the task.
        """
elif False:
    AddIncidentTaskActionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddIncidentTaskActionPropertiesArgs:
    def __init__(__self__, *,
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: The title of the task.
        :param pulumi.Input[str] description: The description of the task.
        """
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        """
        The title of the task.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the task.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class AlertDetailsOverrideArgsDict(TypedDict):
        """
        Settings for how to dynamically override alert static details
        """
        alert_description_format: NotRequired[pulumi.Input[str]]
        """
        the format containing columns name(s) to override the alert description
        """
        alert_display_name_format: NotRequired[pulumi.Input[str]]
        """
        the format containing columns name(s) to override the alert name
        """
        alert_dynamic_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['AlertPropertyMappingArgsDict']]]]
        """
        List of additional dynamic properties to override
        """
        alert_severity_column_name: NotRequired[pulumi.Input[str]]
        """
        the column name to take the alert severity from
        """
        alert_tactics_column_name: NotRequired[pulumi.Input[str]]
        """
        the column name to take the alert tactics from
        """
elif False:
    AlertDetailsOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertDetailsOverrideArgs:
    def __init__(__self__, *,
                 alert_description_format: Optional[pulumi.Input[str]] = None,
                 alert_display_name_format: Optional[pulumi.Input[str]] = None,
                 alert_dynamic_properties: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPropertyMappingArgs']]]] = None,
                 alert_severity_column_name: Optional[pulumi.Input[str]] = None,
                 alert_tactics_column_name: Optional[pulumi.Input[str]] = None):
        """
        Settings for how to dynamically override alert static details
        :param pulumi.Input[str] alert_description_format: the format containing columns name(s) to override the alert description
        :param pulumi.Input[str] alert_display_name_format: the format containing columns name(s) to override the alert name
        :param pulumi.Input[Sequence[pulumi.Input['AlertPropertyMappingArgs']]] alert_dynamic_properties: List of additional dynamic properties to override
        :param pulumi.Input[str] alert_severity_column_name: the column name to take the alert severity from
        :param pulumi.Input[str] alert_tactics_column_name: the column name to take the alert tactics from
        """
        if alert_description_format is not None:
            pulumi.set(__self__, "alert_description_format", alert_description_format)
        if alert_display_name_format is not None:
            pulumi.set(__self__, "alert_display_name_format", alert_display_name_format)
        if alert_dynamic_properties is not None:
            pulumi.set(__self__, "alert_dynamic_properties", alert_dynamic_properties)
        if alert_severity_column_name is not None:
            pulumi.set(__self__, "alert_severity_column_name", alert_severity_column_name)
        if alert_tactics_column_name is not None:
            pulumi.set(__self__, "alert_tactics_column_name", alert_tactics_column_name)

    @property
    @pulumi.getter(name="alertDescriptionFormat")
    def alert_description_format(self) -> Optional[pulumi.Input[str]]:
        """
        the format containing columns name(s) to override the alert description
        """
        return pulumi.get(self, "alert_description_format")

    @alert_description_format.setter
    def alert_description_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alert_description_format", value)

    @property
    @pulumi.getter(name="alertDisplayNameFormat")
    def alert_display_name_format(self) -> Optional[pulumi.Input[str]]:
        """
        the format containing columns name(s) to override the alert name
        """
        return pulumi.get(self, "alert_display_name_format")

    @alert_display_name_format.setter
    def alert_display_name_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alert_display_name_format", value)

    @property
    @pulumi.getter(name="alertDynamicProperties")
    def alert_dynamic_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertPropertyMappingArgs']]]]:
        """
        List of additional dynamic properties to override
        """
        return pulumi.get(self, "alert_dynamic_properties")

    @alert_dynamic_properties.setter
    def alert_dynamic_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertPropertyMappingArgs']]]]):
        pulumi.set(self, "alert_dynamic_properties", value)

    @property
    @pulumi.getter(name="alertSeverityColumnName")
    def alert_severity_column_name(self) -> Optional[pulumi.Input[str]]:
        """
        the column name to take the alert severity from
        """
        return pulumi.get(self, "alert_severity_column_name")

    @alert_severity_column_name.setter
    def alert_severity_column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alert_severity_column_name", value)

    @property
    @pulumi.getter(name="alertTacticsColumnName")
    def alert_tactics_column_name(self) -> Optional[pulumi.Input[str]]:
        """
        the column name to take the alert tactics from
        """
        return pulumi.get(self, "alert_tactics_column_name")

    @alert_tactics_column_name.setter
    def alert_tactics_column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alert_tactics_column_name", value)


if not MYPY:
    class AlertPropertyMappingArgsDict(TypedDict):
        """
        A single alert property mapping to override
        """
        alert_property: NotRequired[pulumi.Input[Union[str, 'AlertProperty']]]
        """
        The V3 alert property
        """
        value: NotRequired[pulumi.Input[str]]
        """
        the column name to use to override this property
        """
elif False:
    AlertPropertyMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertPropertyMappingArgs:
    def __init__(__self__, *,
                 alert_property: Optional[pulumi.Input[Union[str, 'AlertProperty']]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        A single alert property mapping to override
        :param pulumi.Input[Union[str, 'AlertProperty']] alert_property: The V3 alert property
        :param pulumi.Input[str] value: the column name to use to override this property
        """
        if alert_property is not None:
            pulumi.set(__self__, "alert_property", alert_property)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="alertProperty")
    def alert_property(self) -> Optional[pulumi.Input[Union[str, 'AlertProperty']]]:
        """
        The V3 alert property
        """
        return pulumi.get(self, "alert_property")

    @alert_property.setter
    def alert_property(self, value: Optional[pulumi.Input[Union[str, 'AlertProperty']]]):
        pulumi.set(self, "alert_property", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        the column name to use to override this property
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AlertsDataTypeOfDataConnectorArgsDict(TypedDict):
        """
        Alerts data type for data connectors.
        """
        alerts: pulumi.Input['DataConnectorDataTypeCommonArgsDict']
        """
        Alerts data type connection.
        """
elif False:
    AlertsDataTypeOfDataConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertsDataTypeOfDataConnectorArgs:
    def __init__(__self__, *,
                 alerts: pulumi.Input['DataConnectorDataTypeCommonArgs']):
        """
        Alerts data type for data connectors.
        :param pulumi.Input['DataConnectorDataTypeCommonArgs'] alerts: Alerts data type connection.
        """
        pulumi.set(__self__, "alerts", alerts)

    @property
    @pulumi.getter
    def alerts(self) -> pulumi.Input['DataConnectorDataTypeCommonArgs']:
        """
        Alerts data type connection.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: pulumi.Input['DataConnectorDataTypeCommonArgs']):
        pulumi.set(self, "alerts", value)


if not MYPY:
    class ApiKeyAuthModelArgsDict(TypedDict):
        """
        Model for authentication with the API Key. Will result in additional header on the request (default behavior) to the remote server: 'ApiKeyName: ApiKeyIdentifier ApiKey'. If 'IsApiKeyInPostPayload' is true it will send it in the body of the request and not the header.
        """
        api_key: pulumi.Input[str]
        """
        API Key for the user secret key credential
        """
        api_key_name: pulumi.Input[str]
        """
        API Key name
        """
        type: pulumi.Input[str]
        """
        Type of paging
        Expected value is 'APIKey'.
        """
        api_key_identifier: NotRequired[pulumi.Input[str]]
        """
        API Key Identifier
        """
        is_api_key_in_post_payload: NotRequired[pulumi.Input[bool]]
        """
        Flag to indicate if API key is set in HTTP POST payload
        """
elif False:
    ApiKeyAuthModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiKeyAuthModelArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 api_key_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 api_key_identifier: Optional[pulumi.Input[str]] = None,
                 is_api_key_in_post_payload: Optional[pulumi.Input[bool]] = None):
        """
        Model for authentication with the API Key. Will result in additional header on the request (default behavior) to the remote server: 'ApiKeyName: ApiKeyIdentifier ApiKey'. If 'IsApiKeyInPostPayload' is true it will send it in the body of the request and not the header.
        :param pulumi.Input[str] api_key: API Key for the user secret key credential
        :param pulumi.Input[str] api_key_name: API Key name
        :param pulumi.Input[str] type: Type of paging
               Expected value is 'APIKey'.
        :param pulumi.Input[str] api_key_identifier: API Key Identifier
        :param pulumi.Input[bool] is_api_key_in_post_payload: Flag to indicate if API key is set in HTTP POST payload
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_key_name", api_key_name)
        pulumi.set(__self__, "type", 'APIKey')
        if api_key_identifier is not None:
            pulumi.set(__self__, "api_key_identifier", api_key_identifier)
        if is_api_key_in_post_payload is not None:
            pulumi.set(__self__, "is_api_key_in_post_payload", is_api_key_in_post_payload)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key for the user secret key credential
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="apiKeyName")
    def api_key_name(self) -> pulumi.Input[str]:
        """
        API Key name
        """
        return pulumi.get(self, "api_key_name")

    @api_key_name.setter
    def api_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of paging
        Expected value is 'APIKey'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="apiKeyIdentifier")
    def api_key_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        API Key Identifier
        """
        return pulumi.get(self, "api_key_identifier")

    @api_key_identifier.setter
    def api_key_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key_identifier", value)

    @property
    @pulumi.getter(name="isApiKeyInPostPayload")
    def is_api_key_in_post_payload(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to indicate if API key is set in HTTP POST payload
        """
        return pulumi.get(self, "is_api_key_in_post_payload")

    @is_api_key_in_post_payload.setter
    def is_api_key_in_post_payload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_api_key_in_post_payload", value)


if not MYPY:
    class AssignmentItemArgsDict(TypedDict):
        """
        An entity describing a content item.
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        The resource id of the content item
        """
elif False:
    AssignmentItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AssignmentItemArgs:
    def __init__(__self__, *,
                 resource_id: Optional[pulumi.Input[str]] = None):
        """
        An entity describing a content item.
        :param pulumi.Input[str] resource_id: The resource id of the content item
        """
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource id of the content item
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)


if not MYPY:
    class AutomationRuleAddIncidentTaskActionArgsDict(TypedDict):
        """
        Describes an automation rule action to add a task to an incident
        """
        action_type: pulumi.Input[str]
        """
        The type of the automation rule action.
        Expected value is 'AddIncidentTask'.
        """
        order: pulumi.Input[int]
        action_configuration: NotRequired[pulumi.Input['AddIncidentTaskActionPropertiesArgsDict']]
elif False:
    AutomationRuleAddIncidentTaskActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleAddIncidentTaskActionArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 order: pulumi.Input[int],
                 action_configuration: Optional[pulumi.Input['AddIncidentTaskActionPropertiesArgs']] = None):
        """
        Describes an automation rule action to add a task to an incident
        :param pulumi.Input[str] action_type: The type of the automation rule action.
               Expected value is 'AddIncidentTask'.
        """
        pulumi.set(__self__, "action_type", 'AddIncidentTask')
        pulumi.set(__self__, "order", order)
        if action_configuration is not None:
            pulumi.set(__self__, "action_configuration", action_configuration)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        The type of the automation rule action.
        Expected value is 'AddIncidentTask'.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional[pulumi.Input['AddIncidentTaskActionPropertiesArgs']]:
        return pulumi.get(self, "action_configuration")

    @action_configuration.setter
    def action_configuration(self, value: Optional[pulumi.Input['AddIncidentTaskActionPropertiesArgs']]):
        pulumi.set(self, "action_configuration", value)


if not MYPY:
    class AutomationRuleBooleanConditionArgsDict(TypedDict):
        inner_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['BooleanConditionPropertiesArgsDict', 'PropertyArrayChangedConditionPropertiesArgsDict', 'PropertyArrayConditionPropertiesArgsDict', 'PropertyChangedConditionPropertiesArgsDict', 'PropertyConditionPropertiesArgsDict']]]]]
        operator: NotRequired[pulumi.Input[Union[str, 'AutomationRuleBooleanConditionSupportedOperator']]]
elif False:
    AutomationRuleBooleanConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleBooleanConditionArgs:
    def __init__(__self__, *,
                 inner_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['BooleanConditionPropertiesArgs', 'PropertyArrayChangedConditionPropertiesArgs', 'PropertyArrayConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]]] = None,
                 operator: Optional[pulumi.Input[Union[str, 'AutomationRuleBooleanConditionSupportedOperator']]] = None):
        if inner_conditions is not None:
            pulumi.set(__self__, "inner_conditions", inner_conditions)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="innerConditions")
    def inner_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['BooleanConditionPropertiesArgs', 'PropertyArrayChangedConditionPropertiesArgs', 'PropertyArrayConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]]]:
        return pulumi.get(self, "inner_conditions")

    @inner_conditions.setter
    def inner_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['BooleanConditionPropertiesArgs', 'PropertyArrayChangedConditionPropertiesArgs', 'PropertyArrayConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]]]):
        pulumi.set(self, "inner_conditions", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[Union[str, 'AutomationRuleBooleanConditionSupportedOperator']]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[Union[str, 'AutomationRuleBooleanConditionSupportedOperator']]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class AutomationRuleModifyPropertiesActionArgsDict(TypedDict):
        """
        Describes an automation rule action to modify an object's properties
        """
        action_type: pulumi.Input[str]
        """
        The type of the automation rule action.
        Expected value is 'ModifyProperties'.
        """
        order: pulumi.Input[int]
        action_configuration: NotRequired[pulumi.Input['IncidentPropertiesActionArgsDict']]
elif False:
    AutomationRuleModifyPropertiesActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleModifyPropertiesActionArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 order: pulumi.Input[int],
                 action_configuration: Optional[pulumi.Input['IncidentPropertiesActionArgs']] = None):
        """
        Describes an automation rule action to modify an object's properties
        :param pulumi.Input[str] action_type: The type of the automation rule action.
               Expected value is 'ModifyProperties'.
        """
        pulumi.set(__self__, "action_type", 'ModifyProperties')
        pulumi.set(__self__, "order", order)
        if action_configuration is not None:
            pulumi.set(__self__, "action_configuration", action_configuration)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        The type of the automation rule action.
        Expected value is 'ModifyProperties'.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional[pulumi.Input['IncidentPropertiesActionArgs']]:
        return pulumi.get(self, "action_configuration")

    @action_configuration.setter
    def action_configuration(self, value: Optional[pulumi.Input['IncidentPropertiesActionArgs']]):
        pulumi.set(self, "action_configuration", value)


if not MYPY:
    class AutomationRulePropertyArrayChangedValuesConditionArgsDict(TypedDict):
        array_type: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedArrayType']]]
        change_type: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedChangeType']]]
elif False:
    AutomationRulePropertyArrayChangedValuesConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRulePropertyArrayChangedValuesConditionArgs:
    def __init__(__self__, *,
                 array_type: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedArrayType']]] = None,
                 change_type: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedChangeType']]] = None):
        if array_type is not None:
            pulumi.set(__self__, "array_type", array_type)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)

    @property
    @pulumi.getter(name="arrayType")
    def array_type(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedArrayType']]]:
        return pulumi.get(self, "array_type")

    @array_type.setter
    def array_type(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedArrayType']]]):
        pulumi.set(self, "array_type", value)

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedChangeType']]]:
        return pulumi.get(self, "change_type")

    @change_type.setter
    def change_type(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayChangedConditionSupportedChangeType']]]):
        pulumi.set(self, "change_type", value)


if not MYPY:
    class AutomationRulePropertyArrayValuesConditionArgsDict(TypedDict):
        array_condition_type: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyArrayConditionSupportedArrayConditionType']]]
        array_type: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyArrayConditionSupportedArrayType']]]
        item_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['BooleanConditionPropertiesArgsDict', 'PropertyArrayChangedConditionPropertiesArgsDict', 'PropertyArrayConditionPropertiesArgsDict', 'PropertyChangedConditionPropertiesArgsDict', 'PropertyConditionPropertiesArgsDict']]]]]
elif False:
    AutomationRulePropertyArrayValuesConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRulePropertyArrayValuesConditionArgs:
    def __init__(__self__, *,
                 array_condition_type: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayConditionSupportedArrayConditionType']]] = None,
                 array_type: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayConditionSupportedArrayType']]] = None,
                 item_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['BooleanConditionPropertiesArgs', 'PropertyArrayChangedConditionPropertiesArgs', 'PropertyArrayConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]]] = None):
        if array_condition_type is not None:
            pulumi.set(__self__, "array_condition_type", array_condition_type)
        if array_type is not None:
            pulumi.set(__self__, "array_type", array_type)
        if item_conditions is not None:
            pulumi.set(__self__, "item_conditions", item_conditions)

    @property
    @pulumi.getter(name="arrayConditionType")
    def array_condition_type(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayConditionSupportedArrayConditionType']]]:
        return pulumi.get(self, "array_condition_type")

    @array_condition_type.setter
    def array_condition_type(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayConditionSupportedArrayConditionType']]]):
        pulumi.set(self, "array_condition_type", value)

    @property
    @pulumi.getter(name="arrayType")
    def array_type(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayConditionSupportedArrayType']]]:
        return pulumi.get(self, "array_type")

    @array_type.setter
    def array_type(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyArrayConditionSupportedArrayType']]]):
        pulumi.set(self, "array_type", value)

    @property
    @pulumi.getter(name="itemConditions")
    def item_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['BooleanConditionPropertiesArgs', 'PropertyArrayChangedConditionPropertiesArgs', 'PropertyArrayConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]]]:
        return pulumi.get(self, "item_conditions")

    @item_conditions.setter
    def item_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['BooleanConditionPropertiesArgs', 'PropertyArrayChangedConditionPropertiesArgs', 'PropertyArrayConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]]]):
        pulumi.set(self, "item_conditions", value)


if not MYPY:
    class AutomationRulePropertyValuesChangedConditionArgsDict(TypedDict):
        change_type: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedChangedType']]]
        operator: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]]
        property_name: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedPropertyType']]]
        property_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    AutomationRulePropertyValuesChangedConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRulePropertyValuesChangedConditionArgs:
    def __init__(__self__, *,
                 change_type: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedChangedType']]] = None,
                 operator: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]] = None,
                 property_name: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedPropertyType']]] = None,
                 property_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if property_values is not None:
            pulumi.set(__self__, "property_values", property_values)

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedChangedType']]]:
        return pulumi.get(self, "change_type")

    @change_type.setter
    def change_type(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedChangedType']]]):
        pulumi.set(self, "change_type", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedPropertyType']]]:
        return pulumi.get(self, "property_name")

    @property_name.setter
    def property_name(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyChangedConditionSupportedPropertyType']]]):
        pulumi.set(self, "property_name", value)

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "property_values")

    @property_values.setter
    def property_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "property_values", value)


if not MYPY:
    class AutomationRulePropertyValuesConditionArgsDict(TypedDict):
        operator: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]]
        property_name: NotRequired[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedProperty']]]
        """
        The property to evaluate in an automation rule property condition.
        """
        property_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    AutomationRulePropertyValuesConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRulePropertyValuesConditionArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]] = None,
                 property_name: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedProperty']]] = None,
                 property_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedProperty']] property_name: The property to evaluate in an automation rule property condition.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if property_values is not None:
            pulumi.set(__self__, "property_values", property_values)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedOperator']]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedProperty']]]:
        """
        The property to evaluate in an automation rule property condition.
        """
        return pulumi.get(self, "property_name")

    @property_name.setter
    def property_name(self, value: Optional[pulumi.Input[Union[str, 'AutomationRulePropertyConditionSupportedProperty']]]):
        pulumi.set(self, "property_name", value)

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "property_values")

    @property_values.setter
    def property_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "property_values", value)


if not MYPY:
    class AutomationRuleRunPlaybookActionArgsDict(TypedDict):
        """
        Describes an automation rule action to run a playbook
        """
        action_type: pulumi.Input[str]
        """
        The type of the automation rule action.
        Expected value is 'RunPlaybook'.
        """
        order: pulumi.Input[int]
        action_configuration: NotRequired[pulumi.Input['PlaybookActionPropertiesArgsDict']]
elif False:
    AutomationRuleRunPlaybookActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleRunPlaybookActionArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 order: pulumi.Input[int],
                 action_configuration: Optional[pulumi.Input['PlaybookActionPropertiesArgs']] = None):
        """
        Describes an automation rule action to run a playbook
        :param pulumi.Input[str] action_type: The type of the automation rule action.
               Expected value is 'RunPlaybook'.
        """
        pulumi.set(__self__, "action_type", 'RunPlaybook')
        pulumi.set(__self__, "order", order)
        if action_configuration is not None:
            pulumi.set(__self__, "action_configuration", action_configuration)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        The type of the automation rule action.
        Expected value is 'RunPlaybook'.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="actionConfiguration")
    def action_configuration(self) -> Optional[pulumi.Input['PlaybookActionPropertiesArgs']]:
        return pulumi.get(self, "action_configuration")

    @action_configuration.setter
    def action_configuration(self, value: Optional[pulumi.Input['PlaybookActionPropertiesArgs']]):
        pulumi.set(self, "action_configuration", value)


if not MYPY:
    class AutomationRuleTriggeringLogicArgsDict(TypedDict):
        """
        Describes automation rule triggering logic.
        """
        is_enabled: pulumi.Input[bool]
        """
        Determines whether the automation rule is enabled or disabled.
        """
        triggers_on: pulumi.Input[Union[str, 'TriggersOn']]
        triggers_when: pulumi.Input[Union[str, 'TriggersWhen']]
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['BooleanConditionPropertiesArgsDict', 'PropertyArrayChangedConditionPropertiesArgsDict', 'PropertyArrayConditionPropertiesArgsDict', 'PropertyChangedConditionPropertiesArgsDict', 'PropertyConditionPropertiesArgsDict']]]]]
        """
        The conditions to evaluate to determine if the automation rule should be triggered on a given object.
        """
        expiration_time_utc: NotRequired[pulumi.Input[str]]
        """
        Determines when the automation rule should automatically expire and be disabled.
        """
elif False:
    AutomationRuleTriggeringLogicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationRuleTriggeringLogicArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool],
                 triggers_on: pulumi.Input[Union[str, 'TriggersOn']],
                 triggers_when: pulumi.Input[Union[str, 'TriggersWhen']],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['BooleanConditionPropertiesArgs', 'PropertyArrayChangedConditionPropertiesArgs', 'PropertyArrayConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]]] = None,
                 expiration_time_utc: Optional[pulumi.Input[str]] = None):
        """
        Describes automation rule triggering logic.
        :param pulumi.Input[bool] is_enabled: Determines whether the automation rule is enabled or disabled.
        :param pulumi.Input[Sequence[pulumi.Input[Union['BooleanConditionPropertiesArgs', 'PropertyArrayChangedConditionPropertiesArgs', 'PropertyArrayConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]] conditions: The conditions to evaluate to determine if the automation rule should be triggered on a given object.
        :param pulumi.Input[str] expiration_time_utc: Determines when the automation rule should automatically expire and be disabled.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "triggers_on", triggers_on)
        pulumi.set(__self__, "triggers_when", triggers_when)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if expiration_time_utc is not None:
            pulumi.set(__self__, "expiration_time_utc", expiration_time_utc)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Determines whether the automation rule is enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="triggersOn")
    def triggers_on(self) -> pulumi.Input[Union[str, 'TriggersOn']]:
        return pulumi.get(self, "triggers_on")

    @triggers_on.setter
    def triggers_on(self, value: pulumi.Input[Union[str, 'TriggersOn']]):
        pulumi.set(self, "triggers_on", value)

    @property
    @pulumi.getter(name="triggersWhen")
    def triggers_when(self) -> pulumi.Input[Union[str, 'TriggersWhen']]:
        return pulumi.get(self, "triggers_when")

    @triggers_when.setter
    def triggers_when(self, value: pulumi.Input[Union[str, 'TriggersWhen']]):
        pulumi.set(self, "triggers_when", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['BooleanConditionPropertiesArgs', 'PropertyArrayChangedConditionPropertiesArgs', 'PropertyArrayConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]]]:
        """
        The conditions to evaluate to determine if the automation rule should be triggered on a given object.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['BooleanConditionPropertiesArgs', 'PropertyArrayChangedConditionPropertiesArgs', 'PropertyArrayConditionPropertiesArgs', 'PropertyChangedConditionPropertiesArgs', 'PropertyConditionPropertiesArgs']]]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="expirationTimeUtc")
    def expiration_time_utc(self) -> Optional[pulumi.Input[str]]:
        """
        Determines when the automation rule should automatically expire and be disabled.
        """
        return pulumi.get(self, "expiration_time_utc")

    @expiration_time_utc.setter
    def expiration_time_utc(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration_time_utc", value)


if not MYPY:
    class AvailabilityArgsDict(TypedDict):
        """
        Connector Availability Status
        """
        is_preview: NotRequired[pulumi.Input[bool]]
        """
        Set connector as preview
        """
        status: NotRequired[pulumi.Input[int]]
        """
        The connector Availability Status
        """
elif False:
    AvailabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AvailabilityArgs:
    def __init__(__self__, *,
                 is_preview: Optional[pulumi.Input[bool]] = None,
                 status: Optional[pulumi.Input[int]] = None):
        """
        Connector Availability Status
        :param pulumi.Input[bool] is_preview: Set connector as preview
        :param pulumi.Input[int] status: The connector Availability Status
        """
        if is_preview is not None:
            pulumi.set(__self__, "is_preview", is_preview)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="isPreview")
    def is_preview(self) -> Optional[pulumi.Input[bool]]:
        """
        Set connector as preview
        """
        return pulumi.get(self, "is_preview")

    @is_preview.setter
    def is_preview(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_preview", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[int]]:
        """
        The connector Availability Status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class AwsCloudTrailDataConnectorDataTypesLogsArgsDict(TypedDict):
        """
        Logs data type.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    AwsCloudTrailDataConnectorDataTypesLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsCloudTrailDataConnectorDataTypesLogsArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Logs data type.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class AwsCloudTrailDataConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for Amazon Web Services CloudTrail data connector.
        """
        logs: pulumi.Input['AwsCloudTrailDataConnectorDataTypesLogsArgsDict']
        """
        Logs data type.
        """
elif False:
    AwsCloudTrailDataConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsCloudTrailDataConnectorDataTypesArgs:
    def __init__(__self__, *,
                 logs: pulumi.Input['AwsCloudTrailDataConnectorDataTypesLogsArgs']):
        """
        The available data types for Amazon Web Services CloudTrail data connector.
        :param pulumi.Input['AwsCloudTrailDataConnectorDataTypesLogsArgs'] logs: Logs data type.
        """
        pulumi.set(__self__, "logs", logs)

    @property
    @pulumi.getter
    def logs(self) -> pulumi.Input['AwsCloudTrailDataConnectorDataTypesLogsArgs']:
        """
        Logs data type.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: pulumi.Input['AwsCloudTrailDataConnectorDataTypesLogsArgs']):
        pulumi.set(self, "logs", value)


if not MYPY:
    class AwsS3DataConnectorDataTypesLogsArgsDict(TypedDict):
        """
        Logs data type.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    AwsS3DataConnectorDataTypesLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsS3DataConnectorDataTypesLogsArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Logs data type.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class AwsS3DataConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for Amazon Web Services S3 data connector.
        """
        logs: pulumi.Input['AwsS3DataConnectorDataTypesLogsArgsDict']
        """
        Logs data type.
        """
elif False:
    AwsS3DataConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsS3DataConnectorDataTypesArgs:
    def __init__(__self__, *,
                 logs: pulumi.Input['AwsS3DataConnectorDataTypesLogsArgs']):
        """
        The available data types for Amazon Web Services S3 data connector.
        :param pulumi.Input['AwsS3DataConnectorDataTypesLogsArgs'] logs: Logs data type.
        """
        pulumi.set(__self__, "logs", logs)

    @property
    @pulumi.getter
    def logs(self) -> pulumi.Input['AwsS3DataConnectorDataTypesLogsArgs']:
        """
        Logs data type.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: pulumi.Input['AwsS3DataConnectorDataTypesLogsArgs']):
        pulumi.set(self, "logs", value)


if not MYPY:
    class BasicAuthModelArgsDict(TypedDict):
        """
        Model for API authentication with basic flow - user name + password.
        """
        password: pulumi.Input[str]
        """
        The password
        """
        type: pulumi.Input[str]
        """
        Type of paging
        Expected value is 'Basic'.
        """
        user_name: pulumi.Input[str]
        """
        The user name.
        """
elif False:
    BasicAuthModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BasicAuthModelArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 type: pulumi.Input[str],
                 user_name: pulumi.Input[str]):
        """
        Model for API authentication with basic flow - user name + password.
        :param pulumi.Input[str] password: The password
        :param pulumi.Input[str] type: Type of paging
               Expected value is 'Basic'.
        :param pulumi.Input[str] user_name: The user name.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "type", 'Basic')
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of paging
        Expected value is 'Basic'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[str]:
        """
        The user name.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class BookmarkEntityMappingsArgsDict(TypedDict):
        """
        Describes the entity mappings of a single entity
        """
        entity_type: NotRequired[pulumi.Input[str]]
        """
        The entity type
        """
        field_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['EntityFieldMappingArgsDict']]]]
        """
        Array of fields mapping for that entity type
        """
elif False:
    BookmarkEntityMappingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BookmarkEntityMappingsArgs:
    def __init__(__self__, *,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['EntityFieldMappingArgs']]]] = None):
        """
        Describes the entity mappings of a single entity
        :param pulumi.Input[str] entity_type: The entity type
        :param pulumi.Input[Sequence[pulumi.Input['EntityFieldMappingArgs']]] field_mappings: Array of fields mapping for that entity type
        """
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        The entity type
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EntityFieldMappingArgs']]]]:
        """
        Array of fields mapping for that entity type
        """
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EntityFieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)


if not MYPY:
    class BooleanConditionPropertiesArgsDict(TypedDict):
        """
        Describes an automation rule condition that applies a boolean operator (e.g AND, OR) to conditions
        """
        condition_type: pulumi.Input[str]
        """

        Expected value is 'Boolean'.
        """
        condition_properties: NotRequired[pulumi.Input['AutomationRuleBooleanConditionArgsDict']]
elif False:
    BooleanConditionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BooleanConditionPropertiesArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[str],
                 condition_properties: Optional[pulumi.Input['AutomationRuleBooleanConditionArgs']] = None):
        """
        Describes an automation rule condition that applies a boolean operator (e.g AND, OR) to conditions
        :param pulumi.Input[str] condition_type: 
               Expected value is 'Boolean'.
        """
        pulumi.set(__self__, "condition_type", 'Boolean')
        if condition_properties is not None:
            pulumi.set(__self__, "condition_properties", condition_properties)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[str]:
        """

        Expected value is 'Boolean'.
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition_type", value)

    @property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional[pulumi.Input['AutomationRuleBooleanConditionArgs']]:
        return pulumi.get(self, "condition_properties")

    @condition_properties.setter
    def condition_properties(self, value: Optional[pulumi.Input['AutomationRuleBooleanConditionArgs']]):
        pulumi.set(self, "condition_properties", value)


if not MYPY:
    class CcpResponseConfigArgsDict(TypedDict):
        """
        A custom response configuration for a rule.
        """
        events_json_paths: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The json paths, '$' char is the json root.
        """
        compression_algo: NotRequired[pulumi.Input[str]]
        """
        The compression algorithm.
        """
        convert_child_properties_to_array: NotRequired[pulumi.Input[bool]]
        """
        The a value indicating whether the response isn't an array of events / logs.  By setting this flag to true it means the remote server will response with an object which each property has as a value an array of events / logs.
        """
        csv_delimiter: NotRequired[pulumi.Input[str]]
        """
        The csv delimiter, in case the response format is CSV.
        """
        csv_escape: NotRequired[pulumi.Input[str]]
        """
        Th character used to escape characters in CSV.
        """
        format: NotRequired[pulumi.Input[str]]
        """
        The response format. possible values are json,csv,xml
        """
        has_csv_boundary: NotRequired[pulumi.Input[bool]]
        """
        The value indicating whether the response has CSV boundary in case the response in CSV format.
        """
        has_csv_header: NotRequired[pulumi.Input[bool]]
        """
        The value indicating whether the response has headers in case the response in CSV format.
        """
        is_gzip_compressed: NotRequired[pulumi.Input[bool]]
        """
        The value indicating whether the remote server support Gzip and we should expect Gzip response.
        """
        success_status_json_path: NotRequired[pulumi.Input[str]]
        """
        The value where the status message/code should appear in the response.
        """
        success_status_value: NotRequired[pulumi.Input[str]]
        """
        The the status value.
        """
elif False:
    CcpResponseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CcpResponseConfigArgs:
    def __init__(__self__, *,
                 events_json_paths: pulumi.Input[Sequence[pulumi.Input[str]]],
                 compression_algo: Optional[pulumi.Input[str]] = None,
                 convert_child_properties_to_array: Optional[pulumi.Input[bool]] = None,
                 csv_delimiter: Optional[pulumi.Input[str]] = None,
                 csv_escape: Optional[pulumi.Input[str]] = None,
                 format: Optional[pulumi.Input[str]] = None,
                 has_csv_boundary: Optional[pulumi.Input[bool]] = None,
                 has_csv_header: Optional[pulumi.Input[bool]] = None,
                 is_gzip_compressed: Optional[pulumi.Input[bool]] = None,
                 success_status_json_path: Optional[pulumi.Input[str]] = None,
                 success_status_value: Optional[pulumi.Input[str]] = None):
        """
        A custom response configuration for a rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] events_json_paths: The json paths, '$' char is the json root.
        :param pulumi.Input[str] compression_algo: The compression algorithm.
        :param pulumi.Input[bool] convert_child_properties_to_array: The a value indicating whether the response isn't an array of events / logs.  By setting this flag to true it means the remote server will response with an object which each property has as a value an array of events / logs.
        :param pulumi.Input[str] csv_delimiter: The csv delimiter, in case the response format is CSV.
        :param pulumi.Input[str] csv_escape: Th character used to escape characters in CSV.
        :param pulumi.Input[str] format: The response format. possible values are json,csv,xml
        :param pulumi.Input[bool] has_csv_boundary: The value indicating whether the response has CSV boundary in case the response in CSV format.
        :param pulumi.Input[bool] has_csv_header: The value indicating whether the response has headers in case the response in CSV format.
        :param pulumi.Input[bool] is_gzip_compressed: The value indicating whether the remote server support Gzip and we should expect Gzip response.
        :param pulumi.Input[str] success_status_json_path: The value where the status message/code should appear in the response.
        :param pulumi.Input[str] success_status_value: The the status value.
        """
        pulumi.set(__self__, "events_json_paths", events_json_paths)
        if compression_algo is not None:
            pulumi.set(__self__, "compression_algo", compression_algo)
        if convert_child_properties_to_array is not None:
            pulumi.set(__self__, "convert_child_properties_to_array", convert_child_properties_to_array)
        if csv_delimiter is not None:
            pulumi.set(__self__, "csv_delimiter", csv_delimiter)
        if csv_escape is None:
            csv_escape = '"'
        if csv_escape is not None:
            pulumi.set(__self__, "csv_escape", csv_escape)
        if format is None:
            format = 'json'
        if format is not None:
            pulumi.set(__self__, "format", format)
        if has_csv_boundary is not None:
            pulumi.set(__self__, "has_csv_boundary", has_csv_boundary)
        if has_csv_header is not None:
            pulumi.set(__self__, "has_csv_header", has_csv_header)
        if is_gzip_compressed is not None:
            pulumi.set(__self__, "is_gzip_compressed", is_gzip_compressed)
        if success_status_json_path is not None:
            pulumi.set(__self__, "success_status_json_path", success_status_json_path)
        if success_status_value is not None:
            pulumi.set(__self__, "success_status_value", success_status_value)

    @property
    @pulumi.getter(name="eventsJsonPaths")
    def events_json_paths(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The json paths, '$' char is the json root.
        """
        return pulumi.get(self, "events_json_paths")

    @events_json_paths.setter
    def events_json_paths(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "events_json_paths", value)

    @property
    @pulumi.getter(name="compressionAlgo")
    def compression_algo(self) -> Optional[pulumi.Input[str]]:
        """
        The compression algorithm.
        """
        return pulumi.get(self, "compression_algo")

    @compression_algo.setter
    def compression_algo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_algo", value)

    @property
    @pulumi.getter(name="convertChildPropertiesToArray")
    def convert_child_properties_to_array(self) -> Optional[pulumi.Input[bool]]:
        """
        The a value indicating whether the response isn't an array of events / logs.  By setting this flag to true it means the remote server will response with an object which each property has as a value an array of events / logs.
        """
        return pulumi.get(self, "convert_child_properties_to_array")

    @convert_child_properties_to_array.setter
    def convert_child_properties_to_array(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "convert_child_properties_to_array", value)

    @property
    @pulumi.getter(name="csvDelimiter")
    def csv_delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The csv delimiter, in case the response format is CSV.
        """
        return pulumi.get(self, "csv_delimiter")

    @csv_delimiter.setter
    def csv_delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "csv_delimiter", value)

    @property
    @pulumi.getter(name="csvEscape")
    def csv_escape(self) -> Optional[pulumi.Input[str]]:
        """
        Th character used to escape characters in CSV.
        """
        return pulumi.get(self, "csv_escape")

    @csv_escape.setter
    def csv_escape(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "csv_escape", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[str]]:
        """
        The response format. possible values are json,csv,xml
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="hasCsvBoundary")
    def has_csv_boundary(self) -> Optional[pulumi.Input[bool]]:
        """
        The value indicating whether the response has CSV boundary in case the response in CSV format.
        """
        return pulumi.get(self, "has_csv_boundary")

    @has_csv_boundary.setter
    def has_csv_boundary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_csv_boundary", value)

    @property
    @pulumi.getter(name="hasCsvHeader")
    def has_csv_header(self) -> Optional[pulumi.Input[bool]]:
        """
        The value indicating whether the response has headers in case the response in CSV format.
        """
        return pulumi.get(self, "has_csv_header")

    @has_csv_header.setter
    def has_csv_header(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_csv_header", value)

    @property
    @pulumi.getter(name="isGzipCompressed")
    def is_gzip_compressed(self) -> Optional[pulumi.Input[bool]]:
        """
        The value indicating whether the remote server support Gzip and we should expect Gzip response.
        """
        return pulumi.get(self, "is_gzip_compressed")

    @is_gzip_compressed.setter
    def is_gzip_compressed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_gzip_compressed", value)

    @property
    @pulumi.getter(name="successStatusJsonPath")
    def success_status_json_path(self) -> Optional[pulumi.Input[str]]:
        """
        The value where the status message/code should appear in the response.
        """
        return pulumi.get(self, "success_status_json_path")

    @success_status_json_path.setter
    def success_status_json_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "success_status_json_path", value)

    @property
    @pulumi.getter(name="successStatusValue")
    def success_status_value(self) -> Optional[pulumi.Input[str]]:
        """
        The the status value.
        """
        return pulumi.get(self, "success_status_value")

    @success_status_value.setter
    def success_status_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "success_status_value", value)


if not MYPY:
    class ClientInfoArgsDict(TypedDict):
        """
        Information on the client (user or application) that made some action
        """
        email: NotRequired[pulumi.Input[str]]
        """
        The email of the client.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the client.
        """
        object_id: NotRequired[pulumi.Input[str]]
        """
        The object id of the client.
        """
        user_principal_name: NotRequired[pulumi.Input[str]]
        """
        The user principal name of the client.
        """
elif False:
    ClientInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientInfoArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 user_principal_name: Optional[pulumi.Input[str]] = None):
        """
        Information on the client (user or application) that made some action
        :param pulumi.Input[str] email: The email of the client.
        :param pulumi.Input[str] name: The name of the client.
        :param pulumi.Input[str] object_id: The object id of the client.
        :param pulumi.Input[str] user_principal_name: The user principal name of the client.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if user_principal_name is not None:
            pulumi.set(__self__, "user_principal_name", user_principal_name)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The email of the client.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the client.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The object id of the client.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        The user principal name of the client.
        """
        return pulumi.get(self, "user_principal_name")

    @user_principal_name.setter
    def user_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_principal_name", value)


if not MYPY:
    class CodelessConnectorPollingAuthPropertiesArgsDict(TypedDict):
        """
        Describe the authentication properties needed to successfully authenticate with the server
        """
        auth_type: pulumi.Input[str]
        """
        The authentication type
        """
        api_key_identifier: NotRequired[pulumi.Input[str]]
        """
        A prefix send in the header before the actual token
        """
        api_key_name: NotRequired[pulumi.Input[str]]
        """
        The header name which the token is sent with
        """
        authorization_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint used to authorize the user, used in Oauth 2.0 flow
        """
        authorization_endpoint_query_parameters: NotRequired[Any]
        """
        The query parameters used in authorization request, used in Oauth 2.0 flow
        """
        flow_name: NotRequired[pulumi.Input[str]]
        """
        Describes the flow name, for example 'AuthCode' for Oauth 2.0
        """
        is_api_key_in_post_payload: NotRequired[pulumi.Input[str]]
        """
        Marks if the key should sent in header
        """
        is_client_secret_in_header: NotRequired[pulumi.Input[bool]]
        """
        Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow
        """
        redirection_endpoint: NotRequired[pulumi.Input[str]]
        """
        The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The OAuth token scope
        """
        token_endpoint: NotRequired[pulumi.Input[str]]
        """
        The endpoint used to issue a token, used in Oauth 2.0 flow
        """
        token_endpoint_headers: NotRequired[Any]
        """
        The query headers used in token request, used in Oauth 2.0 flow
        """
        token_endpoint_query_parameters: NotRequired[Any]
        """
        The query parameters used in token request, used in Oauth 2.0 flow
        """
elif False:
    CodelessConnectorPollingAuthPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodelessConnectorPollingAuthPropertiesArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[str],
                 api_key_identifier: Optional[pulumi.Input[str]] = None,
                 api_key_name: Optional[pulumi.Input[str]] = None,
                 authorization_endpoint: Optional[pulumi.Input[str]] = None,
                 authorization_endpoint_query_parameters: Optional[Any] = None,
                 flow_name: Optional[pulumi.Input[str]] = None,
                 is_api_key_in_post_payload: Optional[pulumi.Input[str]] = None,
                 is_client_secret_in_header: Optional[pulumi.Input[bool]] = None,
                 redirection_endpoint: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 token_endpoint: Optional[pulumi.Input[str]] = None,
                 token_endpoint_headers: Optional[Any] = None,
                 token_endpoint_query_parameters: Optional[Any] = None):
        """
        Describe the authentication properties needed to successfully authenticate with the server
        :param pulumi.Input[str] auth_type: The authentication type
        :param pulumi.Input[str] api_key_identifier: A prefix send in the header before the actual token
        :param pulumi.Input[str] api_key_name: The header name which the token is sent with
        :param pulumi.Input[str] authorization_endpoint: The endpoint used to authorize the user, used in Oauth 2.0 flow
        :param Any authorization_endpoint_query_parameters: The query parameters used in authorization request, used in Oauth 2.0 flow
        :param pulumi.Input[str] flow_name: Describes the flow name, for example 'AuthCode' for Oauth 2.0
        :param pulumi.Input[str] is_api_key_in_post_payload: Marks if the key should sent in header
        :param pulumi.Input[bool] is_client_secret_in_header: Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow
        :param pulumi.Input[str] redirection_endpoint: The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow
        :param pulumi.Input[str] scope: The OAuth token scope
        :param pulumi.Input[str] token_endpoint: The endpoint used to issue a token, used in Oauth 2.0 flow
        :param Any token_endpoint_headers: The query headers used in token request, used in Oauth 2.0 flow
        :param Any token_endpoint_query_parameters: The query parameters used in token request, used in Oauth 2.0 flow
        """
        pulumi.set(__self__, "auth_type", auth_type)
        if api_key_identifier is not None:
            pulumi.set(__self__, "api_key_identifier", api_key_identifier)
        if api_key_name is not None:
            pulumi.set(__self__, "api_key_name", api_key_name)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if authorization_endpoint_query_parameters is not None:
            pulumi.set(__self__, "authorization_endpoint_query_parameters", authorization_endpoint_query_parameters)
        if flow_name is not None:
            pulumi.set(__self__, "flow_name", flow_name)
        if is_api_key_in_post_payload is not None:
            pulumi.set(__self__, "is_api_key_in_post_payload", is_api_key_in_post_payload)
        if is_client_secret_in_header is not None:
            pulumi.set(__self__, "is_client_secret_in_header", is_client_secret_in_header)
        if redirection_endpoint is not None:
            pulumi.set(__self__, "redirection_endpoint", redirection_endpoint)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if token_endpoint_headers is not None:
            pulumi.set(__self__, "token_endpoint_headers", token_endpoint_headers)
        if token_endpoint_query_parameters is not None:
            pulumi.set(__self__, "token_endpoint_query_parameters", token_endpoint_query_parameters)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[str]:
        """
        The authentication type
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="apiKeyIdentifier")
    def api_key_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        A prefix send in the header before the actual token
        """
        return pulumi.get(self, "api_key_identifier")

    @api_key_identifier.setter
    def api_key_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key_identifier", value)

    @property
    @pulumi.getter(name="apiKeyName")
    def api_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        The header name which the token is sent with
        """
        return pulumi.get(self, "api_key_name")

    @api_key_name.setter
    def api_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key_name", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint used to authorize the user, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="authorizationEndpointQueryParameters")
    def authorization_endpoint_query_parameters(self) -> Optional[Any]:
        """
        The query parameters used in authorization request, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "authorization_endpoint_query_parameters")

    @authorization_endpoint_query_parameters.setter
    def authorization_endpoint_query_parameters(self, value: Optional[Any]):
        pulumi.set(self, "authorization_endpoint_query_parameters", value)

    @property
    @pulumi.getter(name="flowName")
    def flow_name(self) -> Optional[pulumi.Input[str]]:
        """
        Describes the flow name, for example 'AuthCode' for Oauth 2.0
        """
        return pulumi.get(self, "flow_name")

    @flow_name.setter
    def flow_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flow_name", value)

    @property
    @pulumi.getter(name="isApiKeyInPostPayload")
    def is_api_key_in_post_payload(self) -> Optional[pulumi.Input[str]]:
        """
        Marks if the key should sent in header
        """
        return pulumi.get(self, "is_api_key_in_post_payload")

    @is_api_key_in_post_payload.setter
    def is_api_key_in_post_payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_api_key_in_post_payload", value)

    @property
    @pulumi.getter(name="isClientSecretInHeader")
    def is_client_secret_in_header(self) -> Optional[pulumi.Input[bool]]:
        """
        Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "is_client_secret_in_header")

    @is_client_secret_in_header.setter
    def is_client_secret_in_header(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_client_secret_in_header", value)

    @property
    @pulumi.getter(name="redirectionEndpoint")
    def redirection_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "redirection_endpoint")

    @redirection_endpoint.setter
    def redirection_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirection_endpoint", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth token scope
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint used to issue a token, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="tokenEndpointHeaders")
    def token_endpoint_headers(self) -> Optional[Any]:
        """
        The query headers used in token request, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "token_endpoint_headers")

    @token_endpoint_headers.setter
    def token_endpoint_headers(self, value: Optional[Any]):
        pulumi.set(self, "token_endpoint_headers", value)

    @property
    @pulumi.getter(name="tokenEndpointQueryParameters")
    def token_endpoint_query_parameters(self) -> Optional[Any]:
        """
        The query parameters used in token request, used in Oauth 2.0 flow
        """
        return pulumi.get(self, "token_endpoint_query_parameters")

    @token_endpoint_query_parameters.setter
    def token_endpoint_query_parameters(self, value: Optional[Any]):
        pulumi.set(self, "token_endpoint_query_parameters", value)


if not MYPY:
    class CodelessConnectorPollingConfigPropertiesArgsDict(TypedDict):
        """
        Config to describe the polling config for API poller connector
        """
        auth: pulumi.Input['CodelessConnectorPollingAuthPropertiesArgsDict']
        """
        Describe the authentication type of the poller
        """
        request: pulumi.Input['CodelessConnectorPollingRequestPropertiesArgsDict']
        """
        Describe the poll request config parameters of the poller
        """
        is_active: NotRequired[pulumi.Input[bool]]
        """
        The poller active status
        """
        paging: NotRequired[pulumi.Input['CodelessConnectorPollingPagingPropertiesArgsDict']]
        """
        Describe the poll request paging config of the poller
        """
        response: NotRequired[pulumi.Input['CodelessConnectorPollingResponsePropertiesArgsDict']]
        """
        Describe the response config parameters of the poller
        """
elif False:
    CodelessConnectorPollingConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodelessConnectorPollingConfigPropertiesArgs:
    def __init__(__self__, *,
                 auth: pulumi.Input['CodelessConnectorPollingAuthPropertiesArgs'],
                 request: pulumi.Input['CodelessConnectorPollingRequestPropertiesArgs'],
                 is_active: Optional[pulumi.Input[bool]] = None,
                 paging: Optional[pulumi.Input['CodelessConnectorPollingPagingPropertiesArgs']] = None,
                 response: Optional[pulumi.Input['CodelessConnectorPollingResponsePropertiesArgs']] = None):
        """
        Config to describe the polling config for API poller connector
        :param pulumi.Input['CodelessConnectorPollingAuthPropertiesArgs'] auth: Describe the authentication type of the poller
        :param pulumi.Input['CodelessConnectorPollingRequestPropertiesArgs'] request: Describe the poll request config parameters of the poller
        :param pulumi.Input[bool] is_active: The poller active status
        :param pulumi.Input['CodelessConnectorPollingPagingPropertiesArgs'] paging: Describe the poll request paging config of the poller
        :param pulumi.Input['CodelessConnectorPollingResponsePropertiesArgs'] response: Describe the response config parameters of the poller
        """
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "request", request)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if paging is not None:
            pulumi.set(__self__, "paging", paging)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def auth(self) -> pulumi.Input['CodelessConnectorPollingAuthPropertiesArgs']:
        """
        Describe the authentication type of the poller
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: pulumi.Input['CodelessConnectorPollingAuthPropertiesArgs']):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def request(self) -> pulumi.Input['CodelessConnectorPollingRequestPropertiesArgs']:
        """
        Describe the poll request config parameters of the poller
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: pulumi.Input['CodelessConnectorPollingRequestPropertiesArgs']):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[bool]]:
        """
        The poller active status
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_active", value)

    @property
    @pulumi.getter
    def paging(self) -> Optional[pulumi.Input['CodelessConnectorPollingPagingPropertiesArgs']]:
        """
        Describe the poll request paging config of the poller
        """
        return pulumi.get(self, "paging")

    @paging.setter
    def paging(self, value: Optional[pulumi.Input['CodelessConnectorPollingPagingPropertiesArgs']]):
        pulumi.set(self, "paging", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['CodelessConnectorPollingResponsePropertiesArgs']]:
        """
        Describe the response config parameters of the poller
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['CodelessConnectorPollingResponsePropertiesArgs']]):
        pulumi.set(self, "response", value)


if not MYPY:
    class CodelessConnectorPollingPagingPropertiesArgsDict(TypedDict):
        """
        Describe the properties needed to make a pagination call
        """
        paging_type: pulumi.Input[str]
        """
        Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'
        """
        next_page_para_name: NotRequired[pulumi.Input[str]]
        """
        Defines the name of a next page attribute
        """
        next_page_token_json_path: NotRequired[pulumi.Input[str]]
        """
        Defines the path to a next page token JSON
        """
        page_count_attribute_path: NotRequired[pulumi.Input[str]]
        """
        Defines the path to a page count attribute
        """
        page_size: NotRequired[pulumi.Input[int]]
        """
        Defines the paging size
        """
        page_size_para_name: NotRequired[pulumi.Input[str]]
        """
        Defines the name of the page size parameter
        """
        page_time_stamp_attribute_path: NotRequired[pulumi.Input[str]]
        """
        Defines the path to a paging time stamp attribute
        """
        page_total_count_attribute_path: NotRequired[pulumi.Input[str]]
        """
        Defines the path to a page total count attribute
        """
        search_the_latest_time_stamp_from_events_list: NotRequired[pulumi.Input[str]]
        """
        Determines whether to search for the latest time stamp in the events list
        """
elif False:
    CodelessConnectorPollingPagingPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodelessConnectorPollingPagingPropertiesArgs:
    def __init__(__self__, *,
                 paging_type: pulumi.Input[str],
                 next_page_para_name: Optional[pulumi.Input[str]] = None,
                 next_page_token_json_path: Optional[pulumi.Input[str]] = None,
                 page_count_attribute_path: Optional[pulumi.Input[str]] = None,
                 page_size: Optional[pulumi.Input[int]] = None,
                 page_size_para_name: Optional[pulumi.Input[str]] = None,
                 page_time_stamp_attribute_path: Optional[pulumi.Input[str]] = None,
                 page_total_count_attribute_path: Optional[pulumi.Input[str]] = None,
                 search_the_latest_time_stamp_from_events_list: Optional[pulumi.Input[str]] = None):
        """
        Describe the properties needed to make a pagination call
        :param pulumi.Input[str] paging_type: Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'
        :param pulumi.Input[str] next_page_para_name: Defines the name of a next page attribute
        :param pulumi.Input[str] next_page_token_json_path: Defines the path to a next page token JSON
        :param pulumi.Input[str] page_count_attribute_path: Defines the path to a page count attribute
        :param pulumi.Input[int] page_size: Defines the paging size
        :param pulumi.Input[str] page_size_para_name: Defines the name of the page size parameter
        :param pulumi.Input[str] page_time_stamp_attribute_path: Defines the path to a paging time stamp attribute
        :param pulumi.Input[str] page_total_count_attribute_path: Defines the path to a page total count attribute
        :param pulumi.Input[str] search_the_latest_time_stamp_from_events_list: Determines whether to search for the latest time stamp in the events list
        """
        pulumi.set(__self__, "paging_type", paging_type)
        if next_page_para_name is not None:
            pulumi.set(__self__, "next_page_para_name", next_page_para_name)
        if next_page_token_json_path is not None:
            pulumi.set(__self__, "next_page_token_json_path", next_page_token_json_path)
        if page_count_attribute_path is not None:
            pulumi.set(__self__, "page_count_attribute_path", page_count_attribute_path)
        if page_size is not None:
            pulumi.set(__self__, "page_size", page_size)
        if page_size_para_name is not None:
            pulumi.set(__self__, "page_size_para_name", page_size_para_name)
        if page_time_stamp_attribute_path is not None:
            pulumi.set(__self__, "page_time_stamp_attribute_path", page_time_stamp_attribute_path)
        if page_total_count_attribute_path is not None:
            pulumi.set(__self__, "page_total_count_attribute_path", page_total_count_attribute_path)
        if search_the_latest_time_stamp_from_events_list is not None:
            pulumi.set(__self__, "search_the_latest_time_stamp_from_events_list", search_the_latest_time_stamp_from_events_list)

    @property
    @pulumi.getter(name="pagingType")
    def paging_type(self) -> pulumi.Input[str]:
        """
        Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'
        """
        return pulumi.get(self, "paging_type")

    @paging_type.setter
    def paging_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "paging_type", value)

    @property
    @pulumi.getter(name="nextPageParaName")
    def next_page_para_name(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the name of a next page attribute
        """
        return pulumi.get(self, "next_page_para_name")

    @next_page_para_name.setter
    def next_page_para_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_page_para_name", value)

    @property
    @pulumi.getter(name="nextPageTokenJsonPath")
    def next_page_token_json_path(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the path to a next page token JSON
        """
        return pulumi.get(self, "next_page_token_json_path")

    @next_page_token_json_path.setter
    def next_page_token_json_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_page_token_json_path", value)

    @property
    @pulumi.getter(name="pageCountAttributePath")
    def page_count_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the path to a page count attribute
        """
        return pulumi.get(self, "page_count_attribute_path")

    @page_count_attribute_path.setter
    def page_count_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "page_count_attribute_path", value)

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[pulumi.Input[int]]:
        """
        Defines the paging size
        """
        return pulumi.get(self, "page_size")

    @page_size.setter
    def page_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "page_size", value)

    @property
    @pulumi.getter(name="pageSizeParaName")
    def page_size_para_name(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the name of the page size parameter
        """
        return pulumi.get(self, "page_size_para_name")

    @page_size_para_name.setter
    def page_size_para_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "page_size_para_name", value)

    @property
    @pulumi.getter(name="pageTimeStampAttributePath")
    def page_time_stamp_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the path to a paging time stamp attribute
        """
        return pulumi.get(self, "page_time_stamp_attribute_path")

    @page_time_stamp_attribute_path.setter
    def page_time_stamp_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "page_time_stamp_attribute_path", value)

    @property
    @pulumi.getter(name="pageTotalCountAttributePath")
    def page_total_count_attribute_path(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the path to a page total count attribute
        """
        return pulumi.get(self, "page_total_count_attribute_path")

    @page_total_count_attribute_path.setter
    def page_total_count_attribute_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "page_total_count_attribute_path", value)

    @property
    @pulumi.getter(name="searchTheLatestTimeStampFromEventsList")
    def search_the_latest_time_stamp_from_events_list(self) -> Optional[pulumi.Input[str]]:
        """
        Determines whether to search for the latest time stamp in the events list
        """
        return pulumi.get(self, "search_the_latest_time_stamp_from_events_list")

    @search_the_latest_time_stamp_from_events_list.setter
    def search_the_latest_time_stamp_from_events_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_the_latest_time_stamp_from_events_list", value)


if not MYPY:
    class CodelessConnectorPollingRequestPropertiesArgsDict(TypedDict):
        """
        Describe the request properties needed to successfully pull from the server
        """
        api_endpoint: pulumi.Input[str]
        """
        Describe the endpoint we should pull the data from
        """
        http_method: pulumi.Input[str]
        """
        The http method type we will use in the poll request, GET or POST
        """
        query_time_format: pulumi.Input[str]
        """
        The time format will be used the query events in a specific window
        """
        query_window_in_min: pulumi.Input[int]
        """
        The window interval we will use the pull the data
        """
        end_time_attribute_name: NotRequired[pulumi.Input[str]]
        """
        This will be used the query events from the end of the time window
        """
        headers: NotRequired[Any]
        """
        Describe the headers sent in the poll request
        """
        query_parameters: NotRequired[Any]
        """
        Describe the query parameters sent in the poll request
        """
        query_parameters_template: NotRequired[pulumi.Input[str]]
        """
        For advanced scenarios for example user name/password embedded in nested JSON payload
        """
        rate_limit_qps: NotRequired[pulumi.Input[int]]
        """
        Defines the rate limit QPS
        """
        retry_count: NotRequired[pulumi.Input[int]]
        """
        Describe the amount of time we should try and poll the data in case of failure
        """
        start_time_attribute_name: NotRequired[pulumi.Input[str]]
        """
        This will be used the query events from a start of the time window
        """
        timeout_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds we will consider as a request timeout
        """
elif False:
    CodelessConnectorPollingRequestPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodelessConnectorPollingRequestPropertiesArgs:
    def __init__(__self__, *,
                 api_endpoint: pulumi.Input[str],
                 http_method: pulumi.Input[str],
                 query_time_format: pulumi.Input[str],
                 query_window_in_min: pulumi.Input[int],
                 end_time_attribute_name: Optional[pulumi.Input[str]] = None,
                 headers: Optional[Any] = None,
                 query_parameters: Optional[Any] = None,
                 query_parameters_template: Optional[pulumi.Input[str]] = None,
                 rate_limit_qps: Optional[pulumi.Input[int]] = None,
                 retry_count: Optional[pulumi.Input[int]] = None,
                 start_time_attribute_name: Optional[pulumi.Input[str]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        Describe the request properties needed to successfully pull from the server
        :param pulumi.Input[str] api_endpoint: Describe the endpoint we should pull the data from
        :param pulumi.Input[str] http_method: The http method type we will use in the poll request, GET or POST
        :param pulumi.Input[str] query_time_format: The time format will be used the query events in a specific window
        :param pulumi.Input[int] query_window_in_min: The window interval we will use the pull the data
        :param pulumi.Input[str] end_time_attribute_name: This will be used the query events from the end of the time window
        :param Any headers: Describe the headers sent in the poll request
        :param Any query_parameters: Describe the query parameters sent in the poll request
        :param pulumi.Input[str] query_parameters_template: For advanced scenarios for example user name/password embedded in nested JSON payload
        :param pulumi.Input[int] rate_limit_qps: Defines the rate limit QPS
        :param pulumi.Input[int] retry_count: Describe the amount of time we should try and poll the data in case of failure
        :param pulumi.Input[str] start_time_attribute_name: This will be used the query events from a start of the time window
        :param pulumi.Input[int] timeout_in_seconds: The number of seconds we will consider as a request timeout
        """
        pulumi.set(__self__, "api_endpoint", api_endpoint)
        pulumi.set(__self__, "http_method", http_method)
        pulumi.set(__self__, "query_time_format", query_time_format)
        pulumi.set(__self__, "query_window_in_min", query_window_in_min)
        if end_time_attribute_name is not None:
            pulumi.set(__self__, "end_time_attribute_name", end_time_attribute_name)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if query_parameters_template is not None:
            pulumi.set(__self__, "query_parameters_template", query_parameters_template)
        if rate_limit_qps is not None:
            pulumi.set(__self__, "rate_limit_qps", rate_limit_qps)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if start_time_attribute_name is not None:
            pulumi.set(__self__, "start_time_attribute_name", start_time_attribute_name)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @property
    @pulumi.getter(name="apiEndpoint")
    def api_endpoint(self) -> pulumi.Input[str]:
        """
        Describe the endpoint we should pull the data from
        """
        return pulumi.get(self, "api_endpoint")

    @api_endpoint.setter
    def api_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_endpoint", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> pulumi.Input[str]:
        """
        The http method type we will use in the poll request, GET or POST
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="queryTimeFormat")
    def query_time_format(self) -> pulumi.Input[str]:
        """
        The time format will be used the query events in a specific window
        """
        return pulumi.get(self, "query_time_format")

    @query_time_format.setter
    def query_time_format(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_time_format", value)

    @property
    @pulumi.getter(name="queryWindowInMin")
    def query_window_in_min(self) -> pulumi.Input[int]:
        """
        The window interval we will use the pull the data
        """
        return pulumi.get(self, "query_window_in_min")

    @query_window_in_min.setter
    def query_window_in_min(self, value: pulumi.Input[int]):
        pulumi.set(self, "query_window_in_min", value)

    @property
    @pulumi.getter(name="endTimeAttributeName")
    def end_time_attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        This will be used the query events from the end of the time window
        """
        return pulumi.get(self, "end_time_attribute_name")

    @end_time_attribute_name.setter
    def end_time_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time_attribute_name", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Any]:
        """
        Describe the headers sent in the poll request
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[Any]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Any]:
        """
        Describe the query parameters sent in the poll request
        """
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[Any]):
        pulumi.set(self, "query_parameters", value)

    @property
    @pulumi.getter(name="queryParametersTemplate")
    def query_parameters_template(self) -> Optional[pulumi.Input[str]]:
        """
        For advanced scenarios for example user name/password embedded in nested JSON payload
        """
        return pulumi.get(self, "query_parameters_template")

    @query_parameters_template.setter
    def query_parameters_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_parameters_template", value)

    @property
    @pulumi.getter(name="rateLimitQps")
    def rate_limit_qps(self) -> Optional[pulumi.Input[int]]:
        """
        Defines the rate limit QPS
        """
        return pulumi.get(self, "rate_limit_qps")

    @rate_limit_qps.setter
    def rate_limit_qps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rate_limit_qps", value)

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[pulumi.Input[int]]:
        """
        Describe the amount of time we should try and poll the data in case of failure
        """
        return pulumi.get(self, "retry_count")

    @retry_count.setter
    def retry_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retry_count", value)

    @property
    @pulumi.getter(name="startTimeAttributeName")
    def start_time_attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        This will be used the query events from a start of the time window
        """
        return pulumi.get(self, "start_time_attribute_name")

    @start_time_attribute_name.setter
    def start_time_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time_attribute_name", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds we will consider as a request timeout
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_seconds", value)


if not MYPY:
    class CodelessConnectorPollingResponsePropertiesArgsDict(TypedDict):
        """
        Describes the response from the external server
        """
        events_json_paths: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Describes the path we should extract the data in the response
        """
        is_gzip_compressed: NotRequired[pulumi.Input[bool]]
        """
        Describes if the data in the response is Gzip
        """
        success_status_json_path: NotRequired[pulumi.Input[str]]
        """
        Describes the path we should extract the status code in the response
        """
        success_status_value: NotRequired[pulumi.Input[str]]
        """
        Describes the path we should extract the status value in the response
        """
elif False:
    CodelessConnectorPollingResponsePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodelessConnectorPollingResponsePropertiesArgs:
    def __init__(__self__, *,
                 events_json_paths: pulumi.Input[Sequence[pulumi.Input[str]]],
                 is_gzip_compressed: Optional[pulumi.Input[bool]] = None,
                 success_status_json_path: Optional[pulumi.Input[str]] = None,
                 success_status_value: Optional[pulumi.Input[str]] = None):
        """
        Describes the response from the external server
        :param pulumi.Input[Sequence[pulumi.Input[str]]] events_json_paths: Describes the path we should extract the data in the response
        :param pulumi.Input[bool] is_gzip_compressed: Describes if the data in the response is Gzip
        :param pulumi.Input[str] success_status_json_path: Describes the path we should extract the status code in the response
        :param pulumi.Input[str] success_status_value: Describes the path we should extract the status value in the response
        """
        pulumi.set(__self__, "events_json_paths", events_json_paths)
        if is_gzip_compressed is not None:
            pulumi.set(__self__, "is_gzip_compressed", is_gzip_compressed)
        if success_status_json_path is not None:
            pulumi.set(__self__, "success_status_json_path", success_status_json_path)
        if success_status_value is not None:
            pulumi.set(__self__, "success_status_value", success_status_value)

    @property
    @pulumi.getter(name="eventsJsonPaths")
    def events_json_paths(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Describes the path we should extract the data in the response
        """
        return pulumi.get(self, "events_json_paths")

    @events_json_paths.setter
    def events_json_paths(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "events_json_paths", value)

    @property
    @pulumi.getter(name="isGzipCompressed")
    def is_gzip_compressed(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if the data in the response is Gzip
        """
        return pulumi.get(self, "is_gzip_compressed")

    @is_gzip_compressed.setter
    def is_gzip_compressed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_gzip_compressed", value)

    @property
    @pulumi.getter(name="successStatusJsonPath")
    def success_status_json_path(self) -> Optional[pulumi.Input[str]]:
        """
        Describes the path we should extract the status code in the response
        """
        return pulumi.get(self, "success_status_json_path")

    @success_status_json_path.setter
    def success_status_json_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "success_status_json_path", value)

    @property
    @pulumi.getter(name="successStatusValue")
    def success_status_value(self) -> Optional[pulumi.Input[str]]:
        """
        Describes the path we should extract the status value in the response
        """
        return pulumi.get(self, "success_status_value")

    @success_status_value.setter
    def success_status_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "success_status_value", value)


if not MYPY:
    class CodelessUiConnectorConfigPropertiesConnectivityCriteriaArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[Union[str, 'ConnectivityType']]]
        """
        type of connectivity
        """
        value: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Queries for checking connectivity
        """
elif False:
    CodelessUiConnectorConfigPropertiesConnectivityCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodelessUiConnectorConfigPropertiesConnectivityCriteriaArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[str, 'ConnectivityType']]] = None,
                 value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Union[str, 'ConnectivityType']] type: type of connectivity
        :param pulumi.Input[Sequence[pulumi.Input[str]]] value: Queries for checking connectivity
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'ConnectivityType']]]:
        """
        type of connectivity
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'ConnectivityType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Queries for checking connectivity
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CodelessUiConnectorConfigPropertiesDataTypesArgsDict(TypedDict):
        last_data_received_query: NotRequired[pulumi.Input[str]]
        """
        Query for indicate last data received
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the data type to show in the graph. can be use with {{graphQueriesTableName}} placeholder
        """
elif False:
    CodelessUiConnectorConfigPropertiesDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodelessUiConnectorConfigPropertiesDataTypesArgs:
    def __init__(__self__, *,
                 last_data_received_query: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_data_received_query: Query for indicate last data received
        :param pulumi.Input[str] name: Name of the data type to show in the graph. can be use with {{graphQueriesTableName}} placeholder
        """
        if last_data_received_query is not None:
            pulumi.set(__self__, "last_data_received_query", last_data_received_query)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lastDataReceivedQuery")
    def last_data_received_query(self) -> Optional[pulumi.Input[str]]:
        """
        Query for indicate last data received
        """
        return pulumi.get(self, "last_data_received_query")

    @last_data_received_query.setter
    def last_data_received_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_data_received_query", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the data type to show in the graph. can be use with {{graphQueriesTableName}} placeholder
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CodelessUiConnectorConfigPropertiesGraphQueriesArgsDict(TypedDict):
        base_query: NotRequired[pulumi.Input[str]]
        """
        The base query for the graph
        """
        legend: NotRequired[pulumi.Input[str]]
        """
        The legend for the graph
        """
        metric_name: NotRequired[pulumi.Input[str]]
        """
        the metric that the query is checking
        """
elif False:
    CodelessUiConnectorConfigPropertiesGraphQueriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodelessUiConnectorConfigPropertiesGraphQueriesArgs:
    def __init__(__self__, *,
                 base_query: Optional[pulumi.Input[str]] = None,
                 legend: Optional[pulumi.Input[str]] = None,
                 metric_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] base_query: The base query for the graph
        :param pulumi.Input[str] legend: The legend for the graph
        :param pulumi.Input[str] metric_name: the metric that the query is checking
        """
        if base_query is not None:
            pulumi.set(__self__, "base_query", base_query)
        if legend is not None:
            pulumi.set(__self__, "legend", legend)
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)

    @property
    @pulumi.getter(name="baseQuery")
    def base_query(self) -> Optional[pulumi.Input[str]]:
        """
        The base query for the graph
        """
        return pulumi.get(self, "base_query")

    @base_query.setter
    def base_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_query", value)

    @property
    @pulumi.getter
    def legend(self) -> Optional[pulumi.Input[str]]:
        """
        The legend for the graph
        """
        return pulumi.get(self, "legend")

    @legend.setter
    def legend(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legend", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[pulumi.Input[str]]:
        """
        the metric that the query is checking
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_name", value)


if not MYPY:
    class CodelessUiConnectorConfigPropertiesInstructionStepsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        Instruction step description
        """
        instructions: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstructionStepsInstructionsArgsDict']]]]
        """
        Instruction step details
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Instruction step title
        """
elif False:
    CodelessUiConnectorConfigPropertiesInstructionStepsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodelessUiConnectorConfigPropertiesInstructionStepsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 instructions: Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepsInstructionsArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: Instruction step description
        :param pulumi.Input[Sequence[pulumi.Input['InstructionStepsInstructionsArgs']]] instructions: Instruction step details
        :param pulumi.Input[str] title: Instruction step title
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if instructions is not None:
            pulumi.set(__self__, "instructions", instructions)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Instruction step description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def instructions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepsInstructionsArgs']]]]:
        """
        Instruction step details
        """
        return pulumi.get(self, "instructions")

    @instructions.setter
    def instructions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepsInstructionsArgs']]]]):
        pulumi.set(self, "instructions", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Instruction step title
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class CodelessUiConnectorConfigPropertiesSampleQueriesArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        The sample query description
        """
        query: NotRequired[pulumi.Input[str]]
        """
        the sample query
        """
elif False:
    CodelessUiConnectorConfigPropertiesSampleQueriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodelessUiConnectorConfigPropertiesSampleQueriesArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: The sample query description
        :param pulumi.Input[str] query: the sample query
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The sample query description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        the sample query
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


if not MYPY:
    class CodelessUiConnectorConfigPropertiesArgsDict(TypedDict):
        """
        Config to describe the instructions blade
        """
        availability: pulumi.Input['AvailabilityArgsDict']
        """
        Connector Availability Status
        """
        connectivity_criteria: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesConnectivityCriteriaArgsDict']]]
        """
        Define the way the connector check connectivity
        """
        data_types: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesDataTypesArgsDict']]]
        """
        Data types to check for last data received
        """
        description_markdown: pulumi.Input[str]
        """
        Connector description
        """
        graph_queries: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesGraphQueriesArgsDict']]]
        """
        The graph query to show the current data status
        """
        graph_queries_table_name: pulumi.Input[str]
        """
        Name of the table the connector will insert the data to
        """
        instruction_steps: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesInstructionStepsArgsDict']]]
        """
        Instruction steps to enable the connector
        """
        permissions: pulumi.Input['PermissionsArgsDict']
        """
        Permissions required for the connector
        """
        publisher: pulumi.Input[str]
        """
        Connector publisher name
        """
        sample_queries: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesSampleQueriesArgsDict']]]
        """
        The sample queries for the connector
        """
        title: pulumi.Input[str]
        """
        Connector blade title
        """
        custom_image: NotRequired[pulumi.Input[str]]
        """
        An optional custom image to be used when displaying the connector within Azure Sentinel's connector's gallery
        """
elif False:
    CodelessUiConnectorConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CodelessUiConnectorConfigPropertiesArgs:
    def __init__(__self__, *,
                 availability: pulumi.Input['AvailabilityArgs'],
                 connectivity_criteria: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesConnectivityCriteriaArgs']]],
                 data_types: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesDataTypesArgs']]],
                 description_markdown: pulumi.Input[str],
                 graph_queries: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesGraphQueriesArgs']]],
                 graph_queries_table_name: pulumi.Input[str],
                 instruction_steps: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesInstructionStepsArgs']]],
                 permissions: pulumi.Input['PermissionsArgs'],
                 publisher: pulumi.Input[str],
                 sample_queries: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesSampleQueriesArgs']]],
                 title: pulumi.Input[str],
                 custom_image: Optional[pulumi.Input[str]] = None):
        """
        Config to describe the instructions blade
        :param pulumi.Input['AvailabilityArgs'] availability: Connector Availability Status
        :param pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesConnectivityCriteriaArgs']]] connectivity_criteria: Define the way the connector check connectivity
        :param pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesDataTypesArgs']]] data_types: Data types to check for last data received
        :param pulumi.Input[str] description_markdown: Connector description
        :param pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesGraphQueriesArgs']]] graph_queries: The graph query to show the current data status
        :param pulumi.Input[str] graph_queries_table_name: Name of the table the connector will insert the data to
        :param pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesInstructionStepsArgs']]] instruction_steps: Instruction steps to enable the connector
        :param pulumi.Input['PermissionsArgs'] permissions: Permissions required for the connector
        :param pulumi.Input[str] publisher: Connector publisher name
        :param pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesSampleQueriesArgs']]] sample_queries: The sample queries for the connector
        :param pulumi.Input[str] title: Connector blade title
        :param pulumi.Input[str] custom_image: An optional custom image to be used when displaying the connector within Azure Sentinel's connector's gallery
        """
        pulumi.set(__self__, "availability", availability)
        pulumi.set(__self__, "connectivity_criteria", connectivity_criteria)
        pulumi.set(__self__, "data_types", data_types)
        pulumi.set(__self__, "description_markdown", description_markdown)
        pulumi.set(__self__, "graph_queries", graph_queries)
        pulumi.set(__self__, "graph_queries_table_name", graph_queries_table_name)
        pulumi.set(__self__, "instruction_steps", instruction_steps)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sample_queries", sample_queries)
        pulumi.set(__self__, "title", title)
        if custom_image is not None:
            pulumi.set(__self__, "custom_image", custom_image)

    @property
    @pulumi.getter
    def availability(self) -> pulumi.Input['AvailabilityArgs']:
        """
        Connector Availability Status
        """
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: pulumi.Input['AvailabilityArgs']):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter(name="connectivityCriteria")
    def connectivity_criteria(self) -> pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesConnectivityCriteriaArgs']]]:
        """
        Define the way the connector check connectivity
        """
        return pulumi.get(self, "connectivity_criteria")

    @connectivity_criteria.setter
    def connectivity_criteria(self, value: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesConnectivityCriteriaArgs']]]):
        pulumi.set(self, "connectivity_criteria", value)

    @property
    @pulumi.getter(name="dataTypes")
    def data_types(self) -> pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesDataTypesArgs']]]:
        """
        Data types to check for last data received
        """
        return pulumi.get(self, "data_types")

    @data_types.setter
    def data_types(self, value: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesDataTypesArgs']]]):
        pulumi.set(self, "data_types", value)

    @property
    @pulumi.getter(name="descriptionMarkdown")
    def description_markdown(self) -> pulumi.Input[str]:
        """
        Connector description
        """
        return pulumi.get(self, "description_markdown")

    @description_markdown.setter
    def description_markdown(self, value: pulumi.Input[str]):
        pulumi.set(self, "description_markdown", value)

    @property
    @pulumi.getter(name="graphQueries")
    def graph_queries(self) -> pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesGraphQueriesArgs']]]:
        """
        The graph query to show the current data status
        """
        return pulumi.get(self, "graph_queries")

    @graph_queries.setter
    def graph_queries(self, value: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesGraphQueriesArgs']]]):
        pulumi.set(self, "graph_queries", value)

    @property
    @pulumi.getter(name="graphQueriesTableName")
    def graph_queries_table_name(self) -> pulumi.Input[str]:
        """
        Name of the table the connector will insert the data to
        """
        return pulumi.get(self, "graph_queries_table_name")

    @graph_queries_table_name.setter
    def graph_queries_table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "graph_queries_table_name", value)

    @property
    @pulumi.getter(name="instructionSteps")
    def instruction_steps(self) -> pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesInstructionStepsArgs']]]:
        """
        Instruction steps to enable the connector
        """
        return pulumi.get(self, "instruction_steps")

    @instruction_steps.setter
    def instruction_steps(self, value: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesInstructionStepsArgs']]]):
        pulumi.set(self, "instruction_steps", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input['PermissionsArgs']:
        """
        Permissions required for the connector
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input['PermissionsArgs']):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Connector publisher name
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter(name="sampleQueries")
    def sample_queries(self) -> pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesSampleQueriesArgs']]]:
        """
        The sample queries for the connector
        """
        return pulumi.get(self, "sample_queries")

    @sample_queries.setter
    def sample_queries(self, value: pulumi.Input[Sequence[pulumi.Input['CodelessUiConnectorConfigPropertiesSampleQueriesArgs']]]):
        pulumi.set(self, "sample_queries", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        """
        Connector blade title
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="customImage")
    def custom_image(self) -> Optional[pulumi.Input[str]]:
        """
        An optional custom image to be used when displaying the connector within Azure Sentinel's connector's gallery
        """
        return pulumi.get(self, "custom_image")

    @custom_image.setter
    def custom_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_image", value)


if not MYPY:
    class ConnectivityCriterionArgsDict(TypedDict):
        """
        The criteria by which we determine whether the connector is connected or not.
        For Example, use a KQL query to check if  the expected data type is flowing).
        """
        type: pulumi.Input[str]
        """
        Gets or sets the type of connectivity.
        """
        value: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Gets or sets the queries for checking connectivity.
        """
elif False:
    ConnectivityCriterionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectivityCriterionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The criteria by which we determine whether the connector is connected or not.
        For Example, use a KQL query to check if  the expected data type is flowing).
        :param pulumi.Input[str] type: Gets or sets the type of connectivity.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] value: Gets or sets the queries for checking connectivity.
        """
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Gets or sets the type of connectivity.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Gets or sets the queries for checking connectivity.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ConnectorDataTypeArgsDict(TypedDict):
        """
        The data type which is created by the connector,
        including a query indicated when was the last time that data type was received in the workspace.
        """
        last_data_received_query: pulumi.Input[str]
        """
        Gets or sets the query to indicate when relevant data was last received in the workspace.
        """
        name: pulumi.Input[str]
        """
        Gets or sets the name of the data type to show in the graph.
        """
elif False:
    ConnectorDataTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorDataTypeArgs:
    def __init__(__self__, *,
                 last_data_received_query: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        The data type which is created by the connector,
        including a query indicated when was the last time that data type was received in the workspace.
        :param pulumi.Input[str] last_data_received_query: Gets or sets the query to indicate when relevant data was last received in the workspace.
        :param pulumi.Input[str] name: Gets or sets the name of the data type to show in the graph.
        """
        pulumi.set(__self__, "last_data_received_query", last_data_received_query)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lastDataReceivedQuery")
    def last_data_received_query(self) -> pulumi.Input[str]:
        """
        Gets or sets the query to indicate when relevant data was last received in the workspace.
        """
        return pulumi.get(self, "last_data_received_query")

    @last_data_received_query.setter
    def last_data_received_query(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_data_received_query", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Gets or sets the name of the data type to show in the graph.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ConnectorDefinitionsAvailabilityArgsDict(TypedDict):
        """
        The exposure status of the connector to the customers.
        """
        is_preview: NotRequired[pulumi.Input[bool]]
        """
        Gets or sets a value indicating whether the connector is preview.
        """
        status: NotRequired[pulumi.Input[int]]
        """
        The exposure status of the connector to the customers. Available values are 0-4 (0=None, 1=Available, 2=FeatureFlag, 3=Internal).
        """
elif False:
    ConnectorDefinitionsAvailabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorDefinitionsAvailabilityArgs:
    def __init__(__self__, *,
                 is_preview: Optional[pulumi.Input[bool]] = None,
                 status: Optional[pulumi.Input[int]] = None):
        """
        The exposure status of the connector to the customers.
        :param pulumi.Input[bool] is_preview: Gets or sets a value indicating whether the connector is preview.
        :param pulumi.Input[int] status: The exposure status of the connector to the customers. Available values are 0-4 (0=None, 1=Available, 2=FeatureFlag, 3=Internal).
        """
        if is_preview is not None:
            pulumi.set(__self__, "is_preview", is_preview)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="isPreview")
    def is_preview(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets or sets a value indicating whether the connector is preview.
        """
        return pulumi.get(self, "is_preview")

    @is_preview.setter
    def is_preview(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_preview", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[int]]:
        """
        The exposure status of the connector to the customers. Available values are 0-4 (0=None, 1=Available, 2=FeatureFlag, 3=Internal).
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ConnectorDefinitionsPermissionsArgsDict(TypedDict):
        """
        The required Permissions for the connector.
        """
        customs: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomPermissionDetailsArgsDict']]]]
        """
        Gets or sets the customs permissions required for the user to create connections.
        """
        licenses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Gets or sets the required licenses for the user to create connections.
        """
        resource_provider: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectorDefinitionsResourceProviderArgsDict']]]]
        """
        Gets or sets the resource provider permissions required for the user to create connections.
        """
        tenant: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Gets or sets the required tenant permissions for the connector.
        """
elif False:
    ConnectorDefinitionsPermissionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorDefinitionsPermissionsArgs:
    def __init__(__self__, *,
                 customs: Optional[pulumi.Input[Sequence[pulumi.Input['CustomPermissionDetailsArgs']]]] = None,
                 licenses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_provider: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorDefinitionsResourceProviderArgs']]]] = None,
                 tenant: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The required Permissions for the connector.
        :param pulumi.Input[Sequence[pulumi.Input['CustomPermissionDetailsArgs']]] customs: Gets or sets the customs permissions required for the user to create connections.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] licenses: Gets or sets the required licenses for the user to create connections.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectorDefinitionsResourceProviderArgs']]] resource_provider: Gets or sets the resource provider permissions required for the user to create connections.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tenant: Gets or sets the required tenant permissions for the connector.
        """
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if licenses is not None:
            pulumi.set(__self__, "licenses", licenses)
        if resource_provider is not None:
            pulumi.set(__self__, "resource_provider", resource_provider)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)

    @property
    @pulumi.getter
    def customs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomPermissionDetailsArgs']]]]:
        """
        Gets or sets the customs permissions required for the user to create connections.
        """
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomPermissionDetailsArgs']]]]):
        pulumi.set(self, "customs", value)

    @property
    @pulumi.getter
    def licenses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Gets or sets the required licenses for the user to create connections.
        """
        return pulumi.get(self, "licenses")

    @licenses.setter
    def licenses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "licenses", value)

    @property
    @pulumi.getter(name="resourceProvider")
    def resource_provider(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorDefinitionsResourceProviderArgs']]]]:
        """
        Gets or sets the resource provider permissions required for the user to create connections.
        """
        return pulumi.get(self, "resource_provider")

    @resource_provider.setter
    def resource_provider(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorDefinitionsResourceProviderArgs']]]]):
        pulumi.set(self, "resource_provider", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Gets or sets the required tenant permissions for the connector.
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tenant", value)


if not MYPY:
    class ConnectorDefinitionsResourceProviderArgsDict(TypedDict):
        """
        The resource provider details include the required permissions for the user to create connections.
        The user should have the required permissions(Read\\Write, ..) in the specified scope ProviderPermissionsScope against the specified resource provider.
        """
        permissions_display_text: pulumi.Input[str]
        """
        Gets or sets the permissions description text.
        """
        provider: pulumi.Input[str]
        """
        Gets or sets the provider name.
        """
        provider_display_name: pulumi.Input[str]
        """
        Gets or sets the permissions provider display name.
        """
        required_permissions: pulumi.Input['ResourceProviderRequiredPermissionsArgsDict']
        """
        Required permissions for the connector resource provider that define in ResourceProviders.
        For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
        """
        scope: pulumi.Input[Union[str, 'ProviderPermissionsScope']]
        """
        The scope on which the user should have permissions, in order to be able to create connections.
        """
elif False:
    ConnectorDefinitionsResourceProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorDefinitionsResourceProviderArgs:
    def __init__(__self__, *,
                 permissions_display_text: pulumi.Input[str],
                 provider: pulumi.Input[str],
                 provider_display_name: pulumi.Input[str],
                 required_permissions: pulumi.Input['ResourceProviderRequiredPermissionsArgs'],
                 scope: pulumi.Input[Union[str, 'ProviderPermissionsScope']]):
        """
        The resource provider details include the required permissions for the user to create connections.
        The user should have the required permissions(Read\\Write, ..) in the specified scope ProviderPermissionsScope against the specified resource provider.
        :param pulumi.Input[str] permissions_display_text: Gets or sets the permissions description text.
        :param pulumi.Input[str] provider: Gets or sets the provider name.
        :param pulumi.Input[str] provider_display_name: Gets or sets the permissions provider display name.
        :param pulumi.Input['ResourceProviderRequiredPermissionsArgs'] required_permissions: Required permissions for the connector resource provider that define in ResourceProviders.
               For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
        :param pulumi.Input[Union[str, 'ProviderPermissionsScope']] scope: The scope on which the user should have permissions, in order to be able to create connections.
        """
        pulumi.set(__self__, "permissions_display_text", permissions_display_text)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "provider_display_name", provider_display_name)
        pulumi.set(__self__, "required_permissions", required_permissions)
        pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="permissionsDisplayText")
    def permissions_display_text(self) -> pulumi.Input[str]:
        """
        Gets or sets the permissions description text.
        """
        return pulumi.get(self, "permissions_display_text")

    @permissions_display_text.setter
    def permissions_display_text(self, value: pulumi.Input[str]):
        pulumi.set(self, "permissions_display_text", value)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input[str]:
        """
        Gets or sets the provider name.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter(name="providerDisplayName")
    def provider_display_name(self) -> pulumi.Input[str]:
        """
        Gets or sets the permissions provider display name.
        """
        return pulumi.get(self, "provider_display_name")

    @provider_display_name.setter
    def provider_display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider_display_name", value)

    @property
    @pulumi.getter(name="requiredPermissions")
    def required_permissions(self) -> pulumi.Input['ResourceProviderRequiredPermissionsArgs']:
        """
        Required permissions for the connector resource provider that define in ResourceProviders.
        For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
        """
        return pulumi.get(self, "required_permissions")

    @required_permissions.setter
    def required_permissions(self, value: pulumi.Input['ResourceProviderRequiredPermissionsArgs']):
        pulumi.set(self, "required_permissions", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[Union[str, 'ProviderPermissionsScope']]:
        """
        The scope on which the user should have permissions, in order to be able to create connections.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[Union[str, 'ProviderPermissionsScope']]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class CustomPermissionDetailsArgsDict(TypedDict):
        """
        The Custom permissions required for the connector.
        """
        description: pulumi.Input[str]
        """
        Gets or sets the custom permissions description.
        """
        name: pulumi.Input[str]
        """
        Gets or sets the custom permissions name.
        """
elif False:
    CustomPermissionDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomPermissionDetailsArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        The Custom permissions required for the connector.
        :param pulumi.Input[str] description: Gets or sets the custom permissions description.
        :param pulumi.Input[str] name: Gets or sets the custom permissions name.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> pulumi.Input[str]:
        """
        Gets or sets the custom permissions description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Gets or sets the custom permissions name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CustomizableConnectionsConfigArgsDict(TypedDict):
        """
        The UiConfig for 'Customizable' connector definition kind.
        """
        template_spec_name: pulumi.Input[str]
        """
        Gets or sets the template name. The template includes ARM templates that can be created by the connector, usually it will be the dataConnectors ARM templates.
        """
        template_spec_version: pulumi.Input[str]
        """
        Gets or sets the template version.
        """
elif False:
    CustomizableConnectionsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomizableConnectionsConfigArgs:
    def __init__(__self__, *,
                 template_spec_name: pulumi.Input[str],
                 template_spec_version: pulumi.Input[str]):
        """
        The UiConfig for 'Customizable' connector definition kind.
        :param pulumi.Input[str] template_spec_name: Gets or sets the template name. The template includes ARM templates that can be created by the connector, usually it will be the dataConnectors ARM templates.
        :param pulumi.Input[str] template_spec_version: Gets or sets the template version.
        """
        pulumi.set(__self__, "template_spec_name", template_spec_name)
        pulumi.set(__self__, "template_spec_version", template_spec_version)

    @property
    @pulumi.getter(name="templateSpecName")
    def template_spec_name(self) -> pulumi.Input[str]:
        """
        Gets or sets the template name. The template includes ARM templates that can be created by the connector, usually it will be the dataConnectors ARM templates.
        """
        return pulumi.get(self, "template_spec_name")

    @template_spec_name.setter
    def template_spec_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "template_spec_name", value)

    @property
    @pulumi.getter(name="templateSpecVersion")
    def template_spec_version(self) -> pulumi.Input[str]:
        """
        Gets or sets the template version.
        """
        return pulumi.get(self, "template_spec_version")

    @template_spec_version.setter
    def template_spec_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "template_spec_version", value)


if not MYPY:
    class CustomizableConnectorUiConfigArgsDict(TypedDict):
        """
        The UiConfig for 'Customizable' connector definition kind.
        """
        connectivity_criteria: pulumi.Input[Sequence[pulumi.Input['ConnectivityCriterionArgsDict']]]
        """
        Gets or sets the way the connector checks whether the connector is connected.
        """
        data_types: pulumi.Input[Sequence[pulumi.Input['ConnectorDataTypeArgsDict']]]
        """
        Gets or sets the data types to check for last data received.
        """
        description_markdown: pulumi.Input[str]
        """
        Gets or sets the connector description in markdown format.
        """
        graph_queries: pulumi.Input[Sequence[pulumi.Input['GraphQueryArgsDict']]]
        """
        Gets or sets the graph queries to show the current data volume over time.
        """
        instruction_steps: pulumi.Input[Sequence[pulumi.Input['InstructionStepArgsDict']]]
        """
        Gets or sets the instruction steps to enable the connector.
        """
        permissions: pulumi.Input['ConnectorDefinitionsPermissionsArgsDict']
        """
        The required Permissions for the connector.
        """
        publisher: pulumi.Input[str]
        """
        Gets or sets the connector publisher name.
        """
        title: pulumi.Input[str]
        """
        Gets or sets the connector blade title.
        """
        availability: NotRequired[pulumi.Input['ConnectorDefinitionsAvailabilityArgsDict']]
        """
        The exposure status of the connector to the customers.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Gets or sets custom connector id. optional field.
        """
        is_connectivity_criterias_match_some: NotRequired[pulumi.Input[bool]]
        """
        Gets or sets a value indicating whether to use 'OR'(SOME) or 'AND' between ConnectivityCriteria items.
        """
        logo: NotRequired[pulumi.Input[str]]
        """
        Gets or sets the connector logo to be used when displaying the connector within Azure Sentinel's connector's gallery.
        The logo value should be in SVG format.
        """
elif False:
    CustomizableConnectorUiConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomizableConnectorUiConfigArgs:
    def __init__(__self__, *,
                 connectivity_criteria: pulumi.Input[Sequence[pulumi.Input['ConnectivityCriterionArgs']]],
                 data_types: pulumi.Input[Sequence[pulumi.Input['ConnectorDataTypeArgs']]],
                 description_markdown: pulumi.Input[str],
                 graph_queries: pulumi.Input[Sequence[pulumi.Input['GraphQueryArgs']]],
                 instruction_steps: pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]],
                 permissions: pulumi.Input['ConnectorDefinitionsPermissionsArgs'],
                 publisher: pulumi.Input[str],
                 title: pulumi.Input[str],
                 availability: Optional[pulumi.Input['ConnectorDefinitionsAvailabilityArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_connectivity_criterias_match_some: Optional[pulumi.Input[bool]] = None,
                 logo: Optional[pulumi.Input[str]] = None):
        """
        The UiConfig for 'Customizable' connector definition kind.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectivityCriterionArgs']]] connectivity_criteria: Gets or sets the way the connector checks whether the connector is connected.
        :param pulumi.Input[Sequence[pulumi.Input['ConnectorDataTypeArgs']]] data_types: Gets or sets the data types to check for last data received.
        :param pulumi.Input[str] description_markdown: Gets or sets the connector description in markdown format.
        :param pulumi.Input[Sequence[pulumi.Input['GraphQueryArgs']]] graph_queries: Gets or sets the graph queries to show the current data volume over time.
        :param pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]] instruction_steps: Gets or sets the instruction steps to enable the connector.
        :param pulumi.Input['ConnectorDefinitionsPermissionsArgs'] permissions: The required Permissions for the connector.
        :param pulumi.Input[str] publisher: Gets or sets the connector publisher name.
        :param pulumi.Input[str] title: Gets or sets the connector blade title.
        :param pulumi.Input['ConnectorDefinitionsAvailabilityArgs'] availability: The exposure status of the connector to the customers.
        :param pulumi.Input[str] id: Gets or sets custom connector id. optional field.
        :param pulumi.Input[bool] is_connectivity_criterias_match_some: Gets or sets a value indicating whether to use 'OR'(SOME) or 'AND' between ConnectivityCriteria items.
        :param pulumi.Input[str] logo: Gets or sets the connector logo to be used when displaying the connector within Azure Sentinel's connector's gallery.
               The logo value should be in SVG format.
        """
        pulumi.set(__self__, "connectivity_criteria", connectivity_criteria)
        pulumi.set(__self__, "data_types", data_types)
        pulumi.set(__self__, "description_markdown", description_markdown)
        pulumi.set(__self__, "graph_queries", graph_queries)
        pulumi.set(__self__, "instruction_steps", instruction_steps)
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "title", title)
        if availability is not None:
            pulumi.set(__self__, "availability", availability)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_connectivity_criterias_match_some is not None:
            pulumi.set(__self__, "is_connectivity_criterias_match_some", is_connectivity_criterias_match_some)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)

    @property
    @pulumi.getter(name="connectivityCriteria")
    def connectivity_criteria(self) -> pulumi.Input[Sequence[pulumi.Input['ConnectivityCriterionArgs']]]:
        """
        Gets or sets the way the connector checks whether the connector is connected.
        """
        return pulumi.get(self, "connectivity_criteria")

    @connectivity_criteria.setter
    def connectivity_criteria(self, value: pulumi.Input[Sequence[pulumi.Input['ConnectivityCriterionArgs']]]):
        pulumi.set(self, "connectivity_criteria", value)

    @property
    @pulumi.getter(name="dataTypes")
    def data_types(self) -> pulumi.Input[Sequence[pulumi.Input['ConnectorDataTypeArgs']]]:
        """
        Gets or sets the data types to check for last data received.
        """
        return pulumi.get(self, "data_types")

    @data_types.setter
    def data_types(self, value: pulumi.Input[Sequence[pulumi.Input['ConnectorDataTypeArgs']]]):
        pulumi.set(self, "data_types", value)

    @property
    @pulumi.getter(name="descriptionMarkdown")
    def description_markdown(self) -> pulumi.Input[str]:
        """
        Gets or sets the connector description in markdown format.
        """
        return pulumi.get(self, "description_markdown")

    @description_markdown.setter
    def description_markdown(self, value: pulumi.Input[str]):
        pulumi.set(self, "description_markdown", value)

    @property
    @pulumi.getter(name="graphQueries")
    def graph_queries(self) -> pulumi.Input[Sequence[pulumi.Input['GraphQueryArgs']]]:
        """
        Gets or sets the graph queries to show the current data volume over time.
        """
        return pulumi.get(self, "graph_queries")

    @graph_queries.setter
    def graph_queries(self, value: pulumi.Input[Sequence[pulumi.Input['GraphQueryArgs']]]):
        pulumi.set(self, "graph_queries", value)

    @property
    @pulumi.getter(name="instructionSteps")
    def instruction_steps(self) -> pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]]:
        """
        Gets or sets the instruction steps to enable the connector.
        """
        return pulumi.get(self, "instruction_steps")

    @instruction_steps.setter
    def instruction_steps(self, value: pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]]):
        pulumi.set(self, "instruction_steps", value)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input['ConnectorDefinitionsPermissionsArgs']:
        """
        The required Permissions for the connector.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input['ConnectorDefinitionsPermissionsArgs']):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        Gets or sets the connector publisher name.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        """
        Gets or sets the connector blade title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def availability(self) -> Optional[pulumi.Input['ConnectorDefinitionsAvailabilityArgs']]:
        """
        The exposure status of the connector to the customers.
        """
        return pulumi.get(self, "availability")

    @availability.setter
    def availability(self, value: Optional[pulumi.Input['ConnectorDefinitionsAvailabilityArgs']]):
        pulumi.set(self, "availability", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets custom connector id. optional field.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isConnectivityCriteriasMatchSome")
    def is_connectivity_criterias_match_some(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets or sets a value indicating whether to use 'OR'(SOME) or 'AND' between ConnectivityCriteria items.
        """
        return pulumi.get(self, "is_connectivity_criterias_match_some")

    @is_connectivity_criterias_match_some.setter
    def is_connectivity_criterias_match_some(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_connectivity_criterias_match_some", value)

    @property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the connector logo to be used when displaying the connector within Azure Sentinel's connector's gallery.
        The logo value should be in SVG format.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logo", value)


if not MYPY:
    class DCRConfigurationArgsDict(TypedDict):
        """
        The configuration of the destination of the data.
        """
        data_collection_endpoint: pulumi.Input[str]
        """
        Represents the data collection ingestion endpoint in log analytics.
        """
        data_collection_rule_immutable_id: pulumi.Input[str]
        """
        The data collection rule immutable id, the rule defines the transformation and data destination.
        """
        stream_name: pulumi.Input[str]
        """
        The stream we are sending the data to.
        """
elif False:
    DCRConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DCRConfigurationArgs:
    def __init__(__self__, *,
                 data_collection_endpoint: pulumi.Input[str],
                 data_collection_rule_immutable_id: pulumi.Input[str],
                 stream_name: pulumi.Input[str]):
        """
        The configuration of the destination of the data.
        :param pulumi.Input[str] data_collection_endpoint: Represents the data collection ingestion endpoint in log analytics.
        :param pulumi.Input[str] data_collection_rule_immutable_id: The data collection rule immutable id, the rule defines the transformation and data destination.
        :param pulumi.Input[str] stream_name: The stream we are sending the data to.
        """
        pulumi.set(__self__, "data_collection_endpoint", data_collection_endpoint)
        pulumi.set(__self__, "data_collection_rule_immutable_id", data_collection_rule_immutable_id)
        pulumi.set(__self__, "stream_name", stream_name)

    @property
    @pulumi.getter(name="dataCollectionEndpoint")
    def data_collection_endpoint(self) -> pulumi.Input[str]:
        """
        Represents the data collection ingestion endpoint in log analytics.
        """
        return pulumi.get(self, "data_collection_endpoint")

    @data_collection_endpoint.setter
    def data_collection_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_collection_endpoint", value)

    @property
    @pulumi.getter(name="dataCollectionRuleImmutableId")
    def data_collection_rule_immutable_id(self) -> pulumi.Input[str]:
        """
        The data collection rule immutable id, the rule defines the transformation and data destination.
        """
        return pulumi.get(self, "data_collection_rule_immutable_id")

    @data_collection_rule_immutable_id.setter
    def data_collection_rule_immutable_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_collection_rule_immutable_id", value)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[str]:
        """
        The stream we are sending the data to.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_name", value)


if not MYPY:
    class DataConnectorDataTypeCommonArgsDict(TypedDict):
        """
        Common field for data type in data connectors.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    DataConnectorDataTypeCommonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataConnectorDataTypeCommonArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Common field for data type in data connectors.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class Dynamics365DataConnectorDataTypesDynamics365CdsActivitiesArgsDict(TypedDict):
        """
        Common Data Service data type connection.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    Dynamics365DataConnectorDataTypesDynamics365CdsActivitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Dynamics365DataConnectorDataTypesDynamics365CdsActivitiesArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Common Data Service data type connection.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class Dynamics365DataConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for Dynamics365 data connector.
        """
        dynamics365_cds_activities: pulumi.Input['Dynamics365DataConnectorDataTypesDynamics365CdsActivitiesArgsDict']
        """
        Common Data Service data type connection.
        """
elif False:
    Dynamics365DataConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Dynamics365DataConnectorDataTypesArgs:
    def __init__(__self__, *,
                 dynamics365_cds_activities: pulumi.Input['Dynamics365DataConnectorDataTypesDynamics365CdsActivitiesArgs']):
        """
        The available data types for Dynamics365 data connector.
        :param pulumi.Input['Dynamics365DataConnectorDataTypesDynamics365CdsActivitiesArgs'] dynamics365_cds_activities: Common Data Service data type connection.
        """
        pulumi.set(__self__, "dynamics365_cds_activities", dynamics365_cds_activities)

    @property
    @pulumi.getter(name="dynamics365CdsActivities")
    def dynamics365_cds_activities(self) -> pulumi.Input['Dynamics365DataConnectorDataTypesDynamics365CdsActivitiesArgs']:
        """
        Common Data Service data type connection.
        """
        return pulumi.get(self, "dynamics365_cds_activities")

    @dynamics365_cds_activities.setter
    def dynamics365_cds_activities(self, value: pulumi.Input['Dynamics365DataConnectorDataTypesDynamics365CdsActivitiesArgs']):
        pulumi.set(self, "dynamics365_cds_activities", value)


if not MYPY:
    class EntityFieldMappingArgsDict(TypedDict):
        """
        Map identifiers of a single entity
        """
        identifier: NotRequired[pulumi.Input[str]]
        """
        Alert V3 identifier
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the identifier
        """
elif False:
    EntityFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityFieldMappingArgs:
    def __init__(__self__, *,
                 identifier: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Map identifiers of a single entity
        :param pulumi.Input[str] identifier: Alert V3 identifier
        :param pulumi.Input[str] value: The value of the identifier
        """
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def identifier(self) -> Optional[pulumi.Input[str]]:
        """
        Alert V3 identifier
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the identifier
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EntityMappingArgsDict(TypedDict):
        """
        Single entity mapping for the alert rule
        """
        entity_type: NotRequired[pulumi.Input[Union[str, 'EntityMappingType']]]
        """
        The V3 type of the mapped entity
        """
        field_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['FieldMappingArgsDict']]]]
        """
        array of field mappings for the given entity mapping
        """
elif False:
    EntityMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityMappingArgs:
    def __init__(__self__, *,
                 entity_type: Optional[pulumi.Input[Union[str, 'EntityMappingType']]] = None,
                 field_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['FieldMappingArgs']]]] = None):
        """
        Single entity mapping for the alert rule
        :param pulumi.Input[Union[str, 'EntityMappingType']] entity_type: The V3 type of the mapped entity
        :param pulumi.Input[Sequence[pulumi.Input['FieldMappingArgs']]] field_mappings: array of field mappings for the given entity mapping
        """
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if field_mappings is not None:
            pulumi.set(__self__, "field_mappings", field_mappings)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[Union[str, 'EntityMappingType']]]:
        """
        The V3 type of the mapped entity
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[Union[str, 'EntityMappingType']]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="fieldMappings")
    def field_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FieldMappingArgs']]]]:
        """
        array of field mappings for the given entity mapping
        """
        return pulumi.get(self, "field_mappings")

    @field_mappings.setter
    def field_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FieldMappingArgs']]]]):
        pulumi.set(self, "field_mappings", value)


if not MYPY:
    class EventGroupingSettingsArgsDict(TypedDict):
        """
        Event grouping settings property bag.
        """
        aggregation_kind: NotRequired[pulumi.Input[Union[str, 'EventGroupingAggregationKind']]]
        """
        The event grouping aggregation kinds
        """
elif False:
    EventGroupingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventGroupingSettingsArgs:
    def __init__(__self__, *,
                 aggregation_kind: Optional[pulumi.Input[Union[str, 'EventGroupingAggregationKind']]] = None):
        """
        Event grouping settings property bag.
        :param pulumi.Input[Union[str, 'EventGroupingAggregationKind']] aggregation_kind: The event grouping aggregation kinds
        """
        if aggregation_kind is not None:
            pulumi.set(__self__, "aggregation_kind", aggregation_kind)

    @property
    @pulumi.getter(name="aggregationKind")
    def aggregation_kind(self) -> Optional[pulumi.Input[Union[str, 'EventGroupingAggregationKind']]]:
        """
        The event grouping aggregation kinds
        """
        return pulumi.get(self, "aggregation_kind")

    @aggregation_kind.setter
    def aggregation_kind(self, value: Optional[pulumi.Input[Union[str, 'EventGroupingAggregationKind']]]):
        pulumi.set(self, "aggregation_kind", value)


if not MYPY:
    class FieldMappingArgsDict(TypedDict):
        """
        A single field mapping of the mapped entity
        """
        column_name: NotRequired[pulumi.Input[str]]
        """
        the column name to be mapped to the identifier
        """
        identifier: NotRequired[pulumi.Input[str]]
        """
        the V3 identifier of the entity
        """
elif False:
    FieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FieldMappingArgs:
    def __init__(__self__, *,
                 column_name: Optional[pulumi.Input[str]] = None,
                 identifier: Optional[pulumi.Input[str]] = None):
        """
        A single field mapping of the mapped entity
        :param pulumi.Input[str] column_name: the column name to be mapped to the identifier
        :param pulumi.Input[str] identifier: the V3 identifier of the entity
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[str]]:
        """
        the column name to be mapped to the identifier
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter
    def identifier(self) -> Optional[pulumi.Input[str]]:
        """
        the V3 identifier of the entity
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class FileMetadataArgsDict(TypedDict):
        """
        Represents a file.
        """
        file_format: NotRequired[pulumi.Input[Union[str, 'FileFormat']]]
        """
        The format of the file
        """
        file_name: NotRequired[pulumi.Input[str]]
        """
        The name of the file.
        """
        file_size: NotRequired[pulumi.Input[int]]
        """
        The size of the file.
        """
elif False:
    FileMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileMetadataArgs:
    def __init__(__self__, *,
                 file_format: Optional[pulumi.Input[Union[str, 'FileFormat']]] = None,
                 file_name: Optional[pulumi.Input[str]] = None,
                 file_size: Optional[pulumi.Input[int]] = None):
        """
        Represents a file.
        :param pulumi.Input[Union[str, 'FileFormat']] file_format: The format of the file
        :param pulumi.Input[str] file_name: The name of the file.
        :param pulumi.Input[int] file_size: The size of the file.
        """
        if file_format is not None:
            pulumi.set(__self__, "file_format", file_format)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if file_size is not None:
            pulumi.set(__self__, "file_size", file_size)

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> Optional[pulumi.Input[Union[str, 'FileFormat']]]:
        """
        The format of the file
        """
        return pulumi.get(self, "file_format")

    @file_format.setter
    def file_format(self, value: Optional[pulumi.Input[Union[str, 'FileFormat']]]):
        pulumi.set(self, "file_format", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the file.
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter(name="fileSize")
    def file_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the file.
        """
        return pulumi.get(self, "file_size")

    @file_size.setter
    def file_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "file_size", value)


if not MYPY:
    class FusionScenarioExclusionPatternArgsDict(TypedDict):
        """
        Represents a Fusion scenario exclusion patterns in Fusion detection.
        """
        date_added_in_utc: pulumi.Input[str]
        """
        DateTime when scenario exclusion pattern is added in UTC.
        """
        exclusion_pattern: pulumi.Input[str]
        """
        Scenario exclusion pattern.
        """
elif False:
    FusionScenarioExclusionPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionScenarioExclusionPatternArgs:
    def __init__(__self__, *,
                 date_added_in_utc: pulumi.Input[str],
                 exclusion_pattern: pulumi.Input[str]):
        """
        Represents a Fusion scenario exclusion patterns in Fusion detection.
        :param pulumi.Input[str] date_added_in_utc: DateTime when scenario exclusion pattern is added in UTC.
        :param pulumi.Input[str] exclusion_pattern: Scenario exclusion pattern.
        """
        pulumi.set(__self__, "date_added_in_utc", date_added_in_utc)
        pulumi.set(__self__, "exclusion_pattern", exclusion_pattern)

    @property
    @pulumi.getter(name="dateAddedInUTC")
    def date_added_in_utc(self) -> pulumi.Input[str]:
        """
        DateTime when scenario exclusion pattern is added in UTC.
        """
        return pulumi.get(self, "date_added_in_utc")

    @date_added_in_utc.setter
    def date_added_in_utc(self, value: pulumi.Input[str]):
        pulumi.set(self, "date_added_in_utc", value)

    @property
    @pulumi.getter(name="exclusionPattern")
    def exclusion_pattern(self) -> pulumi.Input[str]:
        """
        Scenario exclusion pattern.
        """
        return pulumi.get(self, "exclusion_pattern")

    @exclusion_pattern.setter
    def exclusion_pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "exclusion_pattern", value)


if not MYPY:
    class FusionSourceSettingsArgsDict(TypedDict):
        """
        Represents a supported source signal configuration in Fusion detection.
        """
        enabled: pulumi.Input[bool]
        """
        Determines whether this source signal is enabled or disabled in Fusion detection.
        """
        source_name: pulumi.Input[str]
        """
        Name of the Fusion source signal. Refer to Fusion alert rule template for supported values.
        """
        source_sub_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['FusionSourceSubTypeSettingArgsDict']]]]
        """
        Configuration for all source subtypes under this source signal consumed in fusion detection.
        """
elif False:
    FusionSourceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionSourceSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 source_name: pulumi.Input[str],
                 source_sub_types: Optional[pulumi.Input[Sequence[pulumi.Input['FusionSourceSubTypeSettingArgs']]]] = None):
        """
        Represents a supported source signal configuration in Fusion detection.
        :param pulumi.Input[bool] enabled: Determines whether this source signal is enabled or disabled in Fusion detection.
        :param pulumi.Input[str] source_name: Name of the Fusion source signal. Refer to Fusion alert rule template for supported values.
        :param pulumi.Input[Sequence[pulumi.Input['FusionSourceSubTypeSettingArgs']]] source_sub_types: Configuration for all source subtypes under this source signal consumed in fusion detection.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "source_name", source_name)
        if source_sub_types is not None:
            pulumi.set(__self__, "source_sub_types", source_sub_types)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Determines whether this source signal is enabled or disabled in Fusion detection.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> pulumi.Input[str]:
        """
        Name of the Fusion source signal. Refer to Fusion alert rule template for supported values.
        """
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_name", value)

    @property
    @pulumi.getter(name="sourceSubTypes")
    def source_sub_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FusionSourceSubTypeSettingArgs']]]]:
        """
        Configuration for all source subtypes under this source signal consumed in fusion detection.
        """
        return pulumi.get(self, "source_sub_types")

    @source_sub_types.setter
    def source_sub_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FusionSourceSubTypeSettingArgs']]]]):
        pulumi.set(self, "source_sub_types", value)


if not MYPY:
    class FusionSourceSubTypeSettingArgsDict(TypedDict):
        """
        Represents a supported source subtype configuration under a source signal in Fusion detection.
        """
        enabled: pulumi.Input[bool]
        """
        Determines whether this source subtype under source signal is enabled or disabled in Fusion detection.
        """
        severity_filters: pulumi.Input['FusionSubTypeSeverityFilterArgsDict']
        """
        Severity configuration for a source subtype consumed in fusion detection.
        """
        source_sub_type_name: pulumi.Input[str]
        """
        The Name of the source subtype under a given source signal in Fusion detection. Refer to Fusion alert rule template for supported values.
        """
elif False:
    FusionSourceSubTypeSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionSourceSubTypeSettingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 severity_filters: pulumi.Input['FusionSubTypeSeverityFilterArgs'],
                 source_sub_type_name: pulumi.Input[str]):
        """
        Represents a supported source subtype configuration under a source signal in Fusion detection.
        :param pulumi.Input[bool] enabled: Determines whether this source subtype under source signal is enabled or disabled in Fusion detection.
        :param pulumi.Input['FusionSubTypeSeverityFilterArgs'] severity_filters: Severity configuration for a source subtype consumed in fusion detection.
        :param pulumi.Input[str] source_sub_type_name: The Name of the source subtype under a given source signal in Fusion detection. Refer to Fusion alert rule template for supported values.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "severity_filters", severity_filters)
        pulumi.set(__self__, "source_sub_type_name", source_sub_type_name)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Determines whether this source subtype under source signal is enabled or disabled in Fusion detection.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="severityFilters")
    def severity_filters(self) -> pulumi.Input['FusionSubTypeSeverityFilterArgs']:
        """
        Severity configuration for a source subtype consumed in fusion detection.
        """
        return pulumi.get(self, "severity_filters")

    @severity_filters.setter
    def severity_filters(self, value: pulumi.Input['FusionSubTypeSeverityFilterArgs']):
        pulumi.set(self, "severity_filters", value)

    @property
    @pulumi.getter(name="sourceSubTypeName")
    def source_sub_type_name(self) -> pulumi.Input[str]:
        """
        The Name of the source subtype under a given source signal in Fusion detection. Refer to Fusion alert rule template for supported values.
        """
        return pulumi.get(self, "source_sub_type_name")

    @source_sub_type_name.setter
    def source_sub_type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_sub_type_name", value)


if not MYPY:
    class FusionSubTypeSeverityFiltersItemArgsDict(TypedDict):
        """
        Represents a Severity filter setting for a given source subtype consumed in Fusion detection.
        """
        enabled: pulumi.Input[bool]
        """
        Determines whether this severity is enabled or disabled for this source subtype consumed in Fusion detection.
        """
        severity: pulumi.Input[Union[str, 'AlertSeverity']]
        """
        The Severity for a given source subtype consumed in Fusion detection.
        """
elif False:
    FusionSubTypeSeverityFiltersItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionSubTypeSeverityFiltersItemArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 severity: pulumi.Input[Union[str, 'AlertSeverity']]):
        """
        Represents a Severity filter setting for a given source subtype consumed in Fusion detection.
        :param pulumi.Input[bool] enabled: Determines whether this severity is enabled or disabled for this source subtype consumed in Fusion detection.
        :param pulumi.Input[Union[str, 'AlertSeverity']] severity: The Severity for a given source subtype consumed in Fusion detection.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Determines whether this severity is enabled or disabled for this source subtype consumed in Fusion detection.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def severity(self) -> pulumi.Input[Union[str, 'AlertSeverity']]:
        """
        The Severity for a given source subtype consumed in Fusion detection.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[Union[str, 'AlertSeverity']]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class FusionSubTypeSeverityFilterArgsDict(TypedDict):
        """
        Represents severity configuration for a source subtype consumed in Fusion detection.
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['FusionSubTypeSeverityFiltersItemArgsDict']]]]
        """
        Individual Severity configuration settings for a given source subtype consumed in Fusion detection.
        """
elif False:
    FusionSubTypeSeverityFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FusionSubTypeSeverityFilterArgs:
    def __init__(__self__, *,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input['FusionSubTypeSeverityFiltersItemArgs']]]] = None):
        """
        Represents severity configuration for a source subtype consumed in Fusion detection.
        :param pulumi.Input[Sequence[pulumi.Input['FusionSubTypeSeverityFiltersItemArgs']]] filters: Individual Severity configuration settings for a given source subtype consumed in Fusion detection.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FusionSubTypeSeverityFiltersItemArgs']]]]:
        """
        Individual Severity configuration settings for a given source subtype consumed in Fusion detection.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FusionSubTypeSeverityFiltersItemArgs']]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class GCPAuthModelArgsDict(TypedDict):
        """
        Model for API authentication for all GCP kind connectors.
        """
        project_number: pulumi.Input[str]
        """
        GCP Project Number
        """
        service_account_email: pulumi.Input[str]
        """
        GCP Service Account Email
        """
        type: pulumi.Input[str]
        """
        Type of paging
        Expected value is 'GCP'.
        """
        workload_identity_provider_id: pulumi.Input[str]
        """
        GCP Workload Identity Provider ID
        """
elif False:
    GCPAuthModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GCPAuthModelArgs:
    def __init__(__self__, *,
                 project_number: pulumi.Input[str],
                 service_account_email: pulumi.Input[str],
                 type: pulumi.Input[str],
                 workload_identity_provider_id: pulumi.Input[str]):
        """
        Model for API authentication for all GCP kind connectors.
        :param pulumi.Input[str] project_number: GCP Project Number
        :param pulumi.Input[str] service_account_email: GCP Service Account Email
        :param pulumi.Input[str] type: Type of paging
               Expected value is 'GCP'.
        :param pulumi.Input[str] workload_identity_provider_id: GCP Workload Identity Provider ID
        """
        pulumi.set(__self__, "project_number", project_number)
        pulumi.set(__self__, "service_account_email", service_account_email)
        pulumi.set(__self__, "type", 'GCP')
        pulumi.set(__self__, "workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="projectNumber")
    def project_number(self) -> pulumi.Input[str]:
        """
        GCP Project Number
        """
        return pulumi.get(self, "project_number")

    @project_number.setter
    def project_number(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_number", value)

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> pulumi.Input[str]:
        """
        GCP Service Account Email
        """
        return pulumi.get(self, "service_account_email")

    @service_account_email.setter
    def service_account_email(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_email", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of paging
        Expected value is 'GCP'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> pulumi.Input[str]:
        """
        GCP Workload Identity Provider ID
        """
        return pulumi.get(self, "workload_identity_provider_id")

    @workload_identity_provider_id.setter
    def workload_identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "workload_identity_provider_id", value)


if not MYPY:
    class GCPAuthPropertiesArgsDict(TypedDict):
        """
        Google Cloud Platform auth section properties.
        """
        project_number: pulumi.Input[str]
        """
        The GCP project number.
        """
        service_account_email: pulumi.Input[str]
        """
        The service account that is used to access the GCP project.
        """
        workload_identity_provider_id: pulumi.Input[str]
        """
        The workload identity provider id that is used to gain access to the GCP project.
        """
elif False:
    GCPAuthPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GCPAuthPropertiesArgs:
    def __init__(__self__, *,
                 project_number: pulumi.Input[str],
                 service_account_email: pulumi.Input[str],
                 workload_identity_provider_id: pulumi.Input[str]):
        """
        Google Cloud Platform auth section properties.
        :param pulumi.Input[str] project_number: The GCP project number.
        :param pulumi.Input[str] service_account_email: The service account that is used to access the GCP project.
        :param pulumi.Input[str] workload_identity_provider_id: The workload identity provider id that is used to gain access to the GCP project.
        """
        pulumi.set(__self__, "project_number", project_number)
        pulumi.set(__self__, "service_account_email", service_account_email)
        pulumi.set(__self__, "workload_identity_provider_id", workload_identity_provider_id)

    @property
    @pulumi.getter(name="projectNumber")
    def project_number(self) -> pulumi.Input[str]:
        """
        The GCP project number.
        """
        return pulumi.get(self, "project_number")

    @project_number.setter
    def project_number(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_number", value)

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> pulumi.Input[str]:
        """
        The service account that is used to access the GCP project.
        """
        return pulumi.get(self, "service_account_email")

    @service_account_email.setter
    def service_account_email(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_email", value)

    @property
    @pulumi.getter(name="workloadIdentityProviderId")
    def workload_identity_provider_id(self) -> pulumi.Input[str]:
        """
        The workload identity provider id that is used to gain access to the GCP project.
        """
        return pulumi.get(self, "workload_identity_provider_id")

    @workload_identity_provider_id.setter
    def workload_identity_provider_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "workload_identity_provider_id", value)


if not MYPY:
    class GCPRequestPropertiesArgsDict(TypedDict):
        """
        Google Cloud Platform request section properties.
        """
        project_id: pulumi.Input[str]
        """
        The GCP project id.
        """
        subscription_names: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The GCP pub/sub subscription names.
        """
elif False:
    GCPRequestPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GCPRequestPropertiesArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[str],
                 subscription_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Google Cloud Platform request section properties.
        :param pulumi.Input[str] project_id: The GCP project id.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subscription_names: The GCP pub/sub subscription names.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "subscription_names", subscription_names)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The GCP project id.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="subscriptionNames")
    def subscription_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The GCP pub/sub subscription names.
        """
        return pulumi.get(self, "subscription_names")

    @subscription_names.setter
    def subscription_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subscription_names", value)


if not MYPY:
    class GenericBlobSbsAuthModelArgsDict(TypedDict):
        """
        Model for API authentication for working with service bus or storage account.
        """
        type: pulumi.Input[str]
        """
        Type of paging
        Expected value is 'ServiceBus'.
        """
        credentials_config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Credentials for service bus namespace, keyvault uri for access key
        """
        storage_account_credentials_config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Credentials for storage account, keyvault uri for access key
        """
elif False:
    GenericBlobSbsAuthModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenericBlobSbsAuthModelArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 credentials_config: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 storage_account_credentials_config: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Model for API authentication for working with service bus or storage account.
        :param pulumi.Input[str] type: Type of paging
               Expected value is 'ServiceBus'.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] credentials_config: Credentials for service bus namespace, keyvault uri for access key
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] storage_account_credentials_config: Credentials for storage account, keyvault uri for access key
        """
        pulumi.set(__self__, "type", 'ServiceBus')
        if credentials_config is not None:
            pulumi.set(__self__, "credentials_config", credentials_config)
        if storage_account_credentials_config is not None:
            pulumi.set(__self__, "storage_account_credentials_config", storage_account_credentials_config)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of paging
        Expected value is 'ServiceBus'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="credentialsConfig")
    def credentials_config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Credentials for service bus namespace, keyvault uri for access key
        """
        return pulumi.get(self, "credentials_config")

    @credentials_config.setter
    def credentials_config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "credentials_config", value)

    @property
    @pulumi.getter(name="storageAccountCredentialsConfig")
    def storage_account_credentials_config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Credentials for storage account, keyvault uri for access key
        """
        return pulumi.get(self, "storage_account_credentials_config")

    @storage_account_credentials_config.setter
    def storage_account_credentials_config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "storage_account_credentials_config", value)


if not MYPY:
    class GitHubAuthModelArgsDict(TypedDict):
        """
        Model for API authentication for GitHub. For this authentication first we need to approve the Router app (Microsoft Security DevOps) to access the GitHub account, Then we only need the InstallationId to get the access token from https://api.github.com/app/installations/{installId}/access_tokens.
        """
        type: pulumi.Input[str]
        """
        Type of paging
        Expected value is 'GitHub'.
        """
        installation_id: NotRequired[pulumi.Input[str]]
        """
        The GitHubApp auth installation id.
        """
elif False:
    GitHubAuthModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitHubAuthModelArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 installation_id: Optional[pulumi.Input[str]] = None):
        """
        Model for API authentication for GitHub. For this authentication first we need to approve the Router app (Microsoft Security DevOps) to access the GitHub account, Then we only need the InstallationId to get the access token from https://api.github.com/app/installations/{installId}/access_tokens.
        :param pulumi.Input[str] type: Type of paging
               Expected value is 'GitHub'.
        :param pulumi.Input[str] installation_id: The GitHubApp auth installation id.
        """
        pulumi.set(__self__, "type", 'GitHub')
        if installation_id is not None:
            pulumi.set(__self__, "installation_id", installation_id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of paging
        Expected value is 'GitHub'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="installationId")
    def installation_id(self) -> Optional[pulumi.Input[str]]:
        """
        The GitHubApp auth installation id.
        """
        return pulumi.get(self, "installation_id")

    @installation_id.setter
    def installation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "installation_id", value)


if not MYPY:
    class GraphQueryArgsDict(TypedDict):
        """
        The graph query to show the volume of data arriving into the workspace over time.
        """
        base_query: pulumi.Input[str]
        """
        Gets or sets the base query for the graph.
        The base query is wrapped by Sentinel UI infra with a KQL query, that measures the volume over time.
        """
        legend: pulumi.Input[str]
        """
        Gets or sets the legend for the graph.
        """
        metric_name: pulumi.Input[str]
        """
        Gets or sets the metric name that the query is checking. For example: 'Total data receive'.
        """
elif False:
    GraphQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GraphQueryArgs:
    def __init__(__self__, *,
                 base_query: pulumi.Input[str],
                 legend: pulumi.Input[str],
                 metric_name: pulumi.Input[str]):
        """
        The graph query to show the volume of data arriving into the workspace over time.
        :param pulumi.Input[str] base_query: Gets or sets the base query for the graph.
               The base query is wrapped by Sentinel UI infra with a KQL query, that measures the volume over time.
        :param pulumi.Input[str] legend: Gets or sets the legend for the graph.
        :param pulumi.Input[str] metric_name: Gets or sets the metric name that the query is checking. For example: 'Total data receive'.
        """
        pulumi.set(__self__, "base_query", base_query)
        pulumi.set(__self__, "legend", legend)
        pulumi.set(__self__, "metric_name", metric_name)

    @property
    @pulumi.getter(name="baseQuery")
    def base_query(self) -> pulumi.Input[str]:
        """
        Gets or sets the base query for the graph.
        The base query is wrapped by Sentinel UI infra with a KQL query, that measures the volume over time.
        """
        return pulumi.get(self, "base_query")

    @base_query.setter
    def base_query(self, value: pulumi.Input[str]):
        pulumi.set(self, "base_query", value)

    @property
    @pulumi.getter
    def legend(self) -> pulumi.Input[str]:
        """
        Gets or sets the legend for the graph.
        """
        return pulumi.get(self, "legend")

    @legend.setter
    def legend(self, value: pulumi.Input[str]):
        pulumi.set(self, "legend", value)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        Gets or sets the metric name that the query is checking. For example: 'Total data receive'.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)


if not MYPY:
    class GroupingConfigurationArgsDict(TypedDict):
        """
        Grouping configuration property bag.
        """
        enabled: pulumi.Input[bool]
        """
        Grouping enabled
        """
        lookback_duration: pulumi.Input[str]
        """
        Limit the group to alerts created within the lookback duration (in ISO 8601 duration format)
        """
        matching_method: pulumi.Input[Union[str, 'MatchingMethod']]
        """
        Grouping matching method. When method is Selected at least one of groupByEntities, groupByAlertDetails, groupByCustomDetails must be provided and not empty.
        """
        reopen_closed_incident: pulumi.Input[bool]
        """
        Re-open closed matching incidents
        """
        group_by_alert_details: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AlertDetail']]]]]
        """
        A list of alert details to group by (when matchingMethod is Selected)
        """
        group_by_custom_details: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of custom details keys to group by (when matchingMethod is Selected). Only keys defined in the current alert rule may be used.
        """
        group_by_entities: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'EntityMappingType']]]]]
        """
        A list of entity types to group by (when matchingMethod is Selected). Only entities defined in the current alert rule may be used.
        """
elif False:
    GroupingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupingConfigurationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 lookback_duration: pulumi.Input[str],
                 matching_method: pulumi.Input[Union[str, 'MatchingMethod']],
                 reopen_closed_incident: pulumi.Input[bool],
                 group_by_alert_details: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AlertDetail']]]]] = None,
                 group_by_custom_details: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_by_entities: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'EntityMappingType']]]]] = None):
        """
        Grouping configuration property bag.
        :param pulumi.Input[bool] enabled: Grouping enabled
        :param pulumi.Input[str] lookback_duration: Limit the group to alerts created within the lookback duration (in ISO 8601 duration format)
        :param pulumi.Input[Union[str, 'MatchingMethod']] matching_method: Grouping matching method. When method is Selected at least one of groupByEntities, groupByAlertDetails, groupByCustomDetails must be provided and not empty.
        :param pulumi.Input[bool] reopen_closed_incident: Re-open closed matching incidents
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'AlertDetail']]]] group_by_alert_details: A list of alert details to group by (when matchingMethod is Selected)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_by_custom_details: A list of custom details keys to group by (when matchingMethod is Selected). Only keys defined in the current alert rule may be used.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'EntityMappingType']]]] group_by_entities: A list of entity types to group by (when matchingMethod is Selected). Only entities defined in the current alert rule may be used.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "lookback_duration", lookback_duration)
        pulumi.set(__self__, "matching_method", matching_method)
        pulumi.set(__self__, "reopen_closed_incident", reopen_closed_incident)
        if group_by_alert_details is not None:
            pulumi.set(__self__, "group_by_alert_details", group_by_alert_details)
        if group_by_custom_details is not None:
            pulumi.set(__self__, "group_by_custom_details", group_by_custom_details)
        if group_by_entities is not None:
            pulumi.set(__self__, "group_by_entities", group_by_entities)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Grouping enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="lookbackDuration")
    def lookback_duration(self) -> pulumi.Input[str]:
        """
        Limit the group to alerts created within the lookback duration (in ISO 8601 duration format)
        """
        return pulumi.get(self, "lookback_duration")

    @lookback_duration.setter
    def lookback_duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "lookback_duration", value)

    @property
    @pulumi.getter(name="matchingMethod")
    def matching_method(self) -> pulumi.Input[Union[str, 'MatchingMethod']]:
        """
        Grouping matching method. When method is Selected at least one of groupByEntities, groupByAlertDetails, groupByCustomDetails must be provided and not empty.
        """
        return pulumi.get(self, "matching_method")

    @matching_method.setter
    def matching_method(self, value: pulumi.Input[Union[str, 'MatchingMethod']]):
        pulumi.set(self, "matching_method", value)

    @property
    @pulumi.getter(name="reopenClosedIncident")
    def reopen_closed_incident(self) -> pulumi.Input[bool]:
        """
        Re-open closed matching incidents
        """
        return pulumi.get(self, "reopen_closed_incident")

    @reopen_closed_incident.setter
    def reopen_closed_incident(self, value: pulumi.Input[bool]):
        pulumi.set(self, "reopen_closed_incident", value)

    @property
    @pulumi.getter(name="groupByAlertDetails")
    def group_by_alert_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AlertDetail']]]]]:
        """
        A list of alert details to group by (when matchingMethod is Selected)
        """
        return pulumi.get(self, "group_by_alert_details")

    @group_by_alert_details.setter
    def group_by_alert_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AlertDetail']]]]]):
        pulumi.set(self, "group_by_alert_details", value)

    @property
    @pulumi.getter(name="groupByCustomDetails")
    def group_by_custom_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of custom details keys to group by (when matchingMethod is Selected). Only keys defined in the current alert rule may be used.
        """
        return pulumi.get(self, "group_by_custom_details")

    @group_by_custom_details.setter
    def group_by_custom_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_by_custom_details", value)

    @property
    @pulumi.getter(name="groupByEntities")
    def group_by_entities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'EntityMappingType']]]]]:
        """
        A list of entity types to group by (when matchingMethod is Selected). Only entities defined in the current alert rule may be used.
        """
        return pulumi.get(self, "group_by_entities")

    @group_by_entities.setter
    def group_by_entities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'EntityMappingType']]]]]):
        pulumi.set(self, "group_by_entities", value)


if not MYPY:
    class HuntOwnerArgsDict(TypedDict):
        """
        Describes a user that the hunt is assigned to
        """
        assigned_to: NotRequired[pulumi.Input[str]]
        """
        The name of the user the hunt is assigned to.
        """
        email: NotRequired[pulumi.Input[str]]
        """
        The email of the user the hunt is assigned to.
        """
        object_id: NotRequired[pulumi.Input[str]]
        """
        The object id of the user the hunt is assigned to.
        """
        owner_type: NotRequired[pulumi.Input[Union[str, 'OwnerType']]]
        """
        The type of the owner the hunt is assigned to.
        """
        user_principal_name: NotRequired[pulumi.Input[str]]
        """
        The user principal name of the user the hunt is assigned to.
        """
elif False:
    HuntOwnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HuntOwnerArgs:
    def __init__(__self__, *,
                 assigned_to: Optional[pulumi.Input[str]] = None,
                 email: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 owner_type: Optional[pulumi.Input[Union[str, 'OwnerType']]] = None,
                 user_principal_name: Optional[pulumi.Input[str]] = None):
        """
        Describes a user that the hunt is assigned to
        :param pulumi.Input[str] assigned_to: The name of the user the hunt is assigned to.
        :param pulumi.Input[str] email: The email of the user the hunt is assigned to.
        :param pulumi.Input[str] object_id: The object id of the user the hunt is assigned to.
        :param pulumi.Input[Union[str, 'OwnerType']] owner_type: The type of the owner the hunt is assigned to.
        :param pulumi.Input[str] user_principal_name: The user principal name of the user the hunt is assigned to.
        """
        if assigned_to is not None:
            pulumi.set(__self__, "assigned_to", assigned_to)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if owner_type is not None:
            pulumi.set(__self__, "owner_type", owner_type)
        if user_principal_name is not None:
            pulumi.set(__self__, "user_principal_name", user_principal_name)

    @property
    @pulumi.getter(name="assignedTo")
    def assigned_to(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the user the hunt is assigned to.
        """
        return pulumi.get(self, "assigned_to")

    @assigned_to.setter
    def assigned_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assigned_to", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The email of the user the hunt is assigned to.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The object id of the user the hunt is assigned to.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="ownerType")
    def owner_type(self) -> Optional[pulumi.Input[Union[str, 'OwnerType']]]:
        """
        The type of the owner the hunt is assigned to.
        """
        return pulumi.get(self, "owner_type")

    @owner_type.setter
    def owner_type(self, value: Optional[pulumi.Input[Union[str, 'OwnerType']]]):
        pulumi.set(self, "owner_type", value)

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        The user principal name of the user the hunt is assigned to.
        """
        return pulumi.get(self, "user_principal_name")

    @user_principal_name.setter
    def user_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_principal_name", value)


if not MYPY:
    class IncidentConfigurationArgsDict(TypedDict):
        """
        Incident Configuration property bag.
        """
        create_incident: pulumi.Input[bool]
        """
        Create incidents from alerts triggered by this analytics rule
        """
        grouping_configuration: NotRequired[pulumi.Input['GroupingConfigurationArgsDict']]
        """
        Set how the alerts that are triggered by this analytics rule, are grouped into incidents
        """
elif False:
    IncidentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentConfigurationArgs:
    def __init__(__self__, *,
                 create_incident: pulumi.Input[bool],
                 grouping_configuration: Optional[pulumi.Input['GroupingConfigurationArgs']] = None):
        """
        Incident Configuration property bag.
        :param pulumi.Input[bool] create_incident: Create incidents from alerts triggered by this analytics rule
        :param pulumi.Input['GroupingConfigurationArgs'] grouping_configuration: Set how the alerts that are triggered by this analytics rule, are grouped into incidents
        """
        pulumi.set(__self__, "create_incident", create_incident)
        if grouping_configuration is not None:
            pulumi.set(__self__, "grouping_configuration", grouping_configuration)

    @property
    @pulumi.getter(name="createIncident")
    def create_incident(self) -> pulumi.Input[bool]:
        """
        Create incidents from alerts triggered by this analytics rule
        """
        return pulumi.get(self, "create_incident")

    @create_incident.setter
    def create_incident(self, value: pulumi.Input[bool]):
        pulumi.set(self, "create_incident", value)

    @property
    @pulumi.getter(name="groupingConfiguration")
    def grouping_configuration(self) -> Optional[pulumi.Input['GroupingConfigurationArgs']]:
        """
        Set how the alerts that are triggered by this analytics rule, are grouped into incidents
        """
        return pulumi.get(self, "grouping_configuration")

    @grouping_configuration.setter
    def grouping_configuration(self, value: Optional[pulumi.Input['GroupingConfigurationArgs']]):
        pulumi.set(self, "grouping_configuration", value)


if not MYPY:
    class IncidentInfoArgsDict(TypedDict):
        """
        Describes related incident information for the bookmark
        """
        incident_id: NotRequired[pulumi.Input[str]]
        """
        Incident Id
        """
        relation_name: NotRequired[pulumi.Input[str]]
        """
        Relation Name
        """
        severity: NotRequired[pulumi.Input[Union[str, 'IncidentSeverity']]]
        """
        The severity of the incident
        """
        title: NotRequired[pulumi.Input[str]]
        """
        The title of the incident
        """
elif False:
    IncidentInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentInfoArgs:
    def __init__(__self__, *,
                 incident_id: Optional[pulumi.Input[str]] = None,
                 relation_name: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[Union[str, 'IncidentSeverity']]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        Describes related incident information for the bookmark
        :param pulumi.Input[str] incident_id: Incident Id
        :param pulumi.Input[str] relation_name: Relation Name
        :param pulumi.Input[Union[str, 'IncidentSeverity']] severity: The severity of the incident
        :param pulumi.Input[str] title: The title of the incident
        """
        if incident_id is not None:
            pulumi.set(__self__, "incident_id", incident_id)
        if relation_name is not None:
            pulumi.set(__self__, "relation_name", relation_name)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="incidentId")
    def incident_id(self) -> Optional[pulumi.Input[str]]:
        """
        Incident Id
        """
        return pulumi.get(self, "incident_id")

    @incident_id.setter
    def incident_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "incident_id", value)

    @property
    @pulumi.getter(name="relationName")
    def relation_name(self) -> Optional[pulumi.Input[str]]:
        """
        Relation Name
        """
        return pulumi.get(self, "relation_name")

    @relation_name.setter
    def relation_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relation_name", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[Union[str, 'IncidentSeverity']]]:
        """
        The severity of the incident
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[Union[str, 'IncidentSeverity']]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        The title of the incident
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class IncidentLabelArgsDict(TypedDict):
        """
        Represents an incident label
        """
        label_name: pulumi.Input[str]
        """
        The name of the label
        """
elif False:
    IncidentLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentLabelArgs:
    def __init__(__self__, *,
                 label_name: pulumi.Input[str]):
        """
        Represents an incident label
        :param pulumi.Input[str] label_name: The name of the label
        """
        pulumi.set(__self__, "label_name", label_name)

    @property
    @pulumi.getter(name="labelName")
    def label_name(self) -> pulumi.Input[str]:
        """
        The name of the label
        """
        return pulumi.get(self, "label_name")

    @label_name.setter
    def label_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "label_name", value)


if not MYPY:
    class IncidentOwnerInfoArgsDict(TypedDict):
        """
        Information on the user an incident is assigned to
        """
        assigned_to: NotRequired[pulumi.Input[str]]
        """
        The name of the user the incident is assigned to.
        """
        email: NotRequired[pulumi.Input[str]]
        """
        The email of the user the incident is assigned to.
        """
        object_id: NotRequired[pulumi.Input[str]]
        """
        The object id of the user the incident is assigned to.
        """
        owner_type: NotRequired[pulumi.Input[Union[str, 'OwnerType']]]
        """
        The type of the owner the incident is assigned to.
        """
        user_principal_name: NotRequired[pulumi.Input[str]]
        """
        The user principal name of the user the incident is assigned to.
        """
elif False:
    IncidentOwnerInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentOwnerInfoArgs:
    def __init__(__self__, *,
                 assigned_to: Optional[pulumi.Input[str]] = None,
                 email: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 owner_type: Optional[pulumi.Input[Union[str, 'OwnerType']]] = None,
                 user_principal_name: Optional[pulumi.Input[str]] = None):
        """
        Information on the user an incident is assigned to
        :param pulumi.Input[str] assigned_to: The name of the user the incident is assigned to.
        :param pulumi.Input[str] email: The email of the user the incident is assigned to.
        :param pulumi.Input[str] object_id: The object id of the user the incident is assigned to.
        :param pulumi.Input[Union[str, 'OwnerType']] owner_type: The type of the owner the incident is assigned to.
        :param pulumi.Input[str] user_principal_name: The user principal name of the user the incident is assigned to.
        """
        if assigned_to is not None:
            pulumi.set(__self__, "assigned_to", assigned_to)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if owner_type is not None:
            pulumi.set(__self__, "owner_type", owner_type)
        if user_principal_name is not None:
            pulumi.set(__self__, "user_principal_name", user_principal_name)

    @property
    @pulumi.getter(name="assignedTo")
    def assigned_to(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the user the incident is assigned to.
        """
        return pulumi.get(self, "assigned_to")

    @assigned_to.setter
    def assigned_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assigned_to", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        The email of the user the incident is assigned to.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The object id of the user the incident is assigned to.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="ownerType")
    def owner_type(self) -> Optional[pulumi.Input[Union[str, 'OwnerType']]]:
        """
        The type of the owner the incident is assigned to.
        """
        return pulumi.get(self, "owner_type")

    @owner_type.setter
    def owner_type(self, value: Optional[pulumi.Input[Union[str, 'OwnerType']]]):
        pulumi.set(self, "owner_type", value)

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        The user principal name of the user the incident is assigned to.
        """
        return pulumi.get(self, "user_principal_name")

    @user_principal_name.setter
    def user_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_principal_name", value)


if not MYPY:
    class IncidentPropertiesActionArgsDict(TypedDict):
        classification: NotRequired[pulumi.Input[Union[str, 'IncidentClassification']]]
        """
        The reason the incident was closed
        """
        classification_comment: NotRequired[pulumi.Input[str]]
        """
        Describes the reason the incident was closed.
        """
        classification_reason: NotRequired[pulumi.Input[Union[str, 'IncidentClassificationReason']]]
        """
        The classification reason the incident was closed with
        """
        labels: NotRequired[pulumi.Input[Sequence[pulumi.Input['IncidentLabelArgsDict']]]]
        """
        List of labels to add to the incident.
        """
        owner: NotRequired[pulumi.Input['IncidentOwnerInfoArgsDict']]
        """
        Information on the user an incident is assigned to
        """
        severity: NotRequired[pulumi.Input[Union[str, 'IncidentSeverity']]]
        """
        The severity of the incident
        """
        status: NotRequired[pulumi.Input[Union[str, 'IncidentStatus']]]
        """
        The status of the incident
        """
elif False:
    IncidentPropertiesActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentPropertiesActionArgs:
    def __init__(__self__, *,
                 classification: Optional[pulumi.Input[Union[str, 'IncidentClassification']]] = None,
                 classification_comment: Optional[pulumi.Input[str]] = None,
                 classification_reason: Optional[pulumi.Input[Union[str, 'IncidentClassificationReason']]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentLabelArgs']]]] = None,
                 owner: Optional[pulumi.Input['IncidentOwnerInfoArgs']] = None,
                 severity: Optional[pulumi.Input[Union[str, 'IncidentSeverity']]] = None,
                 status: Optional[pulumi.Input[Union[str, 'IncidentStatus']]] = None):
        """
        :param pulumi.Input[Union[str, 'IncidentClassification']] classification: The reason the incident was closed
        :param pulumi.Input[str] classification_comment: Describes the reason the incident was closed.
        :param pulumi.Input[Union[str, 'IncidentClassificationReason']] classification_reason: The classification reason the incident was closed with
        :param pulumi.Input[Sequence[pulumi.Input['IncidentLabelArgs']]] labels: List of labels to add to the incident.
        :param pulumi.Input['IncidentOwnerInfoArgs'] owner: Information on the user an incident is assigned to
        :param pulumi.Input[Union[str, 'IncidentSeverity']] severity: The severity of the incident
        :param pulumi.Input[Union[str, 'IncidentStatus']] status: The status of the incident
        """
        if classification is not None:
            pulumi.set(__self__, "classification", classification)
        if classification_comment is not None:
            pulumi.set(__self__, "classification_comment", classification_comment)
        if classification_reason is not None:
            pulumi.set(__self__, "classification_reason", classification_reason)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def classification(self) -> Optional[pulumi.Input[Union[str, 'IncidentClassification']]]:
        """
        The reason the incident was closed
        """
        return pulumi.get(self, "classification")

    @classification.setter
    def classification(self, value: Optional[pulumi.Input[Union[str, 'IncidentClassification']]]):
        pulumi.set(self, "classification", value)

    @property
    @pulumi.getter(name="classificationComment")
    def classification_comment(self) -> Optional[pulumi.Input[str]]:
        """
        Describes the reason the incident was closed.
        """
        return pulumi.get(self, "classification_comment")

    @classification_comment.setter
    def classification_comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "classification_comment", value)

    @property
    @pulumi.getter(name="classificationReason")
    def classification_reason(self) -> Optional[pulumi.Input[Union[str, 'IncidentClassificationReason']]]:
        """
        The classification reason the incident was closed with
        """
        return pulumi.get(self, "classification_reason")

    @classification_reason.setter
    def classification_reason(self, value: Optional[pulumi.Input[Union[str, 'IncidentClassificationReason']]]):
        pulumi.set(self, "classification_reason", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IncidentLabelArgs']]]]:
        """
        List of labels to add to the incident.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentLabelArgs']]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input['IncidentOwnerInfoArgs']]:
        """
        Information on the user an incident is assigned to
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input['IncidentOwnerInfoArgs']]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[Union[str, 'IncidentSeverity']]]:
        """
        The severity of the incident
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[Union[str, 'IncidentSeverity']]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[str, 'IncidentStatus']]]:
        """
        The status of the incident
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[str, 'IncidentStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class InstructionStepDetailsArgsDict(TypedDict):
        """
        Instruction step details, to be displayed in the Instructions steps section in the connector's page in Sentinel Portal.
        """
        parameters: Any
        """
        Gets or sets the instruction type parameters settings.
        """
        type: pulumi.Input[str]
        """
        Gets or sets the instruction type name.
        """
elif False:
    InstructionStepDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstructionStepDetailsArgs:
    def __init__(__self__, *,
                 parameters: Any,
                 type: pulumi.Input[str]):
        """
        Instruction step details, to be displayed in the Instructions steps section in the connector's page in Sentinel Portal.
        :param Any parameters: Gets or sets the instruction type parameters settings.
        :param pulumi.Input[str] type: Gets or sets the instruction type name.
        """
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def parameters(self) -> Any:
        """
        Gets or sets the instruction type parameters settings.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Any):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Gets or sets the instruction type name.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class InstructionStepsInstructionsArgsDict(TypedDict):
        type: pulumi.Input[Union[str, 'SettingType']]
        """
        The kind of the setting
        """
        parameters: NotRequired[Any]
        """
        The parameters for the setting
        """
elif False:
    InstructionStepsInstructionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstructionStepsInstructionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'SettingType']],
                 parameters: Optional[Any] = None):
        """
        :param pulumi.Input[Union[str, 'SettingType']] type: The kind of the setting
        :param Any parameters: The parameters for the setting
        """
        pulumi.set(__self__, "type", type)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'SettingType']]:
        """
        The kind of the setting
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'SettingType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        """
        The parameters for the setting
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[Any]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class InstructionStepArgsDict(TypedDict):
        """
        Instruction steps to enable the connector.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Gets or sets the instruction step description.
        """
        inner_steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstructionStepArgsDict']]]]
        """
        Gets or sets the inner instruction steps details.
        Foe Example: instruction step 1 might contain inner instruction steps: [instruction step 1.1, instruction step 1.2].
        """
        instructions: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstructionStepDetailsArgsDict']]]]
        """
        Gets or sets the instruction step details.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Gets or sets the instruction step title.
        """
elif False:
    InstructionStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstructionStepArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 inner_steps: Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]]] = None,
                 instructions: Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepDetailsArgs']]]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        Instruction steps to enable the connector.
        :param pulumi.Input[str] description: Gets or sets the instruction step description.
        :param pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]] inner_steps: Gets or sets the inner instruction steps details.
               Foe Example: instruction step 1 might contain inner instruction steps: [instruction step 1.1, instruction step 1.2].
        :param pulumi.Input[Sequence[pulumi.Input['InstructionStepDetailsArgs']]] instructions: Gets or sets the instruction step details.
        :param pulumi.Input[str] title: Gets or sets the instruction step title.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if inner_steps is not None:
            pulumi.set(__self__, "inner_steps", inner_steps)
        if instructions is not None:
            pulumi.set(__self__, "instructions", instructions)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the instruction step description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="innerSteps")
    def inner_steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]]]:
        """
        Gets or sets the inner instruction steps details.
        Foe Example: instruction step 1 might contain inner instruction steps: [instruction step 1.1, instruction step 1.2].
        """
        return pulumi.get(self, "inner_steps")

    @inner_steps.setter
    def inner_steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepArgs']]]]):
        pulumi.set(self, "inner_steps", value)

    @property
    @pulumi.getter
    def instructions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepDetailsArgs']]]]:
        """
        Gets or sets the instruction step details.
        """
        return pulumi.get(self, "instructions")

    @instructions.setter
    def instructions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstructionStepDetailsArgs']]]]):
        pulumi.set(self, "instructions", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the instruction step title.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class JwtAuthModelArgsDict(TypedDict):
        """
        Model for API authentication with JWT. Simple exchange between user name + password to access token.
        """
        password: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        The password
        """
        token_endpoint: pulumi.Input[str]
        """
        Token endpoint to request JWT
        """
        type: pulumi.Input[str]
        """
        Type of paging
        Expected value is 'JwtToken'.
        """
        user_name: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        The user name. If user name and password sent in header request we only need to populate the `value` property with the user name (Same as basic auth). If user name and password sent in body request we need to specify the `Key` and `Value`.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The custom headers we want to add once we send request to token endpoint.
        """
        is_credentials_in_headers: NotRequired[pulumi.Input[bool]]
        """
        Flag indicating whether we want to send the user name and password to token endpoint in the headers.
        """
        is_json_request: NotRequired[pulumi.Input[bool]]
        """
        Flag indicating whether the body request is JSON (header Content-Type = application/json), meaning its a Form URL encoded request (header Content-Type = application/x-www-form-urlencoded).
        """
        query_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The custom query parameter we want to add once we send request to token endpoint.
        """
        request_timeout_in_seconds: NotRequired[pulumi.Input[int]]
        """
        Request timeout in seconds.
        """
elif False:
    JwtAuthModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JwtAuthModelArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 token_endpoint: pulumi.Input[str],
                 type: pulumi.Input[str],
                 user_name: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 is_credentials_in_headers: Optional[pulumi.Input[bool]] = None,
                 is_json_request: Optional[pulumi.Input[bool]] = None,
                 query_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 request_timeout_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        Model for API authentication with JWT. Simple exchange between user name + password to access token.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] password: The password
        :param pulumi.Input[str] token_endpoint: Token endpoint to request JWT
        :param pulumi.Input[str] type: Type of paging
               Expected value is 'JwtToken'.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] user_name: The user name. If user name and password sent in header request we only need to populate the `value` property with the user name (Same as basic auth). If user name and password sent in body request we need to specify the `Key` and `Value`.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] headers: The custom headers we want to add once we send request to token endpoint.
        :param pulumi.Input[bool] is_credentials_in_headers: Flag indicating whether we want to send the user name and password to token endpoint in the headers.
        :param pulumi.Input[bool] is_json_request: Flag indicating whether the body request is JSON (header Content-Type = application/json), meaning its a Form URL encoded request (header Content-Type = application/x-www-form-urlencoded).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] query_parameters: The custom query parameter we want to add once we send request to token endpoint.
        :param pulumi.Input[int] request_timeout_in_seconds: Request timeout in seconds.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        pulumi.set(__self__, "type", 'JwtToken')
        pulumi.set(__self__, "user_name", user_name)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if is_credentials_in_headers is not None:
            pulumi.set(__self__, "is_credentials_in_headers", is_credentials_in_headers)
        if is_json_request is None:
            is_json_request = False
        if is_json_request is not None:
            pulumi.set(__self__, "is_json_request", is_json_request)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if request_timeout_in_seconds is None:
            request_timeout_in_seconds = 100
        if request_timeout_in_seconds is not None:
            pulumi.set(__self__, "request_timeout_in_seconds", request_timeout_in_seconds)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        The password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[str]:
        """
        Token endpoint to request JWT
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of paging
        Expected value is 'JwtToken'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        The user name. If user name and password sent in header request we only need to populate the `value` property with the user name (Same as basic auth). If user name and password sent in body request we need to specify the `Key` and `Value`.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "user_name", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The custom headers we want to add once we send request to token endpoint.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="isCredentialsInHeaders")
    def is_credentials_in_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag indicating whether we want to send the user name and password to token endpoint in the headers.
        """
        return pulumi.get(self, "is_credentials_in_headers")

    @is_credentials_in_headers.setter
    def is_credentials_in_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_credentials_in_headers", value)

    @property
    @pulumi.getter(name="isJsonRequest")
    def is_json_request(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag indicating whether the body request is JSON (header Content-Type = application/json), meaning its a Form URL encoded request (header Content-Type = application/x-www-form-urlencoded).
        """
        return pulumi.get(self, "is_json_request")

    @is_json_request.setter
    def is_json_request(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_json_request", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The custom query parameter we want to add once we send request to token endpoint.
        """
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "query_parameters", value)

    @property
    @pulumi.getter(name="requestTimeoutInSeconds")
    def request_timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Request timeout in seconds.
        """
        return pulumi.get(self, "request_timeout_in_seconds")

    @request_timeout_in_seconds.setter
    def request_timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "request_timeout_in_seconds", value)


if not MYPY:
    class MCASDataConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for MCAS (Microsoft Cloud App Security) data connector.
        """
        alerts: pulumi.Input['DataConnectorDataTypeCommonArgsDict']
        """
        Alerts data type connection.
        """
        discovery_logs: NotRequired[pulumi.Input['DataConnectorDataTypeCommonArgsDict']]
        """
        Discovery log data type connection.
        """
elif False:
    MCASDataConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MCASDataConnectorDataTypesArgs:
    def __init__(__self__, *,
                 alerts: pulumi.Input['DataConnectorDataTypeCommonArgs'],
                 discovery_logs: Optional[pulumi.Input['DataConnectorDataTypeCommonArgs']] = None):
        """
        The available data types for MCAS (Microsoft Cloud App Security) data connector.
        :param pulumi.Input['DataConnectorDataTypeCommonArgs'] alerts: Alerts data type connection.
        :param pulumi.Input['DataConnectorDataTypeCommonArgs'] discovery_logs: Discovery log data type connection.
        """
        pulumi.set(__self__, "alerts", alerts)
        if discovery_logs is not None:
            pulumi.set(__self__, "discovery_logs", discovery_logs)

    @property
    @pulumi.getter
    def alerts(self) -> pulumi.Input['DataConnectorDataTypeCommonArgs']:
        """
        Alerts data type connection.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: pulumi.Input['DataConnectorDataTypeCommonArgs']):
        pulumi.set(self, "alerts", value)

    @property
    @pulumi.getter(name="discoveryLogs")
    def discovery_logs(self) -> Optional[pulumi.Input['DataConnectorDataTypeCommonArgs']]:
        """
        Discovery log data type connection.
        """
        return pulumi.get(self, "discovery_logs")

    @discovery_logs.setter
    def discovery_logs(self, value: Optional[pulumi.Input['DataConnectorDataTypeCommonArgs']]):
        pulumi.set(self, "discovery_logs", value)


if not MYPY:
    class MSTIDataConnectorDataTypesMicrosoftEmergingThreatFeedArgsDict(TypedDict):
        """
        Data type for Microsoft Threat Intelligence Platforms data connector.
        """
        lookback_period: pulumi.Input[str]
        """
        The lookback period for the feed to be imported.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    MSTIDataConnectorDataTypesMicrosoftEmergingThreatFeedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MSTIDataConnectorDataTypesMicrosoftEmergingThreatFeedArgs:
    def __init__(__self__, *,
                 lookback_period: pulumi.Input[str],
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Data type for Microsoft Threat Intelligence Platforms data connector.
        :param pulumi.Input[str] lookback_period: The lookback period for the feed to be imported.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "lookback_period", lookback_period)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="lookbackPeriod")
    def lookback_period(self) -> pulumi.Input[str]:
        """
        The lookback period for the feed to be imported.
        """
        return pulumi.get(self, "lookback_period")

    @lookback_period.setter
    def lookback_period(self, value: pulumi.Input[str]):
        pulumi.set(self, "lookback_period", value)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MSTIDataConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for Microsoft Threat Intelligence Platforms data connector.
        """
        microsoft_emerging_threat_feed: pulumi.Input['MSTIDataConnectorDataTypesMicrosoftEmergingThreatFeedArgsDict']
        """
        Data type for Microsoft Threat Intelligence Platforms data connector.
        """
elif False:
    MSTIDataConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MSTIDataConnectorDataTypesArgs:
    def __init__(__self__, *,
                 microsoft_emerging_threat_feed: pulumi.Input['MSTIDataConnectorDataTypesMicrosoftEmergingThreatFeedArgs']):
        """
        The available data types for Microsoft Threat Intelligence Platforms data connector.
        :param pulumi.Input['MSTIDataConnectorDataTypesMicrosoftEmergingThreatFeedArgs'] microsoft_emerging_threat_feed: Data type for Microsoft Threat Intelligence Platforms data connector.
        """
        pulumi.set(__self__, "microsoft_emerging_threat_feed", microsoft_emerging_threat_feed)

    @property
    @pulumi.getter(name="microsoftEmergingThreatFeed")
    def microsoft_emerging_threat_feed(self) -> pulumi.Input['MSTIDataConnectorDataTypesMicrosoftEmergingThreatFeedArgs']:
        """
        Data type for Microsoft Threat Intelligence Platforms data connector.
        """
        return pulumi.get(self, "microsoft_emerging_threat_feed")

    @microsoft_emerging_threat_feed.setter
    def microsoft_emerging_threat_feed(self, value: pulumi.Input['MSTIDataConnectorDataTypesMicrosoftEmergingThreatFeedArgs']):
        pulumi.set(self, "microsoft_emerging_threat_feed", value)


if not MYPY:
    class MTPDataConnectorDataTypesAlertsArgsDict(TypedDict):
        """
        Alerts data type for Microsoft Threat Protection Platforms data connector.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    MTPDataConnectorDataTypesAlertsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MTPDataConnectorDataTypesAlertsArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Alerts data type for Microsoft Threat Protection Platforms data connector.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MTPDataConnectorDataTypesIncidentsArgsDict(TypedDict):
        """
        Incidents data type for Microsoft Threat Protection Platforms data connector.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    MTPDataConnectorDataTypesIncidentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MTPDataConnectorDataTypesIncidentsArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Incidents data type for Microsoft Threat Protection Platforms data connector.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MTPDataConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for Microsoft Threat Protection Platforms data connector.
        """
        incidents: pulumi.Input['MTPDataConnectorDataTypesIncidentsArgsDict']
        """
        Incidents data type for Microsoft Threat Protection Platforms data connector.
        """
        alerts: NotRequired[pulumi.Input['MTPDataConnectorDataTypesAlertsArgsDict']]
        """
        Alerts data type for Microsoft Threat Protection Platforms data connector.
        """
elif False:
    MTPDataConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MTPDataConnectorDataTypesArgs:
    def __init__(__self__, *,
                 incidents: pulumi.Input['MTPDataConnectorDataTypesIncidentsArgs'],
                 alerts: Optional[pulumi.Input['MTPDataConnectorDataTypesAlertsArgs']] = None):
        """
        The available data types for Microsoft Threat Protection Platforms data connector.
        :param pulumi.Input['MTPDataConnectorDataTypesIncidentsArgs'] incidents: Incidents data type for Microsoft Threat Protection Platforms data connector.
        :param pulumi.Input['MTPDataConnectorDataTypesAlertsArgs'] alerts: Alerts data type for Microsoft Threat Protection Platforms data connector.
        """
        pulumi.set(__self__, "incidents", incidents)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)

    @property
    @pulumi.getter
    def incidents(self) -> pulumi.Input['MTPDataConnectorDataTypesIncidentsArgs']:
        """
        Incidents data type for Microsoft Threat Protection Platforms data connector.
        """
        return pulumi.get(self, "incidents")

    @incidents.setter
    def incidents(self, value: pulumi.Input['MTPDataConnectorDataTypesIncidentsArgs']):
        pulumi.set(self, "incidents", value)

    @property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input['MTPDataConnectorDataTypesAlertsArgs']]:
        """
        Alerts data type for Microsoft Threat Protection Platforms data connector.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input['MTPDataConnectorDataTypesAlertsArgs']]):
        pulumi.set(self, "alerts", value)


if not MYPY:
    class MetadataAuthorArgsDict(TypedDict):
        """
        Publisher or creator of the content item.
        """
        email: NotRequired[pulumi.Input[str]]
        """
        Email of author contact
        """
        link: NotRequired[pulumi.Input[str]]
        """
        Link for author/vendor page
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the author. Company or person.
        """
elif False:
    MetadataAuthorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataAuthorArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Publisher or creator of the content item.
        :param pulumi.Input[str] email: Email of author contact
        :param pulumi.Input[str] link: Link for author/vendor page
        :param pulumi.Input[str] name: Name of the author. Company or person.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        Email of author contact
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        Link for author/vendor page
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the author. Company or person.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class MetadataCategoriesArgsDict(TypedDict):
        """
        ies for the solution content item
        """
        domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        domain for the solution content item
        """
        verticals: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Industry verticals for the solution content item
        """
elif False:
    MetadataCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataCategoriesArgs:
    def __init__(__self__, *,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verticals: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        ies for the solution content item
        :param pulumi.Input[Sequence[pulumi.Input[str]]] domains: domain for the solution content item
        :param pulumi.Input[Sequence[pulumi.Input[str]]] verticals: Industry verticals for the solution content item
        """
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if verticals is not None:
            pulumi.set(__self__, "verticals", verticals)

    @property
    @pulumi.getter
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        domain for the solution content item
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "domains", value)

    @property
    @pulumi.getter
    def verticals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Industry verticals for the solution content item
        """
        return pulumi.get(self, "verticals")

    @verticals.setter
    def verticals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "verticals", value)


if not MYPY:
    class MetadataDependenciesArgsDict(TypedDict):
        """
        Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex dependencies.
        """
        content_id: NotRequired[pulumi.Input[str]]
        """
        Id of the content item we depend on
        """
        criteria: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetadataDependenciesArgsDict']]]]
        """
        This is the list of dependencies we must fulfill, according to the AND/OR operator
        """
        kind: NotRequired[pulumi.Input[Union[str, 'Kind']]]
        """
        Type of the content item we depend on
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the content item
        """
        operator: NotRequired[pulumi.Input[Union[str, 'Operator']]]
        """
        Operator used for list of dependencies in criteria array.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        """
elif False:
    MetadataDependenciesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataDependenciesArgs:
    def __init__(__self__, *,
                 content_id: Optional[pulumi.Input[str]] = None,
                 criteria: Optional[pulumi.Input[Sequence[pulumi.Input['MetadataDependenciesArgs']]]] = None,
                 kind: Optional[pulumi.Input[Union[str, 'Kind']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[Union[str, 'Operator']]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex dependencies.
        :param pulumi.Input[str] content_id: Id of the content item we depend on
        :param pulumi.Input[Sequence[pulumi.Input['MetadataDependenciesArgs']]] criteria: This is the list of dependencies we must fulfill, according to the AND/OR operator
        :param pulumi.Input[Union[str, 'Kind']] kind: Type of the content item we depend on
        :param pulumi.Input[str] name: Name of the content item
        :param pulumi.Input[Union[str, 'Operator']] operator: Operator used for list of dependencies in criteria array.
        :param pulumi.Input[str] version: Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        """
        if content_id is not None:
            pulumi.set(__self__, "content_id", content_id)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="contentId")
    def content_id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the content item we depend on
        """
        return pulumi.get(self, "content_id")

    @content_id.setter
    def content_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_id", value)

    @property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetadataDependenciesArgs']]]]:
        """
        This is the list of dependencies we must fulfill, according to the AND/OR operator
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetadataDependenciesArgs']]]]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[Union[str, 'Kind']]]:
        """
        Type of the content item we depend on
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[Union[str, 'Kind']]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the content item
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[Union[str, 'Operator']]]:
        """
        Operator used for list of dependencies in criteria array.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[Union[str, 'Operator']]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class MetadataSourceArgsDict(TypedDict):
        """
        The original source of the content item, where it comes from.
        """
        kind: pulumi.Input[Union[str, 'SourceKind']]
        """
        Source type of the content
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the content source.  The repo name, solution name, LA workspace name etc.
        """
        source_id: NotRequired[pulumi.Input[str]]
        """
        ID of the content source.  The solution ID, workspace ID, etc
        """
elif False:
    MetadataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataSourceArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[Union[str, 'SourceKind']],
                 name: Optional[pulumi.Input[str]] = None,
                 source_id: Optional[pulumi.Input[str]] = None):
        """
        The original source of the content item, where it comes from.
        :param pulumi.Input[Union[str, 'SourceKind']] kind: Source type of the content
        :param pulumi.Input[str] name: Name of the content source.  The repo name, solution name, LA workspace name etc.
        :param pulumi.Input[str] source_id: ID of the content source.  The solution ID, workspace ID, etc
        """
        pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[Union[str, 'SourceKind']]:
        """
        Source type of the content
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[Union[str, 'SourceKind']]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the content source.  The repo name, solution name, LA workspace name etc.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the content source.  The solution ID, workspace ID, etc
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_id", value)


if not MYPY:
    class MetadataSupportArgsDict(TypedDict):
        """
        Support information for the content item.
        """
        tier: pulumi.Input[Union[str, 'SupportTier']]
        """
        Type of support for content item
        """
        email: NotRequired[pulumi.Input[str]]
        """
        Email of support contact
        """
        link: NotRequired[pulumi.Input[str]]
        """
        Link for support help, like to support page to open a ticket etc.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the support contact. Company or person.
        """
elif False:
    MetadataSupportArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataSupportArgs:
    def __init__(__self__, *,
                 tier: pulumi.Input[Union[str, 'SupportTier']],
                 email: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Support information for the content item.
        :param pulumi.Input[Union[str, 'SupportTier']] tier: Type of support for content item
        :param pulumi.Input[str] email: Email of support contact
        :param pulumi.Input[str] link: Link for support help, like to support page to open a ticket etc.
        :param pulumi.Input[str] name: Name of the support contact. Company or person.
        """
        pulumi.set(__self__, "tier", tier)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def tier(self) -> pulumi.Input[Union[str, 'SupportTier']]:
        """
        Type of support for content item
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: pulumi.Input[Union[str, 'SupportTier']]):
        pulumi.set(self, "tier", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        Email of support contact
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        Link for support help, like to support page to open a ticket etc.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the support contact. Company or person.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class MicrosoftPurviewInformationProtectionConnectorDataTypesLogsArgsDict(TypedDict):
        """
        Logs data type.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    MicrosoftPurviewInformationProtectionConnectorDataTypesLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MicrosoftPurviewInformationProtectionConnectorDataTypesLogsArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Logs data type.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MicrosoftPurviewInformationProtectionConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for Microsoft Purview Information Protection data connector.
        """
        logs: pulumi.Input['MicrosoftPurviewInformationProtectionConnectorDataTypesLogsArgsDict']
        """
        Logs data type.
        """
elif False:
    MicrosoftPurviewInformationProtectionConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MicrosoftPurviewInformationProtectionConnectorDataTypesArgs:
    def __init__(__self__, *,
                 logs: pulumi.Input['MicrosoftPurviewInformationProtectionConnectorDataTypesLogsArgs']):
        """
        The available data types for Microsoft Purview Information Protection data connector.
        :param pulumi.Input['MicrosoftPurviewInformationProtectionConnectorDataTypesLogsArgs'] logs: Logs data type.
        """
        pulumi.set(__self__, "logs", logs)

    @property
    @pulumi.getter
    def logs(self) -> pulumi.Input['MicrosoftPurviewInformationProtectionConnectorDataTypesLogsArgs']:
        """
        Logs data type.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: pulumi.Input['MicrosoftPurviewInformationProtectionConnectorDataTypesLogsArgs']):
        pulumi.set(self, "logs", value)


if not MYPY:
    class MtpFilteredProvidersArgsDict(TypedDict):
        """
        Represents the connector's Filtered providers
        """
        alerts: pulumi.Input[Sequence[pulumi.Input[Union[str, 'MtpProvider']]]]
        """
        Alerts filtered providers. When filters are not applied, all alerts will stream through the MTP pipeline, still in private preview for all products EXCEPT MDA and MDI, which are in GA state.
        """
elif False:
    MtpFilteredProvidersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MtpFilteredProvidersArgs:
    def __init__(__self__, *,
                 alerts: pulumi.Input[Sequence[pulumi.Input[Union[str, 'MtpProvider']]]]):
        """
        Represents the connector's Filtered providers
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'MtpProvider']]]] alerts: Alerts filtered providers. When filters are not applied, all alerts will stream through the MTP pipeline, still in private preview for all products EXCEPT MDA and MDI, which are in GA state.
        """
        pulumi.set(__self__, "alerts", alerts)

    @property
    @pulumi.getter
    def alerts(self) -> pulumi.Input[Sequence[pulumi.Input[Union[str, 'MtpProvider']]]]:
        """
        Alerts filtered providers. When filters are not applied, all alerts will stream through the MTP pipeline, still in private preview for all products EXCEPT MDA and MDI, which are in GA state.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: pulumi.Input[Sequence[pulumi.Input[Union[str, 'MtpProvider']]]]):
        pulumi.set(self, "alerts", value)


if not MYPY:
    class NoneAuthModelArgsDict(TypedDict):
        """
        Model for API authentication with no authentication method - public API.
        """
        type: pulumi.Input[str]
        """
        Type of paging
        Expected value is 'None'.
        """
elif False:
    NoneAuthModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NoneAuthModelArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        Model for API authentication with no authentication method - public API.
        :param pulumi.Input[str] type: Type of paging
               Expected value is 'None'.
        """
        pulumi.set(__self__, "type", 'None')

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of paging
        Expected value is 'None'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class OAuthModelArgsDict(TypedDict):
        """
        Model for API authentication with OAuth2.
        """
        client_id: pulumi.Input[str]
        """
        The Application (client) ID that the OAuth provider assigned to your app.
        """
        client_secret: pulumi.Input[str]
        """
        The Application (client) secret that the OAuth provider assigned to your app.
        """
        grant_type: pulumi.Input[str]
        """
        The grant type, usually will be 'authorization code'.
        """
        token_endpoint: pulumi.Input[str]
        """
        The token endpoint. Defines the OAuth2 refresh token.
        """
        type: pulumi.Input[str]
        """
        Type of paging
        Expected value is 'OAuth2'.
        """
        access_token_prepend: NotRequired[pulumi.Input[str]]
        """
        Access token prepend. Default is 'Bearer'.
        """
        authorization_code: NotRequired[pulumi.Input[str]]
        """
        The user's authorization code.
        """
        authorization_endpoint: NotRequired[pulumi.Input[str]]
        """
        The authorization endpoint.
        """
        authorization_endpoint_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The authorization endpoint headers.
        """
        authorization_endpoint_query_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The authorization endpoint query parameters.
        """
        is_credentials_in_headers: NotRequired[pulumi.Input[bool]]
        """
        Indicating whether we want to send the clientId and clientSecret to token endpoint in the headers.
        """
        is_jwt_bearer_flow: NotRequired[pulumi.Input[bool]]
        """
        A value indicating whether it's a JWT flow.
        """
        redirect_uri: NotRequired[pulumi.Input[str]]
        """
        The Application redirect url that the user config in the OAuth provider.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The Application (client) Scope that the OAuth provider assigned to your app.
        """
        token_endpoint_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The token endpoint headers.
        """
        token_endpoint_query_parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The token endpoint query parameters.
        """
elif False:
    OAuthModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OAuthModelArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 grant_type: pulumi.Input[str],
                 token_endpoint: pulumi.Input[str],
                 type: pulumi.Input[str],
                 access_token_prepend: Optional[pulumi.Input[str]] = None,
                 authorization_code: Optional[pulumi.Input[str]] = None,
                 authorization_endpoint: Optional[pulumi.Input[str]] = None,
                 authorization_endpoint_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 authorization_endpoint_query_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 is_credentials_in_headers: Optional[pulumi.Input[bool]] = None,
                 is_jwt_bearer_flow: Optional[pulumi.Input[bool]] = None,
                 redirect_uri: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 token_endpoint_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 token_endpoint_query_parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Model for API authentication with OAuth2.
        :param pulumi.Input[str] client_id: The Application (client) ID that the OAuth provider assigned to your app.
        :param pulumi.Input[str] client_secret: The Application (client) secret that the OAuth provider assigned to your app.
        :param pulumi.Input[str] grant_type: The grant type, usually will be 'authorization code'.
        :param pulumi.Input[str] token_endpoint: The token endpoint. Defines the OAuth2 refresh token.
        :param pulumi.Input[str] type: Type of paging
               Expected value is 'OAuth2'.
        :param pulumi.Input[str] access_token_prepend: Access token prepend. Default is 'Bearer'.
        :param pulumi.Input[str] authorization_code: The user's authorization code.
        :param pulumi.Input[str] authorization_endpoint: The authorization endpoint.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] authorization_endpoint_headers: The authorization endpoint headers.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] authorization_endpoint_query_parameters: The authorization endpoint query parameters.
        :param pulumi.Input[bool] is_credentials_in_headers: Indicating whether we want to send the clientId and clientSecret to token endpoint in the headers.
        :param pulumi.Input[bool] is_jwt_bearer_flow: A value indicating whether it's a JWT flow.
        :param pulumi.Input[str] redirect_uri: The Application redirect url that the user config in the OAuth provider.
        :param pulumi.Input[str] scope: The Application (client) Scope that the OAuth provider assigned to your app.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] token_endpoint_headers: The token endpoint headers.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] token_endpoint_query_parameters: The token endpoint query parameters.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "grant_type", grant_type)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        pulumi.set(__self__, "type", 'OAuth2')
        if access_token_prepend is not None:
            pulumi.set(__self__, "access_token_prepend", access_token_prepend)
        if authorization_code is not None:
            pulumi.set(__self__, "authorization_code", authorization_code)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if authorization_endpoint_headers is not None:
            pulumi.set(__self__, "authorization_endpoint_headers", authorization_endpoint_headers)
        if authorization_endpoint_query_parameters is not None:
            pulumi.set(__self__, "authorization_endpoint_query_parameters", authorization_endpoint_query_parameters)
        if is_credentials_in_headers is None:
            is_credentials_in_headers = False
        if is_credentials_in_headers is not None:
            pulumi.set(__self__, "is_credentials_in_headers", is_credentials_in_headers)
        if is_jwt_bearer_flow is not None:
            pulumi.set(__self__, "is_jwt_bearer_flow", is_jwt_bearer_flow)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if token_endpoint_headers is not None:
            pulumi.set(__self__, "token_endpoint_headers", token_endpoint_headers)
        if token_endpoint_query_parameters is not None:
            pulumi.set(__self__, "token_endpoint_query_parameters", token_endpoint_query_parameters)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Application (client) ID that the OAuth provider assigned to your app.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Application (client) secret that the OAuth provider assigned to your app.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="grantType")
    def grant_type(self) -> pulumi.Input[str]:
        """
        The grant type, usually will be 'authorization code'.
        """
        return pulumi.get(self, "grant_type")

    @grant_type.setter
    def grant_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "grant_type", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[str]:
        """
        The token endpoint. Defines the OAuth2 refresh token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of paging
        Expected value is 'OAuth2'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessTokenPrepend")
    def access_token_prepend(self) -> Optional[pulumi.Input[str]]:
        """
        Access token prepend. Default is 'Bearer'.
        """
        return pulumi.get(self, "access_token_prepend")

    @access_token_prepend.setter
    def access_token_prepend(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token_prepend", value)

    @property
    @pulumi.getter(name="authorizationCode")
    def authorization_code(self) -> Optional[pulumi.Input[str]]:
        """
        The user's authorization code.
        """
        return pulumi.get(self, "authorization_code")

    @authorization_code.setter
    def authorization_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_code", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The authorization endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="authorizationEndpointHeaders")
    def authorization_endpoint_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The authorization endpoint headers.
        """
        return pulumi.get(self, "authorization_endpoint_headers")

    @authorization_endpoint_headers.setter
    def authorization_endpoint_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "authorization_endpoint_headers", value)

    @property
    @pulumi.getter(name="authorizationEndpointQueryParameters")
    def authorization_endpoint_query_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The authorization endpoint query parameters.
        """
        return pulumi.get(self, "authorization_endpoint_query_parameters")

    @authorization_endpoint_query_parameters.setter
    def authorization_endpoint_query_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "authorization_endpoint_query_parameters", value)

    @property
    @pulumi.getter(name="isCredentialsInHeaders")
    def is_credentials_in_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicating whether we want to send the clientId and clientSecret to token endpoint in the headers.
        """
        return pulumi.get(self, "is_credentials_in_headers")

    @is_credentials_in_headers.setter
    def is_credentials_in_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_credentials_in_headers", value)

    @property
    @pulumi.getter(name="isJwtBearerFlow")
    def is_jwt_bearer_flow(self) -> Optional[pulumi.Input[bool]]:
        """
        A value indicating whether it's a JWT flow.
        """
        return pulumi.get(self, "is_jwt_bearer_flow")

    @is_jwt_bearer_flow.setter
    def is_jwt_bearer_flow(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_jwt_bearer_flow", value)

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Application redirect url that the user config in the OAuth provider.
        """
        return pulumi.get(self, "redirect_uri")

    @redirect_uri.setter
    def redirect_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_uri", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The Application (client) Scope that the OAuth provider assigned to your app.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="tokenEndpointHeaders")
    def token_endpoint_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The token endpoint headers.
        """
        return pulumi.get(self, "token_endpoint_headers")

    @token_endpoint_headers.setter
    def token_endpoint_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "token_endpoint_headers", value)

    @property
    @pulumi.getter(name="tokenEndpointQueryParameters")
    def token_endpoint_query_parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The token endpoint query parameters.
        """
        return pulumi.get(self, "token_endpoint_query_parameters")

    @token_endpoint_query_parameters.setter
    def token_endpoint_query_parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "token_endpoint_query_parameters", value)


if not MYPY:
    class Office365ProjectConnectorDataTypesLogsArgsDict(TypedDict):
        """
        Logs data type.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    Office365ProjectConnectorDataTypesLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Office365ProjectConnectorDataTypesLogsArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Logs data type.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class Office365ProjectConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for Office Microsoft Project data connector.
        """
        logs: pulumi.Input['Office365ProjectConnectorDataTypesLogsArgsDict']
        """
        Logs data type.
        """
elif False:
    Office365ProjectConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Office365ProjectConnectorDataTypesArgs:
    def __init__(__self__, *,
                 logs: pulumi.Input['Office365ProjectConnectorDataTypesLogsArgs']):
        """
        The available data types for Office Microsoft Project data connector.
        :param pulumi.Input['Office365ProjectConnectorDataTypesLogsArgs'] logs: Logs data type.
        """
        pulumi.set(__self__, "logs", logs)

    @property
    @pulumi.getter
    def logs(self) -> pulumi.Input['Office365ProjectConnectorDataTypesLogsArgs']:
        """
        Logs data type.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: pulumi.Input['Office365ProjectConnectorDataTypesLogsArgs']):
        pulumi.set(self, "logs", value)


if not MYPY:
    class OfficeDataConnectorDataTypesExchangeArgsDict(TypedDict):
        """
        Exchange data type connection.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    OfficeDataConnectorDataTypesExchangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OfficeDataConnectorDataTypesExchangeArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Exchange data type connection.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class OfficeDataConnectorDataTypesSharePointArgsDict(TypedDict):
        """
        SharePoint data type connection.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    OfficeDataConnectorDataTypesSharePointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OfficeDataConnectorDataTypesSharePointArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        SharePoint data type connection.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class OfficeDataConnectorDataTypesTeamsArgsDict(TypedDict):
        """
        Teams data type connection.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    OfficeDataConnectorDataTypesTeamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OfficeDataConnectorDataTypesTeamsArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Teams data type connection.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class OfficeDataConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for office data connector.
        """
        exchange: pulumi.Input['OfficeDataConnectorDataTypesExchangeArgsDict']
        """
        Exchange data type connection.
        """
        share_point: pulumi.Input['OfficeDataConnectorDataTypesSharePointArgsDict']
        """
        SharePoint data type connection.
        """
        teams: pulumi.Input['OfficeDataConnectorDataTypesTeamsArgsDict']
        """
        Teams data type connection.
        """
elif False:
    OfficeDataConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OfficeDataConnectorDataTypesArgs:
    def __init__(__self__, *,
                 exchange: pulumi.Input['OfficeDataConnectorDataTypesExchangeArgs'],
                 share_point: pulumi.Input['OfficeDataConnectorDataTypesSharePointArgs'],
                 teams: pulumi.Input['OfficeDataConnectorDataTypesTeamsArgs']):
        """
        The available data types for office data connector.
        :param pulumi.Input['OfficeDataConnectorDataTypesExchangeArgs'] exchange: Exchange data type connection.
        :param pulumi.Input['OfficeDataConnectorDataTypesSharePointArgs'] share_point: SharePoint data type connection.
        :param pulumi.Input['OfficeDataConnectorDataTypesTeamsArgs'] teams: Teams data type connection.
        """
        pulumi.set(__self__, "exchange", exchange)
        pulumi.set(__self__, "share_point", share_point)
        pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter
    def exchange(self) -> pulumi.Input['OfficeDataConnectorDataTypesExchangeArgs']:
        """
        Exchange data type connection.
        """
        return pulumi.get(self, "exchange")

    @exchange.setter
    def exchange(self, value: pulumi.Input['OfficeDataConnectorDataTypesExchangeArgs']):
        pulumi.set(self, "exchange", value)

    @property
    @pulumi.getter(name="sharePoint")
    def share_point(self) -> pulumi.Input['OfficeDataConnectorDataTypesSharePointArgs']:
        """
        SharePoint data type connection.
        """
        return pulumi.get(self, "share_point")

    @share_point.setter
    def share_point(self, value: pulumi.Input['OfficeDataConnectorDataTypesSharePointArgs']):
        pulumi.set(self, "share_point", value)

    @property
    @pulumi.getter
    def teams(self) -> pulumi.Input['OfficeDataConnectorDataTypesTeamsArgs']:
        """
        Teams data type connection.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: pulumi.Input['OfficeDataConnectorDataTypesTeamsArgs']):
        pulumi.set(self, "teams", value)


if not MYPY:
    class OfficePowerBIConnectorDataTypesLogsArgsDict(TypedDict):
        """
        Logs data type.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    OfficePowerBIConnectorDataTypesLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OfficePowerBIConnectorDataTypesLogsArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Logs data type.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class OfficePowerBIConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for Office Microsoft PowerBI data connector.
        """
        logs: pulumi.Input['OfficePowerBIConnectorDataTypesLogsArgsDict']
        """
        Logs data type.
        """
elif False:
    OfficePowerBIConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OfficePowerBIConnectorDataTypesArgs:
    def __init__(__self__, *,
                 logs: pulumi.Input['OfficePowerBIConnectorDataTypesLogsArgs']):
        """
        The available data types for Office Microsoft PowerBI data connector.
        :param pulumi.Input['OfficePowerBIConnectorDataTypesLogsArgs'] logs: Logs data type.
        """
        pulumi.set(__self__, "logs", logs)

    @property
    @pulumi.getter
    def logs(self) -> pulumi.Input['OfficePowerBIConnectorDataTypesLogsArgs']:
        """
        Logs data type.
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: pulumi.Input['OfficePowerBIConnectorDataTypesLogsArgs']):
        pulumi.set(self, "logs", value)


if not MYPY:
    class OracleAuthModelArgsDict(TypedDict):
        """
        Model for API authentication for Oracle.
        """
        pem_file: pulumi.Input[str]
        """
        Content of the PRM file
        """
        public_fingerprint: pulumi.Input[str]
        """
        Public Fingerprint
        """
        tenant_id: pulumi.Input[str]
        """
        Oracle tenant ID
        """
        type: pulumi.Input[str]
        """
        Type of paging
        Expected value is 'Oracle'.
        """
        user_id: pulumi.Input[str]
        """
        Oracle user ID
        """
elif False:
    OracleAuthModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OracleAuthModelArgs:
    def __init__(__self__, *,
                 pem_file: pulumi.Input[str],
                 public_fingerprint: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 type: pulumi.Input[str],
                 user_id: pulumi.Input[str]):
        """
        Model for API authentication for Oracle.
        :param pulumi.Input[str] pem_file: Content of the PRM file
        :param pulumi.Input[str] public_fingerprint: Public Fingerprint
        :param pulumi.Input[str] tenant_id: Oracle tenant ID
        :param pulumi.Input[str] type: Type of paging
               Expected value is 'Oracle'.
        :param pulumi.Input[str] user_id: Oracle user ID
        """
        pulumi.set(__self__, "pem_file", pem_file)
        pulumi.set(__self__, "public_fingerprint", public_fingerprint)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", 'Oracle')
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="pemFile")
    def pem_file(self) -> pulumi.Input[str]:
        """
        Content of the PRM file
        """
        return pulumi.get(self, "pem_file")

    @pem_file.setter
    def pem_file(self, value: pulumi.Input[str]):
        pulumi.set(self, "pem_file", value)

    @property
    @pulumi.getter(name="publicFingerprint")
    def public_fingerprint(self) -> pulumi.Input[str]:
        """
        Public Fingerprint
        """
        return pulumi.get(self, "public_fingerprint")

    @public_fingerprint.setter
    def public_fingerprint(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_fingerprint", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        Oracle tenant ID
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of paging
        Expected value is 'Oracle'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> pulumi.Input[str]:
        """
        Oracle user ID
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class PermissionsCustomsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        Customs permissions description
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Customs permissions name
        """
elif False:
    PermissionsCustomsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsCustomsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: Customs permissions description
        :param pulumi.Input[str] name: Customs permissions name
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Customs permissions description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Customs permissions name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PermissionsResourceProviderArgsDict(TypedDict):
        permissions_display_text: NotRequired[pulumi.Input[str]]
        """
        Permission description text
        """
        provider: NotRequired[pulumi.Input[Union[str, 'ProviderName']]]
        """
        Provider name
        """
        provider_display_name: NotRequired[pulumi.Input[str]]
        """
        Permission provider display name
        """
        required_permissions: NotRequired[pulumi.Input['RequiredPermissionsArgsDict']]
        """
        Required permissions for the connector
        """
        scope: NotRequired[pulumi.Input[Union[str, 'PermissionProviderScope']]]
        """
        Permission provider scope
        """
elif False:
    PermissionsResourceProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsResourceProviderArgs:
    def __init__(__self__, *,
                 permissions_display_text: Optional[pulumi.Input[str]] = None,
                 provider: Optional[pulumi.Input[Union[str, 'ProviderName']]] = None,
                 provider_display_name: Optional[pulumi.Input[str]] = None,
                 required_permissions: Optional[pulumi.Input['RequiredPermissionsArgs']] = None,
                 scope: Optional[pulumi.Input[Union[str, 'PermissionProviderScope']]] = None):
        """
        :param pulumi.Input[str] permissions_display_text: Permission description text
        :param pulumi.Input[Union[str, 'ProviderName']] provider: Provider name
        :param pulumi.Input[str] provider_display_name: Permission provider display name
        :param pulumi.Input['RequiredPermissionsArgs'] required_permissions: Required permissions for the connector
        :param pulumi.Input[Union[str, 'PermissionProviderScope']] scope: Permission provider scope
        """
        if permissions_display_text is not None:
            pulumi.set(__self__, "permissions_display_text", permissions_display_text)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if provider_display_name is not None:
            pulumi.set(__self__, "provider_display_name", provider_display_name)
        if required_permissions is not None:
            pulumi.set(__self__, "required_permissions", required_permissions)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="permissionsDisplayText")
    def permissions_display_text(self) -> Optional[pulumi.Input[str]]:
        """
        Permission description text
        """
        return pulumi.get(self, "permissions_display_text")

    @permissions_display_text.setter
    def permissions_display_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "permissions_display_text", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[Union[str, 'ProviderName']]]:
        """
        Provider name
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[Union[str, 'ProviderName']]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter(name="providerDisplayName")
    def provider_display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Permission provider display name
        """
        return pulumi.get(self, "provider_display_name")

    @provider_display_name.setter
    def provider_display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider_display_name", value)

    @property
    @pulumi.getter(name="requiredPermissions")
    def required_permissions(self) -> Optional[pulumi.Input['RequiredPermissionsArgs']]:
        """
        Required permissions for the connector
        """
        return pulumi.get(self, "required_permissions")

    @required_permissions.setter
    def required_permissions(self, value: Optional[pulumi.Input['RequiredPermissionsArgs']]):
        pulumi.set(self, "required_permissions", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[Union[str, 'PermissionProviderScope']]]:
        """
        Permission provider scope
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[Union[str, 'PermissionProviderScope']]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class PermissionsArgsDict(TypedDict):
        """
        Permissions required for the connector
        """
        customs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PermissionsCustomsArgsDict']]]]
        """
        Customs permissions required for the connector
        """
        resource_provider: NotRequired[pulumi.Input[Sequence[pulumi.Input['PermissionsResourceProviderArgsDict']]]]
        """
        Resource provider permissions required for the connector
        """
elif False:
    PermissionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionsArgs:
    def __init__(__self__, *,
                 customs: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionsCustomsArgs']]]] = None,
                 resource_provider: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionsResourceProviderArgs']]]] = None):
        """
        Permissions required for the connector
        :param pulumi.Input[Sequence[pulumi.Input['PermissionsCustomsArgs']]] customs: Customs permissions required for the connector
        :param pulumi.Input[Sequence[pulumi.Input['PermissionsResourceProviderArgs']]] resource_provider: Resource provider permissions required for the connector
        """
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if resource_provider is not None:
            pulumi.set(__self__, "resource_provider", resource_provider)

    @property
    @pulumi.getter
    def customs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionsCustomsArgs']]]]:
        """
        Customs permissions required for the connector
        """
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionsCustomsArgs']]]]):
        pulumi.set(self, "customs", value)

    @property
    @pulumi.getter(name="resourceProvider")
    def resource_provider(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PermissionsResourceProviderArgs']]]]:
        """
        Resource provider permissions required for the connector
        """
        return pulumi.get(self, "resource_provider")

    @resource_provider.setter
    def resource_provider(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PermissionsResourceProviderArgs']]]]):
        pulumi.set(self, "resource_provider", value)


if not MYPY:
    class PlaybookActionPropertiesArgsDict(TypedDict):
        logic_app_resource_id: pulumi.Input[str]
        """
        The resource id of the playbook resource.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The tenant id of the playbook resource.
        """
elif False:
    PlaybookActionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlaybookActionPropertiesArgs:
    def __init__(__self__, *,
                 logic_app_resource_id: pulumi.Input[str],
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] logic_app_resource_id: The resource id of the playbook resource.
        :param pulumi.Input[str] tenant_id: The tenant id of the playbook resource.
        """
        pulumi.set(__self__, "logic_app_resource_id", logic_app_resource_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="logicAppResourceId")
    def logic_app_resource_id(self) -> pulumi.Input[str]:
        """
        The resource id of the playbook resource.
        """
        return pulumi.get(self, "logic_app_resource_id")

    @logic_app_resource_id.setter
    def logic_app_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "logic_app_resource_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The tenant id of the playbook resource.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class PropertyArrayChangedConditionPropertiesArgsDict(TypedDict):
        """
        Describes an automation rule condition that evaluates an array property's value change
        """
        condition_type: pulumi.Input[str]
        """

        Expected value is 'PropertyArrayChanged'.
        """
        condition_properties: NotRequired[pulumi.Input['AutomationRulePropertyArrayChangedValuesConditionArgsDict']]
elif False:
    PropertyArrayChangedConditionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyArrayChangedConditionPropertiesArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[str],
                 condition_properties: Optional[pulumi.Input['AutomationRulePropertyArrayChangedValuesConditionArgs']] = None):
        """
        Describes an automation rule condition that evaluates an array property's value change
        :param pulumi.Input[str] condition_type: 
               Expected value is 'PropertyArrayChanged'.
        """
        pulumi.set(__self__, "condition_type", 'PropertyArrayChanged')
        if condition_properties is not None:
            pulumi.set(__self__, "condition_properties", condition_properties)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[str]:
        """

        Expected value is 'PropertyArrayChanged'.
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition_type", value)

    @property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional[pulumi.Input['AutomationRulePropertyArrayChangedValuesConditionArgs']]:
        return pulumi.get(self, "condition_properties")

    @condition_properties.setter
    def condition_properties(self, value: Optional[pulumi.Input['AutomationRulePropertyArrayChangedValuesConditionArgs']]):
        pulumi.set(self, "condition_properties", value)


if not MYPY:
    class PropertyArrayConditionPropertiesArgsDict(TypedDict):
        """
        Describes an automation rule condition that evaluates an array property's value
        """
        condition_type: pulumi.Input[str]
        """

        Expected value is 'PropertyArray'.
        """
        condition_properties: NotRequired[pulumi.Input['AutomationRulePropertyArrayValuesConditionArgsDict']]
elif False:
    PropertyArrayConditionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyArrayConditionPropertiesArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[str],
                 condition_properties: Optional[pulumi.Input['AutomationRulePropertyArrayValuesConditionArgs']] = None):
        """
        Describes an automation rule condition that evaluates an array property's value
        :param pulumi.Input[str] condition_type: 
               Expected value is 'PropertyArray'.
        """
        pulumi.set(__self__, "condition_type", 'PropertyArray')
        if condition_properties is not None:
            pulumi.set(__self__, "condition_properties", condition_properties)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[str]:
        """

        Expected value is 'PropertyArray'.
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition_type", value)

    @property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional[pulumi.Input['AutomationRulePropertyArrayValuesConditionArgs']]:
        return pulumi.get(self, "condition_properties")

    @condition_properties.setter
    def condition_properties(self, value: Optional[pulumi.Input['AutomationRulePropertyArrayValuesConditionArgs']]):
        pulumi.set(self, "condition_properties", value)


if not MYPY:
    class PropertyChangedConditionPropertiesArgsDict(TypedDict):
        """
        Describes an automation rule condition that evaluates a property's value change
        """
        condition_type: pulumi.Input[str]
        """

        Expected value is 'PropertyChanged'.
        """
        condition_properties: NotRequired[pulumi.Input['AutomationRulePropertyValuesChangedConditionArgsDict']]
elif False:
    PropertyChangedConditionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyChangedConditionPropertiesArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[str],
                 condition_properties: Optional[pulumi.Input['AutomationRulePropertyValuesChangedConditionArgs']] = None):
        """
        Describes an automation rule condition that evaluates a property's value change
        :param pulumi.Input[str] condition_type: 
               Expected value is 'PropertyChanged'.
        """
        pulumi.set(__self__, "condition_type", 'PropertyChanged')
        if condition_properties is not None:
            pulumi.set(__self__, "condition_properties", condition_properties)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[str]:
        """

        Expected value is 'PropertyChanged'.
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition_type", value)

    @property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional[pulumi.Input['AutomationRulePropertyValuesChangedConditionArgs']]:
        return pulumi.get(self, "condition_properties")

    @condition_properties.setter
    def condition_properties(self, value: Optional[pulumi.Input['AutomationRulePropertyValuesChangedConditionArgs']]):
        pulumi.set(self, "condition_properties", value)


if not MYPY:
    class PropertyConditionPropertiesArgsDict(TypedDict):
        """
        Describes an automation rule condition that evaluates a property's value
        """
        condition_type: pulumi.Input[str]
        """

        Expected value is 'Property'.
        """
        condition_properties: NotRequired[pulumi.Input['AutomationRulePropertyValuesConditionArgsDict']]
elif False:
    PropertyConditionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PropertyConditionPropertiesArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[str],
                 condition_properties: Optional[pulumi.Input['AutomationRulePropertyValuesConditionArgs']] = None):
        """
        Describes an automation rule condition that evaluates a property's value
        :param pulumi.Input[str] condition_type: 
               Expected value is 'Property'.
        """
        pulumi.set(__self__, "condition_type", 'Property')
        if condition_properties is not None:
            pulumi.set(__self__, "condition_properties", condition_properties)

    @property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[str]:
        """

        Expected value is 'Property'.
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition_type", value)

    @property
    @pulumi.getter(name="conditionProperties")
    def condition_properties(self) -> Optional[pulumi.Input['AutomationRulePropertyValuesConditionArgs']]:
        return pulumi.get(self, "condition_properties")

    @condition_properties.setter
    def condition_properties(self, value: Optional[pulumi.Input['AutomationRulePropertyValuesConditionArgs']]):
        pulumi.set(self, "condition_properties", value)


if not MYPY:
    class RequiredPermissionsArgsDict(TypedDict):
        """
        Required permissions for the connector
        """
        action: NotRequired[pulumi.Input[bool]]
        """
        action permission
        """
        delete: NotRequired[pulumi.Input[bool]]
        """
        delete permission
        """
        read: NotRequired[pulumi.Input[bool]]
        """
        read permission
        """
        write: NotRequired[pulumi.Input[bool]]
        """
        write permission
        """
elif False:
    RequiredPermissionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RequiredPermissionsArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[bool]] = None,
                 delete: Optional[pulumi.Input[bool]] = None,
                 read: Optional[pulumi.Input[bool]] = None,
                 write: Optional[pulumi.Input[bool]] = None):
        """
        Required permissions for the connector
        :param pulumi.Input[bool] action: action permission
        :param pulumi.Input[bool] delete: delete permission
        :param pulumi.Input[bool] read: read permission
        :param pulumi.Input[bool] write: write permission
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if write is not None:
            pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[bool]]:
        """
        action permission
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[bool]]:
        """
        delete permission
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[bool]]:
        """
        read permission
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def write(self) -> Optional[pulumi.Input[bool]]:
        """
        write permission
        """
        return pulumi.get(self, "write")

    @write.setter
    def write(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write", value)


if not MYPY:
    class ResourceProviderRequiredPermissionsArgsDict(TypedDict):
        """
        Required permissions for the connector resource provider that define in ResourceProviders.
        For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
        """
        action: NotRequired[pulumi.Input[bool]]
        """
        Gets or sets a value indicating whether the permission is custom actions (POST).
        """
        delete: NotRequired[pulumi.Input[bool]]
        """
        Gets or sets a value indicating whether the permission is delete action (DELETE).
        """
        read: NotRequired[pulumi.Input[bool]]
        """
        Gets or sets a value indicating whether the permission is read action (GET).
        """
        write: NotRequired[pulumi.Input[bool]]
        """
        Gets or sets a value indicating whether the permission is write action (PUT or PATCH).
        """
elif False:
    ResourceProviderRequiredPermissionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceProviderRequiredPermissionsArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[bool]] = None,
                 delete: Optional[pulumi.Input[bool]] = None,
                 read: Optional[pulumi.Input[bool]] = None,
                 write: Optional[pulumi.Input[bool]] = None):
        """
        Required permissions for the connector resource provider that define in ResourceProviders.
        For more information about the permissions see <see href="https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#actions-format">here</see>.
        :param pulumi.Input[bool] action: Gets or sets a value indicating whether the permission is custom actions (POST).
        :param pulumi.Input[bool] delete: Gets or sets a value indicating whether the permission is delete action (DELETE).
        :param pulumi.Input[bool] read: Gets or sets a value indicating whether the permission is read action (GET).
        :param pulumi.Input[bool] write: Gets or sets a value indicating whether the permission is write action (PUT or PATCH).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if write is not None:
            pulumi.set(__self__, "write", write)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets or sets a value indicating whether the permission is custom actions (POST).
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets or sets a value indicating whether the permission is delete action (DELETE).
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets or sets a value indicating whether the permission is read action (GET).
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read", value)

    @property
    @pulumi.getter
    def write(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets or sets a value indicating whether the permission is write action (PUT or PATCH).
        """
        return pulumi.get(self, "write")

    @write.setter
    def write(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write", value)


if not MYPY:
    class RestApiPollerRequestConfigArgsDict(TypedDict):
        """
        The request configuration.
        """
        api_endpoint: pulumi.Input[str]
        """
        The API endpoint.
        """
        end_time_attribute_name: NotRequired[pulumi.Input[str]]
        """
        The query parameter name which the remote server expect to end query. This property goes hand to hand with `startTimeAttributeName`
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The header for the request for the remote server.
        """
        http_method: NotRequired[pulumi.Input[Union[str, 'HttpMethodVerb']]]
        """
        The HTTP method, default value GET.
        """
        is_post_payload_json: NotRequired[pulumi.Input[bool]]
        """
        Flag to indicate if HTTP POST payload is in JSON format (vs form-urlencoded).
        """
        query_parameters: NotRequired[Any]
        """
        The HTTP query parameters to RESTful API.
        """
        query_parameters_template: NotRequired[pulumi.Input[str]]
        """
        the query parameters template. Defines the query parameters template to use when passing query parameters in advanced scenarios.
        """
        query_time_format: NotRequired[pulumi.Input[str]]
        """
        The query time format. A remote server can have a query to pull data from range 'start' to 'end'. This property indicate what is the expected time format the remote server know to parse.
        """
        query_time_interval_attribute_name: NotRequired[pulumi.Input[str]]
        """
        The query parameter name which we need to send the server for query logs in time interval. Should be defined with `queryTimeIntervalPrepend` and `queryTimeIntervalDelimiter`
        """
        query_time_interval_delimiter: NotRequired[pulumi.Input[str]]
        """
        The delimiter string between 2 QueryTimeFormat in the query parameter `queryTimeIntervalAttributeName`.
        """
        query_time_interval_prepend: NotRequired[pulumi.Input[str]]
        """
        The string prepend to the value of the query parameter in `queryTimeIntervalAttributeName`.
        """
        query_window_in_min: NotRequired[pulumi.Input[int]]
        """
        The query window in minutes for the request.
        """
        rate_limit_qps: NotRequired[pulumi.Input[int]]
        """
        The Rate limit queries per second for the request..
        """
        retry_count: NotRequired[pulumi.Input[int]]
        """
        The retry count.
        """
        start_time_attribute_name: NotRequired[pulumi.Input[str]]
        """
        The query parameter name which the remote server expect to start query. This property goes hand to hand with `endTimeAttributeName`.
        """
        timeout_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The timeout in seconds.
        """
elif False:
    RestApiPollerRequestConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RestApiPollerRequestConfigArgs:
    def __init__(__self__, *,
                 api_endpoint: pulumi.Input[str],
                 end_time_attribute_name: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 http_method: Optional[pulumi.Input[Union[str, 'HttpMethodVerb']]] = None,
                 is_post_payload_json: Optional[pulumi.Input[bool]] = None,
                 query_parameters: Optional[Any] = None,
                 query_parameters_template: Optional[pulumi.Input[str]] = None,
                 query_time_format: Optional[pulumi.Input[str]] = None,
                 query_time_interval_attribute_name: Optional[pulumi.Input[str]] = None,
                 query_time_interval_delimiter: Optional[pulumi.Input[str]] = None,
                 query_time_interval_prepend: Optional[pulumi.Input[str]] = None,
                 query_window_in_min: Optional[pulumi.Input[int]] = None,
                 rate_limit_qps: Optional[pulumi.Input[int]] = None,
                 retry_count: Optional[pulumi.Input[int]] = None,
                 start_time_attribute_name: Optional[pulumi.Input[str]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        The request configuration.
        :param pulumi.Input[str] api_endpoint: The API endpoint.
        :param pulumi.Input[str] end_time_attribute_name: The query parameter name which the remote server expect to end query. This property goes hand to hand with `startTimeAttributeName`
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] headers: The header for the request for the remote server.
        :param pulumi.Input[Union[str, 'HttpMethodVerb']] http_method: The HTTP method, default value GET.
        :param pulumi.Input[bool] is_post_payload_json: Flag to indicate if HTTP POST payload is in JSON format (vs form-urlencoded).
        :param Any query_parameters: The HTTP query parameters to RESTful API.
        :param pulumi.Input[str] query_parameters_template: the query parameters template. Defines the query parameters template to use when passing query parameters in advanced scenarios.
        :param pulumi.Input[str] query_time_format: The query time format. A remote server can have a query to pull data from range 'start' to 'end'. This property indicate what is the expected time format the remote server know to parse.
        :param pulumi.Input[str] query_time_interval_attribute_name: The query parameter name which we need to send the server for query logs in time interval. Should be defined with `queryTimeIntervalPrepend` and `queryTimeIntervalDelimiter`
        :param pulumi.Input[str] query_time_interval_delimiter: The delimiter string between 2 QueryTimeFormat in the query parameter `queryTimeIntervalAttributeName`.
        :param pulumi.Input[str] query_time_interval_prepend: The string prepend to the value of the query parameter in `queryTimeIntervalAttributeName`.
        :param pulumi.Input[int] query_window_in_min: The query window in minutes for the request.
        :param pulumi.Input[int] rate_limit_qps: The Rate limit queries per second for the request..
        :param pulumi.Input[int] retry_count: The retry count.
        :param pulumi.Input[str] start_time_attribute_name: The query parameter name which the remote server expect to start query. This property goes hand to hand with `endTimeAttributeName`.
        :param pulumi.Input[int] timeout_in_seconds: The timeout in seconds.
        """
        pulumi.set(__self__, "api_endpoint", api_endpoint)
        if end_time_attribute_name is not None:
            pulumi.set(__self__, "end_time_attribute_name", end_time_attribute_name)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if is_post_payload_json is not None:
            pulumi.set(__self__, "is_post_payload_json", is_post_payload_json)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if query_parameters_template is not None:
            pulumi.set(__self__, "query_parameters_template", query_parameters_template)
        if query_time_format is not None:
            pulumi.set(__self__, "query_time_format", query_time_format)
        if query_time_interval_attribute_name is not None:
            pulumi.set(__self__, "query_time_interval_attribute_name", query_time_interval_attribute_name)
        if query_time_interval_delimiter is not None:
            pulumi.set(__self__, "query_time_interval_delimiter", query_time_interval_delimiter)
        if query_time_interval_prepend is not None:
            pulumi.set(__self__, "query_time_interval_prepend", query_time_interval_prepend)
        if query_window_in_min is not None:
            pulumi.set(__self__, "query_window_in_min", query_window_in_min)
        if rate_limit_qps is not None:
            pulumi.set(__self__, "rate_limit_qps", rate_limit_qps)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if start_time_attribute_name is not None:
            pulumi.set(__self__, "start_time_attribute_name", start_time_attribute_name)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @property
    @pulumi.getter(name="apiEndpoint")
    def api_endpoint(self) -> pulumi.Input[str]:
        """
        The API endpoint.
        """
        return pulumi.get(self, "api_endpoint")

    @api_endpoint.setter
    def api_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_endpoint", value)

    @property
    @pulumi.getter(name="endTimeAttributeName")
    def end_time_attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The query parameter name which the remote server expect to end query. This property goes hand to hand with `startTimeAttributeName`
        """
        return pulumi.get(self, "end_time_attribute_name")

    @end_time_attribute_name.setter
    def end_time_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time_attribute_name", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The header for the request for the remote server.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[Union[str, 'HttpMethodVerb']]]:
        """
        The HTTP method, default value GET.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[Union[str, 'HttpMethodVerb']]]):
        pulumi.set(self, "http_method", value)

    @property
    @pulumi.getter(name="isPostPayloadJson")
    def is_post_payload_json(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to indicate if HTTP POST payload is in JSON format (vs form-urlencoded).
        """
        return pulumi.get(self, "is_post_payload_json")

    @is_post_payload_json.setter
    def is_post_payload_json(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_post_payload_json", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Any]:
        """
        The HTTP query parameters to RESTful API.
        """
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[Any]):
        pulumi.set(self, "query_parameters", value)

    @property
    @pulumi.getter(name="queryParametersTemplate")
    def query_parameters_template(self) -> Optional[pulumi.Input[str]]:
        """
        the query parameters template. Defines the query parameters template to use when passing query parameters in advanced scenarios.
        """
        return pulumi.get(self, "query_parameters_template")

    @query_parameters_template.setter
    def query_parameters_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_parameters_template", value)

    @property
    @pulumi.getter(name="queryTimeFormat")
    def query_time_format(self) -> Optional[pulumi.Input[str]]:
        """
        The query time format. A remote server can have a query to pull data from range 'start' to 'end'. This property indicate what is the expected time format the remote server know to parse.
        """
        return pulumi.get(self, "query_time_format")

    @query_time_format.setter
    def query_time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_time_format", value)

    @property
    @pulumi.getter(name="queryTimeIntervalAttributeName")
    def query_time_interval_attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The query parameter name which we need to send the server for query logs in time interval. Should be defined with `queryTimeIntervalPrepend` and `queryTimeIntervalDelimiter`
        """
        return pulumi.get(self, "query_time_interval_attribute_name")

    @query_time_interval_attribute_name.setter
    def query_time_interval_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_time_interval_attribute_name", value)

    @property
    @pulumi.getter(name="queryTimeIntervalDelimiter")
    def query_time_interval_delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The delimiter string between 2 QueryTimeFormat in the query parameter `queryTimeIntervalAttributeName`.
        """
        return pulumi.get(self, "query_time_interval_delimiter")

    @query_time_interval_delimiter.setter
    def query_time_interval_delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_time_interval_delimiter", value)

    @property
    @pulumi.getter(name="queryTimeIntervalPrepend")
    def query_time_interval_prepend(self) -> Optional[pulumi.Input[str]]:
        """
        The string prepend to the value of the query parameter in `queryTimeIntervalAttributeName`.
        """
        return pulumi.get(self, "query_time_interval_prepend")

    @query_time_interval_prepend.setter
    def query_time_interval_prepend(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_time_interval_prepend", value)

    @property
    @pulumi.getter(name="queryWindowInMin")
    def query_window_in_min(self) -> Optional[pulumi.Input[int]]:
        """
        The query window in minutes for the request.
        """
        return pulumi.get(self, "query_window_in_min")

    @query_window_in_min.setter
    def query_window_in_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "query_window_in_min", value)

    @property
    @pulumi.getter(name="rateLimitQPS")
    def rate_limit_qps(self) -> Optional[pulumi.Input[int]]:
        """
        The Rate limit queries per second for the request..
        """
        return pulumi.get(self, "rate_limit_qps")

    @rate_limit_qps.setter
    def rate_limit_qps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rate_limit_qps", value)

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[pulumi.Input[int]]:
        """
        The retry count.
        """
        return pulumi.get(self, "retry_count")

    @retry_count.setter
    def retry_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retry_count", value)

    @property
    @pulumi.getter(name="startTimeAttributeName")
    def start_time_attribute_name(self) -> Optional[pulumi.Input[str]]:
        """
        The query parameter name which the remote server expect to start query. This property goes hand to hand with `endTimeAttributeName`.
        """
        return pulumi.get(self, "start_time_attribute_name")

    @start_time_attribute_name.setter
    def start_time_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time_attribute_name", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout in seconds.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_seconds", value)


if not MYPY:
    class RestApiPollerRequestPagingConfigArgsDict(TypedDict):
        """
        The request paging configuration.
        """
        paging_type: pulumi.Input[Union[str, 'RestApiPollerRequestPagingKind']]
        """
        Type of paging
        """
        page_size: NotRequired[pulumi.Input[int]]
        """
        Page size
        """
        page_size_parameter_name: NotRequired[pulumi.Input[str]]
        """
        Page size parameter name
        """
elif False:
    RestApiPollerRequestPagingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RestApiPollerRequestPagingConfigArgs:
    def __init__(__self__, *,
                 paging_type: pulumi.Input[Union[str, 'RestApiPollerRequestPagingKind']],
                 page_size: Optional[pulumi.Input[int]] = None,
                 page_size_parameter_name: Optional[pulumi.Input[str]] = None):
        """
        The request paging configuration.
        :param pulumi.Input[Union[str, 'RestApiPollerRequestPagingKind']] paging_type: Type of paging
        :param pulumi.Input[int] page_size: Page size
        :param pulumi.Input[str] page_size_parameter_name: Page size parameter name
        """
        pulumi.set(__self__, "paging_type", paging_type)
        if page_size is not None:
            pulumi.set(__self__, "page_size", page_size)
        if page_size_parameter_name is not None:
            pulumi.set(__self__, "page_size_parameter_name", page_size_parameter_name)

    @property
    @pulumi.getter(name="pagingType")
    def paging_type(self) -> pulumi.Input[Union[str, 'RestApiPollerRequestPagingKind']]:
        """
        Type of paging
        """
        return pulumi.get(self, "paging_type")

    @paging_type.setter
    def paging_type(self, value: pulumi.Input[Union[str, 'RestApiPollerRequestPagingKind']]):
        pulumi.set(self, "paging_type", value)

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[pulumi.Input[int]]:
        """
        Page size
        """
        return pulumi.get(self, "page_size")

    @page_size.setter
    def page_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "page_size", value)

    @property
    @pulumi.getter(name="pageSizeParameterName")
    def page_size_parameter_name(self) -> Optional[pulumi.Input[str]]:
        """
        Page size parameter name
        """
        return pulumi.get(self, "page_size_parameter_name")

    @page_size_parameter_name.setter
    def page_size_parameter_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "page_size_parameter_name", value)


if not MYPY:
    class SecurityMLAnalyticsSettingsDataSourceArgsDict(TypedDict):
        """
        security ml analytics settings data sources
        """
        connector_id: NotRequired[pulumi.Input[str]]
        """
        The connector id that provides the following data types
        """
        data_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The data types used by the security ml analytics settings
        """
elif False:
    SecurityMLAnalyticsSettingsDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityMLAnalyticsSettingsDataSourceArgs:
    def __init__(__self__, *,
                 connector_id: Optional[pulumi.Input[str]] = None,
                 data_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        security ml analytics settings data sources
        :param pulumi.Input[str] connector_id: The connector id that provides the following data types
        :param pulumi.Input[Sequence[pulumi.Input[str]]] data_types: The data types used by the security ml analytics settings
        """
        if connector_id is not None:
            pulumi.set(__self__, "connector_id", connector_id)
        if data_types is not None:
            pulumi.set(__self__, "data_types", data_types)

    @property
    @pulumi.getter(name="connectorId")
    def connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The connector id that provides the following data types
        """
        return pulumi.get(self, "connector_id")

    @connector_id.setter
    def connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connector_id", value)

    @property
    @pulumi.getter(name="dataTypes")
    def data_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The data types used by the security ml analytics settings
        """
        return pulumi.get(self, "data_types")

    @data_types.setter
    def data_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "data_types", value)


if not MYPY:
    class SentinelEntityMappingArgsDict(TypedDict):
        """
        A single sentinel entity mapping
        """
        column_name: NotRequired[pulumi.Input[str]]
        """
        the column name to be mapped to the SentinelEntities
        """
elif False:
    SentinelEntityMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SentinelEntityMappingArgs:
    def __init__(__self__, *,
                 column_name: Optional[pulumi.Input[str]] = None):
        """
        A single sentinel entity mapping
        :param pulumi.Input[str] column_name: the column name to be mapped to the SentinelEntities
        """
        if column_name is not None:
            pulumi.set(__self__, "column_name", column_name)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> Optional[pulumi.Input[str]]:
        """
        the column name to be mapped to the SentinelEntities
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column_name", value)


if not MYPY:
    class SessionAuthModelArgsDict(TypedDict):
        """
        Model for API authentication with session cookie.
        """
        password: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        The password attribute name.
        """
        type: pulumi.Input[str]
        """
        Type of paging
        Expected value is 'Session'.
        """
        user_name: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        The user name attribute key value.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        HTTP request headers to session service endpoint.
        """
        is_post_payload_json: NotRequired[pulumi.Input[bool]]
        """
        Indicating whether API key is set in HTTP POST payload.
        """
        query_parameters: NotRequired[Any]
        """
        Query parameters to session service endpoint.
        """
        session_id_name: NotRequired[pulumi.Input[str]]
        """
        Session id attribute name from HTTP response header.
        """
        session_login_request_uri: NotRequired[pulumi.Input[str]]
        """
        HTTP request URL to session service endpoint.
        """
        session_timeout_in_minutes: NotRequired[pulumi.Input[int]]
        """
        Session timeout in minutes.
        """
elif False:
    SessionAuthModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionAuthModelArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 type: pulumi.Input[str],
                 user_name: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 is_post_payload_json: Optional[pulumi.Input[bool]] = None,
                 query_parameters: Optional[Any] = None,
                 session_id_name: Optional[pulumi.Input[str]] = None,
                 session_login_request_uri: Optional[pulumi.Input[str]] = None,
                 session_timeout_in_minutes: Optional[pulumi.Input[int]] = None):
        """
        Model for API authentication with session cookie.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] password: The password attribute name.
        :param pulumi.Input[str] type: Type of paging
               Expected value is 'Session'.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] user_name: The user name attribute key value.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] headers: HTTP request headers to session service endpoint.
        :param pulumi.Input[bool] is_post_payload_json: Indicating whether API key is set in HTTP POST payload.
        :param Any query_parameters: Query parameters to session service endpoint.
        :param pulumi.Input[str] session_id_name: Session id attribute name from HTTP response header.
        :param pulumi.Input[str] session_login_request_uri: HTTP request URL to session service endpoint.
        :param pulumi.Input[int] session_timeout_in_minutes: Session timeout in minutes.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "type", 'Session')
        pulumi.set(__self__, "user_name", user_name)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if is_post_payload_json is not None:
            pulumi.set(__self__, "is_post_payload_json", is_post_payload_json)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if session_id_name is not None:
            pulumi.set(__self__, "session_id_name", session_id_name)
        if session_login_request_uri is not None:
            pulumi.set(__self__, "session_login_request_uri", session_login_request_uri)
        if session_timeout_in_minutes is not None:
            pulumi.set(__self__, "session_timeout_in_minutes", session_timeout_in_minutes)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        The password attribute name.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of paging
        Expected value is 'Session'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        The user name attribute key value.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "user_name", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        HTTP request headers to session service endpoint.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="isPostPayloadJson")
    def is_post_payload_json(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicating whether API key is set in HTTP POST payload.
        """
        return pulumi.get(self, "is_post_payload_json")

    @is_post_payload_json.setter
    def is_post_payload_json(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_post_payload_json", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[Any]:
        """
        Query parameters to session service endpoint.
        """
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[Any]):
        pulumi.set(self, "query_parameters", value)

    @property
    @pulumi.getter(name="sessionIdName")
    def session_id_name(self) -> Optional[pulumi.Input[str]]:
        """
        Session id attribute name from HTTP response header.
        """
        return pulumi.get(self, "session_id_name")

    @session_id_name.setter
    def session_id_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_id_name", value)

    @property
    @pulumi.getter(name="sessionLoginRequestUri")
    def session_login_request_uri(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP request URL to session service endpoint.
        """
        return pulumi.get(self, "session_login_request_uri")

    @session_login_request_uri.setter
    def session_login_request_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_login_request_uri", value)

    @property
    @pulumi.getter(name="sessionTimeoutInMinutes")
    def session_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Session timeout in minutes.
        """
        return pulumi.get(self, "session_timeout_in_minutes")

    @session_timeout_in_minutes.setter
    def session_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "session_timeout_in_minutes", value)


if not MYPY:
    class TIDataConnectorDataTypesIndicatorsArgsDict(TypedDict):
        """
        Data type for indicators connection.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    TIDataConnectorDataTypesIndicatorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TIDataConnectorDataTypesIndicatorsArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Data type for indicators connection.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class TIDataConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for TI (Threat Intelligence) data connector.
        """
        indicators: pulumi.Input['TIDataConnectorDataTypesIndicatorsArgsDict']
        """
        Data type for indicators connection.
        """
elif False:
    TIDataConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TIDataConnectorDataTypesArgs:
    def __init__(__self__, *,
                 indicators: pulumi.Input['TIDataConnectorDataTypesIndicatorsArgs']):
        """
        The available data types for TI (Threat Intelligence) data connector.
        :param pulumi.Input['TIDataConnectorDataTypesIndicatorsArgs'] indicators: Data type for indicators connection.
        """
        pulumi.set(__self__, "indicators", indicators)

    @property
    @pulumi.getter
    def indicators(self) -> pulumi.Input['TIDataConnectorDataTypesIndicatorsArgs']:
        """
        Data type for indicators connection.
        """
        return pulumi.get(self, "indicators")

    @indicators.setter
    def indicators(self, value: pulumi.Input['TIDataConnectorDataTypesIndicatorsArgs']):
        pulumi.set(self, "indicators", value)


if not MYPY:
    class ThreatIntelligenceExternalReferenceArgsDict(TypedDict):
        """
        Describes external reference
        """
        description: NotRequired[pulumi.Input[str]]
        """
        External reference description
        """
        external_id: NotRequired[pulumi.Input[str]]
        """
        External reference ID
        """
        hashes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        External reference hashes
        """
        source_name: NotRequired[pulumi.Input[str]]
        """
        External reference source name
        """
        url: NotRequired[pulumi.Input[str]]
        """
        External reference URL
        """
elif False:
    ThreatIntelligenceExternalReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThreatIntelligenceExternalReferenceArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 external_id: Optional[pulumi.Input[str]] = None,
                 hashes: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 source_name: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        Describes external reference
        :param pulumi.Input[str] description: External reference description
        :param pulumi.Input[str] external_id: External reference ID
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] hashes: External reference hashes
        :param pulumi.Input[str] source_name: External reference source name
        :param pulumi.Input[str] url: External reference URL
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if hashes is not None:
            pulumi.set(__self__, "hashes", hashes)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        External reference description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        """
        External reference ID
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter
    def hashes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        External reference hashes
        """
        return pulumi.get(self, "hashes")

    @hashes.setter
    def hashes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "hashes", value)

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[pulumi.Input[str]]:
        """
        External reference source name
        """
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_name", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        External reference URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ThreatIntelligenceGranularMarkingModelArgsDict(TypedDict):
        """
        Describes threat granular marking model entity
        """
        language: NotRequired[pulumi.Input[str]]
        """
        Language granular marking model
        """
        marking_ref: NotRequired[pulumi.Input[int]]
        """
        marking reference granular marking model
        """
        selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        granular marking model selectors
        """
elif False:
    ThreatIntelligenceGranularMarkingModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThreatIntelligenceGranularMarkingModelArgs:
    def __init__(__self__, *,
                 language: Optional[pulumi.Input[str]] = None,
                 marking_ref: Optional[pulumi.Input[int]] = None,
                 selectors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Describes threat granular marking model entity
        :param pulumi.Input[str] language: Language granular marking model
        :param pulumi.Input[int] marking_ref: marking reference granular marking model
        :param pulumi.Input[Sequence[pulumi.Input[str]]] selectors: granular marking model selectors
        """
        if language is not None:
            pulumi.set(__self__, "language", language)
        if marking_ref is not None:
            pulumi.set(__self__, "marking_ref", marking_ref)
        if selectors is not None:
            pulumi.set(__self__, "selectors", selectors)

    @property
    @pulumi.getter
    def language(self) -> Optional[pulumi.Input[str]]:
        """
        Language granular marking model
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language", value)

    @property
    @pulumi.getter(name="markingRef")
    def marking_ref(self) -> Optional[pulumi.Input[int]]:
        """
        marking reference granular marking model
        """
        return pulumi.get(self, "marking_ref")

    @marking_ref.setter
    def marking_ref(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "marking_ref", value)

    @property
    @pulumi.getter
    def selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        granular marking model selectors
        """
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class ThreatIntelligenceKillChainPhaseArgsDict(TypedDict):
        """
        Describes threat kill chain phase entity
        """
        kill_chain_name: NotRequired[pulumi.Input[str]]
        """
        Kill chainName name
        """
        phase_name: NotRequired[pulumi.Input[str]]
        """
        Phase name
        """
elif False:
    ThreatIntelligenceKillChainPhaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThreatIntelligenceKillChainPhaseArgs:
    def __init__(__self__, *,
                 kill_chain_name: Optional[pulumi.Input[str]] = None,
                 phase_name: Optional[pulumi.Input[str]] = None):
        """
        Describes threat kill chain phase entity
        :param pulumi.Input[str] kill_chain_name: Kill chainName name
        :param pulumi.Input[str] phase_name: Phase name
        """
        if kill_chain_name is not None:
            pulumi.set(__self__, "kill_chain_name", kill_chain_name)
        if phase_name is not None:
            pulumi.set(__self__, "phase_name", phase_name)

    @property
    @pulumi.getter(name="killChainName")
    def kill_chain_name(self) -> Optional[pulumi.Input[str]]:
        """
        Kill chainName name
        """
        return pulumi.get(self, "kill_chain_name")

    @kill_chain_name.setter
    def kill_chain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kill_chain_name", value)

    @property
    @pulumi.getter(name="phaseName")
    def phase_name(self) -> Optional[pulumi.Input[str]]:
        """
        Phase name
        """
        return pulumi.get(self, "phase_name")

    @phase_name.setter
    def phase_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase_name", value)


if not MYPY:
    class ThreatIntelligenceParsedPatternTypeValueArgsDict(TypedDict):
        """
        Describes threat kill chain phase entity
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of parsed pattern
        """
        value_type: NotRequired[pulumi.Input[str]]
        """
        Type of the value
        """
elif False:
    ThreatIntelligenceParsedPatternTypeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThreatIntelligenceParsedPatternTypeValueArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None,
                 value_type: Optional[pulumi.Input[str]] = None):
        """
        Describes threat kill chain phase entity
        :param pulumi.Input[str] value: Value of parsed pattern
        :param pulumi.Input[str] value_type: Type of the value
        """
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of parsed pattern
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the value
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class ThreatIntelligenceParsedPatternArgsDict(TypedDict):
        """
        Describes parsed pattern entity
        """
        pattern_type_key: NotRequired[pulumi.Input[str]]
        """
        Pattern type key
        """
        pattern_type_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['ThreatIntelligenceParsedPatternTypeValueArgsDict']]]]
        """
        Pattern type keys
        """
elif False:
    ThreatIntelligenceParsedPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThreatIntelligenceParsedPatternArgs:
    def __init__(__self__, *,
                 pattern_type_key: Optional[pulumi.Input[str]] = None,
                 pattern_type_values: Optional[pulumi.Input[Sequence[pulumi.Input['ThreatIntelligenceParsedPatternTypeValueArgs']]]] = None):
        """
        Describes parsed pattern entity
        :param pulumi.Input[str] pattern_type_key: Pattern type key
        :param pulumi.Input[Sequence[pulumi.Input['ThreatIntelligenceParsedPatternTypeValueArgs']]] pattern_type_values: Pattern type keys
        """
        if pattern_type_key is not None:
            pulumi.set(__self__, "pattern_type_key", pattern_type_key)
        if pattern_type_values is not None:
            pulumi.set(__self__, "pattern_type_values", pattern_type_values)

    @property
    @pulumi.getter(name="patternTypeKey")
    def pattern_type_key(self) -> Optional[pulumi.Input[str]]:
        """
        Pattern type key
        """
        return pulumi.get(self, "pattern_type_key")

    @pattern_type_key.setter
    def pattern_type_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern_type_key", value)

    @property
    @pulumi.getter(name="patternTypeValues")
    def pattern_type_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ThreatIntelligenceParsedPatternTypeValueArgs']]]]:
        """
        Pattern type keys
        """
        return pulumi.get(self, "pattern_type_values")

    @pattern_type_values.setter
    def pattern_type_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ThreatIntelligenceParsedPatternTypeValueArgs']]]]):
        pulumi.set(self, "pattern_type_values", value)


if not MYPY:
    class TiTaxiiDataConnectorDataTypesTaxiiClientArgsDict(TypedDict):
        """
        Data type for TAXII connector.
        """
        state: pulumi.Input[Union[str, 'DataTypeState']]
        """
        Describe whether this data type connection is enabled or not.
        """
elif False:
    TiTaxiiDataConnectorDataTypesTaxiiClientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TiTaxiiDataConnectorDataTypesTaxiiClientArgs:
    def __init__(__self__, *,
                 state: pulumi.Input[Union[str, 'DataTypeState']]):
        """
        Data type for TAXII connector.
        :param pulumi.Input[Union[str, 'DataTypeState']] state: Describe whether this data type connection is enabled or not.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> pulumi.Input[Union[str, 'DataTypeState']]:
        """
        Describe whether this data type connection is enabled or not.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input[Union[str, 'DataTypeState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class TiTaxiiDataConnectorDataTypesArgsDict(TypedDict):
        """
        The available data types for Threat Intelligence TAXII data connector.
        """
        taxii_client: pulumi.Input['TiTaxiiDataConnectorDataTypesTaxiiClientArgsDict']
        """
        Data type for TAXII connector.
        """
elif False:
    TiTaxiiDataConnectorDataTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TiTaxiiDataConnectorDataTypesArgs:
    def __init__(__self__, *,
                 taxii_client: pulumi.Input['TiTaxiiDataConnectorDataTypesTaxiiClientArgs']):
        """
        The available data types for Threat Intelligence TAXII data connector.
        :param pulumi.Input['TiTaxiiDataConnectorDataTypesTaxiiClientArgs'] taxii_client: Data type for TAXII connector.
        """
        pulumi.set(__self__, "taxii_client", taxii_client)

    @property
    @pulumi.getter(name="taxiiClient")
    def taxii_client(self) -> pulumi.Input['TiTaxiiDataConnectorDataTypesTaxiiClientArgs']:
        """
        Data type for TAXII connector.
        """
        return pulumi.get(self, "taxii_client")

    @taxii_client.setter
    def taxii_client(self, value: pulumi.Input['TiTaxiiDataConnectorDataTypesTaxiiClientArgs']):
        pulumi.set(self, "taxii_client", value)


if not MYPY:
    class UserInfoArgsDict(TypedDict):
        """
        User information that made some action
        """
        object_id: NotRequired[pulumi.Input[str]]
        """
        The object id of the user.
        """
elif False:
    UserInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserInfoArgs:
    def __init__(__self__, *,
                 object_id: Optional[pulumi.Input[str]] = None):
        """
        User information that made some action
        :param pulumi.Input[str] object_id: The object id of the user.
        """
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The object id of the user.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)


if not MYPY:
    class WatchlistUserInfoArgsDict(TypedDict):
        """
        User information that made some action
        """
        object_id: NotRequired[pulumi.Input[str]]
        """
        The object id of the user.
        """
elif False:
    WatchlistUserInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WatchlistUserInfoArgs:
    def __init__(__self__, *,
                 object_id: Optional[pulumi.Input[str]] = None):
        """
        User information that made some action
        :param pulumi.Input[str] object_id: The object id of the user.
        """
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The object id of the user.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)


