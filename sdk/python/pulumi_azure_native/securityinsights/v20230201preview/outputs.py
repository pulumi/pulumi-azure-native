# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ActivityTimelineItemResponse',
    'AnomalyTimelineItemResponse',
    'BookmarkTimelineItemResponse',
    'EntityInsightItemResponse',
    'EntityInsightItemResponseQueryTimeInterval',
    'GetInsightsErrorKindResponse',
    'GetInsightsResultsMetadataResponse',
    'IncidentAdditionalDataResponse',
    'IncidentLabelResponse',
    'IncidentOwnerInfoResponse',
    'InsightsTableResultResponse',
    'InsightsTableResultResponseColumns',
    'MetadataAuthorResponse',
    'MetadataCategoriesResponse',
    'MetadataDependenciesResponse',
    'MetadataSourceResponse',
    'MetadataSupportResponse',
    'RepoResponse',
    'SecurityAlertTimelineItemResponse',
    'SystemDataResponse',
    'TeamInformationResponse',
    'TimelineAggregationResponse',
    'TimelineErrorResponse',
    'TimelineResultsMetadataResponse',
    'UserInfoResponse',
]

@pulumi.output_type
class ActivityTimelineItemResponse(dict):
    """
    Represents Activity timeline item.
    """
    def __init__(__self__, *,
                 bucket_end_time_utc: str,
                 bucket_start_time_utc: str,
                 content: str,
                 first_activity_time_utc: str,
                 kind: str,
                 last_activity_time_utc: str,
                 query_id: str,
                 title: str):
        """
        Represents Activity timeline item.
        :param str bucket_end_time_utc: The grouping bucket end time.
        :param str bucket_start_time_utc: The grouping bucket start time.
        :param str content: The activity timeline content.
        :param str first_activity_time_utc: The time of the first activity in the grouping bucket.
        :param str kind: The entity query kind
               Expected value is 'Activity'.
        :param str last_activity_time_utc: The time of the last activity in the grouping bucket.
        :param str query_id: The activity query id.
        :param str title: The activity timeline title.
        """
        ActivityTimelineItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_end_time_utc=bucket_end_time_utc,
            bucket_start_time_utc=bucket_start_time_utc,
            content=content,
            first_activity_time_utc=first_activity_time_utc,
            kind=kind,
            last_activity_time_utc=last_activity_time_utc,
            query_id=query_id,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_end_time_utc: Optional[str] = None,
             bucket_start_time_utc: Optional[str] = None,
             content: Optional[str] = None,
             first_activity_time_utc: Optional[str] = None,
             kind: Optional[str] = None,
             last_activity_time_utc: Optional[str] = None,
             query_id: Optional[str] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_end_time_utc is None and 'bucketEndTimeUTC' in kwargs:
            bucket_end_time_utc = kwargs['bucketEndTimeUTC']
        if bucket_end_time_utc is None:
            raise TypeError("Missing 'bucket_end_time_utc' argument")
        if bucket_start_time_utc is None and 'bucketStartTimeUTC' in kwargs:
            bucket_start_time_utc = kwargs['bucketStartTimeUTC']
        if bucket_start_time_utc is None:
            raise TypeError("Missing 'bucket_start_time_utc' argument")
        if content is None:
            raise TypeError("Missing 'content' argument")
        if first_activity_time_utc is None and 'firstActivityTimeUTC' in kwargs:
            first_activity_time_utc = kwargs['firstActivityTimeUTC']
        if first_activity_time_utc is None:
            raise TypeError("Missing 'first_activity_time_utc' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if last_activity_time_utc is None and 'lastActivityTimeUTC' in kwargs:
            last_activity_time_utc = kwargs['lastActivityTimeUTC']
        if last_activity_time_utc is None:
            raise TypeError("Missing 'last_activity_time_utc' argument")
        if query_id is None and 'queryId' in kwargs:
            query_id = kwargs['queryId']
        if query_id is None:
            raise TypeError("Missing 'query_id' argument")
        if title is None:
            raise TypeError("Missing 'title' argument")

        _setter("bucket_end_time_utc", bucket_end_time_utc)
        _setter("bucket_start_time_utc", bucket_start_time_utc)
        _setter("content", content)
        _setter("first_activity_time_utc", first_activity_time_utc)
        _setter("kind", 'Activity')
        _setter("last_activity_time_utc", last_activity_time_utc)
        _setter("query_id", query_id)
        _setter("title", title)

    @property
    @pulumi.getter(name="bucketEndTimeUTC")
    def bucket_end_time_utc(self) -> str:
        """
        The grouping bucket end time.
        """
        return pulumi.get(self, "bucket_end_time_utc")

    @property
    @pulumi.getter(name="bucketStartTimeUTC")
    def bucket_start_time_utc(self) -> str:
        """
        The grouping bucket start time.
        """
        return pulumi.get(self, "bucket_start_time_utc")

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The activity timeline content.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="firstActivityTimeUTC")
    def first_activity_time_utc(self) -> str:
        """
        The time of the first activity in the grouping bucket.
        """
        return pulumi.get(self, "first_activity_time_utc")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The entity query kind
        Expected value is 'Activity'.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="lastActivityTimeUTC")
    def last_activity_time_utc(self) -> str:
        """
        The time of the last activity in the grouping bucket.
        """
        return pulumi.get(self, "last_activity_time_utc")

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> str:
        """
        The activity query id.
        """
        return pulumi.get(self, "query_id")

    @property
    @pulumi.getter
    def title(self) -> str:
        """
        The activity timeline title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class AnomalyTimelineItemResponse(dict):
    """
    Represents anomaly timeline item.
    """
    def __init__(__self__, *,
                 azure_resource_id: str,
                 display_name: str,
                 end_time_utc: str,
                 kind: str,
                 start_time_utc: str,
                 time_generated: str,
                 description: Optional[str] = None,
                 intent: Optional[str] = None,
                 product_name: Optional[str] = None,
                 reasons: Optional[Sequence[str]] = None,
                 techniques: Optional[Sequence[str]] = None,
                 vendor: Optional[str] = None):
        """
        Represents anomaly timeline item.
        :param str azure_resource_id: The anomaly azure resource id.
        :param str display_name: The anomaly name.
        :param str end_time_utc: The anomaly end time.
        :param str kind: The entity query kind
               Expected value is 'Anomaly'.
        :param str start_time_utc: The anomaly start time.
        :param str time_generated: The anomaly generated time.
        :param str description: The anomaly description.
        :param str intent: The intent of the anomaly.
        :param str product_name: The anomaly product name.
        :param Sequence[str] reasons: The reasons that cause the anomaly.
        :param Sequence[str] techniques: The techniques of the anomaly.
        :param str vendor: The name of the anomaly vendor.
        """
        AnomalyTimelineItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_resource_id=azure_resource_id,
            display_name=display_name,
            end_time_utc=end_time_utc,
            kind=kind,
            start_time_utc=start_time_utc,
            time_generated=time_generated,
            description=description,
            intent=intent,
            product_name=product_name,
            reasons=reasons,
            techniques=techniques,
            vendor=vendor,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_resource_id: Optional[str] = None,
             display_name: Optional[str] = None,
             end_time_utc: Optional[str] = None,
             kind: Optional[str] = None,
             start_time_utc: Optional[str] = None,
             time_generated: Optional[str] = None,
             description: Optional[str] = None,
             intent: Optional[str] = None,
             product_name: Optional[str] = None,
             reasons: Optional[Sequence[str]] = None,
             techniques: Optional[Sequence[str]] = None,
             vendor: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if azure_resource_id is None and 'azureResourceId' in kwargs:
            azure_resource_id = kwargs['azureResourceId']
        if azure_resource_id is None:
            raise TypeError("Missing 'azure_resource_id' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if end_time_utc is None and 'endTimeUtc' in kwargs:
            end_time_utc = kwargs['endTimeUtc']
        if end_time_utc is None:
            raise TypeError("Missing 'end_time_utc' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if start_time_utc is None and 'startTimeUtc' in kwargs:
            start_time_utc = kwargs['startTimeUtc']
        if start_time_utc is None:
            raise TypeError("Missing 'start_time_utc' argument")
        if time_generated is None and 'timeGenerated' in kwargs:
            time_generated = kwargs['timeGenerated']
        if time_generated is None:
            raise TypeError("Missing 'time_generated' argument")
        if product_name is None and 'productName' in kwargs:
            product_name = kwargs['productName']

        _setter("azure_resource_id", azure_resource_id)
        _setter("display_name", display_name)
        _setter("end_time_utc", end_time_utc)
        _setter("kind", 'Anomaly')
        _setter("start_time_utc", start_time_utc)
        _setter("time_generated", time_generated)
        if description is not None:
            _setter("description", description)
        if intent is not None:
            _setter("intent", intent)
        if product_name is not None:
            _setter("product_name", product_name)
        if reasons is not None:
            _setter("reasons", reasons)
        if techniques is not None:
            _setter("techniques", techniques)
        if vendor is not None:
            _setter("vendor", vendor)

    @property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> str:
        """
        The anomaly azure resource id.
        """
        return pulumi.get(self, "azure_resource_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The anomaly name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> str:
        """
        The anomaly end time.
        """
        return pulumi.get(self, "end_time_utc")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The entity query kind
        Expected value is 'Anomaly'.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> str:
        """
        The anomaly start time.
        """
        return pulumi.get(self, "start_time_utc")

    @property
    @pulumi.getter(name="timeGenerated")
    def time_generated(self) -> str:
        """
        The anomaly generated time.
        """
        return pulumi.get(self, "time_generated")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The anomaly description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def intent(self) -> Optional[str]:
        """
        The intent of the anomaly.
        """
        return pulumi.get(self, "intent")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        """
        The anomaly product name.
        """
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter
    def reasons(self) -> Optional[Sequence[str]]:
        """
        The reasons that cause the anomaly.
        """
        return pulumi.get(self, "reasons")

    @property
    @pulumi.getter
    def techniques(self) -> Optional[Sequence[str]]:
        """
        The techniques of the anomaly.
        """
        return pulumi.get(self, "techniques")

    @property
    @pulumi.getter
    def vendor(self) -> Optional[str]:
        """
        The name of the anomaly vendor.
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class BookmarkTimelineItemResponse(dict):
    """
    Represents bookmark timeline item.
    """
    def __init__(__self__, *,
                 azure_resource_id: str,
                 kind: str,
                 created_by: Optional['outputs.UserInfoResponse'] = None,
                 display_name: Optional[str] = None,
                 end_time_utc: Optional[str] = None,
                 event_time: Optional[str] = None,
                 labels: Optional[Sequence[str]] = None,
                 notes: Optional[str] = None,
                 start_time_utc: Optional[str] = None):
        """
        Represents bookmark timeline item.
        :param str azure_resource_id: The bookmark azure resource id.
        :param str kind: The entity query kind
               Expected value is 'Bookmark'.
        :param 'UserInfoResponse' created_by: Describes a user that created the bookmark
        :param str display_name: The bookmark display name.
        :param str end_time_utc: The bookmark end time.
        :param str event_time: The bookmark event time.
        :param Sequence[str] labels: List of labels relevant to this bookmark
        :param str notes: The notes of the bookmark
        :param str start_time_utc: The bookmark start time.
        """
        BookmarkTimelineItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_resource_id=azure_resource_id,
            kind=kind,
            created_by=created_by,
            display_name=display_name,
            end_time_utc=end_time_utc,
            event_time=event_time,
            labels=labels,
            notes=notes,
            start_time_utc=start_time_utc,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_resource_id: Optional[str] = None,
             kind: Optional[str] = None,
             created_by: Optional['outputs.UserInfoResponse'] = None,
             display_name: Optional[str] = None,
             end_time_utc: Optional[str] = None,
             event_time: Optional[str] = None,
             labels: Optional[Sequence[str]] = None,
             notes: Optional[str] = None,
             start_time_utc: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if azure_resource_id is None and 'azureResourceId' in kwargs:
            azure_resource_id = kwargs['azureResourceId']
        if azure_resource_id is None:
            raise TypeError("Missing 'azure_resource_id' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if end_time_utc is None and 'endTimeUtc' in kwargs:
            end_time_utc = kwargs['endTimeUtc']
        if event_time is None and 'eventTime' in kwargs:
            event_time = kwargs['eventTime']
        if start_time_utc is None and 'startTimeUtc' in kwargs:
            start_time_utc = kwargs['startTimeUtc']

        _setter("azure_resource_id", azure_resource_id)
        _setter("kind", 'Bookmark')
        if created_by is not None:
            _setter("created_by", created_by)
        if display_name is not None:
            _setter("display_name", display_name)
        if end_time_utc is not None:
            _setter("end_time_utc", end_time_utc)
        if event_time is not None:
            _setter("event_time", event_time)
        if labels is not None:
            _setter("labels", labels)
        if notes is not None:
            _setter("notes", notes)
        if start_time_utc is not None:
            _setter("start_time_utc", start_time_utc)

    @property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> str:
        """
        The bookmark azure resource id.
        """
        return pulumi.get(self, "azure_resource_id")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The entity query kind
        Expected value is 'Bookmark'.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional['outputs.UserInfoResponse']:
        """
        Describes a user that created the bookmark
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        The bookmark display name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> Optional[str]:
        """
        The bookmark end time.
        """
        return pulumi.get(self, "end_time_utc")

    @property
    @pulumi.getter(name="eventTime")
    def event_time(self) -> Optional[str]:
        """
        The bookmark event time.
        """
        return pulumi.get(self, "event_time")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        List of labels relevant to this bookmark
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def notes(self) -> Optional[str]:
        """
        The notes of the bookmark
        """
        return pulumi.get(self, "notes")

    @property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> Optional[str]:
        """
        The bookmark start time.
        """
        return pulumi.get(self, "start_time_utc")


@pulumi.output_type
class EntityInsightItemResponse(dict):
    """
    Entity insight Item.
    """
    def __init__(__self__, *,
                 chart_query_results: Optional[Sequence['outputs.InsightsTableResultResponse']] = None,
                 query_id: Optional[str] = None,
                 query_time_interval: Optional['outputs.EntityInsightItemResponseQueryTimeInterval'] = None,
                 table_query_results: Optional['outputs.InsightsTableResultResponse'] = None):
        """
        Entity insight Item.
        :param Sequence['InsightsTableResultResponse'] chart_query_results: Query results for table insights query.
        :param str query_id: The query id of the insight
        :param 'EntityInsightItemResponseQueryTimeInterval' query_time_interval: The Time interval that the query actually executed on.
        :param 'InsightsTableResultResponse' table_query_results: Query results for table insights query.
        """
        EntityInsightItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            chart_query_results=chart_query_results,
            query_id=query_id,
            query_time_interval=query_time_interval,
            table_query_results=table_query_results,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             chart_query_results: Optional[Sequence['outputs.InsightsTableResultResponse']] = None,
             query_id: Optional[str] = None,
             query_time_interval: Optional['outputs.EntityInsightItemResponseQueryTimeInterval'] = None,
             table_query_results: Optional['outputs.InsightsTableResultResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if chart_query_results is None and 'chartQueryResults' in kwargs:
            chart_query_results = kwargs['chartQueryResults']
        if query_id is None and 'queryId' in kwargs:
            query_id = kwargs['queryId']
        if query_time_interval is None and 'queryTimeInterval' in kwargs:
            query_time_interval = kwargs['queryTimeInterval']
        if table_query_results is None and 'tableQueryResults' in kwargs:
            table_query_results = kwargs['tableQueryResults']

        if chart_query_results is not None:
            _setter("chart_query_results", chart_query_results)
        if query_id is not None:
            _setter("query_id", query_id)
        if query_time_interval is not None:
            _setter("query_time_interval", query_time_interval)
        if table_query_results is not None:
            _setter("table_query_results", table_query_results)

    @property
    @pulumi.getter(name="chartQueryResults")
    def chart_query_results(self) -> Optional[Sequence['outputs.InsightsTableResultResponse']]:
        """
        Query results for table insights query.
        """
        return pulumi.get(self, "chart_query_results")

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> Optional[str]:
        """
        The query id of the insight
        """
        return pulumi.get(self, "query_id")

    @property
    @pulumi.getter(name="queryTimeInterval")
    def query_time_interval(self) -> Optional['outputs.EntityInsightItemResponseQueryTimeInterval']:
        """
        The Time interval that the query actually executed on.
        """
        return pulumi.get(self, "query_time_interval")

    @property
    @pulumi.getter(name="tableQueryResults")
    def table_query_results(self) -> Optional['outputs.InsightsTableResultResponse']:
        """
        Query results for table insights query.
        """
        return pulumi.get(self, "table_query_results")


@pulumi.output_type
class EntityInsightItemResponseQueryTimeInterval(dict):
    """
    The Time interval that the query actually executed on.
    """
    def __init__(__self__, *,
                 end_time: Optional[str] = None,
                 start_time: Optional[str] = None):
        """
        The Time interval that the query actually executed on.
        :param str end_time: Insight query end time
        :param str start_time: Insight query start time
        """
        EntityInsightItemResponseQueryTimeInterval._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_time=end_time,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_time: Optional[str] = None,
             start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end_time is None and 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if start_time is None and 'startTime' in kwargs:
            start_time = kwargs['startTime']

        if end_time is not None:
            _setter("end_time", end_time)
        if start_time is not None:
            _setter("start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        Insight query end time
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Insight query start time
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetInsightsErrorKindResponse(dict):
    """
    GetInsights Query Errors.
    """
    def __init__(__self__, *,
                 error_message: str,
                 kind: str,
                 query_id: Optional[str] = None):
        """
        GetInsights Query Errors.
        :param str error_message: the error message
        :param str kind: the query kind
        :param str query_id: the query id
        """
        GetInsightsErrorKindResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error_message=error_message,
            kind=kind,
            query_id=query_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error_message: Optional[str] = None,
             kind: Optional[str] = None,
             query_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error_message is None and 'errorMessage' in kwargs:
            error_message = kwargs['errorMessage']
        if error_message is None:
            raise TypeError("Missing 'error_message' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if query_id is None and 'queryId' in kwargs:
            query_id = kwargs['queryId']

        _setter("error_message", error_message)
        _setter("kind", kind)
        if query_id is not None:
            _setter("query_id", query_id)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        the error message
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        the query kind
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> Optional[str]:
        """
        the query id
        """
        return pulumi.get(self, "query_id")


@pulumi.output_type
class GetInsightsResultsMetadataResponse(dict):
    """
    Get Insights result metadata.
    """
    def __init__(__self__, *,
                 total_count: int,
                 errors: Optional[Sequence['outputs.GetInsightsErrorKindResponse']] = None):
        """
        Get Insights result metadata.
        :param int total_count: the total items found for the insights request
        :param Sequence['GetInsightsErrorKindResponse'] errors: information about the failed queries
        """
        GetInsightsResultsMetadataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            total_count=total_count,
            errors=errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             total_count: Optional[int] = None,
             errors: Optional[Sequence['outputs.GetInsightsErrorKindResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if total_count is None and 'totalCount' in kwargs:
            total_count = kwargs['totalCount']
        if total_count is None:
            raise TypeError("Missing 'total_count' argument")

        _setter("total_count", total_count)
        if errors is not None:
            _setter("errors", errors)

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> int:
        """
        the total items found for the insights request
        """
        return pulumi.get(self, "total_count")

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.GetInsightsErrorKindResponse']]:
        """
        information about the failed queries
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class IncidentAdditionalDataResponse(dict):
    """
    Incident additional data property bag.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertProductNames":
            suggest = "alert_product_names"
        elif key == "alertsCount":
            suggest = "alerts_count"
        elif key == "bookmarksCount":
            suggest = "bookmarks_count"
        elif key == "commentsCount":
            suggest = "comments_count"
        elif key == "providerIncidentUrl":
            suggest = "provider_incident_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentAdditionalDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentAdditionalDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentAdditionalDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_product_names: Sequence[str],
                 alerts_count: int,
                 bookmarks_count: int,
                 comments_count: int,
                 provider_incident_url: str,
                 tactics: Sequence[str],
                 techniques: Sequence[str]):
        """
        Incident additional data property bag.
        :param Sequence[str] alert_product_names: List of product names of alerts in the incident
        :param int alerts_count: The number of alerts in the incident
        :param int bookmarks_count: The number of bookmarks in the incident
        :param int comments_count: The number of comments in the incident
        :param str provider_incident_url: The provider incident url to the incident in Microsoft 365 Defender portal
        :param Sequence[str] tactics: The tactics associated with incident
        :param Sequence[str] techniques: The techniques associated with incident's tactics
        """
        IncidentAdditionalDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_product_names=alert_product_names,
            alerts_count=alerts_count,
            bookmarks_count=bookmarks_count,
            comments_count=comments_count,
            provider_incident_url=provider_incident_url,
            tactics=tactics,
            techniques=techniques,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_product_names: Optional[Sequence[str]] = None,
             alerts_count: Optional[int] = None,
             bookmarks_count: Optional[int] = None,
             comments_count: Optional[int] = None,
             provider_incident_url: Optional[str] = None,
             tactics: Optional[Sequence[str]] = None,
             techniques: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alert_product_names is None and 'alertProductNames' in kwargs:
            alert_product_names = kwargs['alertProductNames']
        if alert_product_names is None:
            raise TypeError("Missing 'alert_product_names' argument")
        if alerts_count is None and 'alertsCount' in kwargs:
            alerts_count = kwargs['alertsCount']
        if alerts_count is None:
            raise TypeError("Missing 'alerts_count' argument")
        if bookmarks_count is None and 'bookmarksCount' in kwargs:
            bookmarks_count = kwargs['bookmarksCount']
        if bookmarks_count is None:
            raise TypeError("Missing 'bookmarks_count' argument")
        if comments_count is None and 'commentsCount' in kwargs:
            comments_count = kwargs['commentsCount']
        if comments_count is None:
            raise TypeError("Missing 'comments_count' argument")
        if provider_incident_url is None and 'providerIncidentUrl' in kwargs:
            provider_incident_url = kwargs['providerIncidentUrl']
        if provider_incident_url is None:
            raise TypeError("Missing 'provider_incident_url' argument")
        if tactics is None:
            raise TypeError("Missing 'tactics' argument")
        if techniques is None:
            raise TypeError("Missing 'techniques' argument")

        _setter("alert_product_names", alert_product_names)
        _setter("alerts_count", alerts_count)
        _setter("bookmarks_count", bookmarks_count)
        _setter("comments_count", comments_count)
        _setter("provider_incident_url", provider_incident_url)
        _setter("tactics", tactics)
        _setter("techniques", techniques)

    @property
    @pulumi.getter(name="alertProductNames")
    def alert_product_names(self) -> Sequence[str]:
        """
        List of product names of alerts in the incident
        """
        return pulumi.get(self, "alert_product_names")

    @property
    @pulumi.getter(name="alertsCount")
    def alerts_count(self) -> int:
        """
        The number of alerts in the incident
        """
        return pulumi.get(self, "alerts_count")

    @property
    @pulumi.getter(name="bookmarksCount")
    def bookmarks_count(self) -> int:
        """
        The number of bookmarks in the incident
        """
        return pulumi.get(self, "bookmarks_count")

    @property
    @pulumi.getter(name="commentsCount")
    def comments_count(self) -> int:
        """
        The number of comments in the incident
        """
        return pulumi.get(self, "comments_count")

    @property
    @pulumi.getter(name="providerIncidentUrl")
    def provider_incident_url(self) -> str:
        """
        The provider incident url to the incident in Microsoft 365 Defender portal
        """
        return pulumi.get(self, "provider_incident_url")

    @property
    @pulumi.getter
    def tactics(self) -> Sequence[str]:
        """
        The tactics associated with incident
        """
        return pulumi.get(self, "tactics")

    @property
    @pulumi.getter
    def techniques(self) -> Sequence[str]:
        """
        The techniques associated with incident's tactics
        """
        return pulumi.get(self, "techniques")


@pulumi.output_type
class IncidentLabelResponse(dict):
    """
    Represents an incident label
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelName":
            suggest = "label_name"
        elif key == "labelType":
            suggest = "label_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentLabelResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentLabelResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentLabelResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_name: str,
                 label_type: str):
        """
        Represents an incident label
        :param str label_name: The name of the label
        :param str label_type: The type of the label
        """
        IncidentLabelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label_name=label_name,
            label_type=label_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label_name: Optional[str] = None,
             label_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if label_name is None and 'labelName' in kwargs:
            label_name = kwargs['labelName']
        if label_name is None:
            raise TypeError("Missing 'label_name' argument")
        if label_type is None and 'labelType' in kwargs:
            label_type = kwargs['labelType']
        if label_type is None:
            raise TypeError("Missing 'label_type' argument")

        _setter("label_name", label_name)
        _setter("label_type", label_type)

    @property
    @pulumi.getter(name="labelName")
    def label_name(self) -> str:
        """
        The name of the label
        """
        return pulumi.get(self, "label_name")

    @property
    @pulumi.getter(name="labelType")
    def label_type(self) -> str:
        """
        The type of the label
        """
        return pulumi.get(self, "label_type")


@pulumi.output_type
class IncidentOwnerInfoResponse(dict):
    """
    Information on the user an incident is assigned to
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignedTo":
            suggest = "assigned_to"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "ownerType":
            suggest = "owner_type"
        elif key == "userPrincipalName":
            suggest = "user_principal_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentOwnerInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentOwnerInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentOwnerInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assigned_to: Optional[str] = None,
                 email: Optional[str] = None,
                 object_id: Optional[str] = None,
                 owner_type: Optional[str] = None,
                 user_principal_name: Optional[str] = None):
        """
        Information on the user an incident is assigned to
        :param str assigned_to: The name of the user the incident is assigned to.
        :param str email: The email of the user the incident is assigned to.
        :param str object_id: The object id of the user the incident is assigned to.
        :param str owner_type: The type of the owner the incident is assigned to.
        :param str user_principal_name: The user principal name of the user the incident is assigned to.
        """
        IncidentOwnerInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assigned_to=assigned_to,
            email=email,
            object_id=object_id,
            owner_type=owner_type,
            user_principal_name=user_principal_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assigned_to: Optional[str] = None,
             email: Optional[str] = None,
             object_id: Optional[str] = None,
             owner_type: Optional[str] = None,
             user_principal_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if assigned_to is None and 'assignedTo' in kwargs:
            assigned_to = kwargs['assignedTo']
        if object_id is None and 'objectId' in kwargs:
            object_id = kwargs['objectId']
        if owner_type is None and 'ownerType' in kwargs:
            owner_type = kwargs['ownerType']
        if user_principal_name is None and 'userPrincipalName' in kwargs:
            user_principal_name = kwargs['userPrincipalName']

        if assigned_to is not None:
            _setter("assigned_to", assigned_to)
        if email is not None:
            _setter("email", email)
        if object_id is not None:
            _setter("object_id", object_id)
        if owner_type is not None:
            _setter("owner_type", owner_type)
        if user_principal_name is not None:
            _setter("user_principal_name", user_principal_name)

    @property
    @pulumi.getter(name="assignedTo")
    def assigned_to(self) -> Optional[str]:
        """
        The name of the user the incident is assigned to.
        """
        return pulumi.get(self, "assigned_to")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The email of the user the incident is assigned to.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[str]:
        """
        The object id of the user the incident is assigned to.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="ownerType")
    def owner_type(self) -> Optional[str]:
        """
        The type of the owner the incident is assigned to.
        """
        return pulumi.get(self, "owner_type")

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[str]:
        """
        The user principal name of the user the incident is assigned to.
        """
        return pulumi.get(self, "user_principal_name")


@pulumi.output_type
class InsightsTableResultResponse(dict):
    """
    Query results for table insights query.
    """
    def __init__(__self__, *,
                 columns: Optional[Sequence['outputs.InsightsTableResultResponseColumns']] = None,
                 rows: Optional[Sequence[Sequence[str]]] = None):
        """
        Query results for table insights query.
        :param Sequence['InsightsTableResultResponseColumns'] columns: Columns Metadata of the table
        :param Sequence[Sequence[str]] rows: Rows data of the table
        """
        InsightsTableResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            rows=rows,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence['outputs.InsightsTableResultResponseColumns']] = None,
             rows: Optional[Sequence[Sequence[str]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if columns is not None:
            _setter("columns", columns)
        if rows is not None:
            _setter("rows", rows)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.InsightsTableResultResponseColumns']]:
        """
        Columns Metadata of the table
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def rows(self) -> Optional[Sequence[Sequence[str]]]:
        """
        Rows data of the table
        """
        return pulumi.get(self, "rows")


@pulumi.output_type
class InsightsTableResultResponseColumns(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: the name of the colum
        :param str type: the type of the colum
        """
        InsightsTableResultResponseColumns._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        the name of the colum
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        the type of the colum
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MetadataAuthorResponse(dict):
    """
    Publisher or creator of the content item.
    """
    def __init__(__self__, *,
                 email: Optional[str] = None,
                 link: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Publisher or creator of the content item.
        :param str email: Email of author contact
        :param str link: Link for author/vendor page
        :param str name: Name of the author. Company or person.
        """
        MetadataAuthorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            link=link,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: Optional[str] = None,
             link: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if email is not None:
            _setter("email", email)
        if link is not None:
            _setter("link", link)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Email of author contact
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        Link for author/vendor page
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the author. Company or person.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MetadataCategoriesResponse(dict):
    """
    ies for the solution content item
    """
    def __init__(__self__, *,
                 domains: Optional[Sequence[str]] = None,
                 verticals: Optional[Sequence[str]] = None):
        """
        ies for the solution content item
        :param Sequence[str] domains: domain for the solution content item
        :param Sequence[str] verticals: Industry verticals for the solution content item
        """
        MetadataCategoriesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domains=domains,
            verticals=verticals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domains: Optional[Sequence[str]] = None,
             verticals: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if domains is not None:
            _setter("domains", domains)
        if verticals is not None:
            _setter("verticals", verticals)

    @property
    @pulumi.getter
    def domains(self) -> Optional[Sequence[str]]:
        """
        domain for the solution content item
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter
    def verticals(self) -> Optional[Sequence[str]]:
        """
        Industry verticals for the solution content item
        """
        return pulumi.get(self, "verticals")


@pulumi.output_type
class MetadataDependenciesResponse(dict):
    """
    Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex dependencies.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentId":
            suggest = "content_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataDependenciesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataDependenciesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataDependenciesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_id: Optional[str] = None,
                 criteria: Optional[Sequence['outputs.MetadataDependenciesResponse']] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 operator: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex dependencies.
        :param str content_id: Id of the content item we depend on
        :param Sequence['MetadataDependenciesResponse'] criteria: This is the list of dependencies we must fulfill, according to the AND/OR operator
        :param str kind: Type of the content item we depend on
        :param str name: Name of the content item
        :param str operator: Operator used for list of dependencies in criteria array.
        :param str version: Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        """
        MetadataDependenciesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content_id=content_id,
            criteria=criteria,
            kind=kind,
            name=name,
            operator=operator,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content_id: Optional[str] = None,
             criteria: Optional[Sequence['outputs.MetadataDependenciesResponse']] = None,
             kind: Optional[str] = None,
             name: Optional[str] = None,
             operator: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if content_id is None and 'contentId' in kwargs:
            content_id = kwargs['contentId']

        if content_id is not None:
            _setter("content_id", content_id)
        if criteria is not None:
            _setter("criteria", criteria)
        if kind is not None:
            _setter("kind", kind)
        if name is not None:
            _setter("name", name)
        if operator is not None:
            _setter("operator", operator)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="contentId")
    def content_id(self) -> Optional[str]:
        """
        Id of the content item we depend on
        """
        return pulumi.get(self, "content_id")

    @property
    @pulumi.getter
    def criteria(self) -> Optional[Sequence['outputs.MetadataDependenciesResponse']]:
        """
        This is the list of dependencies we must fulfill, according to the AND/OR operator
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Type of the content item we depend on
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the content item
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator used for list of dependencies in criteria array.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MetadataSourceResponse(dict):
    """
    The original source of the content item, where it comes from.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceId":
            suggest = "source_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataSourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataSourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataSourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: str,
                 name: Optional[str] = None,
                 source_id: Optional[str] = None):
        """
        The original source of the content item, where it comes from.
        :param str kind: Source type of the content
        :param str name: Name of the content source.  The repo name, solution name, LA workspace name etc.
        :param str source_id: ID of the content source.  The solution ID, workspace ID, etc
        """
        MetadataSourceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kind=kind,
            name=name,
            source_id=source_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kind: Optional[str] = None,
             name: Optional[str] = None,
             source_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if source_id is None and 'sourceId' in kwargs:
            source_id = kwargs['sourceId']

        _setter("kind", kind)
        if name is not None:
            _setter("name", name)
        if source_id is not None:
            _setter("source_id", source_id)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Source type of the content
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the content source.  The repo name, solution name, LA workspace name etc.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[str]:
        """
        ID of the content source.  The solution ID, workspace ID, etc
        """
        return pulumi.get(self, "source_id")


@pulumi.output_type
class MetadataSupportResponse(dict):
    """
    Support information for the content item.
    """
    def __init__(__self__, *,
                 tier: str,
                 email: Optional[str] = None,
                 link: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Support information for the content item.
        :param str tier: Type of support for content item
        :param str email: Email of support contact
        :param str link: Link for support help, like to support page to open a ticket etc.
        :param str name: Name of the support contact. Company or person.
        """
        MetadataSupportResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tier=tier,
            email=email,
            link=link,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tier: Optional[str] = None,
             email: Optional[str] = None,
             link: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if tier is None:
            raise TypeError("Missing 'tier' argument")

        _setter("tier", tier)
        if email is not None:
            _setter("email", email)
        if link is not None:
            _setter("link", link)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        Type of support for content item
        """
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Email of support contact
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        Link for support help, like to support page to open a ticket etc.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the support contact. Company or person.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RepoResponse(dict):
    """
    Represents a repository.
    """
    def __init__(__self__, *,
                 branches: Optional[Sequence[str]] = None,
                 full_name: Optional[str] = None,
                 url: Optional[str] = None):
        """
        Represents a repository.
        :param Sequence[str] branches: Array of branches.
        :param str full_name: The name of the repository.
        :param str url: The url to access the repository.
        """
        RepoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            branches=branches,
            full_name=full_name,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             branches: Optional[Sequence[str]] = None,
             full_name: Optional[str] = None,
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if full_name is None and 'fullName' in kwargs:
            full_name = kwargs['fullName']

        if branches is not None:
            _setter("branches", branches)
        if full_name is not None:
            _setter("full_name", full_name)
        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter
    def branches(self) -> Optional[Sequence[str]]:
        """
        Array of branches.
        """
        return pulumi.get(self, "branches")

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[str]:
        """
        The name of the repository.
        """
        return pulumi.get(self, "full_name")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The url to access the repository.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SecurityAlertTimelineItemResponse(dict):
    """
    Represents security alert timeline item.
    """
    def __init__(__self__, *,
                 alert_type: str,
                 azure_resource_id: str,
                 display_name: str,
                 end_time_utc: str,
                 intent: str,
                 kind: str,
                 severity: str,
                 start_time_utc: str,
                 time_generated: str,
                 description: Optional[str] = None,
                 product_name: Optional[str] = None,
                 techniques: Optional[Sequence[str]] = None):
        """
        Represents security alert timeline item.
        :param str alert_type: The name of the alert type.
        :param str azure_resource_id: The alert azure resource id.
        :param str display_name: The alert name.
        :param str end_time_utc: The alert end time.
        :param str intent: The intent of the alert.
        :param str kind: The entity query kind
               Expected value is 'SecurityAlert'.
        :param str severity: The alert severity.
        :param str start_time_utc: The alert start time.
        :param str time_generated: The alert generated time.
        :param str description: The alert description.
        :param str product_name: The alert product name.
        :param Sequence[str] techniques: The techniques of the alert.
        """
        SecurityAlertTimelineItemResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_type=alert_type,
            azure_resource_id=azure_resource_id,
            display_name=display_name,
            end_time_utc=end_time_utc,
            intent=intent,
            kind=kind,
            severity=severity,
            start_time_utc=start_time_utc,
            time_generated=time_generated,
            description=description,
            product_name=product_name,
            techniques=techniques,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_type: Optional[str] = None,
             azure_resource_id: Optional[str] = None,
             display_name: Optional[str] = None,
             end_time_utc: Optional[str] = None,
             intent: Optional[str] = None,
             kind: Optional[str] = None,
             severity: Optional[str] = None,
             start_time_utc: Optional[str] = None,
             time_generated: Optional[str] = None,
             description: Optional[str] = None,
             product_name: Optional[str] = None,
             techniques: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if alert_type is None and 'alertType' in kwargs:
            alert_type = kwargs['alertType']
        if alert_type is None:
            raise TypeError("Missing 'alert_type' argument")
        if azure_resource_id is None and 'azureResourceId' in kwargs:
            azure_resource_id = kwargs['azureResourceId']
        if azure_resource_id is None:
            raise TypeError("Missing 'azure_resource_id' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if end_time_utc is None and 'endTimeUtc' in kwargs:
            end_time_utc = kwargs['endTimeUtc']
        if end_time_utc is None:
            raise TypeError("Missing 'end_time_utc' argument")
        if intent is None:
            raise TypeError("Missing 'intent' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if severity is None:
            raise TypeError("Missing 'severity' argument")
        if start_time_utc is None and 'startTimeUtc' in kwargs:
            start_time_utc = kwargs['startTimeUtc']
        if start_time_utc is None:
            raise TypeError("Missing 'start_time_utc' argument")
        if time_generated is None and 'timeGenerated' in kwargs:
            time_generated = kwargs['timeGenerated']
        if time_generated is None:
            raise TypeError("Missing 'time_generated' argument")
        if product_name is None and 'productName' in kwargs:
            product_name = kwargs['productName']

        _setter("alert_type", alert_type)
        _setter("azure_resource_id", azure_resource_id)
        _setter("display_name", display_name)
        _setter("end_time_utc", end_time_utc)
        _setter("intent", intent)
        _setter("kind", 'SecurityAlert')
        _setter("severity", severity)
        _setter("start_time_utc", start_time_utc)
        _setter("time_generated", time_generated)
        if description is not None:
            _setter("description", description)
        if product_name is not None:
            _setter("product_name", product_name)
        if techniques is not None:
            _setter("techniques", techniques)

    @property
    @pulumi.getter(name="alertType")
    def alert_type(self) -> str:
        """
        The name of the alert type.
        """
        return pulumi.get(self, "alert_type")

    @property
    @pulumi.getter(name="azureResourceId")
    def azure_resource_id(self) -> str:
        """
        The alert azure resource id.
        """
        return pulumi.get(self, "azure_resource_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        The alert name.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="endTimeUtc")
    def end_time_utc(self) -> str:
        """
        The alert end time.
        """
        return pulumi.get(self, "end_time_utc")

    @property
    @pulumi.getter
    def intent(self) -> str:
        """
        The intent of the alert.
        """
        return pulumi.get(self, "intent")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The entity query kind
        Expected value is 'SecurityAlert'.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        The alert severity.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> str:
        """
        The alert start time.
        """
        return pulumi.get(self, "start_time_utc")

    @property
    @pulumi.getter(name="timeGenerated")
    def time_generated(self) -> str:
        """
        The alert generated time.
        """
        return pulumi.get(self, "time_generated")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The alert description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="productName")
    def product_name(self) -> Optional[str]:
        """
        The alert product name.
        """
        return pulumi.get(self, "product_name")

    @property
    @pulumi.getter
    def techniques(self) -> Optional[Sequence[str]]:
        """
        The techniques of the alert.
        """
        return pulumi.get(self, "techniques")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TeamInformationResponse(dict):
    """
    Describes team information
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryChannelUrl":
            suggest = "primary_channel_url"
        elif key == "teamCreationTimeUtc":
            suggest = "team_creation_time_utc"
        elif key == "teamId":
            suggest = "team_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TeamInformationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TeamInformationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TeamInformationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 name: str,
                 primary_channel_url: str,
                 team_creation_time_utc: str,
                 team_id: str):
        """
        Describes team information
        :param str description: The description of the team
        :param str name: The name of the team
        :param str primary_channel_url: The primary channel URL of the team
        :param str team_creation_time_utc: The time the team was created
        :param str team_id: Team ID
        """
        TeamInformationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            name=name,
            primary_channel_url=primary_channel_url,
            team_creation_time_utc=team_creation_time_utc,
            team_id=team_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             name: Optional[str] = None,
             primary_channel_url: Optional[str] = None,
             team_creation_time_utc: Optional[str] = None,
             team_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if description is None:
            raise TypeError("Missing 'description' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if primary_channel_url is None and 'primaryChannelUrl' in kwargs:
            primary_channel_url = kwargs['primaryChannelUrl']
        if primary_channel_url is None:
            raise TypeError("Missing 'primary_channel_url' argument")
        if team_creation_time_utc is None and 'teamCreationTimeUtc' in kwargs:
            team_creation_time_utc = kwargs['teamCreationTimeUtc']
        if team_creation_time_utc is None:
            raise TypeError("Missing 'team_creation_time_utc' argument")
        if team_id is None and 'teamId' in kwargs:
            team_id = kwargs['teamId']
        if team_id is None:
            raise TypeError("Missing 'team_id' argument")

        _setter("description", description)
        _setter("name", name)
        _setter("primary_channel_url", primary_channel_url)
        _setter("team_creation_time_utc", team_creation_time_utc)
        _setter("team_id", team_id)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the team
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the team
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryChannelUrl")
    def primary_channel_url(self) -> str:
        """
        The primary channel URL of the team
        """
        return pulumi.get(self, "primary_channel_url")

    @property
    @pulumi.getter(name="teamCreationTimeUtc")
    def team_creation_time_utc(self) -> str:
        """
        The time the team was created
        """
        return pulumi.get(self, "team_creation_time_utc")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        Team ID
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class TimelineAggregationResponse(dict):
    """
    timeline aggregation information per kind
    """
    def __init__(__self__, *,
                 count: int,
                 kind: str):
        """
        timeline aggregation information per kind
        :param int count: the total items found for a kind
        :param str kind: the query kind
        """
        TimelineAggregationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            kind=kind,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             kind: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if count is None:
            raise TypeError("Missing 'count' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")

        _setter("count", count)
        _setter("kind", kind)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        the total items found for a kind
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        the query kind
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class TimelineErrorResponse(dict):
    """
    Timeline Query Errors.
    """
    def __init__(__self__, *,
                 error_message: str,
                 kind: str,
                 query_id: Optional[str] = None):
        """
        Timeline Query Errors.
        :param str error_message: the error message
        :param str kind: the query kind
        :param str query_id: the query id
        """
        TimelineErrorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error_message=error_message,
            kind=kind,
            query_id=query_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error_message: Optional[str] = None,
             kind: Optional[str] = None,
             query_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error_message is None and 'errorMessage' in kwargs:
            error_message = kwargs['errorMessage']
        if error_message is None:
            raise TypeError("Missing 'error_message' argument")
        if kind is None:
            raise TypeError("Missing 'kind' argument")
        if query_id is None and 'queryId' in kwargs:
            query_id = kwargs['queryId']

        _setter("error_message", error_message)
        _setter("kind", kind)
        if query_id is not None:
            _setter("query_id", query_id)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        the error message
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        the query kind
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> Optional[str]:
        """
        the query id
        """
        return pulumi.get(self, "query_id")


@pulumi.output_type
class TimelineResultsMetadataResponse(dict):
    """
    Expansion result metadata.
    """
    def __init__(__self__, *,
                 aggregations: Sequence['outputs.TimelineAggregationResponse'],
                 total_count: int,
                 errors: Optional[Sequence['outputs.TimelineErrorResponse']] = None):
        """
        Expansion result metadata.
        :param Sequence['TimelineAggregationResponse'] aggregations: timeline aggregation per kind
        :param int total_count: the total items found for the timeline request
        :param Sequence['TimelineErrorResponse'] errors: information about the failure queries
        """
        TimelineResultsMetadataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregations=aggregations,
            total_count=total_count,
            errors=errors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregations: Optional[Sequence['outputs.TimelineAggregationResponse']] = None,
             total_count: Optional[int] = None,
             errors: Optional[Sequence['outputs.TimelineErrorResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aggregations is None:
            raise TypeError("Missing 'aggregations' argument")
        if total_count is None and 'totalCount' in kwargs:
            total_count = kwargs['totalCount']
        if total_count is None:
            raise TypeError("Missing 'total_count' argument")

        _setter("aggregations", aggregations)
        _setter("total_count", total_count)
        if errors is not None:
            _setter("errors", errors)

    @property
    @pulumi.getter
    def aggregations(self) -> Sequence['outputs.TimelineAggregationResponse']:
        """
        timeline aggregation per kind
        """
        return pulumi.get(self, "aggregations")

    @property
    @pulumi.getter(name="totalCount")
    def total_count(self) -> int:
        """
        the total items found for the timeline request
        """
        return pulumi.get(self, "total_count")

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.TimelineErrorResponse']]:
        """
        information about the failure queries
        """
        return pulumi.get(self, "errors")


@pulumi.output_type
class UserInfoResponse(dict):
    """
    User information that made some action
    """
    def __init__(__self__, *,
                 email: str,
                 name: str,
                 object_id: Optional[str] = None):
        """
        User information that made some action
        :param str email: The email of the user.
        :param str name: The name of the user.
        :param str object_id: The object id of the user.
        """
        UserInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email=email,
            name=name,
            object_id=object_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email: Optional[str] = None,
             name: Optional[str] = None,
             object_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if email is None:
            raise TypeError("Missing 'email' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if object_id is None and 'objectId' in kwargs:
            object_id = kwargs['objectId']

        _setter("email", email)
        _setter("name", name)
        if object_id is not None:
            _setter("object_id", object_id)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[str]:
        """
        The object id of the user.
        """
        return pulumi.get(self, "object_id")


