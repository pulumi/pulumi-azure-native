# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ActiveDirectoryConnectorDNSDetailsResponse',
    'ActiveDirectoryConnectorDomainDetailsResponse',
    'ActiveDirectoryConnectorPropertiesResponse',
    'ActiveDirectoryConnectorSpecResponse',
    'ActiveDirectoryConnectorStatusResponse',
    'ActiveDirectoryDomainControllerResponse',
    'ActiveDirectoryDomainControllersResponse',
    'AvailabilityGroupConfigureResponse',
    'AvailabilityGroupInfoResponse',
    'AvailabilityGroupStateResponse',
    'BackgroundJobResponse',
    'BackupPolicyResponse',
    'BasicLoginInformationResponse',
    'DataControllerPropertiesResponse',
    'ExtendedLocationResponse',
    'FailoverClusterResponse',
    'FailoverGroupPropertiesResponse',
    'FailoverGroupSpecResponse',
    'K8sActiveDirectoryResponse',
    'K8sActiveDirectoryResponseConnector',
    'K8sNetworkSettingsResponse',
    'K8sResourceRequirementsResponse',
    'K8sSchedulingOptionsResponse',
    'K8sSchedulingResponse',
    'K8sSecurityResponse',
    'K8sSettingsResponse',
    'K8stransparentDataEncryptionResponse',
    'LogAnalyticsWorkspaceConfigResponse',
    'MonitoringResponse',
    'OnPremisePropertyResponse',
    'PostgresInstancePropertiesResponse',
    'PostgresInstanceSkuResponse',
    'SequencerActionResponse',
    'SqlAvailabilityGroupDatabaseReplicaResourcePropertiesResponse',
    'SqlAvailabilityGroupReplicaResourcePropertiesResponse',
    'SqlManagedInstanceK8sRawResponse',
    'SqlManagedInstanceK8sSpecResponse',
    'SqlManagedInstancePropertiesResponse',
    'SqlManagedInstanceSkuResponse',
    'SqlServerAvailabilityGroupResourcePropertiesResponse',
    'SqlServerAvailabilityGroupResourcePropertiesResponseDatabases',
    'SqlServerAvailabilityGroupResourcePropertiesResponseReplicas',
    'SqlServerDatabaseResourcePropertiesResponse',
    'SqlServerDatabaseResourcePropertiesResponseBackupInformation',
    'SqlServerDatabaseResourcePropertiesResponseDatabaseOptions',
    'SqlServerEsuLicensePropertiesResponse',
    'SqlServerInstanceJobStatusResponse',
    'SqlServerInstancePropertiesResponse',
    'SqlServerInstanceTelemetryColumnResponse',
    'SqlServerLicensePropertiesResponse',
    'SystemDataResponse',
    'UploadServicePrincipalResponse',
    'UploadWatermarkResponse',
]

@pulumi.output_type
class ActiveDirectoryConnectorDNSDetailsResponse(dict):
    """
    DNS server details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameserverIPAddresses":
            suggest = "nameserver_ip_addresses"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "preferK8sDnsForPtrLookups":
            suggest = "prefer_k8s_dns_for_ptr_lookups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveDirectoryConnectorDNSDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveDirectoryConnectorDNSDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveDirectoryConnectorDNSDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nameserver_ip_addresses: Sequence[_builtins.str],
                 domain_name: Optional[_builtins.str] = None,
                 prefer_k8s_dns_for_ptr_lookups: Optional[_builtins.bool] = None,
                 replicas: Optional[_builtins.float] = None):
        """
        DNS server details
        :param Sequence[_builtins.str] nameserver_ip_addresses: List of Active Directory DNS server IP addresses.
        :param _builtins.str domain_name: DNS domain name for which DNS lookups should be forwarded to the Active Directory DNS servers.
        :param _builtins.bool prefer_k8s_dns_for_ptr_lookups: Flag indicating whether to prefer Kubernetes DNS server response over AD DNS server response for IP address lookups.
        :param _builtins.float replicas: Replica count for DNS proxy service. Default value is 1.
        """
        pulumi.set(__self__, "nameserver_ip_addresses", nameserver_ip_addresses)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if prefer_k8s_dns_for_ptr_lookups is None:
            prefer_k8s_dns_for_ptr_lookups = True
        if prefer_k8s_dns_for_ptr_lookups is not None:
            pulumi.set(__self__, "prefer_k8s_dns_for_ptr_lookups", prefer_k8s_dns_for_ptr_lookups)
        if replicas is None:
            replicas = 1
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @_builtins.property
    @pulumi.getter(name="nameserverIPAddresses")
    def nameserver_ip_addresses(self) -> Sequence[_builtins.str]:
        """
        List of Active Directory DNS server IP addresses.
        """
        return pulumi.get(self, "nameserver_ip_addresses")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[_builtins.str]:
        """
        DNS domain name for which DNS lookups should be forwarded to the Active Directory DNS servers.
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="preferK8sDnsForPtrLookups")
    def prefer_k8s_dns_for_ptr_lookups(self) -> Optional[_builtins.bool]:
        """
        Flag indicating whether to prefer Kubernetes DNS server response over AD DNS server response for IP address lookups.
        """
        return pulumi.get(self, "prefer_k8s_dns_for_ptr_lookups")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[_builtins.float]:
        """
        Replica count for DNS proxy service. Default value is 1.
        """
        return pulumi.get(self, "replicas")


@pulumi.output_type
class ActiveDirectoryConnectorDomainDetailsResponse(dict):
    """
    Active Directory domain details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainControllers":
            suggest = "domain_controllers"
        elif key == "netbiosDomainName":
            suggest = "netbios_domain_name"
        elif key == "ouDistinguishedName":
            suggest = "ou_distinguished_name"
        elif key == "serviceAccountProvisioning":
            suggest = "service_account_provisioning"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveDirectoryConnectorDomainDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveDirectoryConnectorDomainDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveDirectoryConnectorDomainDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 realm: _builtins.str,
                 domain_controllers: Optional['outputs.ActiveDirectoryDomainControllersResponse'] = None,
                 netbios_domain_name: Optional[_builtins.str] = None,
                 ou_distinguished_name: Optional[_builtins.str] = None,
                 service_account_provisioning: Optional[_builtins.str] = None):
        """
        Active Directory domain details
        :param _builtins.str realm: Name (uppercase) of the Active Directory domain that this AD connector will be associated with.
        :param 'ActiveDirectoryDomainControllersResponse' domain_controllers: null
        :param _builtins.str netbios_domain_name: NETBIOS name of the Active Directory domain.
        :param _builtins.str ou_distinguished_name: The distinguished name of the Active Directory Organizational Unit.
        :param _builtins.str service_account_provisioning: The service account provisioning mode for this Active Directory connector.
        """
        pulumi.set(__self__, "realm", realm)
        if domain_controllers is not None:
            pulumi.set(__self__, "domain_controllers", domain_controllers)
        if netbios_domain_name is not None:
            pulumi.set(__self__, "netbios_domain_name", netbios_domain_name)
        if ou_distinguished_name is not None:
            pulumi.set(__self__, "ou_distinguished_name", ou_distinguished_name)
        if service_account_provisioning is None:
            service_account_provisioning = 'manual'
        if service_account_provisioning is not None:
            pulumi.set(__self__, "service_account_provisioning", service_account_provisioning)

    @_builtins.property
    @pulumi.getter
    def realm(self) -> _builtins.str:
        """
        Name (uppercase) of the Active Directory domain that this AD connector will be associated with.
        """
        return pulumi.get(self, "realm")

    @_builtins.property
    @pulumi.getter(name="domainControllers")
    def domain_controllers(self) -> Optional['outputs.ActiveDirectoryDomainControllersResponse']:
        """
        null
        """
        return pulumi.get(self, "domain_controllers")

    @_builtins.property
    @pulumi.getter(name="netbiosDomainName")
    def netbios_domain_name(self) -> Optional[_builtins.str]:
        """
        NETBIOS name of the Active Directory domain.
        """
        return pulumi.get(self, "netbios_domain_name")

    @_builtins.property
    @pulumi.getter(name="ouDistinguishedName")
    def ou_distinguished_name(self) -> Optional[_builtins.str]:
        """
        The distinguished name of the Active Directory Organizational Unit.
        """
        return pulumi.get(self, "ou_distinguished_name")

    @_builtins.property
    @pulumi.getter(name="serviceAccountProvisioning")
    def service_account_provisioning(self) -> Optional[_builtins.str]:
        """
        The service account provisioning mode for this Active Directory connector.
        """
        return pulumi.get(self, "service_account_provisioning")


@pulumi.output_type
class ActiveDirectoryConnectorPropertiesResponse(dict):
    """
    The properties of an Active Directory connector resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "domainServiceAccountLoginInformation":
            suggest = "domain_service_account_login_information"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveDirectoryConnectorPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveDirectoryConnectorPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveDirectoryConnectorPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: _builtins.str,
                 spec: 'outputs.ActiveDirectoryConnectorSpecResponse',
                 domain_service_account_login_information: Optional['outputs.BasicLoginInformationResponse'] = None,
                 status: Optional['outputs.ActiveDirectoryConnectorStatusResponse'] = None):
        """
        The properties of an Active Directory connector resource
        :param _builtins.str provisioning_state: The provisioning state of the Active Directory connector resource.
        :param 'ActiveDirectoryConnectorSpecResponse' spec: null
        :param 'BasicLoginInformationResponse' domain_service_account_login_information: Username and password for domain service account authentication.
        :param 'ActiveDirectoryConnectorStatusResponse' status: null
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "spec", spec)
        if domain_service_account_login_information is not None:
            pulumi.set(__self__, "domain_service_account_login_information", domain_service_account_login_information)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the Active Directory connector resource.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> 'outputs.ActiveDirectoryConnectorSpecResponse':
        """
        null
        """
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter(name="domainServiceAccountLoginInformation")
    def domain_service_account_login_information(self) -> Optional['outputs.BasicLoginInformationResponse']:
        """
        Username and password for domain service account authentication.
        """
        return pulumi.get(self, "domain_service_account_login_information")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['outputs.ActiveDirectoryConnectorStatusResponse']:
        """
        null
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ActiveDirectoryConnectorSpecResponse(dict):
    """
    The specifications of the AD Kubernetes resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveDirectoryConnectorSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveDirectoryConnectorSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveDirectoryConnectorSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_directory: 'outputs.ActiveDirectoryConnectorDomainDetailsResponse',
                 dns: 'outputs.ActiveDirectoryConnectorDNSDetailsResponse'):
        """
        The specifications of the AD Kubernetes resource.
        :param 'ActiveDirectoryConnectorDomainDetailsResponse' active_directory: null
        :param 'ActiveDirectoryConnectorDNSDetailsResponse' dns: null
        """
        pulumi.set(__self__, "active_directory", active_directory)
        pulumi.set(__self__, "dns", dns)

    @_builtins.property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> 'outputs.ActiveDirectoryConnectorDomainDetailsResponse':
        """
        null
        """
        return pulumi.get(self, "active_directory")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> 'outputs.ActiveDirectoryConnectorDNSDetailsResponse':
        """
        null
        """
        return pulumi.get(self, "dns")


@pulumi.output_type
class ActiveDirectoryConnectorStatusResponse(dict):
    """
    The status of the Kubernetes custom resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastUpdateTime":
            suggest = "last_update_time"
        elif key == "observedGeneration":
            suggest = "observed_generation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveDirectoryConnectorStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveDirectoryConnectorStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveDirectoryConnectorStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_update_time: Optional[_builtins.str] = None,
                 observed_generation: Optional[_builtins.float] = None,
                 state: Optional[_builtins.str] = None):
        """
        The status of the Kubernetes custom resource.
        :param _builtins.str last_update_time: The time that the custom resource was last updated.
        :param _builtins.float observed_generation: The version of the replicaSet associated with the AD connector custom resource.
        :param _builtins.str state: The state of the AD connector custom resource.
        """
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[_builtins.str]:
        """
        The time that the custom resource was last updated.
        """
        return pulumi.get(self, "last_update_time")

    @_builtins.property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[_builtins.float]:
        """
        The version of the replicaSet associated with the AD connector custom resource.
        """
        return pulumi.get(self, "observed_generation")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The state of the AD connector custom resource.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ActiveDirectoryDomainControllerResponse(dict):
    """
    Information about a domain controller in the AD domain.
    """
    def __init__(__self__, *,
                 hostname: _builtins.str):
        """
        Information about a domain controller in the AD domain.
        :param _builtins.str hostname: Fully-qualified domain name of a domain controller in the AD domain.
        """
        pulumi.set(__self__, "hostname", hostname)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Fully-qualified domain name of a domain controller in the AD domain.
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class ActiveDirectoryDomainControllersResponse(dict):
    """
    Details about the Active Directory domain controllers associated with this AD connector instance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryDomainController":
            suggest = "primary_domain_controller"
        elif key == "secondaryDomainControllers":
            suggest = "secondary_domain_controllers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveDirectoryDomainControllersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveDirectoryDomainControllersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveDirectoryDomainControllersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_domain_controller: Optional['outputs.ActiveDirectoryDomainControllerResponse'] = None,
                 secondary_domain_controllers: Optional[Sequence['outputs.ActiveDirectoryDomainControllerResponse']] = None):
        """
        Details about the Active Directory domain controllers associated with this AD connector instance
        :param 'ActiveDirectoryDomainControllerResponse' primary_domain_controller: Information about the Primary Domain Controller (PDC) in the AD domain.
        :param Sequence['ActiveDirectoryDomainControllerResponse'] secondary_domain_controllers: null
        """
        if primary_domain_controller is not None:
            pulumi.set(__self__, "primary_domain_controller", primary_domain_controller)
        if secondary_domain_controllers is not None:
            pulumi.set(__self__, "secondary_domain_controllers", secondary_domain_controllers)

    @_builtins.property
    @pulumi.getter(name="primaryDomainController")
    def primary_domain_controller(self) -> Optional['outputs.ActiveDirectoryDomainControllerResponse']:
        """
        Information about the Primary Domain Controller (PDC) in the AD domain.
        """
        return pulumi.get(self, "primary_domain_controller")

    @_builtins.property
    @pulumi.getter(name="secondaryDomainControllers")
    def secondary_domain_controllers(self) -> Optional[Sequence['outputs.ActiveDirectoryDomainControllerResponse']]:
        """
        null
        """
        return pulumi.get(self, "secondary_domain_controllers")


@pulumi.output_type
class AvailabilityGroupConfigureResponse(dict):
    """
    The specifications of the availability group replica configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityModeDescription":
            suggest = "availability_mode_description"
        elif key == "failoverModeDescription":
            suggest = "failover_mode_description"
        elif key == "primaryRoleAllowConnectionsDescription":
            suggest = "primary_role_allow_connections_description"
        elif key == "replicaCreateDate":
            suggest = "replica_create_date"
        elif key == "replicaModifyDate":
            suggest = "replica_modify_date"
        elif key == "secondaryRoleAllowConnectionsDescription":
            suggest = "secondary_role_allow_connections_description"
        elif key == "seedingModeDescription":
            suggest = "seeding_mode_description"
        elif key == "backupPriority":
            suggest = "backup_priority"
        elif key == "endpointUrl":
            suggest = "endpoint_url"
        elif key == "readOnlyRoutingUrl":
            suggest = "read_only_routing_url"
        elif key == "readWriteRoutingUrl":
            suggest = "read_write_routing_url"
        elif key == "sessionTimeout":
            suggest = "session_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AvailabilityGroupConfigureResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AvailabilityGroupConfigureResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AvailabilityGroupConfigureResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_mode_description: _builtins.str,
                 failover_mode_description: _builtins.str,
                 primary_role_allow_connections_description: _builtins.str,
                 replica_create_date: _builtins.str,
                 replica_modify_date: _builtins.str,
                 secondary_role_allow_connections_description: _builtins.str,
                 seeding_mode_description: _builtins.str,
                 backup_priority: Optional[_builtins.int] = None,
                 endpoint_url: Optional[_builtins.str] = None,
                 read_only_routing_url: Optional[_builtins.str] = None,
                 read_write_routing_url: Optional[_builtins.str] = None,
                 session_timeout: Optional[_builtins.int] = None):
        """
        The specifications of the availability group replica configuration
        :param _builtins.str availability_mode_description: The Availability Synchronization mode of the availability group replica.
        :param _builtins.str failover_mode_description: The failover mode of the availability group replica.
        :param _builtins.str primary_role_allow_connections_description: Whether the availability allows all connections or only read-write connections.
        :param _builtins.str replica_create_date: Date that the replica was created.
        :param _builtins.str replica_modify_date: Date that the replica was modified.
        :param _builtins.str secondary_role_allow_connections_description: Whether an availability replica that is performing the secondary role (that is, a secondary replica) can accept connections from clients.
        :param _builtins.str seeding_mode_description: Describes seeding mode.
        :param _builtins.int backup_priority: Represents the user-specified priority for performing backups on this replica relative to the other replicas in the same availability group.
        :param _builtins.str endpoint_url: Mirroring endpoint URL of availability group replica
        :param _builtins.str read_only_routing_url: Connectivity endpoint (URL) of the read only availability replica.
        :param _builtins.str read_write_routing_url: Connectivity endpoint (URL) of the read write availability replica.
        :param _builtins.int session_timeout: The time-out period of availability group session replica, in seconds.
        """
        pulumi.set(__self__, "availability_mode_description", availability_mode_description)
        pulumi.set(__self__, "failover_mode_description", failover_mode_description)
        pulumi.set(__self__, "primary_role_allow_connections_description", primary_role_allow_connections_description)
        pulumi.set(__self__, "replica_create_date", replica_create_date)
        pulumi.set(__self__, "replica_modify_date", replica_modify_date)
        pulumi.set(__self__, "secondary_role_allow_connections_description", secondary_role_allow_connections_description)
        pulumi.set(__self__, "seeding_mode_description", seeding_mode_description)
        if backup_priority is not None:
            pulumi.set(__self__, "backup_priority", backup_priority)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if read_only_routing_url is not None:
            pulumi.set(__self__, "read_only_routing_url", read_only_routing_url)
        if read_write_routing_url is not None:
            pulumi.set(__self__, "read_write_routing_url", read_write_routing_url)
        if session_timeout is not None:
            pulumi.set(__self__, "session_timeout", session_timeout)

    @_builtins.property
    @pulumi.getter(name="availabilityModeDescription")
    def availability_mode_description(self) -> _builtins.str:
        """
        The Availability Synchronization mode of the availability group replica.
        """
        return pulumi.get(self, "availability_mode_description")

    @_builtins.property
    @pulumi.getter(name="failoverModeDescription")
    def failover_mode_description(self) -> _builtins.str:
        """
        The failover mode of the availability group replica.
        """
        return pulumi.get(self, "failover_mode_description")

    @_builtins.property
    @pulumi.getter(name="primaryRoleAllowConnectionsDescription")
    def primary_role_allow_connections_description(self) -> _builtins.str:
        """
        Whether the availability allows all connections or only read-write connections.
        """
        return pulumi.get(self, "primary_role_allow_connections_description")

    @_builtins.property
    @pulumi.getter(name="replicaCreateDate")
    def replica_create_date(self) -> _builtins.str:
        """
        Date that the replica was created.
        """
        return pulumi.get(self, "replica_create_date")

    @_builtins.property
    @pulumi.getter(name="replicaModifyDate")
    def replica_modify_date(self) -> _builtins.str:
        """
        Date that the replica was modified.
        """
        return pulumi.get(self, "replica_modify_date")

    @_builtins.property
    @pulumi.getter(name="secondaryRoleAllowConnectionsDescription")
    def secondary_role_allow_connections_description(self) -> _builtins.str:
        """
        Whether an availability replica that is performing the secondary role (that is, a secondary replica) can accept connections from clients.
        """
        return pulumi.get(self, "secondary_role_allow_connections_description")

    @_builtins.property
    @pulumi.getter(name="seedingModeDescription")
    def seeding_mode_description(self) -> _builtins.str:
        """
        Describes seeding mode.
        """
        return pulumi.get(self, "seeding_mode_description")

    @_builtins.property
    @pulumi.getter(name="backupPriority")
    def backup_priority(self) -> Optional[_builtins.int]:
        """
        Represents the user-specified priority for performing backups on this replica relative to the other replicas in the same availability group.
        """
        return pulumi.get(self, "backup_priority")

    @_builtins.property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[_builtins.str]:
        """
        Mirroring endpoint URL of availability group replica
        """
        return pulumi.get(self, "endpoint_url")

    @_builtins.property
    @pulumi.getter(name="readOnlyRoutingUrl")
    def read_only_routing_url(self) -> Optional[_builtins.str]:
        """
        Connectivity endpoint (URL) of the read only availability replica.
        """
        return pulumi.get(self, "read_only_routing_url")

    @_builtins.property
    @pulumi.getter(name="readWriteRoutingUrl")
    def read_write_routing_url(self) -> Optional[_builtins.str]:
        """
        Connectivity endpoint (URL) of the read write availability replica.
        """
        return pulumi.get(self, "read_write_routing_url")

    @_builtins.property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[_builtins.int]:
        """
        The time-out period of availability group session replica, in seconds.
        """
        return pulumi.get(self, "session_timeout")


@pulumi.output_type
class AvailabilityGroupInfoResponse(dict):
    """
    The specifications of the availability group state
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automatedBackupPreferenceDescription":
            suggest = "automated_backup_preference_description"
        elif key == "clusterTypeDescription":
            suggest = "cluster_type_description"
        elif key == "primaryRecoveryHealthDescription":
            suggest = "primary_recovery_health_description"
        elif key == "primaryReplica":
            suggest = "primary_replica"
        elif key == "replicationPartnerType":
            suggest = "replication_partner_type"
        elif key == "secondaryRecoveryHealthDescription":
            suggest = "secondary_recovery_health_description"
        elif key == "synchronizationHealthDescription":
            suggest = "synchronization_health_description"
        elif key == "basicFeatures":
            suggest = "basic_features"
        elif key == "dbFailover":
            suggest = "db_failover"
        elif key == "dtcSupport":
            suggest = "dtc_support"
        elif key == "failureConditionLevel":
            suggest = "failure_condition_level"
        elif key == "healthCheckTimeout":
            suggest = "health_check_timeout"
        elif key == "isContained":
            suggest = "is_contained"
        elif key == "isDistributed":
            suggest = "is_distributed"
        elif key == "requiredSynchronizedSecondariesToCommit":
            suggest = "required_synchronized_secondaries_to_commit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AvailabilityGroupInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AvailabilityGroupInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AvailabilityGroupInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automated_backup_preference_description: _builtins.str,
                 cluster_type_description: _builtins.str,
                 primary_recovery_health_description: _builtins.str,
                 primary_replica: _builtins.str,
                 replication_partner_type: _builtins.str,
                 secondary_recovery_health_description: _builtins.str,
                 synchronization_health_description: _builtins.str,
                 version: _builtins.int,
                 basic_features: Optional[_builtins.bool] = None,
                 db_failover: Optional[_builtins.bool] = None,
                 dtc_support: Optional[_builtins.bool] = None,
                 failure_condition_level: Optional[_builtins.int] = None,
                 health_check_timeout: Optional[_builtins.int] = None,
                 is_contained: Optional[_builtins.bool] = None,
                 is_distributed: Optional[_builtins.bool] = None,
                 required_synchronized_secondaries_to_commit: Optional[_builtins.int] = None):
        """
        The specifications of the availability group state
        :param _builtins.str automated_backup_preference_description: Preferred location for performing backups on the availability databases in this availability group.
        :param _builtins.str cluster_type_description: SQL Server availability group cluster type description
        :param _builtins.str primary_recovery_health_description: Indicates the recovery health of the primary replica.
        :param _builtins.str primary_replica: Name of the server instance that is hosting the current primary replica.
        :param _builtins.str secondary_recovery_health_description: Indicates the recovery health of a secondary replica.
        :param _builtins.str synchronization_health_description: Reflects a roll-up of the synchronization health of all availability replicas in the availability group.
        :param _builtins.int version: SQL Server availability group current version.
        :param _builtins.bool basic_features: Specifies whether this is a basic availability group.
        :param _builtins.bool db_failover: Specifies whether the availability group supports failover for database health conditions.
        :param _builtins.bool dtc_support: Specifies whether DTC support has been enabled for this availability group.
        :param _builtins.int failure_condition_level: User-defined failure condition level under which an automatic failover must be triggered.
        :param _builtins.int health_check_timeout: Wait time (in milliseconds) for the sp_server_diagnostics system stored procedure to return server-health information, before the server instance is assumed to be slow or not responding.
        :param _builtins.bool is_contained: SQL Server availability group contained system databases.
        :param _builtins.bool is_distributed: Specifies whether this is a distributed availability group.
        :param _builtins.int required_synchronized_secondaries_to_commit: The number of secondary replicas that must be in a synchronized state for a commit to complete.
        """
        pulumi.set(__self__, "automated_backup_preference_description", automated_backup_preference_description)
        pulumi.set(__self__, "cluster_type_description", cluster_type_description)
        pulumi.set(__self__, "primary_recovery_health_description", primary_recovery_health_description)
        pulumi.set(__self__, "primary_replica", primary_replica)
        pulumi.set(__self__, "replication_partner_type", replication_partner_type)
        pulumi.set(__self__, "secondary_recovery_health_description", secondary_recovery_health_description)
        pulumi.set(__self__, "synchronization_health_description", synchronization_health_description)
        pulumi.set(__self__, "version", version)
        if basic_features is not None:
            pulumi.set(__self__, "basic_features", basic_features)
        if db_failover is not None:
            pulumi.set(__self__, "db_failover", db_failover)
        if dtc_support is not None:
            pulumi.set(__self__, "dtc_support", dtc_support)
        if failure_condition_level is not None:
            pulumi.set(__self__, "failure_condition_level", failure_condition_level)
        if health_check_timeout is not None:
            pulumi.set(__self__, "health_check_timeout", health_check_timeout)
        if is_contained is not None:
            pulumi.set(__self__, "is_contained", is_contained)
        if is_distributed is not None:
            pulumi.set(__self__, "is_distributed", is_distributed)
        if required_synchronized_secondaries_to_commit is not None:
            pulumi.set(__self__, "required_synchronized_secondaries_to_commit", required_synchronized_secondaries_to_commit)

    @_builtins.property
    @pulumi.getter(name="automatedBackupPreferenceDescription")
    def automated_backup_preference_description(self) -> _builtins.str:
        """
        Preferred location for performing backups on the availability databases in this availability group.
        """
        return pulumi.get(self, "automated_backup_preference_description")

    @_builtins.property
    @pulumi.getter(name="clusterTypeDescription")
    def cluster_type_description(self) -> _builtins.str:
        """
        SQL Server availability group cluster type description
        """
        return pulumi.get(self, "cluster_type_description")

    @_builtins.property
    @pulumi.getter(name="primaryRecoveryHealthDescription")
    def primary_recovery_health_description(self) -> _builtins.str:
        """
        Indicates the recovery health of the primary replica.
        """
        return pulumi.get(self, "primary_recovery_health_description")

    @_builtins.property
    @pulumi.getter(name="primaryReplica")
    def primary_replica(self) -> _builtins.str:
        """
        Name of the server instance that is hosting the current primary replica.
        """
        return pulumi.get(self, "primary_replica")

    @_builtins.property
    @pulumi.getter(name="replicationPartnerType")
    def replication_partner_type(self) -> _builtins.str:
        return pulumi.get(self, "replication_partner_type")

    @_builtins.property
    @pulumi.getter(name="secondaryRecoveryHealthDescription")
    def secondary_recovery_health_description(self) -> _builtins.str:
        """
        Indicates the recovery health of a secondary replica.
        """
        return pulumi.get(self, "secondary_recovery_health_description")

    @_builtins.property
    @pulumi.getter(name="synchronizationHealthDescription")
    def synchronization_health_description(self) -> _builtins.str:
        """
        Reflects a roll-up of the synchronization health of all availability replicas in the availability group.
        """
        return pulumi.get(self, "synchronization_health_description")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        SQL Server availability group current version.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="basicFeatures")
    def basic_features(self) -> Optional[_builtins.bool]:
        """
        Specifies whether this is a basic availability group.
        """
        return pulumi.get(self, "basic_features")

    @_builtins.property
    @pulumi.getter(name="dbFailover")
    def db_failover(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the availability group supports failover for database health conditions.
        """
        return pulumi.get(self, "db_failover")

    @_builtins.property
    @pulumi.getter(name="dtcSupport")
    def dtc_support(self) -> Optional[_builtins.bool]:
        """
        Specifies whether DTC support has been enabled for this availability group.
        """
        return pulumi.get(self, "dtc_support")

    @_builtins.property
    @pulumi.getter(name="failureConditionLevel")
    def failure_condition_level(self) -> Optional[_builtins.int]:
        """
        User-defined failure condition level under which an automatic failover must be triggered.
        """
        return pulumi.get(self, "failure_condition_level")

    @_builtins.property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> Optional[_builtins.int]:
        """
        Wait time (in milliseconds) for the sp_server_diagnostics system stored procedure to return server-health information, before the server instance is assumed to be slow or not responding.
        """
        return pulumi.get(self, "health_check_timeout")

    @_builtins.property
    @pulumi.getter(name="isContained")
    def is_contained(self) -> Optional[_builtins.bool]:
        """
        SQL Server availability group contained system databases.
        """
        return pulumi.get(self, "is_contained")

    @_builtins.property
    @pulumi.getter(name="isDistributed")
    def is_distributed(self) -> Optional[_builtins.bool]:
        """
        Specifies whether this is a distributed availability group.
        """
        return pulumi.get(self, "is_distributed")

    @_builtins.property
    @pulumi.getter(name="requiredSynchronizedSecondariesToCommit")
    def required_synchronized_secondaries_to_commit(self) -> Optional[_builtins.int]:
        """
        The number of secondary replicas that must be in a synchronized state for a commit to complete.
        """
        return pulumi.get(self, "required_synchronized_secondaries_to_commit")


@pulumi.output_type
class AvailabilityGroupStateResponse(dict):
    """
    The specifications of the availability group state
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityGroupReplicaRole":
            suggest = "availability_group_replica_role"
        elif key == "connectedStateDescription":
            suggest = "connected_state_description"
        elif key == "lastConnectErrorDescription":
            suggest = "last_connect_error_description"
        elif key == "lastConnectErrorTimestamp":
            suggest = "last_connect_error_timestamp"
        elif key == "operationalStateDescription":
            suggest = "operational_state_description"
        elif key == "recoveryHealthDescription":
            suggest = "recovery_health_description"
        elif key == "synchronizationHealthDescription":
            suggest = "synchronization_health_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AvailabilityGroupStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AvailabilityGroupStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AvailabilityGroupStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_group_replica_role: _builtins.str,
                 connected_state_description: _builtins.str,
                 last_connect_error_description: _builtins.str,
                 last_connect_error_timestamp: _builtins.str,
                 operational_state_description: _builtins.str,
                 recovery_health_description: _builtins.str,
                 synchronization_health_description: _builtins.str):
        """
        The specifications of the availability group state
        :param _builtins.str availability_group_replica_role: Current Always On availability groups role of the availability group replica.
        :param _builtins.str connected_state_description: Whether a secondary replica is currently connected to the primary replica.
        :param _builtins.str last_connect_error_description: Text description of the last connection error of the availability group replica.
        :param _builtins.str last_connect_error_timestamp: Date and time timestamp indicating when the last connect error occurred.
        :param _builtins.str operational_state_description: Current operational state of the availability group replica
        :param _builtins.str recovery_health_description: Recovery health of the availability group replica.
        :param _builtins.str synchronization_health_description: Reflects a rollup of the database synchronization state (synchronization_state) of all joined availability databases (also known as replicas) and the availability mode of the replica (synchronous-commit or asynchronous-commit mode). The rollup will reflect the least healthy accumulated state the databases on the replica.
        """
        pulumi.set(__self__, "availability_group_replica_role", availability_group_replica_role)
        pulumi.set(__self__, "connected_state_description", connected_state_description)
        pulumi.set(__self__, "last_connect_error_description", last_connect_error_description)
        pulumi.set(__self__, "last_connect_error_timestamp", last_connect_error_timestamp)
        pulumi.set(__self__, "operational_state_description", operational_state_description)
        pulumi.set(__self__, "recovery_health_description", recovery_health_description)
        pulumi.set(__self__, "synchronization_health_description", synchronization_health_description)

    @_builtins.property
    @pulumi.getter(name="availabilityGroupReplicaRole")
    def availability_group_replica_role(self) -> _builtins.str:
        """
        Current Always On availability groups role of the availability group replica.
        """
        return pulumi.get(self, "availability_group_replica_role")

    @_builtins.property
    @pulumi.getter(name="connectedStateDescription")
    def connected_state_description(self) -> _builtins.str:
        """
        Whether a secondary replica is currently connected to the primary replica.
        """
        return pulumi.get(self, "connected_state_description")

    @_builtins.property
    @pulumi.getter(name="lastConnectErrorDescription")
    def last_connect_error_description(self) -> _builtins.str:
        """
        Text description of the last connection error of the availability group replica.
        """
        return pulumi.get(self, "last_connect_error_description")

    @_builtins.property
    @pulumi.getter(name="lastConnectErrorTimestamp")
    def last_connect_error_timestamp(self) -> _builtins.str:
        """
        Date and time timestamp indicating when the last connect error occurred.
        """
        return pulumi.get(self, "last_connect_error_timestamp")

    @_builtins.property
    @pulumi.getter(name="operationalStateDescription")
    def operational_state_description(self) -> _builtins.str:
        """
        Current operational state of the availability group replica
        """
        return pulumi.get(self, "operational_state_description")

    @_builtins.property
    @pulumi.getter(name="recoveryHealthDescription")
    def recovery_health_description(self) -> _builtins.str:
        """
        Recovery health of the availability group replica.
        """
        return pulumi.get(self, "recovery_health_description")

    @_builtins.property
    @pulumi.getter(name="synchronizationHealthDescription")
    def synchronization_health_description(self) -> _builtins.str:
        """
        Reflects a rollup of the database synchronization state (synchronization_state) of all joined availability databases (also known as replicas) and the availability mode of the replica (synchronous-commit or asynchronous-commit mode). The rollup will reflect the least healthy accumulated state the databases on the replica.
        """
        return pulumi.get(self, "synchronization_health_description")


@pulumi.output_type
class BackgroundJobResponse(dict):
    """
    The background job details.
    """
    def __init__(__self__, *,
                 end_time: Optional[_builtins.str] = None,
                 execution_state: Optional[_builtins.str] = None,
                 last_execution_status: Optional[_builtins.str] = None,
                 last_execution_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        The background job details.
        :param _builtins.str end_time: The end time of the background job.
        :param _builtins.str execution_state: The execution state of the background job.
        :param _builtins.str last_execution_status: The last execution status of the background job.
        :param _builtins.str last_execution_time: The last execution time of the background job.
        :param _builtins.str start_time: The start time of the background job.
        :param _builtins.str state: The state of the background job.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if execution_state is not None:
            pulumi.set(__self__, "execution_state", execution_state)
        if last_execution_status is not None:
            pulumi.set(__self__, "last_execution_status", last_execution_status)
        if last_execution_time is not None:
            pulumi.set(__self__, "last_execution_time", last_execution_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        The end time of the background job.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="executionState")
    def execution_state(self) -> Optional[_builtins.str]:
        """
        The execution state of the background job.
        """
        return pulumi.get(self, "execution_state")

    @_builtins.property
    @pulumi.getter(name="lastExecutionStatus")
    def last_execution_status(self) -> Optional[_builtins.str]:
        """
        The last execution status of the background job.
        """
        return pulumi.get(self, "last_execution_status")

    @_builtins.property
    @pulumi.getter(name="lastExecutionTime")
    def last_execution_time(self) -> Optional[_builtins.str]:
        """
        The last execution time of the background job.
        """
        return pulumi.get(self, "last_execution_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        The start time of the background job.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The state of the background job.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class BackupPolicyResponse(dict):
    """
    The backup profile for the SQL server.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "differentialBackupHours":
            suggest = "differential_backup_hours"
        elif key == "fullBackupDays":
            suggest = "full_backup_days"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"
        elif key == "transactionLogBackupMinutes":
            suggest = "transaction_log_backup_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 differential_backup_hours: Optional[_builtins.int] = None,
                 full_backup_days: Optional[_builtins.int] = None,
                 retention_period_days: Optional[_builtins.int] = None,
                 transaction_log_backup_minutes: Optional[_builtins.int] = None):
        """
        The backup profile for the SQL server.
        :param _builtins.int differential_backup_hours: The differential backup interval in hours.
        :param _builtins.int full_backup_days: The value indicating days between full backups.
        :param _builtins.int retention_period_days: The retention period for all the databases in this managed instance.
        :param _builtins.int transaction_log_backup_minutes: The value indicating minutes between transaction log backups.
        """
        if differential_backup_hours is not None:
            pulumi.set(__self__, "differential_backup_hours", differential_backup_hours)
        if full_backup_days is not None:
            pulumi.set(__self__, "full_backup_days", full_backup_days)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if transaction_log_backup_minutes is not None:
            pulumi.set(__self__, "transaction_log_backup_minutes", transaction_log_backup_minutes)

    @_builtins.property
    @pulumi.getter(name="differentialBackupHours")
    def differential_backup_hours(self) -> Optional[_builtins.int]:
        """
        The differential backup interval in hours.
        """
        return pulumi.get(self, "differential_backup_hours")

    @_builtins.property
    @pulumi.getter(name="fullBackupDays")
    def full_backup_days(self) -> Optional[_builtins.int]:
        """
        The value indicating days between full backups.
        """
        return pulumi.get(self, "full_backup_days")

    @_builtins.property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[_builtins.int]:
        """
        The retention period for all the databases in this managed instance.
        """
        return pulumi.get(self, "retention_period_days")

    @_builtins.property
    @pulumi.getter(name="transactionLogBackupMinutes")
    def transaction_log_backup_minutes(self) -> Optional[_builtins.int]:
        """
        The value indicating minutes between transaction log backups.
        """
        return pulumi.get(self, "transaction_log_backup_minutes")


@pulumi.output_type
class BasicLoginInformationResponse(dict):
    """
    Username and password for basic login authentication.
    """
    def __init__(__self__, *,
                 username: Optional[_builtins.str] = None):
        """
        Username and password for basic login authentication.
        :param _builtins.str username: Login username.
        """
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Login username.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DataControllerPropertiesResponse(dict):
    """
    The data controller properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "basicLoginInformation":
            suggest = "basic_login_information"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "extensionId":
            suggest = "extension_id"
        elif key == "k8sRaw":
            suggest = "k8s_raw"
        elif key == "lastUploadedDate":
            suggest = "last_uploaded_date"
        elif key == "logAnalyticsWorkspaceConfig":
            suggest = "log_analytics_workspace_config"
        elif key == "logsDashboardCredential":
            suggest = "logs_dashboard_credential"
        elif key == "metricsDashboardCredential":
            suggest = "metrics_dashboard_credential"
        elif key == "onPremiseProperty":
            suggest = "on_premise_property"
        elif key == "uploadServicePrincipal":
            suggest = "upload_service_principal"
        elif key == "uploadWatermark":
            suggest = "upload_watermark"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataControllerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataControllerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataControllerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: _builtins.str,
                 basic_login_information: Optional['outputs.BasicLoginInformationResponse'] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 extension_id: Optional[_builtins.str] = None,
                 infrastructure: Optional[_builtins.str] = None,
                 k8s_raw: Optional[Any] = None,
                 last_uploaded_date: Optional[_builtins.str] = None,
                 log_analytics_workspace_config: Optional['outputs.LogAnalyticsWorkspaceConfigResponse'] = None,
                 logs_dashboard_credential: Optional['outputs.BasicLoginInformationResponse'] = None,
                 metrics_dashboard_credential: Optional['outputs.BasicLoginInformationResponse'] = None,
                 on_premise_property: Optional['outputs.OnPremisePropertyResponse'] = None,
                 upload_service_principal: Optional['outputs.UploadServicePrincipalResponse'] = None,
                 upload_watermark: Optional['outputs.UploadWatermarkResponse'] = None):
        """
        The data controller properties.
        :param _builtins.str provisioning_state: The provisioning state of the Arc Data Controller resource.
        :param 'BasicLoginInformationResponse' basic_login_information: Deprecated. Azure Arc Data Services data controller no longer expose any endpoint. All traffic are exposed through Kubernetes native API.
        :param _builtins.str cluster_id: If a CustomLocation is provided, this contains the ARM id of the connected cluster the custom location belongs to.
        :param _builtins.str extension_id: If a CustomLocation is provided, this contains the ARM id of the extension the custom location belongs to.
        :param _builtins.str infrastructure: The infrastructure the data controller is running on.
        :param Any k8s_raw: The raw kubernetes information
        :param _builtins.str last_uploaded_date: Last uploaded date from Kubernetes cluster. Defaults to current date time
        :param 'LogAnalyticsWorkspaceConfigResponse' log_analytics_workspace_config: Log analytics workspace id and primary key
        :param 'BasicLoginInformationResponse' logs_dashboard_credential: Login credential for logs dashboard on the Kubernetes cluster.
        :param 'BasicLoginInformationResponse' metrics_dashboard_credential: Login credential for metrics dashboard on the Kubernetes cluster.
        :param 'OnPremisePropertyResponse' on_premise_property: Properties from the Kubernetes data controller
        :param 'UploadServicePrincipalResponse' upload_service_principal: Deprecated. Service principal is deprecated in favor of Arc Kubernetes service extension managed identity.
        :param 'UploadWatermarkResponse' upload_watermark: Properties on upload watermark.  Mostly timestamp for each upload data type
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if basic_login_information is not None:
            pulumi.set(__self__, "basic_login_information", basic_login_information)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if extension_id is not None:
            pulumi.set(__self__, "extension_id", extension_id)
        if infrastructure is None:
            infrastructure = 'other'
        if infrastructure is not None:
            pulumi.set(__self__, "infrastructure", infrastructure)
        if k8s_raw is not None:
            pulumi.set(__self__, "k8s_raw", k8s_raw)
        if last_uploaded_date is not None:
            pulumi.set(__self__, "last_uploaded_date", last_uploaded_date)
        if log_analytics_workspace_config is not None:
            pulumi.set(__self__, "log_analytics_workspace_config", log_analytics_workspace_config)
        if logs_dashboard_credential is not None:
            pulumi.set(__self__, "logs_dashboard_credential", logs_dashboard_credential)
        if metrics_dashboard_credential is not None:
            pulumi.set(__self__, "metrics_dashboard_credential", metrics_dashboard_credential)
        if on_premise_property is not None:
            pulumi.set(__self__, "on_premise_property", on_premise_property)
        if upload_service_principal is not None:
            pulumi.set(__self__, "upload_service_principal", upload_service_principal)
        if upload_watermark is not None:
            pulumi.set(__self__, "upload_watermark", upload_watermark)

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the Arc Data Controller resource.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="basicLoginInformation")
    def basic_login_information(self) -> Optional['outputs.BasicLoginInformationResponse']:
        """
        Deprecated. Azure Arc Data Services data controller no longer expose any endpoint. All traffic are exposed through Kubernetes native API.
        """
        return pulumi.get(self, "basic_login_information")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        """
        If a CustomLocation is provided, this contains the ARM id of the connected cluster the custom location belongs to.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="extensionId")
    def extension_id(self) -> Optional[_builtins.str]:
        """
        If a CustomLocation is provided, this contains the ARM id of the extension the custom location belongs to.
        """
        return pulumi.get(self, "extension_id")

    @_builtins.property
    @pulumi.getter
    def infrastructure(self) -> Optional[_builtins.str]:
        """
        The infrastructure the data controller is running on.
        """
        return pulumi.get(self, "infrastructure")

    @_builtins.property
    @pulumi.getter(name="k8sRaw")
    def k8s_raw(self) -> Optional[Any]:
        """
        The raw kubernetes information
        """
        return pulumi.get(self, "k8s_raw")

    @_builtins.property
    @pulumi.getter(name="lastUploadedDate")
    def last_uploaded_date(self) -> Optional[_builtins.str]:
        """
        Last uploaded date from Kubernetes cluster. Defaults to current date time
        """
        return pulumi.get(self, "last_uploaded_date")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceConfig")
    def log_analytics_workspace_config(self) -> Optional['outputs.LogAnalyticsWorkspaceConfigResponse']:
        """
        Log analytics workspace id and primary key
        """
        return pulumi.get(self, "log_analytics_workspace_config")

    @_builtins.property
    @pulumi.getter(name="logsDashboardCredential")
    def logs_dashboard_credential(self) -> Optional['outputs.BasicLoginInformationResponse']:
        """
        Login credential for logs dashboard on the Kubernetes cluster.
        """
        return pulumi.get(self, "logs_dashboard_credential")

    @_builtins.property
    @pulumi.getter(name="metricsDashboardCredential")
    def metrics_dashboard_credential(self) -> Optional['outputs.BasicLoginInformationResponse']:
        """
        Login credential for metrics dashboard on the Kubernetes cluster.
        """
        return pulumi.get(self, "metrics_dashboard_credential")

    @_builtins.property
    @pulumi.getter(name="onPremiseProperty")
    def on_premise_property(self) -> Optional['outputs.OnPremisePropertyResponse']:
        """
        Properties from the Kubernetes data controller
        """
        return pulumi.get(self, "on_premise_property")

    @_builtins.property
    @pulumi.getter(name="uploadServicePrincipal")
    def upload_service_principal(self) -> Optional['outputs.UploadServicePrincipalResponse']:
        """
        Deprecated. Service principal is deprecated in favor of Arc Kubernetes service extension managed identity.
        """
        return pulumi.get(self, "upload_service_principal")

    @_builtins.property
    @pulumi.getter(name="uploadWatermark")
    def upload_watermark(self) -> Optional['outputs.UploadWatermarkResponse']:
        """
        Properties on upload watermark.  Mostly timestamp for each upload data type
        """
        return pulumi.get(self, "upload_watermark")


@pulumi.output_type
class ExtendedLocationResponse(dict):
    """
    The complex type of the extended location.
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        The complex type of the extended location.
        :param _builtins.str name: The name of the extended location.
        :param _builtins.str type: The type of the extended location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the extended location.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FailoverClusterResponse(dict):
    """
    Failover Cluster Instance properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostNames":
            suggest = "host_names"
        elif key == "networkName":
            suggest = "network_name"
        elif key == "sqlInstanceIds":
            suggest = "sql_instance_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailoverClusterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailoverClusterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailoverClusterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_names: Sequence[_builtins.str],
                 id: _builtins.str,
                 network_name: _builtins.str,
                 sql_instance_ids: Sequence[_builtins.str]):
        """
        Failover Cluster Instance properties.
        :param Sequence[_builtins.str] host_names: The host names which are part of the SQL FCI resource group.
        :param _builtins.str id: The GUID of the SQL Server's underlying Failover Cluster.
        :param _builtins.str network_name: The network name to connect to the SQL FCI.
        :param Sequence[_builtins.str] sql_instance_ids: The ARM IDs of the Arc SQL Server resources, belonging to the current server's Failover cluster.
        """
        pulumi.set(__self__, "host_names", host_names)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "sql_instance_ids", sql_instance_ids)

    @_builtins.property
    @pulumi.getter(name="hostNames")
    def host_names(self) -> Sequence[_builtins.str]:
        """
        The host names which are part of the SQL FCI resource group.
        """
        return pulumi.get(self, "host_names")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The GUID of the SQL Server's underlying Failover Cluster.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> _builtins.str:
        """
        The network name to connect to the SQL FCI.
        """
        return pulumi.get(self, "network_name")

    @_builtins.property
    @pulumi.getter(name="sqlInstanceIds")
    def sql_instance_ids(self) -> Sequence[_builtins.str]:
        """
        The ARM IDs of the Arc SQL Server resources, belonging to the current server's Failover cluster.
        """
        return pulumi.get(self, "sql_instance_ids")


@pulumi.output_type
class FailoverGroupPropertiesResponse(dict):
    """
    The properties of a failover group resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partnerManagedInstanceId":
            suggest = "partner_managed_instance_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailoverGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailoverGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailoverGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partner_managed_instance_id: _builtins.str,
                 provisioning_state: _builtins.str,
                 spec: 'outputs.FailoverGroupSpecResponse',
                 status: Optional[Any] = None):
        """
        The properties of a failover group resource.
        :param _builtins.str partner_managed_instance_id: The resource ID of the partner SQL managed instance.
        :param _builtins.str provisioning_state: The provisioning state of the failover group resource.
        :param 'FailoverGroupSpecResponse' spec: The specifications of the failover group resource.
        :param Any status: The status of the failover group custom resource.
        """
        pulumi.set(__self__, "partner_managed_instance_id", partner_managed_instance_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="partnerManagedInstanceId")
    def partner_managed_instance_id(self) -> _builtins.str:
        """
        The resource ID of the partner SQL managed instance.
        """
        return pulumi.get(self, "partner_managed_instance_id")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the failover group resource.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> 'outputs.FailoverGroupSpecResponse':
        """
        The specifications of the failover group resource.
        """
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[Any]:
        """
        The status of the failover group custom resource.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class FailoverGroupSpecResponse(dict):
    """
    The specifications of the failover group resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partnerMI":
            suggest = "partner_mi"
        elif key == "partnerMirroringCert":
            suggest = "partner_mirroring_cert"
        elif key == "partnerMirroringURL":
            suggest = "partner_mirroring_url"
        elif key == "partnerSyncMode":
            suggest = "partner_sync_mode"
        elif key == "sharedName":
            suggest = "shared_name"
        elif key == "sourceMI":
            suggest = "source_mi"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FailoverGroupSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FailoverGroupSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FailoverGroupSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role: Optional[_builtins.str] = None,
                 partner_mi: Optional[_builtins.str] = None,
                 partner_mirroring_cert: Optional[_builtins.str] = None,
                 partner_mirroring_url: Optional[_builtins.str] = None,
                 partner_sync_mode: Optional[_builtins.str] = None,
                 shared_name: Optional[_builtins.str] = None,
                 source_mi: Optional[_builtins.str] = None):
        """
        The specifications of the failover group resource.
        :param _builtins.str role: The role of the SQL managed instance in this failover group.
        :param _builtins.str partner_mi: The name of the partner SQL managed instance.
        :param _builtins.str partner_mirroring_cert: The mirroring endpoint public certificate for the partner SQL managed instance. Only PEM format is supported.
        :param _builtins.str partner_mirroring_url: The mirroring endpoint URL of the partner SQL managed instance.
        :param _builtins.str partner_sync_mode: The partner sync mode of the SQL managed instance.
        :param _builtins.str shared_name: The shared name of the failover group for this SQL managed instance. Both SQL managed instance and its partner have to use the same shared name.
        :param _builtins.str source_mi: The name of the SQL managed instance with this failover group role.
        """
        if role is None:
            role = 'primary'
        pulumi.set(__self__, "role", role)
        if partner_mi is not None:
            pulumi.set(__self__, "partner_mi", partner_mi)
        if partner_mirroring_cert is not None:
            pulumi.set(__self__, "partner_mirroring_cert", partner_mirroring_cert)
        if partner_mirroring_url is not None:
            pulumi.set(__self__, "partner_mirroring_url", partner_mirroring_url)
        if partner_sync_mode is None:
            partner_sync_mode = 'async'
        if partner_sync_mode is not None:
            pulumi.set(__self__, "partner_sync_mode", partner_sync_mode)
        if shared_name is not None:
            pulumi.set(__self__, "shared_name", shared_name)
        if source_mi is not None:
            pulumi.set(__self__, "source_mi", source_mi)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role of the SQL managed instance in this failover group.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="partnerMI")
    def partner_mi(self) -> Optional[_builtins.str]:
        """
        The name of the partner SQL managed instance.
        """
        return pulumi.get(self, "partner_mi")

    @_builtins.property
    @pulumi.getter(name="partnerMirroringCert")
    def partner_mirroring_cert(self) -> Optional[_builtins.str]:
        """
        The mirroring endpoint public certificate for the partner SQL managed instance. Only PEM format is supported.
        """
        return pulumi.get(self, "partner_mirroring_cert")

    @_builtins.property
    @pulumi.getter(name="partnerMirroringURL")
    def partner_mirroring_url(self) -> Optional[_builtins.str]:
        """
        The mirroring endpoint URL of the partner SQL managed instance.
        """
        return pulumi.get(self, "partner_mirroring_url")

    @_builtins.property
    @pulumi.getter(name="partnerSyncMode")
    def partner_sync_mode(self) -> Optional[_builtins.str]:
        """
        The partner sync mode of the SQL managed instance.
        """
        return pulumi.get(self, "partner_sync_mode")

    @_builtins.property
    @pulumi.getter(name="sharedName")
    def shared_name(self) -> Optional[_builtins.str]:
        """
        The shared name of the failover group for this SQL managed instance. Both SQL managed instance and its partner have to use the same shared name.
        """
        return pulumi.get(self, "shared_name")

    @_builtins.property
    @pulumi.getter(name="sourceMI")
    def source_mi(self) -> Optional[_builtins.str]:
        """
        The name of the SQL managed instance with this failover group role.
        """
        return pulumi.get(self, "source_mi")


@pulumi.output_type
class K8sActiveDirectoryResponse(dict):
    """
    The kubernetes active directory information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "encryptionTypes":
            suggest = "encryption_types"
        elif key == "keytabSecret":
            suggest = "keytab_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sActiveDirectoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sActiveDirectoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sActiveDirectoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: Optional[_builtins.str] = None,
                 connector: Optional['outputs.K8sActiveDirectoryResponseConnector'] = None,
                 encryption_types: Optional[Sequence[_builtins.str]] = None,
                 keytab_secret: Optional[_builtins.str] = None):
        """
        The kubernetes active directory information.
        :param _builtins.str account_name: Account name for AAD
        :param Sequence[_builtins.str] encryption_types: An array of encryption types
        :param _builtins.str keytab_secret: Keytab secret used to authenticate with Active Directory.
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if connector is not None:
            pulumi.set(__self__, "connector", connector)
        if encryption_types is not None:
            pulumi.set(__self__, "encryption_types", encryption_types)
        if keytab_secret is not None:
            pulumi.set(__self__, "keytab_secret", keytab_secret)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[_builtins.str]:
        """
        Account name for AAD
        """
        return pulumi.get(self, "account_name")

    @_builtins.property
    @pulumi.getter
    def connector(self) -> Optional['outputs.K8sActiveDirectoryResponseConnector']:
        return pulumi.get(self, "connector")

    @_builtins.property
    @pulumi.getter(name="encryptionTypes")
    def encryption_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of encryption types
        """
        return pulumi.get(self, "encryption_types")

    @_builtins.property
    @pulumi.getter(name="keytabSecret")
    def keytab_secret(self) -> Optional[_builtins.str]:
        """
        Keytab secret used to authenticate with Active Directory.
        """
        return pulumi.get(self, "keytab_secret")


@pulumi.output_type
class K8sActiveDirectoryResponseConnector(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the connector
        :param _builtins.str namespace: Name space of the connector
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the connector
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Name space of the connector
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class K8sNetworkSettingsResponse(dict):
    """
    The kubernetes network settings information.
    """
    def __init__(__self__, *,
                 forceencryption: Optional[_builtins.int] = None,
                 tlsciphers: Optional[_builtins.str] = None,
                 tlsprotocols: Optional[_builtins.str] = None):
        """
        The kubernetes network settings information.
        :param _builtins.int forceencryption: If 1, then SQL Server forces all connections to be encrypted. By default, this option is 0
        :param _builtins.str tlsciphers: Specifies which ciphers are allowed by SQL Server for TLS
        :param _builtins.str tlsprotocols: A comma-separated list of which TLS protocols are allowed by SQL Server
        """
        if forceencryption is not None:
            pulumi.set(__self__, "forceencryption", forceencryption)
        if tlsciphers is not None:
            pulumi.set(__self__, "tlsciphers", tlsciphers)
        if tlsprotocols is not None:
            pulumi.set(__self__, "tlsprotocols", tlsprotocols)

    @_builtins.property
    @pulumi.getter
    def forceencryption(self) -> Optional[_builtins.int]:
        """
        If 1, then SQL Server forces all connections to be encrypted. By default, this option is 0
        """
        return pulumi.get(self, "forceencryption")

    @_builtins.property
    @pulumi.getter
    def tlsciphers(self) -> Optional[_builtins.str]:
        """
        Specifies which ciphers are allowed by SQL Server for TLS
        """
        return pulumi.get(self, "tlsciphers")

    @_builtins.property
    @pulumi.getter
    def tlsprotocols(self) -> Optional[_builtins.str]:
        """
        A comma-separated list of which TLS protocols are allowed by SQL Server
        """
        return pulumi.get(self, "tlsprotocols")


@pulumi.output_type
class K8sResourceRequirementsResponse(dict):
    """
    The kubernetes resource limits and requests used to restrict or reserve resource usage.
    """
    def __init__(__self__, *,
                 limits: Optional[Mapping[str, _builtins.str]] = None,
                 requests: Optional[Mapping[str, _builtins.str]] = None):
        """
        The kubernetes resource limits and requests used to restrict or reserve resource usage.
        :param Mapping[str, _builtins.str] limits: Limits for a kubernetes resource type (e.g 'cpu', 'memory'). The 'cpu' request must be less than or equal to 'cpu' limit. Default 'cpu' is 2, minimum is 1. Default 'memory' is '4Gi', minimum is '2Gi. If sku.tier is GeneralPurpose, maximum 'cpu' is 24 and maximum 'memory' is '128Gi'.
        :param Mapping[str, _builtins.str] requests: Requests for a kubernetes resource type (e.g 'cpu', 'memory'). The 'cpu' request must be less than or equal to 'cpu' limit. Default 'cpu' is 2, minimum is 1. Default 'memory' is '4Gi', minimum is '2Gi. If sku.tier is GeneralPurpose, maximum 'cpu' is 24 and maximum 'memory' is '128Gi'.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Limits for a kubernetes resource type (e.g 'cpu', 'memory'). The 'cpu' request must be less than or equal to 'cpu' limit. Default 'cpu' is 2, minimum is 1. Default 'memory' is '4Gi', minimum is '2Gi. If sku.tier is GeneralPurpose, maximum 'cpu' is 24 and maximum 'memory' is '128Gi'.
        """
        return pulumi.get(self, "limits")

    @_builtins.property
    @pulumi.getter
    def requests(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Requests for a kubernetes resource type (e.g 'cpu', 'memory'). The 'cpu' request must be less than or equal to 'cpu' limit. Default 'cpu' is 2, minimum is 1. Default 'memory' is '4Gi', minimum is '2Gi. If sku.tier is GeneralPurpose, maximum 'cpu' is 24 and maximum 'memory' is '128Gi'.
        """
        return pulumi.get(self, "requests")


@pulumi.output_type
class K8sSchedulingOptionsResponse(dict):
    """
    The kubernetes scheduling options. It describes restrictions used to help Kubernetes select appropriate nodes to host the database service
    """
    def __init__(__self__, *,
                 resources: Optional['outputs.K8sResourceRequirementsResponse'] = None):
        """
        The kubernetes scheduling options. It describes restrictions used to help Kubernetes select appropriate nodes to host the database service
        :param 'K8sResourceRequirementsResponse' resources: The kubernetes resource limits and requests used to restrict or reserve resource usage.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional['outputs.K8sResourceRequirementsResponse']:
        """
        The kubernetes resource limits and requests used to restrict or reserve resource usage.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class K8sSchedulingResponse(dict):
    """
    The kubernetes scheduling information.
    """
    def __init__(__self__, *,
                 default: Optional['outputs.K8sSchedulingOptionsResponse'] = None):
        """
        The kubernetes scheduling information.
        :param 'K8sSchedulingOptionsResponse' default: The kubernetes scheduling options. It describes restrictions used to help Kubernetes select appropriate nodes to host the database service
        """
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional['outputs.K8sSchedulingOptionsResponse']:
        """
        The kubernetes scheduling options. It describes restrictions used to help Kubernetes select appropriate nodes to host the database service
        """
        return pulumi.get(self, "default")


@pulumi.output_type
class K8sSecurityResponse(dict):
    """
    The kubernetes security information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "adminLoginSecret":
            suggest = "admin_login_secret"
        elif key == "serviceCertificateSecret":
            suggest = "service_certificate_secret"
        elif key == "transparentDataEncryption":
            suggest = "transparent_data_encryption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sSecurityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sSecurityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sSecurityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_directory: Optional['outputs.K8sActiveDirectoryResponse'] = None,
                 admin_login_secret: Optional[_builtins.str] = None,
                 service_certificate_secret: Optional[_builtins.str] = None,
                 transparent_data_encryption: Optional['outputs.K8stransparentDataEncryptionResponse'] = None):
        """
        The kubernetes security information.
        :param 'K8sActiveDirectoryResponse' active_directory: The kubernetes active directory information.
        :param _builtins.str admin_login_secret: Admin login secret key
        :param _builtins.str service_certificate_secret: Service certificate secret used
        :param 'K8stransparentDataEncryptionResponse' transparent_data_encryption: Transparent data encryption information.
        """
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if admin_login_secret is not None:
            pulumi.set(__self__, "admin_login_secret", admin_login_secret)
        if service_certificate_secret is not None:
            pulumi.set(__self__, "service_certificate_secret", service_certificate_secret)
        if transparent_data_encryption is not None:
            pulumi.set(__self__, "transparent_data_encryption", transparent_data_encryption)

    @_builtins.property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.K8sActiveDirectoryResponse']:
        """
        The kubernetes active directory information.
        """
        return pulumi.get(self, "active_directory")

    @_builtins.property
    @pulumi.getter(name="adminLoginSecret")
    def admin_login_secret(self) -> Optional[_builtins.str]:
        """
        Admin login secret key
        """
        return pulumi.get(self, "admin_login_secret")

    @_builtins.property
    @pulumi.getter(name="serviceCertificateSecret")
    def service_certificate_secret(self) -> Optional[_builtins.str]:
        """
        Service certificate secret used
        """
        return pulumi.get(self, "service_certificate_secret")

    @_builtins.property
    @pulumi.getter(name="transparentDataEncryption")
    def transparent_data_encryption(self) -> Optional['outputs.K8stransparentDataEncryptionResponse']:
        """
        Transparent data encryption information.
        """
        return pulumi.get(self, "transparent_data_encryption")


@pulumi.output_type
class K8sSettingsResponse(dict):
    """
    The kubernetes settings information.
    """
    def __init__(__self__, *,
                 network: Optional['outputs.K8sNetworkSettingsResponse'] = None):
        """
        The kubernetes settings information.
        :param 'K8sNetworkSettingsResponse' network: The kubernetes network settings information.
        """
        if network is not None:
            pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.K8sNetworkSettingsResponse']:
        """
        The kubernetes network settings information.
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class K8stransparentDataEncryptionResponse(dict):
    """
    Transparent data encryption information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "protectorSecret":
            suggest = "protector_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8stransparentDataEncryptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8stransparentDataEncryptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8stransparentDataEncryptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 protector_secret: Optional[_builtins.str] = None):
        """
        Transparent data encryption information.
        :param _builtins.str mode: Transparent data encryption mode. Can be Service Managed, Customer managed or disabled
        :param _builtins.str protector_secret: Protector secret for customer managed Transparent data encryption mode
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if protector_secret is not None:
            pulumi.set(__self__, "protector_secret", protector_secret)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        Transparent data encryption mode. Can be Service Managed, Customer managed or disabled
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="protectorSecret")
    def protector_secret(self) -> Optional[_builtins.str]:
        """
        Protector secret for customer managed Transparent data encryption mode
        """
        return pulumi.get(self, "protector_secret")


@pulumi.output_type
class LogAnalyticsWorkspaceConfigResponse(dict):
    """
    Log analytics workspace id and primary key
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAnalyticsWorkspaceConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAnalyticsWorkspaceConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAnalyticsWorkspaceConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_id: Optional[_builtins.str] = None):
        """
        Log analytics workspace id and primary key
        :param _builtins.str workspace_id: Azure Log Analytics workspace ID
        """
        if workspace_id is not None:
            pulumi.set(__self__, "workspace_id", workspace_id)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> Optional[_builtins.str]:
        """
        Azure Log Analytics workspace ID
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class MonitoringResponse(dict):
    """
    The monitoring configuration.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        The monitoring configuration.
        :param _builtins.bool enabled: Indicates if monitoring is enabled for this SQL Server instance.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates if monitoring is enabled for this SQL Server instance.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OnPremisePropertyResponse(dict):
    """
    Properties from the Kubernetes data controller
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicSigningKey":
            suggest = "public_signing_key"
        elif key == "signingCertificateThumbprint":
            suggest = "signing_certificate_thumbprint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnPremisePropertyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnPremisePropertyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnPremisePropertyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: _builtins.str,
                 public_signing_key: _builtins.str,
                 signing_certificate_thumbprint: Optional[_builtins.str] = None):
        """
        Properties from the Kubernetes data controller
        :param _builtins.str id: A globally unique ID identifying the associated Kubernetes cluster
        :param _builtins.str public_signing_key: Certificate that contains the Kubernetes cluster public key used to verify signing
        :param _builtins.str signing_certificate_thumbprint: Unique thumbprint returned to customer to verify the certificate being uploaded
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "public_signing_key", public_signing_key)
        if signing_certificate_thumbprint is not None:
            pulumi.set(__self__, "signing_certificate_thumbprint", signing_certificate_thumbprint)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        A globally unique ID identifying the associated Kubernetes cluster
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="publicSigningKey")
    def public_signing_key(self) -> _builtins.str:
        """
        Certificate that contains the Kubernetes cluster public key used to verify signing
        """
        return pulumi.get(self, "public_signing_key")

    @_builtins.property
    @pulumi.getter(name="signingCertificateThumbprint")
    def signing_certificate_thumbprint(self) -> Optional[_builtins.str]:
        """
        Unique thumbprint returned to customer to verify the certificate being uploaded
        """
        return pulumi.get(self, "signing_certificate_thumbprint")


@pulumi.output_type
class PostgresInstancePropertiesResponse(dict):
    """
    Postgres Instance properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "basicLoginInformation":
            suggest = "basic_login_information"
        elif key == "dataControllerId":
            suggest = "data_controller_id"
        elif key == "k8sRaw":
            suggest = "k8s_raw"
        elif key == "lastUploadedDate":
            suggest = "last_uploaded_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PostgresInstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PostgresInstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PostgresInstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: _builtins.str,
                 admin: Optional[_builtins.str] = None,
                 basic_login_information: Optional['outputs.BasicLoginInformationResponse'] = None,
                 data_controller_id: Optional[_builtins.str] = None,
                 k8s_raw: Optional[Any] = None,
                 last_uploaded_date: Optional[_builtins.str] = None):
        """
        Postgres Instance properties.
        :param _builtins.str provisioning_state: The provisioning state of the Azure Arc-enabled PostgreSQL instance.
        :param _builtins.str admin: The instance admin
        :param 'BasicLoginInformationResponse' basic_login_information: Username and password for basic authentication.
        :param _builtins.str data_controller_id: The data controller id
        :param Any k8s_raw: The raw kubernetes information
        :param _builtins.str last_uploaded_date: Last uploaded date from Kubernetes cluster. Defaults to current date time
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if admin is not None:
            pulumi.set(__self__, "admin", admin)
        if basic_login_information is not None:
            pulumi.set(__self__, "basic_login_information", basic_login_information)
        if data_controller_id is not None:
            pulumi.set(__self__, "data_controller_id", data_controller_id)
        if k8s_raw is not None:
            pulumi.set(__self__, "k8s_raw", k8s_raw)
        if last_uploaded_date is not None:
            pulumi.set(__self__, "last_uploaded_date", last_uploaded_date)

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the Azure Arc-enabled PostgreSQL instance.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def admin(self) -> Optional[_builtins.str]:
        """
        The instance admin
        """
        return pulumi.get(self, "admin")

    @_builtins.property
    @pulumi.getter(name="basicLoginInformation")
    def basic_login_information(self) -> Optional['outputs.BasicLoginInformationResponse']:
        """
        Username and password for basic authentication.
        """
        return pulumi.get(self, "basic_login_information")

    @_builtins.property
    @pulumi.getter(name="dataControllerId")
    def data_controller_id(self) -> Optional[_builtins.str]:
        """
        The data controller id
        """
        return pulumi.get(self, "data_controller_id")

    @_builtins.property
    @pulumi.getter(name="k8sRaw")
    def k8s_raw(self) -> Optional[Any]:
        """
        The raw kubernetes information
        """
        return pulumi.get(self, "k8s_raw")

    @_builtins.property
    @pulumi.getter(name="lastUploadedDate")
    def last_uploaded_date(self) -> Optional[_builtins.str]:
        """
        Last uploaded date from Kubernetes cluster. Defaults to current date time
        """
        return pulumi.get(self, "last_uploaded_date")


@pulumi.output_type
class PostgresInstanceSkuResponse(dict):
    """
    The resource model definition representing SKU for Azure Database for PostgresSQL - Azure Arc
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 capacity: Optional[_builtins.int] = None,
                 dev: Optional[_builtins.bool] = None,
                 family: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 tier: Optional[_builtins.str] = None):
        """
        The resource model definition representing SKU for Azure Database for PostgresSQL - Azure Arc
        :param _builtins.str name: The name of the SKU.  It is typically a letter+number code
        :param _builtins.int capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param _builtins.bool dev: Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose. 
        :param _builtins.str family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
        :param _builtins.str size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param _builtins.str tier: This field is required to be implemented by the Resource Provider if the service has more than one tier.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if dev is None:
            dev = True
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is None:
            tier = 'Hyperscale'
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the SKU.  It is typically a letter+number code
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> Optional[_builtins.int]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.bool]:
        """
        Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose. 
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[_builtins.str]:
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> Optional[_builtins.str]:
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SequencerActionResponse(dict):
    """
    The sequencer action details.
    """
    def __init__(__self__, *,
                 action_id: Optional[_builtins.str] = None,
                 result: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        The sequencer action details.
        :param _builtins.str action_id: The unique identifier of the sequencer action.
        :param _builtins.str result: The result of the sequencer action.
        :param _builtins.str state: The state of the sequencer action.
        """
        if action_id is not None:
            pulumi.set(__self__, "action_id", action_id)
        if result is not None:
            pulumi.set(__self__, "result", result)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="actionId")
    def action_id(self) -> Optional[_builtins.str]:
        """
        The unique identifier of the sequencer action.
        """
        return pulumi.get(self, "action_id")

    @_builtins.property
    @pulumi.getter
    def result(self) -> Optional[_builtins.str]:
        """
        The result of the sequencer action.
        """
        return pulumi.get(self, "result")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The state of the sequencer action.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class SqlAvailabilityGroupDatabaseReplicaResourcePropertiesResponse(dict):
    """
    The properties of Arc Sql availability group database replica resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseStateDescription":
            suggest = "database_state_description"
        elif key == "isCommitParticipant":
            suggest = "is_commit_participant"
        elif key == "isLocal":
            suggest = "is_local"
        elif key == "isPrimaryReplica":
            suggest = "is_primary_replica"
        elif key == "isSuspended":
            suggest = "is_suspended"
        elif key == "replicaName":
            suggest = "replica_name"
        elif key == "suspendReasonDescription":
            suggest = "suspend_reason_description"
        elif key == "synchronizationHealthDescription":
            suggest = "synchronization_health_description"
        elif key == "synchronizationStateDescription":
            suggest = "synchronization_state_description"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlAvailabilityGroupDatabaseReplicaResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlAvailabilityGroupDatabaseReplicaResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlAvailabilityGroupDatabaseReplicaResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_state_description: _builtins.str,
                 is_commit_participant: _builtins.bool,
                 is_local: _builtins.bool,
                 is_primary_replica: _builtins.bool,
                 is_suspended: _builtins.bool,
                 replica_name: _builtins.str,
                 suspend_reason_description: _builtins.str,
                 synchronization_health_description: _builtins.str,
                 synchronization_state_description: _builtins.str,
                 database_name: Optional[_builtins.str] = None):
        """
        The properties of Arc Sql availability group database replica resource
        :param _builtins.str database_state_description: Description of the database state of the availability replica.
        :param _builtins.bool is_commit_participant: Whether this replica is transaction committer.
        :param _builtins.bool is_local: Whether the availability database is local.
        :param _builtins.bool is_primary_replica: Returns 1 if the replica is primary, or 0 if it is a secondary replica.
        :param _builtins.bool is_suspended: Whether this data movement is suspended.
        :param _builtins.str replica_name: the database replica name.
        :param _builtins.str suspend_reason_description: Description of the database suspended state reason.
        :param _builtins.str synchronization_health_description: Description of the health of database.
        :param _builtins.str synchronization_state_description: Description of the data-movement state.
        :param _builtins.str database_name: the database name.
        """
        pulumi.set(__self__, "database_state_description", database_state_description)
        pulumi.set(__self__, "is_commit_participant", is_commit_participant)
        pulumi.set(__self__, "is_local", is_local)
        pulumi.set(__self__, "is_primary_replica", is_primary_replica)
        pulumi.set(__self__, "is_suspended", is_suspended)
        pulumi.set(__self__, "replica_name", replica_name)
        pulumi.set(__self__, "suspend_reason_description", suspend_reason_description)
        pulumi.set(__self__, "synchronization_health_description", synchronization_health_description)
        pulumi.set(__self__, "synchronization_state_description", synchronization_state_description)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter(name="databaseStateDescription")
    def database_state_description(self) -> _builtins.str:
        """
        Description of the database state of the availability replica.
        """
        return pulumi.get(self, "database_state_description")

    @_builtins.property
    @pulumi.getter(name="isCommitParticipant")
    def is_commit_participant(self) -> _builtins.bool:
        """
        Whether this replica is transaction committer.
        """
        return pulumi.get(self, "is_commit_participant")

    @_builtins.property
    @pulumi.getter(name="isLocal")
    def is_local(self) -> _builtins.bool:
        """
        Whether the availability database is local.
        """
        return pulumi.get(self, "is_local")

    @_builtins.property
    @pulumi.getter(name="isPrimaryReplica")
    def is_primary_replica(self) -> _builtins.bool:
        """
        Returns 1 if the replica is primary, or 0 if it is a secondary replica.
        """
        return pulumi.get(self, "is_primary_replica")

    @_builtins.property
    @pulumi.getter(name="isSuspended")
    def is_suspended(self) -> _builtins.bool:
        """
        Whether this data movement is suspended.
        """
        return pulumi.get(self, "is_suspended")

    @_builtins.property
    @pulumi.getter(name="replicaName")
    def replica_name(self) -> _builtins.str:
        """
        the database replica name.
        """
        return pulumi.get(self, "replica_name")

    @_builtins.property
    @pulumi.getter(name="suspendReasonDescription")
    def suspend_reason_description(self) -> _builtins.str:
        """
        Description of the database suspended state reason.
        """
        return pulumi.get(self, "suspend_reason_description")

    @_builtins.property
    @pulumi.getter(name="synchronizationHealthDescription")
    def synchronization_health_description(self) -> _builtins.str:
        """
        Description of the health of database.
        """
        return pulumi.get(self, "synchronization_health_description")

    @_builtins.property
    @pulumi.getter(name="synchronizationStateDescription")
    def synchronization_state_description(self) -> _builtins.str:
        """
        Description of the data-movement state.
        """
        return pulumi.get(self, "synchronization_state_description")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        the database name.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class SqlAvailabilityGroupReplicaResourcePropertiesResponse(dict):
    """
    The properties of Arc Sql availability group replica resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicaId":
            suggest = "replica_id"
        elif key == "replicaName":
            suggest = "replica_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlAvailabilityGroupReplicaResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlAvailabilityGroupReplicaResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlAvailabilityGroupReplicaResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replica_id: _builtins.str,
                 configure: Optional['outputs.AvailabilityGroupConfigureResponse'] = None,
                 replica_name: Optional[_builtins.str] = None,
                 state: Optional['outputs.AvailabilityGroupStateResponse'] = None):
        """
        The properties of Arc Sql availability group replica resource
        :param _builtins.str replica_id: ID GUID of the availability group.
        :param 'AvailabilityGroupConfigureResponse' configure: null
        :param _builtins.str replica_name: the replica name.
        :param 'AvailabilityGroupStateResponse' state: null
        """
        pulumi.set(__self__, "replica_id", replica_id)
        if configure is not None:
            pulumi.set(__self__, "configure", configure)
        if replica_name is not None:
            pulumi.set(__self__, "replica_name", replica_name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="replicaId")
    def replica_id(self) -> _builtins.str:
        """
        ID GUID of the availability group.
        """
        return pulumi.get(self, "replica_id")

    @_builtins.property
    @pulumi.getter
    def configure(self) -> Optional['outputs.AvailabilityGroupConfigureResponse']:
        """
        null
        """
        return pulumi.get(self, "configure")

    @_builtins.property
    @pulumi.getter(name="replicaName")
    def replica_name(self) -> Optional[_builtins.str]:
        """
        the replica name.
        """
        return pulumi.get(self, "replica_name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional['outputs.AvailabilityGroupStateResponse']:
        """
        null
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class SqlManagedInstanceK8sRawResponse(dict):
    """
    The raw kubernetes information.
    """
    def __init__(__self__, *,
                 spec: Optional['outputs.SqlManagedInstanceK8sSpecResponse'] = None):
        """
        The raw kubernetes information.
        :param 'SqlManagedInstanceK8sSpecResponse' spec: The kubernetes spec information.
        """
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.SqlManagedInstanceK8sSpecResponse']:
        """
        The kubernetes spec information.
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class SqlManagedInstanceK8sSpecResponse(dict):
    """
    The kubernetes spec information.
    """
    def __init__(__self__, *,
                 replicas: Optional[_builtins.int] = None,
                 scheduling: Optional['outputs.K8sSchedulingResponse'] = None,
                 security: Optional['outputs.K8sSecurityResponse'] = None,
                 settings: Optional['outputs.K8sSettingsResponse'] = None):
        """
        The kubernetes spec information.
        :param _builtins.int replicas: This option specifies the number of SQL Managed Instance replicas that will be deployed in your Kubernetes cluster for high availability purposes. If sku.tier is BusinessCritical, allowed values are '2' or '3' with default of '3'. If sku.tier is GeneralPurpose, replicas must be '1'.
        :param 'K8sSchedulingResponse' scheduling: The kubernetes scheduling information.
        :param 'K8sSecurityResponse' security: The kubernetes security information.
        :param 'K8sSettingsResponse' settings: The kubernetes settings information.
        """
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if scheduling is not None:
            pulumi.set(__self__, "scheduling", scheduling)
        if security is not None:
            pulumi.set(__self__, "security", security)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[_builtins.int]:
        """
        This option specifies the number of SQL Managed Instance replicas that will be deployed in your Kubernetes cluster for high availability purposes. If sku.tier is BusinessCritical, allowed values are '2' or '3' with default of '3'. If sku.tier is GeneralPurpose, replicas must be '1'.
        """
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter
    def scheduling(self) -> Optional['outputs.K8sSchedulingResponse']:
        """
        The kubernetes scheduling information.
        """
        return pulumi.get(self, "scheduling")

    @_builtins.property
    @pulumi.getter
    def security(self) -> Optional['outputs.K8sSecurityResponse']:
        """
        The kubernetes security information.
        """
        return pulumi.get(self, "security")

    @_builtins.property
    @pulumi.getter
    def settings(self) -> Optional['outputs.K8sSettingsResponse']:
        """
        The kubernetes settings information.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class SqlManagedInstancePropertiesResponse(dict):
    """
    Properties of sqlManagedInstance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "basicLoginInformation":
            suggest = "basic_login_information"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "dataControllerId":
            suggest = "data_controller_id"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "extensionId":
            suggest = "extension_id"
        elif key == "k8sRaw":
            suggest = "k8s_raw"
        elif key == "lastUploadedDate":
            suggest = "last_uploaded_date"
        elif key == "licenseType":
            suggest = "license_type"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlManagedInstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlManagedInstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlManagedInstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: _builtins.str,
                 admin: Optional[_builtins.str] = None,
                 basic_login_information: Optional['outputs.BasicLoginInformationResponse'] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 data_controller_id: Optional[_builtins.str] = None,
                 end_time: Optional[_builtins.str] = None,
                 extension_id: Optional[_builtins.str] = None,
                 k8s_raw: Optional['outputs.SqlManagedInstanceK8sRawResponse'] = None,
                 last_uploaded_date: Optional[_builtins.str] = None,
                 license_type: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        Properties of sqlManagedInstance.
        :param _builtins.str provisioning_state: The provisioning state of the Arc-enabled SQL Managed Instance resource.
        :param _builtins.str admin: The instance admin user
        :param 'BasicLoginInformationResponse' basic_login_information: Username and password for basic authentication.
        :param _builtins.str cluster_id: If a CustomLocation is provided, this contains the ARM id of the connected cluster the custom location belongs to.
        :param _builtins.str data_controller_id: null
        :param _builtins.str end_time: The instance end time
        :param _builtins.str extension_id: If a CustomLocation is provided, this contains the ARM id of the extension the custom location belongs to.
        :param 'SqlManagedInstanceK8sRawResponse' k8s_raw: The raw kubernetes information
        :param _builtins.str last_uploaded_date: Last uploaded date from Kubernetes cluster. Defaults to current date time
        :param _builtins.str license_type: The license type to apply for this managed instance.
        :param _builtins.str start_time: The instance start time
        """
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if admin is not None:
            pulumi.set(__self__, "admin", admin)
        if basic_login_information is not None:
            pulumi.set(__self__, "basic_login_information", basic_login_information)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if data_controller_id is not None:
            pulumi.set(__self__, "data_controller_id", data_controller_id)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if extension_id is not None:
            pulumi.set(__self__, "extension_id", extension_id)
        if k8s_raw is not None:
            pulumi.set(__self__, "k8s_raw", k8s_raw)
        if last_uploaded_date is not None:
            pulumi.set(__self__, "last_uploaded_date", last_uploaded_date)
        if license_type is None:
            license_type = 'BasePrice'
        if license_type is not None:
            pulumi.set(__self__, "license_type", license_type)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the Arc-enabled SQL Managed Instance resource.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def admin(self) -> Optional[_builtins.str]:
        """
        The instance admin user
        """
        return pulumi.get(self, "admin")

    @_builtins.property
    @pulumi.getter(name="basicLoginInformation")
    def basic_login_information(self) -> Optional['outputs.BasicLoginInformationResponse']:
        """
        Username and password for basic authentication.
        """
        return pulumi.get(self, "basic_login_information")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        """
        If a CustomLocation is provided, this contains the ARM id of the connected cluster the custom location belongs to.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="dataControllerId")
    def data_controller_id(self) -> Optional[_builtins.str]:
        """
        null
        """
        return pulumi.get(self, "data_controller_id")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        The instance end time
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="extensionId")
    def extension_id(self) -> Optional[_builtins.str]:
        """
        If a CustomLocation is provided, this contains the ARM id of the extension the custom location belongs to.
        """
        return pulumi.get(self, "extension_id")

    @_builtins.property
    @pulumi.getter(name="k8sRaw")
    def k8s_raw(self) -> Optional['outputs.SqlManagedInstanceK8sRawResponse']:
        """
        The raw kubernetes information
        """
        return pulumi.get(self, "k8s_raw")

    @_builtins.property
    @pulumi.getter(name="lastUploadedDate")
    def last_uploaded_date(self) -> Optional[_builtins.str]:
        """
        Last uploaded date from Kubernetes cluster. Defaults to current date time
        """
        return pulumi.get(self, "last_uploaded_date")

    @_builtins.property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> Optional[_builtins.str]:
        """
        The license type to apply for this managed instance.
        """
        return pulumi.get(self, "license_type")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        The instance start time
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class SqlManagedInstanceSkuResponse(dict):
    """
    The resource model definition representing SKU for Azure Managed Instance - Azure Arc
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 capacity: Optional[_builtins.int] = None,
                 dev: Optional[_builtins.bool] = None,
                 family: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 tier: Optional[_builtins.str] = None):
        """
        The resource model definition representing SKU for Azure Managed Instance - Azure Arc
        :param _builtins.str name: The name of the SKU.
        :param _builtins.int capacity: The SKU capacity
        :param _builtins.bool dev: Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose. 
        :param _builtins.str family: The SKU family
        :param _builtins.str size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param _builtins.str tier: The pricing tier for the instance.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if dev is None:
            dev = True
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is None:
            tier = 'GeneralPurpose'
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the SKU.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> Optional[_builtins.int]:
        """
        The SKU capacity
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter
    def dev(self) -> Optional[_builtins.bool]:
        """
        Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose. 
        """
        return pulumi.get(self, "dev")

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[_builtins.str]:
        """
        The SKU family
        """
        return pulumi.get(self, "family")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> Optional[_builtins.str]:
        """
        The pricing tier for the instance.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class SqlServerAvailabilityGroupResourcePropertiesResponse(dict):
    """
    The properties of Arc Sql Server availability group resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityGroupId":
            suggest = "availability_group_id"
        elif key == "collectionTimestamp":
            suggest = "collection_timestamp"
        elif key == "instanceName":
            suggest = "instance_name"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlServerAvailabilityGroupResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlServerAvailabilityGroupResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlServerAvailabilityGroupResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_group_id: _builtins.str,
                 collection_timestamp: _builtins.str,
                 instance_name: _builtins.str,
                 provisioning_state: _builtins.str,
                 server_name: _builtins.str,
                 databases: Optional['outputs.SqlServerAvailabilityGroupResourcePropertiesResponseDatabases'] = None,
                 info: Optional['outputs.AvailabilityGroupInfoResponse'] = None,
                 replicas: Optional['outputs.SqlServerAvailabilityGroupResourcePropertiesResponseReplicas'] = None):
        """
        The properties of Arc Sql Server availability group resource
        :param _builtins.str availability_group_id: ID GUID of the availability group.
        :param _builtins.str collection_timestamp: Timestamp for when the data was collected from the client machine.
        :param _builtins.str instance_name: the SQL Server Instance name.
        :param _builtins.str provisioning_state: The provisioning state of the Arc-enabled SQL Server availability group resource.
        :param _builtins.str server_name: the SQL server name.
        :param 'SqlServerAvailabilityGroupResourcePropertiesResponseDatabases' databases: A list of Availability Group Database Replicas.
        :param 'AvailabilityGroupInfoResponse' info: Availability Group Info
        :param 'SqlServerAvailabilityGroupResourcePropertiesResponseReplicas' replicas: A list of Availability Group Replicas.
        """
        pulumi.set(__self__, "availability_group_id", availability_group_id)
        pulumi.set(__self__, "collection_timestamp", collection_timestamp)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "server_name", server_name)
        if databases is not None:
            pulumi.set(__self__, "databases", databases)
        if info is not None:
            pulumi.set(__self__, "info", info)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @_builtins.property
    @pulumi.getter(name="availabilityGroupId")
    def availability_group_id(self) -> _builtins.str:
        """
        ID GUID of the availability group.
        """
        return pulumi.get(self, "availability_group_id")

    @_builtins.property
    @pulumi.getter(name="collectionTimestamp")
    def collection_timestamp(self) -> _builtins.str:
        """
        Timestamp for when the data was collected from the client machine.
        """
        return pulumi.get(self, "collection_timestamp")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        the SQL Server Instance name.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the Arc-enabled SQL Server availability group resource.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="serverName")
    def server_name(self) -> _builtins.str:
        """
        the SQL server name.
        """
        return pulumi.get(self, "server_name")

    @_builtins.property
    @pulumi.getter
    def databases(self) -> Optional['outputs.SqlServerAvailabilityGroupResourcePropertiesResponseDatabases']:
        """
        A list of Availability Group Database Replicas.
        """
        return pulumi.get(self, "databases")

    @_builtins.property
    @pulumi.getter
    def info(self) -> Optional['outputs.AvailabilityGroupInfoResponse']:
        """
        Availability Group Info
        """
        return pulumi.get(self, "info")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional['outputs.SqlServerAvailabilityGroupResourcePropertiesResponseReplicas']:
        """
        A list of Availability Group Replicas.
        """
        return pulumi.get(self, "replicas")


@pulumi.output_type
class SqlServerAvailabilityGroupResourcePropertiesResponseDatabases(dict):
    """
    A list of Availability Group Database Replicas.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextLink":
            suggest = "next_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlServerAvailabilityGroupResourcePropertiesResponseDatabases. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlServerAvailabilityGroupResourcePropertiesResponseDatabases.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlServerAvailabilityGroupResourcePropertiesResponseDatabases.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_link: _builtins.str,
                 value: Optional[Sequence['outputs.SqlAvailabilityGroupDatabaseReplicaResourcePropertiesResponse']] = None):
        """
        A list of Availability Group Database Replicas.
        :param _builtins.str next_link: Link to retrieve next page of results.
        :param Sequence['SqlAvailabilityGroupDatabaseReplicaResourcePropertiesResponse'] value: Array of Availability Group Database Replicas.
        """
        pulumi.set(__self__, "next_link", next_link)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="nextLink")
    def next_link(self) -> _builtins.str:
        """
        Link to retrieve next page of results.
        """
        return pulumi.get(self, "next_link")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[Sequence['outputs.SqlAvailabilityGroupDatabaseReplicaResourcePropertiesResponse']]:
        """
        Array of Availability Group Database Replicas.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlServerAvailabilityGroupResourcePropertiesResponseReplicas(dict):
    """
    A list of Availability Group Replicas.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextLink":
            suggest = "next_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlServerAvailabilityGroupResourcePropertiesResponseReplicas. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlServerAvailabilityGroupResourcePropertiesResponseReplicas.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlServerAvailabilityGroupResourcePropertiesResponseReplicas.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_link: _builtins.str,
                 value: Optional[Sequence['outputs.SqlAvailabilityGroupReplicaResourcePropertiesResponse']] = None):
        """
        A list of Availability Group Replicas.
        :param _builtins.str next_link: Link to retrieve next page of results.
        :param Sequence['SqlAvailabilityGroupReplicaResourcePropertiesResponse'] value: Array of Availability Group Replicas.
        """
        pulumi.set(__self__, "next_link", next_link)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="nextLink")
    def next_link(self) -> _builtins.str:
        """
        Link to retrieve next page of results.
        """
        return pulumi.get(self, "next_link")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[Sequence['outputs.SqlAvailabilityGroupReplicaResourcePropertiesResponse']]:
        """
        Array of Availability Group Replicas.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SqlServerDatabaseResourcePropertiesResponse(dict):
    """
    The properties of Arc Sql Server database resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "earliestRestoreDate":
            suggest = "earliest_restore_date"
        elif key == "lastDatabaseUploadTime":
            suggest = "last_database_upload_time"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "backupInformation":
            suggest = "backup_information"
        elif key == "backupPolicy":
            suggest = "backup_policy"
        elif key == "collationName":
            suggest = "collation_name"
        elif key == "compatibilityLevel":
            suggest = "compatibility_level"
        elif key == "createMode":
            suggest = "create_mode"
        elif key == "databaseCreationDate":
            suggest = "database_creation_date"
        elif key == "databaseOptions":
            suggest = "database_options"
        elif key == "isReadOnly":
            suggest = "is_read_only"
        elif key == "recoveryMode":
            suggest = "recovery_mode"
        elif key == "restorePointInTime":
            suggest = "restore_point_in_time"
        elif key == "sizeMB":
            suggest = "size_mb"
        elif key == "sourceDatabaseId":
            suggest = "source_database_id"
        elif key == "spaceAvailableMB":
            suggest = "space_available_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlServerDatabaseResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlServerDatabaseResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlServerDatabaseResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 earliest_restore_date: _builtins.str,
                 last_database_upload_time: _builtins.str,
                 provisioning_state: _builtins.str,
                 backup_information: Optional['outputs.SqlServerDatabaseResourcePropertiesResponseBackupInformation'] = None,
                 backup_policy: Optional['outputs.BackupPolicyResponse'] = None,
                 collation_name: Optional[_builtins.str] = None,
                 compatibility_level: Optional[_builtins.int] = None,
                 create_mode: Optional[_builtins.str] = None,
                 database_creation_date: Optional[_builtins.str] = None,
                 database_options: Optional['outputs.SqlServerDatabaseResourcePropertiesResponseDatabaseOptions'] = None,
                 is_read_only: Optional[_builtins.bool] = None,
                 recovery_mode: Optional[_builtins.str] = None,
                 restore_point_in_time: Optional[_builtins.str] = None,
                 size_mb: Optional[_builtins.float] = None,
                 source_database_id: Optional[_builtins.str] = None,
                 space_available_mb: Optional[_builtins.float] = None,
                 state: Optional[_builtins.str] = None):
        """
        The properties of Arc Sql Server database resource
        :param _builtins.str earliest_restore_date: This records the earliest start date and time that restore is available for this database (ISO8601 format).
        :param _builtins.str last_database_upload_time: The time when last successful database upload was performed.
        :param _builtins.str provisioning_state: The provisioning state of the Arc-enabled SQL Server database resource.
        :param 'BackupPolicyResponse' backup_policy: The backup profile for the SQL server.
        :param _builtins.str collation_name: Collation of the database.
        :param _builtins.int compatibility_level: Compatibility level of the database
        :param _builtins.str create_mode: Database create mode. PointInTimeRestore: Create a database by restoring a point in time backup of an existing database. sourceDatabaseId and restorePointInTime must be specified.
        :param _builtins.str database_creation_date: Creation date of the database.
        :param 'SqlServerDatabaseResourcePropertiesResponseDatabaseOptions' database_options: List of features that are enabled for the database
        :param _builtins.bool is_read_only: Whether the database is read only or not.
        :param _builtins.str recovery_mode: Status of the database.
        :param _builtins.str restore_point_in_time: Conditional. If createMode is PointInTimeRestore, this value is required. Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database.
        :param _builtins.float size_mb: Size of the database.
        :param _builtins.str source_database_id: The resource identifier of the source database associated with create operation of this database.
        :param _builtins.float space_available_mb: Space left of the database.
        :param _builtins.str state: State of the database.
        """
        pulumi.set(__self__, "earliest_restore_date", earliest_restore_date)
        pulumi.set(__self__, "last_database_upload_time", last_database_upload_time)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if backup_information is not None:
            pulumi.set(__self__, "backup_information", backup_information)
        if backup_policy is not None:
            pulumi.set(__self__, "backup_policy", backup_policy)
        if collation_name is not None:
            pulumi.set(__self__, "collation_name", collation_name)
        if compatibility_level is not None:
            pulumi.set(__self__, "compatibility_level", compatibility_level)
        if create_mode is not None:
            pulumi.set(__self__, "create_mode", create_mode)
        if database_creation_date is not None:
            pulumi.set(__self__, "database_creation_date", database_creation_date)
        if database_options is not None:
            pulumi.set(__self__, "database_options", database_options)
        if is_read_only is not None:
            pulumi.set(__self__, "is_read_only", is_read_only)
        if recovery_mode is not None:
            pulumi.set(__self__, "recovery_mode", recovery_mode)
        if restore_point_in_time is not None:
            pulumi.set(__self__, "restore_point_in_time", restore_point_in_time)
        if size_mb is not None:
            pulumi.set(__self__, "size_mb", size_mb)
        if source_database_id is not None:
            pulumi.set(__self__, "source_database_id", source_database_id)
        if space_available_mb is not None:
            pulumi.set(__self__, "space_available_mb", space_available_mb)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="earliestRestoreDate")
    def earliest_restore_date(self) -> _builtins.str:
        """
        This records the earliest start date and time that restore is available for this database (ISO8601 format).
        """
        return pulumi.get(self, "earliest_restore_date")

    @_builtins.property
    @pulumi.getter(name="lastDatabaseUploadTime")
    def last_database_upload_time(self) -> _builtins.str:
        """
        The time when last successful database upload was performed.
        """
        return pulumi.get(self, "last_database_upload_time")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the Arc-enabled SQL Server database resource.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="backupInformation")
    def backup_information(self) -> Optional['outputs.SqlServerDatabaseResourcePropertiesResponseBackupInformation']:
        return pulumi.get(self, "backup_information")

    @_builtins.property
    @pulumi.getter(name="backupPolicy")
    def backup_policy(self) -> Optional['outputs.BackupPolicyResponse']:
        """
        The backup profile for the SQL server.
        """
        return pulumi.get(self, "backup_policy")

    @_builtins.property
    @pulumi.getter(name="collationName")
    def collation_name(self) -> Optional[_builtins.str]:
        """
        Collation of the database.
        """
        return pulumi.get(self, "collation_name")

    @_builtins.property
    @pulumi.getter(name="compatibilityLevel")
    def compatibility_level(self) -> Optional[_builtins.int]:
        """
        Compatibility level of the database
        """
        return pulumi.get(self, "compatibility_level")

    @_builtins.property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> Optional[_builtins.str]:
        """
        Database create mode. PointInTimeRestore: Create a database by restoring a point in time backup of an existing database. sourceDatabaseId and restorePointInTime must be specified.
        """
        return pulumi.get(self, "create_mode")

    @_builtins.property
    @pulumi.getter(name="databaseCreationDate")
    def database_creation_date(self) -> Optional[_builtins.str]:
        """
        Creation date of the database.
        """
        return pulumi.get(self, "database_creation_date")

    @_builtins.property
    @pulumi.getter(name="databaseOptions")
    def database_options(self) -> Optional['outputs.SqlServerDatabaseResourcePropertiesResponseDatabaseOptions']:
        """
        List of features that are enabled for the database
        """
        return pulumi.get(self, "database_options")

    @_builtins.property
    @pulumi.getter(name="isReadOnly")
    def is_read_only(self) -> Optional[_builtins.bool]:
        """
        Whether the database is read only or not.
        """
        return pulumi.get(self, "is_read_only")

    @_builtins.property
    @pulumi.getter(name="recoveryMode")
    def recovery_mode(self) -> Optional[_builtins.str]:
        """
        Status of the database.
        """
        return pulumi.get(self, "recovery_mode")

    @_builtins.property
    @pulumi.getter(name="restorePointInTime")
    def restore_point_in_time(self) -> Optional[_builtins.str]:
        """
        Conditional. If createMode is PointInTimeRestore, this value is required. Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database.
        """
        return pulumi.get(self, "restore_point_in_time")

    @_builtins.property
    @pulumi.getter(name="sizeMB")
    def size_mb(self) -> Optional[_builtins.float]:
        """
        Size of the database.
        """
        return pulumi.get(self, "size_mb")

    @_builtins.property
    @pulumi.getter(name="sourceDatabaseId")
    def source_database_id(self) -> Optional[_builtins.str]:
        """
        The resource identifier of the source database associated with create operation of this database.
        """
        return pulumi.get(self, "source_database_id")

    @_builtins.property
    @pulumi.getter(name="spaceAvailableMB")
    def space_available_mb(self) -> Optional[_builtins.float]:
        """
        Space left of the database.
        """
        return pulumi.get(self, "space_available_mb")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        State of the database.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class SqlServerDatabaseResourcePropertiesResponseBackupInformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastFullBackup":
            suggest = "last_full_backup"
        elif key == "lastLogBackup":
            suggest = "last_log_backup"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlServerDatabaseResourcePropertiesResponseBackupInformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlServerDatabaseResourcePropertiesResponseBackupInformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlServerDatabaseResourcePropertiesResponseBackupInformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_full_backup: Optional[_builtins.str] = None,
                 last_log_backup: Optional[_builtins.str] = None):
        """
        :param _builtins.str last_full_backup: Date time of last full backup.
        :param _builtins.str last_log_backup: Date time of last log backup.
        """
        if last_full_backup is not None:
            pulumi.set(__self__, "last_full_backup", last_full_backup)
        if last_log_backup is not None:
            pulumi.set(__self__, "last_log_backup", last_log_backup)

    @_builtins.property
    @pulumi.getter(name="lastFullBackup")
    def last_full_backup(self) -> Optional[_builtins.str]:
        """
        Date time of last full backup.
        """
        return pulumi.get(self, "last_full_backup")

    @_builtins.property
    @pulumi.getter(name="lastLogBackup")
    def last_log_backup(self) -> Optional[_builtins.str]:
        """
        Date time of last log backup.
        """
        return pulumi.get(self, "last_log_backup")


@pulumi.output_type
class SqlServerDatabaseResourcePropertiesResponseDatabaseOptions(dict):
    """
    List of features that are enabled for the database
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAutoCloseOn":
            suggest = "is_auto_close_on"
        elif key == "isAutoCreateStatsOn":
            suggest = "is_auto_create_stats_on"
        elif key == "isAutoShrinkOn":
            suggest = "is_auto_shrink_on"
        elif key == "isAutoUpdateStatsOn":
            suggest = "is_auto_update_stats_on"
        elif key == "isEncrypted":
            suggest = "is_encrypted"
        elif key == "isMemoryOptimizationEnabled":
            suggest = "is_memory_optimization_enabled"
        elif key == "isRemoteDataArchiveEnabled":
            suggest = "is_remote_data_archive_enabled"
        elif key == "isTrustworthyOn":
            suggest = "is_trustworthy_on"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlServerDatabaseResourcePropertiesResponseDatabaseOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlServerDatabaseResourcePropertiesResponseDatabaseOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlServerDatabaseResourcePropertiesResponseDatabaseOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_auto_close_on: Optional[_builtins.bool] = None,
                 is_auto_create_stats_on: Optional[_builtins.bool] = None,
                 is_auto_shrink_on: Optional[_builtins.bool] = None,
                 is_auto_update_stats_on: Optional[_builtins.bool] = None,
                 is_encrypted: Optional[_builtins.bool] = None,
                 is_memory_optimization_enabled: Optional[_builtins.bool] = None,
                 is_remote_data_archive_enabled: Optional[_builtins.bool] = None,
                 is_trustworthy_on: Optional[_builtins.bool] = None):
        """
        List of features that are enabled for the database
        """
        if is_auto_close_on is not None:
            pulumi.set(__self__, "is_auto_close_on", is_auto_close_on)
        if is_auto_create_stats_on is not None:
            pulumi.set(__self__, "is_auto_create_stats_on", is_auto_create_stats_on)
        if is_auto_shrink_on is not None:
            pulumi.set(__self__, "is_auto_shrink_on", is_auto_shrink_on)
        if is_auto_update_stats_on is not None:
            pulumi.set(__self__, "is_auto_update_stats_on", is_auto_update_stats_on)
        if is_encrypted is not None:
            pulumi.set(__self__, "is_encrypted", is_encrypted)
        if is_memory_optimization_enabled is not None:
            pulumi.set(__self__, "is_memory_optimization_enabled", is_memory_optimization_enabled)
        if is_remote_data_archive_enabled is not None:
            pulumi.set(__self__, "is_remote_data_archive_enabled", is_remote_data_archive_enabled)
        if is_trustworthy_on is not None:
            pulumi.set(__self__, "is_trustworthy_on", is_trustworthy_on)

    @_builtins.property
    @pulumi.getter(name="isAutoCloseOn")
    def is_auto_close_on(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_auto_close_on")

    @_builtins.property
    @pulumi.getter(name="isAutoCreateStatsOn")
    def is_auto_create_stats_on(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_auto_create_stats_on")

    @_builtins.property
    @pulumi.getter(name="isAutoShrinkOn")
    def is_auto_shrink_on(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_auto_shrink_on")

    @_builtins.property
    @pulumi.getter(name="isAutoUpdateStatsOn")
    def is_auto_update_stats_on(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_auto_update_stats_on")

    @_builtins.property
    @pulumi.getter(name="isEncrypted")
    def is_encrypted(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_encrypted")

    @_builtins.property
    @pulumi.getter(name="isMemoryOptimizationEnabled")
    def is_memory_optimization_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_memory_optimization_enabled")

    @_builtins.property
    @pulumi.getter(name="isRemoteDataArchiveEnabled")
    def is_remote_data_archive_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_remote_data_archive_enabled")

    @_builtins.property
    @pulumi.getter(name="isTrustworthyOn")
    def is_trustworthy_on(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_trustworthy_on")


@pulumi.output_type
class SqlServerEsuLicensePropertiesResponse(dict):
    """
    Properties of SQL Server ESU license.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activatedAt":
            suggest = "activated_at"
        elif key == "activationState":
            suggest = "activation_state"
        elif key == "billingPlan":
            suggest = "billing_plan"
        elif key == "physicalCores":
            suggest = "physical_cores"
        elif key == "scopeType":
            suggest = "scope_type"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "terminatedAt":
            suggest = "terminated_at"
        elif key == "uniqueId":
            suggest = "unique_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlServerEsuLicensePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlServerEsuLicensePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlServerEsuLicensePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activated_at: _builtins.str,
                 activation_state: _builtins.str,
                 billing_plan: _builtins.str,
                 physical_cores: _builtins.int,
                 scope_type: _builtins.str,
                 tenant_id: _builtins.str,
                 terminated_at: _builtins.str,
                 unique_id: _builtins.str,
                 version: _builtins.str):
        """
        Properties of SQL Server ESU license.
        :param _builtins.str activated_at: The timestamp of the activation of the SqlServerEsuLicense in ISO 8601 date-time format.
        :param _builtins.str activation_state: The activation state of the license.
        :param _builtins.str billing_plan: SQL Server ESU license type.
        :param _builtins.int physical_cores: The number of total cores of the license covers.
        :param _builtins.str scope_type: The Azure scope to which the license will apply.
        :param _builtins.str tenant_id: The tenantId the SQL Server ESU license resource subscription resides in.
        :param _builtins.str terminated_at: The timestamp of the termination of the SqlServerEsuLicense in ISO 8601 date-time format.
        :param _builtins.str unique_id: The unique ID of this license. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000).
        :param _builtins.str version: The SQL Server version the license covers.
        """
        pulumi.set(__self__, "activated_at", activated_at)
        pulumi.set(__self__, "activation_state", activation_state)
        pulumi.set(__self__, "billing_plan", billing_plan)
        pulumi.set(__self__, "physical_cores", physical_cores)
        pulumi.set(__self__, "scope_type", scope_type)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "terminated_at", terminated_at)
        pulumi.set(__self__, "unique_id", unique_id)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="activatedAt")
    def activated_at(self) -> _builtins.str:
        """
        The timestamp of the activation of the SqlServerEsuLicense in ISO 8601 date-time format.
        """
        return pulumi.get(self, "activated_at")

    @_builtins.property
    @pulumi.getter(name="activationState")
    def activation_state(self) -> _builtins.str:
        """
        The activation state of the license.
        """
        return pulumi.get(self, "activation_state")

    @_builtins.property
    @pulumi.getter(name="billingPlan")
    def billing_plan(self) -> _builtins.str:
        """
        SQL Server ESU license type.
        """
        return pulumi.get(self, "billing_plan")

    @_builtins.property
    @pulumi.getter(name="physicalCores")
    def physical_cores(self) -> _builtins.int:
        """
        The number of total cores of the license covers.
        """
        return pulumi.get(self, "physical_cores")

    @_builtins.property
    @pulumi.getter(name="scopeType")
    def scope_type(self) -> _builtins.str:
        """
        The Azure scope to which the license will apply.
        """
        return pulumi.get(self, "scope_type")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenantId the SQL Server ESU license resource subscription resides in.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="terminatedAt")
    def terminated_at(self) -> _builtins.str:
        """
        The timestamp of the termination of the SqlServerEsuLicense in ISO 8601 date-time format.
        """
        return pulumi.get(self, "terminated_at")

    @_builtins.property
    @pulumi.getter(name="uniqueId")
    def unique_id(self) -> _builtins.str:
        """
        The unique ID of this license. This is a GUID-formatted string (e.g. 00000000-0000-0000-0000-000000000000).
        """
        return pulumi.get(self, "unique_id")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The SQL Server version the license covers.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SqlServerInstanceJobStatusResponse(dict):
    """
    The status of the job running on the SQL Server instance.
    """
    def __init__(__self__, *,
                 background_job: Optional['outputs.BackgroundJobResponse'] = None,
                 id: Optional[_builtins.str] = None,
                 instance_name: Optional[_builtins.str] = None,
                 job_exception: Optional[_builtins.str] = None,
                 job_status: Optional[_builtins.str] = None,
                 sequencer_actions: Optional[Sequence['outputs.SequencerActionResponse']] = None):
        """
        The status of the job running on the SQL Server instance.
        :param 'BackgroundJobResponse' background_job: The background job details.
        :param _builtins.str id: The unique identifier of the job.
        :param _builtins.str instance_name: The name of the SQL Server instance.
        :param _builtins.str job_exception: The exception message if the job failed.
        :param _builtins.str job_status: The status of the job.
        :param Sequence['SequencerActionResponse'] sequencer_actions: The list of sequencer actions.
        """
        if background_job is not None:
            pulumi.set(__self__, "background_job", background_job)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if job_exception is not None:
            pulumi.set(__self__, "job_exception", job_exception)
        if job_status is not None:
            pulumi.set(__self__, "job_status", job_status)
        if sequencer_actions is not None:
            pulumi.set(__self__, "sequencer_actions", sequencer_actions)

    @_builtins.property
    @pulumi.getter(name="backgroundJob")
    def background_job(self) -> Optional['outputs.BackgroundJobResponse']:
        """
        The background job details.
        """
        return pulumi.get(self, "background_job")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The unique identifier of the job.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[_builtins.str]:
        """
        The name of the SQL Server instance.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="jobException")
    def job_exception(self) -> Optional[_builtins.str]:
        """
        The exception message if the job failed.
        """
        return pulumi.get(self, "job_exception")

    @_builtins.property
    @pulumi.getter(name="jobStatus")
    def job_status(self) -> Optional[_builtins.str]:
        """
        The status of the job.
        """
        return pulumi.get(self, "job_status")

    @_builtins.property
    @pulumi.getter(name="sequencerActions")
    def sequencer_actions(self) -> Optional[Sequence['outputs.SequencerActionResponse']]:
        """
        The list of sequencer actions.
        """
        return pulumi.get(self, "sequencer_actions")


@pulumi.output_type
class SqlServerInstancePropertiesResponse(dict):
    """
    Properties of SqlServerInstance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysOnRole":
            suggest = "always_on_role"
        elif key == "azureDefenderStatus":
            suggest = "azure_defender_status"
        elif key == "azureDefenderStatusLastUpdated":
            suggest = "azure_defender_status_last_updated"
        elif key == "containerResourceId":
            suggest = "container_resource_id"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "currentVersion":
            suggest = "current_version"
        elif key == "lastInventoryUploadTime":
            suggest = "last_inventory_upload_time"
        elif key == "lastUsageUploadTime":
            suggest = "last_usage_upload_time"
        elif key == "licenseType":
            suggest = "license_type"
        elif key == "patchLevel":
            suggest = "patch_level"
        elif key == "productId":
            suggest = "product_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "tcpDynamicPorts":
            suggest = "tcp_dynamic_ports"
        elif key == "tcpStaticPorts":
            suggest = "tcp_static_ports"
        elif key == "vCore":
            suggest = "v_core"
        elif key == "backupPolicy":
            suggest = "backup_policy"
        elif key == "failoverCluster":
            suggest = "failover_cluster"
        elif key == "hostType":
            suggest = "host_type"
        elif key == "instanceName":
            suggest = "instance_name"
        elif key == "upgradeLockedUntil":
            suggest = "upgrade_locked_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlServerInstancePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlServerInstancePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlServerInstancePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_on_role: _builtins.str,
                 azure_defender_status: _builtins.str,
                 azure_defender_status_last_updated: _builtins.str,
                 collation: _builtins.str,
                 container_resource_id: _builtins.str,
                 create_time: _builtins.str,
                 current_version: _builtins.str,
                 last_inventory_upload_time: _builtins.str,
                 last_usage_upload_time: _builtins.str,
                 license_type: _builtins.str,
                 patch_level: _builtins.str,
                 product_id: _builtins.str,
                 provisioning_state: _builtins.str,
                 status: _builtins.str,
                 tcp_dynamic_ports: _builtins.str,
                 tcp_static_ports: _builtins.str,
                 v_core: _builtins.str,
                 backup_policy: Optional['outputs.BackupPolicyResponse'] = None,
                 cores: Optional[_builtins.str] = None,
                 edition: Optional[_builtins.str] = None,
                 failover_cluster: Optional['outputs.FailoverClusterResponse'] = None,
                 host_type: Optional[_builtins.str] = None,
                 instance_name: Optional[_builtins.str] = None,
                 monitoring: Optional['outputs.MonitoringResponse'] = None,
                 upgrade_locked_until: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        Properties of SqlServerInstance.
        :param _builtins.str always_on_role: The role of the SQL Server, based on availability.
        :param _builtins.str azure_defender_status: Status of Azure Defender.
        :param _builtins.str azure_defender_status_last_updated: Timestamp of last Azure Defender status update.
        :param _builtins.str collation: SQL Server collation.
        :param _builtins.str container_resource_id: ARM Resource id of the container resource (Azure Arc for Servers).
        :param _builtins.str create_time: The time when the resource was created.
        :param _builtins.str current_version: SQL Server current version.
        :param _builtins.str last_inventory_upload_time: The time when last successful inventory upload was performed.
        :param _builtins.str last_usage_upload_time: The time when last successful usage upload was performed.
        :param _builtins.str license_type: SQL Server license type.
        :param _builtins.str patch_level: SQL Server update level.
        :param _builtins.str product_id: SQL Server product ID.
        :param _builtins.str provisioning_state: The provisioning state of the Arc-enabled SQL Server resource.
        :param _builtins.str status: The cloud connectivity status.
        :param _builtins.str tcp_dynamic_ports: Dynamic TCP ports used by SQL Server.
        :param _builtins.str tcp_static_ports: Static TCP ports used by SQL Server.
        :param _builtins.str v_core: The number of logical processors used by the SQL Server instance.
        :param 'BackupPolicyResponse' backup_policy: The backup profile for the SQL server.
        :param _builtins.str cores: The number of total cores of the Operating System Environment (OSE) hosting the SQL Server instance.
        :param _builtins.str edition: SQL Server edition.
        :param 'FailoverClusterResponse' failover_cluster: Failover Cluster Instance properties.
        :param _builtins.str host_type: Type of host for Azure Arc SQL Server
        :param _builtins.str instance_name: SQL Server instance name.
        :param 'MonitoringResponse' monitoring: The monitoring configuration.
        :param _builtins.str upgrade_locked_until: Upgrade Action for this resource is locked until it expires. The Expiration time indicated by this value. It is not locked when it is empty.
        :param _builtins.str version: SQL Server version.
        """
        pulumi.set(__self__, "always_on_role", always_on_role)
        pulumi.set(__self__, "azure_defender_status", azure_defender_status)
        pulumi.set(__self__, "azure_defender_status_last_updated", azure_defender_status_last_updated)
        pulumi.set(__self__, "collation", collation)
        pulumi.set(__self__, "container_resource_id", container_resource_id)
        pulumi.set(__self__, "create_time", create_time)
        pulumi.set(__self__, "current_version", current_version)
        pulumi.set(__self__, "last_inventory_upload_time", last_inventory_upload_time)
        pulumi.set(__self__, "last_usage_upload_time", last_usage_upload_time)
        pulumi.set(__self__, "license_type", license_type)
        pulumi.set(__self__, "patch_level", patch_level)
        pulumi.set(__self__, "product_id", product_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tcp_dynamic_ports", tcp_dynamic_ports)
        pulumi.set(__self__, "tcp_static_ports", tcp_static_ports)
        pulumi.set(__self__, "v_core", v_core)
        if backup_policy is not None:
            pulumi.set(__self__, "backup_policy", backup_policy)
        if cores is not None:
            pulumi.set(__self__, "cores", cores)
        if edition is not None:
            pulumi.set(__self__, "edition", edition)
        if failover_cluster is not None:
            pulumi.set(__self__, "failover_cluster", failover_cluster)
        if host_type is not None:
            pulumi.set(__self__, "host_type", host_type)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if upgrade_locked_until is not None:
            pulumi.set(__self__, "upgrade_locked_until", upgrade_locked_until)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="alwaysOnRole")
    def always_on_role(self) -> _builtins.str:
        """
        The role of the SQL Server, based on availability.
        """
        return pulumi.get(self, "always_on_role")

    @_builtins.property
    @pulumi.getter(name="azureDefenderStatus")
    def azure_defender_status(self) -> _builtins.str:
        """
        Status of Azure Defender.
        """
        return pulumi.get(self, "azure_defender_status")

    @_builtins.property
    @pulumi.getter(name="azureDefenderStatusLastUpdated")
    def azure_defender_status_last_updated(self) -> _builtins.str:
        """
        Timestamp of last Azure Defender status update.
        """
        return pulumi.get(self, "azure_defender_status_last_updated")

    @_builtins.property
    @pulumi.getter
    def collation(self) -> _builtins.str:
        """
        SQL Server collation.
        """
        return pulumi.get(self, "collation")

    @_builtins.property
    @pulumi.getter(name="containerResourceId")
    def container_resource_id(self) -> _builtins.str:
        """
        ARM Resource id of the container resource (Azure Arc for Servers).
        """
        return pulumi.get(self, "container_resource_id")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> _builtins.str:
        """
        The time when the resource was created.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="currentVersion")
    def current_version(self) -> _builtins.str:
        """
        SQL Server current version.
        """
        return pulumi.get(self, "current_version")

    @_builtins.property
    @pulumi.getter(name="lastInventoryUploadTime")
    def last_inventory_upload_time(self) -> _builtins.str:
        """
        The time when last successful inventory upload was performed.
        """
        return pulumi.get(self, "last_inventory_upload_time")

    @_builtins.property
    @pulumi.getter(name="lastUsageUploadTime")
    def last_usage_upload_time(self) -> _builtins.str:
        """
        The time when last successful usage upload was performed.
        """
        return pulumi.get(self, "last_usage_upload_time")

    @_builtins.property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> _builtins.str:
        """
        SQL Server license type.
        """
        return pulumi.get(self, "license_type")

    @_builtins.property
    @pulumi.getter(name="patchLevel")
    def patch_level(self) -> _builtins.str:
        """
        SQL Server update level.
        """
        return pulumi.get(self, "patch_level")

    @_builtins.property
    @pulumi.getter(name="productId")
    def product_id(self) -> _builtins.str:
        """
        SQL Server product ID.
        """
        return pulumi.get(self, "product_id")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the Arc-enabled SQL Server resource.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The cloud connectivity status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="tcpDynamicPorts")
    def tcp_dynamic_ports(self) -> _builtins.str:
        """
        Dynamic TCP ports used by SQL Server.
        """
        return pulumi.get(self, "tcp_dynamic_ports")

    @_builtins.property
    @pulumi.getter(name="tcpStaticPorts")
    def tcp_static_ports(self) -> _builtins.str:
        """
        Static TCP ports used by SQL Server.
        """
        return pulumi.get(self, "tcp_static_ports")

    @_builtins.property
    @pulumi.getter(name="vCore")
    def v_core(self) -> _builtins.str:
        """
        The number of logical processors used by the SQL Server instance.
        """
        return pulumi.get(self, "v_core")

    @_builtins.property
    @pulumi.getter(name="backupPolicy")
    def backup_policy(self) -> Optional['outputs.BackupPolicyResponse']:
        """
        The backup profile for the SQL server.
        """
        return pulumi.get(self, "backup_policy")

    @_builtins.property
    @pulumi.getter
    def cores(self) -> Optional[_builtins.str]:
        """
        The number of total cores of the Operating System Environment (OSE) hosting the SQL Server instance.
        """
        return pulumi.get(self, "cores")

    @_builtins.property
    @pulumi.getter
    def edition(self) -> Optional[_builtins.str]:
        """
        SQL Server edition.
        """
        return pulumi.get(self, "edition")

    @_builtins.property
    @pulumi.getter(name="failoverCluster")
    def failover_cluster(self) -> Optional['outputs.FailoverClusterResponse']:
        """
        Failover Cluster Instance properties.
        """
        return pulumi.get(self, "failover_cluster")

    @_builtins.property
    @pulumi.getter(name="hostType")
    def host_type(self) -> Optional[_builtins.str]:
        """
        Type of host for Azure Arc SQL Server
        """
        return pulumi.get(self, "host_type")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[_builtins.str]:
        """
        SQL Server instance name.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional['outputs.MonitoringResponse']:
        """
        The monitoring configuration.
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter(name="upgradeLockedUntil")
    def upgrade_locked_until(self) -> Optional[_builtins.str]:
        """
        Upgrade Action for this resource is locked until it expires. The Expiration time indicated by this value. It is not locked when it is empty.
        """
        return pulumi.get(self, "upgrade_locked_until")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        SQL Server version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SqlServerInstanceTelemetryColumnResponse(dict):
    """
    The telemetry column for the SQL Server instance.
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        The telemetry column for the SQL Server instance.
        :param _builtins.str name: The name of the telemetry column.
        :param _builtins.str type: The type of the telemetry column.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the telemetry column.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the telemetry column.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SqlServerLicensePropertiesResponse(dict):
    """
    Properties of SQL Server License.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activationState":
            suggest = "activation_state"
        elif key == "billingPlan":
            suggest = "billing_plan"
        elif key == "lastActivatedAt":
            suggest = "last_activated_at"
        elif key == "lastDeactivatedAt":
            suggest = "last_deactivated_at"
        elif key == "licenseCategory":
            suggest = "license_category"
        elif key == "physicalCores":
            suggest = "physical_cores"
        elif key == "scopeType":
            suggest = "scope_type"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SqlServerLicensePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SqlServerLicensePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SqlServerLicensePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 activation_state: _builtins.str,
                 billing_plan: _builtins.str,
                 last_activated_at: _builtins.str,
                 last_deactivated_at: _builtins.str,
                 license_category: _builtins.str,
                 physical_cores: _builtins.int,
                 scope_type: _builtins.str,
                 tenant_id: _builtins.str):
        """
        Properties of SQL Server License.
        :param _builtins.str activation_state: The activation state of the license.
        :param _builtins.str billing_plan: SQL Server license type.
        :param _builtins.str last_activated_at: The timestamp of the most recent activation of the SqlServerLicense.
        :param _builtins.str last_deactivated_at: The timestamp of the most recent deactivation of the SqlServerLicense.
        :param _builtins.str license_category: This property represents the choice between SQL Server Core and ESU licenses.
        :param _builtins.int physical_cores: The number of total cores of the license covers.
        :param _builtins.str scope_type: The Azure scope to which the license will apply.
        :param _builtins.str tenant_id: The tenantId the SQL Server license resource subscription resides in.
        """
        pulumi.set(__self__, "activation_state", activation_state)
        pulumi.set(__self__, "billing_plan", billing_plan)
        pulumi.set(__self__, "last_activated_at", last_activated_at)
        pulumi.set(__self__, "last_deactivated_at", last_deactivated_at)
        pulumi.set(__self__, "license_category", license_category)
        pulumi.set(__self__, "physical_cores", physical_cores)
        pulumi.set(__self__, "scope_type", scope_type)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="activationState")
    def activation_state(self) -> _builtins.str:
        """
        The activation state of the license.
        """
        return pulumi.get(self, "activation_state")

    @_builtins.property
    @pulumi.getter(name="billingPlan")
    def billing_plan(self) -> _builtins.str:
        """
        SQL Server license type.
        """
        return pulumi.get(self, "billing_plan")

    @_builtins.property
    @pulumi.getter(name="lastActivatedAt")
    def last_activated_at(self) -> _builtins.str:
        """
        The timestamp of the most recent activation of the SqlServerLicense.
        """
        return pulumi.get(self, "last_activated_at")

    @_builtins.property
    @pulumi.getter(name="lastDeactivatedAt")
    def last_deactivated_at(self) -> _builtins.str:
        """
        The timestamp of the most recent deactivation of the SqlServerLicense.
        """
        return pulumi.get(self, "last_deactivated_at")

    @_builtins.property
    @pulumi.getter(name="licenseCategory")
    def license_category(self) -> _builtins.str:
        """
        This property represents the choice between SQL Server Core and ESU licenses.
        """
        return pulumi.get(self, "license_category")

    @_builtins.property
    @pulumi.getter(name="physicalCores")
    def physical_cores(self) -> _builtins.int:
        """
        The number of total cores of the license covers.
        """
        return pulumi.get(self, "physical_cores")

    @_builtins.property
    @pulumi.getter(name="scopeType")
    def scope_type(self) -> _builtins.str:
        """
        The Azure scope to which the license will apply.
        """
        return pulumi.get(self, "scope_type")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenantId the SQL Server license resource subscription resides in.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UploadServicePrincipalResponse(dict):
    """
    Service principal for uploading billing, metrics and logs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UploadServicePrincipalResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UploadServicePrincipalResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UploadServicePrincipalResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority: Optional[_builtins.str] = None,
                 client_id: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        Service principal for uploading billing, metrics and logs.
        :param _builtins.str authority: Authority for the service principal. Example: https://login.microsoftonline.com/
        :param _builtins.str client_id: Client ID of the service principal for uploading data.
        :param _builtins.str tenant_id: Tenant ID of the service principal.
        """
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter
    def authority(self) -> Optional[_builtins.str]:
        """
        Authority for the service principal. Example: https://login.microsoftonline.com/
        """
        return pulumi.get(self, "authority")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        Client ID of the service principal for uploading data.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        Tenant ID of the service principal.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class UploadWatermarkResponse(dict):
    """
    Properties on upload watermark.  Mostly timestamp for each upload data type
    """
    def __init__(__self__, *,
                 logs: Optional[_builtins.str] = None,
                 metrics: Optional[_builtins.str] = None,
                 usages: Optional[_builtins.str] = None):
        """
        Properties on upload watermark.  Mostly timestamp for each upload data type
        :param _builtins.str logs: Last uploaded date for logs from kubernetes cluster. Defaults to current date time
        :param _builtins.str metrics: Last uploaded date for metrics from kubernetes cluster. Defaults to current date time
        :param _builtins.str usages: Last uploaded date for usages from kubernetes cluster. Defaults to current date time
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if usages is not None:
            pulumi.set(__self__, "usages", usages)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> Optional[_builtins.str]:
        """
        Last uploaded date for logs from kubernetes cluster. Defaults to current date time
        """
        return pulumi.get(self, "logs")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[_builtins.str]:
        """
        Last uploaded date for metrics from kubernetes cluster. Defaults to current date time
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter
    def usages(self) -> Optional[_builtins.str]:
        """
        Last uploaded date for usages from kubernetes cluster. Defaults to current date time
        """
        return pulumi.get(self, "usages")


