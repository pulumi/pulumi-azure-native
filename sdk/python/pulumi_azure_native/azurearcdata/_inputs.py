# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ActiveDirectoryConnectorDNSDetailsArgs',
    'ActiveDirectoryConnectorDNSDetailsArgsDict',
    'ActiveDirectoryConnectorDomainDetailsArgs',
    'ActiveDirectoryConnectorDomainDetailsArgsDict',
    'ActiveDirectoryConnectorPropertiesArgs',
    'ActiveDirectoryConnectorPropertiesArgsDict',
    'ActiveDirectoryConnectorSpecArgs',
    'ActiveDirectoryConnectorSpecArgsDict',
    'ActiveDirectoryConnectorStatusArgs',
    'ActiveDirectoryConnectorStatusArgsDict',
    'ActiveDirectoryDomainControllersArgs',
    'ActiveDirectoryDomainControllersArgsDict',
    'ActiveDirectoryDomainControllerArgs',
    'ActiveDirectoryDomainControllerArgsDict',
    'ActiveDirectoryInformationArgs',
    'ActiveDirectoryInformationArgsDict',
    'AvailabilityGroupConfigureArgs',
    'AvailabilityGroupConfigureArgsDict',
    'AvailabilityGroupInfoArgs',
    'AvailabilityGroupInfoArgsDict',
    'BackupPolicyArgs',
    'BackupPolicyArgsDict',
    'BasicLoginInformationArgs',
    'BasicLoginInformationArgsDict',
    'DataControllerPropertiesArgs',
    'DataControllerPropertiesArgsDict',
    'ExtendedLocationArgs',
    'ExtendedLocationArgsDict',
    'FailoverGroupPropertiesArgs',
    'FailoverGroupPropertiesArgsDict',
    'FailoverGroupSpecArgs',
    'FailoverGroupSpecArgsDict',
    'K8sActiveDirectoryConnectorArgs',
    'K8sActiveDirectoryConnectorArgsDict',
    'K8sActiveDirectoryArgs',
    'K8sActiveDirectoryArgsDict',
    'K8sNetworkSettingsArgs',
    'K8sNetworkSettingsArgsDict',
    'K8sResourceRequirementsArgs',
    'K8sResourceRequirementsArgsDict',
    'K8sSchedulingOptionsArgs',
    'K8sSchedulingOptionsArgsDict',
    'K8sSchedulingArgs',
    'K8sSchedulingArgsDict',
    'K8sSecurityArgs',
    'K8sSecurityArgsDict',
    'K8sSettingsArgs',
    'K8sSettingsArgsDict',
    'K8stransparentDataEncryptionArgs',
    'K8stransparentDataEncryptionArgsDict',
    'KeytabInformationArgs',
    'KeytabInformationArgsDict',
    'LogAnalyticsWorkspaceConfigArgs',
    'LogAnalyticsWorkspaceConfigArgsDict',
    'MonitoringArgs',
    'MonitoringArgsDict',
    'OnPremisePropertyArgs',
    'OnPremisePropertyArgsDict',
    'PostgresInstancePropertiesArgs',
    'PostgresInstancePropertiesArgsDict',
    'PostgresInstanceSkuArgs',
    'PostgresInstanceSkuArgsDict',
    'SqlAvailabilityGroupDatabaseReplicaResourcePropertiesArgs',
    'SqlAvailabilityGroupDatabaseReplicaResourcePropertiesArgsDict',
    'SqlAvailabilityGroupReplicaResourcePropertiesArgs',
    'SqlAvailabilityGroupReplicaResourcePropertiesArgsDict',
    'SqlManagedInstanceK8sRawArgs',
    'SqlManagedInstanceK8sRawArgsDict',
    'SqlManagedInstanceK8sSpecArgs',
    'SqlManagedInstanceK8sSpecArgsDict',
    'SqlManagedInstancePropertiesArgs',
    'SqlManagedInstancePropertiesArgsDict',
    'SqlManagedInstanceSkuArgs',
    'SqlManagedInstanceSkuArgsDict',
    'SqlServerAvailabilityGroupResourcePropertiesDatabasesArgs',
    'SqlServerAvailabilityGroupResourcePropertiesDatabasesArgsDict',
    'SqlServerAvailabilityGroupResourcePropertiesReplicasArgs',
    'SqlServerAvailabilityGroupResourcePropertiesReplicasArgsDict',
    'SqlServerAvailabilityGroupResourcePropertiesArgs',
    'SqlServerAvailabilityGroupResourcePropertiesArgsDict',
    'SqlServerDatabaseResourcePropertiesBackupInformationArgs',
    'SqlServerDatabaseResourcePropertiesBackupInformationArgsDict',
    'SqlServerDatabaseResourcePropertiesDatabaseOptionsArgs',
    'SqlServerDatabaseResourcePropertiesDatabaseOptionsArgsDict',
    'SqlServerDatabaseResourcePropertiesArgs',
    'SqlServerDatabaseResourcePropertiesArgsDict',
    'SqlServerEsuLicensePropertiesArgs',
    'SqlServerEsuLicensePropertiesArgsDict',
    'SqlServerInstancePropertiesArgs',
    'SqlServerInstancePropertiesArgsDict',
    'SqlServerLicensePropertiesArgs',
    'SqlServerLicensePropertiesArgsDict',
    'UploadServicePrincipalArgs',
    'UploadServicePrincipalArgsDict',
    'UploadWatermarkArgs',
    'UploadWatermarkArgsDict',
]

MYPY = False

if not MYPY:
    class ActiveDirectoryConnectorDNSDetailsArgsDict(TypedDict):
        """
        DNS server details
        """
        nameserver_ip_addresses: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        List of Active Directory DNS server IP addresses.
        """
        domain_name: NotRequired[pulumi.Input[builtins.str]]
        """
        DNS domain name for which DNS lookups should be forwarded to the Active Directory DNS servers.
        """
        prefer_k8s_dns_for_ptr_lookups: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag indicating whether to prefer Kubernetes DNS server response over AD DNS server response for IP address lookups.
        """
        replicas: NotRequired[pulumi.Input[builtins.float]]
        """
        Replica count for DNS proxy service. Default value is 1.
        """
elif False:
    ActiveDirectoryConnectorDNSDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActiveDirectoryConnectorDNSDetailsArgs:
    def __init__(__self__, *,
                 nameserver_ip_addresses: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 domain_name: Optional[pulumi.Input[builtins.str]] = None,
                 prefer_k8s_dns_for_ptr_lookups: Optional[pulumi.Input[builtins.bool]] = None,
                 replicas: Optional[pulumi.Input[builtins.float]] = None):
        """
        DNS server details
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] nameserver_ip_addresses: List of Active Directory DNS server IP addresses.
        :param pulumi.Input[builtins.str] domain_name: DNS domain name for which DNS lookups should be forwarded to the Active Directory DNS servers.
        :param pulumi.Input[builtins.bool] prefer_k8s_dns_for_ptr_lookups: Flag indicating whether to prefer Kubernetes DNS server response over AD DNS server response for IP address lookups.
        :param pulumi.Input[builtins.float] replicas: Replica count for DNS proxy service. Default value is 1.
        """
        pulumi.set(__self__, "nameserver_ip_addresses", nameserver_ip_addresses)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if prefer_k8s_dns_for_ptr_lookups is None:
            prefer_k8s_dns_for_ptr_lookups = True
        if prefer_k8s_dns_for_ptr_lookups is not None:
            pulumi.set(__self__, "prefer_k8s_dns_for_ptr_lookups", prefer_k8s_dns_for_ptr_lookups)
        if replicas is None:
            replicas = 1
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter(name="nameserverIPAddresses")
    def nameserver_ip_addresses(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        List of Active Directory DNS server IP addresses.
        """
        return pulumi.get(self, "nameserver_ip_addresses")

    @nameserver_ip_addresses.setter
    def nameserver_ip_addresses(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "nameserver_ip_addresses", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        DNS domain name for which DNS lookups should be forwarded to the Active Directory DNS servers.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="preferK8sDnsForPtrLookups")
    def prefer_k8s_dns_for_ptr_lookups(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag indicating whether to prefer Kubernetes DNS server response over AD DNS server response for IP address lookups.
        """
        return pulumi.get(self, "prefer_k8s_dns_for_ptr_lookups")

    @prefer_k8s_dns_for_ptr_lookups.setter
    def prefer_k8s_dns_for_ptr_lookups(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "prefer_k8s_dns_for_ptr_lookups", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Replica count for DNS proxy service. Default value is 1.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "replicas", value)


if not MYPY:
    class ActiveDirectoryConnectorDomainDetailsArgsDict(TypedDict):
        """
        Active Directory domain details
        """
        realm: pulumi.Input[builtins.str]
        """
        Name (uppercase) of the Active Directory domain that this AD connector will be associated with.
        """
        domain_controllers: NotRequired[pulumi.Input['ActiveDirectoryDomainControllersArgsDict']]
        """
        null
        """
        netbios_domain_name: NotRequired[pulumi.Input[builtins.str]]
        """
        NETBIOS name of the Active Directory domain.
        """
        ou_distinguished_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The distinguished name of the Active Directory Organizational Unit.
        """
        service_account_provisioning: NotRequired[pulumi.Input[Union[builtins.str, 'AccountProvisioningMode']]]
        """
        The service account provisioning mode for this Active Directory connector.
        """
elif False:
    ActiveDirectoryConnectorDomainDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActiveDirectoryConnectorDomainDetailsArgs:
    def __init__(__self__, *,
                 realm: pulumi.Input[builtins.str],
                 domain_controllers: Optional[pulumi.Input['ActiveDirectoryDomainControllersArgs']] = None,
                 netbios_domain_name: Optional[pulumi.Input[builtins.str]] = None,
                 ou_distinguished_name: Optional[pulumi.Input[builtins.str]] = None,
                 service_account_provisioning: Optional[pulumi.Input[Union[builtins.str, 'AccountProvisioningMode']]] = None):
        """
        Active Directory domain details
        :param pulumi.Input[builtins.str] realm: Name (uppercase) of the Active Directory domain that this AD connector will be associated with.
        :param pulumi.Input['ActiveDirectoryDomainControllersArgs'] domain_controllers: null
        :param pulumi.Input[builtins.str] netbios_domain_name: NETBIOS name of the Active Directory domain.
        :param pulumi.Input[builtins.str] ou_distinguished_name: The distinguished name of the Active Directory Organizational Unit.
        :param pulumi.Input[Union[builtins.str, 'AccountProvisioningMode']] service_account_provisioning: The service account provisioning mode for this Active Directory connector.
        """
        pulumi.set(__self__, "realm", realm)
        if domain_controllers is not None:
            pulumi.set(__self__, "domain_controllers", domain_controllers)
        if netbios_domain_name is not None:
            pulumi.set(__self__, "netbios_domain_name", netbios_domain_name)
        if ou_distinguished_name is not None:
            pulumi.set(__self__, "ou_distinguished_name", ou_distinguished_name)
        if service_account_provisioning is None:
            service_account_provisioning = 'manual'
        if service_account_provisioning is not None:
            pulumi.set(__self__, "service_account_provisioning", service_account_provisioning)

    @property
    @pulumi.getter
    def realm(self) -> pulumi.Input[builtins.str]:
        """
        Name (uppercase) of the Active Directory domain that this AD connector will be associated with.
        """
        return pulumi.get(self, "realm")

    @realm.setter
    def realm(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "realm", value)

    @property
    @pulumi.getter(name="domainControllers")
    def domain_controllers(self) -> Optional[pulumi.Input['ActiveDirectoryDomainControllersArgs']]:
        """
        null
        """
        return pulumi.get(self, "domain_controllers")

    @domain_controllers.setter
    def domain_controllers(self, value: Optional[pulumi.Input['ActiveDirectoryDomainControllersArgs']]):
        pulumi.set(self, "domain_controllers", value)

    @property
    @pulumi.getter(name="netbiosDomainName")
    def netbios_domain_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        NETBIOS name of the Active Directory domain.
        """
        return pulumi.get(self, "netbios_domain_name")

    @netbios_domain_name.setter
    def netbios_domain_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "netbios_domain_name", value)

    @property
    @pulumi.getter(name="ouDistinguishedName")
    def ou_distinguished_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The distinguished name of the Active Directory Organizational Unit.
        """
        return pulumi.get(self, "ou_distinguished_name")

    @ou_distinguished_name.setter
    def ou_distinguished_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ou_distinguished_name", value)

    @property
    @pulumi.getter(name="serviceAccountProvisioning")
    def service_account_provisioning(self) -> Optional[pulumi.Input[Union[builtins.str, 'AccountProvisioningMode']]]:
        """
        The service account provisioning mode for this Active Directory connector.
        """
        return pulumi.get(self, "service_account_provisioning")

    @service_account_provisioning.setter
    def service_account_provisioning(self, value: Optional[pulumi.Input[Union[builtins.str, 'AccountProvisioningMode']]]):
        pulumi.set(self, "service_account_provisioning", value)


if not MYPY:
    class ActiveDirectoryConnectorPropertiesArgsDict(TypedDict):
        """
        The properties of an Active Directory connector resource
        """
        spec: pulumi.Input['ActiveDirectoryConnectorSpecArgsDict']
        """
        null
        """
        domain_service_account_login_information: NotRequired[pulumi.Input['BasicLoginInformationArgsDict']]
        """
        Username and password for domain service account authentication.
        """
        status: NotRequired[pulumi.Input['ActiveDirectoryConnectorStatusArgsDict']]
        """
        null
        """
elif False:
    ActiveDirectoryConnectorPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActiveDirectoryConnectorPropertiesArgs:
    def __init__(__self__, *,
                 spec: pulumi.Input['ActiveDirectoryConnectorSpecArgs'],
                 domain_service_account_login_information: Optional[pulumi.Input['BasicLoginInformationArgs']] = None,
                 status: Optional[pulumi.Input['ActiveDirectoryConnectorStatusArgs']] = None):
        """
        The properties of an Active Directory connector resource
        :param pulumi.Input['ActiveDirectoryConnectorSpecArgs'] spec: null
        :param pulumi.Input['BasicLoginInformationArgs'] domain_service_account_login_information: Username and password for domain service account authentication.
        :param pulumi.Input['ActiveDirectoryConnectorStatusArgs'] status: null
        """
        pulumi.set(__self__, "spec", spec)
        if domain_service_account_login_information is not None:
            pulumi.set(__self__, "domain_service_account_login_information", domain_service_account_login_information)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def spec(self) -> pulumi.Input['ActiveDirectoryConnectorSpecArgs']:
        """
        null
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: pulumi.Input['ActiveDirectoryConnectorSpecArgs']):
        pulumi.set(self, "spec", value)

    @property
    @pulumi.getter(name="domainServiceAccountLoginInformation")
    def domain_service_account_login_information(self) -> Optional[pulumi.Input['BasicLoginInformationArgs']]:
        """
        Username and password for domain service account authentication.
        """
        return pulumi.get(self, "domain_service_account_login_information")

    @domain_service_account_login_information.setter
    def domain_service_account_login_information(self, value: Optional[pulumi.Input['BasicLoginInformationArgs']]):
        pulumi.set(self, "domain_service_account_login_information", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['ActiveDirectoryConnectorStatusArgs']]:
        """
        null
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['ActiveDirectoryConnectorStatusArgs']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ActiveDirectoryConnectorSpecArgsDict(TypedDict):
        """
        The specifications of the AD Kubernetes resource.
        """
        active_directory: pulumi.Input['ActiveDirectoryConnectorDomainDetailsArgsDict']
        """
        null
        """
        dns: pulumi.Input['ActiveDirectoryConnectorDNSDetailsArgsDict']
        """
        null
        """
elif False:
    ActiveDirectoryConnectorSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActiveDirectoryConnectorSpecArgs:
    def __init__(__self__, *,
                 active_directory: pulumi.Input['ActiveDirectoryConnectorDomainDetailsArgs'],
                 dns: pulumi.Input['ActiveDirectoryConnectorDNSDetailsArgs']):
        """
        The specifications of the AD Kubernetes resource.
        :param pulumi.Input['ActiveDirectoryConnectorDomainDetailsArgs'] active_directory: null
        :param pulumi.Input['ActiveDirectoryConnectorDNSDetailsArgs'] dns: null
        """
        pulumi.set(__self__, "active_directory", active_directory)
        pulumi.set(__self__, "dns", dns)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> pulumi.Input['ActiveDirectoryConnectorDomainDetailsArgs']:
        """
        null
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: pulumi.Input['ActiveDirectoryConnectorDomainDetailsArgs']):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter
    def dns(self) -> pulumi.Input['ActiveDirectoryConnectorDNSDetailsArgs']:
        """
        null
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: pulumi.Input['ActiveDirectoryConnectorDNSDetailsArgs']):
        pulumi.set(self, "dns", value)


if not MYPY:
    class ActiveDirectoryConnectorStatusArgsDict(TypedDict):
        """
        The status of the Kubernetes custom resource.
        """
        last_update_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The time that the custom resource was last updated.
        """
        observed_generation: NotRequired[pulumi.Input[builtins.float]]
        """
        The version of the replicaSet associated with the AD connector custom resource.
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        The state of the AD connector custom resource.
        """
elif False:
    ActiveDirectoryConnectorStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActiveDirectoryConnectorStatusArgs:
    def __init__(__self__, *,
                 last_update_time: Optional[pulumi.Input[builtins.str]] = None,
                 observed_generation: Optional[pulumi.Input[builtins.float]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None):
        """
        The status of the Kubernetes custom resource.
        :param pulumi.Input[builtins.str] last_update_time: The time that the custom resource was last updated.
        :param pulumi.Input[builtins.float] observed_generation: The version of the replicaSet associated with the AD connector custom resource.
        :param pulumi.Input[builtins.str] state: The state of the AD connector custom resource.
        """
        if last_update_time is not None:
            pulumi.set(__self__, "last_update_time", last_update_time)
        if observed_generation is not None:
            pulumi.set(__self__, "observed_generation", observed_generation)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="lastUpdateTime")
    def last_update_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The time that the custom resource was last updated.
        """
        return pulumi.get(self, "last_update_time")

    @last_update_time.setter
    def last_update_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_update_time", value)

    @property
    @pulumi.getter(name="observedGeneration")
    def observed_generation(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The version of the replicaSet associated with the AD connector custom resource.
        """
        return pulumi.get(self, "observed_generation")

    @observed_generation.setter
    def observed_generation(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "observed_generation", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The state of the AD connector custom resource.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ActiveDirectoryDomainControllersArgsDict(TypedDict):
        """
        Details about the Active Directory domain controllers associated with this AD connector instance
        """
        primary_domain_controller: NotRequired[pulumi.Input['ActiveDirectoryDomainControllerArgsDict']]
        """
        Information about the Primary Domain Controller (PDC) in the AD domain.
        """
        secondary_domain_controllers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ActiveDirectoryDomainControllerArgsDict']]]]
        """
        null
        """
elif False:
    ActiveDirectoryDomainControllersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActiveDirectoryDomainControllersArgs:
    def __init__(__self__, *,
                 primary_domain_controller: Optional[pulumi.Input['ActiveDirectoryDomainControllerArgs']] = None,
                 secondary_domain_controllers: Optional[pulumi.Input[Sequence[pulumi.Input['ActiveDirectoryDomainControllerArgs']]]] = None):
        """
        Details about the Active Directory domain controllers associated with this AD connector instance
        :param pulumi.Input['ActiveDirectoryDomainControllerArgs'] primary_domain_controller: Information about the Primary Domain Controller (PDC) in the AD domain.
        :param pulumi.Input[Sequence[pulumi.Input['ActiveDirectoryDomainControllerArgs']]] secondary_domain_controllers: null
        """
        if primary_domain_controller is not None:
            pulumi.set(__self__, "primary_domain_controller", primary_domain_controller)
        if secondary_domain_controllers is not None:
            pulumi.set(__self__, "secondary_domain_controllers", secondary_domain_controllers)

    @property
    @pulumi.getter(name="primaryDomainController")
    def primary_domain_controller(self) -> Optional[pulumi.Input['ActiveDirectoryDomainControllerArgs']]:
        """
        Information about the Primary Domain Controller (PDC) in the AD domain.
        """
        return pulumi.get(self, "primary_domain_controller")

    @primary_domain_controller.setter
    def primary_domain_controller(self, value: Optional[pulumi.Input['ActiveDirectoryDomainControllerArgs']]):
        pulumi.set(self, "primary_domain_controller", value)

    @property
    @pulumi.getter(name="secondaryDomainControllers")
    def secondary_domain_controllers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActiveDirectoryDomainControllerArgs']]]]:
        """
        null
        """
        return pulumi.get(self, "secondary_domain_controllers")

    @secondary_domain_controllers.setter
    def secondary_domain_controllers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActiveDirectoryDomainControllerArgs']]]]):
        pulumi.set(self, "secondary_domain_controllers", value)


if not MYPY:
    class ActiveDirectoryDomainControllerArgsDict(TypedDict):
        """
        Information about a domain controller in the AD domain.
        """
        hostname: pulumi.Input[builtins.str]
        """
        Fully-qualified domain name of a domain controller in the AD domain.
        """
elif False:
    ActiveDirectoryDomainControllerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActiveDirectoryDomainControllerArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[builtins.str]):
        """
        Information about a domain controller in the AD domain.
        :param pulumi.Input[builtins.str] hostname: Fully-qualified domain name of a domain controller in the AD domain.
        """
        pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[builtins.str]:
        """
        Fully-qualified domain name of a domain controller in the AD domain.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "hostname", value)


if not MYPY:
    class ActiveDirectoryInformationArgsDict(TypedDict):
        """
        Active Directory information that related to the resource.
        """
        keytab_information: NotRequired[pulumi.Input['KeytabInformationArgsDict']]
        """
        Keytab information that is used for the Sql Managed Instance when Active Directory authentication is used.
        """
elif False:
    ActiveDirectoryInformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActiveDirectoryInformationArgs:
    def __init__(__self__, *,
                 keytab_information: Optional[pulumi.Input['KeytabInformationArgs']] = None):
        """
        Active Directory information that related to the resource.
        :param pulumi.Input['KeytabInformationArgs'] keytab_information: Keytab information that is used for the Sql Managed Instance when Active Directory authentication is used.
        """
        if keytab_information is not None:
            pulumi.set(__self__, "keytab_information", keytab_information)

    @property
    @pulumi.getter(name="keytabInformation")
    def keytab_information(self) -> Optional[pulumi.Input['KeytabInformationArgs']]:
        """
        Keytab information that is used for the Sql Managed Instance when Active Directory authentication is used.
        """
        return pulumi.get(self, "keytab_information")

    @keytab_information.setter
    def keytab_information(self, value: Optional[pulumi.Input['KeytabInformationArgs']]):
        pulumi.set(self, "keytab_information", value)


if not MYPY:
    class AvailabilityGroupConfigureArgsDict(TypedDict):
        """
        The specifications of the availability group replica configuration
        """
        backup_priority: NotRequired[pulumi.Input[builtins.int]]
        """
        Represents the user-specified priority for performing backups on this replica relative to the other replicas in the same availability group.
        """
        endpoint_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Mirroring endpoint URL of availability group replica
        """
        read_only_routing_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Connectivity endpoint (URL) of the read only availability replica.
        """
        read_write_routing_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Connectivity endpoint (URL) of the read write availability replica.
        """
        session_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The time-out period of availability group session replica, in seconds.
        """
elif False:
    AvailabilityGroupConfigureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AvailabilityGroupConfigureArgs:
    def __init__(__self__, *,
                 backup_priority: Optional[pulumi.Input[builtins.int]] = None,
                 endpoint_url: Optional[pulumi.Input[builtins.str]] = None,
                 read_only_routing_url: Optional[pulumi.Input[builtins.str]] = None,
                 read_write_routing_url: Optional[pulumi.Input[builtins.str]] = None,
                 session_timeout: Optional[pulumi.Input[builtins.int]] = None):
        """
        The specifications of the availability group replica configuration
        :param pulumi.Input[builtins.int] backup_priority: Represents the user-specified priority for performing backups on this replica relative to the other replicas in the same availability group.
        :param pulumi.Input[builtins.str] endpoint_url: Mirroring endpoint URL of availability group replica
        :param pulumi.Input[builtins.str] read_only_routing_url: Connectivity endpoint (URL) of the read only availability replica.
        :param pulumi.Input[builtins.str] read_write_routing_url: Connectivity endpoint (URL) of the read write availability replica.
        :param pulumi.Input[builtins.int] session_timeout: The time-out period of availability group session replica, in seconds.
        """
        if backup_priority is not None:
            pulumi.set(__self__, "backup_priority", backup_priority)
        if endpoint_url is not None:
            pulumi.set(__self__, "endpoint_url", endpoint_url)
        if read_only_routing_url is not None:
            pulumi.set(__self__, "read_only_routing_url", read_only_routing_url)
        if read_write_routing_url is not None:
            pulumi.set(__self__, "read_write_routing_url", read_write_routing_url)
        if session_timeout is not None:
            pulumi.set(__self__, "session_timeout", session_timeout)

    @property
    @pulumi.getter(name="backupPriority")
    def backup_priority(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Represents the user-specified priority for performing backups on this replica relative to the other replicas in the same availability group.
        """
        return pulumi.get(self, "backup_priority")

    @backup_priority.setter
    def backup_priority(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_priority", value)

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Mirroring endpoint URL of availability group replica
        """
        return pulumi.get(self, "endpoint_url")

    @endpoint_url.setter
    def endpoint_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "endpoint_url", value)

    @property
    @pulumi.getter(name="readOnlyRoutingUrl")
    def read_only_routing_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Connectivity endpoint (URL) of the read only availability replica.
        """
        return pulumi.get(self, "read_only_routing_url")

    @read_only_routing_url.setter
    def read_only_routing_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read_only_routing_url", value)

    @property
    @pulumi.getter(name="readWriteRoutingUrl")
    def read_write_routing_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Connectivity endpoint (URL) of the read write availability replica.
        """
        return pulumi.get(self, "read_write_routing_url")

    @read_write_routing_url.setter
    def read_write_routing_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "read_write_routing_url", value)

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The time-out period of availability group session replica, in seconds.
        """
        return pulumi.get(self, "session_timeout")

    @session_timeout.setter
    def session_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "session_timeout", value)


if not MYPY:
    class AvailabilityGroupInfoArgsDict(TypedDict):
        """
        The specifications of the availability group state
        """
        basic_features: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether this is a basic availability group.
        """
        db_failover: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether the availability group supports failover for database health conditions.
        """
        dtc_support: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether DTC support has been enabled for this availability group.
        """
        failure_condition_level: NotRequired[pulumi.Input[builtins.int]]
        """
        User-defined failure condition level under which an automatic failover must be triggered.
        """
        health_check_timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Wait time (in milliseconds) for the sp_server_diagnostics system stored procedure to return server-health information, before the server instance is assumed to be slow or not responding.
        """
        is_contained: NotRequired[pulumi.Input[builtins.bool]]
        """
        SQL Server availability group contained system databases.
        """
        is_distributed: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether this is a distributed availability group.
        """
        required_synchronized_secondaries_to_commit: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of secondary replicas that must be in a synchronized state for a commit to complete.
        """
elif False:
    AvailabilityGroupInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AvailabilityGroupInfoArgs:
    def __init__(__self__, *,
                 basic_features: Optional[pulumi.Input[builtins.bool]] = None,
                 db_failover: Optional[pulumi.Input[builtins.bool]] = None,
                 dtc_support: Optional[pulumi.Input[builtins.bool]] = None,
                 failure_condition_level: Optional[pulumi.Input[builtins.int]] = None,
                 health_check_timeout: Optional[pulumi.Input[builtins.int]] = None,
                 is_contained: Optional[pulumi.Input[builtins.bool]] = None,
                 is_distributed: Optional[pulumi.Input[builtins.bool]] = None,
                 required_synchronized_secondaries_to_commit: Optional[pulumi.Input[builtins.int]] = None):
        """
        The specifications of the availability group state
        :param pulumi.Input[builtins.bool] basic_features: Specifies whether this is a basic availability group.
        :param pulumi.Input[builtins.bool] db_failover: Specifies whether the availability group supports failover for database health conditions.
        :param pulumi.Input[builtins.bool] dtc_support: Specifies whether DTC support has been enabled for this availability group.
        :param pulumi.Input[builtins.int] failure_condition_level: User-defined failure condition level under which an automatic failover must be triggered.
        :param pulumi.Input[builtins.int] health_check_timeout: Wait time (in milliseconds) for the sp_server_diagnostics system stored procedure to return server-health information, before the server instance is assumed to be slow or not responding.
        :param pulumi.Input[builtins.bool] is_contained: SQL Server availability group contained system databases.
        :param pulumi.Input[builtins.bool] is_distributed: Specifies whether this is a distributed availability group.
        :param pulumi.Input[builtins.int] required_synchronized_secondaries_to_commit: The number of secondary replicas that must be in a synchronized state for a commit to complete.
        """
        if basic_features is not None:
            pulumi.set(__self__, "basic_features", basic_features)
        if db_failover is not None:
            pulumi.set(__self__, "db_failover", db_failover)
        if dtc_support is not None:
            pulumi.set(__self__, "dtc_support", dtc_support)
        if failure_condition_level is not None:
            pulumi.set(__self__, "failure_condition_level", failure_condition_level)
        if health_check_timeout is not None:
            pulumi.set(__self__, "health_check_timeout", health_check_timeout)
        if is_contained is not None:
            pulumi.set(__self__, "is_contained", is_contained)
        if is_distributed is not None:
            pulumi.set(__self__, "is_distributed", is_distributed)
        if required_synchronized_secondaries_to_commit is not None:
            pulumi.set(__self__, "required_synchronized_secondaries_to_commit", required_synchronized_secondaries_to_commit)

    @property
    @pulumi.getter(name="basicFeatures")
    def basic_features(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether this is a basic availability group.
        """
        return pulumi.get(self, "basic_features")

    @basic_features.setter
    def basic_features(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "basic_features", value)

    @property
    @pulumi.getter(name="dbFailover")
    def db_failover(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether the availability group supports failover for database health conditions.
        """
        return pulumi.get(self, "db_failover")

    @db_failover.setter
    def db_failover(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "db_failover", value)

    @property
    @pulumi.getter(name="dtcSupport")
    def dtc_support(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether DTC support has been enabled for this availability group.
        """
        return pulumi.get(self, "dtc_support")

    @dtc_support.setter
    def dtc_support(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "dtc_support", value)

    @property
    @pulumi.getter(name="failureConditionLevel")
    def failure_condition_level(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        User-defined failure condition level under which an automatic failover must be triggered.
        """
        return pulumi.get(self, "failure_condition_level")

    @failure_condition_level.setter
    def failure_condition_level(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "failure_condition_level", value)

    @property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Wait time (in milliseconds) for the sp_server_diagnostics system stored procedure to return server-health information, before the server instance is assumed to be slow or not responding.
        """
        return pulumi.get(self, "health_check_timeout")

    @health_check_timeout.setter
    def health_check_timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "health_check_timeout", value)

    @property
    @pulumi.getter(name="isContained")
    def is_contained(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        SQL Server availability group contained system databases.
        """
        return pulumi.get(self, "is_contained")

    @is_contained.setter
    def is_contained(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_contained", value)

    @property
    @pulumi.getter(name="isDistributed")
    def is_distributed(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether this is a distributed availability group.
        """
        return pulumi.get(self, "is_distributed")

    @is_distributed.setter
    def is_distributed(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_distributed", value)

    @property
    @pulumi.getter(name="requiredSynchronizedSecondariesToCommit")
    def required_synchronized_secondaries_to_commit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of secondary replicas that must be in a synchronized state for a commit to complete.
        """
        return pulumi.get(self, "required_synchronized_secondaries_to_commit")

    @required_synchronized_secondaries_to_commit.setter
    def required_synchronized_secondaries_to_commit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "required_synchronized_secondaries_to_commit", value)


if not MYPY:
    class BackupPolicyArgsDict(TypedDict):
        """
        The backup profile for the SQL server.
        """
        differential_backup_hours: NotRequired[pulumi.Input[builtins.int]]
        """
        The differential backup interval in hours.
        """
        full_backup_days: NotRequired[pulumi.Input[builtins.int]]
        """
        The value indicating days between full backups.
        """
        retention_period_days: NotRequired[pulumi.Input[builtins.int]]
        """
        The retention period for all the databases in this managed instance.
        """
        transaction_log_backup_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        The value indicating minutes between transaction log backups.
        """
elif False:
    BackupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPolicyArgs:
    def __init__(__self__, *,
                 differential_backup_hours: Optional[pulumi.Input[builtins.int]] = None,
                 full_backup_days: Optional[pulumi.Input[builtins.int]] = None,
                 retention_period_days: Optional[pulumi.Input[builtins.int]] = None,
                 transaction_log_backup_minutes: Optional[pulumi.Input[builtins.int]] = None):
        """
        The backup profile for the SQL server.
        :param pulumi.Input[builtins.int] differential_backup_hours: The differential backup interval in hours.
        :param pulumi.Input[builtins.int] full_backup_days: The value indicating days between full backups.
        :param pulumi.Input[builtins.int] retention_period_days: The retention period for all the databases in this managed instance.
        :param pulumi.Input[builtins.int] transaction_log_backup_minutes: The value indicating minutes between transaction log backups.
        """
        if differential_backup_hours is not None:
            pulumi.set(__self__, "differential_backup_hours", differential_backup_hours)
        if full_backup_days is not None:
            pulumi.set(__self__, "full_backup_days", full_backup_days)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)
        if transaction_log_backup_minutes is not None:
            pulumi.set(__self__, "transaction_log_backup_minutes", transaction_log_backup_minutes)

    @property
    @pulumi.getter(name="differentialBackupHours")
    def differential_backup_hours(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The differential backup interval in hours.
        """
        return pulumi.get(self, "differential_backup_hours")

    @differential_backup_hours.setter
    def differential_backup_hours(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "differential_backup_hours", value)

    @property
    @pulumi.getter(name="fullBackupDays")
    def full_backup_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The value indicating days between full backups.
        """
        return pulumi.get(self, "full_backup_days")

    @full_backup_days.setter
    def full_backup_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "full_backup_days", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The retention period for all the databases in this managed instance.
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retention_period_days", value)

    @property
    @pulumi.getter(name="transactionLogBackupMinutes")
    def transaction_log_backup_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The value indicating minutes between transaction log backups.
        """
        return pulumi.get(self, "transaction_log_backup_minutes")

    @transaction_log_backup_minutes.setter
    def transaction_log_backup_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "transaction_log_backup_minutes", value)


if not MYPY:
    class BasicLoginInformationArgsDict(TypedDict):
        """
        Username and password for basic login authentication.
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Login password.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Login username.
        """
elif False:
    BasicLoginInformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BasicLoginInformationArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        Username and password for basic login authentication.
        :param pulumi.Input[builtins.str] password: Login password.
        :param pulumi.Input[builtins.str] username: Login username.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Login password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Login username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class DataControllerPropertiesArgsDict(TypedDict):
        """
        The data controller properties.
        """
        basic_login_information: NotRequired[pulumi.Input['BasicLoginInformationArgsDict']]
        """
        Deprecated. Azure Arc Data Services data controller no longer expose any endpoint. All traffic are exposed through Kubernetes native API.
        """
        cluster_id: NotRequired[pulumi.Input[builtins.str]]
        """
        If a CustomLocation is provided, this contains the ARM id of the connected cluster the custom location belongs to.
        """
        extension_id: NotRequired[pulumi.Input[builtins.str]]
        """
        If a CustomLocation is provided, this contains the ARM id of the extension the custom location belongs to.
        """
        infrastructure: NotRequired[pulumi.Input['Infrastructure']]
        """
        The infrastructure the data controller is running on.
        """
        k8s_raw: NotRequired[Any]
        """
        The raw kubernetes information
        """
        last_uploaded_date: NotRequired[pulumi.Input[builtins.str]]
        """
        Last uploaded date from Kubernetes cluster. Defaults to current date time
        """
        log_analytics_workspace_config: NotRequired[pulumi.Input['LogAnalyticsWorkspaceConfigArgsDict']]
        """
        Log analytics workspace id and primary key
        """
        logs_dashboard_credential: NotRequired[pulumi.Input['BasicLoginInformationArgsDict']]
        """
        Login credential for logs dashboard on the Kubernetes cluster.
        """
        metrics_dashboard_credential: NotRequired[pulumi.Input['BasicLoginInformationArgsDict']]
        """
        Login credential for metrics dashboard on the Kubernetes cluster.
        """
        on_premise_property: NotRequired[pulumi.Input['OnPremisePropertyArgsDict']]
        """
        Properties from the Kubernetes data controller
        """
        upload_service_principal: NotRequired[pulumi.Input['UploadServicePrincipalArgsDict']]
        """
        Deprecated. Service principal is deprecated in favor of Arc Kubernetes service extension managed identity.
        """
        upload_watermark: NotRequired[pulumi.Input['UploadWatermarkArgsDict']]
        """
        Properties on upload watermark.  Mostly timestamp for each upload data type
        """
elif False:
    DataControllerPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataControllerPropertiesArgs:
    def __init__(__self__, *,
                 basic_login_information: Optional[pulumi.Input['BasicLoginInformationArgs']] = None,
                 cluster_id: Optional[pulumi.Input[builtins.str]] = None,
                 extension_id: Optional[pulumi.Input[builtins.str]] = None,
                 infrastructure: Optional[pulumi.Input['Infrastructure']] = None,
                 k8s_raw: Optional[Any] = None,
                 last_uploaded_date: Optional[pulumi.Input[builtins.str]] = None,
                 log_analytics_workspace_config: Optional[pulumi.Input['LogAnalyticsWorkspaceConfigArgs']] = None,
                 logs_dashboard_credential: Optional[pulumi.Input['BasicLoginInformationArgs']] = None,
                 metrics_dashboard_credential: Optional[pulumi.Input['BasicLoginInformationArgs']] = None,
                 on_premise_property: Optional[pulumi.Input['OnPremisePropertyArgs']] = None,
                 upload_service_principal: Optional[pulumi.Input['UploadServicePrincipalArgs']] = None,
                 upload_watermark: Optional[pulumi.Input['UploadWatermarkArgs']] = None):
        """
        The data controller properties.
        :param pulumi.Input['BasicLoginInformationArgs'] basic_login_information: Deprecated. Azure Arc Data Services data controller no longer expose any endpoint. All traffic are exposed through Kubernetes native API.
        :param pulumi.Input[builtins.str] cluster_id: If a CustomLocation is provided, this contains the ARM id of the connected cluster the custom location belongs to.
        :param pulumi.Input[builtins.str] extension_id: If a CustomLocation is provided, this contains the ARM id of the extension the custom location belongs to.
        :param pulumi.Input['Infrastructure'] infrastructure: The infrastructure the data controller is running on.
        :param Any k8s_raw: The raw kubernetes information
        :param pulumi.Input[builtins.str] last_uploaded_date: Last uploaded date from Kubernetes cluster. Defaults to current date time
        :param pulumi.Input['LogAnalyticsWorkspaceConfigArgs'] log_analytics_workspace_config: Log analytics workspace id and primary key
        :param pulumi.Input['BasicLoginInformationArgs'] logs_dashboard_credential: Login credential for logs dashboard on the Kubernetes cluster.
        :param pulumi.Input['BasicLoginInformationArgs'] metrics_dashboard_credential: Login credential for metrics dashboard on the Kubernetes cluster.
        :param pulumi.Input['OnPremisePropertyArgs'] on_premise_property: Properties from the Kubernetes data controller
        :param pulumi.Input['UploadServicePrincipalArgs'] upload_service_principal: Deprecated. Service principal is deprecated in favor of Arc Kubernetes service extension managed identity.
        :param pulumi.Input['UploadWatermarkArgs'] upload_watermark: Properties on upload watermark.  Mostly timestamp for each upload data type
        """
        if basic_login_information is not None:
            pulumi.set(__self__, "basic_login_information", basic_login_information)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if extension_id is not None:
            pulumi.set(__self__, "extension_id", extension_id)
        if infrastructure is None:
            infrastructure = 'other'
        if infrastructure is not None:
            pulumi.set(__self__, "infrastructure", infrastructure)
        if k8s_raw is not None:
            pulumi.set(__self__, "k8s_raw", k8s_raw)
        if last_uploaded_date is not None:
            pulumi.set(__self__, "last_uploaded_date", last_uploaded_date)
        if log_analytics_workspace_config is not None:
            pulumi.set(__self__, "log_analytics_workspace_config", log_analytics_workspace_config)
        if logs_dashboard_credential is not None:
            pulumi.set(__self__, "logs_dashboard_credential", logs_dashboard_credential)
        if metrics_dashboard_credential is not None:
            pulumi.set(__self__, "metrics_dashboard_credential", metrics_dashboard_credential)
        if on_premise_property is not None:
            pulumi.set(__self__, "on_premise_property", on_premise_property)
        if upload_service_principal is not None:
            pulumi.set(__self__, "upload_service_principal", upload_service_principal)
        if upload_watermark is not None:
            pulumi.set(__self__, "upload_watermark", upload_watermark)

    @property
    @pulumi.getter(name="basicLoginInformation")
    def basic_login_information(self) -> Optional[pulumi.Input['BasicLoginInformationArgs']]:
        """
        Deprecated. Azure Arc Data Services data controller no longer expose any endpoint. All traffic are exposed through Kubernetes native API.
        """
        return pulumi.get(self, "basic_login_information")

    @basic_login_information.setter
    def basic_login_information(self, value: Optional[pulumi.Input['BasicLoginInformationArgs']]):
        pulumi.set(self, "basic_login_information", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If a CustomLocation is provided, this contains the ARM id of the connected cluster the custom location belongs to.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="extensionId")
    def extension_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If a CustomLocation is provided, this contains the ARM id of the extension the custom location belongs to.
        """
        return pulumi.get(self, "extension_id")

    @extension_id.setter
    def extension_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "extension_id", value)

    @property
    @pulumi.getter
    def infrastructure(self) -> Optional[pulumi.Input['Infrastructure']]:
        """
        The infrastructure the data controller is running on.
        """
        return pulumi.get(self, "infrastructure")

    @infrastructure.setter
    def infrastructure(self, value: Optional[pulumi.Input['Infrastructure']]):
        pulumi.set(self, "infrastructure", value)

    @property
    @pulumi.getter(name="k8sRaw")
    def k8s_raw(self) -> Optional[Any]:
        """
        The raw kubernetes information
        """
        return pulumi.get(self, "k8s_raw")

    @k8s_raw.setter
    def k8s_raw(self, value: Optional[Any]):
        pulumi.set(self, "k8s_raw", value)

    @property
    @pulumi.getter(name="lastUploadedDate")
    def last_uploaded_date(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last uploaded date from Kubernetes cluster. Defaults to current date time
        """
        return pulumi.get(self, "last_uploaded_date")

    @last_uploaded_date.setter
    def last_uploaded_date(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_uploaded_date", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceConfig")
    def log_analytics_workspace_config(self) -> Optional[pulumi.Input['LogAnalyticsWorkspaceConfigArgs']]:
        """
        Log analytics workspace id and primary key
        """
        return pulumi.get(self, "log_analytics_workspace_config")

    @log_analytics_workspace_config.setter
    def log_analytics_workspace_config(self, value: Optional[pulumi.Input['LogAnalyticsWorkspaceConfigArgs']]):
        pulumi.set(self, "log_analytics_workspace_config", value)

    @property
    @pulumi.getter(name="logsDashboardCredential")
    def logs_dashboard_credential(self) -> Optional[pulumi.Input['BasicLoginInformationArgs']]:
        """
        Login credential for logs dashboard on the Kubernetes cluster.
        """
        return pulumi.get(self, "logs_dashboard_credential")

    @logs_dashboard_credential.setter
    def logs_dashboard_credential(self, value: Optional[pulumi.Input['BasicLoginInformationArgs']]):
        pulumi.set(self, "logs_dashboard_credential", value)

    @property
    @pulumi.getter(name="metricsDashboardCredential")
    def metrics_dashboard_credential(self) -> Optional[pulumi.Input['BasicLoginInformationArgs']]:
        """
        Login credential for metrics dashboard on the Kubernetes cluster.
        """
        return pulumi.get(self, "metrics_dashboard_credential")

    @metrics_dashboard_credential.setter
    def metrics_dashboard_credential(self, value: Optional[pulumi.Input['BasicLoginInformationArgs']]):
        pulumi.set(self, "metrics_dashboard_credential", value)

    @property
    @pulumi.getter(name="onPremiseProperty")
    def on_premise_property(self) -> Optional[pulumi.Input['OnPremisePropertyArgs']]:
        """
        Properties from the Kubernetes data controller
        """
        return pulumi.get(self, "on_premise_property")

    @on_premise_property.setter
    def on_premise_property(self, value: Optional[pulumi.Input['OnPremisePropertyArgs']]):
        pulumi.set(self, "on_premise_property", value)

    @property
    @pulumi.getter(name="uploadServicePrincipal")
    def upload_service_principal(self) -> Optional[pulumi.Input['UploadServicePrincipalArgs']]:
        """
        Deprecated. Service principal is deprecated in favor of Arc Kubernetes service extension managed identity.
        """
        return pulumi.get(self, "upload_service_principal")

    @upload_service_principal.setter
    def upload_service_principal(self, value: Optional[pulumi.Input['UploadServicePrincipalArgs']]):
        pulumi.set(self, "upload_service_principal", value)

    @property
    @pulumi.getter(name="uploadWatermark")
    def upload_watermark(self) -> Optional[pulumi.Input['UploadWatermarkArgs']]:
        """
        Properties on upload watermark.  Mostly timestamp for each upload data type
        """
        return pulumi.get(self, "upload_watermark")

    @upload_watermark.setter
    def upload_watermark(self, value: Optional[pulumi.Input['UploadWatermarkArgs']]):
        pulumi.set(self, "upload_watermark", value)


if not MYPY:
    class ExtendedLocationArgsDict(TypedDict):
        """
        The complex type of the extended location.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the extended location.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']]]
        """
        The type of the extended location.
        """
elif False:
    ExtendedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtendedLocationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']]] = None):
        """
        The complex type of the extended location.
        :param pulumi.Input[builtins.str] name: The name of the extended location.
        :param pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']] type: The type of the extended location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']]]:
        """
        The type of the extended location.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FailoverGroupPropertiesArgsDict(TypedDict):
        """
        The properties of a failover group resource.
        """
        partner_managed_instance_id: pulumi.Input[builtins.str]
        """
        The resource ID of the partner SQL managed instance.
        """
        spec: pulumi.Input['FailoverGroupSpecArgsDict']
        """
        The specifications of the failover group resource.
        """
        status: NotRequired[Any]
        """
        The status of the failover group custom resource.
        """
elif False:
    FailoverGroupPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FailoverGroupPropertiesArgs:
    def __init__(__self__, *,
                 partner_managed_instance_id: pulumi.Input[builtins.str],
                 spec: pulumi.Input['FailoverGroupSpecArgs'],
                 status: Optional[Any] = None):
        """
        The properties of a failover group resource.
        :param pulumi.Input[builtins.str] partner_managed_instance_id: The resource ID of the partner SQL managed instance.
        :param pulumi.Input['FailoverGroupSpecArgs'] spec: The specifications of the failover group resource.
        :param Any status: The status of the failover group custom resource.
        """
        pulumi.set(__self__, "partner_managed_instance_id", partner_managed_instance_id)
        pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="partnerManagedInstanceId")
    def partner_managed_instance_id(self) -> pulumi.Input[builtins.str]:
        """
        The resource ID of the partner SQL managed instance.
        """
        return pulumi.get(self, "partner_managed_instance_id")

    @partner_managed_instance_id.setter
    def partner_managed_instance_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "partner_managed_instance_id", value)

    @property
    @pulumi.getter
    def spec(self) -> pulumi.Input['FailoverGroupSpecArgs']:
        """
        The specifications of the failover group resource.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: pulumi.Input['FailoverGroupSpecArgs']):
        pulumi.set(self, "spec", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[Any]:
        """
        The status of the failover group custom resource.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[Any]):
        pulumi.set(self, "status", value)


if not MYPY:
    class FailoverGroupSpecArgsDict(TypedDict):
        """
        The specifications of the failover group resource.
        """
        role: pulumi.Input[Union[builtins.str, 'InstanceFailoverGroupRole']]
        """
        The role of the SQL managed instance in this failover group.
        """
        partner_mi: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the partner SQL managed instance.
        """
        partner_mirroring_cert: NotRequired[pulumi.Input[builtins.str]]
        """
        The mirroring endpoint public certificate for the partner SQL managed instance. Only PEM format is supported.
        """
        partner_mirroring_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The mirroring endpoint URL of the partner SQL managed instance.
        """
        partner_sync_mode: NotRequired[pulumi.Input[Union[builtins.str, 'FailoverGroupPartnerSyncMode']]]
        """
        The partner sync mode of the SQL managed instance.
        """
        shared_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The shared name of the failover group for this SQL managed instance. Both SQL managed instance and its partner have to use the same shared name.
        """
        source_mi: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the SQL managed instance with this failover group role.
        """
elif False:
    FailoverGroupSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FailoverGroupSpecArgs:
    def __init__(__self__, *,
                 role: Optional[pulumi.Input[Union[builtins.str, 'InstanceFailoverGroupRole']]] = None,
                 partner_mi: Optional[pulumi.Input[builtins.str]] = None,
                 partner_mirroring_cert: Optional[pulumi.Input[builtins.str]] = None,
                 partner_mirroring_url: Optional[pulumi.Input[builtins.str]] = None,
                 partner_sync_mode: Optional[pulumi.Input[Union[builtins.str, 'FailoverGroupPartnerSyncMode']]] = None,
                 shared_name: Optional[pulumi.Input[builtins.str]] = None,
                 source_mi: Optional[pulumi.Input[builtins.str]] = None):
        """
        The specifications of the failover group resource.
        :param pulumi.Input[Union[builtins.str, 'InstanceFailoverGroupRole']] role: The role of the SQL managed instance in this failover group.
        :param pulumi.Input[builtins.str] partner_mi: The name of the partner SQL managed instance.
        :param pulumi.Input[builtins.str] partner_mirroring_cert: The mirroring endpoint public certificate for the partner SQL managed instance. Only PEM format is supported.
        :param pulumi.Input[builtins.str] partner_mirroring_url: The mirroring endpoint URL of the partner SQL managed instance.
        :param pulumi.Input[Union[builtins.str, 'FailoverGroupPartnerSyncMode']] partner_sync_mode: The partner sync mode of the SQL managed instance.
        :param pulumi.Input[builtins.str] shared_name: The shared name of the failover group for this SQL managed instance. Both SQL managed instance and its partner have to use the same shared name.
        :param pulumi.Input[builtins.str] source_mi: The name of the SQL managed instance with this failover group role.
        """
        if role is None:
            role = 'primary'
        pulumi.set(__self__, "role", role)
        if partner_mi is not None:
            pulumi.set(__self__, "partner_mi", partner_mi)
        if partner_mirroring_cert is not None:
            pulumi.set(__self__, "partner_mirroring_cert", partner_mirroring_cert)
        if partner_mirroring_url is not None:
            pulumi.set(__self__, "partner_mirroring_url", partner_mirroring_url)
        if partner_sync_mode is None:
            partner_sync_mode = 'async'
        if partner_sync_mode is not None:
            pulumi.set(__self__, "partner_sync_mode", partner_sync_mode)
        if shared_name is not None:
            pulumi.set(__self__, "shared_name", shared_name)
        if source_mi is not None:
            pulumi.set(__self__, "source_mi", source_mi)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[Union[builtins.str, 'InstanceFailoverGroupRole']]:
        """
        The role of the SQL managed instance in this failover group.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[Union[builtins.str, 'InstanceFailoverGroupRole']]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="partnerMI")
    def partner_mi(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the partner SQL managed instance.
        """
        return pulumi.get(self, "partner_mi")

    @partner_mi.setter
    def partner_mi(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "partner_mi", value)

    @property
    @pulumi.getter(name="partnerMirroringCert")
    def partner_mirroring_cert(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The mirroring endpoint public certificate for the partner SQL managed instance. Only PEM format is supported.
        """
        return pulumi.get(self, "partner_mirroring_cert")

    @partner_mirroring_cert.setter
    def partner_mirroring_cert(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "partner_mirroring_cert", value)

    @property
    @pulumi.getter(name="partnerMirroringURL")
    def partner_mirroring_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The mirroring endpoint URL of the partner SQL managed instance.
        """
        return pulumi.get(self, "partner_mirroring_url")

    @partner_mirroring_url.setter
    def partner_mirroring_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "partner_mirroring_url", value)

    @property
    @pulumi.getter(name="partnerSyncMode")
    def partner_sync_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'FailoverGroupPartnerSyncMode']]]:
        """
        The partner sync mode of the SQL managed instance.
        """
        return pulumi.get(self, "partner_sync_mode")

    @partner_sync_mode.setter
    def partner_sync_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'FailoverGroupPartnerSyncMode']]]):
        pulumi.set(self, "partner_sync_mode", value)

    @property
    @pulumi.getter(name="sharedName")
    def shared_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The shared name of the failover group for this SQL managed instance. Both SQL managed instance and its partner have to use the same shared name.
        """
        return pulumi.get(self, "shared_name")

    @shared_name.setter
    def shared_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "shared_name", value)

    @property
    @pulumi.getter(name="sourceMI")
    def source_mi(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the SQL managed instance with this failover group role.
        """
        return pulumi.get(self, "source_mi")

    @source_mi.setter
    def source_mi(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_mi", value)


if not MYPY:
    class K8sActiveDirectoryConnectorArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the connector
        """
        namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        Name space of the connector
        """
elif False:
    K8sActiveDirectoryConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class K8sActiveDirectoryConnectorArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the connector
        :param pulumi.Input[builtins.str] namespace: Name space of the connector
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the connector
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name space of the connector
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class K8sActiveDirectoryArgsDict(TypedDict):
        """
        The kubernetes active directory information.
        """
        account_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Account name for AAD
        """
        connector: NotRequired[pulumi.Input['K8sActiveDirectoryConnectorArgsDict']]
        encryption_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        An array of encryption types
        """
        keytab_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Keytab secret used to authenticate with Active Directory.
        """
elif False:
    K8sActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class K8sActiveDirectoryArgs:
    def __init__(__self__, *,
                 account_name: Optional[pulumi.Input[builtins.str]] = None,
                 connector: Optional[pulumi.Input['K8sActiveDirectoryConnectorArgs']] = None,
                 encryption_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 keytab_secret: Optional[pulumi.Input[builtins.str]] = None):
        """
        The kubernetes active directory information.
        :param pulumi.Input[builtins.str] account_name: Account name for AAD
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] encryption_types: An array of encryption types
        :param pulumi.Input[builtins.str] keytab_secret: Keytab secret used to authenticate with Active Directory.
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if connector is not None:
            pulumi.set(__self__, "connector", connector)
        if encryption_types is not None:
            pulumi.set(__self__, "encryption_types", encryption_types)
        if keytab_secret is not None:
            pulumi.set(__self__, "keytab_secret", keytab_secret)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Account name for AAD
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter
    def connector(self) -> Optional[pulumi.Input['K8sActiveDirectoryConnectorArgs']]:
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: Optional[pulumi.Input['K8sActiveDirectoryConnectorArgs']]):
        pulumi.set(self, "connector", value)

    @property
    @pulumi.getter(name="encryptionTypes")
    def encryption_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        An array of encryption types
        """
        return pulumi.get(self, "encryption_types")

    @encryption_types.setter
    def encryption_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "encryption_types", value)

    @property
    @pulumi.getter(name="keytabSecret")
    def keytab_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Keytab secret used to authenticate with Active Directory.
        """
        return pulumi.get(self, "keytab_secret")

    @keytab_secret.setter
    def keytab_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keytab_secret", value)


if not MYPY:
    class K8sNetworkSettingsArgsDict(TypedDict):
        """
        The kubernetes network settings information.
        """
        forceencryption: NotRequired[pulumi.Input[builtins.int]]
        """
        If 1, then SQL Server forces all connections to be encrypted. By default, this option is 0
        """
        tlsciphers: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies which ciphers are allowed by SQL Server for TLS
        """
        tlsprotocols: NotRequired[pulumi.Input[builtins.str]]
        """
        A comma-separated list of which TLS protocols are allowed by SQL Server
        """
elif False:
    K8sNetworkSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class K8sNetworkSettingsArgs:
    def __init__(__self__, *,
                 forceencryption: Optional[pulumi.Input[builtins.int]] = None,
                 tlsciphers: Optional[pulumi.Input[builtins.str]] = None,
                 tlsprotocols: Optional[pulumi.Input[builtins.str]] = None):
        """
        The kubernetes network settings information.
        :param pulumi.Input[builtins.int] forceencryption: If 1, then SQL Server forces all connections to be encrypted. By default, this option is 0
        :param pulumi.Input[builtins.str] tlsciphers: Specifies which ciphers are allowed by SQL Server for TLS
        :param pulumi.Input[builtins.str] tlsprotocols: A comma-separated list of which TLS protocols are allowed by SQL Server
        """
        if forceencryption is not None:
            pulumi.set(__self__, "forceencryption", forceencryption)
        if tlsciphers is not None:
            pulumi.set(__self__, "tlsciphers", tlsciphers)
        if tlsprotocols is not None:
            pulumi.set(__self__, "tlsprotocols", tlsprotocols)

    @property
    @pulumi.getter
    def forceencryption(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If 1, then SQL Server forces all connections to be encrypted. By default, this option is 0
        """
        return pulumi.get(self, "forceencryption")

    @forceencryption.setter
    def forceencryption(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "forceencryption", value)

    @property
    @pulumi.getter
    def tlsciphers(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies which ciphers are allowed by SQL Server for TLS
        """
        return pulumi.get(self, "tlsciphers")

    @tlsciphers.setter
    def tlsciphers(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tlsciphers", value)

    @property
    @pulumi.getter
    def tlsprotocols(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A comma-separated list of which TLS protocols are allowed by SQL Server
        """
        return pulumi.get(self, "tlsprotocols")

    @tlsprotocols.setter
    def tlsprotocols(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tlsprotocols", value)


if not MYPY:
    class K8sResourceRequirementsArgsDict(TypedDict):
        """
        The kubernetes resource limits and requests used to restrict or reserve resource usage.
        """
        limits: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Limits for a kubernetes resource type (e.g 'cpu', 'memory'). The 'cpu' request must be less than or equal to 'cpu' limit. Default 'cpu' is 2, minimum is 1. Default 'memory' is '4Gi', minimum is '2Gi. If sku.tier is GeneralPurpose, maximum 'cpu' is 24 and maximum 'memory' is '128Gi'.
        """
        requests: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Requests for a kubernetes resource type (e.g 'cpu', 'memory'). The 'cpu' request must be less than or equal to 'cpu' limit. Default 'cpu' is 2, minimum is 1. Default 'memory' is '4Gi', minimum is '2Gi. If sku.tier is GeneralPurpose, maximum 'cpu' is 24 and maximum 'memory' is '128Gi'.
        """
elif False:
    K8sResourceRequirementsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class K8sResourceRequirementsArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 requests: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        The kubernetes resource limits and requests used to restrict or reserve resource usage.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] limits: Limits for a kubernetes resource type (e.g 'cpu', 'memory'). The 'cpu' request must be less than or equal to 'cpu' limit. Default 'cpu' is 2, minimum is 1. Default 'memory' is '4Gi', minimum is '2Gi. If sku.tier is GeneralPurpose, maximum 'cpu' is 24 and maximum 'memory' is '128Gi'.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] requests: Requests for a kubernetes resource type (e.g 'cpu', 'memory'). The 'cpu' request must be less than or equal to 'cpu' limit. Default 'cpu' is 2, minimum is 1. Default 'memory' is '4Gi', minimum is '2Gi. If sku.tier is GeneralPurpose, maximum 'cpu' is 24 and maximum 'memory' is '128Gi'.
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Limits for a kubernetes resource type (e.g 'cpu', 'memory'). The 'cpu' request must be less than or equal to 'cpu' limit. Default 'cpu' is 2, minimum is 1. Default 'memory' is '4Gi', minimum is '2Gi. If sku.tier is GeneralPurpose, maximum 'cpu' is 24 and maximum 'memory' is '128Gi'.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def requests(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Requests for a kubernetes resource type (e.g 'cpu', 'memory'). The 'cpu' request must be less than or equal to 'cpu' limit. Default 'cpu' is 2, minimum is 1. Default 'memory' is '4Gi', minimum is '2Gi. If sku.tier is GeneralPurpose, maximum 'cpu' is 24 and maximum 'memory' is '128Gi'.
        """
        return pulumi.get(self, "requests")

    @requests.setter
    def requests(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "requests", value)


if not MYPY:
    class K8sSchedulingOptionsArgsDict(TypedDict):
        """
        The kubernetes scheduling options. It describes restrictions used to help Kubernetes select appropriate nodes to host the database service
        """
        resources: NotRequired[pulumi.Input['K8sResourceRequirementsArgsDict']]
        """
        The kubernetes resource limits and requests used to restrict or reserve resource usage.
        """
elif False:
    K8sSchedulingOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class K8sSchedulingOptionsArgs:
    def __init__(__self__, *,
                 resources: Optional[pulumi.Input['K8sResourceRequirementsArgs']] = None):
        """
        The kubernetes scheduling options. It describes restrictions used to help Kubernetes select appropriate nodes to host the database service
        :param pulumi.Input['K8sResourceRequirementsArgs'] resources: The kubernetes resource limits and requests used to restrict or reserve resource usage.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['K8sResourceRequirementsArgs']]:
        """
        The kubernetes resource limits and requests used to restrict or reserve resource usage.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['K8sResourceRequirementsArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class K8sSchedulingArgsDict(TypedDict):
        """
        The kubernetes scheduling information.
        """
        default: NotRequired[pulumi.Input['K8sSchedulingOptionsArgsDict']]
        """
        The kubernetes scheduling options. It describes restrictions used to help Kubernetes select appropriate nodes to host the database service
        """
elif False:
    K8sSchedulingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class K8sSchedulingArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input['K8sSchedulingOptionsArgs']] = None):
        """
        The kubernetes scheduling information.
        :param pulumi.Input['K8sSchedulingOptionsArgs'] default: The kubernetes scheduling options. It describes restrictions used to help Kubernetes select appropriate nodes to host the database service
        """
        if default is not None:
            pulumi.set(__self__, "default", default)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input['K8sSchedulingOptionsArgs']]:
        """
        The kubernetes scheduling options. It describes restrictions used to help Kubernetes select appropriate nodes to host the database service
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input['K8sSchedulingOptionsArgs']]):
        pulumi.set(self, "default", value)


if not MYPY:
    class K8sSecurityArgsDict(TypedDict):
        """
        The kubernetes security information.
        """
        active_directory: NotRequired[pulumi.Input['K8sActiveDirectoryArgsDict']]
        """
        The kubernetes active directory information.
        """
        admin_login_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Admin login secret key
        """
        service_certificate_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Service certificate secret used
        """
        transparent_data_encryption: NotRequired[pulumi.Input['K8stransparentDataEncryptionArgsDict']]
        """
        Transparent data encryption information.
        """
elif False:
    K8sSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class K8sSecurityArgs:
    def __init__(__self__, *,
                 active_directory: Optional[pulumi.Input['K8sActiveDirectoryArgs']] = None,
                 admin_login_secret: Optional[pulumi.Input[builtins.str]] = None,
                 service_certificate_secret: Optional[pulumi.Input[builtins.str]] = None,
                 transparent_data_encryption: Optional[pulumi.Input['K8stransparentDataEncryptionArgs']] = None):
        """
        The kubernetes security information.
        :param pulumi.Input['K8sActiveDirectoryArgs'] active_directory: The kubernetes active directory information.
        :param pulumi.Input[builtins.str] admin_login_secret: Admin login secret key
        :param pulumi.Input[builtins.str] service_certificate_secret: Service certificate secret used
        :param pulumi.Input['K8stransparentDataEncryptionArgs'] transparent_data_encryption: Transparent data encryption information.
        """
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if admin_login_secret is not None:
            pulumi.set(__self__, "admin_login_secret", admin_login_secret)
        if service_certificate_secret is not None:
            pulumi.set(__self__, "service_certificate_secret", service_certificate_secret)
        if transparent_data_encryption is not None:
            pulumi.set(__self__, "transparent_data_encryption", transparent_data_encryption)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['K8sActiveDirectoryArgs']]:
        """
        The kubernetes active directory information.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['K8sActiveDirectoryArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="adminLoginSecret")
    def admin_login_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Admin login secret key
        """
        return pulumi.get(self, "admin_login_secret")

    @admin_login_secret.setter
    def admin_login_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_login_secret", value)

    @property
    @pulumi.getter(name="serviceCertificateSecret")
    def service_certificate_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Service certificate secret used
        """
        return pulumi.get(self, "service_certificate_secret")

    @service_certificate_secret.setter
    def service_certificate_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_certificate_secret", value)

    @property
    @pulumi.getter(name="transparentDataEncryption")
    def transparent_data_encryption(self) -> Optional[pulumi.Input['K8stransparentDataEncryptionArgs']]:
        """
        Transparent data encryption information.
        """
        return pulumi.get(self, "transparent_data_encryption")

    @transparent_data_encryption.setter
    def transparent_data_encryption(self, value: Optional[pulumi.Input['K8stransparentDataEncryptionArgs']]):
        pulumi.set(self, "transparent_data_encryption", value)


if not MYPY:
    class K8sSettingsArgsDict(TypedDict):
        """
        The kubernetes settings information.
        """
        network: NotRequired[pulumi.Input['K8sNetworkSettingsArgsDict']]
        """
        The kubernetes network settings information.
        """
elif False:
    K8sSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class K8sSettingsArgs:
    def __init__(__self__, *,
                 network: Optional[pulumi.Input['K8sNetworkSettingsArgs']] = None):
        """
        The kubernetes settings information.
        :param pulumi.Input['K8sNetworkSettingsArgs'] network: The kubernetes network settings information.
        """
        if network is not None:
            pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input['K8sNetworkSettingsArgs']]:
        """
        The kubernetes network settings information.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input['K8sNetworkSettingsArgs']]):
        pulumi.set(self, "network", value)


if not MYPY:
    class K8stransparentDataEncryptionArgsDict(TypedDict):
        """
        Transparent data encryption information.
        """
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Transparent data encryption mode. Can be Service Managed, Customer managed or disabled
        """
        protector_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Protector secret for customer managed Transparent data encryption mode
        """
elif False:
    K8stransparentDataEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class K8stransparentDataEncryptionArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[builtins.str]] = None,
                 protector_secret: Optional[pulumi.Input[builtins.str]] = None):
        """
        Transparent data encryption information.
        :param pulumi.Input[builtins.str] mode: Transparent data encryption mode. Can be Service Managed, Customer managed or disabled
        :param pulumi.Input[builtins.str] protector_secret: Protector secret for customer managed Transparent data encryption mode
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if protector_secret is not None:
            pulumi.set(__self__, "protector_secret", protector_secret)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Transparent data encryption mode. Can be Service Managed, Customer managed or disabled
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="protectorSecret")
    def protector_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Protector secret for customer managed Transparent data encryption mode
        """
        return pulumi.get(self, "protector_secret")

    @protector_secret.setter
    def protector_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protector_secret", value)


if not MYPY:
    class KeytabInformationArgsDict(TypedDict):
        """
        Keytab used for authenticate with Active Directory.
        """
        keytab: NotRequired[pulumi.Input[builtins.str]]
        """
        A base64-encoded keytab.
        """
elif False:
    KeytabInformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeytabInformationArgs:
    def __init__(__self__, *,
                 keytab: Optional[pulumi.Input[builtins.str]] = None):
        """
        Keytab used for authenticate with Active Directory.
        :param pulumi.Input[builtins.str] keytab: A base64-encoded keytab.
        """
        if keytab is not None:
            pulumi.set(__self__, "keytab", keytab)

    @property
    @pulumi.getter
    def keytab(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A base64-encoded keytab.
        """
        return pulumi.get(self, "keytab")

    @keytab.setter
    def keytab(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keytab", value)


if not MYPY:
    class LogAnalyticsWorkspaceConfigArgsDict(TypedDict):
        """
        Log analytics workspace id and primary key
        """
        primary_key: NotRequired[pulumi.Input[builtins.str]]
        """
        Primary key of the workspace
        """
        workspace_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Azure Log Analytics workspace ID
        """
elif False:
    LogAnalyticsWorkspaceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsWorkspaceConfigArgs:
    def __init__(__self__, *,
                 primary_key: Optional[pulumi.Input[builtins.str]] = None,
                 workspace_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Log analytics workspace id and primary key
        :param pulumi.Input[builtins.str] primary_key: Primary key of the workspace
        :param pulumi.Input[builtins.str] workspace_id: Azure Log Analytics workspace ID
        """
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if workspace_id is not None:
            pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Primary key of the workspace
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Azure Log Analytics workspace ID
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "workspace_id", value)


if not MYPY:
    class MonitoringArgsDict(TypedDict):
        """
        The monitoring configuration.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if monitoring is enabled for this SQL Server instance.
        """
elif False:
    MonitoringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        The monitoring configuration.
        :param pulumi.Input[builtins.bool] enabled: Indicates if monitoring is enabled for this SQL Server instance.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if monitoring is enabled for this SQL Server instance.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class OnPremisePropertyArgsDict(TypedDict):
        """
        Properties from the Kubernetes data controller
        """
        id: pulumi.Input[builtins.str]
        """
        A globally unique ID identifying the associated Kubernetes cluster
        """
        public_signing_key: pulumi.Input[builtins.str]
        """
        Certificate that contains the Kubernetes cluster public key used to verify signing
        """
        signing_certificate_thumbprint: NotRequired[pulumi.Input[builtins.str]]
        """
        Unique thumbprint returned to customer to verify the certificate being uploaded
        """
elif False:
    OnPremisePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnPremisePropertyArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 public_signing_key: pulumi.Input[builtins.str],
                 signing_certificate_thumbprint: Optional[pulumi.Input[builtins.str]] = None):
        """
        Properties from the Kubernetes data controller
        :param pulumi.Input[builtins.str] id: A globally unique ID identifying the associated Kubernetes cluster
        :param pulumi.Input[builtins.str] public_signing_key: Certificate that contains the Kubernetes cluster public key used to verify signing
        :param pulumi.Input[builtins.str] signing_certificate_thumbprint: Unique thumbprint returned to customer to verify the certificate being uploaded
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "public_signing_key", public_signing_key)
        if signing_certificate_thumbprint is not None:
            pulumi.set(__self__, "signing_certificate_thumbprint", signing_certificate_thumbprint)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        A globally unique ID identifying the associated Kubernetes cluster
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="publicSigningKey")
    def public_signing_key(self) -> pulumi.Input[builtins.str]:
        """
        Certificate that contains the Kubernetes cluster public key used to verify signing
        """
        return pulumi.get(self, "public_signing_key")

    @public_signing_key.setter
    def public_signing_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "public_signing_key", value)

    @property
    @pulumi.getter(name="signingCertificateThumbprint")
    def signing_certificate_thumbprint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Unique thumbprint returned to customer to verify the certificate being uploaded
        """
        return pulumi.get(self, "signing_certificate_thumbprint")

    @signing_certificate_thumbprint.setter
    def signing_certificate_thumbprint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "signing_certificate_thumbprint", value)


if not MYPY:
    class PostgresInstancePropertiesArgsDict(TypedDict):
        """
        Postgres Instance properties.
        """
        admin: NotRequired[pulumi.Input[builtins.str]]
        """
        The instance admin
        """
        basic_login_information: NotRequired[pulumi.Input['BasicLoginInformationArgsDict']]
        """
        Username and password for basic authentication.
        """
        data_controller_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The data controller id
        """
        k8s_raw: NotRequired[Any]
        """
        The raw kubernetes information
        """
        last_uploaded_date: NotRequired[pulumi.Input[builtins.str]]
        """
        Last uploaded date from Kubernetes cluster. Defaults to current date time
        """
elif False:
    PostgresInstancePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PostgresInstancePropertiesArgs:
    def __init__(__self__, *,
                 admin: Optional[pulumi.Input[builtins.str]] = None,
                 basic_login_information: Optional[pulumi.Input['BasicLoginInformationArgs']] = None,
                 data_controller_id: Optional[pulumi.Input[builtins.str]] = None,
                 k8s_raw: Optional[Any] = None,
                 last_uploaded_date: Optional[pulumi.Input[builtins.str]] = None):
        """
        Postgres Instance properties.
        :param pulumi.Input[builtins.str] admin: The instance admin
        :param pulumi.Input['BasicLoginInformationArgs'] basic_login_information: Username and password for basic authentication.
        :param pulumi.Input[builtins.str] data_controller_id: The data controller id
        :param Any k8s_raw: The raw kubernetes information
        :param pulumi.Input[builtins.str] last_uploaded_date: Last uploaded date from Kubernetes cluster. Defaults to current date time
        """
        if admin is not None:
            pulumi.set(__self__, "admin", admin)
        if basic_login_information is not None:
            pulumi.set(__self__, "basic_login_information", basic_login_information)
        if data_controller_id is not None:
            pulumi.set(__self__, "data_controller_id", data_controller_id)
        if k8s_raw is not None:
            pulumi.set(__self__, "k8s_raw", k8s_raw)
        if last_uploaded_date is not None:
            pulumi.set(__self__, "last_uploaded_date", last_uploaded_date)

    @property
    @pulumi.getter
    def admin(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The instance admin
        """
        return pulumi.get(self, "admin")

    @admin.setter
    def admin(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin", value)

    @property
    @pulumi.getter(name="basicLoginInformation")
    def basic_login_information(self) -> Optional[pulumi.Input['BasicLoginInformationArgs']]:
        """
        Username and password for basic authentication.
        """
        return pulumi.get(self, "basic_login_information")

    @basic_login_information.setter
    def basic_login_information(self, value: Optional[pulumi.Input['BasicLoginInformationArgs']]):
        pulumi.set(self, "basic_login_information", value)

    @property
    @pulumi.getter(name="dataControllerId")
    def data_controller_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The data controller id
        """
        return pulumi.get(self, "data_controller_id")

    @data_controller_id.setter
    def data_controller_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_controller_id", value)

    @property
    @pulumi.getter(name="k8sRaw")
    def k8s_raw(self) -> Optional[Any]:
        """
        The raw kubernetes information
        """
        return pulumi.get(self, "k8s_raw")

    @k8s_raw.setter
    def k8s_raw(self, value: Optional[Any]):
        pulumi.set(self, "k8s_raw", value)

    @property
    @pulumi.getter(name="lastUploadedDate")
    def last_uploaded_date(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last uploaded date from Kubernetes cluster. Defaults to current date time
        """
        return pulumi.get(self, "last_uploaded_date")

    @last_uploaded_date.setter
    def last_uploaded_date(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_uploaded_date", value)


if not MYPY:
    class PostgresInstanceSkuArgsDict(TypedDict):
        """
        The resource model definition representing SKU for Azure Database for PostgresSQL - Azure Arc
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the SKU.  It is typically a letter+number code
        """
        capacity: NotRequired[pulumi.Input[builtins.int]]
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        dev: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose. 
        """
        family: NotRequired[pulumi.Input[builtins.str]]
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        size: NotRequired[pulumi.Input[builtins.str]]
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        tier: NotRequired[pulumi.Input['PostgresInstanceSkuTier']]
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier.
        """
elif False:
    PostgresInstanceSkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PostgresInstanceSkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 capacity: Optional[pulumi.Input[builtins.int]] = None,
                 dev: Optional[pulumi.Input[builtins.bool]] = None,
                 family: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.str]] = None,
                 tier: Optional[pulumi.Input['PostgresInstanceSkuTier']] = None):
        """
        The resource model definition representing SKU for Azure Database for PostgresSQL - Azure Arc
        :param pulumi.Input[builtins.str] name: The name of the SKU.  It is typically a letter+number code
        :param pulumi.Input[builtins.int] capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param pulumi.Input[builtins.bool] dev: Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose. 
        :param pulumi.Input[builtins.str] family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
        :param pulumi.Input[builtins.str] size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param pulumi.Input['PostgresInstanceSkuTier'] tier: This field is required to be implemented by the Resource Provider if the service has more than one tier.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if dev is None:
            dev = True
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is None:
            tier = 'Hyperscale'
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the SKU.  It is typically a letter+number code
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def dev(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose. 
        """
        return pulumi.get(self, "dev")

    @dev.setter
    def dev(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "dev", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input['PostgresInstanceSkuTier']]:
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input['PostgresInstanceSkuTier']]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class SqlAvailabilityGroupDatabaseReplicaResourcePropertiesArgsDict(TypedDict):
        """
        The properties of Arc Sql availability group database replica resource
        """
        database_name: NotRequired[pulumi.Input[builtins.str]]
        """
        the database name.
        """
elif False:
    SqlAvailabilityGroupDatabaseReplicaResourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlAvailabilityGroupDatabaseReplicaResourcePropertiesArgs:
    def __init__(__self__, *,
                 database_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The properties of Arc Sql availability group database replica resource
        :param pulumi.Input[builtins.str] database_name: the database name.
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        the database name.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "database_name", value)


if not MYPY:
    class SqlAvailabilityGroupReplicaResourcePropertiesArgsDict(TypedDict):
        """
        The properties of Arc Sql availability group replica resource
        """
        configure: NotRequired[pulumi.Input['AvailabilityGroupConfigureArgsDict']]
        """
        null
        """
        replica_name: NotRequired[pulumi.Input[builtins.str]]
        """
        the replica name.
        """
elif False:
    SqlAvailabilityGroupReplicaResourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlAvailabilityGroupReplicaResourcePropertiesArgs:
    def __init__(__self__, *,
                 configure: Optional[pulumi.Input['AvailabilityGroupConfigureArgs']] = None,
                 replica_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The properties of Arc Sql availability group replica resource
        :param pulumi.Input['AvailabilityGroupConfigureArgs'] configure: null
        :param pulumi.Input[builtins.str] replica_name: the replica name.
        """
        if configure is not None:
            pulumi.set(__self__, "configure", configure)
        if replica_name is not None:
            pulumi.set(__self__, "replica_name", replica_name)

    @property
    @pulumi.getter
    def configure(self) -> Optional[pulumi.Input['AvailabilityGroupConfigureArgs']]:
        """
        null
        """
        return pulumi.get(self, "configure")

    @configure.setter
    def configure(self, value: Optional[pulumi.Input['AvailabilityGroupConfigureArgs']]):
        pulumi.set(self, "configure", value)

    @property
    @pulumi.getter(name="replicaName")
    def replica_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        the replica name.
        """
        return pulumi.get(self, "replica_name")

    @replica_name.setter
    def replica_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "replica_name", value)


if not MYPY:
    class SqlManagedInstanceK8sRawArgsDict(TypedDict):
        """
        The raw kubernetes information.
        """
        spec: NotRequired[pulumi.Input['SqlManagedInstanceK8sSpecArgsDict']]
        """
        The kubernetes spec information.
        """
elif False:
    SqlManagedInstanceK8sRawArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlManagedInstanceK8sRawArgs:
    def __init__(__self__, *,
                 spec: Optional[pulumi.Input['SqlManagedInstanceK8sSpecArgs']] = None):
        """
        The raw kubernetes information.
        :param pulumi.Input['SqlManagedInstanceK8sSpecArgs'] spec: The kubernetes spec information.
        """
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['SqlManagedInstanceK8sSpecArgs']]:
        """
        The kubernetes spec information.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['SqlManagedInstanceK8sSpecArgs']]):
        pulumi.set(self, "spec", value)


if not MYPY:
    class SqlManagedInstanceK8sSpecArgsDict(TypedDict):
        """
        The kubernetes spec information.
        """
        replicas: NotRequired[pulumi.Input[builtins.int]]
        """
        This option specifies the number of SQL Managed Instance replicas that will be deployed in your Kubernetes cluster for high availability purposes. If sku.tier is BusinessCritical, allowed values are '2' or '3' with default of '3'. If sku.tier is GeneralPurpose, replicas must be '1'.
        """
        scheduling: NotRequired[pulumi.Input['K8sSchedulingArgsDict']]
        """
        The kubernetes scheduling information.
        """
        security: NotRequired[pulumi.Input['K8sSecurityArgsDict']]
        """
        The kubernetes security information.
        """
        settings: NotRequired[pulumi.Input['K8sSettingsArgsDict']]
        """
        The kubernetes settings information.
        """
elif False:
    SqlManagedInstanceK8sSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlManagedInstanceK8sSpecArgs:
    def __init__(__self__, *,
                 replicas: Optional[pulumi.Input[builtins.int]] = None,
                 scheduling: Optional[pulumi.Input['K8sSchedulingArgs']] = None,
                 security: Optional[pulumi.Input['K8sSecurityArgs']] = None,
                 settings: Optional[pulumi.Input['K8sSettingsArgs']] = None):
        """
        The kubernetes spec information.
        :param pulumi.Input[builtins.int] replicas: This option specifies the number of SQL Managed Instance replicas that will be deployed in your Kubernetes cluster for high availability purposes. If sku.tier is BusinessCritical, allowed values are '2' or '3' with default of '3'. If sku.tier is GeneralPurpose, replicas must be '1'.
        :param pulumi.Input['K8sSchedulingArgs'] scheduling: The kubernetes scheduling information.
        :param pulumi.Input['K8sSecurityArgs'] security: The kubernetes security information.
        :param pulumi.Input['K8sSettingsArgs'] settings: The kubernetes settings information.
        """
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if scheduling is not None:
            pulumi.set(__self__, "scheduling", scheduling)
        if security is not None:
            pulumi.set(__self__, "security", security)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        This option specifies the number of SQL Managed Instance replicas that will be deployed in your Kubernetes cluster for high availability purposes. If sku.tier is BusinessCritical, allowed values are '2' or '3' with default of '3'. If sku.tier is GeneralPurpose, replicas must be '1'.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def scheduling(self) -> Optional[pulumi.Input['K8sSchedulingArgs']]:
        """
        The kubernetes scheduling information.
        """
        return pulumi.get(self, "scheduling")

    @scheduling.setter
    def scheduling(self, value: Optional[pulumi.Input['K8sSchedulingArgs']]):
        pulumi.set(self, "scheduling", value)

    @property
    @pulumi.getter
    def security(self) -> Optional[pulumi.Input['K8sSecurityArgs']]:
        """
        The kubernetes security information.
        """
        return pulumi.get(self, "security")

    @security.setter
    def security(self, value: Optional[pulumi.Input['K8sSecurityArgs']]):
        pulumi.set(self, "security", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['K8sSettingsArgs']]:
        """
        The kubernetes settings information.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['K8sSettingsArgs']]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class SqlManagedInstancePropertiesArgsDict(TypedDict):
        """
        Properties of sqlManagedInstance.
        """
        active_directory_information: NotRequired[pulumi.Input['ActiveDirectoryInformationArgsDict']]
        """
        Active Directory information related to this SQL Managed Instance.
        """
        admin: NotRequired[pulumi.Input[builtins.str]]
        """
        The instance admin user
        """
        basic_login_information: NotRequired[pulumi.Input['BasicLoginInformationArgsDict']]
        """
        Username and password for basic authentication.
        """
        cluster_id: NotRequired[pulumi.Input[builtins.str]]
        """
        If a CustomLocation is provided, this contains the ARM id of the connected cluster the custom location belongs to.
        """
        data_controller_id: NotRequired[pulumi.Input[builtins.str]]
        """
        null
        """
        end_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The instance end time
        """
        extension_id: NotRequired[pulumi.Input[builtins.str]]
        """
        If a CustomLocation is provided, this contains the ARM id of the extension the custom location belongs to.
        """
        k8s_raw: NotRequired[pulumi.Input['SqlManagedInstanceK8sRawArgsDict']]
        """
        The raw kubernetes information
        """
        last_uploaded_date: NotRequired[pulumi.Input[builtins.str]]
        """
        Last uploaded date from Kubernetes cluster. Defaults to current date time
        """
        license_type: NotRequired[pulumi.Input[Union[builtins.str, 'ArcSqlManagedInstanceLicenseType']]]
        """
        The license type to apply for this managed instance.
        """
        start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The instance start time
        """
elif False:
    SqlManagedInstancePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlManagedInstancePropertiesArgs:
    def __init__(__self__, *,
                 active_directory_information: Optional[pulumi.Input['ActiveDirectoryInformationArgs']] = None,
                 admin: Optional[pulumi.Input[builtins.str]] = None,
                 basic_login_information: Optional[pulumi.Input['BasicLoginInformationArgs']] = None,
                 cluster_id: Optional[pulumi.Input[builtins.str]] = None,
                 data_controller_id: Optional[pulumi.Input[builtins.str]] = None,
                 end_time: Optional[pulumi.Input[builtins.str]] = None,
                 extension_id: Optional[pulumi.Input[builtins.str]] = None,
                 k8s_raw: Optional[pulumi.Input['SqlManagedInstanceK8sRawArgs']] = None,
                 last_uploaded_date: Optional[pulumi.Input[builtins.str]] = None,
                 license_type: Optional[pulumi.Input[Union[builtins.str, 'ArcSqlManagedInstanceLicenseType']]] = None,
                 start_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        Properties of sqlManagedInstance.
        :param pulumi.Input['ActiveDirectoryInformationArgs'] active_directory_information: Active Directory information related to this SQL Managed Instance.
        :param pulumi.Input[builtins.str] admin: The instance admin user
        :param pulumi.Input['BasicLoginInformationArgs'] basic_login_information: Username and password for basic authentication.
        :param pulumi.Input[builtins.str] cluster_id: If a CustomLocation is provided, this contains the ARM id of the connected cluster the custom location belongs to.
        :param pulumi.Input[builtins.str] data_controller_id: null
        :param pulumi.Input[builtins.str] end_time: The instance end time
        :param pulumi.Input[builtins.str] extension_id: If a CustomLocation is provided, this contains the ARM id of the extension the custom location belongs to.
        :param pulumi.Input['SqlManagedInstanceK8sRawArgs'] k8s_raw: The raw kubernetes information
        :param pulumi.Input[builtins.str] last_uploaded_date: Last uploaded date from Kubernetes cluster. Defaults to current date time
        :param pulumi.Input[Union[builtins.str, 'ArcSqlManagedInstanceLicenseType']] license_type: The license type to apply for this managed instance.
        :param pulumi.Input[builtins.str] start_time: The instance start time
        """
        if active_directory_information is not None:
            pulumi.set(__self__, "active_directory_information", active_directory_information)
        if admin is not None:
            pulumi.set(__self__, "admin", admin)
        if basic_login_information is not None:
            pulumi.set(__self__, "basic_login_information", basic_login_information)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if data_controller_id is not None:
            pulumi.set(__self__, "data_controller_id", data_controller_id)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if extension_id is not None:
            pulumi.set(__self__, "extension_id", extension_id)
        if k8s_raw is not None:
            pulumi.set(__self__, "k8s_raw", k8s_raw)
        if last_uploaded_date is not None:
            pulumi.set(__self__, "last_uploaded_date", last_uploaded_date)
        if license_type is None:
            license_type = 'BasePrice'
        if license_type is not None:
            pulumi.set(__self__, "license_type", license_type)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="activeDirectoryInformation")
    def active_directory_information(self) -> Optional[pulumi.Input['ActiveDirectoryInformationArgs']]:
        """
        Active Directory information related to this SQL Managed Instance.
        """
        return pulumi.get(self, "active_directory_information")

    @active_directory_information.setter
    def active_directory_information(self, value: Optional[pulumi.Input['ActiveDirectoryInformationArgs']]):
        pulumi.set(self, "active_directory_information", value)

    @property
    @pulumi.getter
    def admin(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The instance admin user
        """
        return pulumi.get(self, "admin")

    @admin.setter
    def admin(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin", value)

    @property
    @pulumi.getter(name="basicLoginInformation")
    def basic_login_information(self) -> Optional[pulumi.Input['BasicLoginInformationArgs']]:
        """
        Username and password for basic authentication.
        """
        return pulumi.get(self, "basic_login_information")

    @basic_login_information.setter
    def basic_login_information(self, value: Optional[pulumi.Input['BasicLoginInformationArgs']]):
        pulumi.set(self, "basic_login_information", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If a CustomLocation is provided, this contains the ARM id of the connected cluster the custom location belongs to.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="dataControllerId")
    def data_controller_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        null
        """
        return pulumi.get(self, "data_controller_id")

    @data_controller_id.setter
    def data_controller_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_controller_id", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The instance end time
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="extensionId")
    def extension_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If a CustomLocation is provided, this contains the ARM id of the extension the custom location belongs to.
        """
        return pulumi.get(self, "extension_id")

    @extension_id.setter
    def extension_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "extension_id", value)

    @property
    @pulumi.getter(name="k8sRaw")
    def k8s_raw(self) -> Optional[pulumi.Input['SqlManagedInstanceK8sRawArgs']]:
        """
        The raw kubernetes information
        """
        return pulumi.get(self, "k8s_raw")

    @k8s_raw.setter
    def k8s_raw(self, value: Optional[pulumi.Input['SqlManagedInstanceK8sRawArgs']]):
        pulumi.set(self, "k8s_raw", value)

    @property
    @pulumi.getter(name="lastUploadedDate")
    def last_uploaded_date(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last uploaded date from Kubernetes cluster. Defaults to current date time
        """
        return pulumi.get(self, "last_uploaded_date")

    @last_uploaded_date.setter
    def last_uploaded_date(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_uploaded_date", value)

    @property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ArcSqlManagedInstanceLicenseType']]]:
        """
        The license type to apply for this managed instance.
        """
        return pulumi.get(self, "license_type")

    @license_type.setter
    def license_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ArcSqlManagedInstanceLicenseType']]]):
        pulumi.set(self, "license_type", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The instance start time
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class SqlManagedInstanceSkuArgsDict(TypedDict):
        """
        The resource model definition representing SKU for Azure Managed Instance - Azure Arc
        """
        name: pulumi.Input['SqlManagedInstanceSkuName']
        """
        The name of the SKU.
        """
        capacity: NotRequired[pulumi.Input[builtins.int]]
        """
        The SKU capacity
        """
        dev: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose. 
        """
        family: NotRequired[pulumi.Input[builtins.str]]
        """
        The SKU family
        """
        size: NotRequired[pulumi.Input[builtins.str]]
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        tier: NotRequired[pulumi.Input['SqlManagedInstanceSkuTier']]
        """
        The pricing tier for the instance.
        """
elif False:
    SqlManagedInstanceSkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlManagedInstanceSkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input['SqlManagedInstanceSkuName'],
                 capacity: Optional[pulumi.Input[builtins.int]] = None,
                 dev: Optional[pulumi.Input[builtins.bool]] = None,
                 family: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.str]] = None,
                 tier: Optional[pulumi.Input['SqlManagedInstanceSkuTier']] = None):
        """
        The resource model definition representing SKU for Azure Managed Instance - Azure Arc
        :param pulumi.Input['SqlManagedInstanceSkuName'] name: The name of the SKU.
        :param pulumi.Input[builtins.int] capacity: The SKU capacity
        :param pulumi.Input[builtins.bool] dev: Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose. 
        :param pulumi.Input[builtins.str] family: The SKU family
        :param pulumi.Input[builtins.str] size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param pulumi.Input['SqlManagedInstanceSkuTier'] tier: The pricing tier for the instance.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if dev is None:
            dev = True
        if dev is not None:
            pulumi.set(__self__, "dev", dev)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is None:
            tier = 'GeneralPurpose'
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input['SqlManagedInstanceSkuName']:
        """
        The name of the SKU.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input['SqlManagedInstanceSkuName']):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The SKU capacity
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def dev(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose. 
        """
        return pulumi.get(self, "dev")

    @dev.setter
    def dev(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "dev", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The SKU family
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input['SqlManagedInstanceSkuTier']]:
        """
        The pricing tier for the instance.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input['SqlManagedInstanceSkuTier']]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class SqlServerAvailabilityGroupResourcePropertiesDatabasesArgsDict(TypedDict):
        """
        A list of Availability Group Database Replicas.
        """
        value: NotRequired[pulumi.Input[Sequence[pulumi.Input['SqlAvailabilityGroupDatabaseReplicaResourcePropertiesArgsDict']]]]
        """
        Array of Availability Group Database Replicas.
        """
elif False:
    SqlServerAvailabilityGroupResourcePropertiesDatabasesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlServerAvailabilityGroupResourcePropertiesDatabasesArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[Sequence[pulumi.Input['SqlAvailabilityGroupDatabaseReplicaResourcePropertiesArgs']]]] = None):
        """
        A list of Availability Group Database Replicas.
        :param pulumi.Input[Sequence[pulumi.Input['SqlAvailabilityGroupDatabaseReplicaResourcePropertiesArgs']]] value: Array of Availability Group Database Replicas.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SqlAvailabilityGroupDatabaseReplicaResourcePropertiesArgs']]]]:
        """
        Array of Availability Group Database Replicas.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SqlAvailabilityGroupDatabaseReplicaResourcePropertiesArgs']]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SqlServerAvailabilityGroupResourcePropertiesReplicasArgsDict(TypedDict):
        """
        A list of Availability Group Replicas.
        """
        value: NotRequired[pulumi.Input[Sequence[pulumi.Input['SqlAvailabilityGroupReplicaResourcePropertiesArgsDict']]]]
        """
        Array of Availability Group Replicas.
        """
elif False:
    SqlServerAvailabilityGroupResourcePropertiesReplicasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlServerAvailabilityGroupResourcePropertiesReplicasArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[Sequence[pulumi.Input['SqlAvailabilityGroupReplicaResourcePropertiesArgs']]]] = None):
        """
        A list of Availability Group Replicas.
        :param pulumi.Input[Sequence[pulumi.Input['SqlAvailabilityGroupReplicaResourcePropertiesArgs']]] value: Array of Availability Group Replicas.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SqlAvailabilityGroupReplicaResourcePropertiesArgs']]]]:
        """
        Array of Availability Group Replicas.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SqlAvailabilityGroupReplicaResourcePropertiesArgs']]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SqlServerAvailabilityGroupResourcePropertiesArgsDict(TypedDict):
        """
        The properties of Arc Sql Server availability group resource
        """
        databases: NotRequired[pulumi.Input['SqlServerAvailabilityGroupResourcePropertiesDatabasesArgsDict']]
        """
        A list of Availability Group Database Replicas.
        """
        info: NotRequired[pulumi.Input['AvailabilityGroupInfoArgsDict']]
        """
        Availability Group Info
        """
        replicas: NotRequired[pulumi.Input['SqlServerAvailabilityGroupResourcePropertiesReplicasArgsDict']]
        """
        A list of Availability Group Replicas.
        """
elif False:
    SqlServerAvailabilityGroupResourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlServerAvailabilityGroupResourcePropertiesArgs:
    def __init__(__self__, *,
                 databases: Optional[pulumi.Input['SqlServerAvailabilityGroupResourcePropertiesDatabasesArgs']] = None,
                 info: Optional[pulumi.Input['AvailabilityGroupInfoArgs']] = None,
                 replicas: Optional[pulumi.Input['SqlServerAvailabilityGroupResourcePropertiesReplicasArgs']] = None):
        """
        The properties of Arc Sql Server availability group resource
        :param pulumi.Input['SqlServerAvailabilityGroupResourcePropertiesDatabasesArgs'] databases: A list of Availability Group Database Replicas.
        :param pulumi.Input['AvailabilityGroupInfoArgs'] info: Availability Group Info
        :param pulumi.Input['SqlServerAvailabilityGroupResourcePropertiesReplicasArgs'] replicas: A list of Availability Group Replicas.
        """
        if databases is not None:
            pulumi.set(__self__, "databases", databases)
        if info is not None:
            pulumi.set(__self__, "info", info)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter
    def databases(self) -> Optional[pulumi.Input['SqlServerAvailabilityGroupResourcePropertiesDatabasesArgs']]:
        """
        A list of Availability Group Database Replicas.
        """
        return pulumi.get(self, "databases")

    @databases.setter
    def databases(self, value: Optional[pulumi.Input['SqlServerAvailabilityGroupResourcePropertiesDatabasesArgs']]):
        pulumi.set(self, "databases", value)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input['AvailabilityGroupInfoArgs']]:
        """
        Availability Group Info
        """
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input['AvailabilityGroupInfoArgs']]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input['SqlServerAvailabilityGroupResourcePropertiesReplicasArgs']]:
        """
        A list of Availability Group Replicas.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input['SqlServerAvailabilityGroupResourcePropertiesReplicasArgs']]):
        pulumi.set(self, "replicas", value)


if not MYPY:
    class SqlServerDatabaseResourcePropertiesBackupInformationArgsDict(TypedDict):
        last_full_backup: NotRequired[pulumi.Input[builtins.str]]
        """
        Date time of last full backup.
        """
        last_log_backup: NotRequired[pulumi.Input[builtins.str]]
        """
        Date time of last log backup.
        """
elif False:
    SqlServerDatabaseResourcePropertiesBackupInformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlServerDatabaseResourcePropertiesBackupInformationArgs:
    def __init__(__self__, *,
                 last_full_backup: Optional[pulumi.Input[builtins.str]] = None,
                 last_log_backup: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] last_full_backup: Date time of last full backup.
        :param pulumi.Input[builtins.str] last_log_backup: Date time of last log backup.
        """
        if last_full_backup is not None:
            pulumi.set(__self__, "last_full_backup", last_full_backup)
        if last_log_backup is not None:
            pulumi.set(__self__, "last_log_backup", last_log_backup)

    @property
    @pulumi.getter(name="lastFullBackup")
    def last_full_backup(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Date time of last full backup.
        """
        return pulumi.get(self, "last_full_backup")

    @last_full_backup.setter
    def last_full_backup(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_full_backup", value)

    @property
    @pulumi.getter(name="lastLogBackup")
    def last_log_backup(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Date time of last log backup.
        """
        return pulumi.get(self, "last_log_backup")

    @last_log_backup.setter
    def last_log_backup(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_log_backup", value)


if not MYPY:
    class SqlServerDatabaseResourcePropertiesDatabaseOptionsArgsDict(TypedDict):
        """
        List of features that are enabled for the database
        """
        is_auto_close_on: NotRequired[pulumi.Input[builtins.bool]]
        is_auto_create_stats_on: NotRequired[pulumi.Input[builtins.bool]]
        is_auto_shrink_on: NotRequired[pulumi.Input[builtins.bool]]
        is_auto_update_stats_on: NotRequired[pulumi.Input[builtins.bool]]
        is_encrypted: NotRequired[pulumi.Input[builtins.bool]]
        is_memory_optimization_enabled: NotRequired[pulumi.Input[builtins.bool]]
        is_remote_data_archive_enabled: NotRequired[pulumi.Input[builtins.bool]]
        is_trustworthy_on: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    SqlServerDatabaseResourcePropertiesDatabaseOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlServerDatabaseResourcePropertiesDatabaseOptionsArgs:
    def __init__(__self__, *,
                 is_auto_close_on: Optional[pulumi.Input[builtins.bool]] = None,
                 is_auto_create_stats_on: Optional[pulumi.Input[builtins.bool]] = None,
                 is_auto_shrink_on: Optional[pulumi.Input[builtins.bool]] = None,
                 is_auto_update_stats_on: Optional[pulumi.Input[builtins.bool]] = None,
                 is_encrypted: Optional[pulumi.Input[builtins.bool]] = None,
                 is_memory_optimization_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 is_remote_data_archive_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 is_trustworthy_on: Optional[pulumi.Input[builtins.bool]] = None):
        """
        List of features that are enabled for the database
        """
        if is_auto_close_on is not None:
            pulumi.set(__self__, "is_auto_close_on", is_auto_close_on)
        if is_auto_create_stats_on is not None:
            pulumi.set(__self__, "is_auto_create_stats_on", is_auto_create_stats_on)
        if is_auto_shrink_on is not None:
            pulumi.set(__self__, "is_auto_shrink_on", is_auto_shrink_on)
        if is_auto_update_stats_on is not None:
            pulumi.set(__self__, "is_auto_update_stats_on", is_auto_update_stats_on)
        if is_encrypted is not None:
            pulumi.set(__self__, "is_encrypted", is_encrypted)
        if is_memory_optimization_enabled is not None:
            pulumi.set(__self__, "is_memory_optimization_enabled", is_memory_optimization_enabled)
        if is_remote_data_archive_enabled is not None:
            pulumi.set(__self__, "is_remote_data_archive_enabled", is_remote_data_archive_enabled)
        if is_trustworthy_on is not None:
            pulumi.set(__self__, "is_trustworthy_on", is_trustworthy_on)

    @property
    @pulumi.getter(name="isAutoCloseOn")
    def is_auto_close_on(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_auto_close_on")

    @is_auto_close_on.setter
    def is_auto_close_on(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_auto_close_on", value)

    @property
    @pulumi.getter(name="isAutoCreateStatsOn")
    def is_auto_create_stats_on(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_auto_create_stats_on")

    @is_auto_create_stats_on.setter
    def is_auto_create_stats_on(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_auto_create_stats_on", value)

    @property
    @pulumi.getter(name="isAutoShrinkOn")
    def is_auto_shrink_on(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_auto_shrink_on")

    @is_auto_shrink_on.setter
    def is_auto_shrink_on(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_auto_shrink_on", value)

    @property
    @pulumi.getter(name="isAutoUpdateStatsOn")
    def is_auto_update_stats_on(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_auto_update_stats_on")

    @is_auto_update_stats_on.setter
    def is_auto_update_stats_on(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_auto_update_stats_on", value)

    @property
    @pulumi.getter(name="isEncrypted")
    def is_encrypted(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_encrypted")

    @is_encrypted.setter
    def is_encrypted(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_encrypted", value)

    @property
    @pulumi.getter(name="isMemoryOptimizationEnabled")
    def is_memory_optimization_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_memory_optimization_enabled")

    @is_memory_optimization_enabled.setter
    def is_memory_optimization_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_memory_optimization_enabled", value)

    @property
    @pulumi.getter(name="isRemoteDataArchiveEnabled")
    def is_remote_data_archive_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_remote_data_archive_enabled")

    @is_remote_data_archive_enabled.setter
    def is_remote_data_archive_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_remote_data_archive_enabled", value)

    @property
    @pulumi.getter(name="isTrustworthyOn")
    def is_trustworthy_on(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_trustworthy_on")

    @is_trustworthy_on.setter
    def is_trustworthy_on(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_trustworthy_on", value)


if not MYPY:
    class SqlServerDatabaseResourcePropertiesArgsDict(TypedDict):
        """
        The properties of Arc Sql Server database resource
        """
        backup_information: NotRequired[pulumi.Input['SqlServerDatabaseResourcePropertiesBackupInformationArgsDict']]
        backup_policy: NotRequired[pulumi.Input['BackupPolicyArgsDict']]
        """
        The backup profile for the SQL server.
        """
        collation_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Collation of the database.
        """
        compatibility_level: NotRequired[pulumi.Input[builtins.int]]
        """
        Compatibility level of the database
        """
        create_mode: NotRequired[pulumi.Input[Union[builtins.str, 'DatabaseCreateMode']]]
        """
        Database create mode. PointInTimeRestore: Create a database by restoring a point in time backup of an existing database. sourceDatabaseId and restorePointInTime must be specified.
        """
        database_creation_date: NotRequired[pulumi.Input[builtins.str]]
        """
        Creation date of the database.
        """
        database_options: NotRequired[pulumi.Input['SqlServerDatabaseResourcePropertiesDatabaseOptionsArgsDict']]
        """
        List of features that are enabled for the database
        """
        is_read_only: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the database is read only or not.
        """
        recovery_mode: NotRequired[pulumi.Input[Union[builtins.str, 'RecoveryMode']]]
        """
        Status of the database.
        """
        restore_point_in_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Conditional. If createMode is PointInTimeRestore, this value is required. Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database.
        """
        size_mb: NotRequired[pulumi.Input[builtins.float]]
        """
        Size of the database.
        """
        source_database_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The resource identifier of the source database associated with create operation of this database.
        """
        space_available_mb: NotRequired[pulumi.Input[builtins.float]]
        """
        Space left of the database.
        """
        state: NotRequired[pulumi.Input[Union[builtins.str, 'DatabaseState']]]
        """
        State of the database.
        """
elif False:
    SqlServerDatabaseResourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlServerDatabaseResourcePropertiesArgs:
    def __init__(__self__, *,
                 backup_information: Optional[pulumi.Input['SqlServerDatabaseResourcePropertiesBackupInformationArgs']] = None,
                 backup_policy: Optional[pulumi.Input['BackupPolicyArgs']] = None,
                 collation_name: Optional[pulumi.Input[builtins.str]] = None,
                 compatibility_level: Optional[pulumi.Input[builtins.int]] = None,
                 create_mode: Optional[pulumi.Input[Union[builtins.str, 'DatabaseCreateMode']]] = None,
                 database_creation_date: Optional[pulumi.Input[builtins.str]] = None,
                 database_options: Optional[pulumi.Input['SqlServerDatabaseResourcePropertiesDatabaseOptionsArgs']] = None,
                 is_read_only: Optional[pulumi.Input[builtins.bool]] = None,
                 recovery_mode: Optional[pulumi.Input[Union[builtins.str, 'RecoveryMode']]] = None,
                 restore_point_in_time: Optional[pulumi.Input[builtins.str]] = None,
                 size_mb: Optional[pulumi.Input[builtins.float]] = None,
                 source_database_id: Optional[pulumi.Input[builtins.str]] = None,
                 space_available_mb: Optional[pulumi.Input[builtins.float]] = None,
                 state: Optional[pulumi.Input[Union[builtins.str, 'DatabaseState']]] = None):
        """
        The properties of Arc Sql Server database resource
        :param pulumi.Input['BackupPolicyArgs'] backup_policy: The backup profile for the SQL server.
        :param pulumi.Input[builtins.str] collation_name: Collation of the database.
        :param pulumi.Input[builtins.int] compatibility_level: Compatibility level of the database
        :param pulumi.Input[Union[builtins.str, 'DatabaseCreateMode']] create_mode: Database create mode. PointInTimeRestore: Create a database by restoring a point in time backup of an existing database. sourceDatabaseId and restorePointInTime must be specified.
        :param pulumi.Input[builtins.str] database_creation_date: Creation date of the database.
        :param pulumi.Input['SqlServerDatabaseResourcePropertiesDatabaseOptionsArgs'] database_options: List of features that are enabled for the database
        :param pulumi.Input[builtins.bool] is_read_only: Whether the database is read only or not.
        :param pulumi.Input[Union[builtins.str, 'RecoveryMode']] recovery_mode: Status of the database.
        :param pulumi.Input[builtins.str] restore_point_in_time: Conditional. If createMode is PointInTimeRestore, this value is required. Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database.
        :param pulumi.Input[builtins.float] size_mb: Size of the database.
        :param pulumi.Input[builtins.str] source_database_id: The resource identifier of the source database associated with create operation of this database.
        :param pulumi.Input[builtins.float] space_available_mb: Space left of the database.
        :param pulumi.Input[Union[builtins.str, 'DatabaseState']] state: State of the database.
        """
        if backup_information is not None:
            pulumi.set(__self__, "backup_information", backup_information)
        if backup_policy is not None:
            pulumi.set(__self__, "backup_policy", backup_policy)
        if collation_name is not None:
            pulumi.set(__self__, "collation_name", collation_name)
        if compatibility_level is not None:
            pulumi.set(__self__, "compatibility_level", compatibility_level)
        if create_mode is not None:
            pulumi.set(__self__, "create_mode", create_mode)
        if database_creation_date is not None:
            pulumi.set(__self__, "database_creation_date", database_creation_date)
        if database_options is not None:
            pulumi.set(__self__, "database_options", database_options)
        if is_read_only is not None:
            pulumi.set(__self__, "is_read_only", is_read_only)
        if recovery_mode is not None:
            pulumi.set(__self__, "recovery_mode", recovery_mode)
        if restore_point_in_time is not None:
            pulumi.set(__self__, "restore_point_in_time", restore_point_in_time)
        if size_mb is not None:
            pulumi.set(__self__, "size_mb", size_mb)
        if source_database_id is not None:
            pulumi.set(__self__, "source_database_id", source_database_id)
        if space_available_mb is not None:
            pulumi.set(__self__, "space_available_mb", space_available_mb)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="backupInformation")
    def backup_information(self) -> Optional[pulumi.Input['SqlServerDatabaseResourcePropertiesBackupInformationArgs']]:
        return pulumi.get(self, "backup_information")

    @backup_information.setter
    def backup_information(self, value: Optional[pulumi.Input['SqlServerDatabaseResourcePropertiesBackupInformationArgs']]):
        pulumi.set(self, "backup_information", value)

    @property
    @pulumi.getter(name="backupPolicy")
    def backup_policy(self) -> Optional[pulumi.Input['BackupPolicyArgs']]:
        """
        The backup profile for the SQL server.
        """
        return pulumi.get(self, "backup_policy")

    @backup_policy.setter
    def backup_policy(self, value: Optional[pulumi.Input['BackupPolicyArgs']]):
        pulumi.set(self, "backup_policy", value)

    @property
    @pulumi.getter(name="collationName")
    def collation_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Collation of the database.
        """
        return pulumi.get(self, "collation_name")

    @collation_name.setter
    def collation_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "collation_name", value)

    @property
    @pulumi.getter(name="compatibilityLevel")
    def compatibility_level(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Compatibility level of the database
        """
        return pulumi.get(self, "compatibility_level")

    @compatibility_level.setter
    def compatibility_level(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "compatibility_level", value)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'DatabaseCreateMode']]]:
        """
        Database create mode. PointInTimeRestore: Create a database by restoring a point in time backup of an existing database. sourceDatabaseId and restorePointInTime must be specified.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'DatabaseCreateMode']]]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="databaseCreationDate")
    def database_creation_date(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Creation date of the database.
        """
        return pulumi.get(self, "database_creation_date")

    @database_creation_date.setter
    def database_creation_date(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "database_creation_date", value)

    @property
    @pulumi.getter(name="databaseOptions")
    def database_options(self) -> Optional[pulumi.Input['SqlServerDatabaseResourcePropertiesDatabaseOptionsArgs']]:
        """
        List of features that are enabled for the database
        """
        return pulumi.get(self, "database_options")

    @database_options.setter
    def database_options(self, value: Optional[pulumi.Input['SqlServerDatabaseResourcePropertiesDatabaseOptionsArgs']]):
        pulumi.set(self, "database_options", value)

    @property
    @pulumi.getter(name="isReadOnly")
    def is_read_only(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the database is read only or not.
        """
        return pulumi.get(self, "is_read_only")

    @is_read_only.setter
    def is_read_only(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_read_only", value)

    @property
    @pulumi.getter(name="recoveryMode")
    def recovery_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'RecoveryMode']]]:
        """
        Status of the database.
        """
        return pulumi.get(self, "recovery_mode")

    @recovery_mode.setter
    def recovery_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'RecoveryMode']]]):
        pulumi.set(self, "recovery_mode", value)

    @property
    @pulumi.getter(name="restorePointInTime")
    def restore_point_in_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Conditional. If createMode is PointInTimeRestore, this value is required. Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database.
        """
        return pulumi.get(self, "restore_point_in_time")

    @restore_point_in_time.setter
    def restore_point_in_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "restore_point_in_time", value)

    @property
    @pulumi.getter(name="sizeMB")
    def size_mb(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Size of the database.
        """
        return pulumi.get(self, "size_mb")

    @size_mb.setter
    def size_mb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "size_mb", value)

    @property
    @pulumi.getter(name="sourceDatabaseId")
    def source_database_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The resource identifier of the source database associated with create operation of this database.
        """
        return pulumi.get(self, "source_database_id")

    @source_database_id.setter
    def source_database_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_database_id", value)

    @property
    @pulumi.getter(name="spaceAvailableMB")
    def space_available_mb(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Space left of the database.
        """
        return pulumi.get(self, "space_available_mb")

    @space_available_mb.setter
    def space_available_mb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "space_available_mb", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[builtins.str, 'DatabaseState']]]:
        """
        State of the database.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[builtins.str, 'DatabaseState']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class SqlServerEsuLicensePropertiesArgsDict(TypedDict):
        """
        Properties of SQL Server ESU license.
        """
        activation_state: pulumi.Input[Union[builtins.str, 'State']]
        """
        The activation state of the license.
        """
        billing_plan: pulumi.Input[Union[builtins.str, 'BillingPlan']]
        """
        SQL Server ESU license type.
        """
        physical_cores: pulumi.Input[builtins.int]
        """
        The number of total cores of the license covers.
        """
        scope_type: pulumi.Input[Union[builtins.str, 'ScopeType']]
        """
        The Azure scope to which the license will apply.
        """
        version: pulumi.Input[Union[builtins.str, 'Version']]
        """
        The SQL Server version the license covers.
        """
elif False:
    SqlServerEsuLicensePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlServerEsuLicensePropertiesArgs:
    def __init__(__self__, *,
                 activation_state: pulumi.Input[Union[builtins.str, 'State']],
                 billing_plan: pulumi.Input[Union[builtins.str, 'BillingPlan']],
                 physical_cores: pulumi.Input[builtins.int],
                 scope_type: pulumi.Input[Union[builtins.str, 'ScopeType']],
                 version: pulumi.Input[Union[builtins.str, 'Version']]):
        """
        Properties of SQL Server ESU license.
        :param pulumi.Input[Union[builtins.str, 'State']] activation_state: The activation state of the license.
        :param pulumi.Input[Union[builtins.str, 'BillingPlan']] billing_plan: SQL Server ESU license type.
        :param pulumi.Input[builtins.int] physical_cores: The number of total cores of the license covers.
        :param pulumi.Input[Union[builtins.str, 'ScopeType']] scope_type: The Azure scope to which the license will apply.
        :param pulumi.Input[Union[builtins.str, 'Version']] version: The SQL Server version the license covers.
        """
        pulumi.set(__self__, "activation_state", activation_state)
        pulumi.set(__self__, "billing_plan", billing_plan)
        pulumi.set(__self__, "physical_cores", physical_cores)
        pulumi.set(__self__, "scope_type", scope_type)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="activationState")
    def activation_state(self) -> pulumi.Input[Union[builtins.str, 'State']]:
        """
        The activation state of the license.
        """
        return pulumi.get(self, "activation_state")

    @activation_state.setter
    def activation_state(self, value: pulumi.Input[Union[builtins.str, 'State']]):
        pulumi.set(self, "activation_state", value)

    @property
    @pulumi.getter(name="billingPlan")
    def billing_plan(self) -> pulumi.Input[Union[builtins.str, 'BillingPlan']]:
        """
        SQL Server ESU license type.
        """
        return pulumi.get(self, "billing_plan")

    @billing_plan.setter
    def billing_plan(self, value: pulumi.Input[Union[builtins.str, 'BillingPlan']]):
        pulumi.set(self, "billing_plan", value)

    @property
    @pulumi.getter(name="physicalCores")
    def physical_cores(self) -> pulumi.Input[builtins.int]:
        """
        The number of total cores of the license covers.
        """
        return pulumi.get(self, "physical_cores")

    @physical_cores.setter
    def physical_cores(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "physical_cores", value)

    @property
    @pulumi.getter(name="scopeType")
    def scope_type(self) -> pulumi.Input[Union[builtins.str, 'ScopeType']]:
        """
        The Azure scope to which the license will apply.
        """
        return pulumi.get(self, "scope_type")

    @scope_type.setter
    def scope_type(self, value: pulumi.Input[Union[builtins.str, 'ScopeType']]):
        pulumi.set(self, "scope_type", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[Union[builtins.str, 'Version']]:
        """
        The SQL Server version the license covers.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[Union[builtins.str, 'Version']]):
        pulumi.set(self, "version", value)


if not MYPY:
    class SqlServerInstancePropertiesArgsDict(TypedDict):
        """
        Properties of SqlServerInstance.
        """
        backup_policy: NotRequired[pulumi.Input['BackupPolicyArgsDict']]
        """
        The backup profile for the SQL server.
        """
        cores: NotRequired[pulumi.Input[builtins.str]]
        """
        The number of total cores of the Operating System Environment (OSE) hosting the SQL Server instance.
        """
        edition: NotRequired[pulumi.Input[Union[builtins.str, 'EditionType']]]
        """
        SQL Server edition.
        """
        host_type: NotRequired[pulumi.Input[Union[builtins.str, 'HostType']]]
        """
        Type of host for Azure Arc SQL Server
        """
        instance_name: NotRequired[pulumi.Input[builtins.str]]
        """
        SQL Server instance name.
        """
        monitoring: NotRequired[pulumi.Input['MonitoringArgsDict']]
        """
        The monitoring configuration.
        """
        upgrade_locked_until: NotRequired[pulumi.Input[builtins.str]]
        """
        Upgrade Action for this resource is locked until it expires. The Expiration time indicated by this value. It is not locked when it is empty.
        """
        version: NotRequired[pulumi.Input[Union[builtins.str, 'SqlVersion']]]
        """
        SQL Server version.
        """
elif False:
    SqlServerInstancePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlServerInstancePropertiesArgs:
    def __init__(__self__, *,
                 backup_policy: Optional[pulumi.Input['BackupPolicyArgs']] = None,
                 cores: Optional[pulumi.Input[builtins.str]] = None,
                 edition: Optional[pulumi.Input[Union[builtins.str, 'EditionType']]] = None,
                 host_type: Optional[pulumi.Input[Union[builtins.str, 'HostType']]] = None,
                 instance_name: Optional[pulumi.Input[builtins.str]] = None,
                 monitoring: Optional[pulumi.Input['MonitoringArgs']] = None,
                 upgrade_locked_until: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[Union[builtins.str, 'SqlVersion']]] = None):
        """
        Properties of SqlServerInstance.
        :param pulumi.Input['BackupPolicyArgs'] backup_policy: The backup profile for the SQL server.
        :param pulumi.Input[builtins.str] cores: The number of total cores of the Operating System Environment (OSE) hosting the SQL Server instance.
        :param pulumi.Input[Union[builtins.str, 'EditionType']] edition: SQL Server edition.
        :param pulumi.Input[Union[builtins.str, 'HostType']] host_type: Type of host for Azure Arc SQL Server
        :param pulumi.Input[builtins.str] instance_name: SQL Server instance name.
        :param pulumi.Input['MonitoringArgs'] monitoring: The monitoring configuration.
        :param pulumi.Input[builtins.str] upgrade_locked_until: Upgrade Action for this resource is locked until it expires. The Expiration time indicated by this value. It is not locked when it is empty.
        :param pulumi.Input[Union[builtins.str, 'SqlVersion']] version: SQL Server version.
        """
        if backup_policy is not None:
            pulumi.set(__self__, "backup_policy", backup_policy)
        if cores is not None:
            pulumi.set(__self__, "cores", cores)
        if edition is not None:
            pulumi.set(__self__, "edition", edition)
        if host_type is not None:
            pulumi.set(__self__, "host_type", host_type)
        if instance_name is not None:
            pulumi.set(__self__, "instance_name", instance_name)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if upgrade_locked_until is not None:
            pulumi.set(__self__, "upgrade_locked_until", upgrade_locked_until)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="backupPolicy")
    def backup_policy(self) -> Optional[pulumi.Input['BackupPolicyArgs']]:
        """
        The backup profile for the SQL server.
        """
        return pulumi.get(self, "backup_policy")

    @backup_policy.setter
    def backup_policy(self, value: Optional[pulumi.Input['BackupPolicyArgs']]):
        pulumi.set(self, "backup_policy", value)

    @property
    @pulumi.getter
    def cores(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The number of total cores of the Operating System Environment (OSE) hosting the SQL Server instance.
        """
        return pulumi.get(self, "cores")

    @cores.setter
    def cores(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cores", value)

    @property
    @pulumi.getter
    def edition(self) -> Optional[pulumi.Input[Union[builtins.str, 'EditionType']]]:
        """
        SQL Server edition.
        """
        return pulumi.get(self, "edition")

    @edition.setter
    def edition(self, value: Optional[pulumi.Input[Union[builtins.str, 'EditionType']]]):
        pulumi.set(self, "edition", value)

    @property
    @pulumi.getter(name="hostType")
    def host_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'HostType']]]:
        """
        Type of host for Azure Arc SQL Server
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'HostType']]]):
        pulumi.set(self, "host_type", value)

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SQL Server instance name.
        """
        return pulumi.get(self, "instance_name")

    @instance_name.setter
    def instance_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "instance_name", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input['MonitoringArgs']]:
        """
        The monitoring configuration.
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input['MonitoringArgs']]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter(name="upgradeLockedUntil")
    def upgrade_locked_until(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Upgrade Action for this resource is locked until it expires. The Expiration time indicated by this value. It is not locked when it is empty.
        """
        return pulumi.get(self, "upgrade_locked_until")

    @upgrade_locked_until.setter
    def upgrade_locked_until(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "upgrade_locked_until", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[Union[builtins.str, 'SqlVersion']]]:
        """
        SQL Server version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[Union[builtins.str, 'SqlVersion']]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class SqlServerLicensePropertiesArgsDict(TypedDict):
        """
        Properties of SQL Server License.
        """
        activation_state: pulumi.Input[Union[builtins.str, 'ActivationState']]
        """
        The activation state of the license.
        """
        billing_plan: pulumi.Input[Union[builtins.str, 'BillingPlan']]
        """
        SQL Server license type.
        """
        license_category: pulumi.Input[Union[builtins.str, 'LicenseCategory']]
        """
        This property represents the choice between SQL Server Core and ESU licenses.
        """
        physical_cores: pulumi.Input[builtins.int]
        """
        The number of total cores of the license covers.
        """
        scope_type: pulumi.Input[Union[builtins.str, 'ScopeType']]
        """
        The Azure scope to which the license will apply.
        """
elif False:
    SqlServerLicensePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlServerLicensePropertiesArgs:
    def __init__(__self__, *,
                 activation_state: pulumi.Input[Union[builtins.str, 'ActivationState']],
                 billing_plan: pulumi.Input[Union[builtins.str, 'BillingPlan']],
                 license_category: pulumi.Input[Union[builtins.str, 'LicenseCategory']],
                 physical_cores: pulumi.Input[builtins.int],
                 scope_type: pulumi.Input[Union[builtins.str, 'ScopeType']]):
        """
        Properties of SQL Server License.
        :param pulumi.Input[Union[builtins.str, 'ActivationState']] activation_state: The activation state of the license.
        :param pulumi.Input[Union[builtins.str, 'BillingPlan']] billing_plan: SQL Server license type.
        :param pulumi.Input[Union[builtins.str, 'LicenseCategory']] license_category: This property represents the choice between SQL Server Core and ESU licenses.
        :param pulumi.Input[builtins.int] physical_cores: The number of total cores of the license covers.
        :param pulumi.Input[Union[builtins.str, 'ScopeType']] scope_type: The Azure scope to which the license will apply.
        """
        pulumi.set(__self__, "activation_state", activation_state)
        pulumi.set(__self__, "billing_plan", billing_plan)
        pulumi.set(__self__, "license_category", license_category)
        pulumi.set(__self__, "physical_cores", physical_cores)
        pulumi.set(__self__, "scope_type", scope_type)

    @property
    @pulumi.getter(name="activationState")
    def activation_state(self) -> pulumi.Input[Union[builtins.str, 'ActivationState']]:
        """
        The activation state of the license.
        """
        return pulumi.get(self, "activation_state")

    @activation_state.setter
    def activation_state(self, value: pulumi.Input[Union[builtins.str, 'ActivationState']]):
        pulumi.set(self, "activation_state", value)

    @property
    @pulumi.getter(name="billingPlan")
    def billing_plan(self) -> pulumi.Input[Union[builtins.str, 'BillingPlan']]:
        """
        SQL Server license type.
        """
        return pulumi.get(self, "billing_plan")

    @billing_plan.setter
    def billing_plan(self, value: pulumi.Input[Union[builtins.str, 'BillingPlan']]):
        pulumi.set(self, "billing_plan", value)

    @property
    @pulumi.getter(name="licenseCategory")
    def license_category(self) -> pulumi.Input[Union[builtins.str, 'LicenseCategory']]:
        """
        This property represents the choice between SQL Server Core and ESU licenses.
        """
        return pulumi.get(self, "license_category")

    @license_category.setter
    def license_category(self, value: pulumi.Input[Union[builtins.str, 'LicenseCategory']]):
        pulumi.set(self, "license_category", value)

    @property
    @pulumi.getter(name="physicalCores")
    def physical_cores(self) -> pulumi.Input[builtins.int]:
        """
        The number of total cores of the license covers.
        """
        return pulumi.get(self, "physical_cores")

    @physical_cores.setter
    def physical_cores(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "physical_cores", value)

    @property
    @pulumi.getter(name="scopeType")
    def scope_type(self) -> pulumi.Input[Union[builtins.str, 'ScopeType']]:
        """
        The Azure scope to which the license will apply.
        """
        return pulumi.get(self, "scope_type")

    @scope_type.setter
    def scope_type(self, value: pulumi.Input[Union[builtins.str, 'ScopeType']]):
        pulumi.set(self, "scope_type", value)


if not MYPY:
    class UploadServicePrincipalArgsDict(TypedDict):
        """
        Service principal for uploading billing, metrics and logs.
        """
        authority: NotRequired[pulumi.Input[builtins.str]]
        """
        Authority for the service principal. Example: https://login.microsoftonline.com/
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Client ID of the service principal for uploading data.
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Secret of the service principal
        """
        tenant_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Tenant ID of the service principal.
        """
elif False:
    UploadServicePrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UploadServicePrincipalArgs:
    def __init__(__self__, *,
                 authority: Optional[pulumi.Input[builtins.str]] = None,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 tenant_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Service principal for uploading billing, metrics and logs.
        :param pulumi.Input[builtins.str] authority: Authority for the service principal. Example: https://login.microsoftonline.com/
        :param pulumi.Input[builtins.str] client_id: Client ID of the service principal for uploading data.
        :param pulumi.Input[builtins.str] client_secret: Secret of the service principal
        :param pulumi.Input[builtins.str] tenant_id: Tenant ID of the service principal.
        """
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def authority(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Authority for the service principal. Example: https://login.microsoftonline.com/
        """
        return pulumi.get(self, "authority")

    @authority.setter
    def authority(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authority", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Client ID of the service principal for uploading data.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Secret of the service principal
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Tenant ID of the service principal.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class UploadWatermarkArgsDict(TypedDict):
        """
        Properties on upload watermark.  Mostly timestamp for each upload data type
        """
        logs: NotRequired[pulumi.Input[builtins.str]]
        """
        Last uploaded date for logs from kubernetes cluster. Defaults to current date time
        """
        metrics: NotRequired[pulumi.Input[builtins.str]]
        """
        Last uploaded date for metrics from kubernetes cluster. Defaults to current date time
        """
        usages: NotRequired[pulumi.Input[builtins.str]]
        """
        Last uploaded date for usages from kubernetes cluster. Defaults to current date time
        """
elif False:
    UploadWatermarkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UploadWatermarkArgs:
    def __init__(__self__, *,
                 logs: Optional[pulumi.Input[builtins.str]] = None,
                 metrics: Optional[pulumi.Input[builtins.str]] = None,
                 usages: Optional[pulumi.Input[builtins.str]] = None):
        """
        Properties on upload watermark.  Mostly timestamp for each upload data type
        :param pulumi.Input[builtins.str] logs: Last uploaded date for logs from kubernetes cluster. Defaults to current date time
        :param pulumi.Input[builtins.str] metrics: Last uploaded date for metrics from kubernetes cluster. Defaults to current date time
        :param pulumi.Input[builtins.str] usages: Last uploaded date for usages from kubernetes cluster. Defaults to current date time
        """
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if usages is not None:
            pulumi.set(__self__, "usages", usages)

    @property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last uploaded date for logs from kubernetes cluster. Defaults to current date time
        """
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logs", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last uploaded date for metrics from kubernetes cluster. Defaults to current date time
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter
    def usages(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last uploaded date for usages from kubernetes cluster. Defaults to current date time
        """
        return pulumi.get(self, "usages")

    @usages.setter
    def usages(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "usages", value)


