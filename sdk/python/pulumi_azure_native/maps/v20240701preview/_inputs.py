# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'CorsRulesArgs',
    'CorsRulesArgsDict',
    'CorsRuleArgs',
    'CorsRuleArgsDict',
    'CreatorPropertiesArgs',
    'CreatorPropertiesArgsDict',
    'EncryptionCustomerManagedKeyEncryptionArgs',
    'EncryptionCustomerManagedKeyEncryptionArgsDict',
    'EncryptionKeyEncryptionKeyIdentityArgs',
    'EncryptionKeyEncryptionKeyIdentityArgsDict',
    'EncryptionArgs',
    'EncryptionArgsDict',
    'LinkedResourceArgs',
    'LinkedResourceArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'MapsAccountPropertiesLocationsArgs',
    'MapsAccountPropertiesLocationsArgsDict',
    'MapsAccountPropertiesArgs',
    'MapsAccountPropertiesArgsDict',
    'SkuArgs',
    'SkuArgsDict',
]

MYPY = False

if not MYPY:
    class CorsRulesArgsDict(TypedDict):
        """
        Sets the CORS rules. You can include up to five CorsRule elements in the request. 
        """
        cors_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['CorsRuleArgsDict']]]]
        """
        The list of CORS rules. You can include up to five CorsRule elements in the request. 
        """
elif False:
    CorsRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CorsRulesArgs:
    def __init__(__self__, *,
                 cors_rules: Optional[pulumi.Input[Sequence[pulumi.Input['CorsRuleArgs']]]] = None):
        """
        Sets the CORS rules. You can include up to five CorsRule elements in the request. 
        :param pulumi.Input[Sequence[pulumi.Input['CorsRuleArgs']]] cors_rules: The list of CORS rules. You can include up to five CorsRule elements in the request. 
        """
        if cors_rules is not None:
            pulumi.set(__self__, "cors_rules", cors_rules)

    @property
    @pulumi.getter(name="corsRules")
    def cors_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CorsRuleArgs']]]]:
        """
        The list of CORS rules. You can include up to five CorsRule elements in the request. 
        """
        return pulumi.get(self, "cors_rules")

    @cors_rules.setter
    def cors_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CorsRuleArgs']]]]):
        pulumi.set(self, "cors_rules", value)


if not MYPY:
    class CorsRuleArgsDict(TypedDict):
        """
        Specifies a CORS rule for the Map Account.
        """
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Required if CorsRule element is present. A list of origin domains that will be allowed via CORS, or "*" to allow all domains
        """
elif False:
    CorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CorsRuleArgs:
    def __init__(__self__, *,
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Specifies a CORS rule for the Map Account.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Required if CorsRule element is present. A list of origin domains that will be allowed via CORS, or "*" to allow all domains
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Required if CorsRule element is present. A list of origin domains that will be allowed via CORS, or "*" to allow all domains
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)


if not MYPY:
    class CreatorPropertiesArgsDict(TypedDict):
        """
        Creator resource properties
        """
        storage_units: pulumi.Input[int]
        """
        The storage units to be allocated. Integer values from 1 to 100, inclusive.
        """
        consumed_storage_unit_size_in_bytes: NotRequired[pulumi.Input[int]]
        """
        The consumed storage unit size in bytes for the creator resource.
        """
        total_storage_unit_size_in_bytes: NotRequired[pulumi.Input[int]]
        """
        The total allocated storage unit size in bytes for the creator resource.
        """
elif False:
    CreatorPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CreatorPropertiesArgs:
    def __init__(__self__, *,
                 storage_units: pulumi.Input[int],
                 consumed_storage_unit_size_in_bytes: Optional[pulumi.Input[int]] = None,
                 total_storage_unit_size_in_bytes: Optional[pulumi.Input[int]] = None):
        """
        Creator resource properties
        :param pulumi.Input[int] storage_units: The storage units to be allocated. Integer values from 1 to 100, inclusive.
        :param pulumi.Input[int] consumed_storage_unit_size_in_bytes: The consumed storage unit size in bytes for the creator resource.
        :param pulumi.Input[int] total_storage_unit_size_in_bytes: The total allocated storage unit size in bytes for the creator resource.
        """
        pulumi.set(__self__, "storage_units", storage_units)
        if consumed_storage_unit_size_in_bytes is not None:
            pulumi.set(__self__, "consumed_storage_unit_size_in_bytes", consumed_storage_unit_size_in_bytes)
        if total_storage_unit_size_in_bytes is not None:
            pulumi.set(__self__, "total_storage_unit_size_in_bytes", total_storage_unit_size_in_bytes)

    @property
    @pulumi.getter(name="storageUnits")
    def storage_units(self) -> pulumi.Input[int]:
        """
        The storage units to be allocated. Integer values from 1 to 100, inclusive.
        """
        return pulumi.get(self, "storage_units")

    @storage_units.setter
    def storage_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "storage_units", value)

    @property
    @pulumi.getter(name="consumedStorageUnitSizeInBytes")
    def consumed_storage_unit_size_in_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        The consumed storage unit size in bytes for the creator resource.
        """
        return pulumi.get(self, "consumed_storage_unit_size_in_bytes")

    @consumed_storage_unit_size_in_bytes.setter
    def consumed_storage_unit_size_in_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consumed_storage_unit_size_in_bytes", value)

    @property
    @pulumi.getter(name="totalStorageUnitSizeInBytes")
    def total_storage_unit_size_in_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        The total allocated storage unit size in bytes for the creator resource.
        """
        return pulumi.get(self, "total_storage_unit_size_in_bytes")

    @total_storage_unit_size_in_bytes.setter
    def total_storage_unit_size_in_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_storage_unit_size_in_bytes", value)


if not MYPY:
    class EncryptionCustomerManagedKeyEncryptionArgsDict(TypedDict):
        """
        All Customer-managed key encryption properties for the resource.
        """
        key_encryption_key_identity: NotRequired[pulumi.Input['EncryptionKeyEncryptionKeyIdentityArgsDict']]
        """
        All identity configuration for Customer-managed key settings defining which identity should be used to auth to Key Vault.
        """
        key_encryption_key_url: NotRequired[pulumi.Input[str]]
        """
        key encryption key Url, versioned or unversioned. Ex: https://contosovault.vault.azure.net/keys/contosokek/562a4bb76b524a1493a6afe8e536ee78 or https://contosovault.vault.azure.net/keys/contosokek.
        """
elif False:
    EncryptionCustomerManagedKeyEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionCustomerManagedKeyEncryptionArgs:
    def __init__(__self__, *,
                 key_encryption_key_identity: Optional[pulumi.Input['EncryptionKeyEncryptionKeyIdentityArgs']] = None,
                 key_encryption_key_url: Optional[pulumi.Input[str]] = None):
        """
        All Customer-managed key encryption properties for the resource.
        :param pulumi.Input['EncryptionKeyEncryptionKeyIdentityArgs'] key_encryption_key_identity: All identity configuration for Customer-managed key settings defining which identity should be used to auth to Key Vault.
        :param pulumi.Input[str] key_encryption_key_url: key encryption key Url, versioned or unversioned. Ex: https://contosovault.vault.azure.net/keys/contosokek/562a4bb76b524a1493a6afe8e536ee78 or https://contosovault.vault.azure.net/keys/contosokek.
        """
        if key_encryption_key_identity is not None:
            pulumi.set(__self__, "key_encryption_key_identity", key_encryption_key_identity)
        if key_encryption_key_url is not None:
            pulumi.set(__self__, "key_encryption_key_url", key_encryption_key_url)

    @property
    @pulumi.getter(name="keyEncryptionKeyIdentity")
    def key_encryption_key_identity(self) -> Optional[pulumi.Input['EncryptionKeyEncryptionKeyIdentityArgs']]:
        """
        All identity configuration for Customer-managed key settings defining which identity should be used to auth to Key Vault.
        """
        return pulumi.get(self, "key_encryption_key_identity")

    @key_encryption_key_identity.setter
    def key_encryption_key_identity(self, value: Optional[pulumi.Input['EncryptionKeyEncryptionKeyIdentityArgs']]):
        pulumi.set(self, "key_encryption_key_identity", value)

    @property
    @pulumi.getter(name="keyEncryptionKeyUrl")
    def key_encryption_key_url(self) -> Optional[pulumi.Input[str]]:
        """
        key encryption key Url, versioned or unversioned. Ex: https://contosovault.vault.azure.net/keys/contosokek/562a4bb76b524a1493a6afe8e536ee78 or https://contosovault.vault.azure.net/keys/contosokek.
        """
        return pulumi.get(self, "key_encryption_key_url")

    @key_encryption_key_url.setter
    def key_encryption_key_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_encryption_key_url", value)


if not MYPY:
    class EncryptionKeyEncryptionKeyIdentityArgsDict(TypedDict):
        """
        All identity configuration for Customer-managed key settings defining which identity should be used to auth to Key Vault.
        """
        delegated_identity_client_id: NotRequired[pulumi.Input[str]]
        """
        delegated identity to use for accessing key encryption key Url. Ex: /subscriptions/fa5fc227-a624-475e-b696-cdd604c735bc/resourceGroups/<resource group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId. Mutually exclusive with identityType systemAssignedIdentity and userAssignedIdentity - internal use only.
        """
        federated_client_id: NotRequired[pulumi.Input[str]]
        """
        application client identity to use for accessing key encryption key Url in a different tenant. Ex: f83c6b1b-4d34-47e4-bb34-9d83df58b540
        """
        identity_type: NotRequired[pulumi.Input[str]]
        """
        The type of identity to use. Values can be systemAssignedIdentity, userAssignedIdentity, or delegatedResourceIdentity.
        """
        user_assigned_identity_resource_id: NotRequired[pulumi.Input[str]]
        """
        User assigned identity to use for accessing key encryption key Url. Ex: /subscriptions/fa5fc227-a624-475e-b696-cdd604c735bc/resourceGroups/<resource group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId. Mutually exclusive with identityType systemAssignedIdentity.
        """
elif False:
    EncryptionKeyEncryptionKeyIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionKeyEncryptionKeyIdentityArgs:
    def __init__(__self__, *,
                 delegated_identity_client_id: Optional[pulumi.Input[str]] = None,
                 federated_client_id: Optional[pulumi.Input[str]] = None,
                 identity_type: Optional[pulumi.Input[str]] = None,
                 user_assigned_identity_resource_id: Optional[pulumi.Input[str]] = None):
        """
        All identity configuration for Customer-managed key settings defining which identity should be used to auth to Key Vault.
        :param pulumi.Input[str] delegated_identity_client_id: delegated identity to use for accessing key encryption key Url. Ex: /subscriptions/fa5fc227-a624-475e-b696-cdd604c735bc/resourceGroups/<resource group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId. Mutually exclusive with identityType systemAssignedIdentity and userAssignedIdentity - internal use only.
        :param pulumi.Input[str] federated_client_id: application client identity to use for accessing key encryption key Url in a different tenant. Ex: f83c6b1b-4d34-47e4-bb34-9d83df58b540
        :param pulumi.Input[str] identity_type: The type of identity to use. Values can be systemAssignedIdentity, userAssignedIdentity, or delegatedResourceIdentity.
        :param pulumi.Input[str] user_assigned_identity_resource_id: User assigned identity to use for accessing key encryption key Url. Ex: /subscriptions/fa5fc227-a624-475e-b696-cdd604c735bc/resourceGroups/<resource group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId. Mutually exclusive with identityType systemAssignedIdentity.
        """
        if delegated_identity_client_id is not None:
            pulumi.set(__self__, "delegated_identity_client_id", delegated_identity_client_id)
        if federated_client_id is not None:
            pulumi.set(__self__, "federated_client_id", federated_client_id)
        if identity_type is not None:
            pulumi.set(__self__, "identity_type", identity_type)
        if user_assigned_identity_resource_id is not None:
            pulumi.set(__self__, "user_assigned_identity_resource_id", user_assigned_identity_resource_id)

    @property
    @pulumi.getter(name="delegatedIdentityClientId")
    def delegated_identity_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        delegated identity to use for accessing key encryption key Url. Ex: /subscriptions/fa5fc227-a624-475e-b696-cdd604c735bc/resourceGroups/<resource group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId. Mutually exclusive with identityType systemAssignedIdentity and userAssignedIdentity - internal use only.
        """
        return pulumi.get(self, "delegated_identity_client_id")

    @delegated_identity_client_id.setter
    def delegated_identity_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delegated_identity_client_id", value)

    @property
    @pulumi.getter(name="federatedClientId")
    def federated_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        application client identity to use for accessing key encryption key Url in a different tenant. Ex: f83c6b1b-4d34-47e4-bb34-9d83df58b540
        """
        return pulumi.get(self, "federated_client_id")

    @federated_client_id.setter
    def federated_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "federated_client_id", value)

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of identity to use. Values can be systemAssignedIdentity, userAssignedIdentity, or delegatedResourceIdentity.
        """
        return pulumi.get(self, "identity_type")

    @identity_type.setter
    def identity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_type", value)

    @property
    @pulumi.getter(name="userAssignedIdentityResourceId")
    def user_assigned_identity_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        User assigned identity to use for accessing key encryption key Url. Ex: /subscriptions/fa5fc227-a624-475e-b696-cdd604c735bc/resourceGroups/<resource group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId. Mutually exclusive with identityType systemAssignedIdentity.
        """
        return pulumi.get(self, "user_assigned_identity_resource_id")

    @user_assigned_identity_resource_id.setter
    def user_assigned_identity_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity_resource_id", value)


if not MYPY:
    class EncryptionArgsDict(TypedDict):
        """
        All encryption configuration for a resource.
        """
        customer_managed_key_encryption: NotRequired[pulumi.Input['EncryptionCustomerManagedKeyEncryptionArgsDict']]
        """
        All Customer-managed key encryption properties for the resource.
        """
        infrastructure_encryption: NotRequired[pulumi.Input[Union[str, 'InfrastructureEncryption']]]
        """
        (Optional) Discouraged to include in resource definition. Only needed where it is possible to disable platform (AKA infrastructure) encryption. Azure SQL TDE is an example of this. Values are enabled and disabled.
        """
elif False:
    EncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionArgs:
    def __init__(__self__, *,
                 customer_managed_key_encryption: Optional[pulumi.Input['EncryptionCustomerManagedKeyEncryptionArgs']] = None,
                 infrastructure_encryption: Optional[pulumi.Input[Union[str, 'InfrastructureEncryption']]] = None):
        """
        All encryption configuration for a resource.
        :param pulumi.Input['EncryptionCustomerManagedKeyEncryptionArgs'] customer_managed_key_encryption: All Customer-managed key encryption properties for the resource.
        :param pulumi.Input[Union[str, 'InfrastructureEncryption']] infrastructure_encryption: (Optional) Discouraged to include in resource definition. Only needed where it is possible to disable platform (AKA infrastructure) encryption. Azure SQL TDE is an example of this. Values are enabled and disabled.
        """
        if customer_managed_key_encryption is not None:
            pulumi.set(__self__, "customer_managed_key_encryption", customer_managed_key_encryption)
        if infrastructure_encryption is not None:
            pulumi.set(__self__, "infrastructure_encryption", infrastructure_encryption)

    @property
    @pulumi.getter(name="customerManagedKeyEncryption")
    def customer_managed_key_encryption(self) -> Optional[pulumi.Input['EncryptionCustomerManagedKeyEncryptionArgs']]:
        """
        All Customer-managed key encryption properties for the resource.
        """
        return pulumi.get(self, "customer_managed_key_encryption")

    @customer_managed_key_encryption.setter
    def customer_managed_key_encryption(self, value: Optional[pulumi.Input['EncryptionCustomerManagedKeyEncryptionArgs']]):
        pulumi.set(self, "customer_managed_key_encryption", value)

    @property
    @pulumi.getter(name="infrastructureEncryption")
    def infrastructure_encryption(self) -> Optional[pulumi.Input[Union[str, 'InfrastructureEncryption']]]:
        """
        (Optional) Discouraged to include in resource definition. Only needed where it is possible to disable platform (AKA infrastructure) encryption. Azure SQL TDE is an example of this. Values are enabled and disabled.
        """
        return pulumi.get(self, "infrastructure_encryption")

    @infrastructure_encryption.setter
    def infrastructure_encryption(self, value: Optional[pulumi.Input[Union[str, 'InfrastructureEncryption']]]):
        pulumi.set(self, "infrastructure_encryption", value)


if not MYPY:
    class LinkedResourceArgsDict(TypedDict):
        """
        Linked resource is reference to a resource deployed in an Azure subscription, add the linked resource `uniqueName` value as an optional parameter for operations on Azure Maps Geospatial REST APIs.
        """
        id: pulumi.Input[str]
        """
        ARM resource id in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/accounts/{storageName}'.
        """
        unique_name: pulumi.Input[str]
        """
        A provided name which uniquely identifies the linked resource.
        """
elif False:
    LinkedResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinkedResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 unique_name: pulumi.Input[str]):
        """
        Linked resource is reference to a resource deployed in an Azure subscription, add the linked resource `uniqueName` value as an optional parameter for operations on Azure Maps Geospatial REST APIs.
        :param pulumi.Input[str] id: ARM resource id in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/accounts/{storageName}'.
        :param pulumi.Input[str] unique_name: A provided name which uniquely identifies the linked resource.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "unique_name", unique_name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ARM resource id in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/accounts/{storageName}'.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="uniqueName")
    def unique_name(self) -> pulumi.Input[str]:
        """
        A provided name which uniquely identifies the linked resource.
        """
        return pulumi.get(self, "unique_name")

    @unique_name.setter
    def unique_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "unique_name", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class MapsAccountPropertiesLocationsArgsDict(TypedDict):
        """
        Data processing location.
        """
        location_name: pulumi.Input[str]
        """
        The location name.
        """
elif False:
    MapsAccountPropertiesLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MapsAccountPropertiesLocationsArgs:
    def __init__(__self__, *,
                 location_name: pulumi.Input[str]):
        """
        Data processing location.
        :param pulumi.Input[str] location_name: The location name.
        """
        pulumi.set(__self__, "location_name", location_name)

    @property
    @pulumi.getter(name="locationName")
    def location_name(self) -> pulumi.Input[str]:
        """
        The location name.
        """
        return pulumi.get(self, "location_name")

    @location_name.setter
    def location_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "location_name", value)


if not MYPY:
    class MapsAccountPropertiesArgsDict(TypedDict):
        """
        Additional Maps account properties
        """
        cors: NotRequired[pulumi.Input['CorsRulesArgsDict']]
        """
        Specifies CORS rules for the Blob service. You can include up to five CorsRule elements in the request. If no CorsRule elements are included in the request body, all CORS rules will be deleted, and CORS will be disabled for the Blob service.
        """
        disable_local_auth: NotRequired[pulumi.Input[bool]]
        """
        Allows toggle functionality on Azure Policy to disable Azure Maps local authentication support. This will disable Shared Keys and Shared Access Signature Token authentication from any usage.
        """
        encryption: NotRequired[pulumi.Input['EncryptionArgsDict']]
        """
        All encryption configuration for a resource.
        """
        linked_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['LinkedResourceArgsDict']]]]
        """
        The array of associated resources to the Maps account. Linked resource in the array cannot individually update, you must update all linked resources in the array together. These resources may be used on operations on the Azure Maps REST API. Access is controlled by the Maps Account Managed Identity(s) permissions to those resource(s).
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['MapsAccountPropertiesLocationsArgsDict']]]]
        """
        List of additional data processing regions for the Maps Account, which may result in requests being processed in another geography. Some features or results may be restricted to specific regions. By default, Maps REST APIs process requests according to the account location or the [geographic scope](https://learn.microsoft.com/azure/azure-maps/geographic-scope).
        """
elif False:
    MapsAccountPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MapsAccountPropertiesArgs:
    def __init__(__self__, *,
                 cors: Optional[pulumi.Input['CorsRulesArgs']] = None,
                 disable_local_auth: Optional[pulumi.Input[bool]] = None,
                 encryption: Optional[pulumi.Input['EncryptionArgs']] = None,
                 linked_resources: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedResourceArgs']]]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input['MapsAccountPropertiesLocationsArgs']]]] = None):
        """
        Additional Maps account properties
        :param pulumi.Input['CorsRulesArgs'] cors: Specifies CORS rules for the Blob service. You can include up to five CorsRule elements in the request. If no CorsRule elements are included in the request body, all CORS rules will be deleted, and CORS will be disabled for the Blob service.
        :param pulumi.Input[bool] disable_local_auth: Allows toggle functionality on Azure Policy to disable Azure Maps local authentication support. This will disable Shared Keys and Shared Access Signature Token authentication from any usage.
        :param pulumi.Input['EncryptionArgs'] encryption: All encryption configuration for a resource.
        :param pulumi.Input[Sequence[pulumi.Input['LinkedResourceArgs']]] linked_resources: The array of associated resources to the Maps account. Linked resource in the array cannot individually update, you must update all linked resources in the array together. These resources may be used on operations on the Azure Maps REST API. Access is controlled by the Maps Account Managed Identity(s) permissions to those resource(s).
        :param pulumi.Input[Sequence[pulumi.Input['MapsAccountPropertiesLocationsArgs']]] locations: List of additional data processing regions for the Maps Account, which may result in requests being processed in another geography. Some features or results may be restricted to specific regions. By default, Maps REST APIs process requests according to the account location or the [geographic scope](https://learn.microsoft.com/azure/azure-maps/geographic-scope).
        """
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if disable_local_auth is None:
            disable_local_auth = False
        if disable_local_auth is not None:
            pulumi.set(__self__, "disable_local_auth", disable_local_auth)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if linked_resources is not None:
            pulumi.set(__self__, "linked_resources", linked_resources)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['CorsRulesArgs']]:
        """
        Specifies CORS rules for the Blob service. You can include up to five CorsRule elements in the request. If no CorsRule elements are included in the request body, all CORS rules will be deleted, and CORS will be disabled for the Blob service.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['CorsRulesArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="disableLocalAuth")
    def disable_local_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows toggle functionality on Azure Policy to disable Azure Maps local authentication support. This will disable Shared Keys and Shared Access Signature Token authentication from any usage.
        """
        return pulumi.get(self, "disable_local_auth")

    @disable_local_auth.setter
    def disable_local_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_local_auth", value)

    @property
    @pulumi.getter
    def encryption(self) -> Optional[pulumi.Input['EncryptionArgs']]:
        """
        All encryption configuration for a resource.
        """
        return pulumi.get(self, "encryption")

    @encryption.setter
    def encryption(self, value: Optional[pulumi.Input['EncryptionArgs']]):
        pulumi.set(self, "encryption", value)

    @property
    @pulumi.getter(name="linkedResources")
    def linked_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LinkedResourceArgs']]]]:
        """
        The array of associated resources to the Maps account. Linked resource in the array cannot individually update, you must update all linked resources in the array together. These resources may be used on operations on the Azure Maps REST API. Access is controlled by the Maps Account Managed Identity(s) permissions to those resource(s).
        """
        return pulumi.get(self, "linked_resources")

    @linked_resources.setter
    def linked_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LinkedResourceArgs']]]]):
        pulumi.set(self, "linked_resources", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MapsAccountPropertiesLocationsArgs']]]]:
        """
        List of additional data processing regions for the Maps Account, which may result in requests being processed in another geography. Some features or results may be restricted to specific regions. By default, Maps REST APIs process requests according to the account location or the [geographic scope](https://learn.microsoft.com/azure/azure-maps/geographic-scope).
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MapsAccountPropertiesLocationsArgs']]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class SkuArgsDict(TypedDict):
        """
        The SKU of the Maps Account.
        """
        name: pulumi.Input[Union[str, 'Name']]
        """
        The name of the SKU, in standard format (such as G2).
        """
elif False:
    SkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[Union[str, 'Name']]):
        """
        The SKU of the Maps Account.
        :param pulumi.Input[Union[str, 'Name']] name: The name of the SKU, in standard format (such as G2).
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[Union[str, 'Name']]:
        """
        The name of the SKU, in standard format (such as G2).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[Union[str, 'Name']]):
        pulumi.set(self, "name", value)


