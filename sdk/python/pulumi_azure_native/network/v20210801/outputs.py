# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'DnsSettingsResponse',
    'ExplicitProxySettingsResponse',
    'FirewallPolicyCertificateAuthorityResponse',
    'FirewallPolicyInsightsResponse',
    'FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse',
    'FirewallPolicyIntrusionDetectionConfigurationResponse',
    'FirewallPolicyIntrusionDetectionResponse',
    'FirewallPolicyIntrusionDetectionSignatureSpecificationResponse',
    'FirewallPolicyLogAnalyticsResourcesResponse',
    'FirewallPolicyLogAnalyticsWorkspaceResponse',
    'FirewallPolicySNATResponse',
    'FirewallPolicySQLResponse',
    'FirewallPolicySkuResponse',
    'FirewallPolicyThreatIntelWhitelistResponse',
    'FirewallPolicyTransportSecurityResponse',
    'ManagedServiceIdentityResponse',
    'ManagedServiceIdentityResponseUserAssignedIdentities',
    'SingleQueryResultResponse',
    'SubResourceResponse',
]

@pulumi.output_type
class DnsSettingsResponse(dict):
    """
    DNS Proxy Settings in Firewall Policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableProxy":
            suggest = "enable_proxy"
        elif key == "requireProxyForNetworkRules":
            suggest = "require_proxy_for_network_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DnsSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DnsSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DnsSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_proxy: Optional[bool] = None,
                 require_proxy_for_network_rules: Optional[bool] = None,
                 servers: Optional[Sequence[str]] = None):
        """
        DNS Proxy Settings in Firewall Policy.
        :param bool enable_proxy: Enable DNS Proxy on Firewalls attached to the Firewall Policy.
        :param bool require_proxy_for_network_rules: FQDNs in Network Rules are supported when set to true.
        :param Sequence[str] servers: List of Custom DNS Servers.
        """
        if enable_proxy is not None:
            pulumi.set(__self__, "enable_proxy", enable_proxy)
        if require_proxy_for_network_rules is not None:
            pulumi.set(__self__, "require_proxy_for_network_rules", require_proxy_for_network_rules)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter(name="enableProxy")
    def enable_proxy(self) -> Optional[bool]:
        """
        Enable DNS Proxy on Firewalls attached to the Firewall Policy.
        """
        return pulumi.get(self, "enable_proxy")

    @property
    @pulumi.getter(name="requireProxyForNetworkRules")
    def require_proxy_for_network_rules(self) -> Optional[bool]:
        """
        FQDNs in Network Rules are supported when set to true.
        """
        return pulumi.get(self, "require_proxy_for_network_rules")

    @property
    @pulumi.getter
    def servers(self) -> Optional[Sequence[str]]:
        """
        List of Custom DNS Servers.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class ExplicitProxySettingsResponse(dict):
    """
    Explicit Proxy Settings in Firewall Policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableExplicitProxy":
            suggest = "enable_explicit_proxy"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "pacFile":
            suggest = "pac_file"
        elif key == "pacFilePort":
            suggest = "pac_file_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExplicitProxySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExplicitProxySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExplicitProxySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_explicit_proxy: Optional[bool] = None,
                 http_port: Optional[int] = None,
                 https_port: Optional[int] = None,
                 pac_file: Optional[str] = None,
                 pac_file_port: Optional[int] = None):
        """
        Explicit Proxy Settings in Firewall Policy.
        :param bool enable_explicit_proxy: When set to true, explicit proxy mode is enabled.
        :param int http_port: Port number for explicit proxy http protocol, cannot be greater than 64000.
        :param int https_port: Port number for explicit proxy https protocol, cannot be greater than 64000.
        :param str pac_file: SAS URL for PAC file.
        :param int pac_file_port: Port number for firewall to serve PAC file.
        """
        if enable_explicit_proxy is not None:
            pulumi.set(__self__, "enable_explicit_proxy", enable_explicit_proxy)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if pac_file is not None:
            pulumi.set(__self__, "pac_file", pac_file)
        if pac_file_port is not None:
            pulumi.set(__self__, "pac_file_port", pac_file_port)

    @property
    @pulumi.getter(name="enableExplicitProxy")
    def enable_explicit_proxy(self) -> Optional[bool]:
        """
        When set to true, explicit proxy mode is enabled.
        """
        return pulumi.get(self, "enable_explicit_proxy")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        Port number for explicit proxy http protocol, cannot be greater than 64000.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[int]:
        """
        Port number for explicit proxy https protocol, cannot be greater than 64000.
        """
        return pulumi.get(self, "https_port")

    @property
    @pulumi.getter(name="pacFile")
    def pac_file(self) -> Optional[str]:
        """
        SAS URL for PAC file.
        """
        return pulumi.get(self, "pac_file")

    @property
    @pulumi.getter(name="pacFilePort")
    def pac_file_port(self) -> Optional[int]:
        """
        Port number for firewall to serve PAC file.
        """
        return pulumi.get(self, "pac_file_port")


@pulumi.output_type
class FirewallPolicyCertificateAuthorityResponse(dict):
    """
    Trusted Root certificates properties for tls.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultSecretId":
            suggest = "key_vault_secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyCertificateAuthorityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyCertificateAuthorityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyCertificateAuthorityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_secret_id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Trusted Root certificates properties for tls.
        :param str key_vault_secret_id: Secret Id of (base-64 encoded unencrypted pfx) 'Secret' or 'Certificate' object stored in KeyVault.
        :param str name: Name of the CA certificate.
        """
        if key_vault_secret_id is not None:
            pulumi.set(__self__, "key_vault_secret_id", key_vault_secret_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="keyVaultSecretId")
    def key_vault_secret_id(self) -> Optional[str]:
        """
        Secret Id of (base-64 encoded unencrypted pfx) 'Secret' or 'Certificate' object stored in KeyVault.
        """
        return pulumi.get(self, "key_vault_secret_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the CA certificate.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FirewallPolicyInsightsResponse(dict):
    """
    Firewall Policy Insights.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "logAnalyticsResources":
            suggest = "log_analytics_resources"
        elif key == "retentionDays":
            suggest = "retention_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyInsightsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyInsightsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyInsightsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: Optional[bool] = None,
                 log_analytics_resources: Optional['outputs.FirewallPolicyLogAnalyticsResourcesResponse'] = None,
                 retention_days: Optional[int] = None):
        """
        Firewall Policy Insights.
        :param bool is_enabled: A flag to indicate if the insights are enabled on the policy.
        :param 'FirewallPolicyLogAnalyticsResourcesResponse' log_analytics_resources: Workspaces needed to configure the Firewall Policy Insights.
        :param int retention_days: Number of days the insights should be enabled on the policy.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if log_analytics_resources is not None:
            pulumi.set(__self__, "log_analytics_resources", log_analytics_resources)
        if retention_days is not None:
            pulumi.set(__self__, "retention_days", retention_days)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        A flag to indicate if the insights are enabled on the policy.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="logAnalyticsResources")
    def log_analytics_resources(self) -> Optional['outputs.FirewallPolicyLogAnalyticsResourcesResponse']:
        """
        Workspaces needed to configure the Firewall Policy Insights.
        """
        return pulumi.get(self, "log_analytics_resources")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[int]:
        """
        Number of days the insights should be enabled on the policy.
        """
        return pulumi.get(self, "retention_days")


@pulumi.output_type
class FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse(dict):
    """
    Intrusion detection bypass traffic specification.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationIpGroups":
            suggest = "destination_ip_groups"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_ip_groups: Optional[Sequence[str]] = None,
                 destination_ports: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        Intrusion detection bypass traffic specification.
        :param str description: Description of the bypass traffic rule.
        :param Sequence[str] destination_addresses: List of destination IP addresses or ranges for this rule.
        :param Sequence[str] destination_ip_groups: List of destination IpGroups for this rule.
        :param Sequence[str] destination_ports: List of destination ports or ranges.
        :param str name: Name of the bypass traffic rule.
        :param str protocol: The rule bypass protocol.
        :param Sequence[str] source_addresses: List of source IP addresses or ranges for this rule.
        :param Sequence[str] source_ip_groups: List of source IpGroups for this rule.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_ip_groups is not None:
            pulumi.set(__self__, "destination_ip_groups", destination_ip_groups)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the bypass traffic rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        List of destination IP addresses or ranges for this rule.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationIpGroups")
    def destination_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of destination IpGroups for this rule.
        """
        return pulumi.get(self, "destination_ip_groups")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[str]]:
        """
        List of destination ports or ranges.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the bypass traffic rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The rule bypass protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        List of source IP addresses or ranges for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class FirewallPolicyIntrusionDetectionConfigurationResponse(dict):
    """
    The operation for configuring intrusion detection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bypassTrafficSettings":
            suggest = "bypass_traffic_settings"
        elif key == "privateRanges":
            suggest = "private_ranges"
        elif key == "signatureOverrides":
            suggest = "signature_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyIntrusionDetectionConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyIntrusionDetectionConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyIntrusionDetectionConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bypass_traffic_settings: Optional[Sequence['outputs.FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse']] = None,
                 private_ranges: Optional[Sequence[str]] = None,
                 signature_overrides: Optional[Sequence['outputs.FirewallPolicyIntrusionDetectionSignatureSpecificationResponse']] = None):
        """
        The operation for configuring intrusion detection.
        :param Sequence['FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse'] bypass_traffic_settings: List of rules for traffic to bypass.
        :param Sequence[str] private_ranges: IDPS Private IP address ranges are used to identify traffic direction (i.e. inbound, outbound, etc.). By default, only ranges defined by IANA RFC 1918 are considered private IP addresses. To modify default ranges, specify your Private IP address ranges with this property
        :param Sequence['FirewallPolicyIntrusionDetectionSignatureSpecificationResponse'] signature_overrides: List of specific signatures states.
        """
        if bypass_traffic_settings is not None:
            pulumi.set(__self__, "bypass_traffic_settings", bypass_traffic_settings)
        if private_ranges is not None:
            pulumi.set(__self__, "private_ranges", private_ranges)
        if signature_overrides is not None:
            pulumi.set(__self__, "signature_overrides", signature_overrides)

    @property
    @pulumi.getter(name="bypassTrafficSettings")
    def bypass_traffic_settings(self) -> Optional[Sequence['outputs.FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse']]:
        """
        List of rules for traffic to bypass.
        """
        return pulumi.get(self, "bypass_traffic_settings")

    @property
    @pulumi.getter(name="privateRanges")
    def private_ranges(self) -> Optional[Sequence[str]]:
        """
        IDPS Private IP address ranges are used to identify traffic direction (i.e. inbound, outbound, etc.). By default, only ranges defined by IANA RFC 1918 are considered private IP addresses. To modify default ranges, specify your Private IP address ranges with this property
        """
        return pulumi.get(self, "private_ranges")

    @property
    @pulumi.getter(name="signatureOverrides")
    def signature_overrides(self) -> Optional[Sequence['outputs.FirewallPolicyIntrusionDetectionSignatureSpecificationResponse']]:
        """
        List of specific signatures states.
        """
        return pulumi.get(self, "signature_overrides")


@pulumi.output_type
class FirewallPolicyIntrusionDetectionResponse(dict):
    """
    Configuration for intrusion detection mode and rules.
    """
    def __init__(__self__, *,
                 configuration: Optional['outputs.FirewallPolicyIntrusionDetectionConfigurationResponse'] = None,
                 mode: Optional[str] = None):
        """
        Configuration for intrusion detection mode and rules.
        :param 'FirewallPolicyIntrusionDetectionConfigurationResponse' configuration: Intrusion detection configuration properties.
        :param str mode: Intrusion detection general state.
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.FirewallPolicyIntrusionDetectionConfigurationResponse']:
        """
        Intrusion detection configuration properties.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Intrusion detection general state.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class FirewallPolicyIntrusionDetectionSignatureSpecificationResponse(dict):
    """
    Intrusion detection signatures specification states.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        Intrusion detection signatures specification states.
        :param str id: Signature id.
        :param str mode: The signature state.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Signature id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The signature state.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class FirewallPolicyLogAnalyticsResourcesResponse(dict):
    """
    Log Analytics Resources for Firewall Policy Insights.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultWorkspaceId":
            suggest = "default_workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyLogAnalyticsResourcesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyLogAnalyticsResourcesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyLogAnalyticsResourcesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_workspace_id: Optional['outputs.SubResourceResponse'] = None,
                 workspaces: Optional[Sequence['outputs.FirewallPolicyLogAnalyticsWorkspaceResponse']] = None):
        """
        Log Analytics Resources for Firewall Policy Insights.
        :param 'SubResourceResponse' default_workspace_id: The default workspace Id for Firewall Policy Insights.
        :param Sequence['FirewallPolicyLogAnalyticsWorkspaceResponse'] workspaces: List of workspaces for Firewall Policy Insights.
        """
        if default_workspace_id is not None:
            pulumi.set(__self__, "default_workspace_id", default_workspace_id)
        if workspaces is not None:
            pulumi.set(__self__, "workspaces", workspaces)

    @property
    @pulumi.getter(name="defaultWorkspaceId")
    def default_workspace_id(self) -> Optional['outputs.SubResourceResponse']:
        """
        The default workspace Id for Firewall Policy Insights.
        """
        return pulumi.get(self, "default_workspace_id")

    @property
    @pulumi.getter
    def workspaces(self) -> Optional[Sequence['outputs.FirewallPolicyLogAnalyticsWorkspaceResponse']]:
        """
        List of workspaces for Firewall Policy Insights.
        """
        return pulumi.get(self, "workspaces")


@pulumi.output_type
class FirewallPolicyLogAnalyticsWorkspaceResponse(dict):
    """
    Log Analytics Workspace for Firewall Policy Insights.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyLogAnalyticsWorkspaceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyLogAnalyticsWorkspaceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyLogAnalyticsWorkspaceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: Optional[str] = None,
                 workspace_id: Optional['outputs.SubResourceResponse'] = None):
        """
        Log Analytics Workspace for Firewall Policy Insights.
        :param str region: Region to configure the Workspace.
        :param 'SubResourceResponse' workspace_id: The workspace Id for Firewall Policy Insights.
        """
        if region is not None:
            pulumi.set(__self__, "region", region)
        if workspace_id is not None:
            pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region to configure the Workspace.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> Optional['outputs.SubResourceResponse']:
        """
        The workspace Id for Firewall Policy Insights.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class FirewallPolicySNATResponse(dict):
    """
    The private IP addresses/IP ranges to which traffic will not be SNAT.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateRanges":
            suggest = "private_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicySNATResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicySNATResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicySNATResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_ranges: Optional[Sequence[str]] = None):
        """
        The private IP addresses/IP ranges to which traffic will not be SNAT.
        :param Sequence[str] private_ranges: List of private IP addresses/IP address ranges to not be SNAT.
        """
        if private_ranges is not None:
            pulumi.set(__self__, "private_ranges", private_ranges)

    @property
    @pulumi.getter(name="privateRanges")
    def private_ranges(self) -> Optional[Sequence[str]]:
        """
        List of private IP addresses/IP address ranges to not be SNAT.
        """
        return pulumi.get(self, "private_ranges")


@pulumi.output_type
class FirewallPolicySQLResponse(dict):
    """
    SQL Settings in Firewall Policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSqlRedirect":
            suggest = "allow_sql_redirect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicySQLResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicySQLResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicySQLResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_sql_redirect: Optional[bool] = None):
        """
        SQL Settings in Firewall Policy.
        :param bool allow_sql_redirect: A flag to indicate if SQL Redirect traffic filtering is enabled. Turning on the flag requires no rule using port 11000-11999.
        """
        if allow_sql_redirect is not None:
            pulumi.set(__self__, "allow_sql_redirect", allow_sql_redirect)

    @property
    @pulumi.getter(name="allowSqlRedirect")
    def allow_sql_redirect(self) -> Optional[bool]:
        """
        A flag to indicate if SQL Redirect traffic filtering is enabled. Turning on the flag requires no rule using port 11000-11999.
        """
        return pulumi.get(self, "allow_sql_redirect")


@pulumi.output_type
class FirewallPolicySkuResponse(dict):
    """
    SKU of Firewall policy.
    """
    def __init__(__self__, *,
                 tier: Optional[str] = None):
        """
        SKU of Firewall policy.
        :param str tier: Tier of Firewall Policy.
        """
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        Tier of Firewall Policy.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class FirewallPolicyThreatIntelWhitelistResponse(dict):
    """
    ThreatIntel Whitelist for Firewall Policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyThreatIntelWhitelistResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyThreatIntelWhitelistResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyThreatIntelWhitelistResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdns: Optional[Sequence[str]] = None,
                 ip_addresses: Optional[Sequence[str]] = None):
        """
        ThreatIntel Whitelist for Firewall Policy.
        :param Sequence[str] fqdns: List of FQDNs for the ThreatIntel Whitelist.
        :param Sequence[str] ip_addresses: List of IP addresses for the ThreatIntel Whitelist.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[Sequence[str]]:
        """
        List of FQDNs for the ThreatIntel Whitelist.
        """
        return pulumi.get(self, "fqdns")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        List of IP addresses for the ThreatIntel Whitelist.
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class FirewallPolicyTransportSecurityResponse(dict):
    """
    Configuration needed to perform TLS termination & initiation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateAuthority":
            suggest = "certificate_authority"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyTransportSecurityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyTransportSecurityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyTransportSecurityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_authority: Optional['outputs.FirewallPolicyCertificateAuthorityResponse'] = None):
        """
        Configuration needed to perform TLS termination & initiation.
        :param 'FirewallPolicyCertificateAuthorityResponse' certificate_authority: The CA used for intermediate CA generation.
        """
        if certificate_authority is not None:
            pulumi.set(__self__, "certificate_authority", certificate_authority)

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> Optional['outputs.FirewallPolicyCertificateAuthorityResponse']:
        """
        The CA used for intermediate CA generation.
        """
        return pulumi.get(self, "certificate_authority")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Identity for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.ManagedServiceIdentityResponseUserAssignedIdentities']] = None):
        """
        Identity for the resource.
        :param str principal_id: The principal id of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant id of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str type: The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine.
        :param Mapping[str, 'ManagedServiceIdentityResponseUserAssignedIdentities'] user_assigned_identities: The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal id of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant id of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.ManagedServiceIdentityResponseUserAssignedIdentities']]:
        """
        The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ManagedServiceIdentityResponseUserAssignedIdentities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponseUserAssignedIdentities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        :param str client_id: The client id of user assigned identity.
        :param str principal_id: The principal id of user assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client id of user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal id of user assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class SingleQueryResultResponse(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 destination_ports: Optional[Sequence[str]] = None,
                 direction: Optional[int] = None,
                 group: Optional[str] = None,
                 inherited_from_parent_policy: Optional[bool] = None,
                 last_updated: Optional[str] = None,
                 mode: Optional[int] = None,
                 protocol: Optional[str] = None,
                 severity: Optional[int] = None,
                 signature_id: Optional[int] = None,
                 source_ports: Optional[Sequence[str]] = None):
        """
        :param str description: Describes what is the signature enforces
        :param Sequence[str] destination_ports: Describes the list of destination ports related to this signature
        :param int direction: Describes in which direction signature is being enforced: 0 - Inbound, 1 - OutBound, 2 - Bidirectional
        :param str group: Describes the groups the signature belongs to
        :param bool inherited_from_parent_policy: Describes if this override is inherited from base policy or not
        :param str last_updated: Describes the last updated time of the signature (provided from 3rd party vendor)
        :param int mode: The current mode enforced, 0 - Disabled, 1 - Alert, 2 -Deny
        :param str protocol: Describes the protocol the signatures is being enforced in
        :param int severity: Describes the severity of signature: 1 - Low, 2 - Medium, 3 - High
        :param int signature_id: The ID of the signature
        :param Sequence[str] source_ports: Describes the list of source ports related to this signature
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if inherited_from_parent_policy is not None:
            pulumi.set(__self__, "inherited_from_parent_policy", inherited_from_parent_policy)
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if signature_id is not None:
            pulumi.set(__self__, "signature_id", signature_id)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Describes what is the signature enforces
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[str]]:
        """
        Describes the list of destination ports related to this signature
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter
    def direction(self) -> Optional[int]:
        """
        Describes in which direction signature is being enforced: 0 - Inbound, 1 - OutBound, 2 - Bidirectional
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Describes the groups the signature belongs to
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="inheritedFromParentPolicy")
    def inherited_from_parent_policy(self) -> Optional[bool]:
        """
        Describes if this override is inherited from base policy or not
        """
        return pulumi.get(self, "inherited_from_parent_policy")

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[str]:
        """
        Describes the last updated time of the signature (provided from 3rd party vendor)
        """
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter
    def mode(self) -> Optional[int]:
        """
        The current mode enforced, 0 - Disabled, 1 - Alert, 2 -Deny
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Describes the protocol the signatures is being enforced in
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def severity(self) -> Optional[int]:
        """
        Describes the severity of signature: 1 - Low, 2 - Medium, 3 - High
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter(name="signatureId")
    def signature_id(self) -> Optional[int]:
        """
        The ID of the signature
        """
        return pulumi.get(self, "signature_id")

    @property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[Sequence[str]]:
        """
        Describes the list of source ports related to this signature
        """
        return pulumi.get(self, "source_ports")


@pulumi.output_type
class SubResourceResponse(dict):
    """
    Reference to another subresource.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Reference to another subresource.
        :param str id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")


