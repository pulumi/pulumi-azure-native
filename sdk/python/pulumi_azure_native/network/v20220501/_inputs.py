# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'CustomRuleListArgs',
    'CustomRuleArgs',
    'FrontDoorManagedRuleGroupOverrideArgs',
    'FrontDoorManagedRuleOverrideArgs',
    'FrontDoorManagedRuleSetArgs',
    'FrontDoorMatchConditionArgs',
    'FrontDoorPolicySettingsArgs',
    'ManagedRuleExclusionArgs',
    'ManagedRuleSetListArgs',
    'SkuArgs',
]

@pulumi.input_type
class CustomRuleListArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleArgs']]]] = None):
        """
        Defines contents of custom rules
        :param pulumi.Input[Sequence[pulumi.Input['CustomRuleArgs']]] rules: List of rules
        """
        CustomRuleListArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleArgs']]]]:
        """
        List of rules
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class CustomRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[Union[str, 'ActionType']],
                 match_conditions: pulumi.Input[Sequence[pulumi.Input['FrontDoorMatchConditionArgs']]],
                 priority: pulumi.Input[int],
                 rule_type: pulumi.Input[Union[str, 'RuleType']],
                 enabled_state: Optional[pulumi.Input[Union[str, 'CustomRuleEnabledState']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 rate_limit_duration_in_minutes: Optional[pulumi.Input[int]] = None,
                 rate_limit_threshold: Optional[pulumi.Input[int]] = None):
        """
        Defines contents of a web application rule
        :param pulumi.Input[Union[str, 'ActionType']] action: Describes what action to be applied when rule matches.
        :param pulumi.Input[Sequence[pulumi.Input['FrontDoorMatchConditionArgs']]] match_conditions: List of match conditions.
        :param pulumi.Input[int] priority: Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
        :param pulumi.Input[Union[str, 'RuleType']] rule_type: Describes type of rule.
        :param pulumi.Input[Union[str, 'CustomRuleEnabledState']] enabled_state: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
        :param pulumi.Input[str] name: Describes the name of the rule.
        :param pulumi.Input[int] rate_limit_duration_in_minutes: Time window for resetting the rate limit count. Default is 1 minute.
        :param pulumi.Input[int] rate_limit_threshold: Number of allowed requests per client within the time window.
        """
        CustomRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            match_conditions=match_conditions,
            priority=priority,
            rule_type=rule_type,
            enabled_state=enabled_state,
            name=name,
            rate_limit_duration_in_minutes=rate_limit_duration_in_minutes,
            rate_limit_threshold=rate_limit_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[pulumi.Input[Union[str, 'ActionType']]] = None,
             match_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['FrontDoorMatchConditionArgs']]]] = None,
             priority: Optional[pulumi.Input[int]] = None,
             rule_type: Optional[pulumi.Input[Union[str, 'RuleType']]] = None,
             enabled_state: Optional[pulumi.Input[Union[str, 'CustomRuleEnabledState']]] = None,
             name: Optional[pulumi.Input[str]] = None,
             rate_limit_duration_in_minutes: Optional[pulumi.Input[int]] = None,
             rate_limit_threshold: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if match_conditions is None and 'matchConditions' in kwargs:
            match_conditions = kwargs['matchConditions']
        if match_conditions is None:
            raise TypeError("Missing 'match_conditions' argument")
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if rule_type is None and 'ruleType' in kwargs:
            rule_type = kwargs['ruleType']
        if rule_type is None:
            raise TypeError("Missing 'rule_type' argument")
        if enabled_state is None and 'enabledState' in kwargs:
            enabled_state = kwargs['enabledState']
        if rate_limit_duration_in_minutes is None and 'rateLimitDurationInMinutes' in kwargs:
            rate_limit_duration_in_minutes = kwargs['rateLimitDurationInMinutes']
        if rate_limit_threshold is None and 'rateLimitThreshold' in kwargs:
            rate_limit_threshold = kwargs['rateLimitThreshold']

        _setter("action", action)
        _setter("match_conditions", match_conditions)
        _setter("priority", priority)
        _setter("rule_type", rule_type)
        if enabled_state is not None:
            _setter("enabled_state", enabled_state)
        if name is not None:
            _setter("name", name)
        if rate_limit_duration_in_minutes is not None:
            _setter("rate_limit_duration_in_minutes", rate_limit_duration_in_minutes)
        if rate_limit_threshold is not None:
            _setter("rate_limit_threshold", rate_limit_threshold)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[Union[str, 'ActionType']]:
        """
        Describes what action to be applied when rule matches.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[Union[str, 'ActionType']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> pulumi.Input[Sequence[pulumi.Input['FrontDoorMatchConditionArgs']]]:
        """
        List of match conditions.
        """
        return pulumi.get(self, "match_conditions")

    @match_conditions.setter
    def match_conditions(self, value: pulumi.Input[Sequence[pulumi.Input['FrontDoorMatchConditionArgs']]]):
        pulumi.set(self, "match_conditions", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[Union[str, 'RuleType']]:
        """
        Describes type of rule.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[Union[str, 'RuleType']]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[pulumi.Input[Union[str, 'CustomRuleEnabledState']]]:
        """
        Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
        """
        return pulumi.get(self, "enabled_state")

    @enabled_state.setter
    def enabled_state(self, value: Optional[pulumi.Input[Union[str, 'CustomRuleEnabledState']]]):
        pulumi.set(self, "enabled_state", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Describes the name of the rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="rateLimitDurationInMinutes")
    def rate_limit_duration_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Time window for resetting the rate limit count. Default is 1 minute.
        """
        return pulumi.get(self, "rate_limit_duration_in_minutes")

    @rate_limit_duration_in_minutes.setter
    def rate_limit_duration_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rate_limit_duration_in_minutes", value)

    @property
    @pulumi.getter(name="rateLimitThreshold")
    def rate_limit_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Number of allowed requests per client within the time window.
        """
        return pulumi.get(self, "rate_limit_threshold")

    @rate_limit_threshold.setter
    def rate_limit_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rate_limit_threshold", value)


@pulumi.input_type
class FrontDoorManagedRuleGroupOverrideArgs:
    def __init__(__self__, *,
                 rule_group_name: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleOverrideArgs']]]] = None):
        """
        Defines a managed rule group override setting.
        :param pulumi.Input[str] rule_group_name: Describes the managed rule group to override.
        :param pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]] exclusions: Describes the exclusions that are applied to all rules in the group.
        :param pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleOverrideArgs']]] rules: List of rules that will be disabled. If none specified, all rules in the group will be disabled.
        """
        FrontDoorManagedRuleGroupOverrideArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_group_name=rule_group_name,
            exclusions=exclusions,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_group_name: Optional[pulumi.Input[str]] = None,
             exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]]] = None,
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleOverrideArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_group_name is None and 'ruleGroupName' in kwargs:
            rule_group_name = kwargs['ruleGroupName']
        if rule_group_name is None:
            raise TypeError("Missing 'rule_group_name' argument")

        _setter("rule_group_name", rule_group_name)
        if exclusions is not None:
            _setter("exclusions", exclusions)
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter(name="ruleGroupName")
    def rule_group_name(self) -> pulumi.Input[str]:
        """
        Describes the managed rule group to override.
        """
        return pulumi.get(self, "rule_group_name")

    @rule_group_name.setter
    def rule_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_group_name", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]]]:
        """
        Describes the exclusions that are applied to all rules in the group.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleOverrideArgs']]]]:
        """
        List of rules that will be disabled. If none specified, all rules in the group will be disabled.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleOverrideArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class FrontDoorManagedRuleOverrideArgs:
    def __init__(__self__, *,
                 rule_id: pulumi.Input[str],
                 action: Optional[pulumi.Input[Union[str, 'ActionType']]] = None,
                 enabled_state: Optional[pulumi.Input[Union[str, 'ManagedRuleEnabledState']]] = None,
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]]] = None):
        """
        Defines a managed rule group override setting.
        :param pulumi.Input[str] rule_id: Identifier for the managed rule.
        :param pulumi.Input[Union[str, 'ActionType']] action: Describes the override action to be applied when rule matches.
        :param pulumi.Input[Union[str, 'ManagedRuleEnabledState']] enabled_state: Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
        :param pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]] exclusions: Describes the exclusions that are applied to this specific rule.
        """
        FrontDoorManagedRuleOverrideArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_id=rule_id,
            action=action,
            enabled_state=enabled_state,
            exclusions=exclusions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_id: Optional[pulumi.Input[str]] = None,
             action: Optional[pulumi.Input[Union[str, 'ActionType']]] = None,
             enabled_state: Optional[pulumi.Input[Union[str, 'ManagedRuleEnabledState']]] = None,
             exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_id is None and 'ruleId' in kwargs:
            rule_id = kwargs['ruleId']
        if rule_id is None:
            raise TypeError("Missing 'rule_id' argument")
        if enabled_state is None and 'enabledState' in kwargs:
            enabled_state = kwargs['enabledState']

        _setter("rule_id", rule_id)
        if action is not None:
            _setter("action", action)
        if enabled_state is not None:
            _setter("enabled_state", enabled_state)
        if exclusions is not None:
            _setter("exclusions", exclusions)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Input[str]:
        """
        Identifier for the managed rule.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[Union[str, 'ActionType']]]:
        """
        Describes the override action to be applied when rule matches.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[Union[str, 'ActionType']]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[pulumi.Input[Union[str, 'ManagedRuleEnabledState']]]:
        """
        Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
        """
        return pulumi.get(self, "enabled_state")

    @enabled_state.setter
    def enabled_state(self, value: Optional[pulumi.Input[Union[str, 'ManagedRuleEnabledState']]]):
        pulumi.set(self, "enabled_state", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]]]:
        """
        Describes the exclusions that are applied to this specific rule.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]]]):
        pulumi.set(self, "exclusions", value)


@pulumi.input_type
class FrontDoorManagedRuleSetArgs:
    def __init__(__self__, *,
                 rule_set_type: pulumi.Input[str],
                 rule_set_version: pulumi.Input[str],
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]]] = None,
                 rule_group_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleGroupOverrideArgs']]]] = None,
                 rule_set_action: Optional[pulumi.Input[Union[str, 'ManagedRuleSetActionType']]] = None):
        """
        Defines a managed rule set.
        :param pulumi.Input[str] rule_set_type: Defines the rule set type to use.
        :param pulumi.Input[str] rule_set_version: Defines the version of the rule set to use.
        :param pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]] exclusions: Describes the exclusions that are applied to all rules in the set.
        :param pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleGroupOverrideArgs']]] rule_group_overrides: Defines the rule group overrides to apply to the rule set.
        :param pulumi.Input[Union[str, 'ManagedRuleSetActionType']] rule_set_action: Defines the rule set action.
        """
        FrontDoorManagedRuleSetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_set_type=rule_set_type,
            rule_set_version=rule_set_version,
            exclusions=exclusions,
            rule_group_overrides=rule_group_overrides,
            rule_set_action=rule_set_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_set_type: Optional[pulumi.Input[str]] = None,
             rule_set_version: Optional[pulumi.Input[str]] = None,
             exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]]] = None,
             rule_group_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleGroupOverrideArgs']]]] = None,
             rule_set_action: Optional[pulumi.Input[Union[str, 'ManagedRuleSetActionType']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_set_type is None and 'ruleSetType' in kwargs:
            rule_set_type = kwargs['ruleSetType']
        if rule_set_type is None:
            raise TypeError("Missing 'rule_set_type' argument")
        if rule_set_version is None and 'ruleSetVersion' in kwargs:
            rule_set_version = kwargs['ruleSetVersion']
        if rule_set_version is None:
            raise TypeError("Missing 'rule_set_version' argument")
        if rule_group_overrides is None and 'ruleGroupOverrides' in kwargs:
            rule_group_overrides = kwargs['ruleGroupOverrides']
        if rule_set_action is None and 'ruleSetAction' in kwargs:
            rule_set_action = kwargs['ruleSetAction']

        _setter("rule_set_type", rule_set_type)
        _setter("rule_set_version", rule_set_version)
        if exclusions is not None:
            _setter("exclusions", exclusions)
        if rule_group_overrides is not None:
            _setter("rule_group_overrides", rule_group_overrides)
        if rule_set_action is not None:
            _setter("rule_set_action", rule_set_action)

    @property
    @pulumi.getter(name="ruleSetType")
    def rule_set_type(self) -> pulumi.Input[str]:
        """
        Defines the rule set type to use.
        """
        return pulumi.get(self, "rule_set_type")

    @rule_set_type.setter
    def rule_set_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_set_type", value)

    @property
    @pulumi.getter(name="ruleSetVersion")
    def rule_set_version(self) -> pulumi.Input[str]:
        """
        Defines the version of the rule set to use.
        """
        return pulumi.get(self, "rule_set_version")

    @rule_set_version.setter
    def rule_set_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_set_version", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]]]:
        """
        Describes the exclusions that are applied to all rules in the set.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleExclusionArgs']]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter(name="ruleGroupOverrides")
    def rule_group_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleGroupOverrideArgs']]]]:
        """
        Defines the rule group overrides to apply to the rule set.
        """
        return pulumi.get(self, "rule_group_overrides")

    @rule_group_overrides.setter
    def rule_group_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleGroupOverrideArgs']]]]):
        pulumi.set(self, "rule_group_overrides", value)

    @property
    @pulumi.getter(name="ruleSetAction")
    def rule_set_action(self) -> Optional[pulumi.Input[Union[str, 'ManagedRuleSetActionType']]]:
        """
        Defines the rule set action.
        """
        return pulumi.get(self, "rule_set_action")

    @rule_set_action.setter
    def rule_set_action(self, value: Optional[pulumi.Input[Union[str, 'ManagedRuleSetActionType']]]):
        pulumi.set(self, "rule_set_action", value)


@pulumi.input_type
class FrontDoorMatchConditionArgs:
    def __init__(__self__, *,
                 match_value: pulumi.Input[Sequence[pulumi.Input[str]]],
                 match_variable: pulumi.Input[Union[str, 'FrontDoorMatchVariable']],
                 operator: pulumi.Input[Union[str, 'Operator']],
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 selector: Optional[pulumi.Input[str]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'TransformType']]]]] = None):
        """
        Define a match condition.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_value: List of possible match values.
        :param pulumi.Input[Union[str, 'FrontDoorMatchVariable']] match_variable: Request variable to compare with.
        :param pulumi.Input[Union[str, 'Operator']] operator: Comparison type to use for matching with the variable value.
        :param pulumi.Input[bool] negate_condition: Describes if the result of this condition should be negated.
        :param pulumi.Input[str] selector: Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies variables. Default is null.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'TransformType']]]] transforms: List of transforms.
        """
        FrontDoorMatchConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_value=match_value,
            match_variable=match_variable,
            operator=operator,
            negate_condition=negate_condition,
            selector=selector,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             match_variable: Optional[pulumi.Input[Union[str, 'FrontDoorMatchVariable']]] = None,
             operator: Optional[pulumi.Input[Union[str, 'Operator']]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             selector: Optional[pulumi.Input[str]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'TransformType']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_value is None and 'matchValue' in kwargs:
            match_value = kwargs['matchValue']
        if match_value is None:
            raise TypeError("Missing 'match_value' argument")
        if match_variable is None and 'matchVariable' in kwargs:
            match_variable = kwargs['matchVariable']
        if match_variable is None:
            raise TypeError("Missing 'match_variable' argument")
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("match_value", match_value)
        _setter("match_variable", match_variable)
        _setter("operator", operator)
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if selector is not None:
            _setter("selector", selector)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of possible match values.
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> pulumi.Input[Union[str, 'FrontDoorMatchVariable']]:
        """
        Request variable to compare with.
        """
        return pulumi.get(self, "match_variable")

    @match_variable.setter
    def match_variable(self, value: pulumi.Input[Union[str, 'FrontDoorMatchVariable']]):
        pulumi.set(self, "match_variable", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'Operator']]:
        """
        Comparison type to use for matching with the variable value.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'Operator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if the result of this condition should be negated.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[str]]:
        """
        Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies variables. Default is null.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'TransformType']]]]]:
        """
        List of transforms.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'TransformType']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class FrontDoorPolicySettingsArgs:
    def __init__(__self__, *,
                 custom_block_response_body: Optional[pulumi.Input[str]] = None,
                 custom_block_response_status_code: Optional[pulumi.Input[int]] = None,
                 enabled_state: Optional[pulumi.Input[Union[str, 'PolicyEnabledState']]] = None,
                 mode: Optional[pulumi.Input[Union[str, 'PolicyMode']]] = None,
                 redirect_url: Optional[pulumi.Input[str]] = None,
                 request_body_check: Optional[pulumi.Input[Union[str, 'PolicyRequestBodyCheck']]] = None):
        """
        Defines top-level WebApplicationFirewallPolicy configuration settings.
        :param pulumi.Input[str] custom_block_response_body: If the action type is block, customer can override the response body. The body must be specified in base64 encoding.
        :param pulumi.Input[int] custom_block_response_status_code: If the action type is block, customer can override the response status code.
        :param pulumi.Input[Union[str, 'PolicyEnabledState']] enabled_state: Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified.
        :param pulumi.Input[Union[str, 'PolicyMode']] mode: Describes if it is in detection mode or prevention mode at policy level.
        :param pulumi.Input[str] redirect_url: If action type is redirect, this field represents redirect URL for the client.
        :param pulumi.Input[Union[str, 'PolicyRequestBodyCheck']] request_body_check: Describes if policy managed rules will inspect the request body content.
        """
        FrontDoorPolicySettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_block_response_body=custom_block_response_body,
            custom_block_response_status_code=custom_block_response_status_code,
            enabled_state=enabled_state,
            mode=mode,
            redirect_url=redirect_url,
            request_body_check=request_body_check,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_block_response_body: Optional[pulumi.Input[str]] = None,
             custom_block_response_status_code: Optional[pulumi.Input[int]] = None,
             enabled_state: Optional[pulumi.Input[Union[str, 'PolicyEnabledState']]] = None,
             mode: Optional[pulumi.Input[Union[str, 'PolicyMode']]] = None,
             redirect_url: Optional[pulumi.Input[str]] = None,
             request_body_check: Optional[pulumi.Input[Union[str, 'PolicyRequestBodyCheck']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom_block_response_body is None and 'customBlockResponseBody' in kwargs:
            custom_block_response_body = kwargs['customBlockResponseBody']
        if custom_block_response_status_code is None and 'customBlockResponseStatusCode' in kwargs:
            custom_block_response_status_code = kwargs['customBlockResponseStatusCode']
        if enabled_state is None and 'enabledState' in kwargs:
            enabled_state = kwargs['enabledState']
        if redirect_url is None and 'redirectUrl' in kwargs:
            redirect_url = kwargs['redirectUrl']
        if request_body_check is None and 'requestBodyCheck' in kwargs:
            request_body_check = kwargs['requestBodyCheck']

        if custom_block_response_body is not None:
            _setter("custom_block_response_body", custom_block_response_body)
        if custom_block_response_status_code is not None:
            _setter("custom_block_response_status_code", custom_block_response_status_code)
        if enabled_state is not None:
            _setter("enabled_state", enabled_state)
        if mode is not None:
            _setter("mode", mode)
        if redirect_url is not None:
            _setter("redirect_url", redirect_url)
        if request_body_check is not None:
            _setter("request_body_check", request_body_check)

    @property
    @pulumi.getter(name="customBlockResponseBody")
    def custom_block_response_body(self) -> Optional[pulumi.Input[str]]:
        """
        If the action type is block, customer can override the response body. The body must be specified in base64 encoding.
        """
        return pulumi.get(self, "custom_block_response_body")

    @custom_block_response_body.setter
    def custom_block_response_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_block_response_body", value)

    @property
    @pulumi.getter(name="customBlockResponseStatusCode")
    def custom_block_response_status_code(self) -> Optional[pulumi.Input[int]]:
        """
        If the action type is block, customer can override the response status code.
        """
        return pulumi.get(self, "custom_block_response_status_code")

    @custom_block_response_status_code.setter
    def custom_block_response_status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_block_response_status_code", value)

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[pulumi.Input[Union[str, 'PolicyEnabledState']]]:
        """
        Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified.
        """
        return pulumi.get(self, "enabled_state")

    @enabled_state.setter
    def enabled_state(self, value: Optional[pulumi.Input[Union[str, 'PolicyEnabledState']]]):
        pulumi.set(self, "enabled_state", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[str, 'PolicyMode']]]:
        """
        Describes if it is in detection mode or prevention mode at policy level.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[str, 'PolicyMode']]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[str]]:
        """
        If action type is redirect, this field represents redirect URL for the client.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_url", value)

    @property
    @pulumi.getter(name="requestBodyCheck")
    def request_body_check(self) -> Optional[pulumi.Input[Union[str, 'PolicyRequestBodyCheck']]]:
        """
        Describes if policy managed rules will inspect the request body content.
        """
        return pulumi.get(self, "request_body_check")

    @request_body_check.setter
    def request_body_check(self, value: Optional[pulumi.Input[Union[str, 'PolicyRequestBodyCheck']]]):
        pulumi.set(self, "request_body_check", value)


@pulumi.input_type
class ManagedRuleExclusionArgs:
    def __init__(__self__, *,
                 match_variable: pulumi.Input[Union[str, 'ManagedRuleExclusionMatchVariable']],
                 selector: pulumi.Input[str],
                 selector_match_operator: pulumi.Input[Union[str, 'ManagedRuleExclusionSelectorMatchOperator']]):
        """
        Exclude variables from managed rule evaluation.
        :param pulumi.Input[Union[str, 'ManagedRuleExclusionMatchVariable']] match_variable: The variable type to be excluded.
        :param pulumi.Input[str] selector: Selector value for which elements in the collection this exclusion applies to.
        :param pulumi.Input[Union[str, 'ManagedRuleExclusionSelectorMatchOperator']] selector_match_operator: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to.
        """
        ManagedRuleExclusionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_variable=match_variable,
            selector=selector,
            selector_match_operator=selector_match_operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_variable: Optional[pulumi.Input[Union[str, 'ManagedRuleExclusionMatchVariable']]] = None,
             selector: Optional[pulumi.Input[str]] = None,
             selector_match_operator: Optional[pulumi.Input[Union[str, 'ManagedRuleExclusionSelectorMatchOperator']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_variable is None and 'matchVariable' in kwargs:
            match_variable = kwargs['matchVariable']
        if match_variable is None:
            raise TypeError("Missing 'match_variable' argument")
        if selector is None:
            raise TypeError("Missing 'selector' argument")
        if selector_match_operator is None and 'selectorMatchOperator' in kwargs:
            selector_match_operator = kwargs['selectorMatchOperator']
        if selector_match_operator is None:
            raise TypeError("Missing 'selector_match_operator' argument")

        _setter("match_variable", match_variable)
        _setter("selector", selector)
        _setter("selector_match_operator", selector_match_operator)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> pulumi.Input[Union[str, 'ManagedRuleExclusionMatchVariable']]:
        """
        The variable type to be excluded.
        """
        return pulumi.get(self, "match_variable")

    @match_variable.setter
    def match_variable(self, value: pulumi.Input[Union[str, 'ManagedRuleExclusionMatchVariable']]):
        pulumi.set(self, "match_variable", value)

    @property
    @pulumi.getter
    def selector(self) -> pulumi.Input[str]:
        """
        Selector value for which elements in the collection this exclusion applies to.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter(name="selectorMatchOperator")
    def selector_match_operator(self) -> pulumi.Input[Union[str, 'ManagedRuleExclusionSelectorMatchOperator']]:
        """
        Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to.
        """
        return pulumi.get(self, "selector_match_operator")

    @selector_match_operator.setter
    def selector_match_operator(self, value: pulumi.Input[Union[str, 'ManagedRuleExclusionSelectorMatchOperator']]):
        pulumi.set(self, "selector_match_operator", value)


@pulumi.input_type
class ManagedRuleSetListArgs:
    def __init__(__self__, *,
                 managed_rule_sets: Optional[pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleSetArgs']]]] = None):
        """
        Defines the list of managed rule sets for the policy.
        :param pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleSetArgs']]] managed_rule_sets: List of rule sets.
        """
        ManagedRuleSetListArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            managed_rule_sets=managed_rule_sets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             managed_rule_sets: Optional[pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleSetArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if managed_rule_sets is None and 'managedRuleSets' in kwargs:
            managed_rule_sets = kwargs['managedRuleSets']

        if managed_rule_sets is not None:
            _setter("managed_rule_sets", managed_rule_sets)

    @property
    @pulumi.getter(name="managedRuleSets")
    def managed_rule_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleSetArgs']]]]:
        """
        List of rule sets.
        """
        return pulumi.get(self, "managed_rule_sets")

    @managed_rule_sets.setter
    def managed_rule_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FrontDoorManagedRuleSetArgs']]]]):
        pulumi.set(self, "managed_rule_sets", value)


@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[Union[str, 'SkuName']]] = None):
        """
        The pricing tier of the web application firewall policy.
        :param pulumi.Input[Union[str, 'SkuName']] name: Name of the pricing tier.
        """
        SkuArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[Union[str, 'SkuName']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[Union[str, 'SkuName']]]:
        """
        Name of the pricing tier.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[Union[str, 'SkuName']]]):
        pulumi.set(self, "name", value)


