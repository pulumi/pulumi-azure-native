# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ApplicationRuleConditionResponse',
    'AzureFirewallApplicationRuleCollectionResponse',
    'AzureFirewallApplicationRuleProtocolResponse',
    'AzureFirewallApplicationRuleResponse',
    'AzureFirewallIPConfigurationResponse',
    'AzureFirewallIpGroupsResponse',
    'AzureFirewallNatRCActionResponse',
    'AzureFirewallNatRuleCollectionResponse',
    'AzureFirewallNatRuleResponse',
    'AzureFirewallNetworkRuleCollectionResponse',
    'AzureFirewallNetworkRuleResponse',
    'AzureFirewallPublicIPAddressResponse',
    'AzureFirewallRCActionResponse',
    'AzureFirewallSkuResponse',
    'FirewallPolicyFilterRuleActionResponse',
    'FirewallPolicyFilterRuleResponse',
    'FirewallPolicyNatRuleActionResponse',
    'FirewallPolicyNatRuleResponse',
    'FirewallPolicyRuleConditionApplicationProtocolResponse',
    'FirewallPolicyThreatIntelWhitelistResponse',
    'HubIPAddressesResponse',
    'HubVirtualNetworkConnectionResponse',
    'ManagedServiceIdentityResponse',
    'ManagedServiceIdentityResponseUserAssignedIdentities',
    'NatRuleConditionResponse',
    'NetworkRuleConditionResponse',
    'PropagatedRouteTableResponse',
    'RoutingConfigurationResponse',
    'StaticRouteResponse',
    'SubResourceResponse',
    'VirtualApplianceNicPropertiesResponse',
    'VirtualApplianceSkuPropertiesResponse',
    'VirtualHubRouteResponse',
    'VirtualHubRouteTableResponse',
    'VirtualHubRouteTableV2Response',
    'VirtualHubRouteV2Response',
    'VnetRouteResponse',
]

@pulumi.output_type
class ApplicationRuleConditionResponse(dict):
    """
    Rule condition of type application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleConditionType":
            suggest = "rule_condition_type"
        elif key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "fqdnTags":
            suggest = "fqdn_tags"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"
        elif key == "targetFqdns":
            suggest = "target_fqdns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationRuleConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationRuleConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationRuleConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_condition_type: str,
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 fqdn_tags: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 protocols: Optional[Sequence['outputs.FirewallPolicyRuleConditionApplicationProtocolResponse']] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None,
                 target_fqdns: Optional[Sequence[str]] = None):
        """
        Rule condition of type application.
        :param str rule_condition_type: Rule Condition Type.
               Expected value is 'ApplicationRuleCondition'.
        :param str description: Description of the rule condition.
        :param Sequence[str] destination_addresses: List of destination IP addresses or Service Tags.
        :param Sequence[str] fqdn_tags: List of FQDN Tags for this rule condition.
        :param str name: Name of the rule condition.
        :param Sequence['FirewallPolicyRuleConditionApplicationProtocolResponse'] protocols: Array of Application Protocols.
        :param Sequence[str] source_addresses: List of source IP addresses for this rule.
        :param Sequence[str] source_ip_groups: List of source IpGroups for this rule.
        :param Sequence[str] target_fqdns: List of FQDNs for this rule condition.
        """
        pulumi.set(__self__, "rule_condition_type", 'ApplicationRuleCondition')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if fqdn_tags is not None:
            pulumi.set(__self__, "fqdn_tags", fqdn_tags)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if target_fqdns is not None:
            pulumi.set(__self__, "target_fqdns", target_fqdns)

    @property
    @pulumi.getter(name="ruleConditionType")
    def rule_condition_type(self) -> str:
        """
        Rule Condition Type.
        Expected value is 'ApplicationRuleCondition'.
        """
        return pulumi.get(self, "rule_condition_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the rule condition.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        List of destination IP addresses or Service Tags.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="fqdnTags")
    def fqdn_tags(self) -> Optional[Sequence[str]]:
        """
        List of FQDN Tags for this rule condition.
        """
        return pulumi.get(self, "fqdn_tags")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the rule condition.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence['outputs.FirewallPolicyRuleConditionApplicationProtocolResponse']]:
        """
        Array of Application Protocols.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        List of source IP addresses for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")

    @property
    @pulumi.getter(name="targetFqdns")
    def target_fqdns(self) -> Optional[Sequence[str]]:
        """
        List of FQDNs for this rule condition.
        """
        return pulumi.get(self, "target_fqdns")


@pulumi.output_type
class AzureFirewallApplicationRuleCollectionResponse(dict):
    """
    Application rule collection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFirewallApplicationRuleCollectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFirewallApplicationRuleCollectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFirewallApplicationRuleCollectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: str,
                 provisioning_state: str,
                 action: Optional['outputs.AzureFirewallRCActionResponse'] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 rules: Optional[Sequence['outputs.AzureFirewallApplicationRuleResponse']] = None):
        """
        Application rule collection resource.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str provisioning_state: The provisioning state of the application rule collection resource.
        :param 'AzureFirewallRCActionResponse' action: The action type of a rule collection.
        :param str id: Resource ID.
        :param str name: The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
        :param int priority: Priority of the application rule collection resource.
        :param Sequence['AzureFirewallApplicationRuleResponse'] rules: Collection of rules used by a application rule collection.
        """
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the application rule collection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.AzureFirewallRCActionResponse']:
        """
        The action type of a rule collection.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority of the application rule collection resource.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AzureFirewallApplicationRuleResponse']]:
        """
        Collection of rules used by a application rule collection.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class AzureFirewallApplicationRuleProtocolResponse(dict):
    """
    Properties of the application rule protocol.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "protocolType":
            suggest = "protocol_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFirewallApplicationRuleProtocolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFirewallApplicationRuleProtocolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFirewallApplicationRuleProtocolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: Optional[int] = None,
                 protocol_type: Optional[str] = None):
        """
        Properties of the application rule protocol.
        :param int port: Port number for the protocol, cannot be greater than 64000. This field is optional.
        :param str protocol_type: Protocol type.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol_type is not None:
            pulumi.set(__self__, "protocol_type", protocol_type)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port number for the protocol, cannot be greater than 64000. This field is optional.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> Optional[str]:
        """
        Protocol type.
        """
        return pulumi.get(self, "protocol_type")


@pulumi.output_type
class AzureFirewallApplicationRuleResponse(dict):
    """
    Properties of an application rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fqdnTags":
            suggest = "fqdn_tags"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"
        elif key == "targetFqdns":
            suggest = "target_fqdns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFirewallApplicationRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFirewallApplicationRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFirewallApplicationRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 fqdn_tags: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 protocols: Optional[Sequence['outputs.AzureFirewallApplicationRuleProtocolResponse']] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None,
                 target_fqdns: Optional[Sequence[str]] = None):
        """
        Properties of an application rule.
        :param str description: Description of the rule.
        :param Sequence[str] fqdn_tags: List of FQDN Tags for this rule.
        :param str name: Name of the application rule.
        :param Sequence['AzureFirewallApplicationRuleProtocolResponse'] protocols: Array of ApplicationRuleProtocols.
        :param Sequence[str] source_addresses: List of source IP addresses for this rule.
        :param Sequence[str] source_ip_groups: List of source IpGroups for this rule.
        :param Sequence[str] target_fqdns: List of FQDNs for this rule.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if fqdn_tags is not None:
            pulumi.set(__self__, "fqdn_tags", fqdn_tags)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if target_fqdns is not None:
            pulumi.set(__self__, "target_fqdns", target_fqdns)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fqdnTags")
    def fqdn_tags(self) -> Optional[Sequence[str]]:
        """
        List of FQDN Tags for this rule.
        """
        return pulumi.get(self, "fqdn_tags")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the application rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence['outputs.AzureFirewallApplicationRuleProtocolResponse']]:
        """
        Array of ApplicationRuleProtocols.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        List of source IP addresses for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")

    @property
    @pulumi.getter(name="targetFqdns")
    def target_fqdns(self) -> Optional[Sequence[str]]:
        """
        List of FQDNs for this rule.
        """
        return pulumi.get(self, "target_fqdns")


@pulumi.output_type
class AzureFirewallIPConfigurationResponse(dict):
    """
    IP configuration of an Azure Firewall.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIPAddress":
            suggest = "private_ip_address"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "publicIPAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFirewallIPConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFirewallIPConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFirewallIPConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: str,
                 private_ip_address: str,
                 provisioning_state: str,
                 type: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 public_ip_address: Optional['outputs.SubResourceResponse'] = None,
                 subnet: Optional['outputs.SubResourceResponse'] = None):
        """
        IP configuration of an Azure Firewall.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str private_ip_address: The Firewall Internal Load Balancer IP to be used as the next hop in User Defined Routes.
        :param str provisioning_state: The provisioning state of the Azure firewall IP configuration resource.
        :param str type: Type of the resource.
        :param str id: Resource ID.
        :param str name: Name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param 'SubResourceResponse' public_ip_address: Reference to the PublicIP resource. This field is a mandatory input if subnet is not null.
        :param 'SubResourceResponse' subnet: Reference to the subnet resource. This resource must be named 'AzureFirewallSubnet' or 'AzureFirewallManagementSubnet'.
        """
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> str:
        """
        The Firewall Internal Load Balancer IP to be used as the next hop in User Defined Routes.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the Azure firewall IP configuration resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the resource.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIPAddress")
    def public_ip_address(self) -> Optional['outputs.SubResourceResponse']:
        """
        Reference to the PublicIP resource. This field is a mandatory input if subnet is not null.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.SubResourceResponse']:
        """
        Reference to the subnet resource. This resource must be named 'AzureFirewallSubnet' or 'AzureFirewallManagementSubnet'.
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class AzureFirewallIpGroupsResponse(dict):
    """
    IpGroups associated with azure firewall.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changeNumber":
            suggest = "change_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFirewallIpGroupsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFirewallIpGroupsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFirewallIpGroupsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 change_number: str,
                 id: str):
        """
        IpGroups associated with azure firewall.
        :param str change_number: The iteration number.
        :param str id: Resource ID.
        """
        pulumi.set(__self__, "change_number", change_number)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="changeNumber")
    def change_number(self) -> str:
        """
        The iteration number.
        """
        return pulumi.get(self, "change_number")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class AzureFirewallNatRCActionResponse(dict):
    """
    AzureFirewall NAT Rule Collection Action.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        AzureFirewall NAT Rule Collection Action.
        :param str type: The type of action.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of action.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AzureFirewallNatRuleCollectionResponse(dict):
    """
    NAT rule collection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFirewallNatRuleCollectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFirewallNatRuleCollectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFirewallNatRuleCollectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: str,
                 provisioning_state: str,
                 action: Optional['outputs.AzureFirewallNatRCActionResponse'] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 rules: Optional[Sequence['outputs.AzureFirewallNatRuleResponse']] = None):
        """
        NAT rule collection resource.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str provisioning_state: The provisioning state of the NAT rule collection resource.
        :param 'AzureFirewallNatRCActionResponse' action: The action type of a NAT rule collection.
        :param str id: Resource ID.
        :param str name: The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
        :param int priority: Priority of the NAT rule collection resource.
        :param Sequence['AzureFirewallNatRuleResponse'] rules: Collection of rules used by a NAT rule collection.
        """
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the NAT rule collection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.AzureFirewallNatRCActionResponse']:
        """
        The action type of a NAT rule collection.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority of the NAT rule collection resource.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AzureFirewallNatRuleResponse']]:
        """
        Collection of rules used by a NAT rule collection.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class AzureFirewallNatRuleResponse(dict):
    """
    Properties of a NAT rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"
        elif key == "translatedAddress":
            suggest = "translated_address"
        elif key == "translatedFqdn":
            suggest = "translated_fqdn"
        elif key == "translatedPort":
            suggest = "translated_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFirewallNatRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFirewallNatRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFirewallNatRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_ports: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 protocols: Optional[Sequence[str]] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None,
                 translated_address: Optional[str] = None,
                 translated_fqdn: Optional[str] = None,
                 translated_port: Optional[str] = None):
        """
        Properties of a NAT rule.
        :param str description: Description of the rule.
        :param Sequence[str] destination_addresses: List of destination IP addresses for this rule. Supports IP ranges, prefixes, and service tags.
        :param Sequence[str] destination_ports: List of destination ports.
        :param str name: Name of the NAT rule.
        :param Sequence[str] protocols: Array of AzureFirewallNetworkRuleProtocols applicable to this NAT rule.
        :param Sequence[str] source_addresses: List of source IP addresses for this rule.
        :param Sequence[str] source_ip_groups: List of source IpGroups for this rule.
        :param str translated_address: The translated address for this NAT rule.
        :param str translated_fqdn: The translated FQDN for this NAT rule.
        :param str translated_port: The translated port for this NAT rule.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if translated_address is not None:
            pulumi.set(__self__, "translated_address", translated_address)
        if translated_fqdn is not None:
            pulumi.set(__self__, "translated_fqdn", translated_fqdn)
        if translated_port is not None:
            pulumi.set(__self__, "translated_port", translated_port)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        List of destination IP addresses for this rule. Supports IP ranges, prefixes, and service tags.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[str]]:
        """
        List of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the NAT rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[str]]:
        """
        Array of AzureFirewallNetworkRuleProtocols applicable to this NAT rule.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        List of source IP addresses for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")

    @property
    @pulumi.getter(name="translatedAddress")
    def translated_address(self) -> Optional[str]:
        """
        The translated address for this NAT rule.
        """
        return pulumi.get(self, "translated_address")

    @property
    @pulumi.getter(name="translatedFqdn")
    def translated_fqdn(self) -> Optional[str]:
        """
        The translated FQDN for this NAT rule.
        """
        return pulumi.get(self, "translated_fqdn")

    @property
    @pulumi.getter(name="translatedPort")
    def translated_port(self) -> Optional[str]:
        """
        The translated port for this NAT rule.
        """
        return pulumi.get(self, "translated_port")


@pulumi.output_type
class AzureFirewallNetworkRuleCollectionResponse(dict):
    """
    Network rule collection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFirewallNetworkRuleCollectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFirewallNetworkRuleCollectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFirewallNetworkRuleCollectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: str,
                 provisioning_state: str,
                 action: Optional['outputs.AzureFirewallRCActionResponse'] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 rules: Optional[Sequence['outputs.AzureFirewallNetworkRuleResponse']] = None):
        """
        Network rule collection resource.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str provisioning_state: The provisioning state of the network rule collection resource.
        :param 'AzureFirewallRCActionResponse' action: The action type of a rule collection.
        :param str id: Resource ID.
        :param str name: The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
        :param int priority: Priority of the network rule collection resource.
        :param Sequence['AzureFirewallNetworkRuleResponse'] rules: Collection of rules used by a network rule collection.
        """
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the network rule collection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.AzureFirewallRCActionResponse']:
        """
        The action type of a rule collection.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within the Azure firewall. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority of the network rule collection resource.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AzureFirewallNetworkRuleResponse']]:
        """
        Collection of rules used by a network rule collection.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class AzureFirewallNetworkRuleResponse(dict):
    """
    Properties of the network rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationFqdns":
            suggest = "destination_fqdns"
        elif key == "destinationIpGroups":
            suggest = "destination_ip_groups"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFirewallNetworkRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFirewallNetworkRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFirewallNetworkRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_fqdns: Optional[Sequence[str]] = None,
                 destination_ip_groups: Optional[Sequence[str]] = None,
                 destination_ports: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 protocols: Optional[Sequence[str]] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        Properties of the network rule.
        :param str description: Description of the rule.
        :param Sequence[str] destination_addresses: List of destination IP addresses.
        :param Sequence[str] destination_fqdns: List of destination FQDNs.
        :param Sequence[str] destination_ip_groups: List of destination IpGroups for this rule.
        :param Sequence[str] destination_ports: List of destination ports.
        :param str name: Name of the network rule.
        :param Sequence[str] protocols: Array of AzureFirewallNetworkRuleProtocols.
        :param Sequence[str] source_addresses: List of source IP addresses for this rule.
        :param Sequence[str] source_ip_groups: List of source IpGroups for this rule.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_fqdns is not None:
            pulumi.set(__self__, "destination_fqdns", destination_fqdns)
        if destination_ip_groups is not None:
            pulumi.set(__self__, "destination_ip_groups", destination_ip_groups)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        List of destination IP addresses.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationFqdns")
    def destination_fqdns(self) -> Optional[Sequence[str]]:
        """
        List of destination FQDNs.
        """
        return pulumi.get(self, "destination_fqdns")

    @property
    @pulumi.getter(name="destinationIpGroups")
    def destination_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of destination IpGroups for this rule.
        """
        return pulumi.get(self, "destination_ip_groups")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[str]]:
        """
        List of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the network rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[str]]:
        """
        Array of AzureFirewallNetworkRuleProtocols.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        List of source IP addresses for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class AzureFirewallPublicIPAddressResponse(dict):
    """
    Public IP Address associated with azure firewall.
    """
    def __init__(__self__, *,
                 address: Optional[str] = None):
        """
        Public IP Address associated with azure firewall.
        :param str address: Public IP Address value.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Public IP Address value.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class AzureFirewallRCActionResponse(dict):
    """
    Properties of the AzureFirewallRCAction.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        Properties of the AzureFirewallRCAction.
        :param str type: The type of action.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of action.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AzureFirewallSkuResponse(dict):
    """
    SKU of an Azure Firewall.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 tier: Optional[str] = None):
        """
        SKU of an Azure Firewall.
        :param str name: Name of an Azure Firewall SKU.
        :param str tier: Tier of an Azure Firewall.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of an Azure Firewall SKU.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        Tier of an Azure Firewall.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class FirewallPolicyFilterRuleActionResponse(dict):
    """
    Properties of the FirewallPolicyFilterRuleAction.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        Properties of the FirewallPolicyFilterRuleAction.
        :param str type: The type of action.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of action.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FirewallPolicyFilterRuleResponse(dict):
    """
    Firewall Policy Filter Rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "ruleConditions":
            suggest = "rule_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyFilterRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyFilterRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyFilterRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_type: str,
                 action: Optional['outputs.FirewallPolicyFilterRuleActionResponse'] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 rule_conditions: Optional[Sequence[Any]] = None):
        """
        Firewall Policy Filter Rule.
        :param str rule_type: The type of the rule.
               Expected value is 'FirewallPolicyFilterRule'.
        :param 'FirewallPolicyFilterRuleActionResponse' action: The action type of a Filter rule.
        :param str name: The name of the rule.
        :param int priority: Priority of the Firewall Policy Rule resource.
        :param Sequence[Union['ApplicationRuleConditionResponse', 'NatRuleConditionResponse', 'NetworkRuleConditionResponse']] rule_conditions: Collection of rule conditions used by a rule.
        """
        pulumi.set(__self__, "rule_type", 'FirewallPolicyFilterRule')
        if action is not None:
            pulumi.set(__self__, "action", action)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rule_conditions is not None:
            pulumi.set(__self__, "rule_conditions", rule_conditions)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of the rule.
        Expected value is 'FirewallPolicyFilterRule'.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.FirewallPolicyFilterRuleActionResponse']:
        """
        The action type of a Filter rule.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority of the Firewall Policy Rule resource.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="ruleConditions")
    def rule_conditions(self) -> Optional[Sequence[Any]]:
        """
        Collection of rule conditions used by a rule.
        """
        return pulumi.get(self, "rule_conditions")


@pulumi.output_type
class FirewallPolicyNatRuleActionResponse(dict):
    """
    Properties of the FirewallPolicyNatRuleAction.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        Properties of the FirewallPolicyNatRuleAction.
        :param str type: The type of action.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of action.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FirewallPolicyNatRuleResponse(dict):
    """
    Firewall Policy NAT Rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "ruleCondition":
            suggest = "rule_condition"
        elif key == "translatedAddress":
            suggest = "translated_address"
        elif key == "translatedPort":
            suggest = "translated_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyNatRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyNatRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyNatRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_type: str,
                 action: Optional['outputs.FirewallPolicyNatRuleActionResponse'] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 rule_condition: Optional[Any] = None,
                 translated_address: Optional[str] = None,
                 translated_port: Optional[str] = None):
        """
        Firewall Policy NAT Rule.
        :param str rule_type: The type of the rule.
               Expected value is 'FirewallPolicyNatRule'.
        :param 'FirewallPolicyNatRuleActionResponse' action: The action type of a Nat rule.
        :param str name: The name of the rule.
        :param int priority: Priority of the Firewall Policy Rule resource.
        :param Union['ApplicationRuleConditionResponse', 'NatRuleConditionResponse', 'NetworkRuleConditionResponse'] rule_condition: The match conditions for incoming traffic.
        :param str translated_address: The translated address for this NAT rule.
        :param str translated_port: The translated port for this NAT rule.
        """
        pulumi.set(__self__, "rule_type", 'FirewallPolicyNatRule')
        if action is not None:
            pulumi.set(__self__, "action", action)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rule_condition is not None:
            pulumi.set(__self__, "rule_condition", rule_condition)
        if translated_address is not None:
            pulumi.set(__self__, "translated_address", translated_address)
        if translated_port is not None:
            pulumi.set(__self__, "translated_port", translated_port)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        The type of the rule.
        Expected value is 'FirewallPolicyNatRule'.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.FirewallPolicyNatRuleActionResponse']:
        """
        The action type of a Nat rule.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority of the Firewall Policy Rule resource.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="ruleCondition")
    def rule_condition(self) -> Optional[Any]:
        """
        The match conditions for incoming traffic.
        """
        return pulumi.get(self, "rule_condition")

    @property
    @pulumi.getter(name="translatedAddress")
    def translated_address(self) -> Optional[str]:
        """
        The translated address for this NAT rule.
        """
        return pulumi.get(self, "translated_address")

    @property
    @pulumi.getter(name="translatedPort")
    def translated_port(self) -> Optional[str]:
        """
        The translated port for this NAT rule.
        """
        return pulumi.get(self, "translated_port")


@pulumi.output_type
class FirewallPolicyRuleConditionApplicationProtocolResponse(dict):
    """
    Properties of the application rule protocol.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "protocolType":
            suggest = "protocol_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyRuleConditionApplicationProtocolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyRuleConditionApplicationProtocolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyRuleConditionApplicationProtocolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: Optional[int] = None,
                 protocol_type: Optional[str] = None):
        """
        Properties of the application rule protocol.
        :param int port: Port number for the protocol, cannot be greater than 64000.
        :param str protocol_type: Protocol type.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol_type is not None:
            pulumi.set(__self__, "protocol_type", protocol_type)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port number for the protocol, cannot be greater than 64000.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> Optional[str]:
        """
        Protocol type.
        """
        return pulumi.get(self, "protocol_type")


@pulumi.output_type
class FirewallPolicyThreatIntelWhitelistResponse(dict):
    """
    ThreatIntel Whitelist for Firewall Policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyThreatIntelWhitelistResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyThreatIntelWhitelistResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyThreatIntelWhitelistResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdns: Optional[Sequence[str]] = None,
                 ip_addresses: Optional[Sequence[str]] = None):
        """
        ThreatIntel Whitelist for Firewall Policy.
        :param Sequence[str] fqdns: List of FQDNs for the ThreatIntel Whitelist.
        :param Sequence[str] ip_addresses: List of IP addresses for the ThreatIntel Whitelist.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[Sequence[str]]:
        """
        List of FQDNs for the ThreatIntel Whitelist.
        """
        return pulumi.get(self, "fqdns")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        List of IP addresses for the ThreatIntel Whitelist.
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class HubIPAddressesResponse(dict):
    """
    IP addresses associated with azure firewall.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIPAddress":
            suggest = "private_ip_address"
        elif key == "publicIPAddresses":
            suggest = "public_ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HubIPAddressesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HubIPAddressesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HubIPAddressesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_ip_address: Optional[str] = None,
                 public_ip_addresses: Optional[Sequence['outputs.AzureFirewallPublicIPAddressResponse']] = None):
        """
        IP addresses associated with azure firewall.
        :param str private_ip_address: Private IP Address associated with azure firewall.
        :param Sequence['AzureFirewallPublicIPAddressResponse'] public_ip_addresses: List of Public IP addresses associated with azure firewall.
        """
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if public_ip_addresses is not None:
            pulumi.set(__self__, "public_ip_addresses", public_ip_addresses)

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        Private IP Address associated with azure firewall.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIPAddresses")
    def public_ip_addresses(self) -> Optional[Sequence['outputs.AzureFirewallPublicIPAddressResponse']]:
        """
        List of Public IP addresses associated with azure firewall.
        """
        return pulumi.get(self, "public_ip_addresses")


@pulumi.output_type
class HubVirtualNetworkConnectionResponse(dict):
    """
    HubVirtualNetworkConnection Resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "allowHubToRemoteVnetTransit":
            suggest = "allow_hub_to_remote_vnet_transit"
        elif key == "allowRemoteVnetToUseHubVnetGateways":
            suggest = "allow_remote_vnet_to_use_hub_vnet_gateways"
        elif key == "enableInternetSecurity":
            suggest = "enable_internet_security"
        elif key == "remoteVirtualNetwork":
            suggest = "remote_virtual_network"
        elif key == "routingConfiguration":
            suggest = "routing_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HubVirtualNetworkConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HubVirtualNetworkConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HubVirtualNetworkConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: str,
                 provisioning_state: str,
                 allow_hub_to_remote_vnet_transit: Optional[bool] = None,
                 allow_remote_vnet_to_use_hub_vnet_gateways: Optional[bool] = None,
                 enable_internet_security: Optional[bool] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 remote_virtual_network: Optional['outputs.SubResourceResponse'] = None,
                 routing_configuration: Optional['outputs.RoutingConfigurationResponse'] = None):
        """
        HubVirtualNetworkConnection Resource.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str provisioning_state: The provisioning state of the hub virtual network connection resource.
        :param bool allow_hub_to_remote_vnet_transit: VirtualHub to RemoteVnet transit to enabled or not.
        :param bool allow_remote_vnet_to_use_hub_vnet_gateways: Allow RemoteVnet to use Virtual Hub's gateways.
        :param bool enable_internet_security: Enable internet security.
        :param str id: Resource ID.
        :param str name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param 'SubResourceResponse' remote_virtual_network: Reference to the remote virtual network.
        :param 'RoutingConfigurationResponse' routing_configuration: The Routing Configuration indicating the associated and propagated route tables on this connection.
        """
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if allow_hub_to_remote_vnet_transit is not None:
            pulumi.set(__self__, "allow_hub_to_remote_vnet_transit", allow_hub_to_remote_vnet_transit)
        if allow_remote_vnet_to_use_hub_vnet_gateways is not None:
            pulumi.set(__self__, "allow_remote_vnet_to_use_hub_vnet_gateways", allow_remote_vnet_to_use_hub_vnet_gateways)
        if enable_internet_security is not None:
            pulumi.set(__self__, "enable_internet_security", enable_internet_security)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if remote_virtual_network is not None:
            pulumi.set(__self__, "remote_virtual_network", remote_virtual_network)
        if routing_configuration is not None:
            pulumi.set(__self__, "routing_configuration", routing_configuration)

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the hub virtual network connection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="allowHubToRemoteVnetTransit")
    def allow_hub_to_remote_vnet_transit(self) -> Optional[bool]:
        """
        VirtualHub to RemoteVnet transit to enabled or not.
        """
        return pulumi.get(self, "allow_hub_to_remote_vnet_transit")

    @property
    @pulumi.getter(name="allowRemoteVnetToUseHubVnetGateways")
    def allow_remote_vnet_to_use_hub_vnet_gateways(self) -> Optional[bool]:
        """
        Allow RemoteVnet to use Virtual Hub's gateways.
        """
        return pulumi.get(self, "allow_remote_vnet_to_use_hub_vnet_gateways")

    @property
    @pulumi.getter(name="enableInternetSecurity")
    def enable_internet_security(self) -> Optional[bool]:
        """
        Enable internet security.
        """
        return pulumi.get(self, "enable_internet_security")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="remoteVirtualNetwork")
    def remote_virtual_network(self) -> Optional['outputs.SubResourceResponse']:
        """
        Reference to the remote virtual network.
        """
        return pulumi.get(self, "remote_virtual_network")

    @property
    @pulumi.getter(name="routingConfiguration")
    def routing_configuration(self) -> Optional['outputs.RoutingConfigurationResponse']:
        """
        The Routing Configuration indicating the associated and propagated route tables on this connection.
        """
        return pulumi.get(self, "routing_configuration")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Identity for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.ManagedServiceIdentityResponseUserAssignedIdentities']] = None):
        """
        Identity for the resource.
        :param str principal_id: The principal id of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant id of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str type: The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine.
        :param Mapping[str, 'ManagedServiceIdentityResponseUserAssignedIdentities'] user_assigned_identities: The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal id of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant id of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.ManagedServiceIdentityResponseUserAssignedIdentities']]:
        """
        The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ManagedServiceIdentityResponseUserAssignedIdentities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponseUserAssignedIdentities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        :param str client_id: The client id of user assigned identity.
        :param str principal_id: The principal id of user assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client id of user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal id of user assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class NatRuleConditionResponse(dict):
    """
    Rule condition of type nat.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleConditionType":
            suggest = "rule_condition_type"
        elif key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "ipProtocols":
            suggest = "ip_protocols"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NatRuleConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NatRuleConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NatRuleConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_condition_type: str,
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_ports: Optional[Sequence[str]] = None,
                 ip_protocols: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        Rule condition of type nat.
        :param str rule_condition_type: Rule Condition Type.
               Expected value is 'NatRuleCondition'.
        :param str description: Description of the rule condition.
        :param Sequence[str] destination_addresses: List of destination IP addresses or Service Tags.
        :param Sequence[str] destination_ports: List of destination ports.
        :param Sequence[str] ip_protocols: Array of FirewallPolicyRuleConditionNetworkProtocols.
        :param str name: Name of the rule condition.
        :param Sequence[str] source_addresses: List of source IP addresses for this rule.
        :param Sequence[str] source_ip_groups: List of source IpGroups for this rule.
        """
        pulumi.set(__self__, "rule_condition_type", 'NatRuleCondition')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if ip_protocols is not None:
            pulumi.set(__self__, "ip_protocols", ip_protocols)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter(name="ruleConditionType")
    def rule_condition_type(self) -> str:
        """
        Rule Condition Type.
        Expected value is 'NatRuleCondition'.
        """
        return pulumi.get(self, "rule_condition_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the rule condition.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        List of destination IP addresses or Service Tags.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[str]]:
        """
        List of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter(name="ipProtocols")
    def ip_protocols(self) -> Optional[Sequence[str]]:
        """
        Array of FirewallPolicyRuleConditionNetworkProtocols.
        """
        return pulumi.get(self, "ip_protocols")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the rule condition.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        List of source IP addresses for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class NetworkRuleConditionResponse(dict):
    """
    Rule condition of type network.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleConditionType":
            suggest = "rule_condition_type"
        elif key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationIpGroups":
            suggest = "destination_ip_groups"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "ipProtocols":
            suggest = "ip_protocols"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkRuleConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkRuleConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkRuleConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_condition_type: str,
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_ip_groups: Optional[Sequence[str]] = None,
                 destination_ports: Optional[Sequence[str]] = None,
                 ip_protocols: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        Rule condition of type network.
        :param str rule_condition_type: Rule Condition Type.
               Expected value is 'NetworkRuleCondition'.
        :param str description: Description of the rule condition.
        :param Sequence[str] destination_addresses: List of destination IP addresses or Service Tags.
        :param Sequence[str] destination_ip_groups: List of destination IpGroups for this rule.
        :param Sequence[str] destination_ports: List of destination ports.
        :param Sequence[str] ip_protocols: Array of FirewallPolicyRuleConditionNetworkProtocols.
        :param str name: Name of the rule condition.
        :param Sequence[str] source_addresses: List of source IP addresses for this rule.
        :param Sequence[str] source_ip_groups: List of source IpGroups for this rule.
        """
        pulumi.set(__self__, "rule_condition_type", 'NetworkRuleCondition')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_ip_groups is not None:
            pulumi.set(__self__, "destination_ip_groups", destination_ip_groups)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if ip_protocols is not None:
            pulumi.set(__self__, "ip_protocols", ip_protocols)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter(name="ruleConditionType")
    def rule_condition_type(self) -> str:
        """
        Rule Condition Type.
        Expected value is 'NetworkRuleCondition'.
        """
        return pulumi.get(self, "rule_condition_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the rule condition.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        List of destination IP addresses or Service Tags.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationIpGroups")
    def destination_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of destination IpGroups for this rule.
        """
        return pulumi.get(self, "destination_ip_groups")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[str]]:
        """
        List of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter(name="ipProtocols")
    def ip_protocols(self) -> Optional[Sequence[str]]:
        """
        Array of FirewallPolicyRuleConditionNetworkProtocols.
        """
        return pulumi.get(self, "ip_protocols")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the rule condition.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        List of source IP addresses for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class PropagatedRouteTableResponse(dict):
    """
    The list of RouteTables to advertise the routes to.
    """
    def __init__(__self__, *,
                 ids: Optional[Sequence['outputs.SubResourceResponse']] = None,
                 labels: Optional[Sequence[str]] = None):
        """
        The list of RouteTables to advertise the routes to.
        :param Sequence['SubResourceResponse'] ids: The list of resource ids of all the RouteTables.
        :param Sequence[str] labels: The list of labels.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence['outputs.SubResourceResponse']]:
        """
        The list of resource ids of all the RouteTables.
        """
        return pulumi.get(self, "ids")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        The list of labels.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class RoutingConfigurationResponse(dict):
    """
    Routing Configuration indicating the associated and propagated route tables for this connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedRouteTable":
            suggest = "associated_route_table"
        elif key == "propagatedRouteTables":
            suggest = "propagated_route_tables"
        elif key == "vnetRoutes":
            suggest = "vnet_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoutingConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoutingConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoutingConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_route_table: Optional['outputs.SubResourceResponse'] = None,
                 propagated_route_tables: Optional['outputs.PropagatedRouteTableResponse'] = None,
                 vnet_routes: Optional['outputs.VnetRouteResponse'] = None):
        """
        Routing Configuration indicating the associated and propagated route tables for this connection.
        :param 'SubResourceResponse' associated_route_table: The resource id RouteTable associated with this RoutingConfiguration.
        :param 'PropagatedRouteTableResponse' propagated_route_tables: The list of RouteTables to advertise the routes to.
        :param 'VnetRouteResponse' vnet_routes: List of routes that control routing from VirtualHub into a virtual network connection.
        """
        if associated_route_table is not None:
            pulumi.set(__self__, "associated_route_table", associated_route_table)
        if propagated_route_tables is not None:
            pulumi.set(__self__, "propagated_route_tables", propagated_route_tables)
        if vnet_routes is not None:
            pulumi.set(__self__, "vnet_routes", vnet_routes)

    @property
    @pulumi.getter(name="associatedRouteTable")
    def associated_route_table(self) -> Optional['outputs.SubResourceResponse']:
        """
        The resource id RouteTable associated with this RoutingConfiguration.
        """
        return pulumi.get(self, "associated_route_table")

    @property
    @pulumi.getter(name="propagatedRouteTables")
    def propagated_route_tables(self) -> Optional['outputs.PropagatedRouteTableResponse']:
        """
        The list of RouteTables to advertise the routes to.
        """
        return pulumi.get(self, "propagated_route_tables")

    @property
    @pulumi.getter(name="vnetRoutes")
    def vnet_routes(self) -> Optional['outputs.VnetRouteResponse']:
        """
        List of routes that control routing from VirtualHub into a virtual network connection.
        """
        return pulumi.get(self, "vnet_routes")


@pulumi.output_type
class StaticRouteResponse(dict):
    """
    List of all Static Routes.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefixes":
            suggest = "address_prefixes"
        elif key == "nextHopIpAddress":
            suggest = "next_hop_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticRouteResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticRouteResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticRouteResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefixes: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 next_hop_ip_address: Optional[str] = None):
        """
        List of all Static Routes.
        :param Sequence[str] address_prefixes: List of all address prefixes.
        :param str name: The name of the StaticRoute that is unique within a VnetRoute.
        :param str next_hop_ip_address: The ip address of the next hop.
        """
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if next_hop_ip_address is not None:
            pulumi.set(__self__, "next_hop_ip_address", next_hop_ip_address)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[Sequence[str]]:
        """
        List of all address prefixes.
        """
        return pulumi.get(self, "address_prefixes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the StaticRoute that is unique within a VnetRoute.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> Optional[str]:
        """
        The ip address of the next hop.
        """
        return pulumi.get(self, "next_hop_ip_address")


@pulumi.output_type
class SubResourceResponse(dict):
    """
    Reference to another subresource.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Reference to another subresource.
        :param str id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class VirtualApplianceNicPropertiesResponse(dict):
    """
    Network Virtual Appliance NIC properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "publicIpAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualApplianceNicPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualApplianceNicPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualApplianceNicPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 private_ip_address: str,
                 public_ip_address: str):
        """
        Network Virtual Appliance NIC properties.
        :param str name: NIC name.
        :param str private_ip_address: Private IP address.
        :param str public_ip_address: Public IP address.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        NIC name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        Private IP address.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        """
        Public IP address.
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class VirtualApplianceSkuPropertiesResponse(dict):
    """
    Network Virtual Appliance Sku Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bundledScaleUnit":
            suggest = "bundled_scale_unit"
        elif key == "marketPlaceVersion":
            suggest = "market_place_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualApplianceSkuPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualApplianceSkuPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualApplianceSkuPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bundled_scale_unit: Optional[str] = None,
                 market_place_version: Optional[str] = None,
                 vendor: Optional[str] = None):
        """
        Network Virtual Appliance Sku Properties.
        :param str bundled_scale_unit: Virtual Appliance Scale Unit.
        :param str market_place_version: Virtual Appliance Version.
        :param str vendor: Virtual Appliance Vendor.
        """
        if bundled_scale_unit is not None:
            pulumi.set(__self__, "bundled_scale_unit", bundled_scale_unit)
        if market_place_version is not None:
            pulumi.set(__self__, "market_place_version", market_place_version)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="bundledScaleUnit")
    def bundled_scale_unit(self) -> Optional[str]:
        """
        Virtual Appliance Scale Unit.
        """
        return pulumi.get(self, "bundled_scale_unit")

    @property
    @pulumi.getter(name="marketPlaceVersion")
    def market_place_version(self) -> Optional[str]:
        """
        Virtual Appliance Version.
        """
        return pulumi.get(self, "market_place_version")

    @property
    @pulumi.getter
    def vendor(self) -> Optional[str]:
        """
        Virtual Appliance Vendor.
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class VirtualHubRouteResponse(dict):
    """
    VirtualHub route.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefixes":
            suggest = "address_prefixes"
        elif key == "nextHopIpAddress":
            suggest = "next_hop_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualHubRouteResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualHubRouteResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualHubRouteResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefixes: Optional[Sequence[str]] = None,
                 next_hop_ip_address: Optional[str] = None):
        """
        VirtualHub route.
        :param Sequence[str] address_prefixes: List of all addressPrefixes.
        :param str next_hop_ip_address: NextHop ip address.
        """
        if address_prefixes is not None:
            pulumi.set(__self__, "address_prefixes", address_prefixes)
        if next_hop_ip_address is not None:
            pulumi.set(__self__, "next_hop_ip_address", next_hop_ip_address)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[Sequence[str]]:
        """
        List of all addressPrefixes.
        """
        return pulumi.get(self, "address_prefixes")

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> Optional[str]:
        """
        NextHop ip address.
        """
        return pulumi.get(self, "next_hop_ip_address")


@pulumi.output_type
class VirtualHubRouteTableResponse(dict):
    """
    VirtualHub route table.
    """
    def __init__(__self__, *,
                 routes: Optional[Sequence['outputs.VirtualHubRouteResponse']] = None):
        """
        VirtualHub route table.
        :param Sequence['VirtualHubRouteResponse'] routes: List of all routes.
        """
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.VirtualHubRouteResponse']]:
        """
        List of all routes.
        """
        return pulumi.get(self, "routes")


@pulumi.output_type
class VirtualHubRouteTableV2Response(dict):
    """
    VirtualHubRouteTableV2 Resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "attachedConnections":
            suggest = "attached_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualHubRouteTableV2Response. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualHubRouteTableV2Response.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualHubRouteTableV2Response.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: str,
                 provisioning_state: str,
                 attached_connections: Optional[Sequence[str]] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 routes: Optional[Sequence['outputs.VirtualHubRouteV2Response']] = None):
        """
        VirtualHubRouteTableV2 Resource.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str provisioning_state: The provisioning state of the virtual hub route table v2 resource.
        :param Sequence[str] attached_connections: List of all connections attached to this route table v2.
        :param str id: Resource ID.
        :param str name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param Sequence['VirtualHubRouteV2Response'] routes: List of all routes.
        """
        pulumi.set(__self__, "etag", etag)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if attached_connections is not None:
            pulumi.set(__self__, "attached_connections", attached_connections)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the virtual hub route table v2 resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="attachedConnections")
    def attached_connections(self) -> Optional[Sequence[str]]:
        """
        List of all connections attached to this route table v2.
        """
        return pulumi.get(self, "attached_connections")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.VirtualHubRouteV2Response']]:
        """
        List of all routes.
        """
        return pulumi.get(self, "routes")


@pulumi.output_type
class VirtualHubRouteV2Response(dict):
    """
    VirtualHubRouteTableV2 route.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationType":
            suggest = "destination_type"
        elif key == "nextHopType":
            suggest = "next_hop_type"
        elif key == "nextHops":
            suggest = "next_hops"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualHubRouteV2Response. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualHubRouteV2Response.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualHubRouteV2Response.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_type: Optional[str] = None,
                 destinations: Optional[Sequence[str]] = None,
                 next_hop_type: Optional[str] = None,
                 next_hops: Optional[Sequence[str]] = None):
        """
        VirtualHubRouteTableV2 route.
        :param str destination_type: The type of destinations.
        :param Sequence[str] destinations: List of all destinations.
        :param str next_hop_type: The type of next hops.
        :param Sequence[str] next_hops: NextHops ip address.
        """
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if next_hop_type is not None:
            pulumi.set(__self__, "next_hop_type", next_hop_type)
        if next_hops is not None:
            pulumi.set(__self__, "next_hops", next_hops)

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[str]:
        """
        The type of destinations.
        """
        return pulumi.get(self, "destination_type")

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence[str]]:
        """
        List of all destinations.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter(name="nextHopType")
    def next_hop_type(self) -> Optional[str]:
        """
        The type of next hops.
        """
        return pulumi.get(self, "next_hop_type")

    @property
    @pulumi.getter(name="nextHops")
    def next_hops(self) -> Optional[Sequence[str]]:
        """
        NextHops ip address.
        """
        return pulumi.get(self, "next_hops")


@pulumi.output_type
class VnetRouteResponse(dict):
    """
    List of routes that control routing from VirtualHub into a virtual network connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "staticRoutes":
            suggest = "static_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VnetRouteResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VnetRouteResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VnetRouteResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 static_routes: Optional[Sequence['outputs.StaticRouteResponse']] = None):
        """
        List of routes that control routing from VirtualHub into a virtual network connection.
        :param Sequence['StaticRouteResponse'] static_routes: List of all Static Routes.
        """
        if static_routes is not None:
            pulumi.set(__self__, "static_routes", static_routes)

    @property
    @pulumi.getter(name="staticRoutes")
    def static_routes(self) -> Optional[Sequence['outputs.StaticRouteResponse']]:
        """
        List of all Static Routes.
        """
        return pulumi.get(self, "static_routes")


