# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'CustomIpPrefixResponse',
    'ExpressRouteCircuitPeeringIdResponse',
    'ExpressRouteConnectionResponse',
    'ExpressRouteGatewayPropertiesResponseAutoScaleConfiguration',
    'ExpressRouteGatewayPropertiesResponseBounds',
    'ExtendedLocationResponse',
    'PropagatedRouteTableResponse',
    'RoutingConfigurationResponse',
    'StaticRouteResponse',
    'SubResourceResponse',
    'VirtualHubIdResponse',
    'VnetRouteResponse',
]

@pulumi.output_type
class CustomIpPrefixResponse(dict):
    """
    Custom IP prefix resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "childCustomIpPrefixes":
            suggest = "child_custom_ip_prefixes"
        elif key == "failedReason":
            suggest = "failed_reason"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "publicIpPrefixes":
            suggest = "public_ip_prefixes"
        elif key == "resourceGuid":
            suggest = "resource_guid"
        elif key == "authorizationMessage":
            suggest = "authorization_message"
        elif key == "commissionedState":
            suggest = "commissioned_state"
        elif key == "customIpPrefixParent":
            suggest = "custom_ip_prefix_parent"
        elif key == "extendedLocation":
            suggest = "extended_location"
        elif key == "signedMessage":
            suggest = "signed_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomIpPrefixResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomIpPrefixResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomIpPrefixResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 child_custom_ip_prefixes: Sequence['outputs.CustomIpPrefixResponse'],
                 etag: str,
                 failed_reason: str,
                 name: str,
                 provisioning_state: str,
                 public_ip_prefixes: Sequence['outputs.SubResourceResponse'],
                 resource_guid: str,
                 type: str,
                 authorization_message: Optional[str] = None,
                 cidr: Optional[str] = None,
                 commissioned_state: Optional[str] = None,
                 custom_ip_prefix_parent: Optional['outputs.CustomIpPrefixResponse'] = None,
                 extended_location: Optional['outputs.ExtendedLocationResponse'] = None,
                 id: Optional[str] = None,
                 location: Optional[str] = None,
                 signed_message: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 zones: Optional[Sequence[str]] = None):
        """
        Custom IP prefix resource.
        :param Sequence['CustomIpPrefixResponse'] child_custom_ip_prefixes: The list of all Children for IPv6 /48 CustomIpPrefix.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str failed_reason: The reason why resource is in failed state.
        :param str name: Resource name.
        :param str provisioning_state: The provisioning state of the custom IP prefix resource.
        :param Sequence['SubResourceResponse'] public_ip_prefixes: The list of all referenced PublicIpPrefixes.
        :param str resource_guid: The resource GUID property of the custom IP prefix resource.
        :param str type: Resource type.
        :param str authorization_message: Authorization message for WAN validation.
        :param str cidr: The prefix range in CIDR notation. Should include the start address and the prefix length.
        :param str commissioned_state: The commissioned state of the Custom IP Prefix.
        :param 'CustomIpPrefixResponse' custom_ip_prefix_parent: The Parent CustomIpPrefix for IPv6 /64 CustomIpPrefix.
        :param 'ExtendedLocationResponse' extended_location: The extended location of the custom IP prefix.
        :param str id: Resource ID.
        :param str location: Resource location.
        :param str signed_message: Signed message for WAN validation.
        :param Mapping[str, str] tags: Resource tags.
        :param Sequence[str] zones: A list of availability zones denoting the IP allocated for the resource needs to come from.
        """
        CustomIpPrefixResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            child_custom_ip_prefixes=child_custom_ip_prefixes,
            etag=etag,
            failed_reason=failed_reason,
            name=name,
            provisioning_state=provisioning_state,
            public_ip_prefixes=public_ip_prefixes,
            resource_guid=resource_guid,
            type=type,
            authorization_message=authorization_message,
            cidr=cidr,
            commissioned_state=commissioned_state,
            custom_ip_prefix_parent=custom_ip_prefix_parent,
            extended_location=extended_location,
            id=id,
            location=location,
            signed_message=signed_message,
            tags=tags,
            zones=zones,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             child_custom_ip_prefixes: Sequence['outputs.CustomIpPrefixResponse'],
             etag: str,
             failed_reason: str,
             name: str,
             provisioning_state: str,
             public_ip_prefixes: Sequence['outputs.SubResourceResponse'],
             resource_guid: str,
             type: str,
             authorization_message: Optional[str] = None,
             cidr: Optional[str] = None,
             commissioned_state: Optional[str] = None,
             custom_ip_prefix_parent: Optional['outputs.CustomIpPrefixResponse'] = None,
             extended_location: Optional['outputs.ExtendedLocationResponse'] = None,
             id: Optional[str] = None,
             location: Optional[str] = None,
             signed_message: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             zones: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'childCustomIpPrefixes' in kwargs:
            child_custom_ip_prefixes = kwargs['childCustomIpPrefixes']
        if 'failedReason' in kwargs:
            failed_reason = kwargs['failedReason']
        if 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if 'publicIpPrefixes' in kwargs:
            public_ip_prefixes = kwargs['publicIpPrefixes']
        if 'resourceGuid' in kwargs:
            resource_guid = kwargs['resourceGuid']
        if 'authorizationMessage' in kwargs:
            authorization_message = kwargs['authorizationMessage']
        if 'commissionedState' in kwargs:
            commissioned_state = kwargs['commissionedState']
        if 'customIpPrefixParent' in kwargs:
            custom_ip_prefix_parent = kwargs['customIpPrefixParent']
        if 'extendedLocation' in kwargs:
            extended_location = kwargs['extendedLocation']
        if 'signedMessage' in kwargs:
            signed_message = kwargs['signedMessage']

        _setter("child_custom_ip_prefixes", child_custom_ip_prefixes)
        _setter("etag", etag)
        _setter("failed_reason", failed_reason)
        _setter("name", name)
        _setter("provisioning_state", provisioning_state)
        _setter("public_ip_prefixes", public_ip_prefixes)
        _setter("resource_guid", resource_guid)
        _setter("type", type)
        if authorization_message is not None:
            _setter("authorization_message", authorization_message)
        if cidr is not None:
            _setter("cidr", cidr)
        if commissioned_state is not None:
            _setter("commissioned_state", commissioned_state)
        if custom_ip_prefix_parent is not None:
            _setter("custom_ip_prefix_parent", custom_ip_prefix_parent)
        if extended_location is not None:
            _setter("extended_location", extended_location)
        if id is not None:
            _setter("id", id)
        if location is not None:
            _setter("location", location)
        if signed_message is not None:
            _setter("signed_message", signed_message)
        if tags is not None:
            _setter("tags", tags)
        if zones is not None:
            _setter("zones", zones)

    @property
    @pulumi.getter(name="childCustomIpPrefixes")
    def child_custom_ip_prefixes(self) -> Sequence['outputs.CustomIpPrefixResponse']:
        """
        The list of all Children for IPv6 /48 CustomIpPrefix.
        """
        return pulumi.get(self, "child_custom_ip_prefixes")

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="failedReason")
    def failed_reason(self) -> str:
        """
        The reason why resource is in failed state.
        """
        return pulumi.get(self, "failed_reason")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the custom IP prefix resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="publicIpPrefixes")
    def public_ip_prefixes(self) -> Sequence['outputs.SubResourceResponse']:
        """
        The list of all referenced PublicIpPrefixes.
        """
        return pulumi.get(self, "public_ip_prefixes")

    @property
    @pulumi.getter(name="resourceGuid")
    def resource_guid(self) -> str:
        """
        The resource GUID property of the custom IP prefix resource.
        """
        return pulumi.get(self, "resource_guid")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="authorizationMessage")
    def authorization_message(self) -> Optional[str]:
        """
        Authorization message for WAN validation.
        """
        return pulumi.get(self, "authorization_message")

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        """
        The prefix range in CIDR notation. Should include the start address and the prefix length.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="commissionedState")
    def commissioned_state(self) -> Optional[str]:
        """
        The commissioned state of the Custom IP Prefix.
        """
        return pulumi.get(self, "commissioned_state")

    @property
    @pulumi.getter(name="customIpPrefixParent")
    def custom_ip_prefix_parent(self) -> Optional['outputs.CustomIpPrefixResponse']:
        """
        The Parent CustomIpPrefix for IPv6 /64 CustomIpPrefix.
        """
        return pulumi.get(self, "custom_ip_prefix_parent")

    @property
    @pulumi.getter(name="extendedLocation")
    def extended_location(self) -> Optional['outputs.ExtendedLocationResponse']:
        """
        The extended location of the custom IP prefix.
        """
        return pulumi.get(self, "extended_location")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Resource location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="signedMessage")
    def signed_message(self) -> Optional[str]:
        """
        Signed message for WAN validation.
        """
        return pulumi.get(self, "signed_message")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[str]]:
        """
        A list of availability zones denoting the IP allocated for the resource needs to come from.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class ExpressRouteCircuitPeeringIdResponse(dict):
    """
    ExpressRoute circuit peering identifier.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        ExpressRoute circuit peering identifier.
        :param str id: The ID of the ExpressRoute circuit peering.
        """
        ExpressRouteCircuitPeeringIdResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the ExpressRoute circuit peering.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ExpressRouteConnectionResponse(dict):
    """
    ExpressRouteConnection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expressRouteCircuitPeering":
            suggest = "express_route_circuit_peering"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "authorizationKey":
            suggest = "authorization_key"
        elif key == "enableInternetSecurity":
            suggest = "enable_internet_security"
        elif key == "expressRouteGatewayBypass":
            suggest = "express_route_gateway_bypass"
        elif key == "routingConfiguration":
            suggest = "routing_configuration"
        elif key == "routingWeight":
            suggest = "routing_weight"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 express_route_circuit_peering: 'outputs.ExpressRouteCircuitPeeringIdResponse',
                 name: str,
                 provisioning_state: str,
                 authorization_key: Optional[str] = None,
                 enable_internet_security: Optional[bool] = None,
                 express_route_gateway_bypass: Optional[bool] = None,
                 id: Optional[str] = None,
                 routing_configuration: Optional['outputs.RoutingConfigurationResponse'] = None,
                 routing_weight: Optional[int] = None):
        """
        ExpressRouteConnection resource.
        :param 'ExpressRouteCircuitPeeringIdResponse' express_route_circuit_peering: The ExpressRoute circuit peering.
        :param str name: The name of the resource.
        :param str provisioning_state: The provisioning state of the express route connection resource.
        :param str authorization_key: Authorization key to establish the connection.
        :param bool enable_internet_security: Enable internet security.
        :param bool express_route_gateway_bypass: Enable FastPath to vWan Firewall hub.
        :param str id: Resource ID.
        :param 'RoutingConfigurationResponse' routing_configuration: The Routing Configuration indicating the associated and propagated route tables on this connection.
        :param int routing_weight: The routing weight associated to the connection.
        """
        ExpressRouteConnectionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            express_route_circuit_peering=express_route_circuit_peering,
            name=name,
            provisioning_state=provisioning_state,
            authorization_key=authorization_key,
            enable_internet_security=enable_internet_security,
            express_route_gateway_bypass=express_route_gateway_bypass,
            id=id,
            routing_configuration=routing_configuration,
            routing_weight=routing_weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             express_route_circuit_peering: 'outputs.ExpressRouteCircuitPeeringIdResponse',
             name: str,
             provisioning_state: str,
             authorization_key: Optional[str] = None,
             enable_internet_security: Optional[bool] = None,
             express_route_gateway_bypass: Optional[bool] = None,
             id: Optional[str] = None,
             routing_configuration: Optional['outputs.RoutingConfigurationResponse'] = None,
             routing_weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'expressRouteCircuitPeering' in kwargs:
            express_route_circuit_peering = kwargs['expressRouteCircuitPeering']
        if 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if 'authorizationKey' in kwargs:
            authorization_key = kwargs['authorizationKey']
        if 'enableInternetSecurity' in kwargs:
            enable_internet_security = kwargs['enableInternetSecurity']
        if 'expressRouteGatewayBypass' in kwargs:
            express_route_gateway_bypass = kwargs['expressRouteGatewayBypass']
        if 'routingConfiguration' in kwargs:
            routing_configuration = kwargs['routingConfiguration']
        if 'routingWeight' in kwargs:
            routing_weight = kwargs['routingWeight']

        _setter("express_route_circuit_peering", express_route_circuit_peering)
        _setter("name", name)
        _setter("provisioning_state", provisioning_state)
        if authorization_key is not None:
            _setter("authorization_key", authorization_key)
        if enable_internet_security is not None:
            _setter("enable_internet_security", enable_internet_security)
        if express_route_gateway_bypass is not None:
            _setter("express_route_gateway_bypass", express_route_gateway_bypass)
        if id is not None:
            _setter("id", id)
        if routing_configuration is not None:
            _setter("routing_configuration", routing_configuration)
        if routing_weight is not None:
            _setter("routing_weight", routing_weight)

    @property
    @pulumi.getter(name="expressRouteCircuitPeering")
    def express_route_circuit_peering(self) -> 'outputs.ExpressRouteCircuitPeeringIdResponse':
        """
        The ExpressRoute circuit peering.
        """
        return pulumi.get(self, "express_route_circuit_peering")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the express route connection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="authorizationKey")
    def authorization_key(self) -> Optional[str]:
        """
        Authorization key to establish the connection.
        """
        return pulumi.get(self, "authorization_key")

    @property
    @pulumi.getter(name="enableInternetSecurity")
    def enable_internet_security(self) -> Optional[bool]:
        """
        Enable internet security.
        """
        return pulumi.get(self, "enable_internet_security")

    @property
    @pulumi.getter(name="expressRouteGatewayBypass")
    def express_route_gateway_bypass(self) -> Optional[bool]:
        """
        Enable FastPath to vWan Firewall hub.
        """
        return pulumi.get(self, "express_route_gateway_bypass")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="routingConfiguration")
    def routing_configuration(self) -> Optional['outputs.RoutingConfigurationResponse']:
        """
        The Routing Configuration indicating the associated and propagated route tables on this connection.
        """
        return pulumi.get(self, "routing_configuration")

    @property
    @pulumi.getter(name="routingWeight")
    def routing_weight(self) -> Optional[int]:
        """
        The routing weight associated to the connection.
        """
        return pulumi.get(self, "routing_weight")


@pulumi.output_type
class ExpressRouteGatewayPropertiesResponseAutoScaleConfiguration(dict):
    """
    Configuration for auto scaling.
    """
    def __init__(__self__, *,
                 bounds: Optional['outputs.ExpressRouteGatewayPropertiesResponseBounds'] = None):
        """
        Configuration for auto scaling.
        :param 'ExpressRouteGatewayPropertiesResponseBounds' bounds: Minimum and maximum number of scale units to deploy.
        """
        ExpressRouteGatewayPropertiesResponseAutoScaleConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bounds=bounds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bounds: Optional['outputs.ExpressRouteGatewayPropertiesResponseBounds'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if bounds is not None:
            _setter("bounds", bounds)

    @property
    @pulumi.getter
    def bounds(self) -> Optional['outputs.ExpressRouteGatewayPropertiesResponseBounds']:
        """
        Minimum and maximum number of scale units to deploy.
        """
        return pulumi.get(self, "bounds")


@pulumi.output_type
class ExpressRouteGatewayPropertiesResponseBounds(dict):
    """
    Minimum and maximum number of scale units to deploy.
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        Minimum and maximum number of scale units to deploy.
        :param int max: Maximum number of scale units deployed for ExpressRoute gateway.
        :param int min: Minimum number of scale units deployed for ExpressRoute gateway.
        """
        ExpressRouteGatewayPropertiesResponseBounds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Maximum number of scale units deployed for ExpressRoute gateway.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Minimum number of scale units deployed for ExpressRoute gateway.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class ExtendedLocationResponse(dict):
    """
    ExtendedLocation complex type.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        ExtendedLocation complex type.
        :param str name: The name of the extended location.
        :param str type: The type of the extended location.
        """
        ExtendedLocationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the extended location.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PropagatedRouteTableResponse(dict):
    """
    The list of RouteTables to advertise the routes to.
    """
    def __init__(__self__, *,
                 ids: Optional[Sequence['outputs.SubResourceResponse']] = None,
                 labels: Optional[Sequence[str]] = None):
        """
        The list of RouteTables to advertise the routes to.
        :param Sequence['SubResourceResponse'] ids: The list of resource ids of all the RouteTables.
        :param Sequence[str] labels: The list of labels.
        """
        PropagatedRouteTableResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ids=ids,
            labels=labels,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ids: Optional[Sequence['outputs.SubResourceResponse']] = None,
             labels: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if ids is not None:
            _setter("ids", ids)
        if labels is not None:
            _setter("labels", labels)

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence['outputs.SubResourceResponse']]:
        """
        The list of resource ids of all the RouteTables.
        """
        return pulumi.get(self, "ids")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Sequence[str]]:
        """
        The list of labels.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class RoutingConfigurationResponse(dict):
    """
    Routing Configuration indicating the associated and propagated route tables for this connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatedRouteTable":
            suggest = "associated_route_table"
        elif key == "propagatedRouteTables":
            suggest = "propagated_route_tables"
        elif key == "vnetRoutes":
            suggest = "vnet_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoutingConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoutingConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoutingConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associated_route_table: Optional['outputs.SubResourceResponse'] = None,
                 propagated_route_tables: Optional['outputs.PropagatedRouteTableResponse'] = None,
                 vnet_routes: Optional['outputs.VnetRouteResponse'] = None):
        """
        Routing Configuration indicating the associated and propagated route tables for this connection.
        :param 'SubResourceResponse' associated_route_table: The resource id RouteTable associated with this RoutingConfiguration.
        :param 'PropagatedRouteTableResponse' propagated_route_tables: The list of RouteTables to advertise the routes to.
        :param 'VnetRouteResponse' vnet_routes: List of routes that control routing from VirtualHub into a virtual network connection.
        """
        RoutingConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            associated_route_table=associated_route_table,
            propagated_route_tables=propagated_route_tables,
            vnet_routes=vnet_routes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             associated_route_table: Optional['outputs.SubResourceResponse'] = None,
             propagated_route_tables: Optional['outputs.PropagatedRouteTableResponse'] = None,
             vnet_routes: Optional['outputs.VnetRouteResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'associatedRouteTable' in kwargs:
            associated_route_table = kwargs['associatedRouteTable']
        if 'propagatedRouteTables' in kwargs:
            propagated_route_tables = kwargs['propagatedRouteTables']
        if 'vnetRoutes' in kwargs:
            vnet_routes = kwargs['vnetRoutes']

        if associated_route_table is not None:
            _setter("associated_route_table", associated_route_table)
        if propagated_route_tables is not None:
            _setter("propagated_route_tables", propagated_route_tables)
        if vnet_routes is not None:
            _setter("vnet_routes", vnet_routes)

    @property
    @pulumi.getter(name="associatedRouteTable")
    def associated_route_table(self) -> Optional['outputs.SubResourceResponse']:
        """
        The resource id RouteTable associated with this RoutingConfiguration.
        """
        return pulumi.get(self, "associated_route_table")

    @property
    @pulumi.getter(name="propagatedRouteTables")
    def propagated_route_tables(self) -> Optional['outputs.PropagatedRouteTableResponse']:
        """
        The list of RouteTables to advertise the routes to.
        """
        return pulumi.get(self, "propagated_route_tables")

    @property
    @pulumi.getter(name="vnetRoutes")
    def vnet_routes(self) -> Optional['outputs.VnetRouteResponse']:
        """
        List of routes that control routing from VirtualHub into a virtual network connection.
        """
        return pulumi.get(self, "vnet_routes")


@pulumi.output_type
class StaticRouteResponse(dict):
    """
    List of all Static Routes.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefixes":
            suggest = "address_prefixes"
        elif key == "nextHopIpAddress":
            suggest = "next_hop_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StaticRouteResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StaticRouteResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StaticRouteResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefixes: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 next_hop_ip_address: Optional[str] = None):
        """
        List of all Static Routes.
        :param Sequence[str] address_prefixes: List of all address prefixes.
        :param str name: The name of the StaticRoute that is unique within a VnetRoute.
        :param str next_hop_ip_address: The ip address of the next hop.
        """
        StaticRouteResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_prefixes=address_prefixes,
            name=name,
            next_hop_ip_address=next_hop_ip_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_prefixes: Optional[Sequence[str]] = None,
             name: Optional[str] = None,
             next_hop_ip_address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'addressPrefixes' in kwargs:
            address_prefixes = kwargs['addressPrefixes']
        if 'nextHopIpAddress' in kwargs:
            next_hop_ip_address = kwargs['nextHopIpAddress']

        if address_prefixes is not None:
            _setter("address_prefixes", address_prefixes)
        if name is not None:
            _setter("name", name)
        if next_hop_ip_address is not None:
            _setter("next_hop_ip_address", next_hop_ip_address)

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[Sequence[str]]:
        """
        List of all address prefixes.
        """
        return pulumi.get(self, "address_prefixes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the StaticRoute that is unique within a VnetRoute.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> Optional[str]:
        """
        The ip address of the next hop.
        """
        return pulumi.get(self, "next_hop_ip_address")


@pulumi.output_type
class SubResourceResponse(dict):
    """
    Reference to another subresource.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Reference to another subresource.
        :param str id: Resource ID.
        """
        SubResourceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class VirtualHubIdResponse(dict):
    """
    Virtual Hub identifier.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Virtual Hub identifier.
        :param str id: The resource URI for the Virtual Hub where the ExpressRoute gateway is or will be deployed. The Virtual Hub resource and the ExpressRoute gateway resource reside in the same subscription.
        """
        VirtualHubIdResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The resource URI for the Virtual Hub where the ExpressRoute gateway is or will be deployed. The Virtual Hub resource and the ExpressRoute gateway resource reside in the same subscription.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class VnetRouteResponse(dict):
    """
    List of routes that control routing from VirtualHub into a virtual network connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bgpConnections":
            suggest = "bgp_connections"
        elif key == "staticRoutes":
            suggest = "static_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VnetRouteResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VnetRouteResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VnetRouteResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bgp_connections: Sequence['outputs.SubResourceResponse'],
                 static_routes: Optional[Sequence['outputs.StaticRouteResponse']] = None):
        """
        List of routes that control routing from VirtualHub into a virtual network connection.
        :param Sequence['SubResourceResponse'] bgp_connections: The list of references to HubBgpConnection objects.
        :param Sequence['StaticRouteResponse'] static_routes: List of all Static Routes.
        """
        VnetRouteResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bgp_connections=bgp_connections,
            static_routes=static_routes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bgp_connections: Sequence['outputs.SubResourceResponse'],
             static_routes: Optional[Sequence['outputs.StaticRouteResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'bgpConnections' in kwargs:
            bgp_connections = kwargs['bgpConnections']
        if 'staticRoutes' in kwargs:
            static_routes = kwargs['staticRoutes']

        _setter("bgp_connections", bgp_connections)
        if static_routes is not None:
            _setter("static_routes", static_routes)

    @property
    @pulumi.getter(name="bgpConnections")
    def bgp_connections(self) -> Sequence['outputs.SubResourceResponse']:
        """
        The list of references to HubBgpConnection objects.
        """
        return pulumi.get(self, "bgp_connections")

    @property
    @pulumi.getter(name="staticRoutes")
    def static_routes(self) -> Optional[Sequence['outputs.StaticRouteResponse']]:
        """
        List of all Static Routes.
        """
        return pulumi.get(self, "static_routes")


