# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'ApplicationRuleArgs',
    'ApplicationRuleArgsDict',
    'DnsSettingsArgs',
    'DnsSettingsArgsDict',
    'ExplicitProxyArgs',
    'ExplicitProxyArgsDict',
    'FirewallPolicyFilterRuleCollectionActionArgs',
    'FirewallPolicyFilterRuleCollectionActionArgsDict',
    'FirewallPolicyFilterRuleCollectionArgs',
    'FirewallPolicyFilterRuleCollectionArgsDict',
    'FirewallPolicyHttpHeaderToInsertArgs',
    'FirewallPolicyHttpHeaderToInsertArgsDict',
    'FirewallPolicyInsightsArgs',
    'FirewallPolicyInsightsArgsDict',
    'FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsArgs',
    'FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsArgsDict',
    'FirewallPolicyIntrusionDetectionConfigurationArgs',
    'FirewallPolicyIntrusionDetectionConfigurationArgsDict',
    'FirewallPolicyIntrusionDetectionSignatureSpecificationArgs',
    'FirewallPolicyIntrusionDetectionSignatureSpecificationArgsDict',
    'FirewallPolicyIntrusionDetectionArgs',
    'FirewallPolicyIntrusionDetectionArgsDict',
    'FirewallPolicyLogAnalyticsResourcesArgs',
    'FirewallPolicyLogAnalyticsResourcesArgsDict',
    'FirewallPolicyLogAnalyticsWorkspaceArgs',
    'FirewallPolicyLogAnalyticsWorkspaceArgsDict',
    'FirewallPolicyNatRuleCollectionActionArgs',
    'FirewallPolicyNatRuleCollectionActionArgsDict',
    'FirewallPolicyNatRuleCollectionArgs',
    'FirewallPolicyNatRuleCollectionArgsDict',
    'FirewallPolicyRuleApplicationProtocolArgs',
    'FirewallPolicyRuleApplicationProtocolArgsDict',
    'FirewallPolicySNATArgs',
    'FirewallPolicySNATArgsDict',
    'FirewallPolicySQLArgs',
    'FirewallPolicySQLArgsDict',
    'FirewallPolicyThreatIntelWhitelistArgs',
    'FirewallPolicyThreatIntelWhitelistArgsDict',
    'NatRuleArgs',
    'NatRuleArgsDict',
    'NetworkRuleArgs',
    'NetworkRuleArgsDict',
    'SubResourceArgs',
    'SubResourceArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationRuleArgsDict(TypedDict):
        """
        Rule of type application.
        """
        rule_type: pulumi.Input[str]
        """
        Rule Type.
        Expected value is 'ApplicationRule'.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the rule.
        """
        destination_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of destination IP addresses or Service Tags.
        """
        fqdn_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of FQDN Tags for this rule.
        """
        http_headers_to_insert: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyHttpHeaderToInsertArgsDict']]]]
        """
        List of HTTP/S headers to insert.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the rule.
        """
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyRuleApplicationProtocolArgsDict']]]]
        """
        Array of Application Protocols.
        """
        source_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of source IP addresses for this rule.
        """
        source_ip_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of source IpGroups for this rule.
        """
        target_fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of FQDNs for this rule.
        """
        target_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Urls for this rule condition.
        """
        terminate_tls: NotRequired[pulumi.Input[bool]]
        """
        Terminate TLS connections for this rule.
        """
        web_categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of destination azure web categories.
        """
elif False:
    ApplicationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationRuleArgs:
    def __init__(__self__, *,
                 rule_type: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 destination_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fqdn_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 http_headers_to_insert: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyHttpHeaderToInsertArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyRuleApplicationProtocolArgs']]]] = None,
                 source_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_ip_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target_fqdns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 terminate_tls: Optional[pulumi.Input[bool]] = None,
                 web_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Rule of type application.
        :param pulumi.Input[str] rule_type: Rule Type.
               Expected value is 'ApplicationRule'.
        :param pulumi.Input[str] description: Description of the rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_addresses: List of destination IP addresses or Service Tags.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fqdn_tags: List of FQDN Tags for this rule.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyHttpHeaderToInsertArgs']]] http_headers_to_insert: List of HTTP/S headers to insert.
        :param pulumi.Input[str] name: Name of the rule.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyRuleApplicationProtocolArgs']]] protocols: Array of Application Protocols.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_addresses: List of source IP addresses for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_ip_groups: List of source IpGroups for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_fqdns: List of FQDNs for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_urls: List of Urls for this rule condition.
        :param pulumi.Input[bool] terminate_tls: Terminate TLS connections for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] web_categories: List of destination azure web categories.
        """
        pulumi.set(__self__, "rule_type", 'ApplicationRule')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if fqdn_tags is not None:
            pulumi.set(__self__, "fqdn_tags", fqdn_tags)
        if http_headers_to_insert is not None:
            pulumi.set(__self__, "http_headers_to_insert", http_headers_to_insert)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if target_fqdns is not None:
            pulumi.set(__self__, "target_fqdns", target_fqdns)
        if target_urls is not None:
            pulumi.set(__self__, "target_urls", target_urls)
        if terminate_tls is not None:
            pulumi.set(__self__, "terminate_tls", terminate_tls)
        if web_categories is not None:
            pulumi.set(__self__, "web_categories", web_categories)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[str]:
        """
        Rule Type.
        Expected value is 'ApplicationRule'.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of destination IP addresses or Service Tags.
        """
        return pulumi.get(self, "destination_addresses")

    @destination_addresses.setter
    def destination_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_addresses", value)

    @property
    @pulumi.getter(name="fqdnTags")
    def fqdn_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of FQDN Tags for this rule.
        """
        return pulumi.get(self, "fqdn_tags")

    @fqdn_tags.setter
    def fqdn_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fqdn_tags", value)

    @property
    @pulumi.getter(name="httpHeadersToInsert")
    def http_headers_to_insert(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyHttpHeaderToInsertArgs']]]]:
        """
        List of HTTP/S headers to insert.
        """
        return pulumi.get(self, "http_headers_to_insert")

    @http_headers_to_insert.setter
    def http_headers_to_insert(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyHttpHeaderToInsertArgs']]]]):
        pulumi.set(self, "http_headers_to_insert", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyRuleApplicationProtocolArgs']]]]:
        """
        Array of Application Protocols.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyRuleApplicationProtocolArgs']]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of source IP addresses for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @source_addresses.setter
    def source_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_addresses", value)

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")

    @source_ip_groups.setter
    def source_ip_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_ip_groups", value)

    @property
    @pulumi.getter(name="targetFqdns")
    def target_fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of FQDNs for this rule.
        """
        return pulumi.get(self, "target_fqdns")

    @target_fqdns.setter
    def target_fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_fqdns", value)

    @property
    @pulumi.getter(name="targetUrls")
    def target_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Urls for this rule condition.
        """
        return pulumi.get(self, "target_urls")

    @target_urls.setter
    def target_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "target_urls", value)

    @property
    @pulumi.getter(name="terminateTLS")
    def terminate_tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Terminate TLS connections for this rule.
        """
        return pulumi.get(self, "terminate_tls")

    @terminate_tls.setter
    def terminate_tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "terminate_tls", value)

    @property
    @pulumi.getter(name="webCategories")
    def web_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of destination azure web categories.
        """
        return pulumi.get(self, "web_categories")

    @web_categories.setter
    def web_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "web_categories", value)


if not MYPY:
    class DnsSettingsArgsDict(TypedDict):
        """
        DNS Proxy Settings in Firewall Policy.
        """
        enable_proxy: NotRequired[pulumi.Input[bool]]
        """
        Enable DNS Proxy on Firewalls attached to the Firewall Policy.
        """
        require_proxy_for_network_rules: NotRequired[pulumi.Input[bool]]
        """
        FQDNs in Network Rules are supported when set to true.
        """
        servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Custom DNS Servers.
        """
elif False:
    DnsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsSettingsArgs:
    def __init__(__self__, *,
                 enable_proxy: Optional[pulumi.Input[bool]] = None,
                 require_proxy_for_network_rules: Optional[pulumi.Input[bool]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        DNS Proxy Settings in Firewall Policy.
        :param pulumi.Input[bool] enable_proxy: Enable DNS Proxy on Firewalls attached to the Firewall Policy.
        :param pulumi.Input[bool] require_proxy_for_network_rules: FQDNs in Network Rules are supported when set to true.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] servers: List of Custom DNS Servers.
        """
        if enable_proxy is not None:
            pulumi.set(__self__, "enable_proxy", enable_proxy)
        if require_proxy_for_network_rules is not None:
            pulumi.set(__self__, "require_proxy_for_network_rules", require_proxy_for_network_rules)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter(name="enableProxy")
    def enable_proxy(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable DNS Proxy on Firewalls attached to the Firewall Policy.
        """
        return pulumi.get(self, "enable_proxy")

    @enable_proxy.setter
    def enable_proxy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_proxy", value)

    @property
    @pulumi.getter(name="requireProxyForNetworkRules")
    def require_proxy_for_network_rules(self) -> Optional[pulumi.Input[bool]]:
        """
        FQDNs in Network Rules are supported when set to true.
        """
        return pulumi.get(self, "require_proxy_for_network_rules")

    @require_proxy_for_network_rules.setter
    def require_proxy_for_network_rules(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_proxy_for_network_rules", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Custom DNS Servers.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "servers", value)


if not MYPY:
    class ExplicitProxyArgsDict(TypedDict):
        """
        Explicit Proxy Settings in Firewall Policy.
        """
        enable_explicit_proxy: NotRequired[pulumi.Input[bool]]
        """
        When set to true, explicit proxy mode is enabled.
        """
        enable_pac_file: NotRequired[pulumi.Input[bool]]
        """
        When set to true, pac file port and url needs to be provided.
        """
        http_port: NotRequired[pulumi.Input[int]]
        """
        Port number for explicit proxy http protocol, cannot be greater than 64000.
        """
        https_port: NotRequired[pulumi.Input[int]]
        """
        Port number for explicit proxy https protocol, cannot be greater than 64000.
        """
        pac_file: NotRequired[pulumi.Input[str]]
        """
        SAS URL for PAC file.
        """
        pac_file_port: NotRequired[pulumi.Input[int]]
        """
        Port number for firewall to serve PAC file.
        """
elif False:
    ExplicitProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExplicitProxyArgs:
    def __init__(__self__, *,
                 enable_explicit_proxy: Optional[pulumi.Input[bool]] = None,
                 enable_pac_file: Optional[pulumi.Input[bool]] = None,
                 http_port: Optional[pulumi.Input[int]] = None,
                 https_port: Optional[pulumi.Input[int]] = None,
                 pac_file: Optional[pulumi.Input[str]] = None,
                 pac_file_port: Optional[pulumi.Input[int]] = None):
        """
        Explicit Proxy Settings in Firewall Policy.
        :param pulumi.Input[bool] enable_explicit_proxy: When set to true, explicit proxy mode is enabled.
        :param pulumi.Input[bool] enable_pac_file: When set to true, pac file port and url needs to be provided.
        :param pulumi.Input[int] http_port: Port number for explicit proxy http protocol, cannot be greater than 64000.
        :param pulumi.Input[int] https_port: Port number for explicit proxy https protocol, cannot be greater than 64000.
        :param pulumi.Input[str] pac_file: SAS URL for PAC file.
        :param pulumi.Input[int] pac_file_port: Port number for firewall to serve PAC file.
        """
        if enable_explicit_proxy is not None:
            pulumi.set(__self__, "enable_explicit_proxy", enable_explicit_proxy)
        if enable_pac_file is not None:
            pulumi.set(__self__, "enable_pac_file", enable_pac_file)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if pac_file is not None:
            pulumi.set(__self__, "pac_file", pac_file)
        if pac_file_port is not None:
            pulumi.set(__self__, "pac_file_port", pac_file_port)

    @property
    @pulumi.getter(name="enableExplicitProxy")
    def enable_explicit_proxy(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, explicit proxy mode is enabled.
        """
        return pulumi.get(self, "enable_explicit_proxy")

    @enable_explicit_proxy.setter
    def enable_explicit_proxy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_explicit_proxy", value)

    @property
    @pulumi.getter(name="enablePacFile")
    def enable_pac_file(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, pac file port and url needs to be provided.
        """
        return pulumi.get(self, "enable_pac_file")

    @enable_pac_file.setter
    def enable_pac_file(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_pac_file", value)

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number for explicit proxy http protocol, cannot be greater than 64000.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_port", value)

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number for explicit proxy https protocol, cannot be greater than 64000.
        """
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "https_port", value)

    @property
    @pulumi.getter(name="pacFile")
    def pac_file(self) -> Optional[pulumi.Input[str]]:
        """
        SAS URL for PAC file.
        """
        return pulumi.get(self, "pac_file")

    @pac_file.setter
    def pac_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pac_file", value)

    @property
    @pulumi.getter(name="pacFilePort")
    def pac_file_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number for firewall to serve PAC file.
        """
        return pulumi.get(self, "pac_file_port")

    @pac_file_port.setter
    def pac_file_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "pac_file_port", value)


if not MYPY:
    class FirewallPolicyFilterRuleCollectionActionArgsDict(TypedDict):
        """
        Properties of the FirewallPolicyFilterRuleCollectionAction.
        """
        type: NotRequired[pulumi.Input[Union[str, 'FirewallPolicyFilterRuleCollectionActionType']]]
        """
        The type of action.
        """
elif False:
    FirewallPolicyFilterRuleCollectionActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFilterRuleCollectionActionArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[str, 'FirewallPolicyFilterRuleCollectionActionType']]] = None):
        """
        Properties of the FirewallPolicyFilterRuleCollectionAction.
        :param pulumi.Input[Union[str, 'FirewallPolicyFilterRuleCollectionActionType']] type: The type of action.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'FirewallPolicyFilterRuleCollectionActionType']]]:
        """
        The type of action.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'FirewallPolicyFilterRuleCollectionActionType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FirewallPolicyFilterRuleCollectionArgsDict(TypedDict):
        """
        Firewall Policy Filter Rule Collection.
        """
        rule_collection_type: pulumi.Input[str]
        """
        The type of the rule collection.
        Expected value is 'FirewallPolicyFilterRuleCollection'.
        """
        action: NotRequired[pulumi.Input['FirewallPolicyFilterRuleCollectionActionArgsDict']]
        """
        The action type of a Filter rule collection.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the rule collection.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Priority of the Firewall Policy Rule Collection resource.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationRuleArgsDict', 'NatRuleArgsDict', 'NetworkRuleArgsDict']]]]]
        """
        List of rules included in a rule collection.
        """
elif False:
    FirewallPolicyFilterRuleCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyFilterRuleCollectionArgs:
    def __init__(__self__, *,
                 rule_collection_type: pulumi.Input[str],
                 action: Optional[pulumi.Input['FirewallPolicyFilterRuleCollectionActionArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationRuleArgs', 'NatRuleArgs', 'NetworkRuleArgs']]]]] = None):
        """
        Firewall Policy Filter Rule Collection.
        :param pulumi.Input[str] rule_collection_type: The type of the rule collection.
               Expected value is 'FirewallPolicyFilterRuleCollection'.
        :param pulumi.Input['FirewallPolicyFilterRuleCollectionActionArgs'] action: The action type of a Filter rule collection.
        :param pulumi.Input[str] name: The name of the rule collection.
        :param pulumi.Input[int] priority: Priority of the Firewall Policy Rule Collection resource.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ApplicationRuleArgs', 'NatRuleArgs', 'NetworkRuleArgs']]]] rules: List of rules included in a rule collection.
        """
        pulumi.set(__self__, "rule_collection_type", 'FirewallPolicyFilterRuleCollection')
        if action is not None:
            pulumi.set(__self__, "action", action)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="ruleCollectionType")
    def rule_collection_type(self) -> pulumi.Input[str]:
        """
        The type of the rule collection.
        Expected value is 'FirewallPolicyFilterRuleCollection'.
        """
        return pulumi.get(self, "rule_collection_type")

    @rule_collection_type.setter
    def rule_collection_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_collection_type", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['FirewallPolicyFilterRuleCollectionActionArgs']]:
        """
        The action type of a Filter rule collection.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['FirewallPolicyFilterRuleCollectionActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the rule collection.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Priority of the Firewall Policy Rule Collection resource.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationRuleArgs', 'NatRuleArgs', 'NetworkRuleArgs']]]]]:
        """
        List of rules included in a rule collection.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationRuleArgs', 'NatRuleArgs', 'NetworkRuleArgs']]]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class FirewallPolicyHttpHeaderToInsertArgsDict(TypedDict):
        """
        name and value of HTTP/S header to insert
        """
        header_name: NotRequired[pulumi.Input[str]]
        """
        Contains the name of the header
        """
        header_value: NotRequired[pulumi.Input[str]]
        """
        Contains the value of the header
        """
elif False:
    FirewallPolicyHttpHeaderToInsertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyHttpHeaderToInsertArgs:
    def __init__(__self__, *,
                 header_name: Optional[pulumi.Input[str]] = None,
                 header_value: Optional[pulumi.Input[str]] = None):
        """
        name and value of HTTP/S header to insert
        :param pulumi.Input[str] header_name: Contains the name of the header
        :param pulumi.Input[str] header_value: Contains the value of the header
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[pulumi.Input[str]]:
        """
        Contains the name of the header
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[pulumi.Input[str]]:
        """
        Contains the value of the header
        """
        return pulumi.get(self, "header_value")

    @header_value.setter
    def header_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_value", value)


if not MYPY:
    class FirewallPolicyInsightsArgsDict(TypedDict):
        """
        Firewall Policy Insights.
        """
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        A flag to indicate if the insights are enabled on the policy.
        """
        log_analytics_resources: NotRequired[pulumi.Input['FirewallPolicyLogAnalyticsResourcesArgsDict']]
        """
        Workspaces needed to configure the Firewall Policy Insights.
        """
        retention_days: NotRequired[pulumi.Input[int]]
        """
        Number of days the insights should be enabled on the policy.
        """
elif False:
    FirewallPolicyInsightsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyInsightsArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 log_analytics_resources: Optional[pulumi.Input['FirewallPolicyLogAnalyticsResourcesArgs']] = None,
                 retention_days: Optional[pulumi.Input[int]] = None):
        """
        Firewall Policy Insights.
        :param pulumi.Input[bool] is_enabled: A flag to indicate if the insights are enabled on the policy.
        :param pulumi.Input['FirewallPolicyLogAnalyticsResourcesArgs'] log_analytics_resources: Workspaces needed to configure the Firewall Policy Insights.
        :param pulumi.Input[int] retention_days: Number of days the insights should be enabled on the policy.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if log_analytics_resources is not None:
            pulumi.set(__self__, "log_analytics_resources", log_analytics_resources)
        if retention_days is not None:
            pulumi.set(__self__, "retention_days", retention_days)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to indicate if the insights are enabled on the policy.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="logAnalyticsResources")
    def log_analytics_resources(self) -> Optional[pulumi.Input['FirewallPolicyLogAnalyticsResourcesArgs']]:
        """
        Workspaces needed to configure the Firewall Policy Insights.
        """
        return pulumi.get(self, "log_analytics_resources")

    @log_analytics_resources.setter
    def log_analytics_resources(self, value: Optional[pulumi.Input['FirewallPolicyLogAnalyticsResourcesArgs']]):
        pulumi.set(self, "log_analytics_resources", value)

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days the insights should be enabled on the policy.
        """
        return pulumi.get(self, "retention_days")

    @retention_days.setter
    def retention_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_days", value)


if not MYPY:
    class FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsArgsDict(TypedDict):
        """
        Intrusion detection bypass traffic specification.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the bypass traffic rule.
        """
        destination_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of destination IP addresses or ranges for this rule.
        """
        destination_ip_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of destination IpGroups for this rule.
        """
        destination_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of destination ports or ranges.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the bypass traffic rule.
        """
        protocol: NotRequired[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionProtocol']]]
        """
        The rule bypass protocol.
        """
        source_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of source IP addresses or ranges for this rule.
        """
        source_ip_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of source IpGroups for this rule.
        """
elif False:
    FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 destination_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 destination_ip_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionProtocol']]] = None,
                 source_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_ip_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Intrusion detection bypass traffic specification.
        :param pulumi.Input[str] description: Description of the bypass traffic rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_addresses: List of destination IP addresses or ranges for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_ip_groups: List of destination IpGroups for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_ports: List of destination ports or ranges.
        :param pulumi.Input[str] name: Name of the bypass traffic rule.
        :param pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionProtocol']] protocol: The rule bypass protocol.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_addresses: List of source IP addresses or ranges for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_ip_groups: List of source IpGroups for this rule.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_ip_groups is not None:
            pulumi.set(__self__, "destination_ip_groups", destination_ip_groups)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the bypass traffic rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of destination IP addresses or ranges for this rule.
        """
        return pulumi.get(self, "destination_addresses")

    @destination_addresses.setter
    def destination_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_addresses", value)

    @property
    @pulumi.getter(name="destinationIpGroups")
    def destination_ip_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of destination IpGroups for this rule.
        """
        return pulumi.get(self, "destination_ip_groups")

    @destination_ip_groups.setter
    def destination_ip_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_ip_groups", value)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of destination ports or ranges.
        """
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_ports", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the bypass traffic rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionProtocol']]]:
        """
        The rule bypass protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionProtocol']]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of source IP addresses or ranges for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @source_addresses.setter
    def source_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_addresses", value)

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")

    @source_ip_groups.setter
    def source_ip_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_ip_groups", value)


if not MYPY:
    class FirewallPolicyIntrusionDetectionConfigurationArgsDict(TypedDict):
        """
        The operation for configuring intrusion detection.
        """
        bypass_traffic_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsArgsDict']]]]
        """
        List of rules for traffic to bypass.
        """
        private_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        IDPS Private IP address ranges are used to identify traffic direction (i.e. inbound, outbound, etc.). By default, only ranges defined by IANA RFC 1918 are considered private IP addresses. To modify default ranges, specify your Private IP address ranges with this property
        """
        signature_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyIntrusionDetectionSignatureSpecificationArgsDict']]]]
        """
        List of specific signatures states.
        """
elif False:
    FirewallPolicyIntrusionDetectionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyIntrusionDetectionConfigurationArgs:
    def __init__(__self__, *,
                 bypass_traffic_settings: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsArgs']]]] = None,
                 private_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 signature_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyIntrusionDetectionSignatureSpecificationArgs']]]] = None):
        """
        The operation for configuring intrusion detection.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsArgs']]] bypass_traffic_settings: List of rules for traffic to bypass.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] private_ranges: IDPS Private IP address ranges are used to identify traffic direction (i.e. inbound, outbound, etc.). By default, only ranges defined by IANA RFC 1918 are considered private IP addresses. To modify default ranges, specify your Private IP address ranges with this property
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyIntrusionDetectionSignatureSpecificationArgs']]] signature_overrides: List of specific signatures states.
        """
        if bypass_traffic_settings is not None:
            pulumi.set(__self__, "bypass_traffic_settings", bypass_traffic_settings)
        if private_ranges is not None:
            pulumi.set(__self__, "private_ranges", private_ranges)
        if signature_overrides is not None:
            pulumi.set(__self__, "signature_overrides", signature_overrides)

    @property
    @pulumi.getter(name="bypassTrafficSettings")
    def bypass_traffic_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsArgs']]]]:
        """
        List of rules for traffic to bypass.
        """
        return pulumi.get(self, "bypass_traffic_settings")

    @bypass_traffic_settings.setter
    def bypass_traffic_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsArgs']]]]):
        pulumi.set(self, "bypass_traffic_settings", value)

    @property
    @pulumi.getter(name="privateRanges")
    def private_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IDPS Private IP address ranges are used to identify traffic direction (i.e. inbound, outbound, etc.). By default, only ranges defined by IANA RFC 1918 are considered private IP addresses. To modify default ranges, specify your Private IP address ranges with this property
        """
        return pulumi.get(self, "private_ranges")

    @private_ranges.setter
    def private_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "private_ranges", value)

    @property
    @pulumi.getter(name="signatureOverrides")
    def signature_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyIntrusionDetectionSignatureSpecificationArgs']]]]:
        """
        List of specific signatures states.
        """
        return pulumi.get(self, "signature_overrides")

    @signature_overrides.setter
    def signature_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyIntrusionDetectionSignatureSpecificationArgs']]]]):
        pulumi.set(self, "signature_overrides", value)


if not MYPY:
    class FirewallPolicyIntrusionDetectionSignatureSpecificationArgsDict(TypedDict):
        """
        Intrusion detection signatures specification states.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Signature id.
        """
        mode: NotRequired[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionStateType']]]
        """
        The signature state.
        """
elif False:
    FirewallPolicyIntrusionDetectionSignatureSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyIntrusionDetectionSignatureSpecificationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionStateType']]] = None):
        """
        Intrusion detection signatures specification states.
        :param pulumi.Input[str] id: Signature id.
        :param pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionStateType']] mode: The signature state.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Signature id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionStateType']]]:
        """
        The signature state.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionStateType']]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class FirewallPolicyIntrusionDetectionArgsDict(TypedDict):
        """
        Configuration for intrusion detection mode and rules.
        """
        configuration: NotRequired[pulumi.Input['FirewallPolicyIntrusionDetectionConfigurationArgsDict']]
        """
        Intrusion detection configuration properties.
        """
        mode: NotRequired[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionStateType']]]
        """
        Intrusion detection general state. When attached to a parent policy, the firewall's effective IDPS mode is the stricter mode of the two.
        """
        profile: NotRequired[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionProfileType']]]
        """
        IDPS profile name. When attached to a parent policy, the firewall's effective profile is the profile name of the parent policy.
        """
elif False:
    FirewallPolicyIntrusionDetectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyIntrusionDetectionArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input['FirewallPolicyIntrusionDetectionConfigurationArgs']] = None,
                 mode: Optional[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionStateType']]] = None,
                 profile: Optional[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionProfileType']]] = None):
        """
        Configuration for intrusion detection mode and rules.
        :param pulumi.Input['FirewallPolicyIntrusionDetectionConfigurationArgs'] configuration: Intrusion detection configuration properties.
        :param pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionStateType']] mode: Intrusion detection general state. When attached to a parent policy, the firewall's effective IDPS mode is the stricter mode of the two.
        :param pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionProfileType']] profile: IDPS profile name. When attached to a parent policy, the firewall's effective profile is the profile name of the parent policy.
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['FirewallPolicyIntrusionDetectionConfigurationArgs']]:
        """
        Intrusion detection configuration properties.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['FirewallPolicyIntrusionDetectionConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionStateType']]]:
        """
        Intrusion detection general state. When attached to a parent policy, the firewall's effective IDPS mode is the stricter mode of the two.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionStateType']]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def profile(self) -> Optional[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionProfileType']]]:
        """
        IDPS profile name. When attached to a parent policy, the firewall's effective profile is the profile name of the parent policy.
        """
        return pulumi.get(self, "profile")

    @profile.setter
    def profile(self, value: Optional[pulumi.Input[Union[str, 'FirewallPolicyIntrusionDetectionProfileType']]]):
        pulumi.set(self, "profile", value)


if not MYPY:
    class FirewallPolicyLogAnalyticsResourcesArgsDict(TypedDict):
        """
        Log Analytics Resources for Firewall Policy Insights.
        """
        default_workspace_id: NotRequired[pulumi.Input['SubResourceArgsDict']]
        """
        The default workspace Id for Firewall Policy Insights.
        """
        workspaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyLogAnalyticsWorkspaceArgsDict']]]]
        """
        List of workspaces for Firewall Policy Insights.
        """
elif False:
    FirewallPolicyLogAnalyticsResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyLogAnalyticsResourcesArgs:
    def __init__(__self__, *,
                 default_workspace_id: Optional[pulumi.Input['SubResourceArgs']] = None,
                 workspaces: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyLogAnalyticsWorkspaceArgs']]]] = None):
        """
        Log Analytics Resources for Firewall Policy Insights.
        :param pulumi.Input['SubResourceArgs'] default_workspace_id: The default workspace Id for Firewall Policy Insights.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyLogAnalyticsWorkspaceArgs']]] workspaces: List of workspaces for Firewall Policy Insights.
        """
        if default_workspace_id is not None:
            pulumi.set(__self__, "default_workspace_id", default_workspace_id)
        if workspaces is not None:
            pulumi.set(__self__, "workspaces", workspaces)

    @property
    @pulumi.getter(name="defaultWorkspaceId")
    def default_workspace_id(self) -> Optional[pulumi.Input['SubResourceArgs']]:
        """
        The default workspace Id for Firewall Policy Insights.
        """
        return pulumi.get(self, "default_workspace_id")

    @default_workspace_id.setter
    def default_workspace_id(self, value: Optional[pulumi.Input['SubResourceArgs']]):
        pulumi.set(self, "default_workspace_id", value)

    @property
    @pulumi.getter
    def workspaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyLogAnalyticsWorkspaceArgs']]]]:
        """
        List of workspaces for Firewall Policy Insights.
        """
        return pulumi.get(self, "workspaces")

    @workspaces.setter
    def workspaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyLogAnalyticsWorkspaceArgs']]]]):
        pulumi.set(self, "workspaces", value)


if not MYPY:
    class FirewallPolicyLogAnalyticsWorkspaceArgsDict(TypedDict):
        """
        Log Analytics Workspace for Firewall Policy Insights.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Region to configure the Workspace.
        """
        workspace_id: NotRequired[pulumi.Input['SubResourceArgsDict']]
        """
        The workspace Id for Firewall Policy Insights.
        """
elif False:
    FirewallPolicyLogAnalyticsWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyLogAnalyticsWorkspaceArgs:
    def __init__(__self__, *,
                 region: Optional[pulumi.Input[str]] = None,
                 workspace_id: Optional[pulumi.Input['SubResourceArgs']] = None):
        """
        Log Analytics Workspace for Firewall Policy Insights.
        :param pulumi.Input[str] region: Region to configure the Workspace.
        :param pulumi.Input['SubResourceArgs'] workspace_id: The workspace Id for Firewall Policy Insights.
        """
        if region is not None:
            pulumi.set(__self__, "region", region)
        if workspace_id is not None:
            pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Region to configure the Workspace.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> Optional[pulumi.Input['SubResourceArgs']]:
        """
        The workspace Id for Firewall Policy Insights.
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: Optional[pulumi.Input['SubResourceArgs']]):
        pulumi.set(self, "workspace_id", value)


if not MYPY:
    class FirewallPolicyNatRuleCollectionActionArgsDict(TypedDict):
        """
        Properties of the FirewallPolicyNatRuleCollectionAction.
        """
        type: NotRequired[pulumi.Input[Union[str, 'FirewallPolicyNatRuleCollectionActionType']]]
        """
        The type of action.
        """
elif False:
    FirewallPolicyNatRuleCollectionActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyNatRuleCollectionActionArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[str, 'FirewallPolicyNatRuleCollectionActionType']]] = None):
        """
        Properties of the FirewallPolicyNatRuleCollectionAction.
        :param pulumi.Input[Union[str, 'FirewallPolicyNatRuleCollectionActionType']] type: The type of action.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'FirewallPolicyNatRuleCollectionActionType']]]:
        """
        The type of action.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'FirewallPolicyNatRuleCollectionActionType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FirewallPolicyNatRuleCollectionArgsDict(TypedDict):
        """
        Firewall Policy NAT Rule Collection.
        """
        rule_collection_type: pulumi.Input[str]
        """
        The type of the rule collection.
        Expected value is 'FirewallPolicyNatRuleCollection'.
        """
        action: NotRequired[pulumi.Input['FirewallPolicyNatRuleCollectionActionArgsDict']]
        """
        The action type of a Nat rule collection.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the rule collection.
        """
        priority: NotRequired[pulumi.Input[int]]
        """
        Priority of the Firewall Policy Rule Collection resource.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationRuleArgsDict', 'NatRuleArgsDict', 'NetworkRuleArgsDict']]]]]
        """
        List of rules included in a rule collection.
        """
elif False:
    FirewallPolicyNatRuleCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyNatRuleCollectionArgs:
    def __init__(__self__, *,
                 rule_collection_type: pulumi.Input[str],
                 action: Optional[pulumi.Input['FirewallPolicyNatRuleCollectionActionArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationRuleArgs', 'NatRuleArgs', 'NetworkRuleArgs']]]]] = None):
        """
        Firewall Policy NAT Rule Collection.
        :param pulumi.Input[str] rule_collection_type: The type of the rule collection.
               Expected value is 'FirewallPolicyNatRuleCollection'.
        :param pulumi.Input['FirewallPolicyNatRuleCollectionActionArgs'] action: The action type of a Nat rule collection.
        :param pulumi.Input[str] name: The name of the rule collection.
        :param pulumi.Input[int] priority: Priority of the Firewall Policy Rule Collection resource.
        :param pulumi.Input[Sequence[pulumi.Input[Union['ApplicationRuleArgs', 'NatRuleArgs', 'NetworkRuleArgs']]]] rules: List of rules included in a rule collection.
        """
        pulumi.set(__self__, "rule_collection_type", 'FirewallPolicyNatRuleCollection')
        if action is not None:
            pulumi.set(__self__, "action", action)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="ruleCollectionType")
    def rule_collection_type(self) -> pulumi.Input[str]:
        """
        The type of the rule collection.
        Expected value is 'FirewallPolicyNatRuleCollection'.
        """
        return pulumi.get(self, "rule_collection_type")

    @rule_collection_type.setter
    def rule_collection_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_collection_type", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['FirewallPolicyNatRuleCollectionActionArgs']]:
        """
        The action type of a Nat rule collection.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['FirewallPolicyNatRuleCollectionActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the rule collection.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Priority of the Firewall Policy Rule Collection resource.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationRuleArgs', 'NatRuleArgs', 'NetworkRuleArgs']]]]]:
        """
        List of rules included in a rule collection.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['ApplicationRuleArgs', 'NatRuleArgs', 'NetworkRuleArgs']]]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class FirewallPolicyRuleApplicationProtocolArgsDict(TypedDict):
        """
        Properties of the application rule protocol.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port number for the protocol, cannot be greater than 64000.
        """
        protocol_type: NotRequired[pulumi.Input[Union[str, 'FirewallPolicyRuleApplicationProtocolType']]]
        """
        Protocol type.
        """
elif False:
    FirewallPolicyRuleApplicationProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyRuleApplicationProtocolArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol_type: Optional[pulumi.Input[Union[str, 'FirewallPolicyRuleApplicationProtocolType']]] = None):
        """
        Properties of the application rule protocol.
        :param pulumi.Input[int] port: Port number for the protocol, cannot be greater than 64000.
        :param pulumi.Input[Union[str, 'FirewallPolicyRuleApplicationProtocolType']] protocol_type: Protocol type.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol_type is not None:
            pulumi.set(__self__, "protocol_type", protocol_type)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port number for the protocol, cannot be greater than 64000.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> Optional[pulumi.Input[Union[str, 'FirewallPolicyRuleApplicationProtocolType']]]:
        """
        Protocol type.
        """
        return pulumi.get(self, "protocol_type")

    @protocol_type.setter
    def protocol_type(self, value: Optional[pulumi.Input[Union[str, 'FirewallPolicyRuleApplicationProtocolType']]]):
        pulumi.set(self, "protocol_type", value)


if not MYPY:
    class FirewallPolicySNATArgsDict(TypedDict):
        """
        The private IP addresses/IP ranges to which traffic will not be SNAT.
        """
        auto_learn_private_ranges: NotRequired[pulumi.Input[Union[str, 'AutoLearnPrivateRangesMode']]]
        """
        The operation mode for automatically learning private ranges to not be SNAT
        """
        private_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of private IP addresses/IP address ranges to not be SNAT.
        """
elif False:
    FirewallPolicySNATArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicySNATArgs:
    def __init__(__self__, *,
                 auto_learn_private_ranges: Optional[pulumi.Input[Union[str, 'AutoLearnPrivateRangesMode']]] = None,
                 private_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The private IP addresses/IP ranges to which traffic will not be SNAT.
        :param pulumi.Input[Union[str, 'AutoLearnPrivateRangesMode']] auto_learn_private_ranges: The operation mode for automatically learning private ranges to not be SNAT
        :param pulumi.Input[Sequence[pulumi.Input[str]]] private_ranges: List of private IP addresses/IP address ranges to not be SNAT.
        """
        if auto_learn_private_ranges is not None:
            pulumi.set(__self__, "auto_learn_private_ranges", auto_learn_private_ranges)
        if private_ranges is not None:
            pulumi.set(__self__, "private_ranges", private_ranges)

    @property
    @pulumi.getter(name="autoLearnPrivateRanges")
    def auto_learn_private_ranges(self) -> Optional[pulumi.Input[Union[str, 'AutoLearnPrivateRangesMode']]]:
        """
        The operation mode for automatically learning private ranges to not be SNAT
        """
        return pulumi.get(self, "auto_learn_private_ranges")

    @auto_learn_private_ranges.setter
    def auto_learn_private_ranges(self, value: Optional[pulumi.Input[Union[str, 'AutoLearnPrivateRangesMode']]]):
        pulumi.set(self, "auto_learn_private_ranges", value)

    @property
    @pulumi.getter(name="privateRanges")
    def private_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of private IP addresses/IP address ranges to not be SNAT.
        """
        return pulumi.get(self, "private_ranges")

    @private_ranges.setter
    def private_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "private_ranges", value)


if not MYPY:
    class FirewallPolicySQLArgsDict(TypedDict):
        """
        SQL Settings in Firewall Policy.
        """
        allow_sql_redirect: NotRequired[pulumi.Input[bool]]
        """
        A flag to indicate if SQL Redirect traffic filtering is enabled. Turning on the flag requires no rule using port 11000-11999.
        """
elif False:
    FirewallPolicySQLArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicySQLArgs:
    def __init__(__self__, *,
                 allow_sql_redirect: Optional[pulumi.Input[bool]] = None):
        """
        SQL Settings in Firewall Policy.
        :param pulumi.Input[bool] allow_sql_redirect: A flag to indicate if SQL Redirect traffic filtering is enabled. Turning on the flag requires no rule using port 11000-11999.
        """
        if allow_sql_redirect is not None:
            pulumi.set(__self__, "allow_sql_redirect", allow_sql_redirect)

    @property
    @pulumi.getter(name="allowSqlRedirect")
    def allow_sql_redirect(self) -> Optional[pulumi.Input[bool]]:
        """
        A flag to indicate if SQL Redirect traffic filtering is enabled. Turning on the flag requires no rule using port 11000-11999.
        """
        return pulumi.get(self, "allow_sql_redirect")

    @allow_sql_redirect.setter
    def allow_sql_redirect(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_sql_redirect", value)


if not MYPY:
    class FirewallPolicyThreatIntelWhitelistArgsDict(TypedDict):
        """
        ThreatIntel Whitelist for Firewall Policy.
        """
        fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of FQDNs for the ThreatIntel Whitelist.
        """
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of IP addresses for the ThreatIntel Whitelist.
        """
elif False:
    FirewallPolicyThreatIntelWhitelistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPolicyThreatIntelWhitelistArgs:
    def __init__(__self__, *,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        ThreatIntel Whitelist for Firewall Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fqdns: List of FQDNs for the ThreatIntel Whitelist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_addresses: List of IP addresses for the ThreatIntel Whitelist.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of FQDNs for the ThreatIntel Whitelist.
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP addresses for the ThreatIntel Whitelist.
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class NatRuleArgsDict(TypedDict):
        """
        Rule of type nat.
        """
        rule_type: pulumi.Input[str]
        """
        Rule Type.
        Expected value is 'NatRule'.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the rule.
        """
        destination_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of destination IP addresses or Service Tags.
        """
        destination_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of destination ports.
        """
        ip_protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FirewallPolicyRuleNetworkProtocol']]]]]
        """
        Array of FirewallPolicyRuleNetworkProtocols.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the rule.
        """
        source_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of source IP addresses for this rule.
        """
        source_ip_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of source IpGroups for this rule.
        """
        translated_address: NotRequired[pulumi.Input[str]]
        """
        The translated address for this NAT rule.
        """
        translated_fqdn: NotRequired[pulumi.Input[str]]
        """
        The translated FQDN for this NAT rule.
        """
        translated_port: NotRequired[pulumi.Input[str]]
        """
        The translated port for this NAT rule.
        """
elif False:
    NatRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatRuleArgs:
    def __init__(__self__, *,
                 rule_type: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 destination_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_protocols: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FirewallPolicyRuleNetworkProtocol']]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 source_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_ip_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 translated_address: Optional[pulumi.Input[str]] = None,
                 translated_fqdn: Optional[pulumi.Input[str]] = None,
                 translated_port: Optional[pulumi.Input[str]] = None):
        """
        Rule of type nat.
        :param pulumi.Input[str] rule_type: Rule Type.
               Expected value is 'NatRule'.
        :param pulumi.Input[str] description: Description of the rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_addresses: List of destination IP addresses or Service Tags.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_ports: List of destination ports.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'FirewallPolicyRuleNetworkProtocol']]]] ip_protocols: Array of FirewallPolicyRuleNetworkProtocols.
        :param pulumi.Input[str] name: Name of the rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_addresses: List of source IP addresses for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_ip_groups: List of source IpGroups for this rule.
        :param pulumi.Input[str] translated_address: The translated address for this NAT rule.
        :param pulumi.Input[str] translated_fqdn: The translated FQDN for this NAT rule.
        :param pulumi.Input[str] translated_port: The translated port for this NAT rule.
        """
        pulumi.set(__self__, "rule_type", 'NatRule')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if ip_protocols is not None:
            pulumi.set(__self__, "ip_protocols", ip_protocols)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if translated_address is not None:
            pulumi.set(__self__, "translated_address", translated_address)
        if translated_fqdn is not None:
            pulumi.set(__self__, "translated_fqdn", translated_fqdn)
        if translated_port is not None:
            pulumi.set(__self__, "translated_port", translated_port)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[str]:
        """
        Rule Type.
        Expected value is 'NatRule'.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of destination IP addresses or Service Tags.
        """
        return pulumi.get(self, "destination_addresses")

    @destination_addresses.setter
    def destination_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_addresses", value)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_ports", value)

    @property
    @pulumi.getter(name="ipProtocols")
    def ip_protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FirewallPolicyRuleNetworkProtocol']]]]]:
        """
        Array of FirewallPolicyRuleNetworkProtocols.
        """
        return pulumi.get(self, "ip_protocols")

    @ip_protocols.setter
    def ip_protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FirewallPolicyRuleNetworkProtocol']]]]]):
        pulumi.set(self, "ip_protocols", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of source IP addresses for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @source_addresses.setter
    def source_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_addresses", value)

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")

    @source_ip_groups.setter
    def source_ip_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_ip_groups", value)

    @property
    @pulumi.getter(name="translatedAddress")
    def translated_address(self) -> Optional[pulumi.Input[str]]:
        """
        The translated address for this NAT rule.
        """
        return pulumi.get(self, "translated_address")

    @translated_address.setter
    def translated_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "translated_address", value)

    @property
    @pulumi.getter(name="translatedFqdn")
    def translated_fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        The translated FQDN for this NAT rule.
        """
        return pulumi.get(self, "translated_fqdn")

    @translated_fqdn.setter
    def translated_fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "translated_fqdn", value)

    @property
    @pulumi.getter(name="translatedPort")
    def translated_port(self) -> Optional[pulumi.Input[str]]:
        """
        The translated port for this NAT rule.
        """
        return pulumi.get(self, "translated_port")

    @translated_port.setter
    def translated_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "translated_port", value)


if not MYPY:
    class NetworkRuleArgsDict(TypedDict):
        """
        Rule of type network.
        """
        rule_type: pulumi.Input[str]
        """
        Rule Type.
        Expected value is 'NetworkRule'.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the rule.
        """
        destination_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of destination IP addresses or Service Tags.
        """
        destination_fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of destination FQDNs.
        """
        destination_ip_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of destination IpGroups for this rule.
        """
        destination_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of destination ports.
        """
        ip_protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FirewallPolicyRuleNetworkProtocol']]]]]
        """
        Array of FirewallPolicyRuleNetworkProtocols.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the rule.
        """
        source_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of source IP addresses for this rule.
        """
        source_ip_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of source IpGroups for this rule.
        """
elif False:
    NetworkRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkRuleArgs:
    def __init__(__self__, *,
                 rule_type: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 destination_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 destination_fqdns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 destination_ip_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_protocols: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FirewallPolicyRuleNetworkProtocol']]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 source_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_ip_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Rule of type network.
        :param pulumi.Input[str] rule_type: Rule Type.
               Expected value is 'NetworkRule'.
        :param pulumi.Input[str] description: Description of the rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_addresses: List of destination IP addresses or Service Tags.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_fqdns: List of destination FQDNs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_ip_groups: List of destination IpGroups for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_ports: List of destination ports.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'FirewallPolicyRuleNetworkProtocol']]]] ip_protocols: Array of FirewallPolicyRuleNetworkProtocols.
        :param pulumi.Input[str] name: Name of the rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_addresses: List of source IP addresses for this rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_ip_groups: List of source IpGroups for this rule.
        """
        pulumi.set(__self__, "rule_type", 'NetworkRule')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_fqdns is not None:
            pulumi.set(__self__, "destination_fqdns", destination_fqdns)
        if destination_ip_groups is not None:
            pulumi.set(__self__, "destination_ip_groups", destination_ip_groups)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if ip_protocols is not None:
            pulumi.set(__self__, "ip_protocols", ip_protocols)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[str]:
        """
        Rule Type.
        Expected value is 'NetworkRule'.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of destination IP addresses or Service Tags.
        """
        return pulumi.get(self, "destination_addresses")

    @destination_addresses.setter
    def destination_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_addresses", value)

    @property
    @pulumi.getter(name="destinationFqdns")
    def destination_fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of destination FQDNs.
        """
        return pulumi.get(self, "destination_fqdns")

    @destination_fqdns.setter
    def destination_fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_fqdns", value)

    @property
    @pulumi.getter(name="destinationIpGroups")
    def destination_ip_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of destination IpGroups for this rule.
        """
        return pulumi.get(self, "destination_ip_groups")

    @destination_ip_groups.setter
    def destination_ip_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_ip_groups", value)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_ports", value)

    @property
    @pulumi.getter(name="ipProtocols")
    def ip_protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FirewallPolicyRuleNetworkProtocol']]]]]:
        """
        Array of FirewallPolicyRuleNetworkProtocols.
        """
        return pulumi.get(self, "ip_protocols")

    @ip_protocols.setter
    def ip_protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'FirewallPolicyRuleNetworkProtocol']]]]]):
        pulumi.set(self, "ip_protocols", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of source IP addresses for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @source_addresses.setter
    def source_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_addresses", value)

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")

    @source_ip_groups.setter
    def source_ip_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_ip_groups", value)


if not MYPY:
    class SubResourceArgsDict(TypedDict):
        """
        Reference to another subresource.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Sub-resource ID. Both absolute resource ID and a relative resource ID are accepted.
        An absolute ID starts with /subscriptions/ and contains the entire ID of the parent resource and the ID of the sub-resource in the end.
        A relative ID replaces the ID of the parent resource with a token '$self', followed by the sub-resource ID itself.
        Example of a relative ID: $self/frontEndConfigurations/my-frontend.
        """
elif False:
    SubResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubResourceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Reference to another subresource.
        :param pulumi.Input[str] id: Sub-resource ID. Both absolute resource ID and a relative resource ID are accepted.
               An absolute ID starts with /subscriptions/ and contains the entire ID of the parent resource and the ID of the sub-resource in the end.
               A relative ID replaces the ID of the parent resource with a token '$self', followed by the sub-resource ID itself.
               Example of a relative ID: $self/frontEndConfigurations/my-frontend.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Sub-resource ID. Both absolute resource ID and a relative resource ID are accepted.
        An absolute ID starts with /subscriptions/ and contains the entire ID of the parent resource and the ID of the sub-resource in the end.
        A relative ID replaces the ID of the parent resource with a token '$self', followed by the sub-resource ID itself.
        Example of a relative ID: $self/frontEndConfigurations/my-frontend.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


