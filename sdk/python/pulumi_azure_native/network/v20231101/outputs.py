# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ApplicationRuleResponse',
    'DnsSettingsResponse',
    'ExplicitProxyResponse',
    'FirewallPolicyFilterRuleCollectionActionResponse',
    'FirewallPolicyFilterRuleCollectionResponse',
    'FirewallPolicyHttpHeaderToInsertResponse',
    'FirewallPolicyInsightsResponse',
    'FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse',
    'FirewallPolicyIntrusionDetectionConfigurationResponse',
    'FirewallPolicyIntrusionDetectionResponse',
    'FirewallPolicyIntrusionDetectionSignatureSpecificationResponse',
    'FirewallPolicyLogAnalyticsResourcesResponse',
    'FirewallPolicyLogAnalyticsWorkspaceResponse',
    'FirewallPolicyNatRuleCollectionActionResponse',
    'FirewallPolicyNatRuleCollectionResponse',
    'FirewallPolicyRuleApplicationProtocolResponse',
    'FirewallPolicySNATResponse',
    'FirewallPolicySQLResponse',
    'FirewallPolicyThreatIntelWhitelistResponse',
    'NatRuleResponse',
    'NetworkRuleResponse',
    'SubResourceResponse',
]

@pulumi.output_type
class ApplicationRuleResponse(dict):
    """
    Rule of type application.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "fqdnTags":
            suggest = "fqdn_tags"
        elif key == "httpHeadersToInsert":
            suggest = "http_headers_to_insert"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"
        elif key == "targetFqdns":
            suggest = "target_fqdns"
        elif key == "targetUrls":
            suggest = "target_urls"
        elif key == "terminateTLS":
            suggest = "terminate_tls"
        elif key == "webCategories":
            suggest = "web_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_type: str,
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 fqdn_tags: Optional[Sequence[str]] = None,
                 http_headers_to_insert: Optional[Sequence['outputs.FirewallPolicyHttpHeaderToInsertResponse']] = None,
                 name: Optional[str] = None,
                 protocols: Optional[Sequence['outputs.FirewallPolicyRuleApplicationProtocolResponse']] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None,
                 target_fqdns: Optional[Sequence[str]] = None,
                 target_urls: Optional[Sequence[str]] = None,
                 terminate_tls: Optional[bool] = None,
                 web_categories: Optional[Sequence[str]] = None):
        """
        Rule of type application.
        :param str rule_type: Rule Type.
               Expected value is 'ApplicationRule'.
        :param str description: Description of the rule.
        :param Sequence[str] destination_addresses: List of destination IP addresses or Service Tags.
        :param Sequence[str] fqdn_tags: List of FQDN Tags for this rule.
        :param Sequence['FirewallPolicyHttpHeaderToInsertResponse'] http_headers_to_insert: List of HTTP/S headers to insert.
        :param str name: Name of the rule.
        :param Sequence['FirewallPolicyRuleApplicationProtocolResponse'] protocols: Array of Application Protocols.
        :param Sequence[str] source_addresses: List of source IP addresses for this rule.
        :param Sequence[str] source_ip_groups: List of source IpGroups for this rule.
        :param Sequence[str] target_fqdns: List of FQDNs for this rule.
        :param Sequence[str] target_urls: List of Urls for this rule condition.
        :param bool terminate_tls: Terminate TLS connections for this rule.
        :param Sequence[str] web_categories: List of destination azure web categories.
        """
        pulumi.set(__self__, "rule_type", 'ApplicationRule')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if fqdn_tags is not None:
            pulumi.set(__self__, "fqdn_tags", fqdn_tags)
        if http_headers_to_insert is not None:
            pulumi.set(__self__, "http_headers_to_insert", http_headers_to_insert)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if target_fqdns is not None:
            pulumi.set(__self__, "target_fqdns", target_fqdns)
        if target_urls is not None:
            pulumi.set(__self__, "target_urls", target_urls)
        if terminate_tls is not None:
            pulumi.set(__self__, "terminate_tls", terminate_tls)
        if web_categories is not None:
            pulumi.set(__self__, "web_categories", web_categories)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        Rule Type.
        Expected value is 'ApplicationRule'.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        List of destination IP addresses or Service Tags.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="fqdnTags")
    def fqdn_tags(self) -> Optional[Sequence[str]]:
        """
        List of FQDN Tags for this rule.
        """
        return pulumi.get(self, "fqdn_tags")

    @property
    @pulumi.getter(name="httpHeadersToInsert")
    def http_headers_to_insert(self) -> Optional[Sequence['outputs.FirewallPolicyHttpHeaderToInsertResponse']]:
        """
        List of HTTP/S headers to insert.
        """
        return pulumi.get(self, "http_headers_to_insert")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence['outputs.FirewallPolicyRuleApplicationProtocolResponse']]:
        """
        Array of Application Protocols.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        List of source IP addresses for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")

    @property
    @pulumi.getter(name="targetFqdns")
    def target_fqdns(self) -> Optional[Sequence[str]]:
        """
        List of FQDNs for this rule.
        """
        return pulumi.get(self, "target_fqdns")

    @property
    @pulumi.getter(name="targetUrls")
    def target_urls(self) -> Optional[Sequence[str]]:
        """
        List of Urls for this rule condition.
        """
        return pulumi.get(self, "target_urls")

    @property
    @pulumi.getter(name="terminateTLS")
    def terminate_tls(self) -> Optional[bool]:
        """
        Terminate TLS connections for this rule.
        """
        return pulumi.get(self, "terminate_tls")

    @property
    @pulumi.getter(name="webCategories")
    def web_categories(self) -> Optional[Sequence[str]]:
        """
        List of destination azure web categories.
        """
        return pulumi.get(self, "web_categories")


@pulumi.output_type
class DnsSettingsResponse(dict):
    """
    DNS Proxy Settings in Firewall Policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableProxy":
            suggest = "enable_proxy"
        elif key == "requireProxyForNetworkRules":
            suggest = "require_proxy_for_network_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DnsSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DnsSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DnsSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_proxy: Optional[bool] = None,
                 require_proxy_for_network_rules: Optional[bool] = None,
                 servers: Optional[Sequence[str]] = None):
        """
        DNS Proxy Settings in Firewall Policy.
        :param bool enable_proxy: Enable DNS Proxy on Firewalls attached to the Firewall Policy.
        :param bool require_proxy_for_network_rules: FQDNs in Network Rules are supported when set to true.
        :param Sequence[str] servers: List of Custom DNS Servers.
        """
        if enable_proxy is not None:
            pulumi.set(__self__, "enable_proxy", enable_proxy)
        if require_proxy_for_network_rules is not None:
            pulumi.set(__self__, "require_proxy_for_network_rules", require_proxy_for_network_rules)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter(name="enableProxy")
    def enable_proxy(self) -> Optional[bool]:
        """
        Enable DNS Proxy on Firewalls attached to the Firewall Policy.
        """
        return pulumi.get(self, "enable_proxy")

    @property
    @pulumi.getter(name="requireProxyForNetworkRules")
    def require_proxy_for_network_rules(self) -> Optional[bool]:
        """
        FQDNs in Network Rules are supported when set to true.
        """
        return pulumi.get(self, "require_proxy_for_network_rules")

    @property
    @pulumi.getter
    def servers(self) -> Optional[Sequence[str]]:
        """
        List of Custom DNS Servers.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class ExplicitProxyResponse(dict):
    """
    Explicit Proxy Settings in Firewall Policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableExplicitProxy":
            suggest = "enable_explicit_proxy"
        elif key == "enablePacFile":
            suggest = "enable_pac_file"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "pacFile":
            suggest = "pac_file"
        elif key == "pacFilePort":
            suggest = "pac_file_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExplicitProxyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExplicitProxyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExplicitProxyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_explicit_proxy: Optional[bool] = None,
                 enable_pac_file: Optional[bool] = None,
                 http_port: Optional[int] = None,
                 https_port: Optional[int] = None,
                 pac_file: Optional[str] = None,
                 pac_file_port: Optional[int] = None):
        """
        Explicit Proxy Settings in Firewall Policy.
        :param bool enable_explicit_proxy: When set to true, explicit proxy mode is enabled.
        :param bool enable_pac_file: When set to true, pac file port and url needs to be provided.
        :param int http_port: Port number for explicit proxy http protocol, cannot be greater than 64000.
        :param int https_port: Port number for explicit proxy https protocol, cannot be greater than 64000.
        :param str pac_file: SAS URL for PAC file.
        :param int pac_file_port: Port number for firewall to serve PAC file.
        """
        if enable_explicit_proxy is not None:
            pulumi.set(__self__, "enable_explicit_proxy", enable_explicit_proxy)
        if enable_pac_file is not None:
            pulumi.set(__self__, "enable_pac_file", enable_pac_file)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if pac_file is not None:
            pulumi.set(__self__, "pac_file", pac_file)
        if pac_file_port is not None:
            pulumi.set(__self__, "pac_file_port", pac_file_port)

    @property
    @pulumi.getter(name="enableExplicitProxy")
    def enable_explicit_proxy(self) -> Optional[bool]:
        """
        When set to true, explicit proxy mode is enabled.
        """
        return pulumi.get(self, "enable_explicit_proxy")

    @property
    @pulumi.getter(name="enablePacFile")
    def enable_pac_file(self) -> Optional[bool]:
        """
        When set to true, pac file port and url needs to be provided.
        """
        return pulumi.get(self, "enable_pac_file")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        Port number for explicit proxy http protocol, cannot be greater than 64000.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[int]:
        """
        Port number for explicit proxy https protocol, cannot be greater than 64000.
        """
        return pulumi.get(self, "https_port")

    @property
    @pulumi.getter(name="pacFile")
    def pac_file(self) -> Optional[str]:
        """
        SAS URL for PAC file.
        """
        return pulumi.get(self, "pac_file")

    @property
    @pulumi.getter(name="pacFilePort")
    def pac_file_port(self) -> Optional[int]:
        """
        Port number for firewall to serve PAC file.
        """
        return pulumi.get(self, "pac_file_port")


@pulumi.output_type
class FirewallPolicyFilterRuleCollectionActionResponse(dict):
    """
    Properties of the FirewallPolicyFilterRuleCollectionAction.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        Properties of the FirewallPolicyFilterRuleCollectionAction.
        :param str type: The type of action.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of action.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FirewallPolicyFilterRuleCollectionResponse(dict):
    """
    Firewall Policy Filter Rule Collection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleCollectionType":
            suggest = "rule_collection_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyFilterRuleCollectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyFilterRuleCollectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyFilterRuleCollectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_collection_type: str,
                 action: Optional['outputs.FirewallPolicyFilterRuleCollectionActionResponse'] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 rules: Optional[Sequence[Any]] = None):
        """
        Firewall Policy Filter Rule Collection.
        :param str rule_collection_type: The type of the rule collection.
               Expected value is 'FirewallPolicyFilterRuleCollection'.
        :param 'FirewallPolicyFilterRuleCollectionActionResponse' action: The action type of a Filter rule collection.
        :param str name: The name of the rule collection.
        :param int priority: Priority of the Firewall Policy Rule Collection resource.
        :param Sequence[Union['ApplicationRuleResponse', 'NatRuleResponse', 'NetworkRuleResponse']] rules: List of rules included in a rule collection.
        """
        pulumi.set(__self__, "rule_collection_type", 'FirewallPolicyFilterRuleCollection')
        if action is not None:
            pulumi.set(__self__, "action", action)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="ruleCollectionType")
    def rule_collection_type(self) -> str:
        """
        The type of the rule collection.
        Expected value is 'FirewallPolicyFilterRuleCollection'.
        """
        return pulumi.get(self, "rule_collection_type")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.FirewallPolicyFilterRuleCollectionActionResponse']:
        """
        The action type of a Filter rule collection.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the rule collection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority of the Firewall Policy Rule Collection resource.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence[Any]]:
        """
        List of rules included in a rule collection.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class FirewallPolicyHttpHeaderToInsertResponse(dict):
    """
    name and value of HTTP/S header to insert
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyHttpHeaderToInsertResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyHttpHeaderToInsertResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyHttpHeaderToInsertResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: Optional[str] = None,
                 header_value: Optional[str] = None):
        """
        name and value of HTTP/S header to insert
        :param str header_name: Contains the name of the header
        :param str header_value: Contains the value of the header
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        Contains the name of the header
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[str]:
        """
        Contains the value of the header
        """
        return pulumi.get(self, "header_value")


@pulumi.output_type
class FirewallPolicyInsightsResponse(dict):
    """
    Firewall Policy Insights.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "logAnalyticsResources":
            suggest = "log_analytics_resources"
        elif key == "retentionDays":
            suggest = "retention_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyInsightsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyInsightsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyInsightsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: Optional[bool] = None,
                 log_analytics_resources: Optional['outputs.FirewallPolicyLogAnalyticsResourcesResponse'] = None,
                 retention_days: Optional[int] = None):
        """
        Firewall Policy Insights.
        :param bool is_enabled: A flag to indicate if the insights are enabled on the policy.
        :param 'FirewallPolicyLogAnalyticsResourcesResponse' log_analytics_resources: Workspaces needed to configure the Firewall Policy Insights.
        :param int retention_days: Number of days the insights should be enabled on the policy.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if log_analytics_resources is not None:
            pulumi.set(__self__, "log_analytics_resources", log_analytics_resources)
        if retention_days is not None:
            pulumi.set(__self__, "retention_days", retention_days)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        A flag to indicate if the insights are enabled on the policy.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="logAnalyticsResources")
    def log_analytics_resources(self) -> Optional['outputs.FirewallPolicyLogAnalyticsResourcesResponse']:
        """
        Workspaces needed to configure the Firewall Policy Insights.
        """
        return pulumi.get(self, "log_analytics_resources")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[int]:
        """
        Number of days the insights should be enabled on the policy.
        """
        return pulumi.get(self, "retention_days")


@pulumi.output_type
class FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse(dict):
    """
    Intrusion detection bypass traffic specification.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationIpGroups":
            suggest = "destination_ip_groups"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_ip_groups: Optional[Sequence[str]] = None,
                 destination_ports: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        Intrusion detection bypass traffic specification.
        :param str description: Description of the bypass traffic rule.
        :param Sequence[str] destination_addresses: List of destination IP addresses or ranges for this rule.
        :param Sequence[str] destination_ip_groups: List of destination IpGroups for this rule.
        :param Sequence[str] destination_ports: List of destination ports or ranges.
        :param str name: Name of the bypass traffic rule.
        :param str protocol: The rule bypass protocol.
        :param Sequence[str] source_addresses: List of source IP addresses or ranges for this rule.
        :param Sequence[str] source_ip_groups: List of source IpGroups for this rule.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_ip_groups is not None:
            pulumi.set(__self__, "destination_ip_groups", destination_ip_groups)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the bypass traffic rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        List of destination IP addresses or ranges for this rule.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationIpGroups")
    def destination_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of destination IpGroups for this rule.
        """
        return pulumi.get(self, "destination_ip_groups")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[str]]:
        """
        List of destination ports or ranges.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the bypass traffic rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The rule bypass protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        List of source IP addresses or ranges for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class FirewallPolicyIntrusionDetectionConfigurationResponse(dict):
    """
    The operation for configuring intrusion detection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bypassTrafficSettings":
            suggest = "bypass_traffic_settings"
        elif key == "privateRanges":
            suggest = "private_ranges"
        elif key == "signatureOverrides":
            suggest = "signature_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyIntrusionDetectionConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyIntrusionDetectionConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyIntrusionDetectionConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bypass_traffic_settings: Optional[Sequence['outputs.FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse']] = None,
                 private_ranges: Optional[Sequence[str]] = None,
                 signature_overrides: Optional[Sequence['outputs.FirewallPolicyIntrusionDetectionSignatureSpecificationResponse']] = None):
        """
        The operation for configuring intrusion detection.
        :param Sequence['FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse'] bypass_traffic_settings: List of rules for traffic to bypass.
        :param Sequence[str] private_ranges: IDPS Private IP address ranges are used to identify traffic direction (i.e. inbound, outbound, etc.). By default, only ranges defined by IANA RFC 1918 are considered private IP addresses. To modify default ranges, specify your Private IP address ranges with this property
        :param Sequence['FirewallPolicyIntrusionDetectionSignatureSpecificationResponse'] signature_overrides: List of specific signatures states.
        """
        if bypass_traffic_settings is not None:
            pulumi.set(__self__, "bypass_traffic_settings", bypass_traffic_settings)
        if private_ranges is not None:
            pulumi.set(__self__, "private_ranges", private_ranges)
        if signature_overrides is not None:
            pulumi.set(__self__, "signature_overrides", signature_overrides)

    @property
    @pulumi.getter(name="bypassTrafficSettings")
    def bypass_traffic_settings(self) -> Optional[Sequence['outputs.FirewallPolicyIntrusionDetectionBypassTrafficSpecificationsResponse']]:
        """
        List of rules for traffic to bypass.
        """
        return pulumi.get(self, "bypass_traffic_settings")

    @property
    @pulumi.getter(name="privateRanges")
    def private_ranges(self) -> Optional[Sequence[str]]:
        """
        IDPS Private IP address ranges are used to identify traffic direction (i.e. inbound, outbound, etc.). By default, only ranges defined by IANA RFC 1918 are considered private IP addresses. To modify default ranges, specify your Private IP address ranges with this property
        """
        return pulumi.get(self, "private_ranges")

    @property
    @pulumi.getter(name="signatureOverrides")
    def signature_overrides(self) -> Optional[Sequence['outputs.FirewallPolicyIntrusionDetectionSignatureSpecificationResponse']]:
        """
        List of specific signatures states.
        """
        return pulumi.get(self, "signature_overrides")


@pulumi.output_type
class FirewallPolicyIntrusionDetectionResponse(dict):
    """
    Configuration for intrusion detection mode and rules.
    """
    def __init__(__self__, *,
                 configuration: Optional['outputs.FirewallPolicyIntrusionDetectionConfigurationResponse'] = None,
                 mode: Optional[str] = None,
                 profile: Optional[str] = None):
        """
        Configuration for intrusion detection mode and rules.
        :param 'FirewallPolicyIntrusionDetectionConfigurationResponse' configuration: Intrusion detection configuration properties.
        :param str mode: Intrusion detection general state. When attached to a parent policy, the firewall's effective IDPS mode is the stricter mode of the two.
        :param str profile: IDPS profile name. When attached to a parent policy, the firewall's effective profile is the profile name of the parent policy.
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if profile is not None:
            pulumi.set(__self__, "profile", profile)

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.FirewallPolicyIntrusionDetectionConfigurationResponse']:
        """
        Intrusion detection configuration properties.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Intrusion detection general state. When attached to a parent policy, the firewall's effective IDPS mode is the stricter mode of the two.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def profile(self) -> Optional[str]:
        """
        IDPS profile name. When attached to a parent policy, the firewall's effective profile is the profile name of the parent policy.
        """
        return pulumi.get(self, "profile")


@pulumi.output_type
class FirewallPolicyIntrusionDetectionSignatureSpecificationResponse(dict):
    """
    Intrusion detection signatures specification states.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        Intrusion detection signatures specification states.
        :param str id: Signature id.
        :param str mode: The signature state.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Signature id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The signature state.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class FirewallPolicyLogAnalyticsResourcesResponse(dict):
    """
    Log Analytics Resources for Firewall Policy Insights.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultWorkspaceId":
            suggest = "default_workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyLogAnalyticsResourcesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyLogAnalyticsResourcesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyLogAnalyticsResourcesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_workspace_id: Optional['outputs.SubResourceResponse'] = None,
                 workspaces: Optional[Sequence['outputs.FirewallPolicyLogAnalyticsWorkspaceResponse']] = None):
        """
        Log Analytics Resources for Firewall Policy Insights.
        :param 'SubResourceResponse' default_workspace_id: The default workspace Id for Firewall Policy Insights.
        :param Sequence['FirewallPolicyLogAnalyticsWorkspaceResponse'] workspaces: List of workspaces for Firewall Policy Insights.
        """
        if default_workspace_id is not None:
            pulumi.set(__self__, "default_workspace_id", default_workspace_id)
        if workspaces is not None:
            pulumi.set(__self__, "workspaces", workspaces)

    @property
    @pulumi.getter(name="defaultWorkspaceId")
    def default_workspace_id(self) -> Optional['outputs.SubResourceResponse']:
        """
        The default workspace Id for Firewall Policy Insights.
        """
        return pulumi.get(self, "default_workspace_id")

    @property
    @pulumi.getter
    def workspaces(self) -> Optional[Sequence['outputs.FirewallPolicyLogAnalyticsWorkspaceResponse']]:
        """
        List of workspaces for Firewall Policy Insights.
        """
        return pulumi.get(self, "workspaces")


@pulumi.output_type
class FirewallPolicyLogAnalyticsWorkspaceResponse(dict):
    """
    Log Analytics Workspace for Firewall Policy Insights.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyLogAnalyticsWorkspaceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyLogAnalyticsWorkspaceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyLogAnalyticsWorkspaceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: Optional[str] = None,
                 workspace_id: Optional['outputs.SubResourceResponse'] = None):
        """
        Log Analytics Workspace for Firewall Policy Insights.
        :param str region: Region to configure the Workspace.
        :param 'SubResourceResponse' workspace_id: The workspace Id for Firewall Policy Insights.
        """
        if region is not None:
            pulumi.set(__self__, "region", region)
        if workspace_id is not None:
            pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region to configure the Workspace.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> Optional['outputs.SubResourceResponse']:
        """
        The workspace Id for Firewall Policy Insights.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class FirewallPolicyNatRuleCollectionActionResponse(dict):
    """
    Properties of the FirewallPolicyNatRuleCollectionAction.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        Properties of the FirewallPolicyNatRuleCollectionAction.
        :param str type: The type of action.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of action.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FirewallPolicyNatRuleCollectionResponse(dict):
    """
    Firewall Policy NAT Rule Collection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleCollectionType":
            suggest = "rule_collection_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyNatRuleCollectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyNatRuleCollectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyNatRuleCollectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_collection_type: str,
                 action: Optional['outputs.FirewallPolicyNatRuleCollectionActionResponse'] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 rules: Optional[Sequence[Any]] = None):
        """
        Firewall Policy NAT Rule Collection.
        :param str rule_collection_type: The type of the rule collection.
               Expected value is 'FirewallPolicyNatRuleCollection'.
        :param 'FirewallPolicyNatRuleCollectionActionResponse' action: The action type of a Nat rule collection.
        :param str name: The name of the rule collection.
        :param int priority: Priority of the Firewall Policy Rule Collection resource.
        :param Sequence[Union['ApplicationRuleResponse', 'NatRuleResponse', 'NetworkRuleResponse']] rules: List of rules included in a rule collection.
        """
        pulumi.set(__self__, "rule_collection_type", 'FirewallPolicyNatRuleCollection')
        if action is not None:
            pulumi.set(__self__, "action", action)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="ruleCollectionType")
    def rule_collection_type(self) -> str:
        """
        The type of the rule collection.
        Expected value is 'FirewallPolicyNatRuleCollection'.
        """
        return pulumi.get(self, "rule_collection_type")

    @property
    @pulumi.getter
    def action(self) -> Optional['outputs.FirewallPolicyNatRuleCollectionActionResponse']:
        """
        The action type of a Nat rule collection.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the rule collection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority of the Firewall Policy Rule Collection resource.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence[Any]]:
        """
        List of rules included in a rule collection.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class FirewallPolicyRuleApplicationProtocolResponse(dict):
    """
    Properties of the application rule protocol.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "protocolType":
            suggest = "protocol_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyRuleApplicationProtocolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyRuleApplicationProtocolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyRuleApplicationProtocolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: Optional[int] = None,
                 protocol_type: Optional[str] = None):
        """
        Properties of the application rule protocol.
        :param int port: Port number for the protocol, cannot be greater than 64000.
        :param str protocol_type: Protocol type.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol_type is not None:
            pulumi.set(__self__, "protocol_type", protocol_type)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port number for the protocol, cannot be greater than 64000.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> Optional[str]:
        """
        Protocol type.
        """
        return pulumi.get(self, "protocol_type")


@pulumi.output_type
class FirewallPolicySNATResponse(dict):
    """
    The private IP addresses/IP ranges to which traffic will not be SNAT.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoLearnPrivateRanges":
            suggest = "auto_learn_private_ranges"
        elif key == "privateRanges":
            suggest = "private_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicySNATResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicySNATResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicySNATResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_learn_private_ranges: Optional[str] = None,
                 private_ranges: Optional[Sequence[str]] = None):
        """
        The private IP addresses/IP ranges to which traffic will not be SNAT.
        :param str auto_learn_private_ranges: The operation mode for automatically learning private ranges to not be SNAT
        :param Sequence[str] private_ranges: List of private IP addresses/IP address ranges to not be SNAT.
        """
        if auto_learn_private_ranges is not None:
            pulumi.set(__self__, "auto_learn_private_ranges", auto_learn_private_ranges)
        if private_ranges is not None:
            pulumi.set(__self__, "private_ranges", private_ranges)

    @property
    @pulumi.getter(name="autoLearnPrivateRanges")
    def auto_learn_private_ranges(self) -> Optional[str]:
        """
        The operation mode for automatically learning private ranges to not be SNAT
        """
        return pulumi.get(self, "auto_learn_private_ranges")

    @property
    @pulumi.getter(name="privateRanges")
    def private_ranges(self) -> Optional[Sequence[str]]:
        """
        List of private IP addresses/IP address ranges to not be SNAT.
        """
        return pulumi.get(self, "private_ranges")


@pulumi.output_type
class FirewallPolicySQLResponse(dict):
    """
    SQL Settings in Firewall Policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSqlRedirect":
            suggest = "allow_sql_redirect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicySQLResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicySQLResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicySQLResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_sql_redirect: Optional[bool] = None):
        """
        SQL Settings in Firewall Policy.
        :param bool allow_sql_redirect: A flag to indicate if SQL Redirect traffic filtering is enabled. Turning on the flag requires no rule using port 11000-11999.
        """
        if allow_sql_redirect is not None:
            pulumi.set(__self__, "allow_sql_redirect", allow_sql_redirect)

    @property
    @pulumi.getter(name="allowSqlRedirect")
    def allow_sql_redirect(self) -> Optional[bool]:
        """
        A flag to indicate if SQL Redirect traffic filtering is enabled. Turning on the flag requires no rule using port 11000-11999.
        """
        return pulumi.get(self, "allow_sql_redirect")


@pulumi.output_type
class FirewallPolicyThreatIntelWhitelistResponse(dict):
    """
    ThreatIntel Whitelist for Firewall Policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPolicyThreatIntelWhitelistResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPolicyThreatIntelWhitelistResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPolicyThreatIntelWhitelistResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdns: Optional[Sequence[str]] = None,
                 ip_addresses: Optional[Sequence[str]] = None):
        """
        ThreatIntel Whitelist for Firewall Policy.
        :param Sequence[str] fqdns: List of FQDNs for the ThreatIntel Whitelist.
        :param Sequence[str] ip_addresses: List of IP addresses for the ThreatIntel Whitelist.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[Sequence[str]]:
        """
        List of FQDNs for the ThreatIntel Whitelist.
        """
        return pulumi.get(self, "fqdns")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        List of IP addresses for the ThreatIntel Whitelist.
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class NatRuleResponse(dict):
    """
    Rule of type nat.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "ipProtocols":
            suggest = "ip_protocols"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"
        elif key == "translatedAddress":
            suggest = "translated_address"
        elif key == "translatedFqdn":
            suggest = "translated_fqdn"
        elif key == "translatedPort":
            suggest = "translated_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NatRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NatRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NatRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_type: str,
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_ports: Optional[Sequence[str]] = None,
                 ip_protocols: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None,
                 translated_address: Optional[str] = None,
                 translated_fqdn: Optional[str] = None,
                 translated_port: Optional[str] = None):
        """
        Rule of type nat.
        :param str rule_type: Rule Type.
               Expected value is 'NatRule'.
        :param str description: Description of the rule.
        :param Sequence[str] destination_addresses: List of destination IP addresses or Service Tags.
        :param Sequence[str] destination_ports: List of destination ports.
        :param Sequence[str] ip_protocols: Array of FirewallPolicyRuleNetworkProtocols.
        :param str name: Name of the rule.
        :param Sequence[str] source_addresses: List of source IP addresses for this rule.
        :param Sequence[str] source_ip_groups: List of source IpGroups for this rule.
        :param str translated_address: The translated address for this NAT rule.
        :param str translated_fqdn: The translated FQDN for this NAT rule.
        :param str translated_port: The translated port for this NAT rule.
        """
        pulumi.set(__self__, "rule_type", 'NatRule')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if ip_protocols is not None:
            pulumi.set(__self__, "ip_protocols", ip_protocols)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)
        if translated_address is not None:
            pulumi.set(__self__, "translated_address", translated_address)
        if translated_fqdn is not None:
            pulumi.set(__self__, "translated_fqdn", translated_fqdn)
        if translated_port is not None:
            pulumi.set(__self__, "translated_port", translated_port)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        Rule Type.
        Expected value is 'NatRule'.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        List of destination IP addresses or Service Tags.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[str]]:
        """
        List of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter(name="ipProtocols")
    def ip_protocols(self) -> Optional[Sequence[str]]:
        """
        Array of FirewallPolicyRuleNetworkProtocols.
        """
        return pulumi.get(self, "ip_protocols")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        List of source IP addresses for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")

    @property
    @pulumi.getter(name="translatedAddress")
    def translated_address(self) -> Optional[str]:
        """
        The translated address for this NAT rule.
        """
        return pulumi.get(self, "translated_address")

    @property
    @pulumi.getter(name="translatedFqdn")
    def translated_fqdn(self) -> Optional[str]:
        """
        The translated FQDN for this NAT rule.
        """
        return pulumi.get(self, "translated_fqdn")

    @property
    @pulumi.getter(name="translatedPort")
    def translated_port(self) -> Optional[str]:
        """
        The translated port for this NAT rule.
        """
        return pulumi.get(self, "translated_port")


@pulumi.output_type
class NetworkRuleResponse(dict):
    """
    Rule of type network.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleType":
            suggest = "rule_type"
        elif key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationFqdns":
            suggest = "destination_fqdns"
        elif key == "destinationIpGroups":
            suggest = "destination_ip_groups"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "ipProtocols":
            suggest = "ip_protocols"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceIpGroups":
            suggest = "source_ip_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_type: str,
                 description: Optional[str] = None,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_fqdns: Optional[Sequence[str]] = None,
                 destination_ip_groups: Optional[Sequence[str]] = None,
                 destination_ports: Optional[Sequence[str]] = None,
                 ip_protocols: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ip_groups: Optional[Sequence[str]] = None):
        """
        Rule of type network.
        :param str rule_type: Rule Type.
               Expected value is 'NetworkRule'.
        :param str description: Description of the rule.
        :param Sequence[str] destination_addresses: List of destination IP addresses or Service Tags.
        :param Sequence[str] destination_fqdns: List of destination FQDNs.
        :param Sequence[str] destination_ip_groups: List of destination IpGroups for this rule.
        :param Sequence[str] destination_ports: List of destination ports.
        :param Sequence[str] ip_protocols: Array of FirewallPolicyRuleNetworkProtocols.
        :param str name: Name of the rule.
        :param Sequence[str] source_addresses: List of source IP addresses for this rule.
        :param Sequence[str] source_ip_groups: List of source IpGroups for this rule.
        """
        pulumi.set(__self__, "rule_type", 'NetworkRule')
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_fqdns is not None:
            pulumi.set(__self__, "destination_fqdns", destination_fqdns)
        if destination_ip_groups is not None:
            pulumi.set(__self__, "destination_ip_groups", destination_ip_groups)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if ip_protocols is not None:
            pulumi.set(__self__, "ip_protocols", ip_protocols)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ip_groups is not None:
            pulumi.set(__self__, "source_ip_groups", source_ip_groups)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> str:
        """
        Rule Type.
        Expected value is 'NetworkRule'.
        """
        return pulumi.get(self, "rule_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        List of destination IP addresses or Service Tags.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationFqdns")
    def destination_fqdns(self) -> Optional[Sequence[str]]:
        """
        List of destination FQDNs.
        """
        return pulumi.get(self, "destination_fqdns")

    @property
    @pulumi.getter(name="destinationIpGroups")
    def destination_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of destination IpGroups for this rule.
        """
        return pulumi.get(self, "destination_ip_groups")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[str]]:
        """
        List of destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter(name="ipProtocols")
    def ip_protocols(self) -> Optional[Sequence[str]]:
        """
        Array of FirewallPolicyRuleNetworkProtocols.
        """
        return pulumi.get(self, "ip_protocols")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        List of source IP addresses for this rule.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourceIpGroups")
    def source_ip_groups(self) -> Optional[Sequence[str]]:
        """
        List of source IpGroups for this rule.
        """
        return pulumi.get(self, "source_ip_groups")


@pulumi.output_type
class SubResourceResponse(dict):
    """
    Reference to another subresource.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Reference to another subresource.
        :param str id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")


