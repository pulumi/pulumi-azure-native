# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs

__all__ = [
    'GetPacketCaptureResult',
    'AwaitableGetPacketCaptureResult',
    'get_packet_capture',
    'get_packet_capture_output',
]

@pulumi.output_type
class GetPacketCaptureResult:
    """
    Information about packet capture session.
    """
    def __init__(__self__, bytes_to_capture_per_packet=None, etag=None, filters=None, id=None, name=None, provisioning_state=None, scope=None, storage_location=None, target=None, target_type=None, time_limit_in_seconds=None, total_bytes_per_session=None):
        if bytes_to_capture_per_packet and not isinstance(bytes_to_capture_per_packet, float):
            raise TypeError("Expected argument 'bytes_to_capture_per_packet' to be a float")
        pulumi.set(__self__, "bytes_to_capture_per_packet", bytes_to_capture_per_packet)
        if etag and not isinstance(etag, str):
            raise TypeError("Expected argument 'etag' to be a str")
        pulumi.set(__self__, "etag", etag)
        if filters and not isinstance(filters, list):
            raise TypeError("Expected argument 'filters' to be a list")
        pulumi.set(__self__, "filters", filters)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if provisioning_state and not isinstance(provisioning_state, str):
            raise TypeError("Expected argument 'provisioning_state' to be a str")
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if scope and not isinstance(scope, dict):
            raise TypeError("Expected argument 'scope' to be a dict")
        pulumi.set(__self__, "scope", scope)
        if storage_location and not isinstance(storage_location, dict):
            raise TypeError("Expected argument 'storage_location' to be a dict")
        pulumi.set(__self__, "storage_location", storage_location)
        if target and not isinstance(target, str):
            raise TypeError("Expected argument 'target' to be a str")
        pulumi.set(__self__, "target", target)
        if target_type and not isinstance(target_type, str):
            raise TypeError("Expected argument 'target_type' to be a str")
        pulumi.set(__self__, "target_type", target_type)
        if time_limit_in_seconds and not isinstance(time_limit_in_seconds, int):
            raise TypeError("Expected argument 'time_limit_in_seconds' to be a int")
        pulumi.set(__self__, "time_limit_in_seconds", time_limit_in_seconds)
        if total_bytes_per_session and not isinstance(total_bytes_per_session, float):
            raise TypeError("Expected argument 'total_bytes_per_session' to be a float")
        pulumi.set(__self__, "total_bytes_per_session", total_bytes_per_session)

    @property
    @pulumi.getter(name="bytesToCapturePerPacket")
    def bytes_to_capture_per_packet(self) -> Optional[float]:
        """
        Number of bytes captured per packet, the remaining bytes are truncated.
        """
        return pulumi.get(self, "bytes_to_capture_per_packet")

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.PacketCaptureFilterResponse']]:
        """
        A list of packet capture filters.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the packet capture operation.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the packet capture session.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the packet capture session.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.PacketCaptureMachineScopeResponse']:
        """
        A list of AzureVMSS instances which can be included or excluded to run packet capture. If both included and excluded are empty, then the packet capture will run on all instances of AzureVMSS.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="storageLocation")
    def storage_location(self) -> 'outputs.PacketCaptureStorageLocationResponse':
        """
        The storage location for a packet capture session.
        """
        return pulumi.get(self, "storage_location")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The ID of the targeted resource, only AzureVM and AzureVMSS as target type are currently supported.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[str]:
        """
        Target type of the resource provided.
        """
        return pulumi.get(self, "target_type")

    @property
    @pulumi.getter(name="timeLimitInSeconds")
    def time_limit_in_seconds(self) -> Optional[int]:
        """
        Maximum duration of the capture session in seconds.
        """
        return pulumi.get(self, "time_limit_in_seconds")

    @property
    @pulumi.getter(name="totalBytesPerSession")
    def total_bytes_per_session(self) -> Optional[float]:
        """
        Maximum size of the capture output.
        """
        return pulumi.get(self, "total_bytes_per_session")


class AwaitableGetPacketCaptureResult(GetPacketCaptureResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetPacketCaptureResult(
            bytes_to_capture_per_packet=self.bytes_to_capture_per_packet,
            etag=self.etag,
            filters=self.filters,
            id=self.id,
            name=self.name,
            provisioning_state=self.provisioning_state,
            scope=self.scope,
            storage_location=self.storage_location,
            target=self.target,
            target_type=self.target_type,
            time_limit_in_seconds=self.time_limit_in_seconds,
            total_bytes_per_session=self.total_bytes_per_session)


def get_packet_capture(network_watcher_name: Optional[str] = None,
                       packet_capture_name: Optional[str] = None,
                       resource_group_name: Optional[str] = None,
                       opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetPacketCaptureResult:
    """
    Gets a packet capture session by name.


    :param str network_watcher_name: The name of the network watcher.
    :param str packet_capture_name: The name of the packet capture session.
    :param str resource_group_name: The name of the resource group.
    """
    __args__ = dict()
    __args__['networkWatcherName'] = network_watcher_name
    __args__['packetCaptureName'] = packet_capture_name
    __args__['resourceGroupName'] = resource_group_name
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('azure-native:network/v20230601:getPacketCapture', __args__, opts=opts, typ=GetPacketCaptureResult).value

    return AwaitableGetPacketCaptureResult(
        bytes_to_capture_per_packet=pulumi.get(__ret__, 'bytes_to_capture_per_packet'),
        etag=pulumi.get(__ret__, 'etag'),
        filters=pulumi.get(__ret__, 'filters'),
        id=pulumi.get(__ret__, 'id'),
        name=pulumi.get(__ret__, 'name'),
        provisioning_state=pulumi.get(__ret__, 'provisioning_state'),
        scope=pulumi.get(__ret__, 'scope'),
        storage_location=pulumi.get(__ret__, 'storage_location'),
        target=pulumi.get(__ret__, 'target'),
        target_type=pulumi.get(__ret__, 'target_type'),
        time_limit_in_seconds=pulumi.get(__ret__, 'time_limit_in_seconds'),
        total_bytes_per_session=pulumi.get(__ret__, 'total_bytes_per_session'))


@_utilities.lift_output_func(get_packet_capture)
def get_packet_capture_output(network_watcher_name: Optional[pulumi.Input[str]] = None,
                              packet_capture_name: Optional[pulumi.Input[str]] = None,
                              resource_group_name: Optional[pulumi.Input[str]] = None,
                              opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetPacketCaptureResult]:
    """
    Gets a packet capture session by name.


    :param str network_watcher_name: The name of the network watcher.
    :param str packet_capture_name: The name of the packet capture session.
    :param str resource_group_name: The name of the resource group.
    """
    ...
