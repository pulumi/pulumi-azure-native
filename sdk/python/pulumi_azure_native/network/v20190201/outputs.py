# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ApplicationGatewayBackendAddressPoolResponse',
    'ApplicationGatewayBackendAddressResponse',
    'ApplicationSecurityGroupResponse',
    'BackendAddressPoolResponse',
    'DdosSettingsResponse',
    'DelegationResponse',
    'EndpointServiceResponse',
    'ExpressRouteCircuitConnectionResponse',
    'ExpressRouteCircuitPeeringConfigResponse',
    'ExpressRouteCircuitPeeringResponse',
    'ExpressRouteCircuitStatsResponse',
    'ExpressRouteConnectionIdResponse',
    'FrontendIPConfigurationResponse',
    'IPConfigurationProfileResponse',
    'IPConfigurationResponse',
    'InboundNatRuleResponse',
    'InterfaceEndpointResponse',
    'IpTagResponse',
    'Ipv6ExpressRouteCircuitPeeringConfigResponse',
    'NetworkInterfaceDnsSettingsResponse',
    'NetworkInterfaceIPConfigurationResponse',
    'NetworkInterfaceResponse',
    'NetworkInterfaceTapConfigurationResponse',
    'NetworkSecurityGroupResponse',
    'PeerExpressRouteCircuitConnectionResponse',
    'PublicIPAddressDnsSettingsResponse',
    'PublicIPAddressResponse',
    'PublicIPAddressSkuResponse',
    'ResourceNavigationLinkResponse',
    'RouteFilterResponse',
    'RouteFilterRuleResponse',
    'RouteResponse',
    'RouteTableResponse',
    'SecurityRuleResponse',
    'ServiceAssociationLinkResponse',
    'ServiceEndpointPolicyDefinitionResponse',
    'ServiceEndpointPolicyResponse',
    'ServiceEndpointPropertiesFormatResponse',
    'SubResourceResponse',
    'SubnetResponse',
    'VirtualNetworkTapResponse',
]

@pulumi.output_type
class ApplicationGatewayBackendAddressPoolResponse(dict):
    """
    Backend Address Pool of an application gateway.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendAddresses":
            suggest = "backend_addresses"
        elif key == "backendIPConfigurations":
            suggest = "backend_ip_configurations"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayBackendAddressPoolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayBackendAddressPoolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayBackendAddressPoolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_addresses: Optional[Sequence['outputs.ApplicationGatewayBackendAddressResponse']] = None,
                 backend_ip_configurations: Optional[Sequence['outputs.NetworkInterfaceIPConfigurationResponse']] = None,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 provisioning_state: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Backend Address Pool of an application gateway.
        :param Sequence['ApplicationGatewayBackendAddressResponse'] backend_addresses: Backend addresses
        :param Sequence['NetworkInterfaceIPConfigurationResponse'] backend_ip_configurations: Collection of references to IPs defined in network interfaces.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str name: Name of the backend address pool that is unique within an Application Gateway.
        :param str provisioning_state: Provisioning state of the backend address pool resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param str type: Type of the resource.
        """
        ApplicationGatewayBackendAddressPoolResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_addresses=backend_addresses,
            backend_ip_configurations=backend_ip_configurations,
            etag=etag,
            id=id,
            name=name,
            provisioning_state=provisioning_state,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_addresses: Optional[Sequence['outputs.ApplicationGatewayBackendAddressResponse']] = None,
             backend_ip_configurations: Optional[Sequence['outputs.NetworkInterfaceIPConfigurationResponse']] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backend_addresses is None and 'backendAddresses' in kwargs:
            backend_addresses = kwargs['backendAddresses']
        if backend_ip_configurations is None and 'backendIPConfigurations' in kwargs:
            backend_ip_configurations = kwargs['backendIPConfigurations']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']

        if backend_addresses is not None:
            _setter("backend_addresses", backend_addresses)
        if backend_ip_configurations is not None:
            _setter("backend_ip_configurations", backend_ip_configurations)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="backendAddresses")
    def backend_addresses(self) -> Optional[Sequence['outputs.ApplicationGatewayBackendAddressResponse']]:
        """
        Backend addresses
        """
        return pulumi.get(self, "backend_addresses")

    @property
    @pulumi.getter(name="backendIPConfigurations")
    def backend_ip_configurations(self) -> Optional[Sequence['outputs.NetworkInterfaceIPConfigurationResponse']]:
        """
        Collection of references to IPs defined in network interfaces.
        """
        return pulumi.get(self, "backend_ip_configurations")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the backend address pool that is unique within an Application Gateway.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        Provisioning state of the backend address pool resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the resource.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ApplicationGatewayBackendAddressResponse(dict):
    """
    Backend address of an application gateway.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGatewayBackendAddressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGatewayBackendAddressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGatewayBackendAddressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: Optional[str] = None,
                 ip_address: Optional[str] = None):
        """
        Backend address of an application gateway.
        :param str fqdn: Fully qualified domain name (FQDN).
        :param str ip_address: IP address
        """
        ApplicationGatewayBackendAddressResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fqdn=fqdn,
            ip_address=ip_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fqdn: Optional[str] = None,
             ip_address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_address is None and 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']

        if fqdn is not None:
            _setter("fqdn", fqdn)
        if ip_address is not None:
            _setter("ip_address", ip_address)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        Fully qualified domain name (FQDN).
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        IP address
        """
        return pulumi.get(self, "ip_address")


@pulumi.output_type
class ApplicationSecurityGroupResponse(dict):
    """
    An application security group in a resource group.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "resourceGuid":
            suggest = "resource_guid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationSecurityGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationSecurityGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationSecurityGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: str,
                 name: str,
                 provisioning_state: str,
                 resource_guid: str,
                 type: str,
                 id: Optional[str] = None,
                 location: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        An application security group in a resource group.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str name: Resource name.
        :param str provisioning_state: The provisioning state of the application security group resource. Possible values are: 'Succeeded', 'Updating', 'Deleting', and 'Failed'.
        :param str resource_guid: The resource GUID property of the application security group resource. It uniquely identifies a resource, even if the user changes its name or migrate the resource across subscriptions or resource groups.
        :param str type: Resource type.
        :param str id: Resource ID.
        :param str location: Resource location.
        :param Mapping[str, str] tags: Resource tags.
        """
        ApplicationSecurityGroupResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            etag=etag,
            name=name,
            provisioning_state=provisioning_state,
            resource_guid=resource_guid,
            type=type,
            id=id,
            location=location,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             etag: Optional[str] = None,
             name: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             resource_guid: Optional[str] = None,
             type: Optional[str] = None,
             id: Optional[str] = None,
             location: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if etag is None:
            raise TypeError("Missing 'etag' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if resource_guid is None and 'resourceGuid' in kwargs:
            resource_guid = kwargs['resourceGuid']
        if resource_guid is None:
            raise TypeError("Missing 'resource_guid' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("etag", etag)
        _setter("name", name)
        _setter("provisioning_state", provisioning_state)
        _setter("resource_guid", resource_guid)
        _setter("type", type)
        if id is not None:
            _setter("id", id)
        if location is not None:
            _setter("location", location)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the application security group resource. Possible values are: 'Succeeded', 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="resourceGuid")
    def resource_guid(self) -> str:
        """
        The resource GUID property of the application security group resource. It uniquely identifies a resource, even if the user changes its name or migrate the resource across subscriptions or resource groups.
        """
        return pulumi.get(self, "resource_guid")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Resource location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class BackendAddressPoolResponse(dict):
    """
    Pool of backend IP addresses.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendIPConfigurations":
            suggest = "backend_ip_configurations"
        elif key == "loadBalancingRules":
            suggest = "load_balancing_rules"
        elif key == "outboundRule":
            suggest = "outbound_rule"
        elif key == "outboundRules":
            suggest = "outbound_rules"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackendAddressPoolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackendAddressPoolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackendAddressPoolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_ip_configurations: Sequence['outputs.NetworkInterfaceIPConfigurationResponse'],
                 load_balancing_rules: Sequence['outputs.SubResourceResponse'],
                 outbound_rule: 'outputs.SubResourceResponse',
                 outbound_rules: Sequence['outputs.SubResourceResponse'],
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 provisioning_state: Optional[str] = None):
        """
        Pool of backend IP addresses.
        :param Sequence['NetworkInterfaceIPConfigurationResponse'] backend_ip_configurations: Gets collection of references to IP addresses defined in network interfaces.
        :param Sequence['SubResourceResponse'] load_balancing_rules: Gets load balancing rules that use this backend address pool.
        :param 'SubResourceResponse' outbound_rule: Gets outbound rules that use this backend address pool.
        :param Sequence['SubResourceResponse'] outbound_rules: Gets outbound rules that use this backend address pool.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str name: Gets name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param str provisioning_state: Get provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        BackendAddressPoolResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_ip_configurations=backend_ip_configurations,
            load_balancing_rules=load_balancing_rules,
            outbound_rule=outbound_rule,
            outbound_rules=outbound_rules,
            etag=etag,
            id=id,
            name=name,
            provisioning_state=provisioning_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_ip_configurations: Optional[Sequence['outputs.NetworkInterfaceIPConfigurationResponse']] = None,
             load_balancing_rules: Optional[Sequence['outputs.SubResourceResponse']] = None,
             outbound_rule: Optional['outputs.SubResourceResponse'] = None,
             outbound_rules: Optional[Sequence['outputs.SubResourceResponse']] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backend_ip_configurations is None and 'backendIPConfigurations' in kwargs:
            backend_ip_configurations = kwargs['backendIPConfigurations']
        if backend_ip_configurations is None:
            raise TypeError("Missing 'backend_ip_configurations' argument")
        if load_balancing_rules is None and 'loadBalancingRules' in kwargs:
            load_balancing_rules = kwargs['loadBalancingRules']
        if load_balancing_rules is None:
            raise TypeError("Missing 'load_balancing_rules' argument")
        if outbound_rule is None and 'outboundRule' in kwargs:
            outbound_rule = kwargs['outboundRule']
        if outbound_rule is None:
            raise TypeError("Missing 'outbound_rule' argument")
        if outbound_rules is None and 'outboundRules' in kwargs:
            outbound_rules = kwargs['outboundRules']
        if outbound_rules is None:
            raise TypeError("Missing 'outbound_rules' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']

        _setter("backend_ip_configurations", backend_ip_configurations)
        _setter("load_balancing_rules", load_balancing_rules)
        _setter("outbound_rule", outbound_rule)
        _setter("outbound_rules", outbound_rules)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="backendIPConfigurations")
    def backend_ip_configurations(self) -> Sequence['outputs.NetworkInterfaceIPConfigurationResponse']:
        """
        Gets collection of references to IP addresses defined in network interfaces.
        """
        return pulumi.get(self, "backend_ip_configurations")

    @property
    @pulumi.getter(name="loadBalancingRules")
    def load_balancing_rules(self) -> Sequence['outputs.SubResourceResponse']:
        """
        Gets load balancing rules that use this backend address pool.
        """
        return pulumi.get(self, "load_balancing_rules")

    @property
    @pulumi.getter(name="outboundRule")
    def outbound_rule(self) -> 'outputs.SubResourceResponse':
        """
        Gets outbound rules that use this backend address pool.
        """
        return pulumi.get(self, "outbound_rule")

    @property
    @pulumi.getter(name="outboundRules")
    def outbound_rules(self) -> Sequence['outputs.SubResourceResponse']:
        """
        Gets outbound rules that use this backend address pool.
        """
        return pulumi.get(self, "outbound_rules")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Gets name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        Get provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class DdosSettingsResponse(dict):
    """
    Contains the DDoS protection settings of the public IP.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ddosCustomPolicy":
            suggest = "ddos_custom_policy"
        elif key == "protectionCoverage":
            suggest = "protection_coverage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DdosSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DdosSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DdosSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ddos_custom_policy: Optional['outputs.SubResourceResponse'] = None,
                 protection_coverage: Optional[str] = None):
        """
        Contains the DDoS protection settings of the public IP.
        :param 'SubResourceResponse' ddos_custom_policy: The DDoS custom policy associated with the public IP.
        :param str protection_coverage: The DDoS protection policy customizability of the public IP. Only standard coverage will have the ability to be customized.
        """
        DdosSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ddos_custom_policy=ddos_custom_policy,
            protection_coverage=protection_coverage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ddos_custom_policy: Optional['outputs.SubResourceResponse'] = None,
             protection_coverage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ddos_custom_policy is None and 'ddosCustomPolicy' in kwargs:
            ddos_custom_policy = kwargs['ddosCustomPolicy']
        if protection_coverage is None and 'protectionCoverage' in kwargs:
            protection_coverage = kwargs['protectionCoverage']

        if ddos_custom_policy is not None:
            _setter("ddos_custom_policy", ddos_custom_policy)
        if protection_coverage is not None:
            _setter("protection_coverage", protection_coverage)

    @property
    @pulumi.getter(name="ddosCustomPolicy")
    def ddos_custom_policy(self) -> Optional['outputs.SubResourceResponse']:
        """
        The DDoS custom policy associated with the public IP.
        """
        return pulumi.get(self, "ddos_custom_policy")

    @property
    @pulumi.getter(name="protectionCoverage")
    def protection_coverage(self) -> Optional[str]:
        """
        The DDoS protection policy customizability of the public IP. Only standard coverage will have the ability to be customized.
        """
        return pulumi.get(self, "protection_coverage")


@pulumi.output_type
class DelegationResponse(dict):
    """
    Details the service to which the subnet is delegated.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DelegationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DelegationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DelegationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 actions: Optional[Sequence[str]] = None,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 service_name: Optional[str] = None):
        """
        Details the service to which the subnet is delegated.
        :param str provisioning_state: The provisioning state of the resource.
        :param Sequence[str] actions: Describes the actions permitted to the service upon delegation
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str name: The name of the resource that is unique within a subnet. This name can be used to access the resource.
        :param str service_name: The name of the service to whom the subnet should be delegated (e.g. Microsoft.Sql/servers)
        """
        DelegationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provisioning_state=provisioning_state,
            actions=actions,
            etag=etag,
            id=id,
            name=name,
            service_name=service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provisioning_state: Optional[str] = None,
             actions: Optional[Sequence[str]] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             service_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if service_name is None and 'serviceName' in kwargs:
            service_name = kwargs['serviceName']

        _setter("provisioning_state", provisioning_state)
        if actions is not None:
            _setter("actions", actions)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if service_name is not None:
            _setter("service_name", service_name)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def actions(self) -> Optional[Sequence[str]]:
        """
        Describes the actions permitted to the service upon delegation
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within a subnet. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        The name of the service to whom the subnet should be delegated (e.g. Microsoft.Sql/servers)
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class EndpointServiceResponse(dict):
    """
    Identifies the service being brought into the virtual network.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Identifies the service being brought into the virtual network.
        :param str id: A unique identifier of the service being referenced by the interface endpoint.
        """
        EndpointServiceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        A unique identifier of the service being referenced by the interface endpoint.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ExpressRouteCircuitConnectionResponse(dict):
    """
    Express Route Circuit Connection in an ExpressRouteCircuitPeering resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "circuitConnectionStatus":
            suggest = "circuit_connection_status"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "addressPrefix":
            suggest = "address_prefix"
        elif key == "authorizationKey":
            suggest = "authorization_key"
        elif key == "expressRouteCircuitPeering":
            suggest = "express_route_circuit_peering"
        elif key == "peerExpressRouteCircuitPeering":
            suggest = "peer_express_route_circuit_peering"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteCircuitConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteCircuitConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteCircuitConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 circuit_connection_status: str,
                 etag: str,
                 provisioning_state: str,
                 address_prefix: Optional[str] = None,
                 authorization_key: Optional[str] = None,
                 express_route_circuit_peering: Optional['outputs.SubResourceResponse'] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 peer_express_route_circuit_peering: Optional['outputs.SubResourceResponse'] = None):
        """
        Express Route Circuit Connection in an ExpressRouteCircuitPeering resource.
        :param str circuit_connection_status: Express Route Circuit connection state.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str provisioning_state: Provisioning state of the circuit connection resource. Possible values are: 'Succeeded', 'Updating', 'Deleting', and 'Failed'.
        :param str address_prefix: /29 IP address space to carve out Customer addresses for tunnels.
        :param str authorization_key: The authorization key.
        :param 'SubResourceResponse' express_route_circuit_peering: Reference to Express Route Circuit Private Peering Resource of the circuit initiating connection.
        :param str id: Resource ID.
        :param str name: Gets name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param 'SubResourceResponse' peer_express_route_circuit_peering: Reference to Express Route Circuit Private Peering Resource of the peered circuit.
        """
        ExpressRouteCircuitConnectionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            circuit_connection_status=circuit_connection_status,
            etag=etag,
            provisioning_state=provisioning_state,
            address_prefix=address_prefix,
            authorization_key=authorization_key,
            express_route_circuit_peering=express_route_circuit_peering,
            id=id,
            name=name,
            peer_express_route_circuit_peering=peer_express_route_circuit_peering,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             circuit_connection_status: Optional[str] = None,
             etag: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             address_prefix: Optional[str] = None,
             authorization_key: Optional[str] = None,
             express_route_circuit_peering: Optional['outputs.SubResourceResponse'] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             peer_express_route_circuit_peering: Optional['outputs.SubResourceResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if circuit_connection_status is None and 'circuitConnectionStatus' in kwargs:
            circuit_connection_status = kwargs['circuitConnectionStatus']
        if circuit_connection_status is None:
            raise TypeError("Missing 'circuit_connection_status' argument")
        if etag is None:
            raise TypeError("Missing 'etag' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if address_prefix is None and 'addressPrefix' in kwargs:
            address_prefix = kwargs['addressPrefix']
        if authorization_key is None and 'authorizationKey' in kwargs:
            authorization_key = kwargs['authorizationKey']
        if express_route_circuit_peering is None and 'expressRouteCircuitPeering' in kwargs:
            express_route_circuit_peering = kwargs['expressRouteCircuitPeering']
        if peer_express_route_circuit_peering is None and 'peerExpressRouteCircuitPeering' in kwargs:
            peer_express_route_circuit_peering = kwargs['peerExpressRouteCircuitPeering']

        _setter("circuit_connection_status", circuit_connection_status)
        _setter("etag", etag)
        _setter("provisioning_state", provisioning_state)
        if address_prefix is not None:
            _setter("address_prefix", address_prefix)
        if authorization_key is not None:
            _setter("authorization_key", authorization_key)
        if express_route_circuit_peering is not None:
            _setter("express_route_circuit_peering", express_route_circuit_peering)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if peer_express_route_circuit_peering is not None:
            _setter("peer_express_route_circuit_peering", peer_express_route_circuit_peering)

    @property
    @pulumi.getter(name="circuitConnectionStatus")
    def circuit_connection_status(self) -> str:
        """
        Express Route Circuit connection state.
        """
        return pulumi.get(self, "circuit_connection_status")

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state of the circuit connection resource. Possible values are: 'Succeeded', 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[str]:
        """
        /29 IP address space to carve out Customer addresses for tunnels.
        """
        return pulumi.get(self, "address_prefix")

    @property
    @pulumi.getter(name="authorizationKey")
    def authorization_key(self) -> Optional[str]:
        """
        The authorization key.
        """
        return pulumi.get(self, "authorization_key")

    @property
    @pulumi.getter(name="expressRouteCircuitPeering")
    def express_route_circuit_peering(self) -> Optional['outputs.SubResourceResponse']:
        """
        Reference to Express Route Circuit Private Peering Resource of the circuit initiating connection.
        """
        return pulumi.get(self, "express_route_circuit_peering")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Gets name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="peerExpressRouteCircuitPeering")
    def peer_express_route_circuit_peering(self) -> Optional['outputs.SubResourceResponse']:
        """
        Reference to Express Route Circuit Private Peering Resource of the peered circuit.
        """
        return pulumi.get(self, "peer_express_route_circuit_peering")


@pulumi.output_type
class ExpressRouteCircuitPeeringConfigResponse(dict):
    """
    Specifies the peering configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advertisedCommunities":
            suggest = "advertised_communities"
        elif key == "advertisedPublicPrefixes":
            suggest = "advertised_public_prefixes"
        elif key == "advertisedPublicPrefixesState":
            suggest = "advertised_public_prefixes_state"
        elif key == "customerASN":
            suggest = "customer_asn"
        elif key == "legacyMode":
            suggest = "legacy_mode"
        elif key == "routingRegistryName":
            suggest = "routing_registry_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteCircuitPeeringConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteCircuitPeeringConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteCircuitPeeringConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advertised_communities: Optional[Sequence[str]] = None,
                 advertised_public_prefixes: Optional[Sequence[str]] = None,
                 advertised_public_prefixes_state: Optional[str] = None,
                 customer_asn: Optional[int] = None,
                 legacy_mode: Optional[int] = None,
                 routing_registry_name: Optional[str] = None):
        """
        Specifies the peering configuration.
        :param Sequence[str] advertised_communities: The communities of bgp peering. Specified for microsoft peering
        :param Sequence[str] advertised_public_prefixes: The reference of AdvertisedPublicPrefixes.
        :param str advertised_public_prefixes_state: AdvertisedPublicPrefixState of the Peering resource. Possible values are 'NotConfigured', 'Configuring', 'Configured', and 'ValidationNeeded'.
        :param int customer_asn: The CustomerASN of the peering.
        :param int legacy_mode: The legacy mode of the peering.
        :param str routing_registry_name: The RoutingRegistryName of the configuration.
        """
        ExpressRouteCircuitPeeringConfigResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            advertised_communities=advertised_communities,
            advertised_public_prefixes=advertised_public_prefixes,
            advertised_public_prefixes_state=advertised_public_prefixes_state,
            customer_asn=customer_asn,
            legacy_mode=legacy_mode,
            routing_registry_name=routing_registry_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             advertised_communities: Optional[Sequence[str]] = None,
             advertised_public_prefixes: Optional[Sequence[str]] = None,
             advertised_public_prefixes_state: Optional[str] = None,
             customer_asn: Optional[int] = None,
             legacy_mode: Optional[int] = None,
             routing_registry_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if advertised_communities is None and 'advertisedCommunities' in kwargs:
            advertised_communities = kwargs['advertisedCommunities']
        if advertised_public_prefixes is None and 'advertisedPublicPrefixes' in kwargs:
            advertised_public_prefixes = kwargs['advertisedPublicPrefixes']
        if advertised_public_prefixes_state is None and 'advertisedPublicPrefixesState' in kwargs:
            advertised_public_prefixes_state = kwargs['advertisedPublicPrefixesState']
        if customer_asn is None and 'customerASN' in kwargs:
            customer_asn = kwargs['customerASN']
        if legacy_mode is None and 'legacyMode' in kwargs:
            legacy_mode = kwargs['legacyMode']
        if routing_registry_name is None and 'routingRegistryName' in kwargs:
            routing_registry_name = kwargs['routingRegistryName']

        if advertised_communities is not None:
            _setter("advertised_communities", advertised_communities)
        if advertised_public_prefixes is not None:
            _setter("advertised_public_prefixes", advertised_public_prefixes)
        if advertised_public_prefixes_state is not None:
            _setter("advertised_public_prefixes_state", advertised_public_prefixes_state)
        if customer_asn is not None:
            _setter("customer_asn", customer_asn)
        if legacy_mode is not None:
            _setter("legacy_mode", legacy_mode)
        if routing_registry_name is not None:
            _setter("routing_registry_name", routing_registry_name)

    @property
    @pulumi.getter(name="advertisedCommunities")
    def advertised_communities(self) -> Optional[Sequence[str]]:
        """
        The communities of bgp peering. Specified for microsoft peering
        """
        return pulumi.get(self, "advertised_communities")

    @property
    @pulumi.getter(name="advertisedPublicPrefixes")
    def advertised_public_prefixes(self) -> Optional[Sequence[str]]:
        """
        The reference of AdvertisedPublicPrefixes.
        """
        return pulumi.get(self, "advertised_public_prefixes")

    @property
    @pulumi.getter(name="advertisedPublicPrefixesState")
    def advertised_public_prefixes_state(self) -> Optional[str]:
        """
        AdvertisedPublicPrefixState of the Peering resource. Possible values are 'NotConfigured', 'Configuring', 'Configured', and 'ValidationNeeded'.
        """
        return pulumi.get(self, "advertised_public_prefixes_state")

    @property
    @pulumi.getter(name="customerASN")
    def customer_asn(self) -> Optional[int]:
        """
        The CustomerASN of the peering.
        """
        return pulumi.get(self, "customer_asn")

    @property
    @pulumi.getter(name="legacyMode")
    def legacy_mode(self) -> Optional[int]:
        """
        The legacy mode of the peering.
        """
        return pulumi.get(self, "legacy_mode")

    @property
    @pulumi.getter(name="routingRegistryName")
    def routing_registry_name(self) -> Optional[str]:
        """
        The RoutingRegistryName of the configuration.
        """
        return pulumi.get(self, "routing_registry_name")


@pulumi.output_type
class ExpressRouteCircuitPeeringResponse(dict):
    """
    Peering in an ExpressRouteCircuit resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peeredConnections":
            suggest = "peered_connections"
        elif key == "azureASN":
            suggest = "azure_asn"
        elif key == "expressRouteConnection":
            suggest = "express_route_connection"
        elif key == "gatewayManagerEtag":
            suggest = "gateway_manager_etag"
        elif key == "ipv6PeeringConfig":
            suggest = "ipv6_peering_config"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "microsoftPeeringConfig":
            suggest = "microsoft_peering_config"
        elif key == "peerASN":
            suggest = "peer_asn"
        elif key == "peeringType":
            suggest = "peering_type"
        elif key == "primaryAzurePort":
            suggest = "primary_azure_port"
        elif key == "primaryPeerAddressPrefix":
            suggest = "primary_peer_address_prefix"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "routeFilter":
            suggest = "route_filter"
        elif key == "secondaryAzurePort":
            suggest = "secondary_azure_port"
        elif key == "secondaryPeerAddressPrefix":
            suggest = "secondary_peer_address_prefix"
        elif key == "sharedKey":
            suggest = "shared_key"
        elif key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteCircuitPeeringResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteCircuitPeeringResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteCircuitPeeringResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: str,
                 peered_connections: Sequence['outputs.PeerExpressRouteCircuitConnectionResponse'],
                 azure_asn: Optional[int] = None,
                 connections: Optional[Sequence['outputs.ExpressRouteCircuitConnectionResponse']] = None,
                 express_route_connection: Optional['outputs.ExpressRouteConnectionIdResponse'] = None,
                 gateway_manager_etag: Optional[str] = None,
                 id: Optional[str] = None,
                 ipv6_peering_config: Optional['outputs.Ipv6ExpressRouteCircuitPeeringConfigResponse'] = None,
                 last_modified_by: Optional[str] = None,
                 microsoft_peering_config: Optional['outputs.ExpressRouteCircuitPeeringConfigResponse'] = None,
                 name: Optional[str] = None,
                 peer_asn: Optional[float] = None,
                 peering_type: Optional[str] = None,
                 primary_azure_port: Optional[str] = None,
                 primary_peer_address_prefix: Optional[str] = None,
                 provisioning_state: Optional[str] = None,
                 route_filter: Optional['outputs.RouteFilterResponse'] = None,
                 secondary_azure_port: Optional[str] = None,
                 secondary_peer_address_prefix: Optional[str] = None,
                 shared_key: Optional[str] = None,
                 state: Optional[str] = None,
                 stats: Optional['outputs.ExpressRouteCircuitStatsResponse'] = None,
                 vlan_id: Optional[int] = None):
        """
        Peering in an ExpressRouteCircuit resource.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param Sequence['PeerExpressRouteCircuitConnectionResponse'] peered_connections: The list of peered circuit connections associated with Azure Private Peering for this circuit.
        :param int azure_asn: The Azure ASN.
        :param Sequence['ExpressRouteCircuitConnectionResponse'] connections: The list of circuit connections associated with Azure Private Peering for this circuit.
        :param 'ExpressRouteConnectionIdResponse' express_route_connection: The ExpressRoute connection.
        :param str gateway_manager_etag: The GatewayManager Etag.
        :param str id: Resource ID.
        :param 'Ipv6ExpressRouteCircuitPeeringConfigResponse' ipv6_peering_config: The IPv6 peering configuration.
        :param str last_modified_by: Gets whether the provider or the customer last modified the peering.
        :param 'ExpressRouteCircuitPeeringConfigResponse' microsoft_peering_config: The Microsoft peering configuration.
        :param str name: Gets name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param float peer_asn: The peer ASN.
        :param str peering_type: The peering type.
        :param str primary_azure_port: The primary port.
        :param str primary_peer_address_prefix: The primary address prefix.
        :param str provisioning_state: Gets the provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param 'RouteFilterResponse' route_filter: The reference of the RouteFilter resource.
        :param str secondary_azure_port: The secondary port.
        :param str secondary_peer_address_prefix: The secondary address prefix.
        :param str shared_key: The shared key.
        :param str state: The peering state.
        :param 'ExpressRouteCircuitStatsResponse' stats: Gets peering stats.
        :param int vlan_id: The VLAN ID.
        """
        ExpressRouteCircuitPeeringResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            etag=etag,
            peered_connections=peered_connections,
            azure_asn=azure_asn,
            connections=connections,
            express_route_connection=express_route_connection,
            gateway_manager_etag=gateway_manager_etag,
            id=id,
            ipv6_peering_config=ipv6_peering_config,
            last_modified_by=last_modified_by,
            microsoft_peering_config=microsoft_peering_config,
            name=name,
            peer_asn=peer_asn,
            peering_type=peering_type,
            primary_azure_port=primary_azure_port,
            primary_peer_address_prefix=primary_peer_address_prefix,
            provisioning_state=provisioning_state,
            route_filter=route_filter,
            secondary_azure_port=secondary_azure_port,
            secondary_peer_address_prefix=secondary_peer_address_prefix,
            shared_key=shared_key,
            state=state,
            stats=stats,
            vlan_id=vlan_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             etag: Optional[str] = None,
             peered_connections: Optional[Sequence['outputs.PeerExpressRouteCircuitConnectionResponse']] = None,
             azure_asn: Optional[int] = None,
             connections: Optional[Sequence['outputs.ExpressRouteCircuitConnectionResponse']] = None,
             express_route_connection: Optional['outputs.ExpressRouteConnectionIdResponse'] = None,
             gateway_manager_etag: Optional[str] = None,
             id: Optional[str] = None,
             ipv6_peering_config: Optional['outputs.Ipv6ExpressRouteCircuitPeeringConfigResponse'] = None,
             last_modified_by: Optional[str] = None,
             microsoft_peering_config: Optional['outputs.ExpressRouteCircuitPeeringConfigResponse'] = None,
             name: Optional[str] = None,
             peer_asn: Optional[float] = None,
             peering_type: Optional[str] = None,
             primary_azure_port: Optional[str] = None,
             primary_peer_address_prefix: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             route_filter: Optional['outputs.RouteFilterResponse'] = None,
             secondary_azure_port: Optional[str] = None,
             secondary_peer_address_prefix: Optional[str] = None,
             shared_key: Optional[str] = None,
             state: Optional[str] = None,
             stats: Optional['outputs.ExpressRouteCircuitStatsResponse'] = None,
             vlan_id: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if etag is None:
            raise TypeError("Missing 'etag' argument")
        if peered_connections is None and 'peeredConnections' in kwargs:
            peered_connections = kwargs['peeredConnections']
        if peered_connections is None:
            raise TypeError("Missing 'peered_connections' argument")
        if azure_asn is None and 'azureASN' in kwargs:
            azure_asn = kwargs['azureASN']
        if express_route_connection is None and 'expressRouteConnection' in kwargs:
            express_route_connection = kwargs['expressRouteConnection']
        if gateway_manager_etag is None and 'gatewayManagerEtag' in kwargs:
            gateway_manager_etag = kwargs['gatewayManagerEtag']
        if ipv6_peering_config is None and 'ipv6PeeringConfig' in kwargs:
            ipv6_peering_config = kwargs['ipv6PeeringConfig']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if microsoft_peering_config is None and 'microsoftPeeringConfig' in kwargs:
            microsoft_peering_config = kwargs['microsoftPeeringConfig']
        if peer_asn is None and 'peerASN' in kwargs:
            peer_asn = kwargs['peerASN']
        if peering_type is None and 'peeringType' in kwargs:
            peering_type = kwargs['peeringType']
        if primary_azure_port is None and 'primaryAzurePort' in kwargs:
            primary_azure_port = kwargs['primaryAzurePort']
        if primary_peer_address_prefix is None and 'primaryPeerAddressPrefix' in kwargs:
            primary_peer_address_prefix = kwargs['primaryPeerAddressPrefix']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if route_filter is None and 'routeFilter' in kwargs:
            route_filter = kwargs['routeFilter']
        if secondary_azure_port is None and 'secondaryAzurePort' in kwargs:
            secondary_azure_port = kwargs['secondaryAzurePort']
        if secondary_peer_address_prefix is None and 'secondaryPeerAddressPrefix' in kwargs:
            secondary_peer_address_prefix = kwargs['secondaryPeerAddressPrefix']
        if shared_key is None and 'sharedKey' in kwargs:
            shared_key = kwargs['sharedKey']
        if vlan_id is None and 'vlanId' in kwargs:
            vlan_id = kwargs['vlanId']

        _setter("etag", etag)
        _setter("peered_connections", peered_connections)
        if azure_asn is not None:
            _setter("azure_asn", azure_asn)
        if connections is not None:
            _setter("connections", connections)
        if express_route_connection is not None:
            _setter("express_route_connection", express_route_connection)
        if gateway_manager_etag is not None:
            _setter("gateway_manager_etag", gateway_manager_etag)
        if id is not None:
            _setter("id", id)
        if ipv6_peering_config is not None:
            _setter("ipv6_peering_config", ipv6_peering_config)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if microsoft_peering_config is not None:
            _setter("microsoft_peering_config", microsoft_peering_config)
        if name is not None:
            _setter("name", name)
        if peer_asn is not None:
            _setter("peer_asn", peer_asn)
        if peering_type is not None:
            _setter("peering_type", peering_type)
        if primary_azure_port is not None:
            _setter("primary_azure_port", primary_azure_port)
        if primary_peer_address_prefix is not None:
            _setter("primary_peer_address_prefix", primary_peer_address_prefix)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if route_filter is not None:
            _setter("route_filter", route_filter)
        if secondary_azure_port is not None:
            _setter("secondary_azure_port", secondary_azure_port)
        if secondary_peer_address_prefix is not None:
            _setter("secondary_peer_address_prefix", secondary_peer_address_prefix)
        if shared_key is not None:
            _setter("shared_key", shared_key)
        if state is not None:
            _setter("state", state)
        if stats is not None:
            _setter("stats", stats)
        if vlan_id is not None:
            _setter("vlan_id", vlan_id)

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="peeredConnections")
    def peered_connections(self) -> Sequence['outputs.PeerExpressRouteCircuitConnectionResponse']:
        """
        The list of peered circuit connections associated with Azure Private Peering for this circuit.
        """
        return pulumi.get(self, "peered_connections")

    @property
    @pulumi.getter(name="azureASN")
    def azure_asn(self) -> Optional[int]:
        """
        The Azure ASN.
        """
        return pulumi.get(self, "azure_asn")

    @property
    @pulumi.getter
    def connections(self) -> Optional[Sequence['outputs.ExpressRouteCircuitConnectionResponse']]:
        """
        The list of circuit connections associated with Azure Private Peering for this circuit.
        """
        return pulumi.get(self, "connections")

    @property
    @pulumi.getter(name="expressRouteConnection")
    def express_route_connection(self) -> Optional['outputs.ExpressRouteConnectionIdResponse']:
        """
        The ExpressRoute connection.
        """
        return pulumi.get(self, "express_route_connection")

    @property
    @pulumi.getter(name="gatewayManagerEtag")
    def gateway_manager_etag(self) -> Optional[str]:
        """
        The GatewayManager Etag.
        """
        return pulumi.get(self, "gateway_manager_etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipv6PeeringConfig")
    def ipv6_peering_config(self) -> Optional['outputs.Ipv6ExpressRouteCircuitPeeringConfigResponse']:
        """
        The IPv6 peering configuration.
        """
        return pulumi.get(self, "ipv6_peering_config")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        Gets whether the provider or the customer last modified the peering.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="microsoftPeeringConfig")
    def microsoft_peering_config(self) -> Optional['outputs.ExpressRouteCircuitPeeringConfigResponse']:
        """
        The Microsoft peering configuration.
        """
        return pulumi.get(self, "microsoft_peering_config")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Gets name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="peerASN")
    def peer_asn(self) -> Optional[float]:
        """
        The peer ASN.
        """
        return pulumi.get(self, "peer_asn")

    @property
    @pulumi.getter(name="peeringType")
    def peering_type(self) -> Optional[str]:
        """
        The peering type.
        """
        return pulumi.get(self, "peering_type")

    @property
    @pulumi.getter(name="primaryAzurePort")
    def primary_azure_port(self) -> Optional[str]:
        """
        The primary port.
        """
        return pulumi.get(self, "primary_azure_port")

    @property
    @pulumi.getter(name="primaryPeerAddressPrefix")
    def primary_peer_address_prefix(self) -> Optional[str]:
        """
        The primary address prefix.
        """
        return pulumi.get(self, "primary_peer_address_prefix")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        Gets the provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="routeFilter")
    def route_filter(self) -> Optional['outputs.RouteFilterResponse']:
        """
        The reference of the RouteFilter resource.
        """
        return pulumi.get(self, "route_filter")

    @property
    @pulumi.getter(name="secondaryAzurePort")
    def secondary_azure_port(self) -> Optional[str]:
        """
        The secondary port.
        """
        return pulumi.get(self, "secondary_azure_port")

    @property
    @pulumi.getter(name="secondaryPeerAddressPrefix")
    def secondary_peer_address_prefix(self) -> Optional[str]:
        """
        The secondary address prefix.
        """
        return pulumi.get(self, "secondary_peer_address_prefix")

    @property
    @pulumi.getter(name="sharedKey")
    def shared_key(self) -> Optional[str]:
        """
        The shared key.
        """
        return pulumi.get(self, "shared_key")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The peering state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def stats(self) -> Optional['outputs.ExpressRouteCircuitStatsResponse']:
        """
        Gets peering stats.
        """
        return pulumi.get(self, "stats")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[int]:
        """
        The VLAN ID.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class ExpressRouteCircuitStatsResponse(dict):
    """
    Contains stats associated with the peering.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primarybytesIn":
            suggest = "primarybytes_in"
        elif key == "primarybytesOut":
            suggest = "primarybytes_out"
        elif key == "secondarybytesIn":
            suggest = "secondarybytes_in"
        elif key == "secondarybytesOut":
            suggest = "secondarybytes_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExpressRouteCircuitStatsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExpressRouteCircuitStatsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExpressRouteCircuitStatsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primarybytes_in: Optional[float] = None,
                 primarybytes_out: Optional[float] = None,
                 secondarybytes_in: Optional[float] = None,
                 secondarybytes_out: Optional[float] = None):
        """
        Contains stats associated with the peering.
        :param float primarybytes_in: Gets BytesIn of the peering.
        :param float primarybytes_out: Gets BytesOut of the peering.
        :param float secondarybytes_in: Gets BytesIn of the peering.
        :param float secondarybytes_out: Gets BytesOut of the peering.
        """
        ExpressRouteCircuitStatsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            primarybytes_in=primarybytes_in,
            primarybytes_out=primarybytes_out,
            secondarybytes_in=secondarybytes_in,
            secondarybytes_out=secondarybytes_out,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             primarybytes_in: Optional[float] = None,
             primarybytes_out: Optional[float] = None,
             secondarybytes_in: Optional[float] = None,
             secondarybytes_out: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if primarybytes_in is None and 'primarybytesIn' in kwargs:
            primarybytes_in = kwargs['primarybytesIn']
        if primarybytes_out is None and 'primarybytesOut' in kwargs:
            primarybytes_out = kwargs['primarybytesOut']
        if secondarybytes_in is None and 'secondarybytesIn' in kwargs:
            secondarybytes_in = kwargs['secondarybytesIn']
        if secondarybytes_out is None and 'secondarybytesOut' in kwargs:
            secondarybytes_out = kwargs['secondarybytesOut']

        if primarybytes_in is not None:
            _setter("primarybytes_in", primarybytes_in)
        if primarybytes_out is not None:
            _setter("primarybytes_out", primarybytes_out)
        if secondarybytes_in is not None:
            _setter("secondarybytes_in", secondarybytes_in)
        if secondarybytes_out is not None:
            _setter("secondarybytes_out", secondarybytes_out)

    @property
    @pulumi.getter(name="primarybytesIn")
    def primarybytes_in(self) -> Optional[float]:
        """
        Gets BytesIn of the peering.
        """
        return pulumi.get(self, "primarybytes_in")

    @property
    @pulumi.getter(name="primarybytesOut")
    def primarybytes_out(self) -> Optional[float]:
        """
        Gets BytesOut of the peering.
        """
        return pulumi.get(self, "primarybytes_out")

    @property
    @pulumi.getter(name="secondarybytesIn")
    def secondarybytes_in(self) -> Optional[float]:
        """
        Gets BytesIn of the peering.
        """
        return pulumi.get(self, "secondarybytes_in")

    @property
    @pulumi.getter(name="secondarybytesOut")
    def secondarybytes_out(self) -> Optional[float]:
        """
        Gets BytesOut of the peering.
        """
        return pulumi.get(self, "secondarybytes_out")


@pulumi.output_type
class ExpressRouteConnectionIdResponse(dict):
    """
    The ID of the ExpressRouteConnection.
    """
    def __init__(__self__, *,
                 id: str):
        """
        The ID of the ExpressRouteConnection.
        :param str id: The ID of the ExpressRouteConnection.
        """
        ExpressRouteConnectionIdResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")

        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the ExpressRouteConnection.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class FrontendIPConfigurationResponse(dict):
    """
    Frontend IP address of the load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inboundNatPools":
            suggest = "inbound_nat_pools"
        elif key == "inboundNatRules":
            suggest = "inbound_nat_rules"
        elif key == "loadBalancingRules":
            suggest = "load_balancing_rules"
        elif key == "outboundRules":
            suggest = "outbound_rules"
        elif key == "privateIPAddress":
            suggest = "private_ip_address"
        elif key == "privateIPAllocationMethod":
            suggest = "private_ip_allocation_method"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "publicIPAddress":
            suggest = "public_ip_address"
        elif key == "publicIPPrefix":
            suggest = "public_ip_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FrontendIPConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FrontendIPConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FrontendIPConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inbound_nat_pools: Sequence['outputs.SubResourceResponse'],
                 inbound_nat_rules: Sequence['outputs.SubResourceResponse'],
                 load_balancing_rules: Sequence['outputs.SubResourceResponse'],
                 outbound_rules: Sequence['outputs.SubResourceResponse'],
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_allocation_method: Optional[str] = None,
                 provisioning_state: Optional[str] = None,
                 public_ip_address: Optional['outputs.PublicIPAddressResponse'] = None,
                 public_ip_prefix: Optional['outputs.SubResourceResponse'] = None,
                 subnet: Optional['outputs.SubnetResponse'] = None,
                 zones: Optional[Sequence[str]] = None):
        """
        Frontend IP address of the load balancer.
        :param Sequence['SubResourceResponse'] inbound_nat_pools: Read only. Inbound pools URIs that use this frontend IP.
        :param Sequence['SubResourceResponse'] inbound_nat_rules: Read only. Inbound rules URIs that use this frontend IP.
        :param Sequence['SubResourceResponse'] load_balancing_rules: Gets load balancing rules URIs that use this frontend IP.
        :param Sequence['SubResourceResponse'] outbound_rules: Read only. Outbound rules URIs that use this frontend IP.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param str private_ip_address: The private IP address of the IP configuration.
        :param str private_ip_allocation_method: The Private IP allocation method.
        :param str provisioning_state: Gets the provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param 'PublicIPAddressResponse' public_ip_address: The reference of the Public IP resource.
        :param 'SubResourceResponse' public_ip_prefix: The reference of the Public IP Prefix resource.
        :param 'SubnetResponse' subnet: The reference of the subnet resource.
        :param Sequence[str] zones: A list of availability zones denoting the IP allocated for the resource needs to come from.
        """
        FrontendIPConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            inbound_nat_pools=inbound_nat_pools,
            inbound_nat_rules=inbound_nat_rules,
            load_balancing_rules=load_balancing_rules,
            outbound_rules=outbound_rules,
            etag=etag,
            id=id,
            name=name,
            private_ip_address=private_ip_address,
            private_ip_allocation_method=private_ip_allocation_method,
            provisioning_state=provisioning_state,
            public_ip_address=public_ip_address,
            public_ip_prefix=public_ip_prefix,
            subnet=subnet,
            zones=zones,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             inbound_nat_pools: Optional[Sequence['outputs.SubResourceResponse']] = None,
             inbound_nat_rules: Optional[Sequence['outputs.SubResourceResponse']] = None,
             load_balancing_rules: Optional[Sequence['outputs.SubResourceResponse']] = None,
             outbound_rules: Optional[Sequence['outputs.SubResourceResponse']] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             private_ip_address: Optional[str] = None,
             private_ip_allocation_method: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             public_ip_address: Optional['outputs.PublicIPAddressResponse'] = None,
             public_ip_prefix: Optional['outputs.SubResourceResponse'] = None,
             subnet: Optional['outputs.SubnetResponse'] = None,
             zones: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if inbound_nat_pools is None and 'inboundNatPools' in kwargs:
            inbound_nat_pools = kwargs['inboundNatPools']
        if inbound_nat_pools is None:
            raise TypeError("Missing 'inbound_nat_pools' argument")
        if inbound_nat_rules is None and 'inboundNatRules' in kwargs:
            inbound_nat_rules = kwargs['inboundNatRules']
        if inbound_nat_rules is None:
            raise TypeError("Missing 'inbound_nat_rules' argument")
        if load_balancing_rules is None and 'loadBalancingRules' in kwargs:
            load_balancing_rules = kwargs['loadBalancingRules']
        if load_balancing_rules is None:
            raise TypeError("Missing 'load_balancing_rules' argument")
        if outbound_rules is None and 'outboundRules' in kwargs:
            outbound_rules = kwargs['outboundRules']
        if outbound_rules is None:
            raise TypeError("Missing 'outbound_rules' argument")
        if private_ip_address is None and 'privateIPAddress' in kwargs:
            private_ip_address = kwargs['privateIPAddress']
        if private_ip_allocation_method is None and 'privateIPAllocationMethod' in kwargs:
            private_ip_allocation_method = kwargs['privateIPAllocationMethod']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if public_ip_address is None and 'publicIPAddress' in kwargs:
            public_ip_address = kwargs['publicIPAddress']
        if public_ip_prefix is None and 'publicIPPrefix' in kwargs:
            public_ip_prefix = kwargs['publicIPPrefix']

        _setter("inbound_nat_pools", inbound_nat_pools)
        _setter("inbound_nat_rules", inbound_nat_rules)
        _setter("load_balancing_rules", load_balancing_rules)
        _setter("outbound_rules", outbound_rules)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip_address is not None:
            _setter("private_ip_address", private_ip_address)
        if private_ip_allocation_method is not None:
            _setter("private_ip_allocation_method", private_ip_allocation_method)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if public_ip_address is not None:
            _setter("public_ip_address", public_ip_address)
        if public_ip_prefix is not None:
            _setter("public_ip_prefix", public_ip_prefix)
        if subnet is not None:
            _setter("subnet", subnet)
        if zones is not None:
            _setter("zones", zones)

    @property
    @pulumi.getter(name="inboundNatPools")
    def inbound_nat_pools(self) -> Sequence['outputs.SubResourceResponse']:
        """
        Read only. Inbound pools URIs that use this frontend IP.
        """
        return pulumi.get(self, "inbound_nat_pools")

    @property
    @pulumi.getter(name="inboundNatRules")
    def inbound_nat_rules(self) -> Sequence['outputs.SubResourceResponse']:
        """
        Read only. Inbound rules URIs that use this frontend IP.
        """
        return pulumi.get(self, "inbound_nat_rules")

    @property
    @pulumi.getter(name="loadBalancingRules")
    def load_balancing_rules(self) -> Sequence['outputs.SubResourceResponse']:
        """
        Gets load balancing rules URIs that use this frontend IP.
        """
        return pulumi.get(self, "load_balancing_rules")

    @property
    @pulumi.getter(name="outboundRules")
    def outbound_rules(self) -> Sequence['outputs.SubResourceResponse']:
        """
        Read only. Outbound rules URIs that use this frontend IP.
        """
        return pulumi.get(self, "outbound_rules")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private IP address of the IP configuration.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIPAllocationMethod")
    def private_ip_allocation_method(self) -> Optional[str]:
        """
        The Private IP allocation method.
        """
        return pulumi.get(self, "private_ip_allocation_method")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        Gets the provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="publicIPAddress")
    def public_ip_address(self) -> Optional['outputs.PublicIPAddressResponse']:
        """
        The reference of the Public IP resource.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="publicIPPrefix")
    def public_ip_prefix(self) -> Optional['outputs.SubResourceResponse']:
        """
        The reference of the Public IP Prefix resource.
        """
        return pulumi.get(self, "public_ip_prefix")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.SubnetResponse']:
        """
        The reference of the subnet resource.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[str]]:
        """
        A list of availability zones denoting the IP allocated for the resource needs to come from.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class IPConfigurationProfileResponse(dict):
    """
    IP configuration profile child resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IPConfigurationProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IPConfigurationProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IPConfigurationProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 type: str,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 subnet: Optional['outputs.SubnetResponse'] = None):
        """
        IP configuration profile child resource.
        :param str provisioning_state: The provisioning state of the resource.
        :param str type: Sub Resource type.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str name: The name of the resource. This name can be used to access the resource.
        :param 'SubnetResponse' subnet: The reference of the subnet resource to create a container network interface ip configuration.
        """
        IPConfigurationProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provisioning_state=provisioning_state,
            type=type,
            etag=etag,
            id=id,
            name=name,
            subnet=subnet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provisioning_state: Optional[str] = None,
             type: Optional[str] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             subnet: Optional['outputs.SubnetResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("provisioning_state", provisioning_state)
        _setter("type", type)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if subnet is not None:
            _setter("subnet", subnet)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Sub Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.SubnetResponse']:
        """
        The reference of the subnet resource to create a container network interface ip configuration.
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class IPConfigurationResponse(dict):
    """
    IP configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIPAddress":
            suggest = "private_ip_address"
        elif key == "privateIPAllocationMethod":
            suggest = "private_ip_allocation_method"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "publicIPAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IPConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IPConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IPConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_allocation_method: Optional[str] = None,
                 provisioning_state: Optional[str] = None,
                 public_ip_address: Optional['outputs.PublicIPAddressResponse'] = None,
                 subnet: Optional['outputs.SubnetResponse'] = None):
        """
        IP configuration
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param str private_ip_address: The private IP address of the IP configuration.
        :param str private_ip_allocation_method: The private IP address allocation method.
        :param str provisioning_state: Gets the provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param 'PublicIPAddressResponse' public_ip_address: The reference of the public IP resource.
        :param 'SubnetResponse' subnet: The reference of the subnet resource.
        """
        IPConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            etag=etag,
            id=id,
            name=name,
            private_ip_address=private_ip_address,
            private_ip_allocation_method=private_ip_allocation_method,
            provisioning_state=provisioning_state,
            public_ip_address=public_ip_address,
            subnet=subnet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             etag: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             private_ip_address: Optional[str] = None,
             private_ip_allocation_method: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             public_ip_address: Optional['outputs.PublicIPAddressResponse'] = None,
             subnet: Optional['outputs.SubnetResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_ip_address is None and 'privateIPAddress' in kwargs:
            private_ip_address = kwargs['privateIPAddress']
        if private_ip_allocation_method is None and 'privateIPAllocationMethod' in kwargs:
            private_ip_allocation_method = kwargs['privateIPAllocationMethod']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if public_ip_address is None and 'publicIPAddress' in kwargs:
            public_ip_address = kwargs['publicIPAddress']

        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if private_ip_address is not None:
            _setter("private_ip_address", private_ip_address)
        if private_ip_allocation_method is not None:
            _setter("private_ip_allocation_method", private_ip_allocation_method)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if public_ip_address is not None:
            _setter("public_ip_address", public_ip_address)
        if subnet is not None:
            _setter("subnet", subnet)

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private IP address of the IP configuration.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIPAllocationMethod")
    def private_ip_allocation_method(self) -> Optional[str]:
        """
        The private IP address allocation method.
        """
        return pulumi.get(self, "private_ip_allocation_method")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        Gets the provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="publicIPAddress")
    def public_ip_address(self) -> Optional['outputs.PublicIPAddressResponse']:
        """
        The reference of the public IP resource.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.SubnetResponse']:
        """
        The reference of the subnet resource.
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class InboundNatRuleResponse(dict):
    """
    Inbound NAT rule of the load balancer.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendIPConfiguration":
            suggest = "backend_ip_configuration"
        elif key == "backendPort":
            suggest = "backend_port"
        elif key == "enableFloatingIP":
            suggest = "enable_floating_ip"
        elif key == "enableTcpReset":
            suggest = "enable_tcp_reset"
        elif key == "frontendIPConfiguration":
            suggest = "frontend_ip_configuration"
        elif key == "frontendPort":
            suggest = "frontend_port"
        elif key == "idleTimeoutInMinutes":
            suggest = "idle_timeout_in_minutes"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InboundNatRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InboundNatRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InboundNatRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_ip_configuration: 'outputs.NetworkInterfaceIPConfigurationResponse',
                 backend_port: Optional[int] = None,
                 enable_floating_ip: Optional[bool] = None,
                 enable_tcp_reset: Optional[bool] = None,
                 etag: Optional[str] = None,
                 frontend_ip_configuration: Optional['outputs.SubResourceResponse'] = None,
                 frontend_port: Optional[int] = None,
                 id: Optional[str] = None,
                 idle_timeout_in_minutes: Optional[int] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None,
                 provisioning_state: Optional[str] = None):
        """
        Inbound NAT rule of the load balancer.
        :param 'NetworkInterfaceIPConfigurationResponse' backend_ip_configuration: A reference to a private IP address defined on a network interface of a VM. Traffic sent to the frontend port of each of the frontend IP configurations is forwarded to the backend IP.
        :param int backend_port: The port used for the internal endpoint. Acceptable values range from 1 to 65535.
        :param bool enable_floating_ip: Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server. This setting can't be changed after you create the endpoint.
        :param bool enable_tcp_reset: Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param 'SubResourceResponse' frontend_ip_configuration: A reference to frontend IP addresses.
        :param int frontend_port: The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values range from 1 to 65534.
        :param str id: Resource ID.
        :param int idle_timeout_in_minutes: The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The default value is 4 minutes. This element is only used when the protocol is set to TCP.
        :param str name: Gets name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param str protocol: The reference to the transport protocol used by the load balancing rule.
        :param str provisioning_state: Gets the provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        InboundNatRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_ip_configuration=backend_ip_configuration,
            backend_port=backend_port,
            enable_floating_ip=enable_floating_ip,
            enable_tcp_reset=enable_tcp_reset,
            etag=etag,
            frontend_ip_configuration=frontend_ip_configuration,
            frontend_port=frontend_port,
            id=id,
            idle_timeout_in_minutes=idle_timeout_in_minutes,
            name=name,
            protocol=protocol,
            provisioning_state=provisioning_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_ip_configuration: Optional['outputs.NetworkInterfaceIPConfigurationResponse'] = None,
             backend_port: Optional[int] = None,
             enable_floating_ip: Optional[bool] = None,
             enable_tcp_reset: Optional[bool] = None,
             etag: Optional[str] = None,
             frontend_ip_configuration: Optional['outputs.SubResourceResponse'] = None,
             frontend_port: Optional[int] = None,
             id: Optional[str] = None,
             idle_timeout_in_minutes: Optional[int] = None,
             name: Optional[str] = None,
             protocol: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backend_ip_configuration is None and 'backendIPConfiguration' in kwargs:
            backend_ip_configuration = kwargs['backendIPConfiguration']
        if backend_ip_configuration is None:
            raise TypeError("Missing 'backend_ip_configuration' argument")
        if backend_port is None and 'backendPort' in kwargs:
            backend_port = kwargs['backendPort']
        if enable_floating_ip is None and 'enableFloatingIP' in kwargs:
            enable_floating_ip = kwargs['enableFloatingIP']
        if enable_tcp_reset is None and 'enableTcpReset' in kwargs:
            enable_tcp_reset = kwargs['enableTcpReset']
        if frontend_ip_configuration is None and 'frontendIPConfiguration' in kwargs:
            frontend_ip_configuration = kwargs['frontendIPConfiguration']
        if frontend_port is None and 'frontendPort' in kwargs:
            frontend_port = kwargs['frontendPort']
        if idle_timeout_in_minutes is None and 'idleTimeoutInMinutes' in kwargs:
            idle_timeout_in_minutes = kwargs['idleTimeoutInMinutes']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']

        _setter("backend_ip_configuration", backend_ip_configuration)
        if backend_port is not None:
            _setter("backend_port", backend_port)
        if enable_floating_ip is not None:
            _setter("enable_floating_ip", enable_floating_ip)
        if enable_tcp_reset is not None:
            _setter("enable_tcp_reset", enable_tcp_reset)
        if etag is not None:
            _setter("etag", etag)
        if frontend_ip_configuration is not None:
            _setter("frontend_ip_configuration", frontend_ip_configuration)
        if frontend_port is not None:
            _setter("frontend_port", frontend_port)
        if id is not None:
            _setter("id", id)
        if idle_timeout_in_minutes is not None:
            _setter("idle_timeout_in_minutes", idle_timeout_in_minutes)
        if name is not None:
            _setter("name", name)
        if protocol is not None:
            _setter("protocol", protocol)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="backendIPConfiguration")
    def backend_ip_configuration(self) -> 'outputs.NetworkInterfaceIPConfigurationResponse':
        """
        A reference to a private IP address defined on a network interface of a VM. Traffic sent to the frontend port of each of the frontend IP configurations is forwarded to the backend IP.
        """
        return pulumi.get(self, "backend_ip_configuration")

    @property
    @pulumi.getter(name="backendPort")
    def backend_port(self) -> Optional[int]:
        """
        The port used for the internal endpoint. Acceptable values range from 1 to 65535.
        """
        return pulumi.get(self, "backend_port")

    @property
    @pulumi.getter(name="enableFloatingIP")
    def enable_floating_ip(self) -> Optional[bool]:
        """
        Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server. This setting can't be changed after you create the endpoint.
        """
        return pulumi.get(self, "enable_floating_ip")

    @property
    @pulumi.getter(name="enableTcpReset")
    def enable_tcp_reset(self) -> Optional[bool]:
        """
        Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
        """
        return pulumi.get(self, "enable_tcp_reset")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="frontendIPConfiguration")
    def frontend_ip_configuration(self) -> Optional['outputs.SubResourceResponse']:
        """
        A reference to frontend IP addresses.
        """
        return pulumi.get(self, "frontend_ip_configuration")

    @property
    @pulumi.getter(name="frontendPort")
    def frontend_port(self) -> Optional[int]:
        """
        The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values range from 1 to 65534.
        """
        return pulumi.get(self, "frontend_port")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[int]:
        """
        The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The default value is 4 minutes. This element is only used when the protocol is set to TCP.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Gets name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The reference to the transport protocol used by the load balancing rule.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        Gets the provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class InterfaceEndpointResponse(dict):
    """
    Interface endpoint resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "endpointService":
            suggest = "endpoint_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InterfaceEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InterfaceEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InterfaceEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 network_interfaces: Sequence['outputs.NetworkInterfaceResponse'],
                 owner: str,
                 provisioning_state: str,
                 type: str,
                 endpoint_service: Optional['outputs.EndpointServiceResponse'] = None,
                 etag: Optional[str] = None,
                 fqdn: Optional[str] = None,
                 id: Optional[str] = None,
                 location: Optional[str] = None,
                 subnet: Optional['outputs.SubnetResponse'] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Interface endpoint resource.
        :param str name: Resource name.
        :param Sequence['NetworkInterfaceResponse'] network_interfaces: Gets an array of references to the network interfaces created for this interface endpoint.
        :param str owner: A read-only property that identifies who created this interface endpoint.
        :param str provisioning_state: The provisioning state of the interface endpoint. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param str type: Resource type.
        :param 'EndpointServiceResponse' endpoint_service: A reference to the service being brought into the virtual network.
        :param str etag: Gets a unique read-only string that changes whenever the resource is updated.
        :param str fqdn: A first-party service's FQDN that is mapped to the private IP allocated via this interface endpoint.
        :param str id: Resource ID.
        :param str location: Resource location.
        :param 'SubnetResponse' subnet: The ID of the subnet from which the private IP will be allocated.
        :param Mapping[str, str] tags: Resource tags.
        """
        InterfaceEndpointResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            network_interfaces=network_interfaces,
            owner=owner,
            provisioning_state=provisioning_state,
            type=type,
            endpoint_service=endpoint_service,
            etag=etag,
            fqdn=fqdn,
            id=id,
            location=location,
            subnet=subnet,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             network_interfaces: Optional[Sequence['outputs.NetworkInterfaceResponse']] = None,
             owner: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             type: Optional[str] = None,
             endpoint_service: Optional['outputs.EndpointServiceResponse'] = None,
             etag: Optional[str] = None,
             fqdn: Optional[str] = None,
             id: Optional[str] = None,
             location: Optional[str] = None,
             subnet: Optional['outputs.SubnetResponse'] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if network_interfaces is None and 'networkInterfaces' in kwargs:
            network_interfaces = kwargs['networkInterfaces']
        if network_interfaces is None:
            raise TypeError("Missing 'network_interfaces' argument")
        if owner is None:
            raise TypeError("Missing 'owner' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if endpoint_service is None and 'endpointService' in kwargs:
            endpoint_service = kwargs['endpointService']

        _setter("name", name)
        _setter("network_interfaces", network_interfaces)
        _setter("owner", owner)
        _setter("provisioning_state", provisioning_state)
        _setter("type", type)
        if endpoint_service is not None:
            _setter("endpoint_service", endpoint_service)
        if etag is not None:
            _setter("etag", etag)
        if fqdn is not None:
            _setter("fqdn", fqdn)
        if id is not None:
            _setter("id", id)
        if location is not None:
            _setter("location", location)
        if subnet is not None:
            _setter("subnet", subnet)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.NetworkInterfaceResponse']:
        """
        Gets an array of references to the network interfaces created for this interface endpoint.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def owner(self) -> str:
        """
        A read-only property that identifies who created this interface endpoint.
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the interface endpoint. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="endpointService")
    def endpoint_service(self) -> Optional['outputs.EndpointServiceResponse']:
        """
        A reference to the service being brought into the virtual network.
        """
        return pulumi.get(self, "endpoint_service")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        Gets a unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        A first-party service's FQDN that is mapped to the private IP allocated via this interface endpoint.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Resource location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.SubnetResponse']:
        """
        The ID of the subnet from which the private IP will be allocated.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class IpTagResponse(dict):
    """
    Contains the IpTag associated with the object
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipTagType":
            suggest = "ip_tag_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpTagResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpTagResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpTagResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_tag_type: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        Contains the IpTag associated with the object
        :param str ip_tag_type: Gets or sets the ipTag type: Example FirstPartyUsage.
        :param str tag: Gets or sets value of the IpTag associated with the public IP. Example SQL, Storage etc
        """
        IpTagResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_tag_type=ip_tag_type,
            tag=tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_tag_type: Optional[str] = None,
             tag: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_tag_type is None and 'ipTagType' in kwargs:
            ip_tag_type = kwargs['ipTagType']

        if ip_tag_type is not None:
            _setter("ip_tag_type", ip_tag_type)
        if tag is not None:
            _setter("tag", tag)

    @property
    @pulumi.getter(name="ipTagType")
    def ip_tag_type(self) -> Optional[str]:
        """
        Gets or sets the ipTag type: Example FirstPartyUsage.
        """
        return pulumi.get(self, "ip_tag_type")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Gets or sets value of the IpTag associated with the public IP. Example SQL, Storage etc
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class Ipv6ExpressRouteCircuitPeeringConfigResponse(dict):
    """
    Contains IPv6 peering config.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "microsoftPeeringConfig":
            suggest = "microsoft_peering_config"
        elif key == "primaryPeerAddressPrefix":
            suggest = "primary_peer_address_prefix"
        elif key == "routeFilter":
            suggest = "route_filter"
        elif key == "secondaryPeerAddressPrefix":
            suggest = "secondary_peer_address_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ipv6ExpressRouteCircuitPeeringConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ipv6ExpressRouteCircuitPeeringConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ipv6ExpressRouteCircuitPeeringConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 microsoft_peering_config: Optional['outputs.ExpressRouteCircuitPeeringConfigResponse'] = None,
                 primary_peer_address_prefix: Optional[str] = None,
                 route_filter: Optional['outputs.RouteFilterResponse'] = None,
                 secondary_peer_address_prefix: Optional[str] = None,
                 state: Optional[str] = None):
        """
        Contains IPv6 peering config.
        :param 'ExpressRouteCircuitPeeringConfigResponse' microsoft_peering_config: The Microsoft peering configuration.
        :param str primary_peer_address_prefix: The primary address prefix.
        :param 'RouteFilterResponse' route_filter: The reference of the RouteFilter resource.
        :param str secondary_peer_address_prefix: The secondary address prefix.
        :param str state: The state of peering. Possible values are: 'Disabled' and 'Enabled'
        """
        Ipv6ExpressRouteCircuitPeeringConfigResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            microsoft_peering_config=microsoft_peering_config,
            primary_peer_address_prefix=primary_peer_address_prefix,
            route_filter=route_filter,
            secondary_peer_address_prefix=secondary_peer_address_prefix,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             microsoft_peering_config: Optional['outputs.ExpressRouteCircuitPeeringConfigResponse'] = None,
             primary_peer_address_prefix: Optional[str] = None,
             route_filter: Optional['outputs.RouteFilterResponse'] = None,
             secondary_peer_address_prefix: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if microsoft_peering_config is None and 'microsoftPeeringConfig' in kwargs:
            microsoft_peering_config = kwargs['microsoftPeeringConfig']
        if primary_peer_address_prefix is None and 'primaryPeerAddressPrefix' in kwargs:
            primary_peer_address_prefix = kwargs['primaryPeerAddressPrefix']
        if route_filter is None and 'routeFilter' in kwargs:
            route_filter = kwargs['routeFilter']
        if secondary_peer_address_prefix is None and 'secondaryPeerAddressPrefix' in kwargs:
            secondary_peer_address_prefix = kwargs['secondaryPeerAddressPrefix']

        if microsoft_peering_config is not None:
            _setter("microsoft_peering_config", microsoft_peering_config)
        if primary_peer_address_prefix is not None:
            _setter("primary_peer_address_prefix", primary_peer_address_prefix)
        if route_filter is not None:
            _setter("route_filter", route_filter)
        if secondary_peer_address_prefix is not None:
            _setter("secondary_peer_address_prefix", secondary_peer_address_prefix)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="microsoftPeeringConfig")
    def microsoft_peering_config(self) -> Optional['outputs.ExpressRouteCircuitPeeringConfigResponse']:
        """
        The Microsoft peering configuration.
        """
        return pulumi.get(self, "microsoft_peering_config")

    @property
    @pulumi.getter(name="primaryPeerAddressPrefix")
    def primary_peer_address_prefix(self) -> Optional[str]:
        """
        The primary address prefix.
        """
        return pulumi.get(self, "primary_peer_address_prefix")

    @property
    @pulumi.getter(name="routeFilter")
    def route_filter(self) -> Optional['outputs.RouteFilterResponse']:
        """
        The reference of the RouteFilter resource.
        """
        return pulumi.get(self, "route_filter")

    @property
    @pulumi.getter(name="secondaryPeerAddressPrefix")
    def secondary_peer_address_prefix(self) -> Optional[str]:
        """
        The secondary address prefix.
        """
        return pulumi.get(self, "secondary_peer_address_prefix")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The state of peering. Possible values are: 'Disabled' and 'Enabled'
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkInterfaceDnsSettingsResponse(dict):
    """
    DNS settings of a network interface.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliedDnsServers":
            suggest = "applied_dns_servers"
        elif key == "dnsServers":
            suggest = "dns_servers"
        elif key == "internalDnsNameLabel":
            suggest = "internal_dns_name_label"
        elif key == "internalDomainNameSuffix":
            suggest = "internal_domain_name_suffix"
        elif key == "internalFqdn":
            suggest = "internal_fqdn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceDnsSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceDnsSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceDnsSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applied_dns_servers: Optional[Sequence[str]] = None,
                 dns_servers: Optional[Sequence[str]] = None,
                 internal_dns_name_label: Optional[str] = None,
                 internal_domain_name_suffix: Optional[str] = None,
                 internal_fqdn: Optional[str] = None):
        """
        DNS settings of a network interface.
        :param Sequence[str] applied_dns_servers: If the VM that uses this NIC is part of an Availability Set, then this list will have the union of all DNS servers from all NICs that are part of the Availability Set. This property is what is configured on each of those VMs.
        :param Sequence[str] dns_servers: List of DNS servers IP addresses. Use 'AzureProvidedDNS' to switch to azure provided DNS resolution. 'AzureProvidedDNS' value cannot be combined with other IPs, it must be the only value in dnsServers collection.
        :param str internal_dns_name_label: Relative DNS name for this NIC used for internal communications between VMs in the same virtual network.
        :param str internal_domain_name_suffix: Even if internalDnsNameLabel is not specified, a DNS entry is created for the primary NIC of the VM. This DNS name can be constructed by concatenating the VM name with the value of internalDomainNameSuffix.
        :param str internal_fqdn: Fully qualified DNS name supporting internal communications between VMs in the same virtual network.
        """
        NetworkInterfaceDnsSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            applied_dns_servers=applied_dns_servers,
            dns_servers=dns_servers,
            internal_dns_name_label=internal_dns_name_label,
            internal_domain_name_suffix=internal_domain_name_suffix,
            internal_fqdn=internal_fqdn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             applied_dns_servers: Optional[Sequence[str]] = None,
             dns_servers: Optional[Sequence[str]] = None,
             internal_dns_name_label: Optional[str] = None,
             internal_domain_name_suffix: Optional[str] = None,
             internal_fqdn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if applied_dns_servers is None and 'appliedDnsServers' in kwargs:
            applied_dns_servers = kwargs['appliedDnsServers']
        if dns_servers is None and 'dnsServers' in kwargs:
            dns_servers = kwargs['dnsServers']
        if internal_dns_name_label is None and 'internalDnsNameLabel' in kwargs:
            internal_dns_name_label = kwargs['internalDnsNameLabel']
        if internal_domain_name_suffix is None and 'internalDomainNameSuffix' in kwargs:
            internal_domain_name_suffix = kwargs['internalDomainNameSuffix']
        if internal_fqdn is None and 'internalFqdn' in kwargs:
            internal_fqdn = kwargs['internalFqdn']

        if applied_dns_servers is not None:
            _setter("applied_dns_servers", applied_dns_servers)
        if dns_servers is not None:
            _setter("dns_servers", dns_servers)
        if internal_dns_name_label is not None:
            _setter("internal_dns_name_label", internal_dns_name_label)
        if internal_domain_name_suffix is not None:
            _setter("internal_domain_name_suffix", internal_domain_name_suffix)
        if internal_fqdn is not None:
            _setter("internal_fqdn", internal_fqdn)

    @property
    @pulumi.getter(name="appliedDnsServers")
    def applied_dns_servers(self) -> Optional[Sequence[str]]:
        """
        If the VM that uses this NIC is part of an Availability Set, then this list will have the union of all DNS servers from all NICs that are part of the Availability Set. This property is what is configured on each of those VMs.
        """
        return pulumi.get(self, "applied_dns_servers")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        """
        List of DNS servers IP addresses. Use 'AzureProvidedDNS' to switch to azure provided DNS resolution. 'AzureProvidedDNS' value cannot be combined with other IPs, it must be the only value in dnsServers collection.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="internalDnsNameLabel")
    def internal_dns_name_label(self) -> Optional[str]:
        """
        Relative DNS name for this NIC used for internal communications between VMs in the same virtual network.
        """
        return pulumi.get(self, "internal_dns_name_label")

    @property
    @pulumi.getter(name="internalDomainNameSuffix")
    def internal_domain_name_suffix(self) -> Optional[str]:
        """
        Even if internalDnsNameLabel is not specified, a DNS entry is created for the primary NIC of the VM. This DNS name can be constructed by concatenating the VM name with the value of internalDomainNameSuffix.
        """
        return pulumi.get(self, "internal_domain_name_suffix")

    @property
    @pulumi.getter(name="internalFqdn")
    def internal_fqdn(self) -> Optional[str]:
        """
        Fully qualified DNS name supporting internal communications between VMs in the same virtual network.
        """
        return pulumi.get(self, "internal_fqdn")


@pulumi.output_type
class NetworkInterfaceIPConfigurationResponse(dict):
    """
    IPConfiguration in a network interface.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationGatewayBackendAddressPools":
            suggest = "application_gateway_backend_address_pools"
        elif key == "applicationSecurityGroups":
            suggest = "application_security_groups"
        elif key == "loadBalancerBackendAddressPools":
            suggest = "load_balancer_backend_address_pools"
        elif key == "loadBalancerInboundNatRules":
            suggest = "load_balancer_inbound_nat_rules"
        elif key == "privateIPAddress":
            suggest = "private_ip_address"
        elif key == "privateIPAddressVersion":
            suggest = "private_ip_address_version"
        elif key == "privateIPAllocationMethod":
            suggest = "private_ip_allocation_method"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "publicIPAddress":
            suggest = "public_ip_address"
        elif key == "virtualNetworkTaps":
            suggest = "virtual_network_taps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceIPConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceIPConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceIPConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_gateway_backend_address_pools: Optional[Sequence['outputs.ApplicationGatewayBackendAddressPoolResponse']] = None,
                 application_security_groups: Optional[Sequence['outputs.ApplicationSecurityGroupResponse']] = None,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 load_balancer_backend_address_pools: Optional[Sequence['outputs.BackendAddressPoolResponse']] = None,
                 load_balancer_inbound_nat_rules: Optional[Sequence['outputs.InboundNatRuleResponse']] = None,
                 name: Optional[str] = None,
                 primary: Optional[bool] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_address_version: Optional[str] = None,
                 private_ip_allocation_method: Optional[str] = None,
                 provisioning_state: Optional[str] = None,
                 public_ip_address: Optional['outputs.PublicIPAddressResponse'] = None,
                 subnet: Optional['outputs.SubnetResponse'] = None,
                 virtual_network_taps: Optional[Sequence['outputs.VirtualNetworkTapResponse']] = None):
        """
        IPConfiguration in a network interface.
        :param Sequence['ApplicationGatewayBackendAddressPoolResponse'] application_gateway_backend_address_pools: The reference of ApplicationGatewayBackendAddressPool resource.
        :param Sequence['ApplicationSecurityGroupResponse'] application_security_groups: Application security groups in which the IP configuration is included.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param Sequence['BackendAddressPoolResponse'] load_balancer_backend_address_pools: The reference of LoadBalancerBackendAddressPool resource.
        :param Sequence['InboundNatRuleResponse'] load_balancer_inbound_nat_rules: A list of references of LoadBalancerInboundNatRules.
        :param str name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param bool primary: Gets whether this is a primary customer address on the network interface.
        :param str private_ip_address: Private IP address of the IP configuration.
        :param str private_ip_address_version: Available from Api-Version 2016-03-30 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.
        :param str private_ip_allocation_method: The private IP address allocation method.
        :param str provisioning_state: The provisioning state of the network interface IP configuration. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param 'PublicIPAddressResponse' public_ip_address: Public IP address bound to the IP configuration.
        :param 'SubnetResponse' subnet: Subnet bound to the IP configuration.
        :param Sequence['VirtualNetworkTapResponse'] virtual_network_taps: The reference to Virtual Network Taps.
        """
        NetworkInterfaceIPConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_gateway_backend_address_pools=application_gateway_backend_address_pools,
            application_security_groups=application_security_groups,
            etag=etag,
            id=id,
            load_balancer_backend_address_pools=load_balancer_backend_address_pools,
            load_balancer_inbound_nat_rules=load_balancer_inbound_nat_rules,
            name=name,
            primary=primary,
            private_ip_address=private_ip_address,
            private_ip_address_version=private_ip_address_version,
            private_ip_allocation_method=private_ip_allocation_method,
            provisioning_state=provisioning_state,
            public_ip_address=public_ip_address,
            subnet=subnet,
            virtual_network_taps=virtual_network_taps,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_gateway_backend_address_pools: Optional[Sequence['outputs.ApplicationGatewayBackendAddressPoolResponse']] = None,
             application_security_groups: Optional[Sequence['outputs.ApplicationSecurityGroupResponse']] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             load_balancer_backend_address_pools: Optional[Sequence['outputs.BackendAddressPoolResponse']] = None,
             load_balancer_inbound_nat_rules: Optional[Sequence['outputs.InboundNatRuleResponse']] = None,
             name: Optional[str] = None,
             primary: Optional[bool] = None,
             private_ip_address: Optional[str] = None,
             private_ip_address_version: Optional[str] = None,
             private_ip_allocation_method: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             public_ip_address: Optional['outputs.PublicIPAddressResponse'] = None,
             subnet: Optional['outputs.SubnetResponse'] = None,
             virtual_network_taps: Optional[Sequence['outputs.VirtualNetworkTapResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if application_gateway_backend_address_pools is None and 'applicationGatewayBackendAddressPools' in kwargs:
            application_gateway_backend_address_pools = kwargs['applicationGatewayBackendAddressPools']
        if application_security_groups is None and 'applicationSecurityGroups' in kwargs:
            application_security_groups = kwargs['applicationSecurityGroups']
        if load_balancer_backend_address_pools is None and 'loadBalancerBackendAddressPools' in kwargs:
            load_balancer_backend_address_pools = kwargs['loadBalancerBackendAddressPools']
        if load_balancer_inbound_nat_rules is None and 'loadBalancerInboundNatRules' in kwargs:
            load_balancer_inbound_nat_rules = kwargs['loadBalancerInboundNatRules']
        if private_ip_address is None and 'privateIPAddress' in kwargs:
            private_ip_address = kwargs['privateIPAddress']
        if private_ip_address_version is None and 'privateIPAddressVersion' in kwargs:
            private_ip_address_version = kwargs['privateIPAddressVersion']
        if private_ip_allocation_method is None and 'privateIPAllocationMethod' in kwargs:
            private_ip_allocation_method = kwargs['privateIPAllocationMethod']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if public_ip_address is None and 'publicIPAddress' in kwargs:
            public_ip_address = kwargs['publicIPAddress']
        if virtual_network_taps is None and 'virtualNetworkTaps' in kwargs:
            virtual_network_taps = kwargs['virtualNetworkTaps']

        if application_gateway_backend_address_pools is not None:
            _setter("application_gateway_backend_address_pools", application_gateway_backend_address_pools)
        if application_security_groups is not None:
            _setter("application_security_groups", application_security_groups)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if load_balancer_backend_address_pools is not None:
            _setter("load_balancer_backend_address_pools", load_balancer_backend_address_pools)
        if load_balancer_inbound_nat_rules is not None:
            _setter("load_balancer_inbound_nat_rules", load_balancer_inbound_nat_rules)
        if name is not None:
            _setter("name", name)
        if primary is not None:
            _setter("primary", primary)
        if private_ip_address is not None:
            _setter("private_ip_address", private_ip_address)
        if private_ip_address_version is not None:
            _setter("private_ip_address_version", private_ip_address_version)
        if private_ip_allocation_method is not None:
            _setter("private_ip_allocation_method", private_ip_allocation_method)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if public_ip_address is not None:
            _setter("public_ip_address", public_ip_address)
        if subnet is not None:
            _setter("subnet", subnet)
        if virtual_network_taps is not None:
            _setter("virtual_network_taps", virtual_network_taps)

    @property
    @pulumi.getter(name="applicationGatewayBackendAddressPools")
    def application_gateway_backend_address_pools(self) -> Optional[Sequence['outputs.ApplicationGatewayBackendAddressPoolResponse']]:
        """
        The reference of ApplicationGatewayBackendAddressPool resource.
        """
        return pulumi.get(self, "application_gateway_backend_address_pools")

    @property
    @pulumi.getter(name="applicationSecurityGroups")
    def application_security_groups(self) -> Optional[Sequence['outputs.ApplicationSecurityGroupResponse']]:
        """
        Application security groups in which the IP configuration is included.
        """
        return pulumi.get(self, "application_security_groups")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="loadBalancerBackendAddressPools")
    def load_balancer_backend_address_pools(self) -> Optional[Sequence['outputs.BackendAddressPoolResponse']]:
        """
        The reference of LoadBalancerBackendAddressPool resource.
        """
        return pulumi.get(self, "load_balancer_backend_address_pools")

    @property
    @pulumi.getter(name="loadBalancerInboundNatRules")
    def load_balancer_inbound_nat_rules(self) -> Optional[Sequence['outputs.InboundNatRuleResponse']]:
        """
        A list of references of LoadBalancerInboundNatRules.
        """
        return pulumi.get(self, "load_balancer_inbound_nat_rules")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Gets whether this is a primary customer address on the network interface.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        Private IP address of the IP configuration.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIPAddressVersion")
    def private_ip_address_version(self) -> Optional[str]:
        """
        Available from Api-Version 2016-03-30 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.
        """
        return pulumi.get(self, "private_ip_address_version")

    @property
    @pulumi.getter(name="privateIPAllocationMethod")
    def private_ip_allocation_method(self) -> Optional[str]:
        """
        The private IP address allocation method.
        """
        return pulumi.get(self, "private_ip_allocation_method")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state of the network interface IP configuration. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="publicIPAddress")
    def public_ip_address(self) -> Optional['outputs.PublicIPAddressResponse']:
        """
        Public IP address bound to the IP configuration.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.SubnetResponse']:
        """
        Subnet bound to the IP configuration.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="virtualNetworkTaps")
    def virtual_network_taps(self) -> Optional[Sequence['outputs.VirtualNetworkTapResponse']]:
        """
        The reference to Virtual Network Taps.
        """
        return pulumi.get(self, "virtual_network_taps")


@pulumi.output_type
class NetworkInterfaceResponse(dict):
    """
    A network interface in a resource group.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostedWorkloads":
            suggest = "hosted_workloads"
        elif key == "interfaceEndpoint":
            suggest = "interface_endpoint"
        elif key == "virtualMachine":
            suggest = "virtual_machine"
        elif key == "dnsSettings":
            suggest = "dns_settings"
        elif key == "enableAcceleratedNetworking":
            suggest = "enable_accelerated_networking"
        elif key == "enableIPForwarding":
            suggest = "enable_ip_forwarding"
        elif key == "ipConfigurations":
            suggest = "ip_configurations"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "networkSecurityGroup":
            suggest = "network_security_group"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "resourceGuid":
            suggest = "resource_guid"
        elif key == "tapConfigurations":
            suggest = "tap_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosted_workloads: Sequence[str],
                 interface_endpoint: 'outputs.InterfaceEndpointResponse',
                 name: str,
                 type: str,
                 virtual_machine: 'outputs.SubResourceResponse',
                 dns_settings: Optional['outputs.NetworkInterfaceDnsSettingsResponse'] = None,
                 enable_accelerated_networking: Optional[bool] = None,
                 enable_ip_forwarding: Optional[bool] = None,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 ip_configurations: Optional[Sequence['outputs.NetworkInterfaceIPConfigurationResponse']] = None,
                 location: Optional[str] = None,
                 mac_address: Optional[str] = None,
                 network_security_group: Optional['outputs.NetworkSecurityGroupResponse'] = None,
                 primary: Optional[bool] = None,
                 provisioning_state: Optional[str] = None,
                 resource_guid: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tap_configurations: Optional[Sequence['outputs.NetworkInterfaceTapConfigurationResponse']] = None):
        """
        A network interface in a resource group.
        :param Sequence[str] hosted_workloads: A list of references to linked BareMetal resources
        :param 'InterfaceEndpointResponse' interface_endpoint: A reference to the interface endpoint to which the network interface is linked.
        :param str name: Resource name.
        :param str type: Resource type.
        :param 'SubResourceResponse' virtual_machine: The reference of a virtual machine.
        :param 'NetworkInterfaceDnsSettingsResponse' dns_settings: The DNS settings in network interface.
        :param bool enable_accelerated_networking: If the network interface is accelerated networking enabled.
        :param bool enable_ip_forwarding: Indicates whether IP forwarding is enabled on this network interface.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param Sequence['NetworkInterfaceIPConfigurationResponse'] ip_configurations: A list of IPConfigurations of the network interface.
        :param str location: Resource location.
        :param str mac_address: The MAC address of the network interface.
        :param 'NetworkSecurityGroupResponse' network_security_group: The reference of the NetworkSecurityGroup resource.
        :param bool primary: Gets whether this is a primary network interface on a virtual machine.
        :param str provisioning_state: The provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param str resource_guid: The resource GUID property of the network interface resource.
        :param Mapping[str, str] tags: Resource tags.
        :param Sequence['NetworkInterfaceTapConfigurationResponse'] tap_configurations: A list of TapConfigurations of the network interface.
        """
        NetworkInterfaceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hosted_workloads=hosted_workloads,
            interface_endpoint=interface_endpoint,
            name=name,
            type=type,
            virtual_machine=virtual_machine,
            dns_settings=dns_settings,
            enable_accelerated_networking=enable_accelerated_networking,
            enable_ip_forwarding=enable_ip_forwarding,
            etag=etag,
            id=id,
            ip_configurations=ip_configurations,
            location=location,
            mac_address=mac_address,
            network_security_group=network_security_group,
            primary=primary,
            provisioning_state=provisioning_state,
            resource_guid=resource_guid,
            tags=tags,
            tap_configurations=tap_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hosted_workloads: Optional[Sequence[str]] = None,
             interface_endpoint: Optional['outputs.InterfaceEndpointResponse'] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             virtual_machine: Optional['outputs.SubResourceResponse'] = None,
             dns_settings: Optional['outputs.NetworkInterfaceDnsSettingsResponse'] = None,
             enable_accelerated_networking: Optional[bool] = None,
             enable_ip_forwarding: Optional[bool] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             ip_configurations: Optional[Sequence['outputs.NetworkInterfaceIPConfigurationResponse']] = None,
             location: Optional[str] = None,
             mac_address: Optional[str] = None,
             network_security_group: Optional['outputs.NetworkSecurityGroupResponse'] = None,
             primary: Optional[bool] = None,
             provisioning_state: Optional[str] = None,
             resource_guid: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             tap_configurations: Optional[Sequence['outputs.NetworkInterfaceTapConfigurationResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if hosted_workloads is None and 'hostedWorkloads' in kwargs:
            hosted_workloads = kwargs['hostedWorkloads']
        if hosted_workloads is None:
            raise TypeError("Missing 'hosted_workloads' argument")
        if interface_endpoint is None and 'interfaceEndpoint' in kwargs:
            interface_endpoint = kwargs['interfaceEndpoint']
        if interface_endpoint is None:
            raise TypeError("Missing 'interface_endpoint' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if virtual_machine is None and 'virtualMachine' in kwargs:
            virtual_machine = kwargs['virtualMachine']
        if virtual_machine is None:
            raise TypeError("Missing 'virtual_machine' argument")
        if dns_settings is None and 'dnsSettings' in kwargs:
            dns_settings = kwargs['dnsSettings']
        if enable_accelerated_networking is None and 'enableAcceleratedNetworking' in kwargs:
            enable_accelerated_networking = kwargs['enableAcceleratedNetworking']
        if enable_ip_forwarding is None and 'enableIPForwarding' in kwargs:
            enable_ip_forwarding = kwargs['enableIPForwarding']
        if ip_configurations is None and 'ipConfigurations' in kwargs:
            ip_configurations = kwargs['ipConfigurations']
        if mac_address is None and 'macAddress' in kwargs:
            mac_address = kwargs['macAddress']
        if network_security_group is None and 'networkSecurityGroup' in kwargs:
            network_security_group = kwargs['networkSecurityGroup']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if resource_guid is None and 'resourceGuid' in kwargs:
            resource_guid = kwargs['resourceGuid']
        if tap_configurations is None and 'tapConfigurations' in kwargs:
            tap_configurations = kwargs['tapConfigurations']

        _setter("hosted_workloads", hosted_workloads)
        _setter("interface_endpoint", interface_endpoint)
        _setter("name", name)
        _setter("type", type)
        _setter("virtual_machine", virtual_machine)
        if dns_settings is not None:
            _setter("dns_settings", dns_settings)
        if enable_accelerated_networking is not None:
            _setter("enable_accelerated_networking", enable_accelerated_networking)
        if enable_ip_forwarding is not None:
            _setter("enable_ip_forwarding", enable_ip_forwarding)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if ip_configurations is not None:
            _setter("ip_configurations", ip_configurations)
        if location is not None:
            _setter("location", location)
        if mac_address is not None:
            _setter("mac_address", mac_address)
        if network_security_group is not None:
            _setter("network_security_group", network_security_group)
        if primary is not None:
            _setter("primary", primary)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if resource_guid is not None:
            _setter("resource_guid", resource_guid)
        if tags is not None:
            _setter("tags", tags)
        if tap_configurations is not None:
            _setter("tap_configurations", tap_configurations)

    @property
    @pulumi.getter(name="hostedWorkloads")
    def hosted_workloads(self) -> Sequence[str]:
        """
        A list of references to linked BareMetal resources
        """
        return pulumi.get(self, "hosted_workloads")

    @property
    @pulumi.getter(name="interfaceEndpoint")
    def interface_endpoint(self) -> 'outputs.InterfaceEndpointResponse':
        """
        A reference to the interface endpoint to which the network interface is linked.
        """
        return pulumi.get(self, "interface_endpoint")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="virtualMachine")
    def virtual_machine(self) -> 'outputs.SubResourceResponse':
        """
        The reference of a virtual machine.
        """
        return pulumi.get(self, "virtual_machine")

    @property
    @pulumi.getter(name="dnsSettings")
    def dns_settings(self) -> Optional['outputs.NetworkInterfaceDnsSettingsResponse']:
        """
        The DNS settings in network interface.
        """
        return pulumi.get(self, "dns_settings")

    @property
    @pulumi.getter(name="enableAcceleratedNetworking")
    def enable_accelerated_networking(self) -> Optional[bool]:
        """
        If the network interface is accelerated networking enabled.
        """
        return pulumi.get(self, "enable_accelerated_networking")

    @property
    @pulumi.getter(name="enableIPForwarding")
    def enable_ip_forwarding(self) -> Optional[bool]:
        """
        Indicates whether IP forwarding is enabled on this network interface.
        """
        return pulumi.get(self, "enable_ip_forwarding")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> Optional[Sequence['outputs.NetworkInterfaceIPConfigurationResponse']]:
        """
        A list of IPConfigurations of the network interface.
        """
        return pulumi.get(self, "ip_configurations")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Resource location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        """
        The MAC address of the network interface.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter(name="networkSecurityGroup")
    def network_security_group(self) -> Optional['outputs.NetworkSecurityGroupResponse']:
        """
        The reference of the NetworkSecurityGroup resource.
        """
        return pulumi.get(self, "network_security_group")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Gets whether this is a primary network interface on a virtual machine.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="resourceGuid")
    def resource_guid(self) -> Optional[str]:
        """
        The resource GUID property of the network interface resource.
        """
        return pulumi.get(self, "resource_guid")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tapConfigurations")
    def tap_configurations(self) -> Optional[Sequence['outputs.NetworkInterfaceTapConfigurationResponse']]:
        """
        A list of TapConfigurations of the network interface.
        """
        return pulumi.get(self, "tap_configurations")


@pulumi.output_type
class NetworkInterfaceTapConfigurationResponse(dict):
    """
    Tap configuration in a Network Interface
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "virtualNetworkTap":
            suggest = "virtual_network_tap"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceTapConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceTapConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceTapConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 type: str,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 virtual_network_tap: Optional['outputs.VirtualNetworkTapResponse'] = None):
        """
        Tap configuration in a Network Interface
        :param str provisioning_state: The provisioning state of the network interface tap configuration. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param str type: Sub Resource type.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param 'VirtualNetworkTapResponse' virtual_network_tap: The reference of the Virtual Network Tap resource.
        """
        NetworkInterfaceTapConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provisioning_state=provisioning_state,
            type=type,
            etag=etag,
            id=id,
            name=name,
            virtual_network_tap=virtual_network_tap,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provisioning_state: Optional[str] = None,
             type: Optional[str] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             virtual_network_tap: Optional['outputs.VirtualNetworkTapResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if virtual_network_tap is None and 'virtualNetworkTap' in kwargs:
            virtual_network_tap = kwargs['virtualNetworkTap']

        _setter("provisioning_state", provisioning_state)
        _setter("type", type)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if virtual_network_tap is not None:
            _setter("virtual_network_tap", virtual_network_tap)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the network interface tap configuration. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Sub Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="virtualNetworkTap")
    def virtual_network_tap(self) -> Optional['outputs.VirtualNetworkTapResponse']:
        """
        The reference of the Virtual Network Tap resource.
        """
        return pulumi.get(self, "virtual_network_tap")


@pulumi.output_type
class NetworkSecurityGroupResponse(dict):
    """
    NetworkSecurityGroup resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "defaultSecurityRules":
            suggest = "default_security_rules"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "resourceGuid":
            suggest = "resource_guid"
        elif key == "securityRules":
            suggest = "security_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkSecurityGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkSecurityGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkSecurityGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 network_interfaces: Sequence['outputs.NetworkInterfaceResponse'],
                 subnets: Sequence['outputs.SubnetResponse'],
                 type: str,
                 default_security_rules: Optional[Sequence['outputs.SecurityRuleResponse']] = None,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 location: Optional[str] = None,
                 provisioning_state: Optional[str] = None,
                 resource_guid: Optional[str] = None,
                 security_rules: Optional[Sequence['outputs.SecurityRuleResponse']] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        NetworkSecurityGroup resource.
        :param str name: Resource name.
        :param Sequence['NetworkInterfaceResponse'] network_interfaces: A collection of references to network interfaces.
        :param Sequence['SubnetResponse'] subnets: A collection of references to subnets.
        :param str type: Resource type.
        :param Sequence['SecurityRuleResponse'] default_security_rules: The default security rules of network security group.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str location: Resource location.
        :param str provisioning_state: The provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param str resource_guid: The resource GUID property of the network security group resource.
        :param Sequence['SecurityRuleResponse'] security_rules: A collection of security rules of the network security group.
        :param Mapping[str, str] tags: Resource tags.
        """
        NetworkSecurityGroupResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            network_interfaces=network_interfaces,
            subnets=subnets,
            type=type,
            default_security_rules=default_security_rules,
            etag=etag,
            id=id,
            location=location,
            provisioning_state=provisioning_state,
            resource_guid=resource_guid,
            security_rules=security_rules,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             network_interfaces: Optional[Sequence['outputs.NetworkInterfaceResponse']] = None,
             subnets: Optional[Sequence['outputs.SubnetResponse']] = None,
             type: Optional[str] = None,
             default_security_rules: Optional[Sequence['outputs.SecurityRuleResponse']] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             location: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             resource_guid: Optional[str] = None,
             security_rules: Optional[Sequence['outputs.SecurityRuleResponse']] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if network_interfaces is None and 'networkInterfaces' in kwargs:
            network_interfaces = kwargs['networkInterfaces']
        if network_interfaces is None:
            raise TypeError("Missing 'network_interfaces' argument")
        if subnets is None:
            raise TypeError("Missing 'subnets' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if default_security_rules is None and 'defaultSecurityRules' in kwargs:
            default_security_rules = kwargs['defaultSecurityRules']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if resource_guid is None and 'resourceGuid' in kwargs:
            resource_guid = kwargs['resourceGuid']
        if security_rules is None and 'securityRules' in kwargs:
            security_rules = kwargs['securityRules']

        _setter("name", name)
        _setter("network_interfaces", network_interfaces)
        _setter("subnets", subnets)
        _setter("type", type)
        if default_security_rules is not None:
            _setter("default_security_rules", default_security_rules)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if location is not None:
            _setter("location", location)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if resource_guid is not None:
            _setter("resource_guid", resource_guid)
        if security_rules is not None:
            _setter("security_rules", security_rules)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.NetworkInterfaceResponse']:
        """
        A collection of references to network interfaces.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.SubnetResponse']:
        """
        A collection of references to subnets.
        """
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="defaultSecurityRules")
    def default_security_rules(self) -> Optional[Sequence['outputs.SecurityRuleResponse']]:
        """
        The default security rules of network security group.
        """
        return pulumi.get(self, "default_security_rules")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Resource location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="resourceGuid")
    def resource_guid(self) -> Optional[str]:
        """
        The resource GUID property of the network security group resource.
        """
        return pulumi.get(self, "resource_guid")

    @property
    @pulumi.getter(name="securityRules")
    def security_rules(self) -> Optional[Sequence['outputs.SecurityRuleResponse']]:
        """
        A collection of security rules of the network security group.
        """
        return pulumi.get(self, "security_rules")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class PeerExpressRouteCircuitConnectionResponse(dict):
    """
    Peer Express Route Circuit Connection in an ExpressRouteCircuitPeering resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "circuitConnectionStatus":
            suggest = "circuit_connection_status"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "addressPrefix":
            suggest = "address_prefix"
        elif key == "authResourceGuid":
            suggest = "auth_resource_guid"
        elif key == "connectionName":
            suggest = "connection_name"
        elif key == "expressRouteCircuitPeering":
            suggest = "express_route_circuit_peering"
        elif key == "peerExpressRouteCircuitPeering":
            suggest = "peer_express_route_circuit_peering"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PeerExpressRouteCircuitConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PeerExpressRouteCircuitConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PeerExpressRouteCircuitConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 circuit_connection_status: str,
                 etag: str,
                 provisioning_state: str,
                 address_prefix: Optional[str] = None,
                 auth_resource_guid: Optional[str] = None,
                 connection_name: Optional[str] = None,
                 express_route_circuit_peering: Optional['outputs.SubResourceResponse'] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 peer_express_route_circuit_peering: Optional['outputs.SubResourceResponse'] = None):
        """
        Peer Express Route Circuit Connection in an ExpressRouteCircuitPeering resource.
        :param str circuit_connection_status: Express Route Circuit connection state.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str provisioning_state: Provisioning state of the peer express route circuit connection resource. Possible values are: 'Succeeded', 'Updating', 'Deleting', and 'Failed'.
        :param str address_prefix: /29 IP address space to carve out Customer addresses for tunnels.
        :param str auth_resource_guid: The resource guid of the authorization used for the express route circuit connection.
        :param str connection_name: The name of the express route circuit connection resource.
        :param 'SubResourceResponse' express_route_circuit_peering: Reference to Express Route Circuit Private Peering Resource of the circuit.
        :param str id: Resource ID.
        :param str name: Gets name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param 'SubResourceResponse' peer_express_route_circuit_peering: Reference to Express Route Circuit Private Peering Resource of the peered circuit.
        """
        PeerExpressRouteCircuitConnectionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            circuit_connection_status=circuit_connection_status,
            etag=etag,
            provisioning_state=provisioning_state,
            address_prefix=address_prefix,
            auth_resource_guid=auth_resource_guid,
            connection_name=connection_name,
            express_route_circuit_peering=express_route_circuit_peering,
            id=id,
            name=name,
            peer_express_route_circuit_peering=peer_express_route_circuit_peering,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             circuit_connection_status: Optional[str] = None,
             etag: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             address_prefix: Optional[str] = None,
             auth_resource_guid: Optional[str] = None,
             connection_name: Optional[str] = None,
             express_route_circuit_peering: Optional['outputs.SubResourceResponse'] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             peer_express_route_circuit_peering: Optional['outputs.SubResourceResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if circuit_connection_status is None and 'circuitConnectionStatus' in kwargs:
            circuit_connection_status = kwargs['circuitConnectionStatus']
        if circuit_connection_status is None:
            raise TypeError("Missing 'circuit_connection_status' argument")
        if etag is None:
            raise TypeError("Missing 'etag' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if address_prefix is None and 'addressPrefix' in kwargs:
            address_prefix = kwargs['addressPrefix']
        if auth_resource_guid is None and 'authResourceGuid' in kwargs:
            auth_resource_guid = kwargs['authResourceGuid']
        if connection_name is None and 'connectionName' in kwargs:
            connection_name = kwargs['connectionName']
        if express_route_circuit_peering is None and 'expressRouteCircuitPeering' in kwargs:
            express_route_circuit_peering = kwargs['expressRouteCircuitPeering']
        if peer_express_route_circuit_peering is None and 'peerExpressRouteCircuitPeering' in kwargs:
            peer_express_route_circuit_peering = kwargs['peerExpressRouteCircuitPeering']

        _setter("circuit_connection_status", circuit_connection_status)
        _setter("etag", etag)
        _setter("provisioning_state", provisioning_state)
        if address_prefix is not None:
            _setter("address_prefix", address_prefix)
        if auth_resource_guid is not None:
            _setter("auth_resource_guid", auth_resource_guid)
        if connection_name is not None:
            _setter("connection_name", connection_name)
        if express_route_circuit_peering is not None:
            _setter("express_route_circuit_peering", express_route_circuit_peering)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if peer_express_route_circuit_peering is not None:
            _setter("peer_express_route_circuit_peering", peer_express_route_circuit_peering)

    @property
    @pulumi.getter(name="circuitConnectionStatus")
    def circuit_connection_status(self) -> str:
        """
        Express Route Circuit connection state.
        """
        return pulumi.get(self, "circuit_connection_status")

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state of the peer express route circuit connection resource. Possible values are: 'Succeeded', 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[str]:
        """
        /29 IP address space to carve out Customer addresses for tunnels.
        """
        return pulumi.get(self, "address_prefix")

    @property
    @pulumi.getter(name="authResourceGuid")
    def auth_resource_guid(self) -> Optional[str]:
        """
        The resource guid of the authorization used for the express route circuit connection.
        """
        return pulumi.get(self, "auth_resource_guid")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        """
        The name of the express route circuit connection resource.
        """
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter(name="expressRouteCircuitPeering")
    def express_route_circuit_peering(self) -> Optional['outputs.SubResourceResponse']:
        """
        Reference to Express Route Circuit Private Peering Resource of the circuit.
        """
        return pulumi.get(self, "express_route_circuit_peering")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Gets name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="peerExpressRouteCircuitPeering")
    def peer_express_route_circuit_peering(self) -> Optional['outputs.SubResourceResponse']:
        """
        Reference to Express Route Circuit Private Peering Resource of the peered circuit.
        """
        return pulumi.get(self, "peer_express_route_circuit_peering")


@pulumi.output_type
class PublicIPAddressDnsSettingsResponse(dict):
    """
    Contains FQDN of the DNS record associated with the public IP address
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainNameLabel":
            suggest = "domain_name_label"
        elif key == "reverseFqdn":
            suggest = "reverse_fqdn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PublicIPAddressDnsSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PublicIPAddressDnsSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PublicIPAddressDnsSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_name_label: Optional[str] = None,
                 fqdn: Optional[str] = None,
                 reverse_fqdn: Optional[str] = None):
        """
        Contains FQDN of the DNS record associated with the public IP address
        :param str domain_name_label: Gets or sets the Domain name label.The concatenation of the domain name label and the regionalized DNS zone make up the fully qualified domain name associated with the public IP address. If a domain name label is specified, an A DNS record is created for the public IP in the Microsoft Azure DNS system.
        :param str fqdn: Gets the FQDN, Fully qualified domain name of the A DNS record associated with the public IP. This is the concatenation of the domainNameLabel and the regionalized DNS zone.
        :param str reverse_fqdn: Gets or Sets the Reverse FQDN. A user-visible, fully qualified domain name that resolves to this public IP address. If the reverseFqdn is specified, then a PTR DNS record is created pointing from the IP address in the in-addr.arpa domain to the reverse FQDN. 
        """
        PublicIPAddressDnsSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_name_label=domain_name_label,
            fqdn=fqdn,
            reverse_fqdn=reverse_fqdn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_name_label: Optional[str] = None,
             fqdn: Optional[str] = None,
             reverse_fqdn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if domain_name_label is None and 'domainNameLabel' in kwargs:
            domain_name_label = kwargs['domainNameLabel']
        if reverse_fqdn is None and 'reverseFqdn' in kwargs:
            reverse_fqdn = kwargs['reverseFqdn']

        if domain_name_label is not None:
            _setter("domain_name_label", domain_name_label)
        if fqdn is not None:
            _setter("fqdn", fqdn)
        if reverse_fqdn is not None:
            _setter("reverse_fqdn", reverse_fqdn)

    @property
    @pulumi.getter(name="domainNameLabel")
    def domain_name_label(self) -> Optional[str]:
        """
        Gets or sets the Domain name label.The concatenation of the domain name label and the regionalized DNS zone make up the fully qualified domain name associated with the public IP address. If a domain name label is specified, an A DNS record is created for the public IP in the Microsoft Azure DNS system.
        """
        return pulumi.get(self, "domain_name_label")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        """
        Gets the FQDN, Fully qualified domain name of the A DNS record associated with the public IP. This is the concatenation of the domainNameLabel and the regionalized DNS zone.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="reverseFqdn")
    def reverse_fqdn(self) -> Optional[str]:
        """
        Gets or Sets the Reverse FQDN. A user-visible, fully qualified domain name that resolves to this public IP address. If the reverseFqdn is specified, then a PTR DNS record is created pointing from the IP address in the in-addr.arpa domain to the reverse FQDN. 
        """
        return pulumi.get(self, "reverse_fqdn")


@pulumi.output_type
class PublicIPAddressResponse(dict):
    """
    Public IP address resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipConfiguration":
            suggest = "ip_configuration"
        elif key == "ddosSettings":
            suggest = "ddos_settings"
        elif key == "dnsSettings":
            suggest = "dns_settings"
        elif key == "idleTimeoutInMinutes":
            suggest = "idle_timeout_in_minutes"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipTags":
            suggest = "ip_tags"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "publicIPAddressVersion":
            suggest = "public_ip_address_version"
        elif key == "publicIPAllocationMethod":
            suggest = "public_ip_allocation_method"
        elif key == "publicIPPrefix":
            suggest = "public_ip_prefix"
        elif key == "resourceGuid":
            suggest = "resource_guid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PublicIPAddressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PublicIPAddressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PublicIPAddressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_configuration: 'outputs.IPConfigurationResponse',
                 name: str,
                 type: str,
                 ddos_settings: Optional['outputs.DdosSettingsResponse'] = None,
                 dns_settings: Optional['outputs.PublicIPAddressDnsSettingsResponse'] = None,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 idle_timeout_in_minutes: Optional[int] = None,
                 ip_address: Optional[str] = None,
                 ip_tags: Optional[Sequence['outputs.IpTagResponse']] = None,
                 location: Optional[str] = None,
                 provisioning_state: Optional[str] = None,
                 public_ip_address_version: Optional[str] = None,
                 public_ip_allocation_method: Optional[str] = None,
                 public_ip_prefix: Optional['outputs.SubResourceResponse'] = None,
                 resource_guid: Optional[str] = None,
                 sku: Optional['outputs.PublicIPAddressSkuResponse'] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 zones: Optional[Sequence[str]] = None):
        """
        Public IP address resource.
        :param 'IPConfigurationResponse' ip_configuration: The IP configuration associated with the public IP address.
        :param str name: Resource name.
        :param str type: Resource type.
        :param 'DdosSettingsResponse' ddos_settings: The DDoS protection custom policy associated with the public IP address.
        :param 'PublicIPAddressDnsSettingsResponse' dns_settings: The FQDN of the DNS record associated with the public IP address.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param int idle_timeout_in_minutes: The idle timeout of the public IP address.
        :param str ip_address: The IP address associated with the public IP address resource.
        :param Sequence['IpTagResponse'] ip_tags: The list of tags associated with the public IP address.
        :param str location: Resource location.
        :param str provisioning_state: The provisioning state of the PublicIP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param str public_ip_address_version: The public IP address version.
        :param str public_ip_allocation_method: The public IP address allocation method.
        :param 'SubResourceResponse' public_ip_prefix: The Public IP Prefix this Public IP Address should be allocated from.
        :param str resource_guid: The resource GUID property of the public IP resource.
        :param 'PublicIPAddressSkuResponse' sku: The public IP address SKU.
        :param Mapping[str, str] tags: Resource tags.
        :param Sequence[str] zones: A list of availability zones denoting the IP allocated for the resource needs to come from.
        """
        PublicIPAddressResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_configuration=ip_configuration,
            name=name,
            type=type,
            ddos_settings=ddos_settings,
            dns_settings=dns_settings,
            etag=etag,
            id=id,
            idle_timeout_in_minutes=idle_timeout_in_minutes,
            ip_address=ip_address,
            ip_tags=ip_tags,
            location=location,
            provisioning_state=provisioning_state,
            public_ip_address_version=public_ip_address_version,
            public_ip_allocation_method=public_ip_allocation_method,
            public_ip_prefix=public_ip_prefix,
            resource_guid=resource_guid,
            sku=sku,
            tags=tags,
            zones=zones,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_configuration: Optional['outputs.IPConfigurationResponse'] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             ddos_settings: Optional['outputs.DdosSettingsResponse'] = None,
             dns_settings: Optional['outputs.PublicIPAddressDnsSettingsResponse'] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             idle_timeout_in_minutes: Optional[int] = None,
             ip_address: Optional[str] = None,
             ip_tags: Optional[Sequence['outputs.IpTagResponse']] = None,
             location: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             public_ip_address_version: Optional[str] = None,
             public_ip_allocation_method: Optional[str] = None,
             public_ip_prefix: Optional['outputs.SubResourceResponse'] = None,
             resource_guid: Optional[str] = None,
             sku: Optional['outputs.PublicIPAddressSkuResponse'] = None,
             tags: Optional[Mapping[str, str]] = None,
             zones: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_configuration is None and 'ipConfiguration' in kwargs:
            ip_configuration = kwargs['ipConfiguration']
        if ip_configuration is None:
            raise TypeError("Missing 'ip_configuration' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if ddos_settings is None and 'ddosSettings' in kwargs:
            ddos_settings = kwargs['ddosSettings']
        if dns_settings is None and 'dnsSettings' in kwargs:
            dns_settings = kwargs['dnsSettings']
        if idle_timeout_in_minutes is None and 'idleTimeoutInMinutes' in kwargs:
            idle_timeout_in_minutes = kwargs['idleTimeoutInMinutes']
        if ip_address is None and 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if ip_tags is None and 'ipTags' in kwargs:
            ip_tags = kwargs['ipTags']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if public_ip_address_version is None and 'publicIPAddressVersion' in kwargs:
            public_ip_address_version = kwargs['publicIPAddressVersion']
        if public_ip_allocation_method is None and 'publicIPAllocationMethod' in kwargs:
            public_ip_allocation_method = kwargs['publicIPAllocationMethod']
        if public_ip_prefix is None and 'publicIPPrefix' in kwargs:
            public_ip_prefix = kwargs['publicIPPrefix']
        if resource_guid is None and 'resourceGuid' in kwargs:
            resource_guid = kwargs['resourceGuid']

        _setter("ip_configuration", ip_configuration)
        _setter("name", name)
        _setter("type", type)
        if ddos_settings is not None:
            _setter("ddos_settings", ddos_settings)
        if dns_settings is not None:
            _setter("dns_settings", dns_settings)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if idle_timeout_in_minutes is not None:
            _setter("idle_timeout_in_minutes", idle_timeout_in_minutes)
        if ip_address is not None:
            _setter("ip_address", ip_address)
        if ip_tags is not None:
            _setter("ip_tags", ip_tags)
        if location is not None:
            _setter("location", location)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if public_ip_address_version is not None:
            _setter("public_ip_address_version", public_ip_address_version)
        if public_ip_allocation_method is not None:
            _setter("public_ip_allocation_method", public_ip_allocation_method)
        if public_ip_prefix is not None:
            _setter("public_ip_prefix", public_ip_prefix)
        if resource_guid is not None:
            _setter("resource_guid", resource_guid)
        if sku is not None:
            _setter("sku", sku)
        if tags is not None:
            _setter("tags", tags)
        if zones is not None:
            _setter("zones", zones)

    @property
    @pulumi.getter(name="ipConfiguration")
    def ip_configuration(self) -> 'outputs.IPConfigurationResponse':
        """
        The IP configuration associated with the public IP address.
        """
        return pulumi.get(self, "ip_configuration")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="ddosSettings")
    def ddos_settings(self) -> Optional['outputs.DdosSettingsResponse']:
        """
        The DDoS protection custom policy associated with the public IP address.
        """
        return pulumi.get(self, "ddos_settings")

    @property
    @pulumi.getter(name="dnsSettings")
    def dns_settings(self) -> Optional['outputs.PublicIPAddressDnsSettingsResponse']:
        """
        The FQDN of the DNS record associated with the public IP address.
        """
        return pulumi.get(self, "dns_settings")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[int]:
        """
        The idle timeout of the public IP address.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP address associated with the public IP address resource.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="ipTags")
    def ip_tags(self) -> Optional[Sequence['outputs.IpTagResponse']]:
        """
        The list of tags associated with the public IP address.
        """
        return pulumi.get(self, "ip_tags")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Resource location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state of the PublicIP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="publicIPAddressVersion")
    def public_ip_address_version(self) -> Optional[str]:
        """
        The public IP address version.
        """
        return pulumi.get(self, "public_ip_address_version")

    @property
    @pulumi.getter(name="publicIPAllocationMethod")
    def public_ip_allocation_method(self) -> Optional[str]:
        """
        The public IP address allocation method.
        """
        return pulumi.get(self, "public_ip_allocation_method")

    @property
    @pulumi.getter(name="publicIPPrefix")
    def public_ip_prefix(self) -> Optional['outputs.SubResourceResponse']:
        """
        The Public IP Prefix this Public IP Address should be allocated from.
        """
        return pulumi.get(self, "public_ip_prefix")

    @property
    @pulumi.getter(name="resourceGuid")
    def resource_guid(self) -> Optional[str]:
        """
        The resource GUID property of the public IP resource.
        """
        return pulumi.get(self, "resource_guid")

    @property
    @pulumi.getter
    def sku(self) -> Optional['outputs.PublicIPAddressSkuResponse']:
        """
        The public IP address SKU.
        """
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[str]]:
        """
        A list of availability zones denoting the IP allocated for the resource needs to come from.
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class PublicIPAddressSkuResponse(dict):
    """
    SKU of a public IP address
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        SKU of a public IP address
        :param str name: Name of a public IP address SKU.
        """
        PublicIPAddressSkuResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of a public IP address SKU.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ResourceNavigationLinkResponse(dict):
    """
    ResourceNavigationLink resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "linkedResourceType":
            suggest = "linked_resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceNavigationLinkResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceNavigationLinkResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceNavigationLinkResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: str,
                 provisioning_state: str,
                 id: Optional[str] = None,
                 link: Optional[str] = None,
                 linked_resource_type: Optional[str] = None,
                 name: Optional[str] = None):
        """
        ResourceNavigationLink resource.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str provisioning_state: Provisioning state of the ResourceNavigationLink resource.
        :param str id: Resource ID.
        :param str link: Link to the external resource
        :param str linked_resource_type: Resource type of the linked resource.
        :param str name: Name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        ResourceNavigationLinkResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            etag=etag,
            provisioning_state=provisioning_state,
            id=id,
            link=link,
            linked_resource_type=linked_resource_type,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             etag: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             id: Optional[str] = None,
             link: Optional[str] = None,
             linked_resource_type: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if etag is None:
            raise TypeError("Missing 'etag' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if linked_resource_type is None and 'linkedResourceType' in kwargs:
            linked_resource_type = kwargs['linkedResourceType']

        _setter("etag", etag)
        _setter("provisioning_state", provisioning_state)
        if id is not None:
            _setter("id", id)
        if link is not None:
            _setter("link", link)
        if linked_resource_type is not None:
            _setter("linked_resource_type", linked_resource_type)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state of the ResourceNavigationLink resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        Link to the external resource
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="linkedResourceType")
    def linked_resource_type(self) -> Optional[str]:
        """
        Resource type of the linked resource.
        """
        return pulumi.get(self, "linked_resource_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RouteFilterResponse(dict):
    """
    Route Filter Resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: str,
                 location: str,
                 name: str,
                 provisioning_state: str,
                 type: str,
                 id: Optional[str] = None,
                 peerings: Optional[Sequence['outputs.ExpressRouteCircuitPeeringResponse']] = None,
                 rules: Optional[Sequence['outputs.RouteFilterRuleResponse']] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Route Filter Resource.
        :param str etag: Gets a unique read-only string that changes whenever the resource is updated.
        :param str location: Resource location.
        :param str name: Resource name.
        :param str provisioning_state: The provisioning state of the resource. Possible values are: 'Updating', 'Deleting', 'Succeeded' and 'Failed'.
        :param str type: Resource type.
        :param str id: Resource ID.
        :param Sequence['ExpressRouteCircuitPeeringResponse'] peerings: A collection of references to express route circuit peerings.
        :param Sequence['RouteFilterRuleResponse'] rules: Collection of RouteFilterRules contained within a route filter.
        :param Mapping[str, str] tags: Resource tags.
        """
        RouteFilterResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            etag=etag,
            location=location,
            name=name,
            provisioning_state=provisioning_state,
            type=type,
            id=id,
            peerings=peerings,
            rules=rules,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             etag: Optional[str] = None,
             location: Optional[str] = None,
             name: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             type: Optional[str] = None,
             id: Optional[str] = None,
             peerings: Optional[Sequence['outputs.ExpressRouteCircuitPeeringResponse']] = None,
             rules: Optional[Sequence['outputs.RouteFilterRuleResponse']] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if etag is None:
            raise TypeError("Missing 'etag' argument")
        if location is None:
            raise TypeError("Missing 'location' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("etag", etag)
        _setter("location", location)
        _setter("name", name)
        _setter("provisioning_state", provisioning_state)
        _setter("type", type)
        if id is not None:
            _setter("id", id)
        if peerings is not None:
            _setter("peerings", peerings)
        if rules is not None:
            _setter("rules", rules)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        Gets a unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Resource location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the resource. Possible values are: 'Updating', 'Deleting', 'Succeeded' and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def peerings(self) -> Optional[Sequence['outputs.ExpressRouteCircuitPeeringResponse']]:
        """
        A collection of references to express route circuit peerings.
        """
        return pulumi.get(self, "peerings")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.RouteFilterRuleResponse']]:
        """
        Collection of RouteFilterRules contained within a route filter.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class RouteFilterRuleResponse(dict):
    """
    Route Filter Rule Resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "routeFilterRuleType":
            suggest = "route_filter_rule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteFilterRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteFilterRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteFilterRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: str,
                 communities: Sequence[str],
                 etag: str,
                 provisioning_state: str,
                 route_filter_rule_type: str,
                 id: Optional[str] = None,
                 location: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Route Filter Rule Resource
        :param str access: The access type of the rule.
        :param Sequence[str] communities: The collection for bgp community values to filter on. e.g. ['12076:5010','12076:5020']
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str provisioning_state: The provisioning state of the resource. Possible values are: 'Updating', 'Deleting', 'Succeeded' and 'Failed'.
        :param str route_filter_rule_type: The rule type of the rule. Valid value is: 'Community'
        :param str id: Resource ID.
        :param str location: Resource location.
        :param str name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        RouteFilterRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access=access,
            communities=communities,
            etag=etag,
            provisioning_state=provisioning_state,
            route_filter_rule_type=route_filter_rule_type,
            id=id,
            location=location,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access: Optional[str] = None,
             communities: Optional[Sequence[str]] = None,
             etag: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             route_filter_rule_type: Optional[str] = None,
             id: Optional[str] = None,
             location: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access is None:
            raise TypeError("Missing 'access' argument")
        if communities is None:
            raise TypeError("Missing 'communities' argument")
        if etag is None:
            raise TypeError("Missing 'etag' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if route_filter_rule_type is None and 'routeFilterRuleType' in kwargs:
            route_filter_rule_type = kwargs['routeFilterRuleType']
        if route_filter_rule_type is None:
            raise TypeError("Missing 'route_filter_rule_type' argument")

        _setter("access", access)
        _setter("communities", communities)
        _setter("etag", etag)
        _setter("provisioning_state", provisioning_state)
        _setter("route_filter_rule_type", route_filter_rule_type)
        if id is not None:
            _setter("id", id)
        if location is not None:
            _setter("location", location)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        The access type of the rule.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def communities(self) -> Sequence[str]:
        """
        The collection for bgp community values to filter on. e.g. ['12076:5010','12076:5020']
        """
        return pulumi.get(self, "communities")

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the resource. Possible values are: 'Updating', 'Deleting', 'Succeeded' and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="routeFilterRuleType")
    def route_filter_rule_type(self) -> str:
        """
        The rule type of the rule. Valid value is: 'Community'
        """
        return pulumi.get(self, "route_filter_rule_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Resource location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RouteResponse(dict):
    """
    Route resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nextHopType":
            suggest = "next_hop_type"
        elif key == "addressPrefix":
            suggest = "address_prefix"
        elif key == "nextHopIpAddress":
            suggest = "next_hop_ip_address"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 next_hop_type: str,
                 address_prefix: Optional[str] = None,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 next_hop_ip_address: Optional[str] = None,
                 provisioning_state: Optional[str] = None):
        """
        Route resource
        :param str next_hop_type: The type of Azure hop the packet should be sent to.
        :param str address_prefix: The destination CIDR to which the route applies.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param str next_hop_ip_address: The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        :param str provisioning_state: The provisioning state of the resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        RouteResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            next_hop_type=next_hop_type,
            address_prefix=address_prefix,
            etag=etag,
            id=id,
            name=name,
            next_hop_ip_address=next_hop_ip_address,
            provisioning_state=provisioning_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             next_hop_type: Optional[str] = None,
             address_prefix: Optional[str] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             next_hop_ip_address: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if next_hop_type is None and 'nextHopType' in kwargs:
            next_hop_type = kwargs['nextHopType']
        if next_hop_type is None:
            raise TypeError("Missing 'next_hop_type' argument")
        if address_prefix is None and 'addressPrefix' in kwargs:
            address_prefix = kwargs['addressPrefix']
        if next_hop_ip_address is None and 'nextHopIpAddress' in kwargs:
            next_hop_ip_address = kwargs['nextHopIpAddress']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']

        _setter("next_hop_type", next_hop_type)
        if address_prefix is not None:
            _setter("address_prefix", address_prefix)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if next_hop_ip_address is not None:
            _setter("next_hop_ip_address", next_hop_ip_address)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="nextHopType")
    def next_hop_type(self) -> str:
        """
        The type of Azure hop the packet should be sent to.
        """
        return pulumi.get(self, "next_hop_type")

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[str]:
        """
        The destination CIDR to which the route applies.
        """
        return pulumi.get(self, "address_prefix")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nextHopIpAddress")
    def next_hop_ip_address(self) -> Optional[str]:
        """
        The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
        """
        return pulumi.get(self, "next_hop_ip_address")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state of the resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class RouteTableResponse(dict):
    """
    Route table resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableBgpRoutePropagation":
            suggest = "disable_bgp_route_propagation"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteTableResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteTableResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteTableResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 subnets: Sequence['outputs.SubnetResponse'],
                 type: str,
                 disable_bgp_route_propagation: Optional[bool] = None,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 location: Optional[str] = None,
                 provisioning_state: Optional[str] = None,
                 routes: Optional[Sequence['outputs.RouteResponse']] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Route table resource.
        :param str name: Resource name.
        :param Sequence['SubnetResponse'] subnets: A collection of references to subnets.
        :param str type: Resource type.
        :param bool disable_bgp_route_propagation: Gets or sets whether to disable the routes learned by BGP on that route table. True means disable.
        :param str etag: Gets a unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str location: Resource location.
        :param str provisioning_state: The provisioning state of the resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param Sequence['RouteResponse'] routes: Collection of routes contained within a route table.
        :param Mapping[str, str] tags: Resource tags.
        """
        RouteTableResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            subnets=subnets,
            type=type,
            disable_bgp_route_propagation=disable_bgp_route_propagation,
            etag=etag,
            id=id,
            location=location,
            provisioning_state=provisioning_state,
            routes=routes,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             subnets: Optional[Sequence['outputs.SubnetResponse']] = None,
             type: Optional[str] = None,
             disable_bgp_route_propagation: Optional[bool] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             location: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             routes: Optional[Sequence['outputs.RouteResponse']] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if subnets is None:
            raise TypeError("Missing 'subnets' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if disable_bgp_route_propagation is None and 'disableBgpRoutePropagation' in kwargs:
            disable_bgp_route_propagation = kwargs['disableBgpRoutePropagation']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']

        _setter("name", name)
        _setter("subnets", subnets)
        _setter("type", type)
        if disable_bgp_route_propagation is not None:
            _setter("disable_bgp_route_propagation", disable_bgp_route_propagation)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if location is not None:
            _setter("location", location)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if routes is not None:
            _setter("routes", routes)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.SubnetResponse']:
        """
        A collection of references to subnets.
        """
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="disableBgpRoutePropagation")
    def disable_bgp_route_propagation(self) -> Optional[bool]:
        """
        Gets or sets whether to disable the routes learned by BGP on that route table. True means disable.
        """
        return pulumi.get(self, "disable_bgp_route_propagation")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        Gets a unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Resource location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state of the resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.RouteResponse']]:
        """
        Collection of routes contained within a route table.
        """
        return pulumi.get(self, "routes")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SecurityRuleResponse(dict):
    """
    Network security rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddressPrefix":
            suggest = "destination_address_prefix"
        elif key == "destinationAddressPrefixes":
            suggest = "destination_address_prefixes"
        elif key == "destinationApplicationSecurityGroups":
            suggest = "destination_application_security_groups"
        elif key == "destinationPortRange":
            suggest = "destination_port_range"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "sourceAddressPrefix":
            suggest = "source_address_prefix"
        elif key == "sourceAddressPrefixes":
            suggest = "source_address_prefixes"
        elif key == "sourceApplicationSecurityGroups":
            suggest = "source_application_security_groups"
        elif key == "sourcePortRange":
            suggest = "source_port_range"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: str,
                 direction: str,
                 protocol: str,
                 description: Optional[str] = None,
                 destination_address_prefix: Optional[str] = None,
                 destination_address_prefixes: Optional[Sequence[str]] = None,
                 destination_application_security_groups: Optional[Sequence['outputs.ApplicationSecurityGroupResponse']] = None,
                 destination_port_range: Optional[str] = None,
                 destination_port_ranges: Optional[Sequence[str]] = None,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 provisioning_state: Optional[str] = None,
                 source_address_prefix: Optional[str] = None,
                 source_address_prefixes: Optional[Sequence[str]] = None,
                 source_application_security_groups: Optional[Sequence['outputs.ApplicationSecurityGroupResponse']] = None,
                 source_port_range: Optional[str] = None,
                 source_port_ranges: Optional[Sequence[str]] = None):
        """
        Network security rule.
        :param str access: The network traffic is allowed or denied.
        :param str direction: The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic.
        :param str protocol: Network protocol this rule applies to. Possible values are 'Tcp', 'Udp', 'Icmp', 'Esp', and '*'.
        :param str description: A description for this rule. Restricted to 140 chars.
        :param str destination_address_prefix: The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
        :param Sequence[str] destination_address_prefixes: The destination address prefixes. CIDR or destination IP ranges.
        :param Sequence['ApplicationSecurityGroupResponse'] destination_application_security_groups: The application security group specified as destination.
        :param str destination_port_range: The destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
        :param Sequence[str] destination_port_ranges: The destination port ranges.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param int priority: The priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
        :param str provisioning_state: The provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param str source_address_prefix: The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from. 
        :param Sequence[str] source_address_prefixes: The CIDR or source IP ranges.
        :param Sequence['ApplicationSecurityGroupResponse'] source_application_security_groups: The application security group specified as source.
        :param str source_port_range: The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
        :param Sequence[str] source_port_ranges: The source port ranges.
        """
        SecurityRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access=access,
            direction=direction,
            protocol=protocol,
            description=description,
            destination_address_prefix=destination_address_prefix,
            destination_address_prefixes=destination_address_prefixes,
            destination_application_security_groups=destination_application_security_groups,
            destination_port_range=destination_port_range,
            destination_port_ranges=destination_port_ranges,
            etag=etag,
            id=id,
            name=name,
            priority=priority,
            provisioning_state=provisioning_state,
            source_address_prefix=source_address_prefix,
            source_address_prefixes=source_address_prefixes,
            source_application_security_groups=source_application_security_groups,
            source_port_range=source_port_range,
            source_port_ranges=source_port_ranges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access: Optional[str] = None,
             direction: Optional[str] = None,
             protocol: Optional[str] = None,
             description: Optional[str] = None,
             destination_address_prefix: Optional[str] = None,
             destination_address_prefixes: Optional[Sequence[str]] = None,
             destination_application_security_groups: Optional[Sequence['outputs.ApplicationSecurityGroupResponse']] = None,
             destination_port_range: Optional[str] = None,
             destination_port_ranges: Optional[Sequence[str]] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             priority: Optional[int] = None,
             provisioning_state: Optional[str] = None,
             source_address_prefix: Optional[str] = None,
             source_address_prefixes: Optional[Sequence[str]] = None,
             source_application_security_groups: Optional[Sequence['outputs.ApplicationSecurityGroupResponse']] = None,
             source_port_range: Optional[str] = None,
             source_port_ranges: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access is None:
            raise TypeError("Missing 'access' argument")
        if direction is None:
            raise TypeError("Missing 'direction' argument")
        if protocol is None:
            raise TypeError("Missing 'protocol' argument")
        if destination_address_prefix is None and 'destinationAddressPrefix' in kwargs:
            destination_address_prefix = kwargs['destinationAddressPrefix']
        if destination_address_prefixes is None and 'destinationAddressPrefixes' in kwargs:
            destination_address_prefixes = kwargs['destinationAddressPrefixes']
        if destination_application_security_groups is None and 'destinationApplicationSecurityGroups' in kwargs:
            destination_application_security_groups = kwargs['destinationApplicationSecurityGroups']
        if destination_port_range is None and 'destinationPortRange' in kwargs:
            destination_port_range = kwargs['destinationPortRange']
        if destination_port_ranges is None and 'destinationPortRanges' in kwargs:
            destination_port_ranges = kwargs['destinationPortRanges']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if source_address_prefix is None and 'sourceAddressPrefix' in kwargs:
            source_address_prefix = kwargs['sourceAddressPrefix']
        if source_address_prefixes is None and 'sourceAddressPrefixes' in kwargs:
            source_address_prefixes = kwargs['sourceAddressPrefixes']
        if source_application_security_groups is None and 'sourceApplicationSecurityGroups' in kwargs:
            source_application_security_groups = kwargs['sourceApplicationSecurityGroups']
        if source_port_range is None and 'sourcePortRange' in kwargs:
            source_port_range = kwargs['sourcePortRange']
        if source_port_ranges is None and 'sourcePortRanges' in kwargs:
            source_port_ranges = kwargs['sourcePortRanges']

        _setter("access", access)
        _setter("direction", direction)
        _setter("protocol", protocol)
        if description is not None:
            _setter("description", description)
        if destination_address_prefix is not None:
            _setter("destination_address_prefix", destination_address_prefix)
        if destination_address_prefixes is not None:
            _setter("destination_address_prefixes", destination_address_prefixes)
        if destination_application_security_groups is not None:
            _setter("destination_application_security_groups", destination_application_security_groups)
        if destination_port_range is not None:
            _setter("destination_port_range", destination_port_range)
        if destination_port_ranges is not None:
            _setter("destination_port_ranges", destination_port_ranges)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if priority is not None:
            _setter("priority", priority)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if source_address_prefix is not None:
            _setter("source_address_prefix", source_address_prefix)
        if source_address_prefixes is not None:
            _setter("source_address_prefixes", source_address_prefixes)
        if source_application_security_groups is not None:
            _setter("source_application_security_groups", source_application_security_groups)
        if source_port_range is not None:
            _setter("source_port_range", source_port_range)
        if source_port_ranges is not None:
            _setter("source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        The network traffic is allowed or denied.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Network protocol this rule applies to. Possible values are 'Tcp', 'Udp', 'Icmp', 'Esp', and '*'.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description for this rule. Restricted to 140 chars.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationAddressPrefix")
    def destination_address_prefix(self) -> Optional[str]:
        """
        The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
        """
        return pulumi.get(self, "destination_address_prefix")

    @property
    @pulumi.getter(name="destinationAddressPrefixes")
    def destination_address_prefixes(self) -> Optional[Sequence[str]]:
        """
        The destination address prefixes. CIDR or destination IP ranges.
        """
        return pulumi.get(self, "destination_address_prefixes")

    @property
    @pulumi.getter(name="destinationApplicationSecurityGroups")
    def destination_application_security_groups(self) -> Optional[Sequence['outputs.ApplicationSecurityGroupResponse']]:
        """
        The application security group specified as destination.
        """
        return pulumi.get(self, "destination_application_security_groups")

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional[str]:
        """
        The destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
        """
        return pulumi.get(self, "destination_port_range")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence[str]]:
        """
        The destination port ranges.
        """
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="sourceAddressPrefix")
    def source_address_prefix(self) -> Optional[str]:
        """
        The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from. 
        """
        return pulumi.get(self, "source_address_prefix")

    @property
    @pulumi.getter(name="sourceAddressPrefixes")
    def source_address_prefixes(self) -> Optional[Sequence[str]]:
        """
        The CIDR or source IP ranges.
        """
        return pulumi.get(self, "source_address_prefixes")

    @property
    @pulumi.getter(name="sourceApplicationSecurityGroups")
    def source_application_security_groups(self) -> Optional[Sequence['outputs.ApplicationSecurityGroupResponse']]:
        """
        The application security group specified as source.
        """
        return pulumi.get(self, "source_application_security_groups")

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[str]:
        """
        The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
        """
        return pulumi.get(self, "source_port_range")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence[str]]:
        """
        The source port ranges.
        """
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class ServiceAssociationLinkResponse(dict):
    """
    ServiceAssociationLink resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "linkedResourceType":
            suggest = "linked_resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAssociationLinkResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAssociationLinkResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAssociationLinkResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etag: str,
                 provisioning_state: str,
                 id: Optional[str] = None,
                 link: Optional[str] = None,
                 linked_resource_type: Optional[str] = None,
                 name: Optional[str] = None):
        """
        ServiceAssociationLink resource.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str provisioning_state: Provisioning state of the ServiceAssociationLink resource.
        :param str id: Resource ID.
        :param str link: Link to the external resource.
        :param str linked_resource_type: Resource type of the linked resource.
        :param str name: Name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        ServiceAssociationLinkResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            etag=etag,
            provisioning_state=provisioning_state,
            id=id,
            link=link,
            linked_resource_type=linked_resource_type,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             etag: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             id: Optional[str] = None,
             link: Optional[str] = None,
             linked_resource_type: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if etag is None:
            raise TypeError("Missing 'etag' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if linked_resource_type is None and 'linkedResourceType' in kwargs:
            linked_resource_type = kwargs['linkedResourceType']

        _setter("etag", etag)
        _setter("provisioning_state", provisioning_state)
        if id is not None:
            _setter("id", id)
        if link is not None:
            _setter("link", link)
        if linked_resource_type is not None:
            _setter("linked_resource_type", linked_resource_type)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def etag(self) -> str:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state of the ServiceAssociationLink resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        Link to the external resource.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="linkedResourceType")
    def linked_resource_type(self) -> Optional[str]:
        """
        Resource type of the linked resource.
        """
        return pulumi.get(self, "linked_resource_type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ServiceEndpointPolicyDefinitionResponse(dict):
    """
    Service Endpoint policy definitions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "serviceResources":
            suggest = "service_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointPolicyDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointPolicyDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointPolicyDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 description: Optional[str] = None,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 service: Optional[str] = None,
                 service_resources: Optional[Sequence[str]] = None):
        """
        Service Endpoint policy definitions.
        :param str provisioning_state: The provisioning state of the service end point policy definition. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param str description: A description for this rule. Restricted to 140 chars.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param str service: Service endpoint name.
        :param Sequence[str] service_resources: A list of service resources.
        """
        ServiceEndpointPolicyDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provisioning_state=provisioning_state,
            description=description,
            etag=etag,
            id=id,
            name=name,
            service=service,
            service_resources=service_resources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provisioning_state: Optional[str] = None,
             description: Optional[str] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             service: Optional[str] = None,
             service_resources: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if service_resources is None and 'serviceResources' in kwargs:
            service_resources = kwargs['serviceResources']

        _setter("provisioning_state", provisioning_state)
        if description is not None:
            _setter("description", description)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if service is not None:
            _setter("service", service)
        if service_resources is not None:
            _setter("service_resources", service_resources)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the service end point policy definition. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description for this rule. Restricted to 140 chars.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Service endpoint name.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="serviceResources")
    def service_resources(self) -> Optional[Sequence[str]]:
        """
        A list of service resources.
        """
        return pulumi.get(self, "service_resources")


@pulumi.output_type
class ServiceEndpointPolicyResponse(dict):
    """
    Service End point policy resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "resourceGuid":
            suggest = "resource_guid"
        elif key == "serviceEndpointPolicyDefinitions":
            suggest = "service_endpoint_policy_definitions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 provisioning_state: str,
                 resource_guid: str,
                 subnets: Sequence['outputs.SubnetResponse'],
                 type: str,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 location: Optional[str] = None,
                 service_endpoint_policy_definitions: Optional[Sequence['outputs.ServiceEndpointPolicyDefinitionResponse']] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Service End point policy resource.
        :param str name: Resource name.
        :param str provisioning_state: The provisioning state of the service endpoint policy. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param str resource_guid: The resource GUID property of the service endpoint policy resource.
        :param Sequence['SubnetResponse'] subnets: A collection of references to subnets.
        :param str type: Resource type.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str location: Resource location.
        :param Sequence['ServiceEndpointPolicyDefinitionResponse'] service_endpoint_policy_definitions: A collection of service endpoint policy definitions of the service endpoint policy.
        :param Mapping[str, str] tags: Resource tags.
        """
        ServiceEndpointPolicyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            provisioning_state=provisioning_state,
            resource_guid=resource_guid,
            subnets=subnets,
            type=type,
            etag=etag,
            id=id,
            location=location,
            service_endpoint_policy_definitions=service_endpoint_policy_definitions,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             resource_guid: Optional[str] = None,
             subnets: Optional[Sequence['outputs.SubnetResponse']] = None,
             type: Optional[str] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             location: Optional[str] = None,
             service_endpoint_policy_definitions: Optional[Sequence['outputs.ServiceEndpointPolicyDefinitionResponse']] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if resource_guid is None and 'resourceGuid' in kwargs:
            resource_guid = kwargs['resourceGuid']
        if resource_guid is None:
            raise TypeError("Missing 'resource_guid' argument")
        if subnets is None:
            raise TypeError("Missing 'subnets' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if service_endpoint_policy_definitions is None and 'serviceEndpointPolicyDefinitions' in kwargs:
            service_endpoint_policy_definitions = kwargs['serviceEndpointPolicyDefinitions']

        _setter("name", name)
        _setter("provisioning_state", provisioning_state)
        _setter("resource_guid", resource_guid)
        _setter("subnets", subnets)
        _setter("type", type)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if location is not None:
            _setter("location", location)
        if service_endpoint_policy_definitions is not None:
            _setter("service_endpoint_policy_definitions", service_endpoint_policy_definitions)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the service endpoint policy. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="resourceGuid")
    def resource_guid(self) -> str:
        """
        The resource GUID property of the service endpoint policy resource.
        """
        return pulumi.get(self, "resource_guid")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.SubnetResponse']:
        """
        A collection of references to subnets.
        """
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Resource location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="serviceEndpointPolicyDefinitions")
    def service_endpoint_policy_definitions(self) -> Optional[Sequence['outputs.ServiceEndpointPolicyDefinitionResponse']]:
        """
        A collection of service endpoint policy definitions of the service endpoint policy.
        """
        return pulumi.get(self, "service_endpoint_policy_definitions")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ServiceEndpointPropertiesFormatResponse(dict):
    """
    The service endpoint properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEndpointPropertiesFormatResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEndpointPropertiesFormatResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEndpointPropertiesFormatResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 locations: Optional[Sequence[str]] = None,
                 provisioning_state: Optional[str] = None,
                 service: Optional[str] = None):
        """
        The service endpoint properties.
        :param Sequence[str] locations: A list of locations.
        :param str provisioning_state: The provisioning state of the resource.
        :param str service: The type of the endpoint service.
        """
        ServiceEndpointPropertiesFormatResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            locations=locations,
            provisioning_state=provisioning_state,
            service=service,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             locations: Optional[Sequence[str]] = None,
             provisioning_state: Optional[str] = None,
             service: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']

        if locations is not None:
            _setter("locations", locations)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if service is not None:
            _setter("service", service)

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        """
        A list of locations.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state of the resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The type of the endpoint service.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class SubResourceResponse(dict):
    """
    Reference to another subresource.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Reference to another subresource.
        :param str id: Resource ID.
        """
        SubResourceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SubnetResponse(dict):
    """
    Subnet in a virtual network resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceEndpoints":
            suggest = "interface_endpoints"
        elif key == "ipConfigurationProfiles":
            suggest = "ip_configuration_profiles"
        elif key == "ipConfigurations":
            suggest = "ip_configurations"
        elif key == "addressPrefix":
            suggest = "address_prefix"
        elif key == "addressPrefixes":
            suggest = "address_prefixes"
        elif key == "natGateway":
            suggest = "nat_gateway"
        elif key == "networkSecurityGroup":
            suggest = "network_security_group"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "resourceNavigationLinks":
            suggest = "resource_navigation_links"
        elif key == "routeTable":
            suggest = "route_table"
        elif key == "serviceAssociationLinks":
            suggest = "service_association_links"
        elif key == "serviceEndpointPolicies":
            suggest = "service_endpoint_policies"
        elif key == "serviceEndpoints":
            suggest = "service_endpoints"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubnetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubnetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubnetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_endpoints: Sequence['outputs.InterfaceEndpointResponse'],
                 ip_configuration_profiles: Sequence['outputs.IPConfigurationProfileResponse'],
                 ip_configurations: Sequence['outputs.IPConfigurationResponse'],
                 purpose: str,
                 address_prefix: Optional[str] = None,
                 address_prefixes: Optional[Sequence[str]] = None,
                 delegations: Optional[Sequence['outputs.DelegationResponse']] = None,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 nat_gateway: Optional['outputs.SubResourceResponse'] = None,
                 network_security_group: Optional['outputs.NetworkSecurityGroupResponse'] = None,
                 provisioning_state: Optional[str] = None,
                 resource_navigation_links: Optional[Sequence['outputs.ResourceNavigationLinkResponse']] = None,
                 route_table: Optional['outputs.RouteTableResponse'] = None,
                 service_association_links: Optional[Sequence['outputs.ServiceAssociationLinkResponse']] = None,
                 service_endpoint_policies: Optional[Sequence['outputs.ServiceEndpointPolicyResponse']] = None,
                 service_endpoints: Optional[Sequence['outputs.ServiceEndpointPropertiesFormatResponse']] = None):
        """
        Subnet in a virtual network resource.
        :param Sequence['InterfaceEndpointResponse'] interface_endpoints: An array of references to interface endpoints 
        :param Sequence['IPConfigurationProfileResponse'] ip_configuration_profiles: Array of IP configuration profiles which reference this subnet.
        :param Sequence['IPConfigurationResponse'] ip_configurations: Gets an array of references to the network interface IP configurations using subnet.
        :param str purpose: A read-only string identifying the intention of use for this subnet based on delegations and other user-defined properties.
        :param str address_prefix: The address prefix for the subnet.
        :param Sequence[str] address_prefixes: List of  address prefixes for the subnet.
        :param Sequence['DelegationResponse'] delegations: Gets an array of references to the delegations on the subnet.
        :param str etag: A unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str name: The name of the resource that is unique within a resource group. This name can be used to access the resource.
        :param 'SubResourceResponse' nat_gateway: Nat gateway associated with this subnet.
        :param 'NetworkSecurityGroupResponse' network_security_group: The reference of the NetworkSecurityGroup resource.
        :param str provisioning_state: The provisioning state of the resource.
        :param Sequence['ResourceNavigationLinkResponse'] resource_navigation_links: Gets an array of references to the external resources using subnet.
        :param 'RouteTableResponse' route_table: The reference of the RouteTable resource.
        :param Sequence['ServiceAssociationLinkResponse'] service_association_links: Gets an array of references to services injecting into this subnet.
        :param Sequence['ServiceEndpointPolicyResponse'] service_endpoint_policies: An array of service endpoint policies.
        :param Sequence['ServiceEndpointPropertiesFormatResponse'] service_endpoints: An array of service endpoints.
        """
        SubnetResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interface_endpoints=interface_endpoints,
            ip_configuration_profiles=ip_configuration_profiles,
            ip_configurations=ip_configurations,
            purpose=purpose,
            address_prefix=address_prefix,
            address_prefixes=address_prefixes,
            delegations=delegations,
            etag=etag,
            id=id,
            name=name,
            nat_gateway=nat_gateway,
            network_security_group=network_security_group,
            provisioning_state=provisioning_state,
            resource_navigation_links=resource_navigation_links,
            route_table=route_table,
            service_association_links=service_association_links,
            service_endpoint_policies=service_endpoint_policies,
            service_endpoints=service_endpoints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interface_endpoints: Optional[Sequence['outputs.InterfaceEndpointResponse']] = None,
             ip_configuration_profiles: Optional[Sequence['outputs.IPConfigurationProfileResponse']] = None,
             ip_configurations: Optional[Sequence['outputs.IPConfigurationResponse']] = None,
             purpose: Optional[str] = None,
             address_prefix: Optional[str] = None,
             address_prefixes: Optional[Sequence[str]] = None,
             delegations: Optional[Sequence['outputs.DelegationResponse']] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             nat_gateway: Optional['outputs.SubResourceResponse'] = None,
             network_security_group: Optional['outputs.NetworkSecurityGroupResponse'] = None,
             provisioning_state: Optional[str] = None,
             resource_navigation_links: Optional[Sequence['outputs.ResourceNavigationLinkResponse']] = None,
             route_table: Optional['outputs.RouteTableResponse'] = None,
             service_association_links: Optional[Sequence['outputs.ServiceAssociationLinkResponse']] = None,
             service_endpoint_policies: Optional[Sequence['outputs.ServiceEndpointPolicyResponse']] = None,
             service_endpoints: Optional[Sequence['outputs.ServiceEndpointPropertiesFormatResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if interface_endpoints is None and 'interfaceEndpoints' in kwargs:
            interface_endpoints = kwargs['interfaceEndpoints']
        if interface_endpoints is None:
            raise TypeError("Missing 'interface_endpoints' argument")
        if ip_configuration_profiles is None and 'ipConfigurationProfiles' in kwargs:
            ip_configuration_profiles = kwargs['ipConfigurationProfiles']
        if ip_configuration_profiles is None:
            raise TypeError("Missing 'ip_configuration_profiles' argument")
        if ip_configurations is None and 'ipConfigurations' in kwargs:
            ip_configurations = kwargs['ipConfigurations']
        if ip_configurations is None:
            raise TypeError("Missing 'ip_configurations' argument")
        if purpose is None:
            raise TypeError("Missing 'purpose' argument")
        if address_prefix is None and 'addressPrefix' in kwargs:
            address_prefix = kwargs['addressPrefix']
        if address_prefixes is None and 'addressPrefixes' in kwargs:
            address_prefixes = kwargs['addressPrefixes']
        if nat_gateway is None and 'natGateway' in kwargs:
            nat_gateway = kwargs['natGateway']
        if network_security_group is None and 'networkSecurityGroup' in kwargs:
            network_security_group = kwargs['networkSecurityGroup']
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if resource_navigation_links is None and 'resourceNavigationLinks' in kwargs:
            resource_navigation_links = kwargs['resourceNavigationLinks']
        if route_table is None and 'routeTable' in kwargs:
            route_table = kwargs['routeTable']
        if service_association_links is None and 'serviceAssociationLinks' in kwargs:
            service_association_links = kwargs['serviceAssociationLinks']
        if service_endpoint_policies is None and 'serviceEndpointPolicies' in kwargs:
            service_endpoint_policies = kwargs['serviceEndpointPolicies']
        if service_endpoints is None and 'serviceEndpoints' in kwargs:
            service_endpoints = kwargs['serviceEndpoints']

        _setter("interface_endpoints", interface_endpoints)
        _setter("ip_configuration_profiles", ip_configuration_profiles)
        _setter("ip_configurations", ip_configurations)
        _setter("purpose", purpose)
        if address_prefix is not None:
            _setter("address_prefix", address_prefix)
        if address_prefixes is not None:
            _setter("address_prefixes", address_prefixes)
        if delegations is not None:
            _setter("delegations", delegations)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if nat_gateway is not None:
            _setter("nat_gateway", nat_gateway)
        if network_security_group is not None:
            _setter("network_security_group", network_security_group)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if resource_navigation_links is not None:
            _setter("resource_navigation_links", resource_navigation_links)
        if route_table is not None:
            _setter("route_table", route_table)
        if service_association_links is not None:
            _setter("service_association_links", service_association_links)
        if service_endpoint_policies is not None:
            _setter("service_endpoint_policies", service_endpoint_policies)
        if service_endpoints is not None:
            _setter("service_endpoints", service_endpoints)

    @property
    @pulumi.getter(name="interfaceEndpoints")
    def interface_endpoints(self) -> Sequence['outputs.InterfaceEndpointResponse']:
        """
        An array of references to interface endpoints 
        """
        return pulumi.get(self, "interface_endpoints")

    @property
    @pulumi.getter(name="ipConfigurationProfiles")
    def ip_configuration_profiles(self) -> Sequence['outputs.IPConfigurationProfileResponse']:
        """
        Array of IP configuration profiles which reference this subnet.
        """
        return pulumi.get(self, "ip_configuration_profiles")

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> Sequence['outputs.IPConfigurationResponse']:
        """
        Gets an array of references to the network interface IP configurations using subnet.
        """
        return pulumi.get(self, "ip_configurations")

    @property
    @pulumi.getter
    def purpose(self) -> str:
        """
        A read-only string identifying the intention of use for this subnet based on delegations and other user-defined properties.
        """
        return pulumi.get(self, "purpose")

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[str]:
        """
        The address prefix for the subnet.
        """
        return pulumi.get(self, "address_prefix")

    @property
    @pulumi.getter(name="addressPrefixes")
    def address_prefixes(self) -> Optional[Sequence[str]]:
        """
        List of  address prefixes for the subnet.
        """
        return pulumi.get(self, "address_prefixes")

    @property
    @pulumi.getter
    def delegations(self) -> Optional[Sequence['outputs.DelegationResponse']]:
        """
        Gets an array of references to the delegations on the subnet.
        """
        return pulumi.get(self, "delegations")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        A unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the resource that is unique within a resource group. This name can be used to access the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="natGateway")
    def nat_gateway(self) -> Optional['outputs.SubResourceResponse']:
        """
        Nat gateway associated with this subnet.
        """
        return pulumi.get(self, "nat_gateway")

    @property
    @pulumi.getter(name="networkSecurityGroup")
    def network_security_group(self) -> Optional['outputs.NetworkSecurityGroupResponse']:
        """
        The reference of the NetworkSecurityGroup resource.
        """
        return pulumi.get(self, "network_security_group")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state of the resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="resourceNavigationLinks")
    def resource_navigation_links(self) -> Optional[Sequence['outputs.ResourceNavigationLinkResponse']]:
        """
        Gets an array of references to the external resources using subnet.
        """
        return pulumi.get(self, "resource_navigation_links")

    @property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional['outputs.RouteTableResponse']:
        """
        The reference of the RouteTable resource.
        """
        return pulumi.get(self, "route_table")

    @property
    @pulumi.getter(name="serviceAssociationLinks")
    def service_association_links(self) -> Optional[Sequence['outputs.ServiceAssociationLinkResponse']]:
        """
        Gets an array of references to services injecting into this subnet.
        """
        return pulumi.get(self, "service_association_links")

    @property
    @pulumi.getter(name="serviceEndpointPolicies")
    def service_endpoint_policies(self) -> Optional[Sequence['outputs.ServiceEndpointPolicyResponse']]:
        """
        An array of service endpoint policies.
        """
        return pulumi.get(self, "service_endpoint_policies")

    @property
    @pulumi.getter(name="serviceEndpoints")
    def service_endpoints(self) -> Optional[Sequence['outputs.ServiceEndpointPropertiesFormatResponse']]:
        """
        An array of service endpoints.
        """
        return pulumi.get(self, "service_endpoints")


@pulumi.output_type
class VirtualNetworkTapResponse(dict):
    """
    Virtual Network Tap resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaceTapConfigurations":
            suggest = "network_interface_tap_configurations"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "resourceGuid":
            suggest = "resource_guid"
        elif key == "destinationLoadBalancerFrontEndIPConfiguration":
            suggest = "destination_load_balancer_front_end_ip_configuration"
        elif key == "destinationNetworkInterfaceIPConfiguration":
            suggest = "destination_network_interface_ip_configuration"
        elif key == "destinationPort":
            suggest = "destination_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualNetworkTapResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualNetworkTapResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualNetworkTapResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 network_interface_tap_configurations: Sequence['outputs.NetworkInterfaceTapConfigurationResponse'],
                 provisioning_state: str,
                 resource_guid: str,
                 type: str,
                 destination_load_balancer_front_end_ip_configuration: Optional['outputs.FrontendIPConfigurationResponse'] = None,
                 destination_network_interface_ip_configuration: Optional['outputs.NetworkInterfaceIPConfigurationResponse'] = None,
                 destination_port: Optional[int] = None,
                 etag: Optional[str] = None,
                 id: Optional[str] = None,
                 location: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Virtual Network Tap resource
        :param str name: Resource name.
        :param Sequence['NetworkInterfaceTapConfigurationResponse'] network_interface_tap_configurations: Specifies the list of resource IDs for the network interface IP configuration that needs to be tapped.
        :param str provisioning_state: The provisioning state of the virtual network tap. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        :param str resource_guid: The resourceGuid property of the virtual network tap.
        :param str type: Resource type.
        :param 'FrontendIPConfigurationResponse' destination_load_balancer_front_end_ip_configuration: The reference to the private IP address on the internal Load Balancer that will receive the tap
        :param 'NetworkInterfaceIPConfigurationResponse' destination_network_interface_ip_configuration: The reference to the private IP Address of the collector nic that will receive the tap
        :param int destination_port: The VXLAN destination port that will receive the tapped traffic.
        :param str etag: Gets a unique read-only string that changes whenever the resource is updated.
        :param str id: Resource ID.
        :param str location: Resource location.
        :param Mapping[str, str] tags: Resource tags.
        """
        VirtualNetworkTapResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            network_interface_tap_configurations=network_interface_tap_configurations,
            provisioning_state=provisioning_state,
            resource_guid=resource_guid,
            type=type,
            destination_load_balancer_front_end_ip_configuration=destination_load_balancer_front_end_ip_configuration,
            destination_network_interface_ip_configuration=destination_network_interface_ip_configuration,
            destination_port=destination_port,
            etag=etag,
            id=id,
            location=location,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             network_interface_tap_configurations: Optional[Sequence['outputs.NetworkInterfaceTapConfigurationResponse']] = None,
             provisioning_state: Optional[str] = None,
             resource_guid: Optional[str] = None,
             type: Optional[str] = None,
             destination_load_balancer_front_end_ip_configuration: Optional['outputs.FrontendIPConfigurationResponse'] = None,
             destination_network_interface_ip_configuration: Optional['outputs.NetworkInterfaceIPConfigurationResponse'] = None,
             destination_port: Optional[int] = None,
             etag: Optional[str] = None,
             id: Optional[str] = None,
             location: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if network_interface_tap_configurations is None and 'networkInterfaceTapConfigurations' in kwargs:
            network_interface_tap_configurations = kwargs['networkInterfaceTapConfigurations']
        if network_interface_tap_configurations is None:
            raise TypeError("Missing 'network_interface_tap_configurations' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if resource_guid is None and 'resourceGuid' in kwargs:
            resource_guid = kwargs['resourceGuid']
        if resource_guid is None:
            raise TypeError("Missing 'resource_guid' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if destination_load_balancer_front_end_ip_configuration is None and 'destinationLoadBalancerFrontEndIPConfiguration' in kwargs:
            destination_load_balancer_front_end_ip_configuration = kwargs['destinationLoadBalancerFrontEndIPConfiguration']
        if destination_network_interface_ip_configuration is None and 'destinationNetworkInterfaceIPConfiguration' in kwargs:
            destination_network_interface_ip_configuration = kwargs['destinationNetworkInterfaceIPConfiguration']
        if destination_port is None and 'destinationPort' in kwargs:
            destination_port = kwargs['destinationPort']

        _setter("name", name)
        _setter("network_interface_tap_configurations", network_interface_tap_configurations)
        _setter("provisioning_state", provisioning_state)
        _setter("resource_guid", resource_guid)
        _setter("type", type)
        if destination_load_balancer_front_end_ip_configuration is not None:
            _setter("destination_load_balancer_front_end_ip_configuration", destination_load_balancer_front_end_ip_configuration)
        if destination_network_interface_ip_configuration is not None:
            _setter("destination_network_interface_ip_configuration", destination_network_interface_ip_configuration)
        if destination_port is not None:
            _setter("destination_port", destination_port)
        if etag is not None:
            _setter("etag", etag)
        if id is not None:
            _setter("id", id)
        if location is not None:
            _setter("location", location)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkInterfaceTapConfigurations")
    def network_interface_tap_configurations(self) -> Sequence['outputs.NetworkInterfaceTapConfigurationResponse']:
        """
        Specifies the list of resource IDs for the network interface IP configuration that needs to be tapped.
        """
        return pulumi.get(self, "network_interface_tap_configurations")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the virtual network tap. Possible values are: 'Updating', 'Deleting', and 'Failed'.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="resourceGuid")
    def resource_guid(self) -> str:
        """
        The resourceGuid property of the virtual network tap.
        """
        return pulumi.get(self, "resource_guid")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="destinationLoadBalancerFrontEndIPConfiguration")
    def destination_load_balancer_front_end_ip_configuration(self) -> Optional['outputs.FrontendIPConfigurationResponse']:
        """
        The reference to the private IP address on the internal Load Balancer that will receive the tap
        """
        return pulumi.get(self, "destination_load_balancer_front_end_ip_configuration")

    @property
    @pulumi.getter(name="destinationNetworkInterfaceIPConfiguration")
    def destination_network_interface_ip_configuration(self) -> Optional['outputs.NetworkInterfaceIPConfigurationResponse']:
        """
        The reference to the private IP Address of the collector nic that will receive the tap
        """
        return pulumi.get(self, "destination_network_interface_ip_configuration")

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[int]:
        """
        The VXLAN destination port that will receive the tapped traffic.
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter
    def etag(self) -> Optional[str]:
        """
        Gets a unique read-only string that changes whenever the resource is updated.
        """
        return pulumi.get(self, "etag")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        Resource location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


