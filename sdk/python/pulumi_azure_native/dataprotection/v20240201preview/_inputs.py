# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AbsoluteDeleteOptionArgs',
    'AbsoluteDeleteOptionArgsDict',
    'AdhocBasedTaggingCriteriaArgs',
    'AdhocBasedTaggingCriteriaArgsDict',
    'AdhocBasedTriggerContextArgs',
    'AdhocBasedTriggerContextArgsDict',
    'AzureBackupParamsArgs',
    'AzureBackupParamsArgsDict',
    'AzureBackupRuleArgs',
    'AzureBackupRuleArgsDict',
    'AzureMonitorAlertSettingsArgs',
    'AzureMonitorAlertSettingsArgsDict',
    'AzureOperationalStoreParametersArgs',
    'AzureOperationalStoreParametersArgsDict',
    'AzureRetentionRuleArgs',
    'AzureRetentionRuleArgsDict',
    'BackupInstanceArgs',
    'BackupInstanceArgsDict',
    'BackupPolicyArgs',
    'BackupPolicyArgsDict',
    'BackupScheduleArgs',
    'BackupScheduleArgsDict',
    'BackupVaultArgs',
    'BackupVaultArgsDict',
    'BlobBackupDatasourceParametersArgs',
    'BlobBackupDatasourceParametersArgsDict',
    'CmkKekIdentityArgs',
    'CmkKekIdentityArgsDict',
    'CmkKeyVaultPropertiesArgs',
    'CmkKeyVaultPropertiesArgsDict',
    'CopyOnExpiryOptionArgs',
    'CopyOnExpiryOptionArgsDict',
    'CrossRegionRestoreSettingsArgs',
    'CrossRegionRestoreSettingsArgsDict',
    'CrossSubscriptionRestoreSettingsArgs',
    'CrossSubscriptionRestoreSettingsArgsDict',
    'CustomCopyOptionArgs',
    'CustomCopyOptionArgsDict',
    'DataStoreInfoBaseArgs',
    'DataStoreInfoBaseArgsDict',
    'DatasourceSetArgs',
    'DatasourceSetArgsDict',
    'DatasourceArgs',
    'DatasourceArgsDict',
    'DayArgs',
    'DayArgsDict',
    'DefaultResourcePropertiesArgs',
    'DefaultResourcePropertiesArgsDict',
    'DppIdentityDetailsArgs',
    'DppIdentityDetailsArgsDict',
    'EncryptionSettingsArgs',
    'EncryptionSettingsArgsDict',
    'FeatureSettingsArgs',
    'FeatureSettingsArgsDict',
    'GenericBackupDatasourceParametersArgs',
    'GenericBackupDatasourceParametersArgsDict',
    'IdentityDetailsArgs',
    'IdentityDetailsArgsDict',
    'ImmediateCopyOptionArgs',
    'ImmediateCopyOptionArgsDict',
    'ImmutabilitySettingsArgs',
    'ImmutabilitySettingsArgsDict',
    'KubernetesClusterBackupDatasourceParametersArgs',
    'KubernetesClusterBackupDatasourceParametersArgsDict',
    'MonitoringSettingsArgs',
    'MonitoringSettingsArgsDict',
    'NamespacedNameResourceArgs',
    'NamespacedNameResourceArgsDict',
    'PolicyInfoArgs',
    'PolicyInfoArgsDict',
    'PolicyParametersArgs',
    'PolicyParametersArgsDict',
    'ResourceGuardOperationDetailArgs',
    'ResourceGuardOperationDetailArgsDict',
    'ResourceGuardProxyBaseArgs',
    'ResourceGuardProxyBaseArgsDict',
    'ResourceGuardArgs',
    'ResourceGuardArgsDict',
    'RetentionTagArgs',
    'RetentionTagArgsDict',
    'ScheduleBasedBackupCriteriaArgs',
    'ScheduleBasedBackupCriteriaArgsDict',
    'ScheduleBasedTriggerContextArgs',
    'ScheduleBasedTriggerContextArgsDict',
    'SecretStoreBasedAuthCredentialsArgs',
    'SecretStoreBasedAuthCredentialsArgsDict',
    'SecretStoreResourceArgs',
    'SecretStoreResourceArgsDict',
    'SecuritySettingsArgs',
    'SecuritySettingsArgsDict',
    'SoftDeleteSettingsArgs',
    'SoftDeleteSettingsArgsDict',
    'SourceLifeCycleArgs',
    'SourceLifeCycleArgsDict',
    'StorageSettingArgs',
    'StorageSettingArgsDict',
    'TaggingCriteriaArgs',
    'TaggingCriteriaArgsDict',
    'TargetCopySettingArgs',
    'TargetCopySettingArgsDict',
]

MYPY = False

if not MYPY:
    class AbsoluteDeleteOptionArgsDict(TypedDict):
        """
        Delete option with duration
        """
        duration: pulumi.Input[str]
        """
        Duration of deletion after given timespan
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'AbsoluteDeleteOption'.
        """
elif False:
    AbsoluteDeleteOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AbsoluteDeleteOptionArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[str],
                 object_type: pulumi.Input[str]):
        """
        Delete option with duration
        :param pulumi.Input[str] duration: Duration of deletion after given timespan
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'AbsoluteDeleteOption'.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "object_type", 'AbsoluteDeleteOption')

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[str]:
        """
        Duration of deletion after given timespan
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'AbsoluteDeleteOption'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)


if not MYPY:
    class AdhocBasedTaggingCriteriaArgsDict(TypedDict):
        """
        Adhoc backup tagging criteria
        """
        tag_info: NotRequired[pulumi.Input['RetentionTagArgsDict']]
        """
        Retention tag information
        """
elif False:
    AdhocBasedTaggingCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdhocBasedTaggingCriteriaArgs:
    def __init__(__self__, *,
                 tag_info: Optional[pulumi.Input['RetentionTagArgs']] = None):
        """
        Adhoc backup tagging criteria
        :param pulumi.Input['RetentionTagArgs'] tag_info: Retention tag information
        """
        if tag_info is not None:
            pulumi.set(__self__, "tag_info", tag_info)

    @property
    @pulumi.getter(name="tagInfo")
    def tag_info(self) -> Optional[pulumi.Input['RetentionTagArgs']]:
        """
        Retention tag information
        """
        return pulumi.get(self, "tag_info")

    @tag_info.setter
    def tag_info(self, value: Optional[pulumi.Input['RetentionTagArgs']]):
        pulumi.set(self, "tag_info", value)


if not MYPY:
    class AdhocBasedTriggerContextArgsDict(TypedDict):
        """
        Adhoc trigger context
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'AdhocBasedTriggerContext'.
        """
        tagging_criteria: pulumi.Input['AdhocBasedTaggingCriteriaArgsDict']
        """
        Tagging Criteria containing retention tag for adhoc backup.
        """
elif False:
    AdhocBasedTriggerContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AdhocBasedTriggerContextArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[str],
                 tagging_criteria: pulumi.Input['AdhocBasedTaggingCriteriaArgs']):
        """
        Adhoc trigger context
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'AdhocBasedTriggerContext'.
        :param pulumi.Input['AdhocBasedTaggingCriteriaArgs'] tagging_criteria: Tagging Criteria containing retention tag for adhoc backup.
        """
        pulumi.set(__self__, "object_type", 'AdhocBasedTriggerContext')
        pulumi.set(__self__, "tagging_criteria", tagging_criteria)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'AdhocBasedTriggerContext'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="taggingCriteria")
    def tagging_criteria(self) -> pulumi.Input['AdhocBasedTaggingCriteriaArgs']:
        """
        Tagging Criteria containing retention tag for adhoc backup.
        """
        return pulumi.get(self, "tagging_criteria")

    @tagging_criteria.setter
    def tagging_criteria(self, value: pulumi.Input['AdhocBasedTaggingCriteriaArgs']):
        pulumi.set(self, "tagging_criteria", value)


if not MYPY:
    class AzureBackupParamsArgsDict(TypedDict):
        """
        Azure backup parameters
        """
        backup_type: pulumi.Input[str]
        """
        BackupType ; Full/Incremental etc
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'AzureBackupParams'.
        """
elif False:
    AzureBackupParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureBackupParamsArgs:
    def __init__(__self__, *,
                 backup_type: pulumi.Input[str],
                 object_type: pulumi.Input[str]):
        """
        Azure backup parameters
        :param pulumi.Input[str] backup_type: BackupType ; Full/Incremental etc
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'AzureBackupParams'.
        """
        pulumi.set(__self__, "backup_type", backup_type)
        pulumi.set(__self__, "object_type", 'AzureBackupParams')

    @property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> pulumi.Input[str]:
        """
        BackupType ; Full/Incremental etc
        """
        return pulumi.get(self, "backup_type")

    @backup_type.setter
    def backup_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_type", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'AzureBackupParams'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)


if not MYPY:
    class AzureBackupRuleArgsDict(TypedDict):
        """
        Azure backup rule
        """
        data_store: pulumi.Input['DataStoreInfoBaseArgsDict']
        """
        DataStoreInfo base
        """
        name: pulumi.Input[str]
        object_type: pulumi.Input[str]
        """

        Expected value is 'AzureBackupRule'.
        """
        trigger: pulumi.Input[Union['AdhocBasedTriggerContextArgsDict', 'ScheduleBasedTriggerContextArgsDict']]
        """
        Trigger context
        """
        backup_parameters: NotRequired[pulumi.Input['AzureBackupParamsArgsDict']]
        """
        BackupParameters base
        """
elif False:
    AzureBackupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureBackupRuleArgs:
    def __init__(__self__, *,
                 data_store: pulumi.Input['DataStoreInfoBaseArgs'],
                 name: pulumi.Input[str],
                 object_type: pulumi.Input[str],
                 trigger: pulumi.Input[Union['AdhocBasedTriggerContextArgs', 'ScheduleBasedTriggerContextArgs']],
                 backup_parameters: Optional[pulumi.Input['AzureBackupParamsArgs']] = None):
        """
        Azure backup rule
        :param pulumi.Input['DataStoreInfoBaseArgs'] data_store: DataStoreInfo base
        :param pulumi.Input[str] object_type: 
               Expected value is 'AzureBackupRule'.
        :param pulumi.Input[Union['AdhocBasedTriggerContextArgs', 'ScheduleBasedTriggerContextArgs']] trigger: Trigger context
        :param pulumi.Input['AzureBackupParamsArgs'] backup_parameters: BackupParameters base
        """
        pulumi.set(__self__, "data_store", data_store)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "object_type", 'AzureBackupRule')
        pulumi.set(__self__, "trigger", trigger)
        if backup_parameters is not None:
            pulumi.set(__self__, "backup_parameters", backup_parameters)

    @property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> pulumi.Input['DataStoreInfoBaseArgs']:
        """
        DataStoreInfo base
        """
        return pulumi.get(self, "data_store")

    @data_store.setter
    def data_store(self, value: pulumi.Input['DataStoreInfoBaseArgs']):
        pulumi.set(self, "data_store", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """

        Expected value is 'AzureBackupRule'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter
    def trigger(self) -> pulumi.Input[Union['AdhocBasedTriggerContextArgs', 'ScheduleBasedTriggerContextArgs']]:
        """
        Trigger context
        """
        return pulumi.get(self, "trigger")

    @trigger.setter
    def trigger(self, value: pulumi.Input[Union['AdhocBasedTriggerContextArgs', 'ScheduleBasedTriggerContextArgs']]):
        pulumi.set(self, "trigger", value)

    @property
    @pulumi.getter(name="backupParameters")
    def backup_parameters(self) -> Optional[pulumi.Input['AzureBackupParamsArgs']]:
        """
        BackupParameters base
        """
        return pulumi.get(self, "backup_parameters")

    @backup_parameters.setter
    def backup_parameters(self, value: Optional[pulumi.Input['AzureBackupParamsArgs']]):
        pulumi.set(self, "backup_parameters", value)


if not MYPY:
    class AzureMonitorAlertSettingsArgsDict(TypedDict):
        """
        Settings for Azure Monitor based alerts
        """
        alerts_for_all_job_failures: NotRequired[pulumi.Input[Union[str, 'AlertsState']]]
elif False:
    AzureMonitorAlertSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureMonitorAlertSettingsArgs:
    def __init__(__self__, *,
                 alerts_for_all_job_failures: Optional[pulumi.Input[Union[str, 'AlertsState']]] = None):
        """
        Settings for Azure Monitor based alerts
        """
        if alerts_for_all_job_failures is not None:
            pulumi.set(__self__, "alerts_for_all_job_failures", alerts_for_all_job_failures)

    @property
    @pulumi.getter(name="alertsForAllJobFailures")
    def alerts_for_all_job_failures(self) -> Optional[pulumi.Input[Union[str, 'AlertsState']]]:
        return pulumi.get(self, "alerts_for_all_job_failures")

    @alerts_for_all_job_failures.setter
    def alerts_for_all_job_failures(self, value: Optional[pulumi.Input[Union[str, 'AlertsState']]]):
        pulumi.set(self, "alerts_for_all_job_failures", value)


if not MYPY:
    class AzureOperationalStoreParametersArgsDict(TypedDict):
        """
        Parameters for Operational-Tier DataStore
        """
        data_store_type: pulumi.Input[Union[str, 'DataStoreTypes']]
        """
        type of datastore; Operational/Vault/Archive
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'AzureOperationalStoreParameters'.
        """
        resource_group_id: NotRequired[pulumi.Input[str]]
        """
        Gets or sets the Snapshot Resource Group Uri.
        """
elif False:
    AzureOperationalStoreParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureOperationalStoreParametersArgs:
    def __init__(__self__, *,
                 data_store_type: pulumi.Input[Union[str, 'DataStoreTypes']],
                 object_type: pulumi.Input[str],
                 resource_group_id: Optional[pulumi.Input[str]] = None):
        """
        Parameters for Operational-Tier DataStore
        :param pulumi.Input[Union[str, 'DataStoreTypes']] data_store_type: type of datastore; Operational/Vault/Archive
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'AzureOperationalStoreParameters'.
        :param pulumi.Input[str] resource_group_id: Gets or sets the Snapshot Resource Group Uri.
        """
        pulumi.set(__self__, "data_store_type", data_store_type)
        pulumi.set(__self__, "object_type", 'AzureOperationalStoreParameters')
        if resource_group_id is not None:
            pulumi.set(__self__, "resource_group_id", resource_group_id)

    @property
    @pulumi.getter(name="dataStoreType")
    def data_store_type(self) -> pulumi.Input[Union[str, 'DataStoreTypes']]:
        """
        type of datastore; Operational/Vault/Archive
        """
        return pulumi.get(self, "data_store_type")

    @data_store_type.setter
    def data_store_type(self, value: pulumi.Input[Union[str, 'DataStoreTypes']]):
        pulumi.set(self, "data_store_type", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'AzureOperationalStoreParameters'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the Snapshot Resource Group Uri.
        """
        return pulumi.get(self, "resource_group_id")

    @resource_group_id.setter
    def resource_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group_id", value)


if not MYPY:
    class AzureRetentionRuleArgsDict(TypedDict):
        """
        Azure retention rule
        """
        lifecycles: pulumi.Input[Sequence[pulumi.Input['SourceLifeCycleArgsDict']]]
        name: pulumi.Input[str]
        object_type: pulumi.Input[str]
        """

        Expected value is 'AzureRetentionRule'.
        """
        is_default: NotRequired[pulumi.Input[bool]]
elif False:
    AzureRetentionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureRetentionRuleArgs:
    def __init__(__self__, *,
                 lifecycles: pulumi.Input[Sequence[pulumi.Input['SourceLifeCycleArgs']]],
                 name: pulumi.Input[str],
                 object_type: pulumi.Input[str],
                 is_default: Optional[pulumi.Input[bool]] = None):
        """
        Azure retention rule
        :param pulumi.Input[str] object_type: 
               Expected value is 'AzureRetentionRule'.
        """
        pulumi.set(__self__, "lifecycles", lifecycles)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "object_type", 'AzureRetentionRule')
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)

    @property
    @pulumi.getter
    def lifecycles(self) -> pulumi.Input[Sequence[pulumi.Input['SourceLifeCycleArgs']]]:
        return pulumi.get(self, "lifecycles")

    @lifecycles.setter
    def lifecycles(self, value: pulumi.Input[Sequence[pulumi.Input['SourceLifeCycleArgs']]]):
        pulumi.set(self, "lifecycles", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """

        Expected value is 'AzureRetentionRule'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_default", value)


if not MYPY:
    class BackupInstanceArgsDict(TypedDict):
        """
        Backup Instance
        """
        data_source_info: pulumi.Input['DatasourceArgsDict']
        """
        Gets or sets the data source information.
        """
        object_type: pulumi.Input[str]
        policy_info: pulumi.Input['PolicyInfoArgsDict']
        """
        Gets or sets the policy information.
        """
        data_source_set_info: NotRequired[pulumi.Input['DatasourceSetArgsDict']]
        """
        Gets or sets the data source set information.
        """
        datasource_auth_credentials: NotRequired[pulumi.Input['SecretStoreBasedAuthCredentialsArgsDict']]
        """
        Credentials to use to authenticate with data source provider.
        """
        friendly_name: NotRequired[pulumi.Input[str]]
        """
        Gets or sets the Backup Instance friendly name.
        """
        identity_details: NotRequired[pulumi.Input['IdentityDetailsArgsDict']]
        """
        Contains information of the Identity Details for the BI.
        If it is null, default will be considered as System Assigned.
        """
        validation_type: NotRequired[pulumi.Input[Union[str, 'ValidationType']]]
        """
        Specifies the type of validation. In case of DeepValidation, all validations from /validateForBackup API will run again.
        """
elif False:
    BackupInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupInstanceArgs:
    def __init__(__self__, *,
                 data_source_info: pulumi.Input['DatasourceArgs'],
                 object_type: pulumi.Input[str],
                 policy_info: pulumi.Input['PolicyInfoArgs'],
                 data_source_set_info: Optional[pulumi.Input['DatasourceSetArgs']] = None,
                 datasource_auth_credentials: Optional[pulumi.Input['SecretStoreBasedAuthCredentialsArgs']] = None,
                 friendly_name: Optional[pulumi.Input[str]] = None,
                 identity_details: Optional[pulumi.Input['IdentityDetailsArgs']] = None,
                 validation_type: Optional[pulumi.Input[Union[str, 'ValidationType']]] = None):
        """
        Backup Instance
        :param pulumi.Input['DatasourceArgs'] data_source_info: Gets or sets the data source information.
        :param pulumi.Input['PolicyInfoArgs'] policy_info: Gets or sets the policy information.
        :param pulumi.Input['DatasourceSetArgs'] data_source_set_info: Gets or sets the data source set information.
        :param pulumi.Input['SecretStoreBasedAuthCredentialsArgs'] datasource_auth_credentials: Credentials to use to authenticate with data source provider.
        :param pulumi.Input[str] friendly_name: Gets or sets the Backup Instance friendly name.
        :param pulumi.Input['IdentityDetailsArgs'] identity_details: Contains information of the Identity Details for the BI.
               If it is null, default will be considered as System Assigned.
        :param pulumi.Input[Union[str, 'ValidationType']] validation_type: Specifies the type of validation. In case of DeepValidation, all validations from /validateForBackup API will run again.
        """
        pulumi.set(__self__, "data_source_info", data_source_info)
        pulumi.set(__self__, "object_type", object_type)
        pulumi.set(__self__, "policy_info", policy_info)
        if data_source_set_info is not None:
            pulumi.set(__self__, "data_source_set_info", data_source_set_info)
        if datasource_auth_credentials is not None:
            pulumi.set(__self__, "datasource_auth_credentials", datasource_auth_credentials)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if identity_details is not None:
            pulumi.set(__self__, "identity_details", identity_details)
        if validation_type is not None:
            pulumi.set(__self__, "validation_type", validation_type)

    @property
    @pulumi.getter(name="dataSourceInfo")
    def data_source_info(self) -> pulumi.Input['DatasourceArgs']:
        """
        Gets or sets the data source information.
        """
        return pulumi.get(self, "data_source_info")

    @data_source_info.setter
    def data_source_info(self, value: pulumi.Input['DatasourceArgs']):
        pulumi.set(self, "data_source_info", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="policyInfo")
    def policy_info(self) -> pulumi.Input['PolicyInfoArgs']:
        """
        Gets or sets the policy information.
        """
        return pulumi.get(self, "policy_info")

    @policy_info.setter
    def policy_info(self, value: pulumi.Input['PolicyInfoArgs']):
        pulumi.set(self, "policy_info", value)

    @property
    @pulumi.getter(name="dataSourceSetInfo")
    def data_source_set_info(self) -> Optional[pulumi.Input['DatasourceSetArgs']]:
        """
        Gets or sets the data source set information.
        """
        return pulumi.get(self, "data_source_set_info")

    @data_source_set_info.setter
    def data_source_set_info(self, value: Optional[pulumi.Input['DatasourceSetArgs']]):
        pulumi.set(self, "data_source_set_info", value)

    @property
    @pulumi.getter(name="datasourceAuthCredentials")
    def datasource_auth_credentials(self) -> Optional[pulumi.Input['SecretStoreBasedAuthCredentialsArgs']]:
        """
        Credentials to use to authenticate with data source provider.
        """
        return pulumi.get(self, "datasource_auth_credentials")

    @datasource_auth_credentials.setter
    def datasource_auth_credentials(self, value: Optional[pulumi.Input['SecretStoreBasedAuthCredentialsArgs']]):
        pulumi.set(self, "datasource_auth_credentials", value)

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the Backup Instance friendly name.
        """
        return pulumi.get(self, "friendly_name")

    @friendly_name.setter
    def friendly_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "friendly_name", value)

    @property
    @pulumi.getter(name="identityDetails")
    def identity_details(self) -> Optional[pulumi.Input['IdentityDetailsArgs']]:
        """
        Contains information of the Identity Details for the BI.
        If it is null, default will be considered as System Assigned.
        """
        return pulumi.get(self, "identity_details")

    @identity_details.setter
    def identity_details(self, value: Optional[pulumi.Input['IdentityDetailsArgs']]):
        pulumi.set(self, "identity_details", value)

    @property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> Optional[pulumi.Input[Union[str, 'ValidationType']]]:
        """
        Specifies the type of validation. In case of DeepValidation, all validations from /validateForBackup API will run again.
        """
        return pulumi.get(self, "validation_type")

    @validation_type.setter
    def validation_type(self, value: Optional[pulumi.Input[Union[str, 'ValidationType']]]):
        pulumi.set(self, "validation_type", value)


if not MYPY:
    class BackupPolicyArgsDict(TypedDict):
        """
        Rule based backup policy
        """
        datasource_types: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Type of datasource for the backup management
        """
        object_type: pulumi.Input[str]
        """

        Expected value is 'BackupPolicy'.
        """
        policy_rules: pulumi.Input[Sequence[pulumi.Input[Union['AzureBackupRuleArgsDict', 'AzureRetentionRuleArgsDict']]]]
        """
        Policy rule dictionary that contains rules for each backuptype i.e Full/Incremental/Logs etc
        """
elif False:
    BackupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPolicyArgs:
    def __init__(__self__, *,
                 datasource_types: pulumi.Input[Sequence[pulumi.Input[str]]],
                 object_type: pulumi.Input[str],
                 policy_rules: pulumi.Input[Sequence[pulumi.Input[Union['AzureBackupRuleArgs', 'AzureRetentionRuleArgs']]]]):
        """
        Rule based backup policy
        :param pulumi.Input[Sequence[pulumi.Input[str]]] datasource_types: Type of datasource for the backup management
        :param pulumi.Input[str] object_type: 
               Expected value is 'BackupPolicy'.
        :param pulumi.Input[Sequence[pulumi.Input[Union['AzureBackupRuleArgs', 'AzureRetentionRuleArgs']]]] policy_rules: Policy rule dictionary that contains rules for each backuptype i.e Full/Incremental/Logs etc
        """
        pulumi.set(__self__, "datasource_types", datasource_types)
        pulumi.set(__self__, "object_type", 'BackupPolicy')
        pulumi.set(__self__, "policy_rules", policy_rules)

    @property
    @pulumi.getter(name="datasourceTypes")
    def datasource_types(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Type of datasource for the backup management
        """
        return pulumi.get(self, "datasource_types")

    @datasource_types.setter
    def datasource_types(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "datasource_types", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """

        Expected value is 'BackupPolicy'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="policyRules")
    def policy_rules(self) -> pulumi.Input[Sequence[pulumi.Input[Union['AzureBackupRuleArgs', 'AzureRetentionRuleArgs']]]]:
        """
        Policy rule dictionary that contains rules for each backuptype i.e Full/Incremental/Logs etc
        """
        return pulumi.get(self, "policy_rules")

    @policy_rules.setter
    def policy_rules(self, value: pulumi.Input[Sequence[pulumi.Input[Union['AzureBackupRuleArgs', 'AzureRetentionRuleArgs']]]]):
        pulumi.set(self, "policy_rules", value)


if not MYPY:
    class BackupScheduleArgsDict(TypedDict):
        """
        Schedule for backup
        """
        repeating_time_intervals: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        ISO 8601 repeating time interval format
        """
        time_zone: NotRequired[pulumi.Input[str]]
        """
        Time zone for a schedule. Example: Pacific Standard Time
        """
elif False:
    BackupScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupScheduleArgs:
    def __init__(__self__, *,
                 repeating_time_intervals: pulumi.Input[Sequence[pulumi.Input[str]]],
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        Schedule for backup
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repeating_time_intervals: ISO 8601 repeating time interval format
        :param pulumi.Input[str] time_zone: Time zone for a schedule. Example: Pacific Standard Time
        """
        pulumi.set(__self__, "repeating_time_intervals", repeating_time_intervals)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="repeatingTimeIntervals")
    def repeating_time_intervals(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        ISO 8601 repeating time interval format
        """
        return pulumi.get(self, "repeating_time_intervals")

    @repeating_time_intervals.setter
    def repeating_time_intervals(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repeating_time_intervals", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Time zone for a schedule. Example: Pacific Standard Time
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class BackupVaultArgsDict(TypedDict):
        """
        Backup Vault
        """
        storage_settings: pulumi.Input[Sequence[pulumi.Input['StorageSettingArgsDict']]]
        """
        Storage Settings
        """
        feature_settings: NotRequired[pulumi.Input['FeatureSettingsArgsDict']]
        """
        Feature Settings
        """
        monitoring_settings: NotRequired[pulumi.Input['MonitoringSettingsArgsDict']]
        """
        Monitoring Settings
        """
        replicated_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of replicated regions for Backup Vault
        """
        security_settings: NotRequired[pulumi.Input['SecuritySettingsArgsDict']]
        """
        Security Settings
        """
elif False:
    BackupVaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupVaultArgs:
    def __init__(__self__, *,
                 storage_settings: pulumi.Input[Sequence[pulumi.Input['StorageSettingArgs']]],
                 feature_settings: Optional[pulumi.Input['FeatureSettingsArgs']] = None,
                 monitoring_settings: Optional[pulumi.Input['MonitoringSettingsArgs']] = None,
                 replicated_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 security_settings: Optional[pulumi.Input['SecuritySettingsArgs']] = None):
        """
        Backup Vault
        :param pulumi.Input[Sequence[pulumi.Input['StorageSettingArgs']]] storage_settings: Storage Settings
        :param pulumi.Input['FeatureSettingsArgs'] feature_settings: Feature Settings
        :param pulumi.Input['MonitoringSettingsArgs'] monitoring_settings: Monitoring Settings
        :param pulumi.Input[Sequence[pulumi.Input[str]]] replicated_regions: List of replicated regions for Backup Vault
        :param pulumi.Input['SecuritySettingsArgs'] security_settings: Security Settings
        """
        pulumi.set(__self__, "storage_settings", storage_settings)
        if feature_settings is not None:
            pulumi.set(__self__, "feature_settings", feature_settings)
        if monitoring_settings is not None:
            pulumi.set(__self__, "monitoring_settings", monitoring_settings)
        if replicated_regions is not None:
            pulumi.set(__self__, "replicated_regions", replicated_regions)
        if security_settings is not None:
            pulumi.set(__self__, "security_settings", security_settings)

    @property
    @pulumi.getter(name="storageSettings")
    def storage_settings(self) -> pulumi.Input[Sequence[pulumi.Input['StorageSettingArgs']]]:
        """
        Storage Settings
        """
        return pulumi.get(self, "storage_settings")

    @storage_settings.setter
    def storage_settings(self, value: pulumi.Input[Sequence[pulumi.Input['StorageSettingArgs']]]):
        pulumi.set(self, "storage_settings", value)

    @property
    @pulumi.getter(name="featureSettings")
    def feature_settings(self) -> Optional[pulumi.Input['FeatureSettingsArgs']]:
        """
        Feature Settings
        """
        return pulumi.get(self, "feature_settings")

    @feature_settings.setter
    def feature_settings(self, value: Optional[pulumi.Input['FeatureSettingsArgs']]):
        pulumi.set(self, "feature_settings", value)

    @property
    @pulumi.getter(name="monitoringSettings")
    def monitoring_settings(self) -> Optional[pulumi.Input['MonitoringSettingsArgs']]:
        """
        Monitoring Settings
        """
        return pulumi.get(self, "monitoring_settings")

    @monitoring_settings.setter
    def monitoring_settings(self, value: Optional[pulumi.Input['MonitoringSettingsArgs']]):
        pulumi.set(self, "monitoring_settings", value)

    @property
    @pulumi.getter(name="replicatedRegions")
    def replicated_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of replicated regions for Backup Vault
        """
        return pulumi.get(self, "replicated_regions")

    @replicated_regions.setter
    def replicated_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "replicated_regions", value)

    @property
    @pulumi.getter(name="securitySettings")
    def security_settings(self) -> Optional[pulumi.Input['SecuritySettingsArgs']]:
        """
        Security Settings
        """
        return pulumi.get(self, "security_settings")

    @security_settings.setter
    def security_settings(self, value: Optional[pulumi.Input['SecuritySettingsArgs']]):
        pulumi.set(self, "security_settings", value)


if not MYPY:
    class BlobBackupDatasourceParametersArgsDict(TypedDict):
        """
        Parameters to be used during configuration of backup of blobs
        """
        containers_list: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of containers to be backed up during configuration of backup of blobs
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'BlobBackupDatasourceParameters'.
        """
elif False:
    BlobBackupDatasourceParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BlobBackupDatasourceParametersArgs:
    def __init__(__self__, *,
                 containers_list: pulumi.Input[Sequence[pulumi.Input[str]]],
                 object_type: pulumi.Input[str]):
        """
        Parameters to be used during configuration of backup of blobs
        :param pulumi.Input[Sequence[pulumi.Input[str]]] containers_list: List of containers to be backed up during configuration of backup of blobs
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'BlobBackupDatasourceParameters'.
        """
        pulumi.set(__self__, "containers_list", containers_list)
        pulumi.set(__self__, "object_type", 'BlobBackupDatasourceParameters')

    @property
    @pulumi.getter(name="containersList")
    def containers_list(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of containers to be backed up during configuration of backup of blobs
        """
        return pulumi.get(self, "containers_list")

    @containers_list.setter
    def containers_list(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "containers_list", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'BlobBackupDatasourceParameters'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)


if not MYPY:
    class CmkKekIdentityArgsDict(TypedDict):
        """
        The details of the managed identity used for CMK
        """
        identity_id: NotRequired[pulumi.Input[str]]
        """
        The managed identity to be used which has access permissions to the Key Vault. Provide a value here in case identity types: 'UserAssigned' only.
        """
        identity_type: NotRequired[pulumi.Input[Union[str, 'IdentityType']]]
        """
        The identity type. 'SystemAssigned' and 'UserAssigned' are mutually exclusive. 'SystemAssigned' will use implicitly created managed identity.
        """
elif False:
    CmkKekIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CmkKekIdentityArgs:
    def __init__(__self__, *,
                 identity_id: Optional[pulumi.Input[str]] = None,
                 identity_type: Optional[pulumi.Input[Union[str, 'IdentityType']]] = None):
        """
        The details of the managed identity used for CMK
        :param pulumi.Input[str] identity_id: The managed identity to be used which has access permissions to the Key Vault. Provide a value here in case identity types: 'UserAssigned' only.
        :param pulumi.Input[Union[str, 'IdentityType']] identity_type: The identity type. 'SystemAssigned' and 'UserAssigned' are mutually exclusive. 'SystemAssigned' will use implicitly created managed identity.
        """
        if identity_id is not None:
            pulumi.set(__self__, "identity_id", identity_id)
        if identity_type is not None:
            pulumi.set(__self__, "identity_type", identity_type)

    @property
    @pulumi.getter(name="identityId")
    def identity_id(self) -> Optional[pulumi.Input[str]]:
        """
        The managed identity to be used which has access permissions to the Key Vault. Provide a value here in case identity types: 'UserAssigned' only.
        """
        return pulumi.get(self, "identity_id")

    @identity_id.setter
    def identity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_id", value)

    @property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> Optional[pulumi.Input[Union[str, 'IdentityType']]]:
        """
        The identity type. 'SystemAssigned' and 'UserAssigned' are mutually exclusive. 'SystemAssigned' will use implicitly created managed identity.
        """
        return pulumi.get(self, "identity_type")

    @identity_type.setter
    def identity_type(self, value: Optional[pulumi.Input[Union[str, 'IdentityType']]]):
        pulumi.set(self, "identity_type", value)


if not MYPY:
    class CmkKeyVaultPropertiesArgsDict(TypedDict):
        """
        The properties of the Key Vault which hosts CMK
        """
        key_uri: NotRequired[pulumi.Input[str]]
        """
        The key uri of the Customer Managed Key
        """
elif False:
    CmkKeyVaultPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CmkKeyVaultPropertiesArgs:
    def __init__(__self__, *,
                 key_uri: Optional[pulumi.Input[str]] = None):
        """
        The properties of the Key Vault which hosts CMK
        :param pulumi.Input[str] key_uri: The key uri of the Customer Managed Key
        """
        if key_uri is not None:
            pulumi.set(__self__, "key_uri", key_uri)

    @property
    @pulumi.getter(name="keyUri")
    def key_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The key uri of the Customer Managed Key
        """
        return pulumi.get(self, "key_uri")

    @key_uri.setter
    def key_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_uri", value)


if not MYPY:
    class CopyOnExpiryOptionArgsDict(TypedDict):
        """
        Copy on Expiry Option
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'CopyOnExpiryOption'.
        """
elif False:
    CopyOnExpiryOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CopyOnExpiryOptionArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[str]):
        """
        Copy on Expiry Option
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'CopyOnExpiryOption'.
        """
        pulumi.set(__self__, "object_type", 'CopyOnExpiryOption')

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'CopyOnExpiryOption'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)


if not MYPY:
    class CrossRegionRestoreSettingsArgsDict(TypedDict):
        state: NotRequired[pulumi.Input[Union[str, 'CrossRegionRestoreState']]]
        """
        CrossRegionRestore state
        """
elif False:
    CrossRegionRestoreSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrossRegionRestoreSettingsArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[Union[str, 'CrossRegionRestoreState']]] = None):
        """
        :param pulumi.Input[Union[str, 'CrossRegionRestoreState']] state: CrossRegionRestore state
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'CrossRegionRestoreState']]]:
        """
        CrossRegionRestore state
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'CrossRegionRestoreState']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class CrossSubscriptionRestoreSettingsArgsDict(TypedDict):
        """
        CrossSubscriptionRestore Settings
        """
        state: NotRequired[pulumi.Input[Union[str, 'CrossSubscriptionRestoreState']]]
        """
        CrossSubscriptionRestore state
        """
elif False:
    CrossSubscriptionRestoreSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CrossSubscriptionRestoreSettingsArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[Union[str, 'CrossSubscriptionRestoreState']]] = None):
        """
        CrossSubscriptionRestore Settings
        :param pulumi.Input[Union[str, 'CrossSubscriptionRestoreState']] state: CrossSubscriptionRestore state
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'CrossSubscriptionRestoreState']]]:
        """
        CrossSubscriptionRestore state
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'CrossSubscriptionRestoreState']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class CustomCopyOptionArgsDict(TypedDict):
        """
        Duration based custom options to copy
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'CustomCopyOption'.
        """
        duration: NotRequired[pulumi.Input[str]]
        """
        Data copied after given timespan
        """
elif False:
    CustomCopyOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomCopyOptionArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[str],
                 duration: Optional[pulumi.Input[str]] = None):
        """
        Duration based custom options to copy
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'CustomCopyOption'.
        :param pulumi.Input[str] duration: Data copied after given timespan
        """
        pulumi.set(__self__, "object_type", 'CustomCopyOption')
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'CustomCopyOption'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        Data copied after given timespan
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)


if not MYPY:
    class DataStoreInfoBaseArgsDict(TypedDict):
        """
        DataStoreInfo base
        """
        data_store_type: pulumi.Input[Union[str, 'DataStoreTypes']]
        """
        type of datastore; Operational/Vault/Archive
        """
        object_type: pulumi.Input[str]
        """
        Type of Datasource object, used to initialize the right inherited type
        """
elif False:
    DataStoreInfoBaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreInfoBaseArgs:
    def __init__(__self__, *,
                 data_store_type: pulumi.Input[Union[str, 'DataStoreTypes']],
                 object_type: pulumi.Input[str]):
        """
        DataStoreInfo base
        :param pulumi.Input[Union[str, 'DataStoreTypes']] data_store_type: type of datastore; Operational/Vault/Archive
        :param pulumi.Input[str] object_type: Type of Datasource object, used to initialize the right inherited type
        """
        pulumi.set(__self__, "data_store_type", data_store_type)
        pulumi.set(__self__, "object_type", object_type)

    @property
    @pulumi.getter(name="dataStoreType")
    def data_store_type(self) -> pulumi.Input[Union[str, 'DataStoreTypes']]:
        """
        type of datastore; Operational/Vault/Archive
        """
        return pulumi.get(self, "data_store_type")

    @data_store_type.setter
    def data_store_type(self, value: pulumi.Input[Union[str, 'DataStoreTypes']]):
        pulumi.set(self, "data_store_type", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of Datasource object, used to initialize the right inherited type
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)


if not MYPY:
    class DatasourceSetArgsDict(TypedDict):
        """
        DatasourceSet details of datasource to be backed up
        """
        resource_id: pulumi.Input[str]
        """
        Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will be the ID created by backup service via Fabric/Vault.
        """
        datasource_type: NotRequired[pulumi.Input[str]]
        """
        DatasourceType of the resource.
        """
        object_type: NotRequired[pulumi.Input[str]]
        """
        Type of Datasource object, used to initialize the right inherited type
        """
        resource_location: NotRequired[pulumi.Input[str]]
        """
        Location of datasource.
        """
        resource_name: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the resource in the context of parent.
        """
        resource_properties: NotRequired[pulumi.Input['DefaultResourcePropertiesArgsDict']]
        """
        Properties specific to data source set
        """
        resource_type: NotRequired[pulumi.Input[str]]
        """
        Resource Type of Datasource.
        """
        resource_uri: NotRequired[pulumi.Input[str]]
        """
        Uri of the resource.
        """
elif False:
    DatasourceSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasourceSetArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[str],
                 datasource_type: Optional[pulumi.Input[str]] = None,
                 object_type: Optional[pulumi.Input[str]] = None,
                 resource_location: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None,
                 resource_properties: Optional[pulumi.Input['DefaultResourcePropertiesArgs']] = None,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 resource_uri: Optional[pulumi.Input[str]] = None):
        """
        DatasourceSet details of datasource to be backed up
        :param pulumi.Input[str] resource_id: Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will be the ID created by backup service via Fabric/Vault.
        :param pulumi.Input[str] datasource_type: DatasourceType of the resource.
        :param pulumi.Input[str] object_type: Type of Datasource object, used to initialize the right inherited type
        :param pulumi.Input[str] resource_location: Location of datasource.
        :param pulumi.Input[str] resource_name: Unique identifier of the resource in the context of parent.
        :param pulumi.Input['DefaultResourcePropertiesArgs'] resource_properties: Properties specific to data source set
        :param pulumi.Input[str] resource_type: Resource Type of Datasource.
        :param pulumi.Input[str] resource_uri: Uri of the resource.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        if datasource_type is not None:
            pulumi.set(__self__, "datasource_type", datasource_type)
        if object_type is not None:
            pulumi.set(__self__, "object_type", object_type)
        if resource_location is not None:
            pulumi.set(__self__, "resource_location", resource_location)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if resource_properties is not None:
            pulumi.set(__self__, "resource_properties", resource_properties)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)

    @property
    @pulumi.getter(name="resourceID")
    def resource_id(self) -> pulumi.Input[str]:
        """
        Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will be the ID created by backup service via Fabric/Vault.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="datasourceType")
    def datasource_type(self) -> Optional[pulumi.Input[str]]:
        """
        DatasourceType of the resource.
        """
        return pulumi.get(self, "datasource_type")

    @datasource_type.setter
    def datasource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datasource_type", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of Datasource object, used to initialize the right inherited type
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="resourceLocation")
    def resource_location(self) -> Optional[pulumi.Input[str]]:
        """
        Location of datasource.
        """
        return pulumi.get(self, "resource_location")

    @resource_location.setter
    def resource_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_location", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the resource in the context of parent.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter(name="resourceProperties")
    def resource_properties(self) -> Optional[pulumi.Input['DefaultResourcePropertiesArgs']]:
        """
        Properties specific to data source set
        """
        return pulumi.get(self, "resource_properties")

    @resource_properties.setter
    def resource_properties(self, value: Optional[pulumi.Input['DefaultResourcePropertiesArgs']]):
        pulumi.set(self, "resource_properties", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        Resource Type of Datasource.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Uri of the resource.
        """
        return pulumi.get(self, "resource_uri")

    @resource_uri.setter
    def resource_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_uri", value)


if not MYPY:
    class DatasourceArgsDict(TypedDict):
        """
        Datasource to be backed up
        """
        resource_id: pulumi.Input[str]
        """
        Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will be the ID created by backup service via Fabric/Vault.
        """
        datasource_type: NotRequired[pulumi.Input[str]]
        """
        DatasourceType of the resource.
        """
        object_type: NotRequired[pulumi.Input[str]]
        """
        Type of Datasource object, used to initialize the right inherited type
        """
        resource_location: NotRequired[pulumi.Input[str]]
        """
        Location of datasource.
        """
        resource_name: NotRequired[pulumi.Input[str]]
        """
        Unique identifier of the resource in the context of parent.
        """
        resource_properties: NotRequired[pulumi.Input['DefaultResourcePropertiesArgsDict']]
        """
        Properties specific to data source
        """
        resource_type: NotRequired[pulumi.Input[str]]
        """
        Resource Type of Datasource.
        """
        resource_uri: NotRequired[pulumi.Input[str]]
        """
        Uri of the resource.
        """
elif False:
    DatasourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasourceArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[str],
                 datasource_type: Optional[pulumi.Input[str]] = None,
                 object_type: Optional[pulumi.Input[str]] = None,
                 resource_location: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None,
                 resource_properties: Optional[pulumi.Input['DefaultResourcePropertiesArgs']] = None,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 resource_uri: Optional[pulumi.Input[str]] = None):
        """
        Datasource to be backed up
        :param pulumi.Input[str] resource_id: Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will be the ID created by backup service via Fabric/Vault.
        :param pulumi.Input[str] datasource_type: DatasourceType of the resource.
        :param pulumi.Input[str] object_type: Type of Datasource object, used to initialize the right inherited type
        :param pulumi.Input[str] resource_location: Location of datasource.
        :param pulumi.Input[str] resource_name: Unique identifier of the resource in the context of parent.
        :param pulumi.Input['DefaultResourcePropertiesArgs'] resource_properties: Properties specific to data source
        :param pulumi.Input[str] resource_type: Resource Type of Datasource.
        :param pulumi.Input[str] resource_uri: Uri of the resource.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        if datasource_type is not None:
            pulumi.set(__self__, "datasource_type", datasource_type)
        if object_type is not None:
            pulumi.set(__self__, "object_type", object_type)
        if resource_location is not None:
            pulumi.set(__self__, "resource_location", resource_location)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if resource_properties is not None:
            pulumi.set(__self__, "resource_properties", resource_properties)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)

    @property
    @pulumi.getter(name="resourceID")
    def resource_id(self) -> pulumi.Input[str]:
        """
        Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will be the ID created by backup service via Fabric/Vault.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="datasourceType")
    def datasource_type(self) -> Optional[pulumi.Input[str]]:
        """
        DatasourceType of the resource.
        """
        return pulumi.get(self, "datasource_type")

    @datasource_type.setter
    def datasource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datasource_type", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of Datasource object, used to initialize the right inherited type
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="resourceLocation")
    def resource_location(self) -> Optional[pulumi.Input[str]]:
        """
        Location of datasource.
        """
        return pulumi.get(self, "resource_location")

    @resource_location.setter
    def resource_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_location", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the resource in the context of parent.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter(name="resourceProperties")
    def resource_properties(self) -> Optional[pulumi.Input['DefaultResourcePropertiesArgs']]:
        """
        Properties specific to data source
        """
        return pulumi.get(self, "resource_properties")

    @resource_properties.setter
    def resource_properties(self, value: Optional[pulumi.Input['DefaultResourcePropertiesArgs']]):
        pulumi.set(self, "resource_properties", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        Resource Type of Datasource.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Uri of the resource.
        """
        return pulumi.get(self, "resource_uri")

    @resource_uri.setter
    def resource_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_uri", value)


if not MYPY:
    class DayArgsDict(TypedDict):
        """
        Day of the week
        """
        date: NotRequired[pulumi.Input[int]]
        """
        Date of the month
        """
        is_last: NotRequired[pulumi.Input[bool]]
        """
        Whether Date is last date of month
        """
elif False:
    DayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DayArgs:
    def __init__(__self__, *,
                 date: Optional[pulumi.Input[int]] = None,
                 is_last: Optional[pulumi.Input[bool]] = None):
        """
        Day of the week
        :param pulumi.Input[int] date: Date of the month
        :param pulumi.Input[bool] is_last: Whether Date is last date of month
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if is_last is not None:
            pulumi.set(__self__, "is_last", is_last)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[int]]:
        """
        Date of the month
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter(name="isLast")
    def is_last(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Date is last date of month
        """
        return pulumi.get(self, "is_last")

    @is_last.setter
    def is_last(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_last", value)


if not MYPY:
    class DefaultResourcePropertiesArgsDict(TypedDict):
        """
        Default source properties
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'DefaultResourceProperties'.
        """
elif False:
    DefaultResourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefaultResourcePropertiesArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[str]):
        """
        Default source properties
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'DefaultResourceProperties'.
        """
        pulumi.set(__self__, "object_type", 'DefaultResourceProperties')

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'DefaultResourceProperties'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)


if not MYPY:
    class DppIdentityDetailsArgsDict(TypedDict):
        """
        Identity details
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The identityType which can be either SystemAssigned, UserAssigned, 'SystemAssigned,UserAssigned' or None
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Gets or sets the user assigned identities.
        """
elif False:
    DppIdentityDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DppIdentityDetailsArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Identity details
        :param pulumi.Input[str] type: The identityType which can be either SystemAssigned, UserAssigned, 'SystemAssigned,UserAssigned' or None
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: Gets or sets the user assigned identities.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The identityType which can be either SystemAssigned, UserAssigned, 'SystemAssigned,UserAssigned' or None
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Gets or sets the user assigned identities.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class EncryptionSettingsArgsDict(TypedDict):
        """
        Customer Managed Key details of the resource.
        """
        infrastructure_encryption: NotRequired[pulumi.Input[Union[str, 'InfrastructureEncryptionState']]]
        """
        Enabling/Disabling the Double Encryption state
        """
        kek_identity: NotRequired[pulumi.Input['CmkKekIdentityArgsDict']]
        """
        The details of the managed identity used for CMK
        """
        key_vault_properties: NotRequired[pulumi.Input['CmkKeyVaultPropertiesArgsDict']]
        """
        The properties of the Key Vault which hosts CMK
        """
        state: NotRequired[pulumi.Input[Union[str, 'EncryptionState']]]
        """
        Encryption state of the Backup Vault.
        """
elif False:
    EncryptionSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionSettingsArgs:
    def __init__(__self__, *,
                 infrastructure_encryption: Optional[pulumi.Input[Union[str, 'InfrastructureEncryptionState']]] = None,
                 kek_identity: Optional[pulumi.Input['CmkKekIdentityArgs']] = None,
                 key_vault_properties: Optional[pulumi.Input['CmkKeyVaultPropertiesArgs']] = None,
                 state: Optional[pulumi.Input[Union[str, 'EncryptionState']]] = None):
        """
        Customer Managed Key details of the resource.
        :param pulumi.Input[Union[str, 'InfrastructureEncryptionState']] infrastructure_encryption: Enabling/Disabling the Double Encryption state
        :param pulumi.Input['CmkKekIdentityArgs'] kek_identity: The details of the managed identity used for CMK
        :param pulumi.Input['CmkKeyVaultPropertiesArgs'] key_vault_properties: The properties of the Key Vault which hosts CMK
        :param pulumi.Input[Union[str, 'EncryptionState']] state: Encryption state of the Backup Vault.
        """
        if infrastructure_encryption is not None:
            pulumi.set(__self__, "infrastructure_encryption", infrastructure_encryption)
        if kek_identity is not None:
            pulumi.set(__self__, "kek_identity", kek_identity)
        if key_vault_properties is not None:
            pulumi.set(__self__, "key_vault_properties", key_vault_properties)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="infrastructureEncryption")
    def infrastructure_encryption(self) -> Optional[pulumi.Input[Union[str, 'InfrastructureEncryptionState']]]:
        """
        Enabling/Disabling the Double Encryption state
        """
        return pulumi.get(self, "infrastructure_encryption")

    @infrastructure_encryption.setter
    def infrastructure_encryption(self, value: Optional[pulumi.Input[Union[str, 'InfrastructureEncryptionState']]]):
        pulumi.set(self, "infrastructure_encryption", value)

    @property
    @pulumi.getter(name="kekIdentity")
    def kek_identity(self) -> Optional[pulumi.Input['CmkKekIdentityArgs']]:
        """
        The details of the managed identity used for CMK
        """
        return pulumi.get(self, "kek_identity")

    @kek_identity.setter
    def kek_identity(self, value: Optional[pulumi.Input['CmkKekIdentityArgs']]):
        pulumi.set(self, "kek_identity", value)

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> Optional[pulumi.Input['CmkKeyVaultPropertiesArgs']]:
        """
        The properties of the Key Vault which hosts CMK
        """
        return pulumi.get(self, "key_vault_properties")

    @key_vault_properties.setter
    def key_vault_properties(self, value: Optional[pulumi.Input['CmkKeyVaultPropertiesArgs']]):
        pulumi.set(self, "key_vault_properties", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'EncryptionState']]]:
        """
        Encryption state of the Backup Vault.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'EncryptionState']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class FeatureSettingsArgsDict(TypedDict):
        """
        Class containing feature settings of vault
        """
        cross_region_restore_settings: NotRequired[pulumi.Input['CrossRegionRestoreSettingsArgsDict']]
        cross_subscription_restore_settings: NotRequired[pulumi.Input['CrossSubscriptionRestoreSettingsArgsDict']]
        """
        CrossSubscriptionRestore Settings
        """
elif False:
    FeatureSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureSettingsArgs:
    def __init__(__self__, *,
                 cross_region_restore_settings: Optional[pulumi.Input['CrossRegionRestoreSettingsArgs']] = None,
                 cross_subscription_restore_settings: Optional[pulumi.Input['CrossSubscriptionRestoreSettingsArgs']] = None):
        """
        Class containing feature settings of vault
        :param pulumi.Input['CrossSubscriptionRestoreSettingsArgs'] cross_subscription_restore_settings: CrossSubscriptionRestore Settings
        """
        if cross_region_restore_settings is not None:
            pulumi.set(__self__, "cross_region_restore_settings", cross_region_restore_settings)
        if cross_subscription_restore_settings is not None:
            pulumi.set(__self__, "cross_subscription_restore_settings", cross_subscription_restore_settings)

    @property
    @pulumi.getter(name="crossRegionRestoreSettings")
    def cross_region_restore_settings(self) -> Optional[pulumi.Input['CrossRegionRestoreSettingsArgs']]:
        return pulumi.get(self, "cross_region_restore_settings")

    @cross_region_restore_settings.setter
    def cross_region_restore_settings(self, value: Optional[pulumi.Input['CrossRegionRestoreSettingsArgs']]):
        pulumi.set(self, "cross_region_restore_settings", value)

    @property
    @pulumi.getter(name="crossSubscriptionRestoreSettings")
    def cross_subscription_restore_settings(self) -> Optional[pulumi.Input['CrossSubscriptionRestoreSettingsArgs']]:
        """
        CrossSubscriptionRestore Settings
        """
        return pulumi.get(self, "cross_subscription_restore_settings")

    @cross_subscription_restore_settings.setter
    def cross_subscription_restore_settings(self, value: Optional[pulumi.Input['CrossSubscriptionRestoreSettingsArgs']]):
        pulumi.set(self, "cross_subscription_restore_settings", value)


if not MYPY:
    class GenericBackupDatasourceParametersArgsDict(TypedDict):
        """
        Generic parameters to be used during configuration of backup
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'GenericBackupDatasourceParameters'.
        """
        resource_selectors: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of resource selectors to be backed up during configuration of backup
        """
elif False:
    GenericBackupDatasourceParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenericBackupDatasourceParametersArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[str],
                 resource_selectors: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Generic parameters to be used during configuration of backup
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'GenericBackupDatasourceParameters'.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_selectors: List of resource selectors to be backed up during configuration of backup
        """
        pulumi.set(__self__, "object_type", 'GenericBackupDatasourceParameters')
        pulumi.set(__self__, "resource_selectors", resource_selectors)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'GenericBackupDatasourceParameters'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="resourceSelectors")
    def resource_selectors(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of resource selectors to be backed up during configuration of backup
        """
        return pulumi.get(self, "resource_selectors")

    @resource_selectors.setter
    def resource_selectors(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "resource_selectors", value)


if not MYPY:
    class IdentityDetailsArgsDict(TypedDict):
        use_system_assigned_identity: NotRequired[pulumi.Input[bool]]
        """
        Specifies if the BI is protected by System Identity.
        """
        user_assigned_identity_arm_url: NotRequired[pulumi.Input[str]]
        """
        ARM URL for User Assigned Identity.
        """
elif False:
    IdentityDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityDetailsArgs:
    def __init__(__self__, *,
                 use_system_assigned_identity: Optional[pulumi.Input[bool]] = None,
                 user_assigned_identity_arm_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] use_system_assigned_identity: Specifies if the BI is protected by System Identity.
        :param pulumi.Input[str] user_assigned_identity_arm_url: ARM URL for User Assigned Identity.
        """
        if use_system_assigned_identity is not None:
            pulumi.set(__self__, "use_system_assigned_identity", use_system_assigned_identity)
        if user_assigned_identity_arm_url is not None:
            pulumi.set(__self__, "user_assigned_identity_arm_url", user_assigned_identity_arm_url)

    @property
    @pulumi.getter(name="useSystemAssignedIdentity")
    def use_system_assigned_identity(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if the BI is protected by System Identity.
        """
        return pulumi.get(self, "use_system_assigned_identity")

    @use_system_assigned_identity.setter
    def use_system_assigned_identity(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_system_assigned_identity", value)

    @property
    @pulumi.getter(name="userAssignedIdentityArmUrl")
    def user_assigned_identity_arm_url(self) -> Optional[pulumi.Input[str]]:
        """
        ARM URL for User Assigned Identity.
        """
        return pulumi.get(self, "user_assigned_identity_arm_url")

    @user_assigned_identity_arm_url.setter
    def user_assigned_identity_arm_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity_arm_url", value)


if not MYPY:
    class ImmediateCopyOptionArgsDict(TypedDict):
        """
        Immediate copy Option
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'ImmediateCopyOption'.
        """
elif False:
    ImmediateCopyOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImmediateCopyOptionArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[str]):
        """
        Immediate copy Option
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'ImmediateCopyOption'.
        """
        pulumi.set(__self__, "object_type", 'ImmediateCopyOption')

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'ImmediateCopyOption'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)


if not MYPY:
    class ImmutabilitySettingsArgsDict(TypedDict):
        """
        Immutability Settings at vault level
        """
        state: NotRequired[pulumi.Input[Union[str, 'ImmutabilityState']]]
        """
        Immutability state
        """
elif False:
    ImmutabilitySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImmutabilitySettingsArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[Union[str, 'ImmutabilityState']]] = None):
        """
        Immutability Settings at vault level
        :param pulumi.Input[Union[str, 'ImmutabilityState']] state: Immutability state
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'ImmutabilityState']]]:
        """
        Immutability state
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'ImmutabilityState']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class KubernetesClusterBackupDatasourceParametersArgsDict(TypedDict):
        """
        Parameters for Kubernetes Cluster Backup Datasource
        """
        include_cluster_scope_resources: pulumi.Input[bool]
        """
        Gets or sets the include cluster resources property. This property if enabled will include cluster scope resources during backup.
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'KubernetesClusterBackupDatasourceParameters'.
        """
        snapshot_volumes: pulumi.Input[bool]
        """
        Gets or sets the volume snapshot property. This property if enabled will take volume snapshots during backup.
        """
        backup_hook_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['NamespacedNameResourceArgsDict']]]]
        """
        Gets or sets the backup hook references. This property sets the hook reference to be executed during backup.
        """
        excluded_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Gets or sets the exclude namespaces property. This property sets the namespaces to be excluded during backup.
        """
        excluded_resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Gets or sets the exclude resource types property. This property sets the resource types to be excluded during backup.
        """
        included_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Gets or sets the include namespaces property. This property sets the namespaces to be included during backup.
        """
        included_resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Gets or sets the include resource types property. This property sets the resource types to be included during backup.
        """
        label_selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Gets or sets the LabelSelectors property. This property sets the resource with such label selectors to be included during backup.
        """
elif False:
    KubernetesClusterBackupDatasourceParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterBackupDatasourceParametersArgs:
    def __init__(__self__, *,
                 include_cluster_scope_resources: pulumi.Input[bool],
                 object_type: pulumi.Input[str],
                 snapshot_volumes: pulumi.Input[bool],
                 backup_hook_references: Optional[pulumi.Input[Sequence[pulumi.Input['NamespacedNameResourceArgs']]]] = None,
                 excluded_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_resource_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_resource_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 label_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Parameters for Kubernetes Cluster Backup Datasource
        :param pulumi.Input[bool] include_cluster_scope_resources: Gets or sets the include cluster resources property. This property if enabled will include cluster scope resources during backup.
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'KubernetesClusterBackupDatasourceParameters'.
        :param pulumi.Input[bool] snapshot_volumes: Gets or sets the volume snapshot property. This property if enabled will take volume snapshots during backup.
        :param pulumi.Input[Sequence[pulumi.Input['NamespacedNameResourceArgs']]] backup_hook_references: Gets or sets the backup hook references. This property sets the hook reference to be executed during backup.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_namespaces: Gets or sets the exclude namespaces property. This property sets the namespaces to be excluded during backup.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_resource_types: Gets or sets the exclude resource types property. This property sets the resource types to be excluded during backup.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_namespaces: Gets or sets the include namespaces property. This property sets the namespaces to be included during backup.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_resource_types: Gets or sets the include resource types property. This property sets the resource types to be included during backup.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] label_selectors: Gets or sets the LabelSelectors property. This property sets the resource with such label selectors to be included during backup.
        """
        pulumi.set(__self__, "include_cluster_scope_resources", include_cluster_scope_resources)
        pulumi.set(__self__, "object_type", 'KubernetesClusterBackupDatasourceParameters')
        pulumi.set(__self__, "snapshot_volumes", snapshot_volumes)
        if backup_hook_references is not None:
            pulumi.set(__self__, "backup_hook_references", backup_hook_references)
        if excluded_namespaces is not None:
            pulumi.set(__self__, "excluded_namespaces", excluded_namespaces)
        if excluded_resource_types is not None:
            pulumi.set(__self__, "excluded_resource_types", excluded_resource_types)
        if included_namespaces is not None:
            pulumi.set(__self__, "included_namespaces", included_namespaces)
        if included_resource_types is not None:
            pulumi.set(__self__, "included_resource_types", included_resource_types)
        if label_selectors is not None:
            pulumi.set(__self__, "label_selectors", label_selectors)

    @property
    @pulumi.getter(name="includeClusterScopeResources")
    def include_cluster_scope_resources(self) -> pulumi.Input[bool]:
        """
        Gets or sets the include cluster resources property. This property if enabled will include cluster scope resources during backup.
        """
        return pulumi.get(self, "include_cluster_scope_resources")

    @include_cluster_scope_resources.setter
    def include_cluster_scope_resources(self, value: pulumi.Input[bool]):
        pulumi.set(self, "include_cluster_scope_resources", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'KubernetesClusterBackupDatasourceParameters'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="snapshotVolumes")
    def snapshot_volumes(self) -> pulumi.Input[bool]:
        """
        Gets or sets the volume snapshot property. This property if enabled will take volume snapshots during backup.
        """
        return pulumi.get(self, "snapshot_volumes")

    @snapshot_volumes.setter
    def snapshot_volumes(self, value: pulumi.Input[bool]):
        pulumi.set(self, "snapshot_volumes", value)

    @property
    @pulumi.getter(name="backupHookReferences")
    def backup_hook_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NamespacedNameResourceArgs']]]]:
        """
        Gets or sets the backup hook references. This property sets the hook reference to be executed during backup.
        """
        return pulumi.get(self, "backup_hook_references")

    @backup_hook_references.setter
    def backup_hook_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NamespacedNameResourceArgs']]]]):
        pulumi.set(self, "backup_hook_references", value)

    @property
    @pulumi.getter(name="excludedNamespaces")
    def excluded_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Gets or sets the exclude namespaces property. This property sets the namespaces to be excluded during backup.
        """
        return pulumi.get(self, "excluded_namespaces")

    @excluded_namespaces.setter
    def excluded_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_namespaces", value)

    @property
    @pulumi.getter(name="excludedResourceTypes")
    def excluded_resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Gets or sets the exclude resource types property. This property sets the resource types to be excluded during backup.
        """
        return pulumi.get(self, "excluded_resource_types")

    @excluded_resource_types.setter
    def excluded_resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_resource_types", value)

    @property
    @pulumi.getter(name="includedNamespaces")
    def included_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Gets or sets the include namespaces property. This property sets the namespaces to be included during backup.
        """
        return pulumi.get(self, "included_namespaces")

    @included_namespaces.setter
    def included_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_namespaces", value)

    @property
    @pulumi.getter(name="includedResourceTypes")
    def included_resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Gets or sets the include resource types property. This property sets the resource types to be included during backup.
        """
        return pulumi.get(self, "included_resource_types")

    @included_resource_types.setter
    def included_resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_resource_types", value)

    @property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Gets or sets the LabelSelectors property. This property sets the resource with such label selectors to be included during backup.
        """
        return pulumi.get(self, "label_selectors")

    @label_selectors.setter
    def label_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "label_selectors", value)


if not MYPY:
    class MonitoringSettingsArgsDict(TypedDict):
        """
        Monitoring Settings
        """
        azure_monitor_alert_settings: NotRequired[pulumi.Input['AzureMonitorAlertSettingsArgsDict']]
        """
        Settings for Azure Monitor based alerts
        """
elif False:
    MonitoringSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringSettingsArgs:
    def __init__(__self__, *,
                 azure_monitor_alert_settings: Optional[pulumi.Input['AzureMonitorAlertSettingsArgs']] = None):
        """
        Monitoring Settings
        :param pulumi.Input['AzureMonitorAlertSettingsArgs'] azure_monitor_alert_settings: Settings for Azure Monitor based alerts
        """
        if azure_monitor_alert_settings is not None:
            pulumi.set(__self__, "azure_monitor_alert_settings", azure_monitor_alert_settings)

    @property
    @pulumi.getter(name="azureMonitorAlertSettings")
    def azure_monitor_alert_settings(self) -> Optional[pulumi.Input['AzureMonitorAlertSettingsArgs']]:
        """
        Settings for Azure Monitor based alerts
        """
        return pulumi.get(self, "azure_monitor_alert_settings")

    @azure_monitor_alert_settings.setter
    def azure_monitor_alert_settings(self, value: Optional[pulumi.Input['AzureMonitorAlertSettingsArgs']]):
        pulumi.set(self, "azure_monitor_alert_settings", value)


if not MYPY:
    class NamespacedNameResourceArgsDict(TypedDict):
        """
        Class to refer resources which contains namespace and name
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the resource
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace in which the resource exists
        """
elif False:
    NamespacedNameResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespacedNameResourceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        Class to refer resources which contains namespace and name
        :param pulumi.Input[str] name: Name of the resource
        :param pulumi.Input[str] namespace: Namespace in which the resource exists
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace in which the resource exists
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class PolicyInfoArgsDict(TypedDict):
        """
        Policy Info in backupInstance
        """
        policy_id: pulumi.Input[str]
        policy_parameters: NotRequired[pulumi.Input['PolicyParametersArgsDict']]
        """
        Policy parameters for the backup instance
        """
elif False:
    PolicyInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyInfoArgs:
    def __init__(__self__, *,
                 policy_id: pulumi.Input[str],
                 policy_parameters: Optional[pulumi.Input['PolicyParametersArgs']] = None):
        """
        Policy Info in backupInstance
        :param pulumi.Input['PolicyParametersArgs'] policy_parameters: Policy parameters for the backup instance
        """
        pulumi.set(__self__, "policy_id", policy_id)
        if policy_parameters is not None:
            pulumi.set(__self__, "policy_parameters", policy_parameters)

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "policy_id")

    @policy_id.setter
    def policy_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_id", value)

    @property
    @pulumi.getter(name="policyParameters")
    def policy_parameters(self) -> Optional[pulumi.Input['PolicyParametersArgs']]:
        """
        Policy parameters for the backup instance
        """
        return pulumi.get(self, "policy_parameters")

    @policy_parameters.setter
    def policy_parameters(self, value: Optional[pulumi.Input['PolicyParametersArgs']]):
        pulumi.set(self, "policy_parameters", value)


if not MYPY:
    class PolicyParametersArgsDict(TypedDict):
        """
        Parameters in Policy
        """
        backup_datasource_parameters_list: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['BlobBackupDatasourceParametersArgsDict', 'GenericBackupDatasourceParametersArgsDict', 'KubernetesClusterBackupDatasourceParametersArgsDict']]]]]
        """
        Gets or sets the Backup Data Source Parameters
        """
        data_store_parameters_list: NotRequired[pulumi.Input[Sequence[pulumi.Input['AzureOperationalStoreParametersArgsDict']]]]
        """
        Gets or sets the DataStore Parameters
        """
elif False:
    PolicyParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyParametersArgs:
    def __init__(__self__, *,
                 backup_datasource_parameters_list: Optional[pulumi.Input[Sequence[pulumi.Input[Union['BlobBackupDatasourceParametersArgs', 'GenericBackupDatasourceParametersArgs', 'KubernetesClusterBackupDatasourceParametersArgs']]]]] = None,
                 data_store_parameters_list: Optional[pulumi.Input[Sequence[pulumi.Input['AzureOperationalStoreParametersArgs']]]] = None):
        """
        Parameters in Policy
        :param pulumi.Input[Sequence[pulumi.Input[Union['BlobBackupDatasourceParametersArgs', 'GenericBackupDatasourceParametersArgs', 'KubernetesClusterBackupDatasourceParametersArgs']]]] backup_datasource_parameters_list: Gets or sets the Backup Data Source Parameters
        :param pulumi.Input[Sequence[pulumi.Input['AzureOperationalStoreParametersArgs']]] data_store_parameters_list: Gets or sets the DataStore Parameters
        """
        if backup_datasource_parameters_list is not None:
            pulumi.set(__self__, "backup_datasource_parameters_list", backup_datasource_parameters_list)
        if data_store_parameters_list is not None:
            pulumi.set(__self__, "data_store_parameters_list", data_store_parameters_list)

    @property
    @pulumi.getter(name="backupDatasourceParametersList")
    def backup_datasource_parameters_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['BlobBackupDatasourceParametersArgs', 'GenericBackupDatasourceParametersArgs', 'KubernetesClusterBackupDatasourceParametersArgs']]]]]:
        """
        Gets or sets the Backup Data Source Parameters
        """
        return pulumi.get(self, "backup_datasource_parameters_list")

    @backup_datasource_parameters_list.setter
    def backup_datasource_parameters_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['BlobBackupDatasourceParametersArgs', 'GenericBackupDatasourceParametersArgs', 'KubernetesClusterBackupDatasourceParametersArgs']]]]]):
        pulumi.set(self, "backup_datasource_parameters_list", value)

    @property
    @pulumi.getter(name="dataStoreParametersList")
    def data_store_parameters_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AzureOperationalStoreParametersArgs']]]]:
        """
        Gets or sets the DataStore Parameters
        """
        return pulumi.get(self, "data_store_parameters_list")

    @data_store_parameters_list.setter
    def data_store_parameters_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AzureOperationalStoreParametersArgs']]]]):
        pulumi.set(self, "data_store_parameters_list", value)


if not MYPY:
    class ResourceGuardOperationDetailArgsDict(TypedDict):
        """
        VaultCritical Operation protected by a resource guard
        """
        default_resource_request: NotRequired[pulumi.Input[str]]
        vault_critical_operation: NotRequired[pulumi.Input[str]]
elif False:
    ResourceGuardOperationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGuardOperationDetailArgs:
    def __init__(__self__, *,
                 default_resource_request: Optional[pulumi.Input[str]] = None,
                 vault_critical_operation: Optional[pulumi.Input[str]] = None):
        """
        VaultCritical Operation protected by a resource guard
        """
        if default_resource_request is not None:
            pulumi.set(__self__, "default_resource_request", default_resource_request)
        if vault_critical_operation is not None:
            pulumi.set(__self__, "vault_critical_operation", vault_critical_operation)

    @property
    @pulumi.getter(name="defaultResourceRequest")
    def default_resource_request(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_resource_request")

    @default_resource_request.setter
    def default_resource_request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_resource_request", value)

    @property
    @pulumi.getter(name="vaultCriticalOperation")
    def vault_critical_operation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vault_critical_operation")

    @vault_critical_operation.setter
    def vault_critical_operation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_critical_operation", value)


if not MYPY:
    class ResourceGuardProxyBaseArgsDict(TypedDict):
        """
        ResourceGuardProxyBase object, used in ResourceGuardProxyBaseResource
        """
        description: NotRequired[pulumi.Input[str]]
        last_updated_time: NotRequired[pulumi.Input[str]]
        resource_guard_operation_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResourceGuardOperationDetailArgsDict']]]]
        resource_guard_resource_id: NotRequired[pulumi.Input[str]]
elif False:
    ResourceGuardProxyBaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGuardProxyBaseArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 last_updated_time: Optional[pulumi.Input[str]] = None,
                 resource_guard_operation_details: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGuardOperationDetailArgs']]]] = None,
                 resource_guard_resource_id: Optional[pulumi.Input[str]] = None):
        """
        ResourceGuardProxyBase object, used in ResourceGuardProxyBaseResource
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if last_updated_time is not None:
            pulumi.set(__self__, "last_updated_time", last_updated_time)
        if resource_guard_operation_details is not None:
            pulumi.set(__self__, "resource_guard_operation_details", resource_guard_operation_details)
        if resource_guard_resource_id is not None:
            pulumi.set(__self__, "resource_guard_resource_id", resource_guard_resource_id)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="lastUpdatedTime")
    def last_updated_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_updated_time")

    @last_updated_time.setter
    def last_updated_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_updated_time", value)

    @property
    @pulumi.getter(name="resourceGuardOperationDetails")
    def resource_guard_operation_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGuardOperationDetailArgs']]]]:
        return pulumi.get(self, "resource_guard_operation_details")

    @resource_guard_operation_details.setter
    def resource_guard_operation_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGuardOperationDetailArgs']]]]):
        pulumi.set(self, "resource_guard_operation_details", value)

    @property
    @pulumi.getter(name="resourceGuardResourceId")
    def resource_guard_resource_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_guard_resource_id")

    @resource_guard_resource_id.setter
    def resource_guard_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_guard_resource_id", value)


if not MYPY:
    class ResourceGuardArgsDict(TypedDict):
        vault_critical_operation_exclusion_list: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of critical operations which are not protected by this resourceGuard
        """
elif False:
    ResourceGuardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGuardArgs:
    def __init__(__self__, *,
                 vault_critical_operation_exclusion_list: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vault_critical_operation_exclusion_list: List of critical operations which are not protected by this resourceGuard
        """
        if vault_critical_operation_exclusion_list is not None:
            pulumi.set(__self__, "vault_critical_operation_exclusion_list", vault_critical_operation_exclusion_list)

    @property
    @pulumi.getter(name="vaultCriticalOperationExclusionList")
    def vault_critical_operation_exclusion_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of critical operations which are not protected by this resourceGuard
        """
        return pulumi.get(self, "vault_critical_operation_exclusion_list")

    @vault_critical_operation_exclusion_list.setter
    def vault_critical_operation_exclusion_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vault_critical_operation_exclusion_list", value)


if not MYPY:
    class RetentionTagArgsDict(TypedDict):
        """
        Retention tag
        """
        tag_name: pulumi.Input[str]
        """
        Retention Tag Name to relate it to retention rule.
        """
elif False:
    RetentionTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RetentionTagArgs:
    def __init__(__self__, *,
                 tag_name: pulumi.Input[str]):
        """
        Retention tag
        :param pulumi.Input[str] tag_name: Retention Tag Name to relate it to retention rule.
        """
        pulumi.set(__self__, "tag_name", tag_name)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> pulumi.Input[str]:
        """
        Retention Tag Name to relate it to retention rule.
        """
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag_name", value)


if not MYPY:
    class ScheduleBasedBackupCriteriaArgsDict(TypedDict):
        """
        Schedule based backup criteria
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'ScheduleBasedBackupCriteria'.
        """
        absolute_criteria: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AbsoluteMarker']]]]]
        """
        it contains absolute values like "AllBackup" / "FirstOfDay" / "FirstOfWeek" / "FirstOfMonth"
        and should be part of AbsoluteMarker enum
        """
        days_of_month: NotRequired[pulumi.Input[Sequence[pulumi.Input['DayArgsDict']]]]
        """
        This is day of the month from 1 to 28 other wise last of month
        """
        days_of_the_week: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'DayOfWeek']]]]]
        """
        It should be Sunday/Monday/T..../Saturday
        """
        months_of_year: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Month']]]]]
        """
        It should be January/February/....../December
        """
        schedule_times: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of schedule times for backup
        """
        weeks_of_the_month: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'WeekNumber']]]]]
        """
        It should be First/Second/Third/Fourth/Last
        """
elif False:
    ScheduleBasedBackupCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleBasedBackupCriteriaArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[str],
                 absolute_criteria: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AbsoluteMarker']]]]] = None,
                 days_of_month: Optional[pulumi.Input[Sequence[pulumi.Input['DayArgs']]]] = None,
                 days_of_the_week: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'DayOfWeek']]]]] = None,
                 months_of_year: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Month']]]]] = None,
                 schedule_times: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 weeks_of_the_month: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'WeekNumber']]]]] = None):
        """
        Schedule based backup criteria
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'ScheduleBasedBackupCriteria'.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'AbsoluteMarker']]]] absolute_criteria: it contains absolute values like "AllBackup" / "FirstOfDay" / "FirstOfWeek" / "FirstOfMonth"
               and should be part of AbsoluteMarker enum
        :param pulumi.Input[Sequence[pulumi.Input['DayArgs']]] days_of_month: This is day of the month from 1 to 28 other wise last of month
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'DayOfWeek']]]] days_of_the_week: It should be Sunday/Monday/T..../Saturday
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Month']]]] months_of_year: It should be January/February/....../December
        :param pulumi.Input[Sequence[pulumi.Input[str]]] schedule_times: List of schedule times for backup
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'WeekNumber']]]] weeks_of_the_month: It should be First/Second/Third/Fourth/Last
        """
        pulumi.set(__self__, "object_type", 'ScheduleBasedBackupCriteria')
        if absolute_criteria is not None:
            pulumi.set(__self__, "absolute_criteria", absolute_criteria)
        if days_of_month is not None:
            pulumi.set(__self__, "days_of_month", days_of_month)
        if days_of_the_week is not None:
            pulumi.set(__self__, "days_of_the_week", days_of_the_week)
        if months_of_year is not None:
            pulumi.set(__self__, "months_of_year", months_of_year)
        if schedule_times is not None:
            pulumi.set(__self__, "schedule_times", schedule_times)
        if weeks_of_the_month is not None:
            pulumi.set(__self__, "weeks_of_the_month", weeks_of_the_month)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'ScheduleBasedBackupCriteria'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="absoluteCriteria")
    def absolute_criteria(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AbsoluteMarker']]]]]:
        """
        it contains absolute values like "AllBackup" / "FirstOfDay" / "FirstOfWeek" / "FirstOfMonth"
        and should be part of AbsoluteMarker enum
        """
        return pulumi.get(self, "absolute_criteria")

    @absolute_criteria.setter
    def absolute_criteria(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AbsoluteMarker']]]]]):
        pulumi.set(self, "absolute_criteria", value)

    @property
    @pulumi.getter(name="daysOfMonth")
    def days_of_month(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DayArgs']]]]:
        """
        This is day of the month from 1 to 28 other wise last of month
        """
        return pulumi.get(self, "days_of_month")

    @days_of_month.setter
    def days_of_month(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DayArgs']]]]):
        pulumi.set(self, "days_of_month", value)

    @property
    @pulumi.getter(name="daysOfTheWeek")
    def days_of_the_week(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'DayOfWeek']]]]]:
        """
        It should be Sunday/Monday/T..../Saturday
        """
        return pulumi.get(self, "days_of_the_week")

    @days_of_the_week.setter
    def days_of_the_week(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'DayOfWeek']]]]]):
        pulumi.set(self, "days_of_the_week", value)

    @property
    @pulumi.getter(name="monthsOfYear")
    def months_of_year(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Month']]]]]:
        """
        It should be January/February/....../December
        """
        return pulumi.get(self, "months_of_year")

    @months_of_year.setter
    def months_of_year(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Month']]]]]):
        pulumi.set(self, "months_of_year", value)

    @property
    @pulumi.getter(name="scheduleTimes")
    def schedule_times(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of schedule times for backup
        """
        return pulumi.get(self, "schedule_times")

    @schedule_times.setter
    def schedule_times(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "schedule_times", value)

    @property
    @pulumi.getter(name="weeksOfTheMonth")
    def weeks_of_the_month(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'WeekNumber']]]]]:
        """
        It should be First/Second/Third/Fourth/Last
        """
        return pulumi.get(self, "weeks_of_the_month")

    @weeks_of_the_month.setter
    def weeks_of_the_month(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'WeekNumber']]]]]):
        pulumi.set(self, "weeks_of_the_month", value)


if not MYPY:
    class ScheduleBasedTriggerContextArgsDict(TypedDict):
        """
        Schedule based trigger context
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'ScheduleBasedTriggerContext'.
        """
        schedule: pulumi.Input['BackupScheduleArgsDict']
        """
        Schedule for this backup
        """
        tagging_criteria: pulumi.Input[Sequence[pulumi.Input['TaggingCriteriaArgsDict']]]
        """
        List of tags that can be applicable for given schedule.
        """
elif False:
    ScheduleBasedTriggerContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleBasedTriggerContextArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[str],
                 schedule: pulumi.Input['BackupScheduleArgs'],
                 tagging_criteria: pulumi.Input[Sequence[pulumi.Input['TaggingCriteriaArgs']]]):
        """
        Schedule based trigger context
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'ScheduleBasedTriggerContext'.
        :param pulumi.Input['BackupScheduleArgs'] schedule: Schedule for this backup
        :param pulumi.Input[Sequence[pulumi.Input['TaggingCriteriaArgs']]] tagging_criteria: List of tags that can be applicable for given schedule.
        """
        pulumi.set(__self__, "object_type", 'ScheduleBasedTriggerContext')
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "tagging_criteria", tagging_criteria)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'ScheduleBasedTriggerContext'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['BackupScheduleArgs']:
        """
        Schedule for this backup
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['BackupScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="taggingCriteria")
    def tagging_criteria(self) -> pulumi.Input[Sequence[pulumi.Input['TaggingCriteriaArgs']]]:
        """
        List of tags that can be applicable for given schedule.
        """
        return pulumi.get(self, "tagging_criteria")

    @tagging_criteria.setter
    def tagging_criteria(self, value: pulumi.Input[Sequence[pulumi.Input['TaggingCriteriaArgs']]]):
        pulumi.set(self, "tagging_criteria", value)


if not MYPY:
    class SecretStoreBasedAuthCredentialsArgsDict(TypedDict):
        """
        Secret store based authentication credentials.
        """
        object_type: pulumi.Input[str]
        """
        Type of the specific object - used for deserializing
        Expected value is 'SecretStoreBasedAuthCredentials'.
        """
        secret_store_resource: NotRequired[pulumi.Input['SecretStoreResourceArgsDict']]
        """
        Secret store resource
        """
elif False:
    SecretStoreBasedAuthCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreBasedAuthCredentialsArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[str],
                 secret_store_resource: Optional[pulumi.Input['SecretStoreResourceArgs']] = None):
        """
        Secret store based authentication credentials.
        :param pulumi.Input[str] object_type: Type of the specific object - used for deserializing
               Expected value is 'SecretStoreBasedAuthCredentials'.
        :param pulumi.Input['SecretStoreResourceArgs'] secret_store_resource: Secret store resource
        """
        pulumi.set(__self__, "object_type", 'SecretStoreBasedAuthCredentials')
        if secret_store_resource is not None:
            pulumi.set(__self__, "secret_store_resource", secret_store_resource)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        Type of the specific object - used for deserializing
        Expected value is 'SecretStoreBasedAuthCredentials'.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="secretStoreResource")
    def secret_store_resource(self) -> Optional[pulumi.Input['SecretStoreResourceArgs']]:
        """
        Secret store resource
        """
        return pulumi.get(self, "secret_store_resource")

    @secret_store_resource.setter
    def secret_store_resource(self, value: Optional[pulumi.Input['SecretStoreResourceArgs']]):
        pulumi.set(self, "secret_store_resource", value)


if not MYPY:
    class SecretStoreResourceArgsDict(TypedDict):
        """
        Class representing a secret store resource.
        """
        secret_store_type: pulumi.Input[Union[str, 'SecretStoreType']]
        """
        Gets or sets the type of secret store
        """
        uri: NotRequired[pulumi.Input[str]]
        """
        Uri to get to the resource
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Gets or sets value stored in secret store resource
        """
elif False:
    SecretStoreResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretStoreResourceArgs:
    def __init__(__self__, *,
                 secret_store_type: pulumi.Input[Union[str, 'SecretStoreType']],
                 uri: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Class representing a secret store resource.
        :param pulumi.Input[Union[str, 'SecretStoreType']] secret_store_type: Gets or sets the type of secret store
        :param pulumi.Input[str] uri: Uri to get to the resource
        :param pulumi.Input[str] value: Gets or sets value stored in secret store resource
        """
        pulumi.set(__self__, "secret_store_type", secret_store_type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="secretStoreType")
    def secret_store_type(self) -> pulumi.Input[Union[str, 'SecretStoreType']]:
        """
        Gets or sets the type of secret store
        """
        return pulumi.get(self, "secret_store_type")

    @secret_store_type.setter
    def secret_store_type(self, value: pulumi.Input[Union[str, 'SecretStoreType']]):
        pulumi.set(self, "secret_store_type", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        Uri to get to the resource
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets value stored in secret store resource
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SecuritySettingsArgsDict(TypedDict):
        """
        Class containing security settings of vault
        """
        encryption_settings: NotRequired[pulumi.Input['EncryptionSettingsArgsDict']]
        """
        Customer Managed Key details of the resource.
        """
        immutability_settings: NotRequired[pulumi.Input['ImmutabilitySettingsArgsDict']]
        """
        Immutability Settings at vault level
        """
        soft_delete_settings: NotRequired[pulumi.Input['SoftDeleteSettingsArgsDict']]
        """
        Soft delete related settings
        """
elif False:
    SecuritySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecuritySettingsArgs:
    def __init__(__self__, *,
                 encryption_settings: Optional[pulumi.Input['EncryptionSettingsArgs']] = None,
                 immutability_settings: Optional[pulumi.Input['ImmutabilitySettingsArgs']] = None,
                 soft_delete_settings: Optional[pulumi.Input['SoftDeleteSettingsArgs']] = None):
        """
        Class containing security settings of vault
        :param pulumi.Input['EncryptionSettingsArgs'] encryption_settings: Customer Managed Key details of the resource.
        :param pulumi.Input['ImmutabilitySettingsArgs'] immutability_settings: Immutability Settings at vault level
        :param pulumi.Input['SoftDeleteSettingsArgs'] soft_delete_settings: Soft delete related settings
        """
        if encryption_settings is not None:
            pulumi.set(__self__, "encryption_settings", encryption_settings)
        if immutability_settings is not None:
            pulumi.set(__self__, "immutability_settings", immutability_settings)
        if soft_delete_settings is not None:
            pulumi.set(__self__, "soft_delete_settings", soft_delete_settings)

    @property
    @pulumi.getter(name="encryptionSettings")
    def encryption_settings(self) -> Optional[pulumi.Input['EncryptionSettingsArgs']]:
        """
        Customer Managed Key details of the resource.
        """
        return pulumi.get(self, "encryption_settings")

    @encryption_settings.setter
    def encryption_settings(self, value: Optional[pulumi.Input['EncryptionSettingsArgs']]):
        pulumi.set(self, "encryption_settings", value)

    @property
    @pulumi.getter(name="immutabilitySettings")
    def immutability_settings(self) -> Optional[pulumi.Input['ImmutabilitySettingsArgs']]:
        """
        Immutability Settings at vault level
        """
        return pulumi.get(self, "immutability_settings")

    @immutability_settings.setter
    def immutability_settings(self, value: Optional[pulumi.Input['ImmutabilitySettingsArgs']]):
        pulumi.set(self, "immutability_settings", value)

    @property
    @pulumi.getter(name="softDeleteSettings")
    def soft_delete_settings(self) -> Optional[pulumi.Input['SoftDeleteSettingsArgs']]:
        """
        Soft delete related settings
        """
        return pulumi.get(self, "soft_delete_settings")

    @soft_delete_settings.setter
    def soft_delete_settings(self, value: Optional[pulumi.Input['SoftDeleteSettingsArgs']]):
        pulumi.set(self, "soft_delete_settings", value)


if not MYPY:
    class SoftDeleteSettingsArgsDict(TypedDict):
        """
        Soft delete related settings
        """
        retention_duration_in_days: NotRequired[pulumi.Input[float]]
        """
        Soft delete retention duration
        """
        state: NotRequired[pulumi.Input[Union[str, 'SoftDeleteState']]]
        """
        State of soft delete
        """
elif False:
    SoftDeleteSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SoftDeleteSettingsArgs:
    def __init__(__self__, *,
                 retention_duration_in_days: Optional[pulumi.Input[float]] = None,
                 state: Optional[pulumi.Input[Union[str, 'SoftDeleteState']]] = None):
        """
        Soft delete related settings
        :param pulumi.Input[float] retention_duration_in_days: Soft delete retention duration
        :param pulumi.Input[Union[str, 'SoftDeleteState']] state: State of soft delete
        """
        if retention_duration_in_days is not None:
            pulumi.set(__self__, "retention_duration_in_days", retention_duration_in_days)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="retentionDurationInDays")
    def retention_duration_in_days(self) -> Optional[pulumi.Input[float]]:
        """
        Soft delete retention duration
        """
        return pulumi.get(self, "retention_duration_in_days")

    @retention_duration_in_days.setter
    def retention_duration_in_days(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "retention_duration_in_days", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[str, 'SoftDeleteState']]]:
        """
        State of soft delete
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[str, 'SoftDeleteState']]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class SourceLifeCycleArgsDict(TypedDict):
        """
        Source LifeCycle
        """
        delete_after: pulumi.Input['AbsoluteDeleteOptionArgsDict']
        """
        Delete Option
        """
        source_data_store: pulumi.Input['DataStoreInfoBaseArgsDict']
        """
        DataStoreInfo base
        """
        target_data_store_copy_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['TargetCopySettingArgsDict']]]]
elif False:
    SourceLifeCycleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceLifeCycleArgs:
    def __init__(__self__, *,
                 delete_after: pulumi.Input['AbsoluteDeleteOptionArgs'],
                 source_data_store: pulumi.Input['DataStoreInfoBaseArgs'],
                 target_data_store_copy_settings: Optional[pulumi.Input[Sequence[pulumi.Input['TargetCopySettingArgs']]]] = None):
        """
        Source LifeCycle
        :param pulumi.Input['AbsoluteDeleteOptionArgs'] delete_after: Delete Option
        :param pulumi.Input['DataStoreInfoBaseArgs'] source_data_store: DataStoreInfo base
        """
        pulumi.set(__self__, "delete_after", delete_after)
        pulumi.set(__self__, "source_data_store", source_data_store)
        if target_data_store_copy_settings is not None:
            pulumi.set(__self__, "target_data_store_copy_settings", target_data_store_copy_settings)

    @property
    @pulumi.getter(name="deleteAfter")
    def delete_after(self) -> pulumi.Input['AbsoluteDeleteOptionArgs']:
        """
        Delete Option
        """
        return pulumi.get(self, "delete_after")

    @delete_after.setter
    def delete_after(self, value: pulumi.Input['AbsoluteDeleteOptionArgs']):
        pulumi.set(self, "delete_after", value)

    @property
    @pulumi.getter(name="sourceDataStore")
    def source_data_store(self) -> pulumi.Input['DataStoreInfoBaseArgs']:
        """
        DataStoreInfo base
        """
        return pulumi.get(self, "source_data_store")

    @source_data_store.setter
    def source_data_store(self, value: pulumi.Input['DataStoreInfoBaseArgs']):
        pulumi.set(self, "source_data_store", value)

    @property
    @pulumi.getter(name="targetDataStoreCopySettings")
    def target_data_store_copy_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TargetCopySettingArgs']]]]:
        return pulumi.get(self, "target_data_store_copy_settings")

    @target_data_store_copy_settings.setter
    def target_data_store_copy_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TargetCopySettingArgs']]]]):
        pulumi.set(self, "target_data_store_copy_settings", value)


if not MYPY:
    class StorageSettingArgsDict(TypedDict):
        """
        Storage setting
        """
        datastore_type: NotRequired[pulumi.Input[Union[str, 'StorageSettingStoreTypes']]]
        """
        Gets or sets the type of the datastore.
        """
        type: NotRequired[pulumi.Input[Union[str, 'StorageSettingTypes']]]
        """
        Gets or sets the type.
        """
elif False:
    StorageSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageSettingArgs:
    def __init__(__self__, *,
                 datastore_type: Optional[pulumi.Input[Union[str, 'StorageSettingStoreTypes']]] = None,
                 type: Optional[pulumi.Input[Union[str, 'StorageSettingTypes']]] = None):
        """
        Storage setting
        :param pulumi.Input[Union[str, 'StorageSettingStoreTypes']] datastore_type: Gets or sets the type of the datastore.
        :param pulumi.Input[Union[str, 'StorageSettingTypes']] type: Gets or sets the type.
        """
        if datastore_type is not None:
            pulumi.set(__self__, "datastore_type", datastore_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="datastoreType")
    def datastore_type(self) -> Optional[pulumi.Input[Union[str, 'StorageSettingStoreTypes']]]:
        """
        Gets or sets the type of the datastore.
        """
        return pulumi.get(self, "datastore_type")

    @datastore_type.setter
    def datastore_type(self, value: Optional[pulumi.Input[Union[str, 'StorageSettingStoreTypes']]]):
        pulumi.set(self, "datastore_type", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'StorageSettingTypes']]]:
        """
        Gets or sets the type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'StorageSettingTypes']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TaggingCriteriaArgsDict(TypedDict):
        """
        Tagging criteria
        """
        is_default: pulumi.Input[bool]
        """
        Specifies if tag is default.
        """
        tag_info: pulumi.Input['RetentionTagArgsDict']
        """
        Retention tag information
        """
        tagging_priority: pulumi.Input[float]
        """
        Retention Tag priority.
        """
        criteria: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduleBasedBackupCriteriaArgsDict']]]]
        """
        Criteria which decides whether the tag can be applied to a triggered backup.
        """
elif False:
    TaggingCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TaggingCriteriaArgs:
    def __init__(__self__, *,
                 is_default: pulumi.Input[bool],
                 tag_info: pulumi.Input['RetentionTagArgs'],
                 tagging_priority: pulumi.Input[float],
                 criteria: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleBasedBackupCriteriaArgs']]]] = None):
        """
        Tagging criteria
        :param pulumi.Input[bool] is_default: Specifies if tag is default.
        :param pulumi.Input['RetentionTagArgs'] tag_info: Retention tag information
        :param pulumi.Input[float] tagging_priority: Retention Tag priority.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleBasedBackupCriteriaArgs']]] criteria: Criteria which decides whether the tag can be applied to a triggered backup.
        """
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "tag_info", tag_info)
        pulumi.set(__self__, "tagging_priority", tagging_priority)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> pulumi.Input[bool]:
        """
        Specifies if tag is default.
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_default", value)

    @property
    @pulumi.getter(name="tagInfo")
    def tag_info(self) -> pulumi.Input['RetentionTagArgs']:
        """
        Retention tag information
        """
        return pulumi.get(self, "tag_info")

    @tag_info.setter
    def tag_info(self, value: pulumi.Input['RetentionTagArgs']):
        pulumi.set(self, "tag_info", value)

    @property
    @pulumi.getter(name="taggingPriority")
    def tagging_priority(self) -> pulumi.Input[float]:
        """
        Retention Tag priority.
        """
        return pulumi.get(self, "tagging_priority")

    @tagging_priority.setter
    def tagging_priority(self, value: pulumi.Input[float]):
        pulumi.set(self, "tagging_priority", value)

    @property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleBasedBackupCriteriaArgs']]]]:
        """
        Criteria which decides whether the tag can be applied to a triggered backup.
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleBasedBackupCriteriaArgs']]]]):
        pulumi.set(self, "criteria", value)


if not MYPY:
    class TargetCopySettingArgsDict(TypedDict):
        """
        Target copy settings
        """
        copy_after: pulumi.Input[Union['CopyOnExpiryOptionArgsDict', 'CustomCopyOptionArgsDict', 'ImmediateCopyOptionArgsDict']]
        """
        It can be CustomCopyOption or ImmediateCopyOption.
        """
        data_store: pulumi.Input['DataStoreInfoBaseArgsDict']
        """
        Info of target datastore
        """
elif False:
    TargetCopySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetCopySettingArgs:
    def __init__(__self__, *,
                 copy_after: pulumi.Input[Union['CopyOnExpiryOptionArgs', 'CustomCopyOptionArgs', 'ImmediateCopyOptionArgs']],
                 data_store: pulumi.Input['DataStoreInfoBaseArgs']):
        """
        Target copy settings
        :param pulumi.Input[Union['CopyOnExpiryOptionArgs', 'CustomCopyOptionArgs', 'ImmediateCopyOptionArgs']] copy_after: It can be CustomCopyOption or ImmediateCopyOption.
        :param pulumi.Input['DataStoreInfoBaseArgs'] data_store: Info of target datastore
        """
        pulumi.set(__self__, "copy_after", copy_after)
        pulumi.set(__self__, "data_store", data_store)

    @property
    @pulumi.getter(name="copyAfter")
    def copy_after(self) -> pulumi.Input[Union['CopyOnExpiryOptionArgs', 'CustomCopyOptionArgs', 'ImmediateCopyOptionArgs']]:
        """
        It can be CustomCopyOption or ImmediateCopyOption.
        """
        return pulumi.get(self, "copy_after")

    @copy_after.setter
    def copy_after(self, value: pulumi.Input[Union['CopyOnExpiryOptionArgs', 'CustomCopyOptionArgs', 'ImmediateCopyOptionArgs']]):
        pulumi.set(self, "copy_after", value)

    @property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> pulumi.Input['DataStoreInfoBaseArgs']:
        """
        Info of target datastore
        """
        return pulumi.get(self, "data_store")

    @data_store.setter
    def data_store(self, value: pulumi.Input['DataStoreInfoBaseArgs']):
        pulumi.set(self, "data_store", value)


