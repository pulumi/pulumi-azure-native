# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AbsoluteDeleteOptionResponse',
    'AdhocBasedTaggingCriteriaResponse',
    'AdhocBasedTriggerContextResponse',
    'AzureBackupParamsResponse',
    'AzureBackupRuleResponse',
    'AzureMonitorAlertSettingsResponse',
    'AzureOperationalStoreParametersResponse',
    'AzureRetentionRuleResponse',
    'BackupInstanceResponse',
    'BackupPolicyResponse',
    'BackupScheduleResponse',
    'BackupVaultResponse',
    'BlobBackupDatasourceParametersResponse',
    'CmkKekIdentityResponse',
    'CmkKeyVaultPropertiesResponse',
    'CopyOnExpiryOptionResponse',
    'CrossRegionRestoreSettingsResponse',
    'CrossSubscriptionRestoreSettingsResponse',
    'CustomCopyOptionResponse',
    'DataStoreInfoBaseResponse',
    'DatasourceResponse',
    'DatasourceSetResponse',
    'DayResponse',
    'DefaultResourcePropertiesResponse',
    'DppIdentityDetailsResponse',
    'EncryptionSettingsResponse',
    'FeatureSettingsResponse',
    'IdentityDetailsResponse',
    'ImmediateCopyOptionResponse',
    'ImmutabilitySettingsResponse',
    'InnerErrorResponse',
    'KubernetesClusterBackupDatasourceParametersResponse',
    'MonitoringSettingsResponse',
    'NamespacedNameResourceResponse',
    'PolicyInfoResponse',
    'PolicyParametersResponse',
    'ProtectionStatusDetailsResponse',
    'ResourceGuardOperationDetailResponse',
    'ResourceGuardOperationResponse',
    'ResourceGuardProxyBaseResponse',
    'ResourceGuardResponse',
    'ResourceMoveDetailsResponse',
    'RetentionTagResponse',
    'ScheduleBasedBackupCriteriaResponse',
    'ScheduleBasedTriggerContextResponse',
    'SecretStoreBasedAuthCredentialsResponse',
    'SecretStoreResourceResponse',
    'SecuritySettingsResponse',
    'SoftDeleteSettingsResponse',
    'SourceLifeCycleResponse',
    'StorageSettingResponse',
    'SystemDataResponse',
    'TaggingCriteriaResponse',
    'TargetCopySettingResponse',
    'UserAssignedIdentityResponse',
    'UserFacingErrorResponse',
]

@pulumi.output_type
class AbsoluteDeleteOptionResponse(dict):
    """
    Delete option with duration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AbsoluteDeleteOptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AbsoluteDeleteOptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AbsoluteDeleteOptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: _builtins.str,
                 object_type: _builtins.str):
        """
        Delete option with duration
        :param _builtins.str duration: Duration of deletion after given timespan
        :param _builtins.str object_type: Type of the specific object - used for deserializing
               Expected value is 'AbsoluteDeleteOption'.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "object_type", 'AbsoluteDeleteOption')

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.str:
        """
        Duration of deletion after given timespan
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of the specific object - used for deserializing
        Expected value is 'AbsoluteDeleteOption'.
        """
        return pulumi.get(self, "object_type")


@pulumi.output_type
class AdhocBasedTaggingCriteriaResponse(dict):
    """
    Adhoc backup tagging criteria
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagInfo":
            suggest = "tag_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdhocBasedTaggingCriteriaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdhocBasedTaggingCriteriaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdhocBasedTaggingCriteriaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_info: Optional['outputs.RetentionTagResponse'] = None):
        """
        Adhoc backup tagging criteria
        :param 'RetentionTagResponse' tag_info: Retention tag information
        """
        if tag_info is not None:
            pulumi.set(__self__, "tag_info", tag_info)

    @_builtins.property
    @pulumi.getter(name="tagInfo")
    def tag_info(self) -> Optional['outputs.RetentionTagResponse']:
        """
        Retention tag information
        """
        return pulumi.get(self, "tag_info")


@pulumi.output_type
class AdhocBasedTriggerContextResponse(dict):
    """
    Adhoc trigger context
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"
        elif key == "taggingCriteria":
            suggest = "tagging_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdhocBasedTriggerContextResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdhocBasedTriggerContextResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdhocBasedTriggerContextResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_type: _builtins.str,
                 tagging_criteria: 'outputs.AdhocBasedTaggingCriteriaResponse'):
        """
        Adhoc trigger context
        :param _builtins.str object_type: Type of the specific object - used for deserializing
               Expected value is 'AdhocBasedTriggerContext'.
        :param 'AdhocBasedTaggingCriteriaResponse' tagging_criteria: Tagging Criteria containing retention tag for adhoc backup.
        """
        pulumi.set(__self__, "object_type", 'AdhocBasedTriggerContext')
        pulumi.set(__self__, "tagging_criteria", tagging_criteria)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of the specific object - used for deserializing
        Expected value is 'AdhocBasedTriggerContext'.
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter(name="taggingCriteria")
    def tagging_criteria(self) -> 'outputs.AdhocBasedTaggingCriteriaResponse':
        """
        Tagging Criteria containing retention tag for adhoc backup.
        """
        return pulumi.get(self, "tagging_criteria")


@pulumi.output_type
class AzureBackupParamsResponse(dict):
    """
    Azure backup parameters
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupType":
            suggest = "backup_type"
        elif key == "objectType":
            suggest = "object_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureBackupParamsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureBackupParamsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureBackupParamsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_type: _builtins.str,
                 object_type: _builtins.str):
        """
        Azure backup parameters
        :param _builtins.str backup_type: BackupType ; Full/Incremental etc
        :param _builtins.str object_type: Type of the specific object - used for deserializing
               Expected value is 'AzureBackupParams'.
        """
        pulumi.set(__self__, "backup_type", backup_type)
        pulumi.set(__self__, "object_type", 'AzureBackupParams')

    @_builtins.property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> _builtins.str:
        """
        BackupType ; Full/Incremental etc
        """
        return pulumi.get(self, "backup_type")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of the specific object - used for deserializing
        Expected value is 'AzureBackupParams'.
        """
        return pulumi.get(self, "object_type")


@pulumi.output_type
class AzureBackupRuleResponse(dict):
    """
    Azure backup rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStore":
            suggest = "data_store"
        elif key == "objectType":
            suggest = "object_type"
        elif key == "backupParameters":
            suggest = "backup_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureBackupRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureBackupRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureBackupRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_store: 'outputs.DataStoreInfoBaseResponse',
                 name: _builtins.str,
                 object_type: _builtins.str,
                 trigger: Any,
                 backup_parameters: Optional['outputs.AzureBackupParamsResponse'] = None):
        """
        Azure backup rule
        :param 'DataStoreInfoBaseResponse' data_store: DataStoreInfo base
        :param _builtins.str object_type: 
               Expected value is 'AzureBackupRule'.
        :param Union['AdhocBasedTriggerContextResponse', 'ScheduleBasedTriggerContextResponse'] trigger: Trigger context
        :param 'AzureBackupParamsResponse' backup_parameters: BackupParameters base
        """
        pulumi.set(__self__, "data_store", data_store)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "object_type", 'AzureBackupRule')
        pulumi.set(__self__, "trigger", trigger)
        if backup_parameters is not None:
            pulumi.set(__self__, "backup_parameters", backup_parameters)

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> 'outputs.DataStoreInfoBaseResponse':
        """
        DataStoreInfo base
        """
        return pulumi.get(self, "data_store")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """

        Expected value is 'AzureBackupRule'.
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter
    def trigger(self) -> Any:
        """
        Trigger context
        """
        return pulumi.get(self, "trigger")

    @_builtins.property
    @pulumi.getter(name="backupParameters")
    def backup_parameters(self) -> Optional['outputs.AzureBackupParamsResponse']:
        """
        BackupParameters base
        """
        return pulumi.get(self, "backup_parameters")


@pulumi.output_type
class AzureMonitorAlertSettingsResponse(dict):
    """
    Settings for Azure Monitor based alerts
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertsForAllJobFailures":
            suggest = "alerts_for_all_job_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureMonitorAlertSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureMonitorAlertSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureMonitorAlertSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alerts_for_all_job_failures: Optional[_builtins.str] = None):
        """
        Settings for Azure Monitor based alerts
        """
        if alerts_for_all_job_failures is not None:
            pulumi.set(__self__, "alerts_for_all_job_failures", alerts_for_all_job_failures)

    @_builtins.property
    @pulumi.getter(name="alertsForAllJobFailures")
    def alerts_for_all_job_failures(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "alerts_for_all_job_failures")


@pulumi.output_type
class AzureOperationalStoreParametersResponse(dict):
    """
    Parameters for Operational-Tier DataStore
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStoreType":
            suggest = "data_store_type"
        elif key == "objectType":
            suggest = "object_type"
        elif key == "resourceGroupId":
            suggest = "resource_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureOperationalStoreParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureOperationalStoreParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureOperationalStoreParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_store_type: _builtins.str,
                 object_type: _builtins.str,
                 resource_group_id: Optional[_builtins.str] = None):
        """
        Parameters for Operational-Tier DataStore
        :param _builtins.str data_store_type: type of datastore; Operational/Vault/Archive
        :param _builtins.str object_type: Type of the specific object - used for deserializing
               Expected value is 'AzureOperationalStoreParameters'.
        :param _builtins.str resource_group_id: Gets or sets the Snapshot Resource Group Uri.
        """
        pulumi.set(__self__, "data_store_type", data_store_type)
        pulumi.set(__self__, "object_type", 'AzureOperationalStoreParameters')
        if resource_group_id is not None:
            pulumi.set(__self__, "resource_group_id", resource_group_id)

    @_builtins.property
    @pulumi.getter(name="dataStoreType")
    def data_store_type(self) -> _builtins.str:
        """
        type of datastore; Operational/Vault/Archive
        """
        return pulumi.get(self, "data_store_type")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of the specific object - used for deserializing
        Expected value is 'AzureOperationalStoreParameters'.
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter(name="resourceGroupId")
    def resource_group_id(self) -> Optional[_builtins.str]:
        """
        Gets or sets the Snapshot Resource Group Uri.
        """
        return pulumi.get(self, "resource_group_id")


@pulumi.output_type
class AzureRetentionRuleResponse(dict):
    """
    Azure retention rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"
        elif key == "isDefault":
            suggest = "is_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureRetentionRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureRetentionRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureRetentionRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lifecycles: Sequence['outputs.SourceLifeCycleResponse'],
                 name: _builtins.str,
                 object_type: _builtins.str,
                 is_default: Optional[_builtins.bool] = None):
        """
        Azure retention rule
        :param _builtins.str object_type: 
               Expected value is 'AzureRetentionRule'.
        """
        pulumi.set(__self__, "lifecycles", lifecycles)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "object_type", 'AzureRetentionRule')
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)

    @_builtins.property
    @pulumi.getter
    def lifecycles(self) -> Sequence['outputs.SourceLifeCycleResponse']:
        return pulumi.get(self, "lifecycles")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """

        Expected value is 'AzureRetentionRule'.
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_default")


@pulumi.output_type
class BackupInstanceResponse(dict):
    """
    Backup Instance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentProtectionState":
            suggest = "current_protection_state"
        elif key == "dataSourceInfo":
            suggest = "data_source_info"
        elif key == "objectType":
            suggest = "object_type"
        elif key == "policyInfo":
            suggest = "policy_info"
        elif key == "protectionErrorDetails":
            suggest = "protection_error_details"
        elif key == "protectionStatus":
            suggest = "protection_status"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "dataSourceSetInfo":
            suggest = "data_source_set_info"
        elif key == "datasourceAuthCredentials":
            suggest = "datasource_auth_credentials"
        elif key == "friendlyName":
            suggest = "friendly_name"
        elif key == "identityDetails":
            suggest = "identity_details"
        elif key == "resourceGuardOperationRequests":
            suggest = "resource_guard_operation_requests"
        elif key == "validationType":
            suggest = "validation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupInstanceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupInstanceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupInstanceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_protection_state: _builtins.str,
                 data_source_info: 'outputs.DatasourceResponse',
                 object_type: _builtins.str,
                 policy_info: 'outputs.PolicyInfoResponse',
                 protection_error_details: 'outputs.UserFacingErrorResponse',
                 protection_status: 'outputs.ProtectionStatusDetailsResponse',
                 provisioning_state: _builtins.str,
                 data_source_set_info: Optional['outputs.DatasourceSetResponse'] = None,
                 datasource_auth_credentials: Optional['outputs.SecretStoreBasedAuthCredentialsResponse'] = None,
                 friendly_name: Optional[_builtins.str] = None,
                 identity_details: Optional['outputs.IdentityDetailsResponse'] = None,
                 resource_guard_operation_requests: Optional[Sequence[_builtins.str]] = None,
                 validation_type: Optional[_builtins.str] = None):
        """
        Backup Instance
        :param _builtins.str current_protection_state: Specifies the current protection state of the resource
        :param 'DatasourceResponse' data_source_info: Gets or sets the data source information.
        :param 'PolicyInfoResponse' policy_info: Gets or sets the policy information.
        :param 'UserFacingErrorResponse' protection_error_details: Specifies the protection error of the resource
        :param 'ProtectionStatusDetailsResponse' protection_status: Specifies the protection status of the resource
        :param _builtins.str provisioning_state: Specifies the provisioning state of the resource i.e. provisioning/updating/Succeeded/Failed
        :param 'DatasourceSetResponse' data_source_set_info: Gets or sets the data source set information.
        :param 'SecretStoreBasedAuthCredentialsResponse' datasource_auth_credentials: Credentials to use to authenticate with data source provider.
        :param _builtins.str friendly_name: Gets or sets the Backup Instance friendly name.
        :param 'IdentityDetailsResponse' identity_details: Contains information of the Identity Details for the BI.
               If it is null, default will be considered as System Assigned.
        :param Sequence[_builtins.str] resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will be performed
        :param _builtins.str validation_type: Specifies the type of validation. In case of DeepValidation, all validations from /validateForBackup API will run again.
        """
        pulumi.set(__self__, "current_protection_state", current_protection_state)
        pulumi.set(__self__, "data_source_info", data_source_info)
        pulumi.set(__self__, "object_type", object_type)
        pulumi.set(__self__, "policy_info", policy_info)
        pulumi.set(__self__, "protection_error_details", protection_error_details)
        pulumi.set(__self__, "protection_status", protection_status)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if data_source_set_info is not None:
            pulumi.set(__self__, "data_source_set_info", data_source_set_info)
        if datasource_auth_credentials is not None:
            pulumi.set(__self__, "datasource_auth_credentials", datasource_auth_credentials)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if identity_details is not None:
            pulumi.set(__self__, "identity_details", identity_details)
        if resource_guard_operation_requests is not None:
            pulumi.set(__self__, "resource_guard_operation_requests", resource_guard_operation_requests)
        if validation_type is not None:
            pulumi.set(__self__, "validation_type", validation_type)

    @_builtins.property
    @pulumi.getter(name="currentProtectionState")
    def current_protection_state(self) -> _builtins.str:
        """
        Specifies the current protection state of the resource
        """
        return pulumi.get(self, "current_protection_state")

    @_builtins.property
    @pulumi.getter(name="dataSourceInfo")
    def data_source_info(self) -> 'outputs.DatasourceResponse':
        """
        Gets or sets the data source information.
        """
        return pulumi.get(self, "data_source_info")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter(name="policyInfo")
    def policy_info(self) -> 'outputs.PolicyInfoResponse':
        """
        Gets or sets the policy information.
        """
        return pulumi.get(self, "policy_info")

    @_builtins.property
    @pulumi.getter(name="protectionErrorDetails")
    def protection_error_details(self) -> 'outputs.UserFacingErrorResponse':
        """
        Specifies the protection error of the resource
        """
        return pulumi.get(self, "protection_error_details")

    @_builtins.property
    @pulumi.getter(name="protectionStatus")
    def protection_status(self) -> 'outputs.ProtectionStatusDetailsResponse':
        """
        Specifies the protection status of the resource
        """
        return pulumi.get(self, "protection_status")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Specifies the provisioning state of the resource i.e. provisioning/updating/Succeeded/Failed
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="dataSourceSetInfo")
    def data_source_set_info(self) -> Optional['outputs.DatasourceSetResponse']:
        """
        Gets or sets the data source set information.
        """
        return pulumi.get(self, "data_source_set_info")

    @_builtins.property
    @pulumi.getter(name="datasourceAuthCredentials")
    def datasource_auth_credentials(self) -> Optional['outputs.SecretStoreBasedAuthCredentialsResponse']:
        """
        Credentials to use to authenticate with data source provider.
        """
        return pulumi.get(self, "datasource_auth_credentials")

    @_builtins.property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[_builtins.str]:
        """
        Gets or sets the Backup Instance friendly name.
        """
        return pulumi.get(self, "friendly_name")

    @_builtins.property
    @pulumi.getter(name="identityDetails")
    def identity_details(self) -> Optional['outputs.IdentityDetailsResponse']:
        """
        Contains information of the Identity Details for the BI.
        If it is null, default will be considered as System Assigned.
        """
        return pulumi.get(self, "identity_details")

    @_builtins.property
    @pulumi.getter(name="resourceGuardOperationRequests")
    def resource_guard_operation_requests(self) -> Optional[Sequence[_builtins.str]]:
        """
        ResourceGuardOperationRequests on which LAC check will be performed
        """
        return pulumi.get(self, "resource_guard_operation_requests")

    @_builtins.property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> Optional[_builtins.str]:
        """
        Specifies the type of validation. In case of DeepValidation, all validations from /validateForBackup API will run again.
        """
        return pulumi.get(self, "validation_type")


@pulumi.output_type
class BackupPolicyResponse(dict):
    """
    Rule based backup policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasourceTypes":
            suggest = "datasource_types"
        elif key == "objectType":
            suggest = "object_type"
        elif key == "policyRules":
            suggest = "policy_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datasource_types: Sequence[_builtins.str],
                 object_type: _builtins.str,
                 policy_rules: Sequence[Any]):
        """
        Rule based backup policy
        :param Sequence[_builtins.str] datasource_types: Type of datasource for the backup management
        :param _builtins.str object_type: 
               Expected value is 'BackupPolicy'.
        :param Sequence[Union['AzureBackupRuleResponse', 'AzureRetentionRuleResponse']] policy_rules: Policy rule dictionary that contains rules for each backuptype i.e Full/Incremental/Logs etc
        """
        pulumi.set(__self__, "datasource_types", datasource_types)
        pulumi.set(__self__, "object_type", 'BackupPolicy')
        pulumi.set(__self__, "policy_rules", policy_rules)

    @_builtins.property
    @pulumi.getter(name="datasourceTypes")
    def datasource_types(self) -> Sequence[_builtins.str]:
        """
        Type of datasource for the backup management
        """
        return pulumi.get(self, "datasource_types")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """

        Expected value is 'BackupPolicy'.
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter(name="policyRules")
    def policy_rules(self) -> Sequence[Any]:
        """
        Policy rule dictionary that contains rules for each backuptype i.e Full/Incremental/Logs etc
        """
        return pulumi.get(self, "policy_rules")


@pulumi.output_type
class BackupScheduleResponse(dict):
    """
    Schedule for backup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repeatingTimeIntervals":
            suggest = "repeating_time_intervals"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repeating_time_intervals: Sequence[_builtins.str],
                 time_zone: Optional[_builtins.str] = None):
        """
        Schedule for backup
        :param Sequence[_builtins.str] repeating_time_intervals: Repeating time interval which only support the following ISO 8601 format [R/startDateTime/Duration]. Example: R/2007-03-01T13:00:00Z/P1Y2M10DT2H30M
        :param _builtins.str time_zone: Time zone for a schedule. Example: Pacific Standard Time
        """
        pulumi.set(__self__, "repeating_time_intervals", repeating_time_intervals)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="repeatingTimeIntervals")
    def repeating_time_intervals(self) -> Sequence[_builtins.str]:
        """
        Repeating time interval which only support the following ISO 8601 format [R/startDateTime/Duration]. Example: R/2007-03-01T13:00:00Z/P1Y2M10DT2H30M
        """
        return pulumi.get(self, "repeating_time_intervals")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        Time zone for a schedule. Example: Pacific Standard Time
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class BackupVaultResponse(dict):
    """
    Backup Vault
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bcdrSecurityLevel":
            suggest = "bcdr_security_level"
        elif key == "isVaultProtectedByResourceGuard":
            suggest = "is_vault_protected_by_resource_guard"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "resourceMoveDetails":
            suggest = "resource_move_details"
        elif key == "resourceMoveState":
            suggest = "resource_move_state"
        elif key == "secureScore":
            suggest = "secure_score"
        elif key == "storageSettings":
            suggest = "storage_settings"
        elif key == "featureSettings":
            suggest = "feature_settings"
        elif key == "monitoringSettings":
            suggest = "monitoring_settings"
        elif key == "replicatedRegions":
            suggest = "replicated_regions"
        elif key == "resourceGuardOperationRequests":
            suggest = "resource_guard_operation_requests"
        elif key == "securitySettings":
            suggest = "security_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupVaultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupVaultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupVaultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bcdr_security_level: _builtins.str,
                 is_vault_protected_by_resource_guard: _builtins.bool,
                 provisioning_state: _builtins.str,
                 resource_move_details: 'outputs.ResourceMoveDetailsResponse',
                 resource_move_state: _builtins.str,
                 secure_score: _builtins.str,
                 storage_settings: Sequence['outputs.StorageSettingResponse'],
                 feature_settings: Optional['outputs.FeatureSettingsResponse'] = None,
                 monitoring_settings: Optional['outputs.MonitoringSettingsResponse'] = None,
                 replicated_regions: Optional[Sequence[_builtins.str]] = None,
                 resource_guard_operation_requests: Optional[Sequence[_builtins.str]] = None,
                 security_settings: Optional['outputs.SecuritySettingsResponse'] = None):
        """
        Backup Vault
        :param _builtins.str bcdr_security_level: Security Level of Backup Vault
        :param _builtins.bool is_vault_protected_by_resource_guard: Is vault protected by resource guard
        :param _builtins.str provisioning_state: Provisioning state of the BackupVault resource
        :param 'ResourceMoveDetailsResponse' resource_move_details: Resource move details for backup vault
        :param _builtins.str resource_move_state: Resource move state for backup vault
        :param _builtins.str secure_score: Secure Score of Backup Vault
        :param Sequence['StorageSettingResponse'] storage_settings: Storage Settings
        :param 'FeatureSettingsResponse' feature_settings: Feature Settings
        :param 'MonitoringSettingsResponse' monitoring_settings: Monitoring Settings
        :param Sequence[_builtins.str] replicated_regions: List of replicated regions for Backup Vault
        :param Sequence[_builtins.str] resource_guard_operation_requests: ResourceGuardOperationRequests on which LAC check will be performed
        :param 'SecuritySettingsResponse' security_settings: Security Settings
        """
        pulumi.set(__self__, "bcdr_security_level", bcdr_security_level)
        pulumi.set(__self__, "is_vault_protected_by_resource_guard", is_vault_protected_by_resource_guard)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "resource_move_details", resource_move_details)
        pulumi.set(__self__, "resource_move_state", resource_move_state)
        pulumi.set(__self__, "secure_score", secure_score)
        pulumi.set(__self__, "storage_settings", storage_settings)
        if feature_settings is not None:
            pulumi.set(__self__, "feature_settings", feature_settings)
        if monitoring_settings is not None:
            pulumi.set(__self__, "monitoring_settings", monitoring_settings)
        if replicated_regions is not None:
            pulumi.set(__self__, "replicated_regions", replicated_regions)
        if resource_guard_operation_requests is not None:
            pulumi.set(__self__, "resource_guard_operation_requests", resource_guard_operation_requests)
        if security_settings is not None:
            pulumi.set(__self__, "security_settings", security_settings)

    @_builtins.property
    @pulumi.getter(name="bcdrSecurityLevel")
    def bcdr_security_level(self) -> _builtins.str:
        """
        Security Level of Backup Vault
        """
        return pulumi.get(self, "bcdr_security_level")

    @_builtins.property
    @pulumi.getter(name="isVaultProtectedByResourceGuard")
    def is_vault_protected_by_resource_guard(self) -> _builtins.bool:
        """
        Is vault protected by resource guard
        """
        return pulumi.get(self, "is_vault_protected_by_resource_guard")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the BackupVault resource
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="resourceMoveDetails")
    def resource_move_details(self) -> 'outputs.ResourceMoveDetailsResponse':
        """
        Resource move details for backup vault
        """
        return pulumi.get(self, "resource_move_details")

    @_builtins.property
    @pulumi.getter(name="resourceMoveState")
    def resource_move_state(self) -> _builtins.str:
        """
        Resource move state for backup vault
        """
        return pulumi.get(self, "resource_move_state")

    @_builtins.property
    @pulumi.getter(name="secureScore")
    def secure_score(self) -> _builtins.str:
        """
        Secure Score of Backup Vault
        """
        return pulumi.get(self, "secure_score")

    @_builtins.property
    @pulumi.getter(name="storageSettings")
    def storage_settings(self) -> Sequence['outputs.StorageSettingResponse']:
        """
        Storage Settings
        """
        return pulumi.get(self, "storage_settings")

    @_builtins.property
    @pulumi.getter(name="featureSettings")
    def feature_settings(self) -> Optional['outputs.FeatureSettingsResponse']:
        """
        Feature Settings
        """
        return pulumi.get(self, "feature_settings")

    @_builtins.property
    @pulumi.getter(name="monitoringSettings")
    def monitoring_settings(self) -> Optional['outputs.MonitoringSettingsResponse']:
        """
        Monitoring Settings
        """
        return pulumi.get(self, "monitoring_settings")

    @_builtins.property
    @pulumi.getter(name="replicatedRegions")
    def replicated_regions(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of replicated regions for Backup Vault
        """
        return pulumi.get(self, "replicated_regions")

    @_builtins.property
    @pulumi.getter(name="resourceGuardOperationRequests")
    def resource_guard_operation_requests(self) -> Optional[Sequence[_builtins.str]]:
        """
        ResourceGuardOperationRequests on which LAC check will be performed
        """
        return pulumi.get(self, "resource_guard_operation_requests")

    @_builtins.property
    @pulumi.getter(name="securitySettings")
    def security_settings(self) -> Optional['outputs.SecuritySettingsResponse']:
        """
        Security Settings
        """
        return pulumi.get(self, "security_settings")


@pulumi.output_type
class BlobBackupDatasourceParametersResponse(dict):
    """
    Parameters to be used during configuration of backup of blobs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containersList":
            suggest = "containers_list"
        elif key == "objectType":
            suggest = "object_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BlobBackupDatasourceParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BlobBackupDatasourceParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BlobBackupDatasourceParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 containers_list: Sequence[_builtins.str],
                 object_type: _builtins.str):
        """
        Parameters to be used during configuration of backup of blobs
        :param Sequence[_builtins.str] containers_list: List of containers to be backed up during configuration of backup of blobs
        :param _builtins.str object_type: Type of the specific object - used for deserializing
               Expected value is 'BlobBackupDatasourceParameters'.
        """
        pulumi.set(__self__, "containers_list", containers_list)
        pulumi.set(__self__, "object_type", 'BlobBackupDatasourceParameters')

    @_builtins.property
    @pulumi.getter(name="containersList")
    def containers_list(self) -> Sequence[_builtins.str]:
        """
        List of containers to be backed up during configuration of backup of blobs
        """
        return pulumi.get(self, "containers_list")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of the specific object - used for deserializing
        Expected value is 'BlobBackupDatasourceParameters'.
        """
        return pulumi.get(self, "object_type")


@pulumi.output_type
class CmkKekIdentityResponse(dict):
    """
    The details of the managed identity used for CMK
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityId":
            suggest = "identity_id"
        elif key == "identityType":
            suggest = "identity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CmkKekIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CmkKekIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CmkKekIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_id: Optional[_builtins.str] = None,
                 identity_type: Optional[_builtins.str] = None):
        """
        The details of the managed identity used for CMK
        :param _builtins.str identity_id: The managed identity to be used which has access permissions to the Key Vault. Provide a value here in case identity types: 'UserAssigned' only.
        :param _builtins.str identity_type: The identity type. 'SystemAssigned' and 'UserAssigned' are mutually exclusive. 'SystemAssigned' will use implicitly created managed identity.
        """
        if identity_id is not None:
            pulumi.set(__self__, "identity_id", identity_id)
        if identity_type is not None:
            pulumi.set(__self__, "identity_type", identity_type)

    @_builtins.property
    @pulumi.getter(name="identityId")
    def identity_id(self) -> Optional[_builtins.str]:
        """
        The managed identity to be used which has access permissions to the Key Vault. Provide a value here in case identity types: 'UserAssigned' only.
        """
        return pulumi.get(self, "identity_id")

    @_builtins.property
    @pulumi.getter(name="identityType")
    def identity_type(self) -> Optional[_builtins.str]:
        """
        The identity type. 'SystemAssigned' and 'UserAssigned' are mutually exclusive. 'SystemAssigned' will use implicitly created managed identity.
        """
        return pulumi.get(self, "identity_type")


@pulumi.output_type
class CmkKeyVaultPropertiesResponse(dict):
    """
    The properties of the Key Vault which hosts CMK
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyUri":
            suggest = "key_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CmkKeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CmkKeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CmkKeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_uri: Optional[_builtins.str] = None):
        """
        The properties of the Key Vault which hosts CMK
        :param _builtins.str key_uri: The key uri of the Customer Managed Key
        """
        if key_uri is not None:
            pulumi.set(__self__, "key_uri", key_uri)

    @_builtins.property
    @pulumi.getter(name="keyUri")
    def key_uri(self) -> Optional[_builtins.str]:
        """
        The key uri of the Customer Managed Key
        """
        return pulumi.get(self, "key_uri")


@pulumi.output_type
class CopyOnExpiryOptionResponse(dict):
    """
    Copy on Expiry Option
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CopyOnExpiryOptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CopyOnExpiryOptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CopyOnExpiryOptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_type: _builtins.str):
        """
        Copy on Expiry Option
        :param _builtins.str object_type: Type of the specific object - used for deserializing
               Expected value is 'CopyOnExpiryOption'.
        """
        pulumi.set(__self__, "object_type", 'CopyOnExpiryOption')

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of the specific object - used for deserializing
        Expected value is 'CopyOnExpiryOption'.
        """
        return pulumi.get(self, "object_type")


@pulumi.output_type
class CrossRegionRestoreSettingsResponse(dict):
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str state: CrossRegionRestore state
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        CrossRegionRestore state
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class CrossSubscriptionRestoreSettingsResponse(dict):
    """
    CrossSubscriptionRestore Settings
    """
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        CrossSubscriptionRestore Settings
        :param _builtins.str state: CrossSubscriptionRestore state
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        CrossSubscriptionRestore state
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class CustomCopyOptionResponse(dict):
    """
    Duration based custom options to copy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomCopyOptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomCopyOptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomCopyOptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_type: _builtins.str,
                 duration: Optional[_builtins.str] = None):
        """
        Duration based custom options to copy
        :param _builtins.str object_type: Type of the specific object - used for deserializing
               Expected value is 'CustomCopyOption'.
        :param _builtins.str duration: Data copied after given timespan
        """
        pulumi.set(__self__, "object_type", 'CustomCopyOption')
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of the specific object - used for deserializing
        Expected value is 'CustomCopyOption'.
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[_builtins.str]:
        """
        Data copied after given timespan
        """
        return pulumi.get(self, "duration")


@pulumi.output_type
class DataStoreInfoBaseResponse(dict):
    """
    DataStoreInfo base
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStoreType":
            suggest = "data_store_type"
        elif key == "objectType":
            suggest = "object_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataStoreInfoBaseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataStoreInfoBaseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataStoreInfoBaseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_store_type: _builtins.str,
                 object_type: _builtins.str):
        """
        DataStoreInfo base
        :param _builtins.str data_store_type: type of datastore; Operational/Vault/Archive
        :param _builtins.str object_type: Type of Datasource object, used to initialize the right inherited type
        """
        pulumi.set(__self__, "data_store_type", data_store_type)
        pulumi.set(__self__, "object_type", object_type)

    @_builtins.property
    @pulumi.getter(name="dataStoreType")
    def data_store_type(self) -> _builtins.str:
        """
        type of datastore; Operational/Vault/Archive
        """
        return pulumi.get(self, "data_store_type")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of Datasource object, used to initialize the right inherited type
        """
        return pulumi.get(self, "object_type")


@pulumi.output_type
class DatasourceResponse(dict):
    """
    Datasource to be backed up
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceID":
            suggest = "resource_id"
        elif key == "datasourceType":
            suggest = "datasource_type"
        elif key == "objectType":
            suggest = "object_type"
        elif key == "resourceLocation":
            suggest = "resource_location"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "resourceProperties":
            suggest = "resource_properties"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "resourceUri":
            suggest = "resource_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 datasource_type: Optional[_builtins.str] = None,
                 object_type: Optional[_builtins.str] = None,
                 resource_location: Optional[_builtins.str] = None,
                 resource_name: Optional[_builtins.str] = None,
                 resource_properties: Optional['outputs.DefaultResourcePropertiesResponse'] = None,
                 resource_type: Optional[_builtins.str] = None,
                 resource_uri: Optional[_builtins.str] = None):
        """
        Datasource to be backed up
        :param _builtins.str resource_id: Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will be the ID created by backup service via Fabric/Vault.
        :param _builtins.str datasource_type: DatasourceType of the resource.
        :param _builtins.str object_type: Type of Datasource object, used to initialize the right inherited type
        :param _builtins.str resource_location: Location of datasource.
        :param _builtins.str resource_name: Unique identifier of the resource in the context of parent.
        :param 'DefaultResourcePropertiesResponse' resource_properties: Properties specific to data source
        :param _builtins.str resource_type: Resource Type of Datasource.
        :param _builtins.str resource_uri: Uri of the resource.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        if datasource_type is not None:
            pulumi.set(__self__, "datasource_type", datasource_type)
        if object_type is not None:
            pulumi.set(__self__, "object_type", object_type)
        if resource_location is not None:
            pulumi.set(__self__, "resource_location", resource_location)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if resource_properties is not None:
            pulumi.set(__self__, "resource_properties", resource_properties)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)

    @_builtins.property
    @pulumi.getter(name="resourceID")
    def resource_id(self) -> _builtins.str:
        """
        Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will be the ID created by backup service via Fabric/Vault.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="datasourceType")
    def datasource_type(self) -> Optional[_builtins.str]:
        """
        DatasourceType of the resource.
        """
        return pulumi.get(self, "datasource_type")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> Optional[_builtins.str]:
        """
        Type of Datasource object, used to initialize the right inherited type
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter(name="resourceLocation")
    def resource_location(self) -> Optional[_builtins.str]:
        """
        Location of datasource.
        """
        return pulumi.get(self, "resource_location")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the resource in the context of parent.
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter(name="resourceProperties")
    def resource_properties(self) -> Optional['outputs.DefaultResourcePropertiesResponse']:
        """
        Properties specific to data source
        """
        return pulumi.get(self, "resource_properties")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        """
        Resource Type of Datasource.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[_builtins.str]:
        """
        Uri of the resource.
        """
        return pulumi.get(self, "resource_uri")


@pulumi.output_type
class DatasourceSetResponse(dict):
    """
    DatasourceSet details of datasource to be backed up
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceID":
            suggest = "resource_id"
        elif key == "datasourceType":
            suggest = "datasource_type"
        elif key == "objectType":
            suggest = "object_type"
        elif key == "resourceLocation":
            suggest = "resource_location"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "resourceProperties":
            suggest = "resource_properties"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "resourceUri":
            suggest = "resource_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatasourceSetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatasourceSetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatasourceSetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 datasource_type: Optional[_builtins.str] = None,
                 object_type: Optional[_builtins.str] = None,
                 resource_location: Optional[_builtins.str] = None,
                 resource_name: Optional[_builtins.str] = None,
                 resource_properties: Optional['outputs.DefaultResourcePropertiesResponse'] = None,
                 resource_type: Optional[_builtins.str] = None,
                 resource_uri: Optional[_builtins.str] = None):
        """
        DatasourceSet details of datasource to be backed up
        :param _builtins.str resource_id: Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will be the ID created by backup service via Fabric/Vault.
        :param _builtins.str datasource_type: DatasourceType of the resource.
        :param _builtins.str object_type: Type of Datasource object, used to initialize the right inherited type
        :param _builtins.str resource_location: Location of datasource.
        :param _builtins.str resource_name: Unique identifier of the resource in the context of parent.
        :param 'DefaultResourcePropertiesResponse' resource_properties: Properties specific to data source set
        :param _builtins.str resource_type: Resource Type of Datasource.
        :param _builtins.str resource_uri: Uri of the resource.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        if datasource_type is not None:
            pulumi.set(__self__, "datasource_type", datasource_type)
        if object_type is not None:
            pulumi.set(__self__, "object_type", object_type)
        if resource_location is not None:
            pulumi.set(__self__, "resource_location", resource_location)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if resource_properties is not None:
            pulumi.set(__self__, "resource_properties", resource_properties)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)

    @_builtins.property
    @pulumi.getter(name="resourceID")
    def resource_id(self) -> _builtins.str:
        """
        Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will be the ID created by backup service via Fabric/Vault.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="datasourceType")
    def datasource_type(self) -> Optional[_builtins.str]:
        """
        DatasourceType of the resource.
        """
        return pulumi.get(self, "datasource_type")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> Optional[_builtins.str]:
        """
        Type of Datasource object, used to initialize the right inherited type
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter(name="resourceLocation")
    def resource_location(self) -> Optional[_builtins.str]:
        """
        Location of datasource.
        """
        return pulumi.get(self, "resource_location")

    @_builtins.property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the resource in the context of parent.
        """
        return pulumi.get(self, "resource_name")

    @_builtins.property
    @pulumi.getter(name="resourceProperties")
    def resource_properties(self) -> Optional['outputs.DefaultResourcePropertiesResponse']:
        """
        Properties specific to data source set
        """
        return pulumi.get(self, "resource_properties")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        """
        Resource Type of Datasource.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[_builtins.str]:
        """
        Uri of the resource.
        """
        return pulumi.get(self, "resource_uri")


@pulumi.output_type
class DayResponse(dict):
    """
    Day of the week
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isLast":
            suggest = "is_last"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DayResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DayResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DayResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date: Optional[_builtins.int] = None,
                 is_last: Optional[_builtins.bool] = None):
        """
        Day of the week
        :param _builtins.int date: Date of the month
        :param _builtins.bool is_last: Whether Date is last date of month
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if is_last is not None:
            pulumi.set(__self__, "is_last", is_last)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[_builtins.int]:
        """
        Date of the month
        """
        return pulumi.get(self, "date")

    @_builtins.property
    @pulumi.getter(name="isLast")
    def is_last(self) -> Optional[_builtins.bool]:
        """
        Whether Date is last date of month
        """
        return pulumi.get(self, "is_last")


@pulumi.output_type
class DefaultResourcePropertiesResponse(dict):
    """
    Default source properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_type: _builtins.str):
        """
        Default source properties
        :param _builtins.str object_type: Type of the specific object - used for deserializing
               Expected value is 'DefaultResourceProperties'.
        """
        pulumi.set(__self__, "object_type", 'DefaultResourceProperties')

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of the specific object - used for deserializing
        Expected value is 'DefaultResourceProperties'.
        """
        return pulumi.get(self, "object_type")


@pulumi.output_type
class DppIdentityDetailsResponse(dict):
    """
    Identity details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DppIdentityDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DppIdentityDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DppIdentityDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: Optional[_builtins.str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Identity details
        :param _builtins.str principal_id: The object ID of the service principal object for the managed identity that is used to grant role-based access to an Azure resource.
        :param _builtins.str tenant_id: A Globally Unique Identifier (GUID) that represents the Azure AD tenant where the resource is now a member.
        :param _builtins.str type: The identityType which can be either SystemAssigned, UserAssigned, 'SystemAssigned,UserAssigned' or None
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: Gets or sets the user assigned identities.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The object ID of the service principal object for the managed identity that is used to grant role-based access to an Azure resource.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        A Globally Unique Identifier (GUID) that represents the Azure AD tenant where the resource is now a member.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The identityType which can be either SystemAssigned, UserAssigned, 'SystemAssigned,UserAssigned' or None
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        Gets or sets the user assigned identities.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class EncryptionSettingsResponse(dict):
    """
    Customer Managed Key details of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infrastructureEncryption":
            suggest = "infrastructure_encryption"
        elif key == "kekIdentity":
            suggest = "kek_identity"
        elif key == "keyVaultProperties":
            suggest = "key_vault_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 infrastructure_encryption: Optional[_builtins.str] = None,
                 kek_identity: Optional['outputs.CmkKekIdentityResponse'] = None,
                 key_vault_properties: Optional['outputs.CmkKeyVaultPropertiesResponse'] = None,
                 state: Optional[_builtins.str] = None):
        """
        Customer Managed Key details of the resource.
        :param _builtins.str infrastructure_encryption: Enabling/Disabling the Double Encryption state
        :param 'CmkKekIdentityResponse' kek_identity: The details of the managed identity used for CMK
        :param 'CmkKeyVaultPropertiesResponse' key_vault_properties: The properties of the Key Vault which hosts CMK
        :param _builtins.str state: Encryption state of the Backup Vault.
        """
        if infrastructure_encryption is not None:
            pulumi.set(__self__, "infrastructure_encryption", infrastructure_encryption)
        if kek_identity is not None:
            pulumi.set(__self__, "kek_identity", kek_identity)
        if key_vault_properties is not None:
            pulumi.set(__self__, "key_vault_properties", key_vault_properties)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="infrastructureEncryption")
    def infrastructure_encryption(self) -> Optional[_builtins.str]:
        """
        Enabling/Disabling the Double Encryption state
        """
        return pulumi.get(self, "infrastructure_encryption")

    @_builtins.property
    @pulumi.getter(name="kekIdentity")
    def kek_identity(self) -> Optional['outputs.CmkKekIdentityResponse']:
        """
        The details of the managed identity used for CMK
        """
        return pulumi.get(self, "kek_identity")

    @_builtins.property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> Optional['outputs.CmkKeyVaultPropertiesResponse']:
        """
        The properties of the Key Vault which hosts CMK
        """
        return pulumi.get(self, "key_vault_properties")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Encryption state of the Backup Vault.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class FeatureSettingsResponse(dict):
    """
    Class containing feature settings of vault
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossRegionRestoreSettings":
            suggest = "cross_region_restore_settings"
        elif key == "crossSubscriptionRestoreSettings":
            suggest = "cross_subscription_restore_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cross_region_restore_settings: Optional['outputs.CrossRegionRestoreSettingsResponse'] = None,
                 cross_subscription_restore_settings: Optional['outputs.CrossSubscriptionRestoreSettingsResponse'] = None):
        """
        Class containing feature settings of vault
        :param 'CrossSubscriptionRestoreSettingsResponse' cross_subscription_restore_settings: CrossSubscriptionRestore Settings
        """
        if cross_region_restore_settings is not None:
            pulumi.set(__self__, "cross_region_restore_settings", cross_region_restore_settings)
        if cross_subscription_restore_settings is not None:
            pulumi.set(__self__, "cross_subscription_restore_settings", cross_subscription_restore_settings)

    @_builtins.property
    @pulumi.getter(name="crossRegionRestoreSettings")
    def cross_region_restore_settings(self) -> Optional['outputs.CrossRegionRestoreSettingsResponse']:
        return pulumi.get(self, "cross_region_restore_settings")

    @_builtins.property
    @pulumi.getter(name="crossSubscriptionRestoreSettings")
    def cross_subscription_restore_settings(self) -> Optional['outputs.CrossSubscriptionRestoreSettingsResponse']:
        """
        CrossSubscriptionRestore Settings
        """
        return pulumi.get(self, "cross_subscription_restore_settings")


@pulumi.output_type
class IdentityDetailsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useSystemAssignedIdentity":
            suggest = "use_system_assigned_identity"
        elif key == "userAssignedIdentityArmUrl":
            suggest = "user_assigned_identity_arm_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 use_system_assigned_identity: Optional[_builtins.bool] = None,
                 user_assigned_identity_arm_url: Optional[_builtins.str] = None):
        """
        :param _builtins.bool use_system_assigned_identity: Specifies if the BI is protected by System Identity.
        :param _builtins.str user_assigned_identity_arm_url: ARM URL for User Assigned Identity.
        """
        if use_system_assigned_identity is not None:
            pulumi.set(__self__, "use_system_assigned_identity", use_system_assigned_identity)
        if user_assigned_identity_arm_url is not None:
            pulumi.set(__self__, "user_assigned_identity_arm_url", user_assigned_identity_arm_url)

    @_builtins.property
    @pulumi.getter(name="useSystemAssignedIdentity")
    def use_system_assigned_identity(self) -> Optional[_builtins.bool]:
        """
        Specifies if the BI is protected by System Identity.
        """
        return pulumi.get(self, "use_system_assigned_identity")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentityArmUrl")
    def user_assigned_identity_arm_url(self) -> Optional[_builtins.str]:
        """
        ARM URL for User Assigned Identity.
        """
        return pulumi.get(self, "user_assigned_identity_arm_url")


@pulumi.output_type
class ImmediateCopyOptionResponse(dict):
    """
    Immediate copy Option
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ImmediateCopyOptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ImmediateCopyOptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ImmediateCopyOptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_type: _builtins.str):
        """
        Immediate copy Option
        :param _builtins.str object_type: Type of the specific object - used for deserializing
               Expected value is 'ImmediateCopyOption'.
        """
        pulumi.set(__self__, "object_type", 'ImmediateCopyOption')

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of the specific object - used for deserializing
        Expected value is 'ImmediateCopyOption'.
        """
        return pulumi.get(self, "object_type")


@pulumi.output_type
class ImmutabilitySettingsResponse(dict):
    """
    Immutability Settings at vault level
    """
    def __init__(__self__, *,
                 state: Optional[_builtins.str] = None):
        """
        Immutability Settings at vault level
        :param _builtins.str state: Immutability state
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        Immutability state
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class InnerErrorResponse(dict):
    """
    Inner Error
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalInfo":
            suggest = "additional_info"
        elif key == "embeddedInnerError":
            suggest = "embedded_inner_error"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InnerErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InnerErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InnerErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_info: Optional[Mapping[str, _builtins.str]] = None,
                 code: Optional[_builtins.str] = None,
                 embedded_inner_error: Optional['outputs.InnerErrorResponse'] = None):
        """
        Inner Error
        :param Mapping[str, _builtins.str] additional_info: Any Key value pairs that can be provided to the client for additional  verbose information.
        :param _builtins.str code: Unique code for this error
        :param 'InnerErrorResponse' embedded_inner_error: Child Inner Error, to allow Nesting.
        """
        if additional_info is not None:
            pulumi.set(__self__, "additional_info", additional_info)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if embedded_inner_error is not None:
            pulumi.set(__self__, "embedded_inner_error", embedded_inner_error)

    @_builtins.property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Any Key value pairs that can be provided to the client for additional  verbose information.
        """
        return pulumi.get(self, "additional_info")

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        Unique code for this error
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter(name="embeddedInnerError")
    def embedded_inner_error(self) -> Optional['outputs.InnerErrorResponse']:
        """
        Child Inner Error, to allow Nesting.
        """
        return pulumi.get(self, "embedded_inner_error")


@pulumi.output_type
class KubernetesClusterBackupDatasourceParametersResponse(dict):
    """
    Parameters for Kubernetes Cluster Backup Datasource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeClusterScopeResources":
            suggest = "include_cluster_scope_resources"
        elif key == "objectType":
            suggest = "object_type"
        elif key == "snapshotVolumes":
            suggest = "snapshot_volumes"
        elif key == "backupHookReferences":
            suggest = "backup_hook_references"
        elif key == "excludedNamespaces":
            suggest = "excluded_namespaces"
        elif key == "excludedResourceTypes":
            suggest = "excluded_resource_types"
        elif key == "includedNamespaces":
            suggest = "included_namespaces"
        elif key == "includedResourceTypes":
            suggest = "included_resource_types"
        elif key == "includedVolumeTypes":
            suggest = "included_volume_types"
        elif key == "labelSelectors":
            suggest = "label_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterBackupDatasourceParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterBackupDatasourceParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterBackupDatasourceParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_cluster_scope_resources: _builtins.bool,
                 object_type: _builtins.str,
                 snapshot_volumes: _builtins.bool,
                 backup_hook_references: Optional[Sequence['outputs.NamespacedNameResourceResponse']] = None,
                 excluded_namespaces: Optional[Sequence[_builtins.str]] = None,
                 excluded_resource_types: Optional[Sequence[_builtins.str]] = None,
                 included_namespaces: Optional[Sequence[_builtins.str]] = None,
                 included_resource_types: Optional[Sequence[_builtins.str]] = None,
                 included_volume_types: Optional[Sequence[_builtins.str]] = None,
                 label_selectors: Optional[Sequence[_builtins.str]] = None):
        """
        Parameters for Kubernetes Cluster Backup Datasource
        :param _builtins.bool include_cluster_scope_resources: Gets or sets the include cluster resources property. This property if enabled will include cluster scope resources during backup.
        :param _builtins.str object_type: Type of the specific object - used for deserializing
               Expected value is 'KubernetesClusterBackupDatasourceParameters'.
        :param _builtins.bool snapshot_volumes: Gets or sets the volume snapshot property. This property if enabled will take volume snapshots during backup.
        :param Sequence['NamespacedNameResourceResponse'] backup_hook_references: Gets or sets the backup hook references. This property sets the hook reference to be executed during backup.
        :param Sequence[_builtins.str] excluded_namespaces: Gets or sets the exclude namespaces property. This property sets the namespaces to be excluded during backup.
        :param Sequence[_builtins.str] excluded_resource_types: Gets or sets the exclude resource types property. This property sets the resource types to be excluded during backup.
        :param Sequence[_builtins.str] included_namespaces: Gets or sets the include namespaces property. This property sets the namespaces to be included during backup.
        :param Sequence[_builtins.str] included_resource_types: Gets or sets the include resource types property. This property sets the resource types to be included during backup.
        :param Sequence[_builtins.str] included_volume_types: Gets or sets the include volume types property. This property sets the volume types to be included during backup.
        :param Sequence[_builtins.str] label_selectors: Gets or sets the LabelSelectors property. This property sets the resource with such label selectors to be included during backup.
        """
        pulumi.set(__self__, "include_cluster_scope_resources", include_cluster_scope_resources)
        pulumi.set(__self__, "object_type", 'KubernetesClusterBackupDatasourceParameters')
        pulumi.set(__self__, "snapshot_volumes", snapshot_volumes)
        if backup_hook_references is not None:
            pulumi.set(__self__, "backup_hook_references", backup_hook_references)
        if excluded_namespaces is not None:
            pulumi.set(__self__, "excluded_namespaces", excluded_namespaces)
        if excluded_resource_types is not None:
            pulumi.set(__self__, "excluded_resource_types", excluded_resource_types)
        if included_namespaces is not None:
            pulumi.set(__self__, "included_namespaces", included_namespaces)
        if included_resource_types is not None:
            pulumi.set(__self__, "included_resource_types", included_resource_types)
        if included_volume_types is not None:
            pulumi.set(__self__, "included_volume_types", included_volume_types)
        if label_selectors is not None:
            pulumi.set(__self__, "label_selectors", label_selectors)

    @_builtins.property
    @pulumi.getter(name="includeClusterScopeResources")
    def include_cluster_scope_resources(self) -> _builtins.bool:
        """
        Gets or sets the include cluster resources property. This property if enabled will include cluster scope resources during backup.
        """
        return pulumi.get(self, "include_cluster_scope_resources")

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of the specific object - used for deserializing
        Expected value is 'KubernetesClusterBackupDatasourceParameters'.
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter(name="snapshotVolumes")
    def snapshot_volumes(self) -> _builtins.bool:
        """
        Gets or sets the volume snapshot property. This property if enabled will take volume snapshots during backup.
        """
        return pulumi.get(self, "snapshot_volumes")

    @_builtins.property
    @pulumi.getter(name="backupHookReferences")
    def backup_hook_references(self) -> Optional[Sequence['outputs.NamespacedNameResourceResponse']]:
        """
        Gets or sets the backup hook references. This property sets the hook reference to be executed during backup.
        """
        return pulumi.get(self, "backup_hook_references")

    @_builtins.property
    @pulumi.getter(name="excludedNamespaces")
    def excluded_namespaces(self) -> Optional[Sequence[_builtins.str]]:
        """
        Gets or sets the exclude namespaces property. This property sets the namespaces to be excluded during backup.
        """
        return pulumi.get(self, "excluded_namespaces")

    @_builtins.property
    @pulumi.getter(name="excludedResourceTypes")
    def excluded_resource_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        Gets or sets the exclude resource types property. This property sets the resource types to be excluded during backup.
        """
        return pulumi.get(self, "excluded_resource_types")

    @_builtins.property
    @pulumi.getter(name="includedNamespaces")
    def included_namespaces(self) -> Optional[Sequence[_builtins.str]]:
        """
        Gets or sets the include namespaces property. This property sets the namespaces to be included during backup.
        """
        return pulumi.get(self, "included_namespaces")

    @_builtins.property
    @pulumi.getter(name="includedResourceTypes")
    def included_resource_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        Gets or sets the include resource types property. This property sets the resource types to be included during backup.
        """
        return pulumi.get(self, "included_resource_types")

    @_builtins.property
    @pulumi.getter(name="includedVolumeTypes")
    def included_volume_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        Gets or sets the include volume types property. This property sets the volume types to be included during backup.
        """
        return pulumi.get(self, "included_volume_types")

    @_builtins.property
    @pulumi.getter(name="labelSelectors")
    def label_selectors(self) -> Optional[Sequence[_builtins.str]]:
        """
        Gets or sets the LabelSelectors property. This property sets the resource with such label selectors to be included during backup.
        """
        return pulumi.get(self, "label_selectors")


@pulumi.output_type
class MonitoringSettingsResponse(dict):
    """
    Monitoring Settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureMonitorAlertSettings":
            suggest = "azure_monitor_alert_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_monitor_alert_settings: Optional['outputs.AzureMonitorAlertSettingsResponse'] = None):
        """
        Monitoring Settings
        :param 'AzureMonitorAlertSettingsResponse' azure_monitor_alert_settings: Settings for Azure Monitor based alerts
        """
        if azure_monitor_alert_settings is not None:
            pulumi.set(__self__, "azure_monitor_alert_settings", azure_monitor_alert_settings)

    @_builtins.property
    @pulumi.getter(name="azureMonitorAlertSettings")
    def azure_monitor_alert_settings(self) -> Optional['outputs.AzureMonitorAlertSettingsResponse']:
        """
        Settings for Azure Monitor based alerts
        """
        return pulumi.get(self, "azure_monitor_alert_settings")


@pulumi.output_type
class NamespacedNameResourceResponse(dict):
    """
    Class to refer resources which contains namespace and name
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None):
        """
        Class to refer resources which contains namespace and name
        :param _builtins.str name: Name of the resource
        :param _builtins.str namespace: Namespace in which the resource exists
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Namespace in which the resource exists
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class PolicyInfoResponse(dict):
    """
    Policy Info in backupInstance
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyId":
            suggest = "policy_id"
        elif key == "policyVersion":
            suggest = "policy_version"
        elif key == "policyParameters":
            suggest = "policy_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_id: _builtins.str,
                 policy_version: _builtins.str,
                 policy_parameters: Optional['outputs.PolicyParametersResponse'] = None):
        """
        Policy Info in backupInstance
        :param 'PolicyParametersResponse' policy_parameters: Policy parameters for the backup instance
        """
        pulumi.set(__self__, "policy_id", policy_id)
        pulumi.set(__self__, "policy_version", policy_version)
        if policy_parameters is not None:
            pulumi.set(__self__, "policy_parameters", policy_parameters)

    @_builtins.property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> _builtins.str:
        return pulumi.get(self, "policy_id")

    @_builtins.property
    @pulumi.getter(name="policyVersion")
    def policy_version(self) -> _builtins.str:
        return pulumi.get(self, "policy_version")

    @_builtins.property
    @pulumi.getter(name="policyParameters")
    def policy_parameters(self) -> Optional['outputs.PolicyParametersResponse']:
        """
        Policy parameters for the backup instance
        """
        return pulumi.get(self, "policy_parameters")


@pulumi.output_type
class PolicyParametersResponse(dict):
    """
    Parameters in Policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupDatasourceParametersList":
            suggest = "backup_datasource_parameters_list"
        elif key == "dataStoreParametersList":
            suggest = "data_store_parameters_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_datasource_parameters_list: Optional[Sequence[Any]] = None,
                 data_store_parameters_list: Optional[Sequence['outputs.AzureOperationalStoreParametersResponse']] = None):
        """
        Parameters in Policy
        :param Sequence[Union['BlobBackupDatasourceParametersResponse', 'KubernetesClusterBackupDatasourceParametersResponse']] backup_datasource_parameters_list: Gets or sets the Backup Data Source Parameters
        :param Sequence['AzureOperationalStoreParametersResponse'] data_store_parameters_list: Gets or sets the DataStore Parameters
        """
        if backup_datasource_parameters_list is not None:
            pulumi.set(__self__, "backup_datasource_parameters_list", backup_datasource_parameters_list)
        if data_store_parameters_list is not None:
            pulumi.set(__self__, "data_store_parameters_list", data_store_parameters_list)

    @_builtins.property
    @pulumi.getter(name="backupDatasourceParametersList")
    def backup_datasource_parameters_list(self) -> Optional[Sequence[Any]]:
        """
        Gets or sets the Backup Data Source Parameters
        """
        return pulumi.get(self, "backup_datasource_parameters_list")

    @_builtins.property
    @pulumi.getter(name="dataStoreParametersList")
    def data_store_parameters_list(self) -> Optional[Sequence['outputs.AzureOperationalStoreParametersResponse']]:
        """
        Gets or sets the DataStore Parameters
        """
        return pulumi.get(self, "data_store_parameters_list")


@pulumi.output_type
class ProtectionStatusDetailsResponse(dict):
    """
    Protection status details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorDetails":
            suggest = "error_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProtectionStatusDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProtectionStatusDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProtectionStatusDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_details: Optional['outputs.UserFacingErrorResponse'] = None,
                 status: Optional[_builtins.str] = None):
        """
        Protection status details
        :param 'UserFacingErrorResponse' error_details: Specifies the protection status error of the resource
        :param _builtins.str status: Specifies the protection status of the resource
        """
        if error_details is not None:
            pulumi.set(__self__, "error_details", error_details)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="errorDetails")
    def error_details(self) -> Optional['outputs.UserFacingErrorResponse']:
        """
        Specifies the protection status error of the resource
        """
        return pulumi.get(self, "error_details")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Specifies the protection status of the resource
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ResourceGuardOperationDetailResponse(dict):
    """
    VaultCritical Operation protected by a resource guard
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultResourceRequest":
            suggest = "default_resource_request"
        elif key == "vaultCriticalOperation":
            suggest = "vault_critical_operation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGuardOperationDetailResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGuardOperationDetailResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGuardOperationDetailResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_resource_request: Optional[_builtins.str] = None,
                 vault_critical_operation: Optional[_builtins.str] = None):
        """
        VaultCritical Operation protected by a resource guard
        """
        if default_resource_request is not None:
            pulumi.set(__self__, "default_resource_request", default_resource_request)
        if vault_critical_operation is not None:
            pulumi.set(__self__, "vault_critical_operation", vault_critical_operation)

    @_builtins.property
    @pulumi.getter(name="defaultResourceRequest")
    def default_resource_request(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_resource_request")

    @_builtins.property
    @pulumi.getter(name="vaultCriticalOperation")
    def vault_critical_operation(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vault_critical_operation")


@pulumi.output_type
class ResourceGuardOperationResponse(dict):
    """
    This class contains all the details about a critical operation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestResourceType":
            suggest = "request_resource_type"
        elif key == "vaultCriticalOperation":
            suggest = "vault_critical_operation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGuardOperationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGuardOperationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGuardOperationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_resource_type: _builtins.str,
                 vault_critical_operation: _builtins.str):
        """
        This class contains all the details about a critical operation.
        :param _builtins.str request_resource_type: Type of resource request.
        :param _builtins.str vault_critical_operation: Name of the critical operation.
        """
        pulumi.set(__self__, "request_resource_type", request_resource_type)
        pulumi.set(__self__, "vault_critical_operation", vault_critical_operation)

    @_builtins.property
    @pulumi.getter(name="requestResourceType")
    def request_resource_type(self) -> _builtins.str:
        """
        Type of resource request.
        """
        return pulumi.get(self, "request_resource_type")

    @_builtins.property
    @pulumi.getter(name="vaultCriticalOperation")
    def vault_critical_operation(self) -> _builtins.str:
        """
        Name of the critical operation.
        """
        return pulumi.get(self, "vault_critical_operation")


@pulumi.output_type
class ResourceGuardProxyBaseResponse(dict):
    """
    ResourceGuardProxyBase object, used in ResourceGuardProxyBaseResource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastUpdatedTime":
            suggest = "last_updated_time"
        elif key == "resourceGuardOperationDetails":
            suggest = "resource_guard_operation_details"
        elif key == "resourceGuardResourceId":
            suggest = "resource_guard_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGuardProxyBaseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGuardProxyBaseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGuardProxyBaseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 last_updated_time: Optional[_builtins.str] = None,
                 resource_guard_operation_details: Optional[Sequence['outputs.ResourceGuardOperationDetailResponse']] = None,
                 resource_guard_resource_id: Optional[_builtins.str] = None):
        """
        ResourceGuardProxyBase object, used in ResourceGuardProxyBaseResource
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if last_updated_time is not None:
            pulumi.set(__self__, "last_updated_time", last_updated_time)
        if resource_guard_operation_details is not None:
            pulumi.set(__self__, "resource_guard_operation_details", resource_guard_operation_details)
        if resource_guard_resource_id is not None:
            pulumi.set(__self__, "resource_guard_resource_id", resource_guard_resource_id)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="lastUpdatedTime")
    def last_updated_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "last_updated_time")

    @_builtins.property
    @pulumi.getter(name="resourceGuardOperationDetails")
    def resource_guard_operation_details(self) -> Optional[Sequence['outputs.ResourceGuardOperationDetailResponse']]:
        return pulumi.get(self, "resource_guard_operation_details")

    @_builtins.property
    @pulumi.getter(name="resourceGuardResourceId")
    def resource_guard_resource_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_guard_resource_id")


@pulumi.output_type
class ResourceGuardResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAutoApprovals":
            suggest = "allow_auto_approvals"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "resourceGuardOperations":
            suggest = "resource_guard_operations"
        elif key == "vaultCriticalOperationExclusionList":
            suggest = "vault_critical_operation_exclusion_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGuardResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGuardResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGuardResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_auto_approvals: _builtins.bool,
                 description: _builtins.str,
                 provisioning_state: _builtins.str,
                 resource_guard_operations: Sequence['outputs.ResourceGuardOperationResponse'],
                 vault_critical_operation_exclusion_list: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool allow_auto_approvals: This flag indicates whether auto approval is allowed or not.
        :param _builtins.str description: Description about the pre-req steps to perform all the critical operations.
        :param _builtins.str provisioning_state: Provisioning state of the BackupVault resource
        :param Sequence['ResourceGuardOperationResponse'] resource_guard_operations: {readonly} List of operation details those are protected by the ResourceGuard resource
        :param Sequence[_builtins.str] vault_critical_operation_exclusion_list: List of critical operations which are not protected by this resourceGuard
        """
        pulumi.set(__self__, "allow_auto_approvals", allow_auto_approvals)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "resource_guard_operations", resource_guard_operations)
        if vault_critical_operation_exclusion_list is not None:
            pulumi.set(__self__, "vault_critical_operation_exclusion_list", vault_critical_operation_exclusion_list)

    @_builtins.property
    @pulumi.getter(name="allowAutoApprovals")
    def allow_auto_approvals(self) -> _builtins.bool:
        """
        This flag indicates whether auto approval is allowed or not.
        """
        return pulumi.get(self, "allow_auto_approvals")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description about the pre-req steps to perform all the critical operations.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the BackupVault resource
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="resourceGuardOperations")
    def resource_guard_operations(self) -> Sequence['outputs.ResourceGuardOperationResponse']:
        """
        {readonly} List of operation details those are protected by the ResourceGuard resource
        """
        return pulumi.get(self, "resource_guard_operations")

    @_builtins.property
    @pulumi.getter(name="vaultCriticalOperationExclusionList")
    def vault_critical_operation_exclusion_list(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of critical operations which are not protected by this resourceGuard
        """
        return pulumi.get(self, "vault_critical_operation_exclusion_list")


@pulumi.output_type
class ResourceMoveDetailsResponse(dict):
    """
    ResourceMoveDetails will be returned in response to GetResource call from ARM
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "completionTimeUtc":
            suggest = "completion_time_utc"
        elif key == "operationId":
            suggest = "operation_id"
        elif key == "sourceResourcePath":
            suggest = "source_resource_path"
        elif key == "startTimeUtc":
            suggest = "start_time_utc"
        elif key == "targetResourcePath":
            suggest = "target_resource_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceMoveDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceMoveDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceMoveDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completion_time_utc: Optional[_builtins.str] = None,
                 operation_id: Optional[_builtins.str] = None,
                 source_resource_path: Optional[_builtins.str] = None,
                 start_time_utc: Optional[_builtins.str] = None,
                 target_resource_path: Optional[_builtins.str] = None):
        """
        ResourceMoveDetails will be returned in response to GetResource call from ARM
        :param _builtins.str completion_time_utc: Completion time in UTC of latest ResourceMove operation attempted. ISO 8601 format.
        :param _builtins.str operation_id: CorrelationId of latest ResourceMove operation attempted
        :param _builtins.str source_resource_path: ARM resource path of source resource
        :param _builtins.str start_time_utc: Start time in UTC of latest ResourceMove operation attempted. ISO 8601 format.
        :param _builtins.str target_resource_path: ARM resource path of target resource used in latest ResourceMove operation
        """
        if completion_time_utc is not None:
            pulumi.set(__self__, "completion_time_utc", completion_time_utc)
        if operation_id is not None:
            pulumi.set(__self__, "operation_id", operation_id)
        if source_resource_path is not None:
            pulumi.set(__self__, "source_resource_path", source_resource_path)
        if start_time_utc is not None:
            pulumi.set(__self__, "start_time_utc", start_time_utc)
        if target_resource_path is not None:
            pulumi.set(__self__, "target_resource_path", target_resource_path)

    @_builtins.property
    @pulumi.getter(name="completionTimeUtc")
    def completion_time_utc(self) -> Optional[_builtins.str]:
        """
        Completion time in UTC of latest ResourceMove operation attempted. ISO 8601 format.
        """
        return pulumi.get(self, "completion_time_utc")

    @_builtins.property
    @pulumi.getter(name="operationId")
    def operation_id(self) -> Optional[_builtins.str]:
        """
        CorrelationId of latest ResourceMove operation attempted
        """
        return pulumi.get(self, "operation_id")

    @_builtins.property
    @pulumi.getter(name="sourceResourcePath")
    def source_resource_path(self) -> Optional[_builtins.str]:
        """
        ARM resource path of source resource
        """
        return pulumi.get(self, "source_resource_path")

    @_builtins.property
    @pulumi.getter(name="startTimeUtc")
    def start_time_utc(self) -> Optional[_builtins.str]:
        """
        Start time in UTC of latest ResourceMove operation attempted. ISO 8601 format.
        """
        return pulumi.get(self, "start_time_utc")

    @_builtins.property
    @pulumi.getter(name="targetResourcePath")
    def target_resource_path(self) -> Optional[_builtins.str]:
        """
        ARM resource path of target resource used in latest ResourceMove operation
        """
        return pulumi.get(self, "target_resource_path")


@pulumi.output_type
class RetentionTagResponse(dict):
    """
    Retention tag
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eTag":
            suggest = "e_tag"
        elif key == "tagName":
            suggest = "tag_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RetentionTagResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RetentionTagResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RetentionTagResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 e_tag: _builtins.str,
                 id: _builtins.str,
                 tag_name: _builtins.str):
        """
        Retention tag
        :param _builtins.str e_tag: Retention Tag version.
        :param _builtins.str id: Retention Tag version.
        :param _builtins.str tag_name: Retention Tag Name to relate it to retention rule.
        """
        pulumi.set(__self__, "e_tag", e_tag)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "tag_name", tag_name)

    @_builtins.property
    @pulumi.getter(name="eTag")
    def e_tag(self) -> _builtins.str:
        """
        Retention Tag version.
        """
        return pulumi.get(self, "e_tag")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Retention Tag version.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> _builtins.str:
        """
        Retention Tag Name to relate it to retention rule.
        """
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class ScheduleBasedBackupCriteriaResponse(dict):
    """
    Schedule based backup criteria
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"
        elif key == "absoluteCriteria":
            suggest = "absolute_criteria"
        elif key == "daysOfMonth":
            suggest = "days_of_month"
        elif key == "daysOfTheWeek":
            suggest = "days_of_the_week"
        elif key == "monthsOfYear":
            suggest = "months_of_year"
        elif key == "scheduleTimes":
            suggest = "schedule_times"
        elif key == "weeksOfTheMonth":
            suggest = "weeks_of_the_month"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleBasedBackupCriteriaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleBasedBackupCriteriaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleBasedBackupCriteriaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_type: _builtins.str,
                 absolute_criteria: Optional[Sequence[_builtins.str]] = None,
                 days_of_month: Optional[Sequence['outputs.DayResponse']] = None,
                 days_of_the_week: Optional[Sequence[_builtins.str]] = None,
                 months_of_year: Optional[Sequence[_builtins.str]] = None,
                 schedule_times: Optional[Sequence[_builtins.str]] = None,
                 weeks_of_the_month: Optional[Sequence[_builtins.str]] = None):
        """
        Schedule based backup criteria
        :param _builtins.str object_type: Type of the specific object - used for deserializing
               Expected value is 'ScheduleBasedBackupCriteria'.
        :param Sequence[_builtins.str] absolute_criteria: it contains absolute values like "AllBackup" / "FirstOfDay" / "FirstOfWeek" / "FirstOfMonth"
               and should be part of AbsoluteMarker enum
        :param Sequence['DayResponse'] days_of_month: This is day of the month from 1 to 28 other wise last of month
        :param Sequence[_builtins.str] days_of_the_week: It should be Sunday/Monday/T..../Saturday
        :param Sequence[_builtins.str] months_of_year: It should be January/February/....../December
        :param Sequence[_builtins.str] schedule_times: List of schedule times for backup
        :param Sequence[_builtins.str] weeks_of_the_month: It should be First/Second/Third/Fourth/Last
        """
        pulumi.set(__self__, "object_type", 'ScheduleBasedBackupCriteria')
        if absolute_criteria is not None:
            pulumi.set(__self__, "absolute_criteria", absolute_criteria)
        if days_of_month is not None:
            pulumi.set(__self__, "days_of_month", days_of_month)
        if days_of_the_week is not None:
            pulumi.set(__self__, "days_of_the_week", days_of_the_week)
        if months_of_year is not None:
            pulumi.set(__self__, "months_of_year", months_of_year)
        if schedule_times is not None:
            pulumi.set(__self__, "schedule_times", schedule_times)
        if weeks_of_the_month is not None:
            pulumi.set(__self__, "weeks_of_the_month", weeks_of_the_month)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of the specific object - used for deserializing
        Expected value is 'ScheduleBasedBackupCriteria'.
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter(name="absoluteCriteria")
    def absolute_criteria(self) -> Optional[Sequence[_builtins.str]]:
        """
        it contains absolute values like "AllBackup" / "FirstOfDay" / "FirstOfWeek" / "FirstOfMonth"
        and should be part of AbsoluteMarker enum
        """
        return pulumi.get(self, "absolute_criteria")

    @_builtins.property
    @pulumi.getter(name="daysOfMonth")
    def days_of_month(self) -> Optional[Sequence['outputs.DayResponse']]:
        """
        This is day of the month from 1 to 28 other wise last of month
        """
        return pulumi.get(self, "days_of_month")

    @_builtins.property
    @pulumi.getter(name="daysOfTheWeek")
    def days_of_the_week(self) -> Optional[Sequence[_builtins.str]]:
        """
        It should be Sunday/Monday/T..../Saturday
        """
        return pulumi.get(self, "days_of_the_week")

    @_builtins.property
    @pulumi.getter(name="monthsOfYear")
    def months_of_year(self) -> Optional[Sequence[_builtins.str]]:
        """
        It should be January/February/....../December
        """
        return pulumi.get(self, "months_of_year")

    @_builtins.property
    @pulumi.getter(name="scheduleTimes")
    def schedule_times(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of schedule times for backup
        """
        return pulumi.get(self, "schedule_times")

    @_builtins.property
    @pulumi.getter(name="weeksOfTheMonth")
    def weeks_of_the_month(self) -> Optional[Sequence[_builtins.str]]:
        """
        It should be First/Second/Third/Fourth/Last
        """
        return pulumi.get(self, "weeks_of_the_month")


@pulumi.output_type
class ScheduleBasedTriggerContextResponse(dict):
    """
    Schedule based trigger context
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"
        elif key == "taggingCriteria":
            suggest = "tagging_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleBasedTriggerContextResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleBasedTriggerContextResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleBasedTriggerContextResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_type: _builtins.str,
                 schedule: 'outputs.BackupScheduleResponse',
                 tagging_criteria: Sequence['outputs.TaggingCriteriaResponse']):
        """
        Schedule based trigger context
        :param _builtins.str object_type: Type of the specific object - used for deserializing
               Expected value is 'ScheduleBasedTriggerContext'.
        :param 'BackupScheduleResponse' schedule: Schedule for this backup
        :param Sequence['TaggingCriteriaResponse'] tagging_criteria: List of tags that can be applicable for given schedule.
        """
        pulumi.set(__self__, "object_type", 'ScheduleBasedTriggerContext')
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "tagging_criteria", tagging_criteria)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of the specific object - used for deserializing
        Expected value is 'ScheduleBasedTriggerContext'.
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> 'outputs.BackupScheduleResponse':
        """
        Schedule for this backup
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter(name="taggingCriteria")
    def tagging_criteria(self) -> Sequence['outputs.TaggingCriteriaResponse']:
        """
        List of tags that can be applicable for given schedule.
        """
        return pulumi.get(self, "tagging_criteria")


@pulumi.output_type
class SecretStoreBasedAuthCredentialsResponse(dict):
    """
    Secret store based authentication credentials.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"
        elif key == "secretStoreResource":
            suggest = "secret_store_resource"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreBasedAuthCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreBasedAuthCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreBasedAuthCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_type: _builtins.str,
                 secret_store_resource: Optional['outputs.SecretStoreResourceResponse'] = None):
        """
        Secret store based authentication credentials.
        :param _builtins.str object_type: Type of the specific object - used for deserializing
               Expected value is 'SecretStoreBasedAuthCredentials'.
        :param 'SecretStoreResourceResponse' secret_store_resource: Secret store resource
        """
        pulumi.set(__self__, "object_type", 'SecretStoreBasedAuthCredentials')
        if secret_store_resource is not None:
            pulumi.set(__self__, "secret_store_resource", secret_store_resource)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        Type of the specific object - used for deserializing
        Expected value is 'SecretStoreBasedAuthCredentials'.
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter(name="secretStoreResource")
    def secret_store_resource(self) -> Optional['outputs.SecretStoreResourceResponse']:
        """
        Secret store resource
        """
        return pulumi.get(self, "secret_store_resource")


@pulumi.output_type
class SecretStoreResourceResponse(dict):
    """
    Class representing a secret store resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretStoreType":
            suggest = "secret_store_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretStoreResourceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretStoreResourceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretStoreResourceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_store_type: _builtins.str,
                 uri: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        Class representing a secret store resource.
        :param _builtins.str secret_store_type: Gets or sets the type of secret store
        :param _builtins.str uri: Uri to get to the resource
        :param _builtins.str value: Gets or sets value stored in secret store resource
        """
        pulumi.set(__self__, "secret_store_type", secret_store_type)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="secretStoreType")
    def secret_store_type(self) -> _builtins.str:
        """
        Gets or sets the type of secret store
        """
        return pulumi.get(self, "secret_store_type")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        Uri to get to the resource
        """
        return pulumi.get(self, "uri")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Gets or sets value stored in secret store resource
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SecuritySettingsResponse(dict):
    """
    Class containing security settings of vault
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionSettings":
            suggest = "encryption_settings"
        elif key == "immutabilitySettings":
            suggest = "immutability_settings"
        elif key == "softDeleteSettings":
            suggest = "soft_delete_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecuritySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecuritySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecuritySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_settings: Optional['outputs.EncryptionSettingsResponse'] = None,
                 immutability_settings: Optional['outputs.ImmutabilitySettingsResponse'] = None,
                 soft_delete_settings: Optional['outputs.SoftDeleteSettingsResponse'] = None):
        """
        Class containing security settings of vault
        :param 'EncryptionSettingsResponse' encryption_settings: Customer Managed Key details of the resource.
        :param 'ImmutabilitySettingsResponse' immutability_settings: Immutability Settings at vault level
        :param 'SoftDeleteSettingsResponse' soft_delete_settings: Soft delete related settings
        """
        if encryption_settings is not None:
            pulumi.set(__self__, "encryption_settings", encryption_settings)
        if immutability_settings is not None:
            pulumi.set(__self__, "immutability_settings", immutability_settings)
        if soft_delete_settings is not None:
            pulumi.set(__self__, "soft_delete_settings", soft_delete_settings)

    @_builtins.property
    @pulumi.getter(name="encryptionSettings")
    def encryption_settings(self) -> Optional['outputs.EncryptionSettingsResponse']:
        """
        Customer Managed Key details of the resource.
        """
        return pulumi.get(self, "encryption_settings")

    @_builtins.property
    @pulumi.getter(name="immutabilitySettings")
    def immutability_settings(self) -> Optional['outputs.ImmutabilitySettingsResponse']:
        """
        Immutability Settings at vault level
        """
        return pulumi.get(self, "immutability_settings")

    @_builtins.property
    @pulumi.getter(name="softDeleteSettings")
    def soft_delete_settings(self) -> Optional['outputs.SoftDeleteSettingsResponse']:
        """
        Soft delete related settings
        """
        return pulumi.get(self, "soft_delete_settings")


@pulumi.output_type
class SoftDeleteSettingsResponse(dict):
    """
    Soft delete related settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionDurationInDays":
            suggest = "retention_duration_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SoftDeleteSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SoftDeleteSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SoftDeleteSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retention_duration_in_days: Optional[_builtins.float] = None,
                 state: Optional[_builtins.str] = None):
        """
        Soft delete related settings
        :param _builtins.float retention_duration_in_days: Soft delete retention duration
        :param _builtins.str state: State of soft delete
        """
        if retention_duration_in_days is not None:
            pulumi.set(__self__, "retention_duration_in_days", retention_duration_in_days)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="retentionDurationInDays")
    def retention_duration_in_days(self) -> Optional[_builtins.float]:
        """
        Soft delete retention duration
        """
        return pulumi.get(self, "retention_duration_in_days")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        State of soft delete
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class SourceLifeCycleResponse(dict):
    """
    Source LifeCycle
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteAfter":
            suggest = "delete_after"
        elif key == "sourceDataStore":
            suggest = "source_data_store"
        elif key == "targetDataStoreCopySettings":
            suggest = "target_data_store_copy_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLifeCycleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLifeCycleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLifeCycleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_after: 'outputs.AbsoluteDeleteOptionResponse',
                 source_data_store: 'outputs.DataStoreInfoBaseResponse',
                 target_data_store_copy_settings: Optional[Sequence['outputs.TargetCopySettingResponse']] = None):
        """
        Source LifeCycle
        :param 'AbsoluteDeleteOptionResponse' delete_after: Delete Option
        :param 'DataStoreInfoBaseResponse' source_data_store: DataStoreInfo base
        """
        pulumi.set(__self__, "delete_after", delete_after)
        pulumi.set(__self__, "source_data_store", source_data_store)
        if target_data_store_copy_settings is not None:
            pulumi.set(__self__, "target_data_store_copy_settings", target_data_store_copy_settings)

    @_builtins.property
    @pulumi.getter(name="deleteAfter")
    def delete_after(self) -> 'outputs.AbsoluteDeleteOptionResponse':
        """
        Delete Option
        """
        return pulumi.get(self, "delete_after")

    @_builtins.property
    @pulumi.getter(name="sourceDataStore")
    def source_data_store(self) -> 'outputs.DataStoreInfoBaseResponse':
        """
        DataStoreInfo base
        """
        return pulumi.get(self, "source_data_store")

    @_builtins.property
    @pulumi.getter(name="targetDataStoreCopySettings")
    def target_data_store_copy_settings(self) -> Optional[Sequence['outputs.TargetCopySettingResponse']]:
        return pulumi.get(self, "target_data_store_copy_settings")


@pulumi.output_type
class StorageSettingResponse(dict):
    """
    Storage setting
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreType":
            suggest = "datastore_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageSettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageSettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageSettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datastore_type: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Storage setting
        :param _builtins.str datastore_type: Gets or sets the type of the datastore.
        :param _builtins.str type: Gets or sets the type.
        """
        if datastore_type is not None:
            pulumi.set(__self__, "datastore_type", datastore_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="datastoreType")
    def datastore_type(self) -> Optional[_builtins.str]:
        """
        Gets or sets the type of the datastore.
        """
        return pulumi.get(self, "datastore_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Gets or sets the type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TaggingCriteriaResponse(dict):
    """
    Tagging criteria
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDefault":
            suggest = "is_default"
        elif key == "tagInfo":
            suggest = "tag_info"
        elif key == "taggingPriority":
            suggest = "tagging_priority"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaggingCriteriaResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaggingCriteriaResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaggingCriteriaResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_default: _builtins.bool,
                 tag_info: 'outputs.RetentionTagResponse',
                 tagging_priority: _builtins.float,
                 criteria: Optional[Sequence['outputs.ScheduleBasedBackupCriteriaResponse']] = None):
        """
        Tagging criteria
        :param _builtins.bool is_default: Specifies if tag is default.
        :param 'RetentionTagResponse' tag_info: Retention tag information
        :param _builtins.float tagging_priority: Retention Tag priority.
        :param Sequence['ScheduleBasedBackupCriteriaResponse'] criteria: Criteria which decides whether the tag can be applied to a triggered backup.
        """
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "tag_info", tag_info)
        pulumi.set(__self__, "tagging_priority", tagging_priority)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> _builtins.bool:
        """
        Specifies if tag is default.
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter(name="tagInfo")
    def tag_info(self) -> 'outputs.RetentionTagResponse':
        """
        Retention tag information
        """
        return pulumi.get(self, "tag_info")

    @_builtins.property
    @pulumi.getter(name="taggingPriority")
    def tagging_priority(self) -> _builtins.float:
        """
        Retention Tag priority.
        """
        return pulumi.get(self, "tagging_priority")

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[Sequence['outputs.ScheduleBasedBackupCriteriaResponse']]:
        """
        Criteria which decides whether the tag can be applied to a triggered backup.
        """
        return pulumi.get(self, "criteria")


@pulumi.output_type
class TargetCopySettingResponse(dict):
    """
    Target copy settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyAfter":
            suggest = "copy_after"
        elif key == "dataStore":
            suggest = "data_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetCopySettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetCopySettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetCopySettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_after: Any,
                 data_store: 'outputs.DataStoreInfoBaseResponse'):
        """
        Target copy settings
        :param Union['CopyOnExpiryOptionResponse', 'CustomCopyOptionResponse', 'ImmediateCopyOptionResponse'] copy_after: It can be CustomCopyOption or ImmediateCopyOption.
        :param 'DataStoreInfoBaseResponse' data_store: Info of target datastore
        """
        pulumi.set(__self__, "copy_after", copy_after)
        pulumi.set(__self__, "data_store", data_store)

    @_builtins.property
    @pulumi.getter(name="copyAfter")
    def copy_after(self) -> Any:
        """
        It can be CustomCopyOption or ImmediateCopyOption.
        """
        return pulumi.get(self, "copy_after")

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> 'outputs.DataStoreInfoBaseResponse':
        """
        Info of target datastore
        """
        return pulumi.get(self, "data_store")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 principal_id: _builtins.str):
        """
        User assigned identity properties
        :param _builtins.str client_id: The client ID of the assigned identity.
        :param _builtins.str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class UserFacingErrorResponse(dict):
    """
    Error object used by layers that have access to localized content, and propagate that to user
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "innerError":
            suggest = "inner_error"
        elif key == "isRetryable":
            suggest = "is_retryable"
        elif key == "isUserError":
            suggest = "is_user_error"
        elif key == "recommendedAction":
            suggest = "recommended_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserFacingErrorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserFacingErrorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserFacingErrorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 details: Optional[Sequence['outputs.UserFacingErrorResponse']] = None,
                 inner_error: Optional['outputs.InnerErrorResponse'] = None,
                 is_retryable: Optional[_builtins.bool] = None,
                 is_user_error: Optional[_builtins.bool] = None,
                 message: Optional[_builtins.str] = None,
                 properties: Optional[Mapping[str, _builtins.str]] = None,
                 recommended_action: Optional[Sequence[_builtins.str]] = None,
                 target: Optional[_builtins.str] = None):
        """
        Error object used by layers that have access to localized content, and propagate that to user
        :param _builtins.str code: Unique code for this error
        :param Sequence['UserFacingErrorResponse'] details: Additional related Errors
        :param 'InnerErrorResponse' inner_error: Inner Error
        :param _builtins.bool is_retryable: Whether the operation will be retryable or not
        :param _builtins.bool is_user_error: Whether the operation is due to a user error or service error
        :param Mapping[str, _builtins.str] properties: Any key value pairs that can be injected inside error object
        :param Sequence[_builtins.str] recommended_action: RecommendedAction  localized.
        :param _builtins.str target: Target of the error.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if inner_error is not None:
            pulumi.set(__self__, "inner_error", inner_error)
        if is_retryable is not None:
            pulumi.set(__self__, "is_retryable", is_retryable)
        if is_user_error is not None:
            pulumi.set(__self__, "is_user_error", is_user_error)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if recommended_action is not None:
            pulumi.set(__self__, "recommended_action", recommended_action)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        Unique code for this error
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.UserFacingErrorResponse']]:
        """
        Additional related Errors
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter(name="innerError")
    def inner_error(self) -> Optional['outputs.InnerErrorResponse']:
        """
        Inner Error
        """
        return pulumi.get(self, "inner_error")

    @_builtins.property
    @pulumi.getter(name="isRetryable")
    def is_retryable(self) -> Optional[_builtins.bool]:
        """
        Whether the operation will be retryable or not
        """
        return pulumi.get(self, "is_retryable")

    @_builtins.property
    @pulumi.getter(name="isUserError")
    def is_user_error(self) -> Optional[_builtins.bool]:
        """
        Whether the operation is due to a user error or service error
        """
        return pulumi.get(self, "is_user_error")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Any key value pairs that can be injected inside error object
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter(name="recommendedAction")
    def recommended_action(self) -> Optional[Sequence[_builtins.str]]:
        """
        RecommendedAction  localized.
        """
        return pulumi.get(self, "recommended_action")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        Target of the error.
        """
        return pulumi.get(self, "target")


