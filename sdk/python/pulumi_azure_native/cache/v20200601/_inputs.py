# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'RedisCommonPropertiesRedisConfigurationArgs',
    'RedisCommonPropertiesRedisConfigurationArgsDict',
    'SkuArgs',
    'SkuArgsDict',
]

MYPY = False

if not MYPY:
    class RedisCommonPropertiesRedisConfigurationArgsDict(TypedDict):
        """
        All Redis Settings. Few possible keys: rdb-backup-enabled,rdb-storage-connection-string,rdb-backup-frequency,maxmemory-delta,maxmemory-policy,notify-keyspace-events,maxmemory-samples,slowlog-log-slower-than,slowlog-max-len,list-max-ziplist-entries,list-max-ziplist-value,hash-max-ziplist-entries,hash-max-ziplist-value,set-max-intset-entries,zset-max-ziplist-entries,zset-max-ziplist-value etc.
        """
        aof_storage_connection_string0: NotRequired[pulumi.Input[str]]
        """
        First storage account connection string
        """
        aof_storage_connection_string1: NotRequired[pulumi.Input[str]]
        """
        Second storage account connection string
        """
        maxfragmentationmemory_reserved: NotRequired[pulumi.Input[str]]
        """
        Value in megabytes reserved for fragmentation per shard
        """
        maxmemory_delta: NotRequired[pulumi.Input[str]]
        """
        Value in megabytes reserved for non-cache usage per shard e.g. failover.
        """
        maxmemory_policy: NotRequired[pulumi.Input[str]]
        """
        The eviction strategy used when your data won't fit within its memory limit.
        """
        maxmemory_reserved: NotRequired[pulumi.Input[str]]
        """
        Value in megabytes reserved for non-cache usage per shard e.g. failover.
        """
        rdb_backup_enabled: NotRequired[pulumi.Input[str]]
        """
        Specifies whether the rdb backup is enabled
        """
        rdb_backup_frequency: NotRequired[pulumi.Input[str]]
        """
        Specifies the frequency for creating rdb backup
        """
        rdb_backup_max_snapshot_count: NotRequired[pulumi.Input[str]]
        """
        Specifies the maximum number of snapshots for rdb backup
        """
        rdb_storage_connection_string: NotRequired[pulumi.Input[str]]
        """
        The storage account connection string for storing rdb file
        """
elif False:
    RedisCommonPropertiesRedisConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RedisCommonPropertiesRedisConfigurationArgs:
    def __init__(__self__, *,
                 aof_storage_connection_string0: Optional[pulumi.Input[str]] = None,
                 aof_storage_connection_string1: Optional[pulumi.Input[str]] = None,
                 maxfragmentationmemory_reserved: Optional[pulumi.Input[str]] = None,
                 maxmemory_delta: Optional[pulumi.Input[str]] = None,
                 maxmemory_policy: Optional[pulumi.Input[str]] = None,
                 maxmemory_reserved: Optional[pulumi.Input[str]] = None,
                 rdb_backup_enabled: Optional[pulumi.Input[str]] = None,
                 rdb_backup_frequency: Optional[pulumi.Input[str]] = None,
                 rdb_backup_max_snapshot_count: Optional[pulumi.Input[str]] = None,
                 rdb_storage_connection_string: Optional[pulumi.Input[str]] = None):
        """
        All Redis Settings. Few possible keys: rdb-backup-enabled,rdb-storage-connection-string,rdb-backup-frequency,maxmemory-delta,maxmemory-policy,notify-keyspace-events,maxmemory-samples,slowlog-log-slower-than,slowlog-max-len,list-max-ziplist-entries,list-max-ziplist-value,hash-max-ziplist-entries,hash-max-ziplist-value,set-max-intset-entries,zset-max-ziplist-entries,zset-max-ziplist-value etc.
        :param pulumi.Input[str] aof_storage_connection_string0: First storage account connection string
        :param pulumi.Input[str] aof_storage_connection_string1: Second storage account connection string
        :param pulumi.Input[str] maxfragmentationmemory_reserved: Value in megabytes reserved for fragmentation per shard
        :param pulumi.Input[str] maxmemory_delta: Value in megabytes reserved for non-cache usage per shard e.g. failover.
        :param pulumi.Input[str] maxmemory_policy: The eviction strategy used when your data won't fit within its memory limit.
        :param pulumi.Input[str] maxmemory_reserved: Value in megabytes reserved for non-cache usage per shard e.g. failover.
        :param pulumi.Input[str] rdb_backup_enabled: Specifies whether the rdb backup is enabled
        :param pulumi.Input[str] rdb_backup_frequency: Specifies the frequency for creating rdb backup
        :param pulumi.Input[str] rdb_backup_max_snapshot_count: Specifies the maximum number of snapshots for rdb backup
        :param pulumi.Input[str] rdb_storage_connection_string: The storage account connection string for storing rdb file
        """
        if aof_storage_connection_string0 is not None:
            pulumi.set(__self__, "aof_storage_connection_string0", aof_storage_connection_string0)
        if aof_storage_connection_string1 is not None:
            pulumi.set(__self__, "aof_storage_connection_string1", aof_storage_connection_string1)
        if maxfragmentationmemory_reserved is not None:
            pulumi.set(__self__, "maxfragmentationmemory_reserved", maxfragmentationmemory_reserved)
        if maxmemory_delta is not None:
            pulumi.set(__self__, "maxmemory_delta", maxmemory_delta)
        if maxmemory_policy is not None:
            pulumi.set(__self__, "maxmemory_policy", maxmemory_policy)
        if maxmemory_reserved is not None:
            pulumi.set(__self__, "maxmemory_reserved", maxmemory_reserved)
        if rdb_backup_enabled is not None:
            pulumi.set(__self__, "rdb_backup_enabled", rdb_backup_enabled)
        if rdb_backup_frequency is not None:
            pulumi.set(__self__, "rdb_backup_frequency", rdb_backup_frequency)
        if rdb_backup_max_snapshot_count is not None:
            pulumi.set(__self__, "rdb_backup_max_snapshot_count", rdb_backup_max_snapshot_count)
        if rdb_storage_connection_string is not None:
            pulumi.set(__self__, "rdb_storage_connection_string", rdb_storage_connection_string)

    @property
    @pulumi.getter(name="aofStorageConnectionString0")
    def aof_storage_connection_string0(self) -> Optional[pulumi.Input[str]]:
        """
        First storage account connection string
        """
        return pulumi.get(self, "aof_storage_connection_string0")

    @aof_storage_connection_string0.setter
    def aof_storage_connection_string0(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aof_storage_connection_string0", value)

    @property
    @pulumi.getter(name="aofStorageConnectionString1")
    def aof_storage_connection_string1(self) -> Optional[pulumi.Input[str]]:
        """
        Second storage account connection string
        """
        return pulumi.get(self, "aof_storage_connection_string1")

    @aof_storage_connection_string1.setter
    def aof_storage_connection_string1(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aof_storage_connection_string1", value)

    @property
    @pulumi.getter(name="maxfragmentationmemoryReserved")
    def maxfragmentationmemory_reserved(self) -> Optional[pulumi.Input[str]]:
        """
        Value in megabytes reserved for fragmentation per shard
        """
        return pulumi.get(self, "maxfragmentationmemory_reserved")

    @maxfragmentationmemory_reserved.setter
    def maxfragmentationmemory_reserved(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maxfragmentationmemory_reserved", value)

    @property
    @pulumi.getter(name="maxmemoryDelta")
    def maxmemory_delta(self) -> Optional[pulumi.Input[str]]:
        """
        Value in megabytes reserved for non-cache usage per shard e.g. failover.
        """
        return pulumi.get(self, "maxmemory_delta")

    @maxmemory_delta.setter
    def maxmemory_delta(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maxmemory_delta", value)

    @property
    @pulumi.getter(name="maxmemoryPolicy")
    def maxmemory_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The eviction strategy used when your data won't fit within its memory limit.
        """
        return pulumi.get(self, "maxmemory_policy")

    @maxmemory_policy.setter
    def maxmemory_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maxmemory_policy", value)

    @property
    @pulumi.getter(name="maxmemoryReserved")
    def maxmemory_reserved(self) -> Optional[pulumi.Input[str]]:
        """
        Value in megabytes reserved for non-cache usage per shard e.g. failover.
        """
        return pulumi.get(self, "maxmemory_reserved")

    @maxmemory_reserved.setter
    def maxmemory_reserved(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maxmemory_reserved", value)

    @property
    @pulumi.getter(name="rdbBackupEnabled")
    def rdb_backup_enabled(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the rdb backup is enabled
        """
        return pulumi.get(self, "rdb_backup_enabled")

    @rdb_backup_enabled.setter
    def rdb_backup_enabled(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rdb_backup_enabled", value)

    @property
    @pulumi.getter(name="rdbBackupFrequency")
    def rdb_backup_frequency(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the frequency for creating rdb backup
        """
        return pulumi.get(self, "rdb_backup_frequency")

    @rdb_backup_frequency.setter
    def rdb_backup_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rdb_backup_frequency", value)

    @property
    @pulumi.getter(name="rdbBackupMaxSnapshotCount")
    def rdb_backup_max_snapshot_count(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the maximum number of snapshots for rdb backup
        """
        return pulumi.get(self, "rdb_backup_max_snapshot_count")

    @rdb_backup_max_snapshot_count.setter
    def rdb_backup_max_snapshot_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rdb_backup_max_snapshot_count", value)

    @property
    @pulumi.getter(name="rdbStorageConnectionString")
    def rdb_storage_connection_string(self) -> Optional[pulumi.Input[str]]:
        """
        The storage account connection string for storing rdb file
        """
        return pulumi.get(self, "rdb_storage_connection_string")

    @rdb_storage_connection_string.setter
    def rdb_storage_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rdb_storage_connection_string", value)


if not MYPY:
    class SkuArgsDict(TypedDict):
        """
        SKU parameters supplied to the create Redis operation.
        """
        capacity: pulumi.Input[int]
        """
        The size of the Redis cache to deploy. Valid values: for C (Basic/Standard) family (0, 1, 2, 3, 4, 5, 6), for P (Premium) family (1, 2, 3, 4).
        """
        family: pulumi.Input[Union[str, 'SkuFamily']]
        """
        The SKU family to use. Valid values: (C, P). (C = Basic/Standard, P = Premium).
        """
        name: pulumi.Input[Union[str, 'SkuName']]
        """
        The type of Redis cache to deploy. Valid values: (Basic, Standard, Premium)
        """
elif False:
    SkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 capacity: pulumi.Input[int],
                 family: pulumi.Input[Union[str, 'SkuFamily']],
                 name: pulumi.Input[Union[str, 'SkuName']]):
        """
        SKU parameters supplied to the create Redis operation.
        :param pulumi.Input[int] capacity: The size of the Redis cache to deploy. Valid values: for C (Basic/Standard) family (0, 1, 2, 3, 4, 5, 6), for P (Premium) family (1, 2, 3, 4).
        :param pulumi.Input[Union[str, 'SkuFamily']] family: The SKU family to use. Valid values: (C, P). (C = Basic/Standard, P = Premium).
        :param pulumi.Input[Union[str, 'SkuName']] name: The type of Redis cache to deploy. Valid values: (Basic, Standard, Premium)
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def capacity(self) -> pulumi.Input[int]:
        """
        The size of the Redis cache to deploy. Valid values: for C (Basic/Standard) family (0, 1, 2, 3, 4, 5, 6), for P (Premium) family (1, 2, 3, 4).
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: pulumi.Input[int]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[Union[str, 'SkuFamily']]:
        """
        The SKU family to use. Valid values: (C, P). (C = Basic/Standard, P = Premium).
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[Union[str, 'SkuFamily']]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[Union[str, 'SkuName']]:
        """
        The type of Redis cache to deploy. Valid values: (Basic, Standard, Premium)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[Union[str, 'SkuName']]):
        pulumi.set(self, "name", value)


