# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'AFDDomainHttpsParametersArgs',
    'ActivatedResourceReferenceArgs',
    'AfdRouteCacheConfigurationArgs',
    'AzureFirstPartyManagedCertificateParametersArgs',
    'CacheConfigurationArgs',
    'CacheExpirationActionParametersArgs',
    'CacheKeyQueryStringActionParametersArgs',
    'ClientPortMatchConditionParametersArgs',
    'CompressionSettingsArgs',
    'CookiesMatchConditionParametersArgs',
    'CustomRuleListArgs',
    'CustomRuleArgs',
    'CustomerCertificateParametersArgs',
    'DeepCreatedOriginGroupArgs',
    'DeepCreatedOriginArgs',
    'DeliveryRuleCacheExpirationActionArgs',
    'DeliveryRuleCacheKeyQueryStringActionArgs',
    'DeliveryRuleClientPortConditionArgs',
    'DeliveryRuleCookiesConditionArgs',
    'DeliveryRuleHostNameConditionArgs',
    'DeliveryRuleHttpVersionConditionArgs',
    'DeliveryRuleIsDeviceConditionArgs',
    'DeliveryRulePostArgsConditionArgs',
    'DeliveryRuleQueryStringConditionArgs',
    'DeliveryRuleRemoteAddressConditionArgs',
    'DeliveryRuleRequestBodyConditionArgs',
    'DeliveryRuleRequestHeaderActionArgs',
    'DeliveryRuleRequestHeaderConditionArgs',
    'DeliveryRuleRequestMethodConditionArgs',
    'DeliveryRuleRequestSchemeConditionArgs',
    'DeliveryRuleRequestUriConditionArgs',
    'DeliveryRuleResponseHeaderActionArgs',
    'DeliveryRuleRouteConfigurationOverrideActionArgs',
    'DeliveryRuleServerPortConditionArgs',
    'DeliveryRuleSocketAddrConditionArgs',
    'DeliveryRuleSslProtocolConditionArgs',
    'DeliveryRuleUrlFileExtensionConditionArgs',
    'DeliveryRuleUrlFileNameConditionArgs',
    'DeliveryRuleUrlPathConditionArgs',
    'DeliveryRuleArgs',
    'EndpointPropertiesUpdateParametersDeliveryPolicyArgs',
    'EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkArgs',
    'GeoFilterArgs',
    'HeaderActionParametersArgs',
    'HealthProbeParametersArgs',
    'HostNameMatchConditionParametersArgs',
    'HttpErrorRangeParametersArgs',
    'HttpVersionMatchConditionParametersArgs',
    'IsDeviceMatchConditionParametersArgs',
    'KeyVaultSigningKeyParametersArgs',
    'LoadBalancingSettingsParametersArgs',
    'ManagedCertificateParametersArgs',
    'ManagedRuleGroupOverrideArgs',
    'ManagedRuleOverrideArgs',
    'ManagedRuleSetListArgs',
    'ManagedRuleSetArgs',
    'ManagedServiceIdentityArgs',
    'MatchConditionArgs',
    'OriginGroupOverrideActionParametersArgs',
    'OriginGroupOverrideActionArgs',
    'OriginGroupOverrideArgs',
    'PolicySettingsArgs',
    'PostArgsMatchConditionParametersArgs',
    'QueryStringMatchConditionParametersArgs',
    'RateLimitRuleListArgs',
    'RateLimitRuleArgs',
    'RemoteAddressMatchConditionParametersArgs',
    'RequestBodyMatchConditionParametersArgs',
    'RequestHeaderMatchConditionParametersArgs',
    'RequestMethodMatchConditionParametersArgs',
    'RequestSchemeMatchConditionParametersArgs',
    'RequestUriMatchConditionParametersArgs',
    'ResourceReferenceArgs',
    'ResponseBasedOriginErrorDetectionParametersArgs',
    'RouteConfigurationOverrideActionParametersArgs',
    'SecurityPolicyWebApplicationFirewallAssociationArgs',
    'SecurityPolicyWebApplicationFirewallParametersArgs',
    'ServerPortMatchConditionParametersArgs',
    'SharedPrivateLinkResourcePropertiesArgs',
    'SkuArgs',
    'SocketAddrMatchConditionParametersArgs',
    'SslProtocolMatchConditionParametersArgs',
    'UrlFileExtensionMatchConditionParametersArgs',
    'UrlFileNameMatchConditionParametersArgs',
    'UrlPathMatchConditionParametersArgs',
    'UrlRedirectActionParametersArgs',
    'UrlRedirectActionArgs',
    'UrlRewriteActionParametersArgs',
    'UrlRewriteActionArgs',
    'UrlSigningActionParametersArgs',
    'UrlSigningActionArgs',
    'UrlSigningKeyParametersArgs',
    'UrlSigningKeyArgs',
    'UrlSigningParamIdentifierArgs',
]

@pulumi.input_type
class AFDDomainHttpsParametersArgs:
    def __init__(__self__, *,
                 certificate_type: pulumi.Input[Union[str, 'AfdCertificateType']],
                 minimum_tls_version: Optional[pulumi.Input['AfdMinimumTlsVersion']] = None,
                 secret: Optional[pulumi.Input['ResourceReferenceArgs']] = None):
        """
        The JSON object that contains the properties to secure a domain.
        :param pulumi.Input[Union[str, 'AfdCertificateType']] certificate_type: Defines the source of the SSL certificate.
        :param pulumi.Input['AfdMinimumTlsVersion'] minimum_tls_version: TLS protocol version that will be used for Https
        :param pulumi.Input['ResourceReferenceArgs'] secret: Resource reference to the secret. ie. subs/rg/profile/secret
        """
        AFDDomainHttpsParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_type=certificate_type,
            minimum_tls_version=minimum_tls_version,
            secret=secret,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_type: Optional[pulumi.Input[Union[str, 'AfdCertificateType']]] = None,
             minimum_tls_version: Optional[pulumi.Input['AfdMinimumTlsVersion']] = None,
             secret: Optional[pulumi.Input['ResourceReferenceArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if certificate_type is None and 'certificateType' in kwargs:
            certificate_type = kwargs['certificateType']
        if certificate_type is None:
            raise TypeError("Missing 'certificate_type' argument")
        if minimum_tls_version is None and 'minimumTlsVersion' in kwargs:
            minimum_tls_version = kwargs['minimumTlsVersion']

        _setter("certificate_type", certificate_type)
        if minimum_tls_version is not None:
            _setter("minimum_tls_version", minimum_tls_version)
        if secret is not None:
            _setter("secret", secret)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> pulumi.Input[Union[str, 'AfdCertificateType']]:
        """
        Defines the source of the SSL certificate.
        """
        return pulumi.get(self, "certificate_type")

    @certificate_type.setter
    def certificate_type(self, value: pulumi.Input[Union[str, 'AfdCertificateType']]):
        pulumi.set(self, "certificate_type", value)

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[pulumi.Input['AfdMinimumTlsVersion']]:
        """
        TLS protocol version that will be used for Https
        """
        return pulumi.get(self, "minimum_tls_version")

    @minimum_tls_version.setter
    def minimum_tls_version(self, value: Optional[pulumi.Input['AfdMinimumTlsVersion']]):
        pulumi.set(self, "minimum_tls_version", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ResourceReferenceArgs']]:
        """
        Resource reference to the secret. ie. subs/rg/profile/secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ResourceReferenceArgs']]):
        pulumi.set(self, "secret", value)


@pulumi.input_type
class ActivatedResourceReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Reference to another resource along with its state.
        :param pulumi.Input[str] id: Resource ID.
        """
        ActivatedResourceReferenceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class AfdRouteCacheConfigurationArgs:
    def __init__(__self__, *,
                 compression_settings: Optional[pulumi.Input['CompressionSettingsArgs']] = None,
                 query_parameters: Optional[pulumi.Input[str]] = None,
                 query_string_caching_behavior: Optional[pulumi.Input[Union[str, 'AfdQueryStringCachingBehavior']]] = None):
        """
        Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
        :param pulumi.Input['CompressionSettingsArgs'] compression_settings: compression settings.
        :param pulumi.Input[str] query_parameters: query parameters to include or exclude (comma separated).
        :param pulumi.Input[Union[str, 'AfdQueryStringCachingBehavior']] query_string_caching_behavior: Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
        """
        AfdRouteCacheConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compression_settings=compression_settings,
            query_parameters=query_parameters,
            query_string_caching_behavior=query_string_caching_behavior,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compression_settings: Optional[pulumi.Input['CompressionSettingsArgs']] = None,
             query_parameters: Optional[pulumi.Input[str]] = None,
             query_string_caching_behavior: Optional[pulumi.Input[Union[str, 'AfdQueryStringCachingBehavior']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if compression_settings is None and 'compressionSettings' in kwargs:
            compression_settings = kwargs['compressionSettings']
        if query_parameters is None and 'queryParameters' in kwargs:
            query_parameters = kwargs['queryParameters']
        if query_string_caching_behavior is None and 'queryStringCachingBehavior' in kwargs:
            query_string_caching_behavior = kwargs['queryStringCachingBehavior']

        if compression_settings is not None:
            _setter("compression_settings", compression_settings)
        if query_parameters is not None:
            _setter("query_parameters", query_parameters)
        if query_string_caching_behavior is not None:
            _setter("query_string_caching_behavior", query_string_caching_behavior)

    @property
    @pulumi.getter(name="compressionSettings")
    def compression_settings(self) -> Optional[pulumi.Input['CompressionSettingsArgs']]:
        """
        compression settings.
        """
        return pulumi.get(self, "compression_settings")

    @compression_settings.setter
    def compression_settings(self, value: Optional[pulumi.Input['CompressionSettingsArgs']]):
        pulumi.set(self, "compression_settings", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[pulumi.Input[str]]:
        """
        query parameters to include or exclude (comma separated).
        """
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_parameters", value)

    @property
    @pulumi.getter(name="queryStringCachingBehavior")
    def query_string_caching_behavior(self) -> Optional[pulumi.Input[Union[str, 'AfdQueryStringCachingBehavior']]]:
        """
        Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
        """
        return pulumi.get(self, "query_string_caching_behavior")

    @query_string_caching_behavior.setter
    def query_string_caching_behavior(self, value: Optional[pulumi.Input[Union[str, 'AfdQueryStringCachingBehavior']]]):
        pulumi.set(self, "query_string_caching_behavior", value)


@pulumi.input_type
class AzureFirstPartyManagedCertificateParametersArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 subject_alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Azure FirstParty Managed Certificate provided by other first party resource providers to enable HTTPS.
        :param pulumi.Input[str] type: The type of the secret resource.
               Expected value is 'AzureFirstPartyManagedCertificate'.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subject_alternative_names: The list of SANs.
        """
        AzureFirstPartyManagedCertificateParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            subject_alternative_names=subject_alternative_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             subject_alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if subject_alternative_names is None and 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']

        _setter("type", 'AzureFirstPartyManagedCertificate')
        if subject_alternative_names is not None:
            _setter("subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the secret resource.
        Expected value is 'AzureFirstPartyManagedCertificate'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of SANs.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subject_alternative_names", value)


@pulumi.input_type
class CacheConfigurationArgs:
    def __init__(__self__, *,
                 cache_behavior: Optional[pulumi.Input[Union[str, 'RuleCacheBehavior']]] = None,
                 cache_duration: Optional[pulumi.Input[str]] = None,
                 is_compression_enabled: Optional[pulumi.Input[Union[str, 'RuleIsCompressionEnabled']]] = None,
                 query_parameters: Optional[pulumi.Input[str]] = None,
                 query_string_caching_behavior: Optional[pulumi.Input[Union[str, 'RuleQueryStringCachingBehavior']]] = None):
        """
        Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
        :param pulumi.Input[Union[str, 'RuleCacheBehavior']] cache_behavior: Caching behavior for the requests
        :param pulumi.Input[str] cache_duration: The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
        :param pulumi.Input[Union[str, 'RuleIsCompressionEnabled']] is_compression_enabled: Indicates whether content compression is enabled. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        :param pulumi.Input[str] query_parameters: query parameters to include or exclude (comma separated).
        :param pulumi.Input[Union[str, 'RuleQueryStringCachingBehavior']] query_string_caching_behavior: Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
        """
        CacheConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cache_behavior=cache_behavior,
            cache_duration=cache_duration,
            is_compression_enabled=is_compression_enabled,
            query_parameters=query_parameters,
            query_string_caching_behavior=query_string_caching_behavior,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cache_behavior: Optional[pulumi.Input[Union[str, 'RuleCacheBehavior']]] = None,
             cache_duration: Optional[pulumi.Input[str]] = None,
             is_compression_enabled: Optional[pulumi.Input[Union[str, 'RuleIsCompressionEnabled']]] = None,
             query_parameters: Optional[pulumi.Input[str]] = None,
             query_string_caching_behavior: Optional[pulumi.Input[Union[str, 'RuleQueryStringCachingBehavior']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cache_behavior is None and 'cacheBehavior' in kwargs:
            cache_behavior = kwargs['cacheBehavior']
        if cache_duration is None and 'cacheDuration' in kwargs:
            cache_duration = kwargs['cacheDuration']
        if is_compression_enabled is None and 'isCompressionEnabled' in kwargs:
            is_compression_enabled = kwargs['isCompressionEnabled']
        if query_parameters is None and 'queryParameters' in kwargs:
            query_parameters = kwargs['queryParameters']
        if query_string_caching_behavior is None and 'queryStringCachingBehavior' in kwargs:
            query_string_caching_behavior = kwargs['queryStringCachingBehavior']

        if cache_behavior is not None:
            _setter("cache_behavior", cache_behavior)
        if cache_duration is not None:
            _setter("cache_duration", cache_duration)
        if is_compression_enabled is not None:
            _setter("is_compression_enabled", is_compression_enabled)
        if query_parameters is not None:
            _setter("query_parameters", query_parameters)
        if query_string_caching_behavior is not None:
            _setter("query_string_caching_behavior", query_string_caching_behavior)

    @property
    @pulumi.getter(name="cacheBehavior")
    def cache_behavior(self) -> Optional[pulumi.Input[Union[str, 'RuleCacheBehavior']]]:
        """
        Caching behavior for the requests
        """
        return pulumi.get(self, "cache_behavior")

    @cache_behavior.setter
    def cache_behavior(self, value: Optional[pulumi.Input[Union[str, 'RuleCacheBehavior']]]):
        pulumi.set(self, "cache_behavior", value)

    @property
    @pulumi.getter(name="cacheDuration")
    def cache_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
        """
        return pulumi.get(self, "cache_duration")

    @cache_duration.setter
    def cache_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_duration", value)

    @property
    @pulumi.getter(name="isCompressionEnabled")
    def is_compression_enabled(self) -> Optional[pulumi.Input[Union[str, 'RuleIsCompressionEnabled']]]:
        """
        Indicates whether content compression is enabled. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        """
        return pulumi.get(self, "is_compression_enabled")

    @is_compression_enabled.setter
    def is_compression_enabled(self, value: Optional[pulumi.Input[Union[str, 'RuleIsCompressionEnabled']]]):
        pulumi.set(self, "is_compression_enabled", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[pulumi.Input[str]]:
        """
        query parameters to include or exclude (comma separated).
        """
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_parameters", value)

    @property
    @pulumi.getter(name="queryStringCachingBehavior")
    def query_string_caching_behavior(self) -> Optional[pulumi.Input[Union[str, 'RuleQueryStringCachingBehavior']]]:
        """
        Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
        """
        return pulumi.get(self, "query_string_caching_behavior")

    @query_string_caching_behavior.setter
    def query_string_caching_behavior(self, value: Optional[pulumi.Input[Union[str, 'RuleQueryStringCachingBehavior']]]):
        pulumi.set(self, "query_string_caching_behavior", value)


@pulumi.input_type
class CacheExpirationActionParametersArgs:
    def __init__(__self__, *,
                 cache_behavior: pulumi.Input[Union[str, 'CacheBehavior']],
                 cache_type: pulumi.Input[Union[str, 'CacheType']],
                 type_name: pulumi.Input[str],
                 cache_duration: Optional[pulumi.Input[str]] = None):
        """
        Defines the parameters for the cache expiration action.
        :param pulumi.Input[Union[str, 'CacheBehavior']] cache_behavior: Caching behavior for the requests
        :param pulumi.Input[Union[str, 'CacheType']] cache_type: The level at which the content needs to be cached.
        :param pulumi.Input[str] cache_duration: The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
        """
        CacheExpirationActionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cache_behavior=cache_behavior,
            cache_type=cache_type,
            type_name=type_name,
            cache_duration=cache_duration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cache_behavior: Optional[pulumi.Input[Union[str, 'CacheBehavior']]] = None,
             cache_type: Optional[pulumi.Input[Union[str, 'CacheType']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             cache_duration: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cache_behavior is None and 'cacheBehavior' in kwargs:
            cache_behavior = kwargs['cacheBehavior']
        if cache_behavior is None:
            raise TypeError("Missing 'cache_behavior' argument")
        if cache_type is None and 'cacheType' in kwargs:
            cache_type = kwargs['cacheType']
        if cache_type is None:
            raise TypeError("Missing 'cache_type' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if cache_duration is None and 'cacheDuration' in kwargs:
            cache_duration = kwargs['cacheDuration']

        _setter("cache_behavior", cache_behavior)
        _setter("cache_type", cache_type)
        _setter("type_name", type_name)
        if cache_duration is not None:
            _setter("cache_duration", cache_duration)

    @property
    @pulumi.getter(name="cacheBehavior")
    def cache_behavior(self) -> pulumi.Input[Union[str, 'CacheBehavior']]:
        """
        Caching behavior for the requests
        """
        return pulumi.get(self, "cache_behavior")

    @cache_behavior.setter
    def cache_behavior(self, value: pulumi.Input[Union[str, 'CacheBehavior']]):
        pulumi.set(self, "cache_behavior", value)

    @property
    @pulumi.getter(name="cacheType")
    def cache_type(self) -> pulumi.Input[Union[str, 'CacheType']]:
        """
        The level at which the content needs to be cached.
        """
        return pulumi.get(self, "cache_type")

    @cache_type.setter
    def cache_type(self, value: pulumi.Input[Union[str, 'CacheType']]):
        pulumi.set(self, "cache_type", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="cacheDuration")
    def cache_duration(self) -> Optional[pulumi.Input[str]]:
        """
        The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
        """
        return pulumi.get(self, "cache_duration")

    @cache_duration.setter
    def cache_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_duration", value)


@pulumi.input_type
class CacheKeyQueryStringActionParametersArgs:
    def __init__(__self__, *,
                 query_string_behavior: pulumi.Input[Union[str, 'QueryStringBehavior']],
                 type_name: pulumi.Input[str],
                 query_parameters: Optional[pulumi.Input[str]] = None):
        """
        Defines the parameters for the cache-key query string action.
        :param pulumi.Input[Union[str, 'QueryStringBehavior']] query_string_behavior: Caching behavior for the requests
        :param pulumi.Input[str] query_parameters: query parameters to include or exclude (comma separated).
        """
        CacheKeyQueryStringActionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query_string_behavior=query_string_behavior,
            type_name=type_name,
            query_parameters=query_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query_string_behavior: Optional[pulumi.Input[Union[str, 'QueryStringBehavior']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             query_parameters: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if query_string_behavior is None and 'queryStringBehavior' in kwargs:
            query_string_behavior = kwargs['queryStringBehavior']
        if query_string_behavior is None:
            raise TypeError("Missing 'query_string_behavior' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if query_parameters is None and 'queryParameters' in kwargs:
            query_parameters = kwargs['queryParameters']

        _setter("query_string_behavior", query_string_behavior)
        _setter("type_name", type_name)
        if query_parameters is not None:
            _setter("query_parameters", query_parameters)

    @property
    @pulumi.getter(name="queryStringBehavior")
    def query_string_behavior(self) -> pulumi.Input[Union[str, 'QueryStringBehavior']]:
        """
        Caching behavior for the requests
        """
        return pulumi.get(self, "query_string_behavior")

    @query_string_behavior.setter
    def query_string_behavior(self, value: pulumi.Input[Union[str, 'QueryStringBehavior']]):
        pulumi.set(self, "query_string_behavior", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[pulumi.Input[str]]:
        """
        query parameters to include or exclude (comma separated).
        """
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_parameters", value)


@pulumi.input_type
class ClientPortMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'ClientPortOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for ClientPort match conditions
        :param pulumi.Input[Union[str, 'ClientPortOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        ClientPortMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'ClientPortOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'ClientPortOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'ClientPortOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class CompressionSettingsArgs:
    def __init__(__self__, *,
                 content_types_to_compress: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_compression_enabled: Optional[pulumi.Input[bool]] = None):
        """
        settings for compression.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] content_types_to_compress: List of content types on which compression applies. The value should be a valid MIME type.
        :param pulumi.Input[bool] is_compression_enabled: Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        """
        CompressionSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content_types_to_compress=content_types_to_compress,
            is_compression_enabled=is_compression_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content_types_to_compress: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             is_compression_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if content_types_to_compress is None and 'contentTypesToCompress' in kwargs:
            content_types_to_compress = kwargs['contentTypesToCompress']
        if is_compression_enabled is None and 'isCompressionEnabled' in kwargs:
            is_compression_enabled = kwargs['isCompressionEnabled']

        if content_types_to_compress is not None:
            _setter("content_types_to_compress", content_types_to_compress)
        if is_compression_enabled is not None:
            _setter("is_compression_enabled", is_compression_enabled)

    @property
    @pulumi.getter(name="contentTypesToCompress")
    def content_types_to_compress(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of content types on which compression applies. The value should be a valid MIME type.
        """
        return pulumi.get(self, "content_types_to_compress")

    @content_types_to_compress.setter
    def content_types_to_compress(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "content_types_to_compress", value)

    @property
    @pulumi.getter(name="isCompressionEnabled")
    def is_compression_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        """
        return pulumi.get(self, "is_compression_enabled")

    @is_compression_enabled.setter
    def is_compression_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_compression_enabled", value)


@pulumi.input_type
class CookiesMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'CookiesOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 selector: Optional[pulumi.Input[str]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for Cookies match conditions
        :param pulumi.Input[Union[str, 'CookiesOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[str] selector: Name of Cookies to be matched
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        CookiesMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            selector=selector,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'CookiesOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             selector: Optional[pulumi.Input[str]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if selector is not None:
            _setter("selector", selector)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'CookiesOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'CookiesOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[str]]:
        """
        Name of Cookies to be matched
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class CustomRuleListArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleArgs']]]] = None):
        """
        Defines contents of custom rules
        :param pulumi.Input[Sequence[pulumi.Input['CustomRuleArgs']]] rules: List of rules
        """
        CustomRuleListArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleArgs']]]]:
        """
        List of rules
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class CustomRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[Union[str, 'ActionType']],
                 match_conditions: pulumi.Input[Sequence[pulumi.Input['MatchConditionArgs']]],
                 name: pulumi.Input[str],
                 priority: pulumi.Input[int],
                 enabled_state: Optional[pulumi.Input[Union[str, 'CustomRuleEnabledState']]] = None):
        """
        Defines the common attributes for a custom rule that can be included in a waf policy
        :param pulumi.Input[Union[str, 'ActionType']] action: Describes what action to be applied when rule matches
        :param pulumi.Input[Sequence[pulumi.Input['MatchConditionArgs']]] match_conditions: List of match conditions.
        :param pulumi.Input[str] name: Defines the name of the custom rule
        :param pulumi.Input[int] priority: Defines in what order this rule be evaluated in the overall list of custom rules
        :param pulumi.Input[Union[str, 'CustomRuleEnabledState']] enabled_state: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
        """
        CustomRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            match_conditions=match_conditions,
            name=name,
            priority=priority,
            enabled_state=enabled_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[pulumi.Input[Union[str, 'ActionType']]] = None,
             match_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['MatchConditionArgs']]]] = None,
             name: Optional[pulumi.Input[str]] = None,
             priority: Optional[pulumi.Input[int]] = None,
             enabled_state: Optional[pulumi.Input[Union[str, 'CustomRuleEnabledState']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if match_conditions is None and 'matchConditions' in kwargs:
            match_conditions = kwargs['matchConditions']
        if match_conditions is None:
            raise TypeError("Missing 'match_conditions' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if enabled_state is None and 'enabledState' in kwargs:
            enabled_state = kwargs['enabledState']

        _setter("action", action)
        _setter("match_conditions", match_conditions)
        _setter("name", name)
        _setter("priority", priority)
        if enabled_state is not None:
            _setter("enabled_state", enabled_state)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[Union[str, 'ActionType']]:
        """
        Describes what action to be applied when rule matches
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[Union[str, 'ActionType']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> pulumi.Input[Sequence[pulumi.Input['MatchConditionArgs']]]:
        """
        List of match conditions.
        """
        return pulumi.get(self, "match_conditions")

    @match_conditions.setter
    def match_conditions(self, value: pulumi.Input[Sequence[pulumi.Input['MatchConditionArgs']]]):
        pulumi.set(self, "match_conditions", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Defines the name of the custom rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Defines in what order this rule be evaluated in the overall list of custom rules
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[pulumi.Input[Union[str, 'CustomRuleEnabledState']]]:
        """
        Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
        """
        return pulumi.get(self, "enabled_state")

    @enabled_state.setter
    def enabled_state(self, value: Optional[pulumi.Input[Union[str, 'CustomRuleEnabledState']]]):
        pulumi.set(self, "enabled_state", value)


@pulumi.input_type
class CustomerCertificateParametersArgs:
    def __init__(__self__, *,
                 secret_source: pulumi.Input['ResourceReferenceArgs'],
                 type: pulumi.Input[str],
                 secret_version: Optional[pulumi.Input[str]] = None,
                 subject_alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 use_latest_version: Optional[pulumi.Input[bool]] = None):
        """
        Customer Certificate used for https
        :param pulumi.Input['ResourceReferenceArgs'] secret_source: Resource reference to the Azure Key Vault certificate. Expected to be in format of /subscriptions/{​​​​​​​​​subscriptionId}​​​​​​​​​/resourceGroups/{​​​​​​​​​resourceGroupName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/providers/Microsoft.KeyVault/vaults/{vaultName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/secrets/{certificateName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
        :param pulumi.Input[str] type: The type of the secret resource.
               Expected value is 'CustomerCertificate'.
        :param pulumi.Input[str] secret_version: Version of the secret to be used
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subject_alternative_names: The list of SANs.
        :param pulumi.Input[bool] use_latest_version: Whether to use the latest version for the certificate
        """
        CustomerCertificateParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_source=secret_source,
            type=type,
            secret_version=secret_version,
            subject_alternative_names=subject_alternative_names,
            use_latest_version=use_latest_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_source: Optional[pulumi.Input['ResourceReferenceArgs']] = None,
             type: Optional[pulumi.Input[str]] = None,
             secret_version: Optional[pulumi.Input[str]] = None,
             subject_alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             use_latest_version: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if secret_source is None and 'secretSource' in kwargs:
            secret_source = kwargs['secretSource']
        if secret_source is None:
            raise TypeError("Missing 'secret_source' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if secret_version is None and 'secretVersion' in kwargs:
            secret_version = kwargs['secretVersion']
        if subject_alternative_names is None and 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']
        if use_latest_version is None and 'useLatestVersion' in kwargs:
            use_latest_version = kwargs['useLatestVersion']

        _setter("secret_source", secret_source)
        _setter("type", 'CustomerCertificate')
        if secret_version is not None:
            _setter("secret_version", secret_version)
        if subject_alternative_names is not None:
            _setter("subject_alternative_names", subject_alternative_names)
        if use_latest_version is not None:
            _setter("use_latest_version", use_latest_version)

    @property
    @pulumi.getter(name="secretSource")
    def secret_source(self) -> pulumi.Input['ResourceReferenceArgs']:
        """
        Resource reference to the Azure Key Vault certificate. Expected to be in format of /subscriptions/{​​​​​​​​​subscriptionId}​​​​​​​​​/resourceGroups/{​​​​​​​​​resourceGroupName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/providers/Microsoft.KeyVault/vaults/{vaultName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/secrets/{certificateName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
        """
        return pulumi.get(self, "secret_source")

    @secret_source.setter
    def secret_source(self, value: pulumi.Input['ResourceReferenceArgs']):
        pulumi.set(self, "secret_source", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the secret resource.
        Expected value is 'CustomerCertificate'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the secret to be used
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_version", value)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of SANs.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subject_alternative_names", value)

    @property
    @pulumi.getter(name="useLatestVersion")
    def use_latest_version(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use the latest version for the certificate
        """
        return pulumi.get(self, "use_latest_version")

    @use_latest_version.setter
    def use_latest_version(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_latest_version", value)


@pulumi.input_type
class DeepCreatedOriginGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 origins: pulumi.Input[Sequence[pulumi.Input['ResourceReferenceArgs']]],
                 health_probe_settings: Optional[pulumi.Input['HealthProbeParametersArgs']] = None,
                 response_based_origin_error_detection_settings: Optional[pulumi.Input['ResponseBasedOriginErrorDetectionParametersArgs']] = None,
                 traffic_restoration_time_to_healed_or_new_endpoints_in_minutes: Optional[pulumi.Input[int]] = None):
        """
        The origin group for CDN content which is added when creating a CDN endpoint. Traffic is sent to the origins within the origin group based on origin health.
        :param pulumi.Input[str] name: Origin group name which must be unique within the endpoint.
        :param pulumi.Input[Sequence[pulumi.Input['ResourceReferenceArgs']]] origins: The source of the content being delivered via CDN within given origin group.
        :param pulumi.Input['HealthProbeParametersArgs'] health_probe_settings: Health probe settings to the origin that is used to determine the health of the origin.
        :param pulumi.Input['ResponseBasedOriginErrorDetectionParametersArgs'] response_based_origin_error_detection_settings: The JSON object that contains the properties to determine origin health using real requests/responses.This property is currently not supported.
        :param pulumi.Input[int] traffic_restoration_time_to_healed_or_new_endpoints_in_minutes: Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not supported.
        """
        DeepCreatedOriginGroupArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            origins=origins,
            health_probe_settings=health_probe_settings,
            response_based_origin_error_detection_settings=response_based_origin_error_detection_settings,
            traffic_restoration_time_to_healed_or_new_endpoints_in_minutes=traffic_restoration_time_to_healed_or_new_endpoints_in_minutes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             origins: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceReferenceArgs']]]] = None,
             health_probe_settings: Optional[pulumi.Input['HealthProbeParametersArgs']] = None,
             response_based_origin_error_detection_settings: Optional[pulumi.Input['ResponseBasedOriginErrorDetectionParametersArgs']] = None,
             traffic_restoration_time_to_healed_or_new_endpoints_in_minutes: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if origins is None:
            raise TypeError("Missing 'origins' argument")
        if health_probe_settings is None and 'healthProbeSettings' in kwargs:
            health_probe_settings = kwargs['healthProbeSettings']
        if response_based_origin_error_detection_settings is None and 'responseBasedOriginErrorDetectionSettings' in kwargs:
            response_based_origin_error_detection_settings = kwargs['responseBasedOriginErrorDetectionSettings']
        if traffic_restoration_time_to_healed_or_new_endpoints_in_minutes is None and 'trafficRestorationTimeToHealedOrNewEndpointsInMinutes' in kwargs:
            traffic_restoration_time_to_healed_or_new_endpoints_in_minutes = kwargs['trafficRestorationTimeToHealedOrNewEndpointsInMinutes']

        _setter("name", name)
        _setter("origins", origins)
        if health_probe_settings is not None:
            _setter("health_probe_settings", health_probe_settings)
        if response_based_origin_error_detection_settings is not None:
            _setter("response_based_origin_error_detection_settings", response_based_origin_error_detection_settings)
        if traffic_restoration_time_to_healed_or_new_endpoints_in_minutes is not None:
            _setter("traffic_restoration_time_to_healed_or_new_endpoints_in_minutes", traffic_restoration_time_to_healed_or_new_endpoints_in_minutes)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Origin group name which must be unique within the endpoint.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def origins(self) -> pulumi.Input[Sequence[pulumi.Input['ResourceReferenceArgs']]]:
        """
        The source of the content being delivered via CDN within given origin group.
        """
        return pulumi.get(self, "origins")

    @origins.setter
    def origins(self, value: pulumi.Input[Sequence[pulumi.Input['ResourceReferenceArgs']]]):
        pulumi.set(self, "origins", value)

    @property
    @pulumi.getter(name="healthProbeSettings")
    def health_probe_settings(self) -> Optional[pulumi.Input['HealthProbeParametersArgs']]:
        """
        Health probe settings to the origin that is used to determine the health of the origin.
        """
        return pulumi.get(self, "health_probe_settings")

    @health_probe_settings.setter
    def health_probe_settings(self, value: Optional[pulumi.Input['HealthProbeParametersArgs']]):
        pulumi.set(self, "health_probe_settings", value)

    @property
    @pulumi.getter(name="responseBasedOriginErrorDetectionSettings")
    def response_based_origin_error_detection_settings(self) -> Optional[pulumi.Input['ResponseBasedOriginErrorDetectionParametersArgs']]:
        """
        The JSON object that contains the properties to determine origin health using real requests/responses.This property is currently not supported.
        """
        return pulumi.get(self, "response_based_origin_error_detection_settings")

    @response_based_origin_error_detection_settings.setter
    def response_based_origin_error_detection_settings(self, value: Optional[pulumi.Input['ResponseBasedOriginErrorDetectionParametersArgs']]):
        pulumi.set(self, "response_based_origin_error_detection_settings", value)

    @property
    @pulumi.getter(name="trafficRestorationTimeToHealedOrNewEndpointsInMinutes")
    def traffic_restoration_time_to_healed_or_new_endpoints_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not supported.
        """
        return pulumi.get(self, "traffic_restoration_time_to_healed_or_new_endpoints_in_minutes")

    @traffic_restoration_time_to_healed_or_new_endpoints_in_minutes.setter
    def traffic_restoration_time_to_healed_or_new_endpoints_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "traffic_restoration_time_to_healed_or_new_endpoints_in_minutes", value)


@pulumi.input_type
class DeepCreatedOriginArgs:
    def __init__(__self__, *,
                 host_name: pulumi.Input[str],
                 name: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 http_port: Optional[pulumi.Input[int]] = None,
                 https_port: Optional[pulumi.Input[int]] = None,
                 origin_host_header: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 private_link_alias: Optional[pulumi.Input[str]] = None,
                 private_link_approval_message: Optional[pulumi.Input[str]] = None,
                 private_link_location: Optional[pulumi.Input[str]] = None,
                 private_link_resource_id: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        The main origin of CDN content which is added when creating a CDN endpoint.
        :param pulumi.Input[str] host_name: The address of the origin. It can be a domain name, IPv4 address, or IPv6 address. This should be unique across all origins in an endpoint.
        :param pulumi.Input[str] name: Origin name which must be unique within the endpoint. 
        :param pulumi.Input[bool] enabled: Origin is enabled for load balancing or not. By default, origin is always enabled.
        :param pulumi.Input[int] http_port: The value of the HTTP port. Must be between 1 and 65535.
        :param pulumi.Input[int] https_port: The value of the HTTPS port. Must be between 1 and 65535.
        :param pulumi.Input[str] origin_host_header: The host header value sent to the origin with each request. If you leave this blank, the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host header value to match the origin hostname by default.
        :param pulumi.Input[int] priority: Priority of origin in given origin group for load balancing. Higher priorities will not be used for load balancing if any lower priority origin is healthy.Must be between 1 and 5.
        :param pulumi.Input[str] private_link_alias: The Alias of the Private Link resource. Populating this optional field indicates that this origin is 'Private'
        :param pulumi.Input[str] private_link_approval_message: A custom message to be included in the approval request to connect to the Private Link.
        :param pulumi.Input[str] private_link_location: The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
        :param pulumi.Input[str] private_link_resource_id: The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
        :param pulumi.Input[int] weight: Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
        """
        DeepCreatedOriginArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host_name=host_name,
            name=name,
            enabled=enabled,
            http_port=http_port,
            https_port=https_port,
            origin_host_header=origin_host_header,
            priority=priority,
            private_link_alias=private_link_alias,
            private_link_approval_message=private_link_approval_message,
            private_link_location=private_link_location,
            private_link_resource_id=private_link_resource_id,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host_name: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             http_port: Optional[pulumi.Input[int]] = None,
             https_port: Optional[pulumi.Input[int]] = None,
             origin_host_header: Optional[pulumi.Input[str]] = None,
             priority: Optional[pulumi.Input[int]] = None,
             private_link_alias: Optional[pulumi.Input[str]] = None,
             private_link_approval_message: Optional[pulumi.Input[str]] = None,
             private_link_location: Optional[pulumi.Input[str]] = None,
             private_link_resource_id: Optional[pulumi.Input[str]] = None,
             weight: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if host_name is None and 'hostName' in kwargs:
            host_name = kwargs['hostName']
        if host_name is None:
            raise TypeError("Missing 'host_name' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if http_port is None and 'httpPort' in kwargs:
            http_port = kwargs['httpPort']
        if https_port is None and 'httpsPort' in kwargs:
            https_port = kwargs['httpsPort']
        if origin_host_header is None and 'originHostHeader' in kwargs:
            origin_host_header = kwargs['originHostHeader']
        if private_link_alias is None and 'privateLinkAlias' in kwargs:
            private_link_alias = kwargs['privateLinkAlias']
        if private_link_approval_message is None and 'privateLinkApprovalMessage' in kwargs:
            private_link_approval_message = kwargs['privateLinkApprovalMessage']
        if private_link_location is None and 'privateLinkLocation' in kwargs:
            private_link_location = kwargs['privateLinkLocation']
        if private_link_resource_id is None and 'privateLinkResourceId' in kwargs:
            private_link_resource_id = kwargs['privateLinkResourceId']

        _setter("host_name", host_name)
        _setter("name", name)
        if enabled is not None:
            _setter("enabled", enabled)
        if http_port is not None:
            _setter("http_port", http_port)
        if https_port is not None:
            _setter("https_port", https_port)
        if origin_host_header is not None:
            _setter("origin_host_header", origin_host_header)
        if priority is not None:
            _setter("priority", priority)
        if private_link_alias is not None:
            _setter("private_link_alias", private_link_alias)
        if private_link_approval_message is not None:
            _setter("private_link_approval_message", private_link_approval_message)
        if private_link_location is not None:
            _setter("private_link_location", private_link_location)
        if private_link_resource_id is not None:
            _setter("private_link_resource_id", private_link_resource_id)
        if weight is not None:
            _setter("weight", weight)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> pulumi.Input[str]:
        """
        The address of the origin. It can be a domain name, IPv4 address, or IPv6 address. This should be unique across all origins in an endpoint.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Origin name which must be unique within the endpoint. 
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Origin is enabled for load balancing or not. By default, origin is always enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[int]]:
        """
        The value of the HTTP port. Must be between 1 and 65535.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_port", value)

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[pulumi.Input[int]]:
        """
        The value of the HTTPS port. Must be between 1 and 65535.
        """
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "https_port", value)

    @property
    @pulumi.getter(name="originHostHeader")
    def origin_host_header(self) -> Optional[pulumi.Input[str]]:
        """
        The host header value sent to the origin with each request. If you leave this blank, the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host header value to match the origin hostname by default.
        """
        return pulumi.get(self, "origin_host_header")

    @origin_host_header.setter
    def origin_host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin_host_header", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Priority of origin in given origin group for load balancing. Higher priorities will not be used for load balancing if any lower priority origin is healthy.Must be between 1 and 5.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="privateLinkAlias")
    def private_link_alias(self) -> Optional[pulumi.Input[str]]:
        """
        The Alias of the Private Link resource. Populating this optional field indicates that this origin is 'Private'
        """
        return pulumi.get(self, "private_link_alias")

    @private_link_alias.setter
    def private_link_alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_alias", value)

    @property
    @pulumi.getter(name="privateLinkApprovalMessage")
    def private_link_approval_message(self) -> Optional[pulumi.Input[str]]:
        """
        A custom message to be included in the approval request to connect to the Private Link.
        """
        return pulumi.get(self, "private_link_approval_message")

    @private_link_approval_message.setter
    def private_link_approval_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_approval_message", value)

    @property
    @pulumi.getter(name="privateLinkLocation")
    def private_link_location(self) -> Optional[pulumi.Input[str]]:
        """
        The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
        """
        return pulumi.get(self, "private_link_location")

    @private_link_location.setter
    def private_link_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_location", value)

    @property
    @pulumi.getter(name="privateLinkResourceId")
    def private_link_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
        """
        return pulumi.get(self, "private_link_resource_id")

    @private_link_resource_id.setter
    def private_link_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_resource_id", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class DeliveryRuleCacheExpirationActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['CacheExpirationActionParametersArgs']):
        """
        Defines the cache expiration action for the delivery rule.
        :param pulumi.Input[str] name: The name of the action for the delivery rule.
               Expected value is 'CacheExpiration'.
        :param pulumi.Input['CacheExpirationActionParametersArgs'] parameters: Defines the parameters for the action.
        """
        DeliveryRuleCacheExpirationActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['CacheExpirationActionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'CacheExpiration')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the action for the delivery rule.
        Expected value is 'CacheExpiration'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['CacheExpirationActionParametersArgs']:
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['CacheExpirationActionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleCacheKeyQueryStringActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['CacheKeyQueryStringActionParametersArgs']):
        """
        Defines the cache-key query string action for the delivery rule.
        :param pulumi.Input[str] name: The name of the action for the delivery rule.
               Expected value is 'CacheKeyQueryString'.
        :param pulumi.Input['CacheKeyQueryStringActionParametersArgs'] parameters: Defines the parameters for the action.
        """
        DeliveryRuleCacheKeyQueryStringActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['CacheKeyQueryStringActionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'CacheKeyQueryString')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the action for the delivery rule.
        Expected value is 'CacheKeyQueryString'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['CacheKeyQueryStringActionParametersArgs']:
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['CacheKeyQueryStringActionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleClientPortConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['ClientPortMatchConditionParametersArgs']):
        """
        Defines the ClientPort condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'ClientPort'.
        :param pulumi.Input['ClientPortMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleClientPortConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['ClientPortMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'ClientPort')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'ClientPort'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['ClientPortMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['ClientPortMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleCookiesConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['CookiesMatchConditionParametersArgs']):
        """
        Defines the Cookies condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'Cookies'.
        :param pulumi.Input['CookiesMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleCookiesConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['CookiesMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'Cookies')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'Cookies'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['CookiesMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['CookiesMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleHostNameConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['HostNameMatchConditionParametersArgs']):
        """
        Defines the HostName condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'HostName'.
        :param pulumi.Input['HostNameMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleHostNameConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['HostNameMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'HostName')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'HostName'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['HostNameMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['HostNameMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleHttpVersionConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['HttpVersionMatchConditionParametersArgs']):
        """
        Defines the HttpVersion condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'HttpVersion'.
        :param pulumi.Input['HttpVersionMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleHttpVersionConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['HttpVersionMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'HttpVersion')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'HttpVersion'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['HttpVersionMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['HttpVersionMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleIsDeviceConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['IsDeviceMatchConditionParametersArgs']):
        """
        Defines the IsDevice condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'IsDevice'.
        :param pulumi.Input['IsDeviceMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleIsDeviceConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['IsDeviceMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'IsDevice')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'IsDevice'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['IsDeviceMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['IsDeviceMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRulePostArgsConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['PostArgsMatchConditionParametersArgs']):
        """
        Defines the PostArgs condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'PostArgs'.
        :param pulumi.Input['PostArgsMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRulePostArgsConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['PostArgsMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'PostArgs')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'PostArgs'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['PostArgsMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['PostArgsMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleQueryStringConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['QueryStringMatchConditionParametersArgs']):
        """
        Defines the QueryString condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'QueryString'.
        :param pulumi.Input['QueryStringMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleQueryStringConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['QueryStringMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'QueryString')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'QueryString'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['QueryStringMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['QueryStringMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleRemoteAddressConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['RemoteAddressMatchConditionParametersArgs']):
        """
        Defines the RemoteAddress condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'RemoteAddress'.
        :param pulumi.Input['RemoteAddressMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleRemoteAddressConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['RemoteAddressMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'RemoteAddress')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'RemoteAddress'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['RemoteAddressMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['RemoteAddressMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleRequestBodyConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['RequestBodyMatchConditionParametersArgs']):
        """
        Defines the RequestBody condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'RequestBody'.
        :param pulumi.Input['RequestBodyMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleRequestBodyConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['RequestBodyMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'RequestBody')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'RequestBody'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['RequestBodyMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['RequestBodyMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleRequestHeaderActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['HeaderActionParametersArgs']):
        """
        Defines the request header action for the delivery rule.
        :param pulumi.Input[str] name: The name of the action for the delivery rule.
               Expected value is 'ModifyRequestHeader'.
        :param pulumi.Input['HeaderActionParametersArgs'] parameters: Defines the parameters for the action.
        """
        DeliveryRuleRequestHeaderActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['HeaderActionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'ModifyRequestHeader')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the action for the delivery rule.
        Expected value is 'ModifyRequestHeader'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['HeaderActionParametersArgs']:
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['HeaderActionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleRequestHeaderConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['RequestHeaderMatchConditionParametersArgs']):
        """
        Defines the RequestHeader condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'RequestHeader'.
        :param pulumi.Input['RequestHeaderMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleRequestHeaderConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['RequestHeaderMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'RequestHeader')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'RequestHeader'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['RequestHeaderMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['RequestHeaderMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleRequestMethodConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['RequestMethodMatchConditionParametersArgs']):
        """
        Defines the RequestMethod condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'RequestMethod'.
        :param pulumi.Input['RequestMethodMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleRequestMethodConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['RequestMethodMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'RequestMethod')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'RequestMethod'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['RequestMethodMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['RequestMethodMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleRequestSchemeConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['RequestSchemeMatchConditionParametersArgs']):
        """
        Defines the RequestScheme condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'RequestScheme'.
        :param pulumi.Input['RequestSchemeMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleRequestSchemeConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['RequestSchemeMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'RequestScheme')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'RequestScheme'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['RequestSchemeMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['RequestSchemeMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleRequestUriConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['RequestUriMatchConditionParametersArgs']):
        """
        Defines the RequestUri condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'RequestUri'.
        :param pulumi.Input['RequestUriMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleRequestUriConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['RequestUriMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'RequestUri')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'RequestUri'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['RequestUriMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['RequestUriMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleResponseHeaderActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['HeaderActionParametersArgs']):
        """
        Defines the response header action for the delivery rule.
        :param pulumi.Input[str] name: The name of the action for the delivery rule.
               Expected value is 'ModifyResponseHeader'.
        :param pulumi.Input['HeaderActionParametersArgs'] parameters: Defines the parameters for the action.
        """
        DeliveryRuleResponseHeaderActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['HeaderActionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'ModifyResponseHeader')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the action for the delivery rule.
        Expected value is 'ModifyResponseHeader'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['HeaderActionParametersArgs']:
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['HeaderActionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleRouteConfigurationOverrideActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['RouteConfigurationOverrideActionParametersArgs']):
        """
        Defines the route configuration override action for the delivery rule. Only applicable to Frontdoor Standard/Premium Profiles.
        :param pulumi.Input[str] name: The name of the action for the delivery rule.
               Expected value is 'RouteConfigurationOverride'.
        :param pulumi.Input['RouteConfigurationOverrideActionParametersArgs'] parameters: Defines the parameters for the action.
        """
        DeliveryRuleRouteConfigurationOverrideActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['RouteConfigurationOverrideActionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'RouteConfigurationOverride')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the action for the delivery rule.
        Expected value is 'RouteConfigurationOverride'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['RouteConfigurationOverrideActionParametersArgs']:
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['RouteConfigurationOverrideActionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleServerPortConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['ServerPortMatchConditionParametersArgs']):
        """
        Defines the ServerPort condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'ServerPort'.
        :param pulumi.Input['ServerPortMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleServerPortConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['ServerPortMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'ServerPort')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'ServerPort'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['ServerPortMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['ServerPortMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleSocketAddrConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['SocketAddrMatchConditionParametersArgs']):
        """
        Defines the SocketAddress condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'SocketAddr'.
        :param pulumi.Input['SocketAddrMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleSocketAddrConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['SocketAddrMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'SocketAddr')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'SocketAddr'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['SocketAddrMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['SocketAddrMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleSslProtocolConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['SslProtocolMatchConditionParametersArgs']):
        """
        Defines the SslProtocol condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'SslProtocol'.
        :param pulumi.Input['SslProtocolMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleSslProtocolConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['SslProtocolMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'SslProtocol')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'SslProtocol'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['SslProtocolMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['SslProtocolMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleUrlFileExtensionConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['UrlFileExtensionMatchConditionParametersArgs']):
        """
        Defines the UrlFileExtension condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'UrlFileExtension'.
        :param pulumi.Input['UrlFileExtensionMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleUrlFileExtensionConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['UrlFileExtensionMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'UrlFileExtension')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'UrlFileExtension'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['UrlFileExtensionMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['UrlFileExtensionMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleUrlFileNameConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['UrlFileNameMatchConditionParametersArgs']):
        """
        Defines the UrlFileName condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'UrlFileName'.
        :param pulumi.Input['UrlFileNameMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleUrlFileNameConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['UrlFileNameMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'UrlFileName')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'UrlFileName'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['UrlFileNameMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['UrlFileNameMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleUrlPathConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['UrlPathMatchConditionParametersArgs']):
        """
        Defines the UrlPath condition for the delivery rule.
        :param pulumi.Input[str] name: The name of the condition for the delivery rule.
               Expected value is 'UrlPath'.
        :param pulumi.Input['UrlPathMatchConditionParametersArgs'] parameters: Defines the parameters for the condition.
        """
        DeliveryRuleUrlPathConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['UrlPathMatchConditionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'UrlPath')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the condition for the delivery rule.
        Expected value is 'UrlPath'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['UrlPathMatchConditionParametersArgs']:
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['UrlPathMatchConditionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class DeliveryRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[Union['DeliveryRuleCacheExpirationActionArgs', 'DeliveryRuleCacheKeyQueryStringActionArgs', 'DeliveryRuleRequestHeaderActionArgs', 'DeliveryRuleResponseHeaderActionArgs', 'DeliveryRuleRouteConfigurationOverrideActionArgs', 'OriginGroupOverrideActionArgs', 'UrlRedirectActionArgs', 'UrlRewriteActionArgs', 'UrlSigningActionArgs']]]],
                 order: pulumi.Input[int],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DeliveryRuleClientPortConditionArgs', 'DeliveryRuleCookiesConditionArgs', 'DeliveryRuleHostNameConditionArgs', 'DeliveryRuleHttpVersionConditionArgs', 'DeliveryRuleIsDeviceConditionArgs', 'DeliveryRulePostArgsConditionArgs', 'DeliveryRuleQueryStringConditionArgs', 'DeliveryRuleRemoteAddressConditionArgs', 'DeliveryRuleRequestBodyConditionArgs', 'DeliveryRuleRequestHeaderConditionArgs', 'DeliveryRuleRequestMethodConditionArgs', 'DeliveryRuleRequestSchemeConditionArgs', 'DeliveryRuleRequestUriConditionArgs', 'DeliveryRuleServerPortConditionArgs', 'DeliveryRuleSocketAddrConditionArgs', 'DeliveryRuleSslProtocolConditionArgs', 'DeliveryRuleUrlFileExtensionConditionArgs', 'DeliveryRuleUrlFileNameConditionArgs', 'DeliveryRuleUrlPathConditionArgs']]]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        A rule that specifies a set of actions and conditions
        :param pulumi.Input[Sequence[pulumi.Input[Union['DeliveryRuleCacheExpirationActionArgs', 'DeliveryRuleCacheKeyQueryStringActionArgs', 'DeliveryRuleRequestHeaderActionArgs', 'DeliveryRuleResponseHeaderActionArgs', 'DeliveryRuleRouteConfigurationOverrideActionArgs', 'OriginGroupOverrideActionArgs', 'UrlRedirectActionArgs', 'UrlRewriteActionArgs', 'UrlSigningActionArgs']]]] actions: A list of actions that are executed when all the conditions of a rule are satisfied.
        :param pulumi.Input[int] order: The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A rule with a lesser order will be applied before a rule with a greater order. Rule with order 0 is a special rule. It does not require any condition and actions listed in it will always be applied.
        :param pulumi.Input[Sequence[pulumi.Input[Union['DeliveryRuleClientPortConditionArgs', 'DeliveryRuleCookiesConditionArgs', 'DeliveryRuleHostNameConditionArgs', 'DeliveryRuleHttpVersionConditionArgs', 'DeliveryRuleIsDeviceConditionArgs', 'DeliveryRulePostArgsConditionArgs', 'DeliveryRuleQueryStringConditionArgs', 'DeliveryRuleRemoteAddressConditionArgs', 'DeliveryRuleRequestBodyConditionArgs', 'DeliveryRuleRequestHeaderConditionArgs', 'DeliveryRuleRequestMethodConditionArgs', 'DeliveryRuleRequestSchemeConditionArgs', 'DeliveryRuleRequestUriConditionArgs', 'DeliveryRuleServerPortConditionArgs', 'DeliveryRuleSocketAddrConditionArgs', 'DeliveryRuleSslProtocolConditionArgs', 'DeliveryRuleUrlFileExtensionConditionArgs', 'DeliveryRuleUrlFileNameConditionArgs', 'DeliveryRuleUrlPathConditionArgs']]]] conditions: A list of conditions that must be matched for the actions to be executed
        :param pulumi.Input[str] name: Name of the rule
        """
        DeliveryRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            order=order,
            conditions=conditions,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DeliveryRuleCacheExpirationActionArgs', 'DeliveryRuleCacheKeyQueryStringActionArgs', 'DeliveryRuleRequestHeaderActionArgs', 'DeliveryRuleResponseHeaderActionArgs', 'DeliveryRuleRouteConfigurationOverrideActionArgs', 'OriginGroupOverrideActionArgs', 'UrlRedirectActionArgs', 'UrlRewriteActionArgs', 'UrlSigningActionArgs']]]]] = None,
             order: Optional[pulumi.Input[int]] = None,
             conditions: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DeliveryRuleClientPortConditionArgs', 'DeliveryRuleCookiesConditionArgs', 'DeliveryRuleHostNameConditionArgs', 'DeliveryRuleHttpVersionConditionArgs', 'DeliveryRuleIsDeviceConditionArgs', 'DeliveryRulePostArgsConditionArgs', 'DeliveryRuleQueryStringConditionArgs', 'DeliveryRuleRemoteAddressConditionArgs', 'DeliveryRuleRequestBodyConditionArgs', 'DeliveryRuleRequestHeaderConditionArgs', 'DeliveryRuleRequestMethodConditionArgs', 'DeliveryRuleRequestSchemeConditionArgs', 'DeliveryRuleRequestUriConditionArgs', 'DeliveryRuleServerPortConditionArgs', 'DeliveryRuleSocketAddrConditionArgs', 'DeliveryRuleSslProtocolConditionArgs', 'DeliveryRuleUrlFileExtensionConditionArgs', 'DeliveryRuleUrlFileNameConditionArgs', 'DeliveryRuleUrlPathConditionArgs']]]]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions is None:
            raise TypeError("Missing 'actions' argument")
        if order is None:
            raise TypeError("Missing 'order' argument")

        _setter("actions", actions)
        _setter("order", order)
        if conditions is not None:
            _setter("conditions", conditions)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[Union['DeliveryRuleCacheExpirationActionArgs', 'DeliveryRuleCacheKeyQueryStringActionArgs', 'DeliveryRuleRequestHeaderActionArgs', 'DeliveryRuleResponseHeaderActionArgs', 'DeliveryRuleRouteConfigurationOverrideActionArgs', 'OriginGroupOverrideActionArgs', 'UrlRedirectActionArgs', 'UrlRewriteActionArgs', 'UrlSigningActionArgs']]]]:
        """
        A list of actions that are executed when all the conditions of a rule are satisfied.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[Union['DeliveryRuleCacheExpirationActionArgs', 'DeliveryRuleCacheKeyQueryStringActionArgs', 'DeliveryRuleRequestHeaderActionArgs', 'DeliveryRuleResponseHeaderActionArgs', 'DeliveryRuleRouteConfigurationOverrideActionArgs', 'OriginGroupOverrideActionArgs', 'UrlRedirectActionArgs', 'UrlRewriteActionArgs', 'UrlSigningActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        """
        The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A rule with a lesser order will be applied before a rule with a greater order. Rule with order 0 is a special rule. It does not require any condition and actions listed in it will always be applied.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['DeliveryRuleClientPortConditionArgs', 'DeliveryRuleCookiesConditionArgs', 'DeliveryRuleHostNameConditionArgs', 'DeliveryRuleHttpVersionConditionArgs', 'DeliveryRuleIsDeviceConditionArgs', 'DeliveryRulePostArgsConditionArgs', 'DeliveryRuleQueryStringConditionArgs', 'DeliveryRuleRemoteAddressConditionArgs', 'DeliveryRuleRequestBodyConditionArgs', 'DeliveryRuleRequestHeaderConditionArgs', 'DeliveryRuleRequestMethodConditionArgs', 'DeliveryRuleRequestSchemeConditionArgs', 'DeliveryRuleRequestUriConditionArgs', 'DeliveryRuleServerPortConditionArgs', 'DeliveryRuleSocketAddrConditionArgs', 'DeliveryRuleSslProtocolConditionArgs', 'DeliveryRuleUrlFileExtensionConditionArgs', 'DeliveryRuleUrlFileNameConditionArgs', 'DeliveryRuleUrlPathConditionArgs']]]]]:
        """
        A list of conditions that must be matched for the actions to be executed
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['DeliveryRuleClientPortConditionArgs', 'DeliveryRuleCookiesConditionArgs', 'DeliveryRuleHostNameConditionArgs', 'DeliveryRuleHttpVersionConditionArgs', 'DeliveryRuleIsDeviceConditionArgs', 'DeliveryRulePostArgsConditionArgs', 'DeliveryRuleQueryStringConditionArgs', 'DeliveryRuleRemoteAddressConditionArgs', 'DeliveryRuleRequestBodyConditionArgs', 'DeliveryRuleRequestHeaderConditionArgs', 'DeliveryRuleRequestMethodConditionArgs', 'DeliveryRuleRequestSchemeConditionArgs', 'DeliveryRuleRequestUriConditionArgs', 'DeliveryRuleServerPortConditionArgs', 'DeliveryRuleSocketAddrConditionArgs', 'DeliveryRuleSslProtocolConditionArgs', 'DeliveryRuleUrlFileExtensionConditionArgs', 'DeliveryRuleUrlFileNameConditionArgs', 'DeliveryRuleUrlPathConditionArgs']]]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class EndpointPropertiesUpdateParametersDeliveryPolicyArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['DeliveryRuleArgs']]],
                 description: Optional[pulumi.Input[str]] = None):
        """
        A policy that specifies the delivery rules to be used for an endpoint.
        :param pulumi.Input[Sequence[pulumi.Input['DeliveryRuleArgs']]] rules: A list of the delivery rules.
        :param pulumi.Input[str] description: User-friendly description of the policy.
        """
        EndpointPropertiesUpdateParametersDeliveryPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['DeliveryRuleArgs']]]] = None,
             description: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rules is None:
            raise TypeError("Missing 'rules' argument")

        _setter("rules", rules)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['DeliveryRuleArgs']]]:
        """
        A list of the delivery rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['DeliveryRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        User-friendly description of the policy.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Defines the Web Application Firewall policy for the endpoint (if applicable)
        :param pulumi.Input[str] id: Resource ID.
        """
        EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class GeoFilterArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['GeoFilterActions'],
                 country_codes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 relative_path: pulumi.Input[str]):
        """
        Rules defining user's geo access within a CDN endpoint.
        :param pulumi.Input['GeoFilterActions'] action: Action of the geo filter, i.e. allow or block access.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] country_codes: Two letter country or region codes defining user country or region access in a geo filter, e.g. AU, MX, US.
        :param pulumi.Input[str] relative_path: Relative path applicable to geo filter. (e.g. '/mypictures', '/mypicture/kitty.jpg', and etc.)
        """
        GeoFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            country_codes=country_codes,
            relative_path=relative_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[pulumi.Input['GeoFilterActions']] = None,
             country_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             relative_path: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if country_codes is None and 'countryCodes' in kwargs:
            country_codes = kwargs['countryCodes']
        if country_codes is None:
            raise TypeError("Missing 'country_codes' argument")
        if relative_path is None and 'relativePath' in kwargs:
            relative_path = kwargs['relativePath']
        if relative_path is None:
            raise TypeError("Missing 'relative_path' argument")

        _setter("action", action)
        _setter("country_codes", country_codes)
        _setter("relative_path", relative_path)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['GeoFilterActions']:
        """
        Action of the geo filter, i.e. allow or block access.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['GeoFilterActions']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Two letter country or region codes defining user country or region access in a geo filter, e.g. AU, MX, US.
        """
        return pulumi.get(self, "country_codes")

    @country_codes.setter
    def country_codes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "country_codes", value)

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> pulumi.Input[str]:
        """
        Relative path applicable to geo filter. (e.g. '/mypictures', '/mypicture/kitty.jpg', and etc.)
        """
        return pulumi.get(self, "relative_path")

    @relative_path.setter
    def relative_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_path", value)


@pulumi.input_type
class HeaderActionParametersArgs:
    def __init__(__self__, *,
                 header_action: pulumi.Input[Union[str, 'HeaderAction']],
                 header_name: pulumi.Input[str],
                 type_name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        Defines the parameters for the request header action.
        :param pulumi.Input[Union[str, 'HeaderAction']] header_action: Action to perform
        :param pulumi.Input[str] header_name: Name of the header to modify
        :param pulumi.Input[str] value: Value for the specified action
        """
        HeaderActionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            header_action=header_action,
            header_name=header_name,
            type_name=type_name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             header_action: Optional[pulumi.Input[Union[str, 'HeaderAction']]] = None,
             header_name: Optional[pulumi.Input[str]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if header_action is None and 'headerAction' in kwargs:
            header_action = kwargs['headerAction']
        if header_action is None:
            raise TypeError("Missing 'header_action' argument")
        if header_name is None and 'headerName' in kwargs:
            header_name = kwargs['headerName']
        if header_name is None:
            raise TypeError("Missing 'header_name' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")

        _setter("header_action", header_action)
        _setter("header_name", header_name)
        _setter("type_name", type_name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> pulumi.Input[Union[str, 'HeaderAction']]:
        """
        Action to perform
        """
        return pulumi.get(self, "header_action")

    @header_action.setter
    def header_action(self, value: pulumi.Input[Union[str, 'HeaderAction']]):
        pulumi.set(self, "header_action", value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[str]:
        """
        Name of the header to modify
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value for the specified action
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class HealthProbeParametersArgs:
    def __init__(__self__, *,
                 probe_interval_in_seconds: Optional[pulumi.Input[int]] = None,
                 probe_path: Optional[pulumi.Input[str]] = None,
                 probe_protocol: Optional[pulumi.Input['ProbeProtocol']] = None,
                 probe_request_type: Optional[pulumi.Input['HealthProbeRequestType']] = None):
        """
        The JSON object that contains the properties to send health probes to origin.
        :param pulumi.Input[int] probe_interval_in_seconds: The number of seconds between health probes.Default is 240sec.
        :param pulumi.Input[str] probe_path: The path relative to the origin that is used to determine the health of the origin.
        :param pulumi.Input['ProbeProtocol'] probe_protocol: Protocol to use for health probe.
        :param pulumi.Input['HealthProbeRequestType'] probe_request_type: The type of health probe request that is made.
        """
        HealthProbeParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            probe_interval_in_seconds=probe_interval_in_seconds,
            probe_path=probe_path,
            probe_protocol=probe_protocol,
            probe_request_type=probe_request_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             probe_interval_in_seconds: Optional[pulumi.Input[int]] = None,
             probe_path: Optional[pulumi.Input[str]] = None,
             probe_protocol: Optional[pulumi.Input['ProbeProtocol']] = None,
             probe_request_type: Optional[pulumi.Input['HealthProbeRequestType']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if probe_interval_in_seconds is None and 'probeIntervalInSeconds' in kwargs:
            probe_interval_in_seconds = kwargs['probeIntervalInSeconds']
        if probe_path is None and 'probePath' in kwargs:
            probe_path = kwargs['probePath']
        if probe_protocol is None and 'probeProtocol' in kwargs:
            probe_protocol = kwargs['probeProtocol']
        if probe_request_type is None and 'probeRequestType' in kwargs:
            probe_request_type = kwargs['probeRequestType']

        if probe_interval_in_seconds is not None:
            _setter("probe_interval_in_seconds", probe_interval_in_seconds)
        if probe_path is not None:
            _setter("probe_path", probe_path)
        if probe_protocol is not None:
            _setter("probe_protocol", probe_protocol)
        if probe_request_type is not None:
            _setter("probe_request_type", probe_request_type)

    @property
    @pulumi.getter(name="probeIntervalInSeconds")
    def probe_interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds between health probes.Default is 240sec.
        """
        return pulumi.get(self, "probe_interval_in_seconds")

    @probe_interval_in_seconds.setter
    def probe_interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "probe_interval_in_seconds", value)

    @property
    @pulumi.getter(name="probePath")
    def probe_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path relative to the origin that is used to determine the health of the origin.
        """
        return pulumi.get(self, "probe_path")

    @probe_path.setter
    def probe_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "probe_path", value)

    @property
    @pulumi.getter(name="probeProtocol")
    def probe_protocol(self) -> Optional[pulumi.Input['ProbeProtocol']]:
        """
        Protocol to use for health probe.
        """
        return pulumi.get(self, "probe_protocol")

    @probe_protocol.setter
    def probe_protocol(self, value: Optional[pulumi.Input['ProbeProtocol']]):
        pulumi.set(self, "probe_protocol", value)

    @property
    @pulumi.getter(name="probeRequestType")
    def probe_request_type(self) -> Optional[pulumi.Input['HealthProbeRequestType']]:
        """
        The type of health probe request that is made.
        """
        return pulumi.get(self, "probe_request_type")

    @probe_request_type.setter
    def probe_request_type(self, value: Optional[pulumi.Input['HealthProbeRequestType']]):
        pulumi.set(self, "probe_request_type", value)


@pulumi.input_type
class HostNameMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'HostNameOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for HostName match conditions
        :param pulumi.Input[Union[str, 'HostNameOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        HostNameMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'HostNameOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'HostNameOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'HostNameOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class HttpErrorRangeParametersArgs:
    def __init__(__self__, *,
                 begin: Optional[pulumi.Input[int]] = None,
                 end: Optional[pulumi.Input[int]] = None):
        """
        The JSON object that represents the range for http status codes
        :param pulumi.Input[int] begin: The inclusive start of the http status code range.
        :param pulumi.Input[int] end: The inclusive end of the http status code range.
        """
        HttpErrorRangeParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            begin=begin,
            end=end,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             begin: Optional[pulumi.Input[int]] = None,
             end: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if begin is not None:
            _setter("begin", begin)
        if end is not None:
            _setter("end", end)

    @property
    @pulumi.getter
    def begin(self) -> Optional[pulumi.Input[int]]:
        """
        The inclusive start of the http status code range.
        """
        return pulumi.get(self, "begin")

    @begin.setter
    def begin(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "begin", value)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[int]]:
        """
        The inclusive end of the http status code range.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end", value)


@pulumi.input_type
class HttpVersionMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'HttpVersionOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for HttpVersion match conditions
        :param pulumi.Input[Union[str, 'HttpVersionOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        HttpVersionMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'HttpVersionOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'HttpVersionOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'HttpVersionOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class IsDeviceMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'IsDeviceOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for IsDevice match conditions
        :param pulumi.Input[Union[str, 'IsDeviceOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        IsDeviceMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'IsDeviceOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'IsDeviceOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'IsDeviceOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class KeyVaultSigningKeyParametersArgs:
    def __init__(__self__, *,
                 resource_group_name: pulumi.Input[str],
                 secret_name: pulumi.Input[str],
                 secret_version: pulumi.Input[str],
                 subscription_id: pulumi.Input[str],
                 type_name: pulumi.Input[str],
                 vault_name: pulumi.Input[str]):
        """
        Describes the parameters for using a user's KeyVault for URL Signing Key.
        :param pulumi.Input[str] resource_group_name: Resource group of the user's Key Vault containing the secret
        :param pulumi.Input[str] secret_name: The name of secret in Key Vault.
        :param pulumi.Input[str] secret_version: The version(GUID) of secret in Key Vault.
        :param pulumi.Input[str] subscription_id: Subscription Id of the user's Key Vault containing the secret
        :param pulumi.Input[str] vault_name: The name of the user's Key Vault containing the secret
        """
        KeyVaultSigningKeyParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_group_name=resource_group_name,
            secret_name=secret_name,
            secret_version=secret_version,
            subscription_id=subscription_id,
            type_name=type_name,
            vault_name=vault_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_group_name: Optional[pulumi.Input[str]] = None,
             secret_name: Optional[pulumi.Input[str]] = None,
             secret_version: Optional[pulumi.Input[str]] = None,
             subscription_id: Optional[pulumi.Input[str]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             vault_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if resource_group_name is None and 'resourceGroupName' in kwargs:
            resource_group_name = kwargs['resourceGroupName']
        if resource_group_name is None:
            raise TypeError("Missing 'resource_group_name' argument")
        if secret_name is None and 'secretName' in kwargs:
            secret_name = kwargs['secretName']
        if secret_name is None:
            raise TypeError("Missing 'secret_name' argument")
        if secret_version is None and 'secretVersion' in kwargs:
            secret_version = kwargs['secretVersion']
        if secret_version is None:
            raise TypeError("Missing 'secret_version' argument")
        if subscription_id is None and 'subscriptionId' in kwargs:
            subscription_id = kwargs['subscriptionId']
        if subscription_id is None:
            raise TypeError("Missing 'subscription_id' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if vault_name is None and 'vaultName' in kwargs:
            vault_name = kwargs['vaultName']
        if vault_name is None:
            raise TypeError("Missing 'vault_name' argument")

        _setter("resource_group_name", resource_group_name)
        _setter("secret_name", secret_name)
        _setter("secret_version", secret_version)
        _setter("subscription_id", subscription_id)
        _setter("type_name", type_name)
        _setter("vault_name", vault_name)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[str]:
        """
        Resource group of the user's Key Vault containing the secret
        """
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        The name of secret in Key Vault.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> pulumi.Input[str]:
        """
        The version(GUID) of secret in Key Vault.
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_version", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[str]:
        """
        Subscription Id of the user's Key Vault containing the secret
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="vaultName")
    def vault_name(self) -> pulumi.Input[str]:
        """
        The name of the user's Key Vault containing the secret
        """
        return pulumi.get(self, "vault_name")

    @vault_name.setter
    def vault_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "vault_name", value)


@pulumi.input_type
class LoadBalancingSettingsParametersArgs:
    def __init__(__self__, *,
                 additional_latency_in_milliseconds: Optional[pulumi.Input[int]] = None,
                 sample_size: Optional[pulumi.Input[int]] = None,
                 successful_samples_required: Optional[pulumi.Input[int]] = None):
        """
        Round-Robin load balancing settings for a backend pool
        :param pulumi.Input[int] additional_latency_in_milliseconds: The additional latency in milliseconds for probes to fall into the lowest latency bucket
        :param pulumi.Input[int] sample_size: The number of samples to consider for load balancing decisions
        :param pulumi.Input[int] successful_samples_required: The number of samples within the sample period that must succeed
        """
        LoadBalancingSettingsParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_latency_in_milliseconds=additional_latency_in_milliseconds,
            sample_size=sample_size,
            successful_samples_required=successful_samples_required,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_latency_in_milliseconds: Optional[pulumi.Input[int]] = None,
             sample_size: Optional[pulumi.Input[int]] = None,
             successful_samples_required: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if additional_latency_in_milliseconds is None and 'additionalLatencyInMilliseconds' in kwargs:
            additional_latency_in_milliseconds = kwargs['additionalLatencyInMilliseconds']
        if sample_size is None and 'sampleSize' in kwargs:
            sample_size = kwargs['sampleSize']
        if successful_samples_required is None and 'successfulSamplesRequired' in kwargs:
            successful_samples_required = kwargs['successfulSamplesRequired']

        if additional_latency_in_milliseconds is not None:
            _setter("additional_latency_in_milliseconds", additional_latency_in_milliseconds)
        if sample_size is not None:
            _setter("sample_size", sample_size)
        if successful_samples_required is not None:
            _setter("successful_samples_required", successful_samples_required)

    @property
    @pulumi.getter(name="additionalLatencyInMilliseconds")
    def additional_latency_in_milliseconds(self) -> Optional[pulumi.Input[int]]:
        """
        The additional latency in milliseconds for probes to fall into the lowest latency bucket
        """
        return pulumi.get(self, "additional_latency_in_milliseconds")

    @additional_latency_in_milliseconds.setter
    def additional_latency_in_milliseconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "additional_latency_in_milliseconds", value)

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[pulumi.Input[int]]:
        """
        The number of samples to consider for load balancing decisions
        """
        return pulumi.get(self, "sample_size")

    @sample_size.setter
    def sample_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sample_size", value)

    @property
    @pulumi.getter(name="successfulSamplesRequired")
    def successful_samples_required(self) -> Optional[pulumi.Input[int]]:
        """
        The number of samples within the sample period that must succeed
        """
        return pulumi.get(self, "successful_samples_required")

    @successful_samples_required.setter
    def successful_samples_required(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "successful_samples_required", value)


@pulumi.input_type
class ManagedCertificateParametersArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str]):
        """
        Managed Certificate used for https
        :param pulumi.Input[str] type: The type of the secret resource.
               Expected value is 'ManagedCertificate'.
        """
        ManagedCertificateParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("type", 'ManagedCertificate')

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the secret resource.
        Expected value is 'ManagedCertificate'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ManagedRuleGroupOverrideArgs:
    def __init__(__self__, *,
                 rule_group_name: pulumi.Input[str],
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleOverrideArgs']]]] = None):
        """
        Defines a managed rule group override setting.
        :param pulumi.Input[str] rule_group_name: Describes the managed rule group within the rule set to override
        :param pulumi.Input[Sequence[pulumi.Input['ManagedRuleOverrideArgs']]] rules: List of rules that will be enabled. If none specified, all rules in the group will be disabled.
        """
        ManagedRuleGroupOverrideArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_group_name=rule_group_name,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_group_name: Optional[pulumi.Input[str]] = None,
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleOverrideArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_group_name is None and 'ruleGroupName' in kwargs:
            rule_group_name = kwargs['ruleGroupName']
        if rule_group_name is None:
            raise TypeError("Missing 'rule_group_name' argument")

        _setter("rule_group_name", rule_group_name)
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter(name="ruleGroupName")
    def rule_group_name(self) -> pulumi.Input[str]:
        """
        Describes the managed rule group within the rule set to override
        """
        return pulumi.get(self, "rule_group_name")

    @rule_group_name.setter
    def rule_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_group_name", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleOverrideArgs']]]]:
        """
        List of rules that will be enabled. If none specified, all rules in the group will be disabled.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleOverrideArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class ManagedRuleOverrideArgs:
    def __init__(__self__, *,
                 rule_id: pulumi.Input[str],
                 action: Optional[pulumi.Input[Union[str, 'ActionType']]] = None,
                 enabled_state: Optional[pulumi.Input[Union[str, 'ManagedRuleEnabledState']]] = None):
        """
        Defines a managed rule group override setting.
        :param pulumi.Input[str] rule_id: Identifier for the managed rule.
        :param pulumi.Input[Union[str, 'ActionType']] action: Describes the override action to be applied when rule matches.
        :param pulumi.Input[Union[str, 'ManagedRuleEnabledState']] enabled_state: Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
        """
        ManagedRuleOverrideArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_id=rule_id,
            action=action,
            enabled_state=enabled_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_id: Optional[pulumi.Input[str]] = None,
             action: Optional[pulumi.Input[Union[str, 'ActionType']]] = None,
             enabled_state: Optional[pulumi.Input[Union[str, 'ManagedRuleEnabledState']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_id is None and 'ruleId' in kwargs:
            rule_id = kwargs['ruleId']
        if rule_id is None:
            raise TypeError("Missing 'rule_id' argument")
        if enabled_state is None and 'enabledState' in kwargs:
            enabled_state = kwargs['enabledState']

        _setter("rule_id", rule_id)
        if action is not None:
            _setter("action", action)
        if enabled_state is not None:
            _setter("enabled_state", enabled_state)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Input[str]:
        """
        Identifier for the managed rule.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[Union[str, 'ActionType']]]:
        """
        Describes the override action to be applied when rule matches.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[Union[str, 'ActionType']]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[pulumi.Input[Union[str, 'ManagedRuleEnabledState']]]:
        """
        Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
        """
        return pulumi.get(self, "enabled_state")

    @enabled_state.setter
    def enabled_state(self, value: Optional[pulumi.Input[Union[str, 'ManagedRuleEnabledState']]]):
        pulumi.set(self, "enabled_state", value)


@pulumi.input_type
class ManagedRuleSetListArgs:
    def __init__(__self__, *,
                 managed_rule_sets: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleSetArgs']]]] = None):
        """
        Defines the list of managed rule sets for the policy.
        :param pulumi.Input[Sequence[pulumi.Input['ManagedRuleSetArgs']]] managed_rule_sets: List of rule sets.
        """
        ManagedRuleSetListArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            managed_rule_sets=managed_rule_sets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             managed_rule_sets: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleSetArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if managed_rule_sets is None and 'managedRuleSets' in kwargs:
            managed_rule_sets = kwargs['managedRuleSets']

        if managed_rule_sets is not None:
            _setter("managed_rule_sets", managed_rule_sets)

    @property
    @pulumi.getter(name="managedRuleSets")
    def managed_rule_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleSetArgs']]]]:
        """
        List of rule sets.
        """
        return pulumi.get(self, "managed_rule_sets")

    @managed_rule_sets.setter
    def managed_rule_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleSetArgs']]]]):
        pulumi.set(self, "managed_rule_sets", value)


@pulumi.input_type
class ManagedRuleSetArgs:
    def __init__(__self__, *,
                 rule_set_type: pulumi.Input[str],
                 rule_set_version: pulumi.Input[str],
                 anomaly_score: Optional[pulumi.Input[int]] = None,
                 rule_group_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleGroupOverrideArgs']]]] = None):
        """
        Defines a managed rule set.
        :param pulumi.Input[str] rule_set_type: Defines the rule set type to use.
        :param pulumi.Input[str] rule_set_version: Defines the version of the rule set to use.
        :param pulumi.Input[int] anomaly_score: Verizon only : If the rule set supports anomaly detection mode, this describes the threshold for blocking requests.
        :param pulumi.Input[Sequence[pulumi.Input['ManagedRuleGroupOverrideArgs']]] rule_group_overrides: Defines the rule overrides to apply to the rule set.
        """
        ManagedRuleSetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_set_type=rule_set_type,
            rule_set_version=rule_set_version,
            anomaly_score=anomaly_score,
            rule_group_overrides=rule_group_overrides,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_set_type: Optional[pulumi.Input[str]] = None,
             rule_set_version: Optional[pulumi.Input[str]] = None,
             anomaly_score: Optional[pulumi.Input[int]] = None,
             rule_group_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleGroupOverrideArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if rule_set_type is None and 'ruleSetType' in kwargs:
            rule_set_type = kwargs['ruleSetType']
        if rule_set_type is None:
            raise TypeError("Missing 'rule_set_type' argument")
        if rule_set_version is None and 'ruleSetVersion' in kwargs:
            rule_set_version = kwargs['ruleSetVersion']
        if rule_set_version is None:
            raise TypeError("Missing 'rule_set_version' argument")
        if anomaly_score is None and 'anomalyScore' in kwargs:
            anomaly_score = kwargs['anomalyScore']
        if rule_group_overrides is None and 'ruleGroupOverrides' in kwargs:
            rule_group_overrides = kwargs['ruleGroupOverrides']

        _setter("rule_set_type", rule_set_type)
        _setter("rule_set_version", rule_set_version)
        if anomaly_score is not None:
            _setter("anomaly_score", anomaly_score)
        if rule_group_overrides is not None:
            _setter("rule_group_overrides", rule_group_overrides)

    @property
    @pulumi.getter(name="ruleSetType")
    def rule_set_type(self) -> pulumi.Input[str]:
        """
        Defines the rule set type to use.
        """
        return pulumi.get(self, "rule_set_type")

    @rule_set_type.setter
    def rule_set_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_set_type", value)

    @property
    @pulumi.getter(name="ruleSetVersion")
    def rule_set_version(self) -> pulumi.Input[str]:
        """
        Defines the version of the rule set to use.
        """
        return pulumi.get(self, "rule_set_version")

    @rule_set_version.setter
    def rule_set_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_set_version", value)

    @property
    @pulumi.getter(name="anomalyScore")
    def anomaly_score(self) -> Optional[pulumi.Input[int]]:
        """
        Verizon only : If the rule set supports anomaly detection mode, this describes the threshold for blocking requests.
        """
        return pulumi.get(self, "anomaly_score")

    @anomaly_score.setter
    def anomaly_score(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "anomaly_score", value)

    @property
    @pulumi.getter(name="ruleGroupOverrides")
    def rule_group_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleGroupOverrideArgs']]]]:
        """
        Defines the rule overrides to apply to the rule set.
        """
        return pulumi.get(self, "rule_group_overrides")

    @rule_group_overrides.setter
    def rule_group_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ManagedRuleGroupOverrideArgs']]]]):
        pulumi.set(self, "rule_group_overrides", value)


@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        ManagedServiceIdentityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[Union[str, 'ManagedServiceIdentityType']]] = None,
             user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if user_assigned_identities is None and 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


@pulumi.input_type
class MatchConditionArgs:
    def __init__(__self__, *,
                 match_value: pulumi.Input[Sequence[pulumi.Input[str]]],
                 match_variable: pulumi.Input[Union[str, 'WafMatchVariable']],
                 operator: pulumi.Input[Union[str, 'Operator']],
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 selector: Optional[pulumi.Input[str]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'TransformType']]]]] = None):
        """
        Define match conditions
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_value: List of possible match values.
        :param pulumi.Input[Union[str, 'WafMatchVariable']] match_variable: Match variable to compare against.
        :param pulumi.Input[Union[str, 'Operator']] operator: Describes operator to be matched
        :param pulumi.Input[bool] negate_condition: Describes if the result of this condition should be negated.
        :param pulumi.Input[str] selector: Selector can used to match a specific key for QueryString, Cookies, RequestHeader or PostArgs.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'TransformType']]]] transforms: List of transforms.
        """
        MatchConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_value=match_value,
            match_variable=match_variable,
            operator=operator,
            negate_condition=negate_condition,
            selector=selector,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             match_variable: Optional[pulumi.Input[Union[str, 'WafMatchVariable']]] = None,
             operator: Optional[pulumi.Input[Union[str, 'Operator']]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             selector: Optional[pulumi.Input[str]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'TransformType']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if match_value is None and 'matchValue' in kwargs:
            match_value = kwargs['matchValue']
        if match_value is None:
            raise TypeError("Missing 'match_value' argument")
        if match_variable is None and 'matchVariable' in kwargs:
            match_variable = kwargs['matchVariable']
        if match_variable is None:
            raise TypeError("Missing 'match_variable' argument")
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("match_value", match_value)
        _setter("match_variable", match_variable)
        _setter("operator", operator)
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if selector is not None:
            _setter("selector", selector)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of possible match values.
        """
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> pulumi.Input[Union[str, 'WafMatchVariable']]:
        """
        Match variable to compare against.
        """
        return pulumi.get(self, "match_variable")

    @match_variable.setter
    def match_variable(self, value: pulumi.Input[Union[str, 'WafMatchVariable']]):
        pulumi.set(self, "match_variable", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'Operator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'Operator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if the result of this condition should be negated.
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[str]]:
        """
        Selector can used to match a specific key for QueryString, Cookies, RequestHeader or PostArgs.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'TransformType']]]]]:
        """
        List of transforms.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'TransformType']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class OriginGroupOverrideActionParametersArgs:
    def __init__(__self__, *,
                 origin_group: pulumi.Input['ResourceReferenceArgs'],
                 type_name: pulumi.Input[str]):
        """
        Defines the parameters for the origin group override action.
        :param pulumi.Input['ResourceReferenceArgs'] origin_group: defines the OriginGroup that would override the DefaultOriginGroup.
        """
        OriginGroupOverrideActionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            origin_group=origin_group,
            type_name=type_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             origin_group: Optional[pulumi.Input['ResourceReferenceArgs']] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if origin_group is None and 'originGroup' in kwargs:
            origin_group = kwargs['originGroup']
        if origin_group is None:
            raise TypeError("Missing 'origin_group' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")

        _setter("origin_group", origin_group)
        _setter("type_name", type_name)

    @property
    @pulumi.getter(name="originGroup")
    def origin_group(self) -> pulumi.Input['ResourceReferenceArgs']:
        """
        defines the OriginGroup that would override the DefaultOriginGroup.
        """
        return pulumi.get(self, "origin_group")

    @origin_group.setter
    def origin_group(self, value: pulumi.Input['ResourceReferenceArgs']):
        pulumi.set(self, "origin_group", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)


@pulumi.input_type
class OriginGroupOverrideActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['OriginGroupOverrideActionParametersArgs']):
        """
        Defines the origin group override action for the delivery rule.
        :param pulumi.Input[str] name: The name of the action for the delivery rule.
               Expected value is 'OriginGroupOverride'.
        :param pulumi.Input['OriginGroupOverrideActionParametersArgs'] parameters: Defines the parameters for the action.
        """
        OriginGroupOverrideActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['OriginGroupOverrideActionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'OriginGroupOverride')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the action for the delivery rule.
        Expected value is 'OriginGroupOverride'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['OriginGroupOverrideActionParametersArgs']:
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['OriginGroupOverrideActionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class OriginGroupOverrideArgs:
    def __init__(__self__, *,
                 forwarding_protocol: Optional[pulumi.Input[Union[str, 'ForwardingProtocol']]] = None,
                 origin_group: Optional[pulumi.Input['ResourceReferenceArgs']] = None):
        """
        Defines the parameters for the origin group override configuration.
        :param pulumi.Input[Union[str, 'ForwardingProtocol']] forwarding_protocol: Protocol this rule will use when forwarding traffic to backends.
        :param pulumi.Input['ResourceReferenceArgs'] origin_group: defines the OriginGroup that would override the DefaultOriginGroup on route.
        """
        OriginGroupOverrideArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forwarding_protocol=forwarding_protocol,
            origin_group=origin_group,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forwarding_protocol: Optional[pulumi.Input[Union[str, 'ForwardingProtocol']]] = None,
             origin_group: Optional[pulumi.Input['ResourceReferenceArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if forwarding_protocol is None and 'forwardingProtocol' in kwargs:
            forwarding_protocol = kwargs['forwardingProtocol']
        if origin_group is None and 'originGroup' in kwargs:
            origin_group = kwargs['originGroup']

        if forwarding_protocol is not None:
            _setter("forwarding_protocol", forwarding_protocol)
        if origin_group is not None:
            _setter("origin_group", origin_group)

    @property
    @pulumi.getter(name="forwardingProtocol")
    def forwarding_protocol(self) -> Optional[pulumi.Input[Union[str, 'ForwardingProtocol']]]:
        """
        Protocol this rule will use when forwarding traffic to backends.
        """
        return pulumi.get(self, "forwarding_protocol")

    @forwarding_protocol.setter
    def forwarding_protocol(self, value: Optional[pulumi.Input[Union[str, 'ForwardingProtocol']]]):
        pulumi.set(self, "forwarding_protocol", value)

    @property
    @pulumi.getter(name="originGroup")
    def origin_group(self) -> Optional[pulumi.Input['ResourceReferenceArgs']]:
        """
        defines the OriginGroup that would override the DefaultOriginGroup on route.
        """
        return pulumi.get(self, "origin_group")

    @origin_group.setter
    def origin_group(self, value: Optional[pulumi.Input['ResourceReferenceArgs']]):
        pulumi.set(self, "origin_group", value)


@pulumi.input_type
class PolicySettingsArgs:
    def __init__(__self__, *,
                 default_custom_block_response_body: Optional[pulumi.Input[str]] = None,
                 default_custom_block_response_status_code: Optional[pulumi.Input[int]] = None,
                 default_redirect_url: Optional[pulumi.Input[str]] = None,
                 enabled_state: Optional[pulumi.Input[Union[str, 'PolicyEnabledState']]] = None,
                 mode: Optional[pulumi.Input[Union[str, 'PolicyMode']]] = None):
        """
        Defines contents of a web application firewall global configuration
        :param pulumi.Input[str] default_custom_block_response_body: If the action type is block, customer can override the response body. The body must be specified in base64 encoding.
        :param pulumi.Input[int] default_custom_block_response_status_code: If the action type is block, this field defines the default customer overridable http response status code.
        :param pulumi.Input[str] default_redirect_url: If action type is redirect, this field represents the default redirect URL for the client.
        :param pulumi.Input[Union[str, 'PolicyEnabledState']] enabled_state: describes if the policy is in enabled state or disabled state
        :param pulumi.Input[Union[str, 'PolicyMode']] mode: Describes if it is in detection mode or prevention mode at policy level.
        """
        PolicySettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_custom_block_response_body=default_custom_block_response_body,
            default_custom_block_response_status_code=default_custom_block_response_status_code,
            default_redirect_url=default_redirect_url,
            enabled_state=enabled_state,
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_custom_block_response_body: Optional[pulumi.Input[str]] = None,
             default_custom_block_response_status_code: Optional[pulumi.Input[int]] = None,
             default_redirect_url: Optional[pulumi.Input[str]] = None,
             enabled_state: Optional[pulumi.Input[Union[str, 'PolicyEnabledState']]] = None,
             mode: Optional[pulumi.Input[Union[str, 'PolicyMode']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if default_custom_block_response_body is None and 'defaultCustomBlockResponseBody' in kwargs:
            default_custom_block_response_body = kwargs['defaultCustomBlockResponseBody']
        if default_custom_block_response_status_code is None and 'defaultCustomBlockResponseStatusCode' in kwargs:
            default_custom_block_response_status_code = kwargs['defaultCustomBlockResponseStatusCode']
        if default_redirect_url is None and 'defaultRedirectUrl' in kwargs:
            default_redirect_url = kwargs['defaultRedirectUrl']
        if enabled_state is None and 'enabledState' in kwargs:
            enabled_state = kwargs['enabledState']

        if default_custom_block_response_body is not None:
            _setter("default_custom_block_response_body", default_custom_block_response_body)
        if default_custom_block_response_status_code is not None:
            _setter("default_custom_block_response_status_code", default_custom_block_response_status_code)
        if default_redirect_url is not None:
            _setter("default_redirect_url", default_redirect_url)
        if enabled_state is not None:
            _setter("enabled_state", enabled_state)
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter(name="defaultCustomBlockResponseBody")
    def default_custom_block_response_body(self) -> Optional[pulumi.Input[str]]:
        """
        If the action type is block, customer can override the response body. The body must be specified in base64 encoding.
        """
        return pulumi.get(self, "default_custom_block_response_body")

    @default_custom_block_response_body.setter
    def default_custom_block_response_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_custom_block_response_body", value)

    @property
    @pulumi.getter(name="defaultCustomBlockResponseStatusCode")
    def default_custom_block_response_status_code(self) -> Optional[pulumi.Input[int]]:
        """
        If the action type is block, this field defines the default customer overridable http response status code.
        """
        return pulumi.get(self, "default_custom_block_response_status_code")

    @default_custom_block_response_status_code.setter
    def default_custom_block_response_status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_custom_block_response_status_code", value)

    @property
    @pulumi.getter(name="defaultRedirectUrl")
    def default_redirect_url(self) -> Optional[pulumi.Input[str]]:
        """
        If action type is redirect, this field represents the default redirect URL for the client.
        """
        return pulumi.get(self, "default_redirect_url")

    @default_redirect_url.setter
    def default_redirect_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_redirect_url", value)

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[pulumi.Input[Union[str, 'PolicyEnabledState']]]:
        """
        describes if the policy is in enabled state or disabled state
        """
        return pulumi.get(self, "enabled_state")

    @enabled_state.setter
    def enabled_state(self, value: Optional[pulumi.Input[Union[str, 'PolicyEnabledState']]]):
        pulumi.set(self, "enabled_state", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[str, 'PolicyMode']]]:
        """
        Describes if it is in detection mode or prevention mode at policy level.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[str, 'PolicyMode']]]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class PostArgsMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'PostArgsOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 selector: Optional[pulumi.Input[str]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for PostArgs match conditions
        :param pulumi.Input[Union[str, 'PostArgsOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[str] selector: Name of PostArg to be matched
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        PostArgsMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            selector=selector,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'PostArgsOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             selector: Optional[pulumi.Input[str]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if selector is not None:
            _setter("selector", selector)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'PostArgsOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'PostArgsOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[str]]:
        """
        Name of PostArg to be matched
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class QueryStringMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'QueryStringOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for QueryString match conditions
        :param pulumi.Input[Union[str, 'QueryStringOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        QueryStringMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'QueryStringOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'QueryStringOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'QueryStringOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class RateLimitRuleListArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['RateLimitRuleArgs']]]] = None):
        """
        Defines contents of rate limit rules
        :param pulumi.Input[Sequence[pulumi.Input['RateLimitRuleArgs']]] rules: List of rules
        """
        RateLimitRuleListArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['RateLimitRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RateLimitRuleArgs']]]]:
        """
        List of rules
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RateLimitRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class RateLimitRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[Union[str, 'ActionType']],
                 match_conditions: pulumi.Input[Sequence[pulumi.Input['MatchConditionArgs']]],
                 name: pulumi.Input[str],
                 priority: pulumi.Input[int],
                 rate_limit_duration_in_minutes: pulumi.Input[int],
                 rate_limit_threshold: pulumi.Input[int],
                 enabled_state: Optional[pulumi.Input[Union[str, 'CustomRuleEnabledState']]] = None):
        """
        Defines a rate limiting rule that can be included in a waf policy
        :param pulumi.Input[Union[str, 'ActionType']] action: Describes what action to be applied when rule matches
        :param pulumi.Input[Sequence[pulumi.Input['MatchConditionArgs']]] match_conditions: List of match conditions.
        :param pulumi.Input[str] name: Defines the name of the custom rule
        :param pulumi.Input[int] priority: Defines in what order this rule be evaluated in the overall list of custom rules
        :param pulumi.Input[int] rate_limit_duration_in_minutes: Defines rate limit duration. Default is 1 minute.
        :param pulumi.Input[int] rate_limit_threshold: Defines rate limit threshold.
        :param pulumi.Input[Union[str, 'CustomRuleEnabledState']] enabled_state: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
        """
        RateLimitRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            match_conditions=match_conditions,
            name=name,
            priority=priority,
            rate_limit_duration_in_minutes=rate_limit_duration_in_minutes,
            rate_limit_threshold=rate_limit_threshold,
            enabled_state=enabled_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[pulumi.Input[Union[str, 'ActionType']]] = None,
             match_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['MatchConditionArgs']]]] = None,
             name: Optional[pulumi.Input[str]] = None,
             priority: Optional[pulumi.Input[int]] = None,
             rate_limit_duration_in_minutes: Optional[pulumi.Input[int]] = None,
             rate_limit_threshold: Optional[pulumi.Input[int]] = None,
             enabled_state: Optional[pulumi.Input[Union[str, 'CustomRuleEnabledState']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if match_conditions is None and 'matchConditions' in kwargs:
            match_conditions = kwargs['matchConditions']
        if match_conditions is None:
            raise TypeError("Missing 'match_conditions' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if priority is None:
            raise TypeError("Missing 'priority' argument")
        if rate_limit_duration_in_minutes is None and 'rateLimitDurationInMinutes' in kwargs:
            rate_limit_duration_in_minutes = kwargs['rateLimitDurationInMinutes']
        if rate_limit_duration_in_minutes is None:
            raise TypeError("Missing 'rate_limit_duration_in_minutes' argument")
        if rate_limit_threshold is None and 'rateLimitThreshold' in kwargs:
            rate_limit_threshold = kwargs['rateLimitThreshold']
        if rate_limit_threshold is None:
            raise TypeError("Missing 'rate_limit_threshold' argument")
        if enabled_state is None and 'enabledState' in kwargs:
            enabled_state = kwargs['enabledState']

        _setter("action", action)
        _setter("match_conditions", match_conditions)
        _setter("name", name)
        _setter("priority", priority)
        _setter("rate_limit_duration_in_minutes", rate_limit_duration_in_minutes)
        _setter("rate_limit_threshold", rate_limit_threshold)
        if enabled_state is not None:
            _setter("enabled_state", enabled_state)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[Union[str, 'ActionType']]:
        """
        Describes what action to be applied when rule matches
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[Union[str, 'ActionType']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> pulumi.Input[Sequence[pulumi.Input['MatchConditionArgs']]]:
        """
        List of match conditions.
        """
        return pulumi.get(self, "match_conditions")

    @match_conditions.setter
    def match_conditions(self, value: pulumi.Input[Sequence[pulumi.Input['MatchConditionArgs']]]):
        pulumi.set(self, "match_conditions", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Defines the name of the custom rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Defines in what order this rule be evaluated in the overall list of custom rules
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="rateLimitDurationInMinutes")
    def rate_limit_duration_in_minutes(self) -> pulumi.Input[int]:
        """
        Defines rate limit duration. Default is 1 minute.
        """
        return pulumi.get(self, "rate_limit_duration_in_minutes")

    @rate_limit_duration_in_minutes.setter
    def rate_limit_duration_in_minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "rate_limit_duration_in_minutes", value)

    @property
    @pulumi.getter(name="rateLimitThreshold")
    def rate_limit_threshold(self) -> pulumi.Input[int]:
        """
        Defines rate limit threshold.
        """
        return pulumi.get(self, "rate_limit_threshold")

    @rate_limit_threshold.setter
    def rate_limit_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "rate_limit_threshold", value)

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[pulumi.Input[Union[str, 'CustomRuleEnabledState']]]:
        """
        Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
        """
        return pulumi.get(self, "enabled_state")

    @enabled_state.setter
    def enabled_state(self, value: Optional[pulumi.Input[Union[str, 'CustomRuleEnabledState']]]):
        pulumi.set(self, "enabled_state", value)


@pulumi.input_type
class RemoteAddressMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'RemoteAddressOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for RemoteAddress match conditions
        :param pulumi.Input[Union[str, 'RemoteAddressOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator this match condition is considered a match.
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        RemoteAddressMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'RemoteAddressOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'RemoteAddressOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'RemoteAddressOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator this match condition is considered a match.
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class RequestBodyMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'RequestBodyOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for RequestBody match conditions
        :param pulumi.Input[Union[str, 'RequestBodyOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        RequestBodyMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'RequestBodyOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'RequestBodyOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'RequestBodyOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class RequestHeaderMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'RequestHeaderOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 selector: Optional[pulumi.Input[str]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for RequestHeader match conditions
        :param pulumi.Input[Union[str, 'RequestHeaderOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[str] selector: Name of Header to be matched
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        RequestHeaderMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            selector=selector,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'RequestHeaderOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             selector: Optional[pulumi.Input[str]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if selector is not None:
            _setter("selector", selector)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'RequestHeaderOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'RequestHeaderOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[str]]:
        """
        Name of Header to be matched
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class RequestMethodMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'RequestMethodOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for RequestMethod match conditions
        :param pulumi.Input[Union[str, 'RequestMethodOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        RequestMethodMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'RequestMethodOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'RequestMethodOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'RequestMethodOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class RequestSchemeMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for RequestScheme match conditions 
        :param pulumi.Input[str] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        RequestSchemeMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[str]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class RequestUriMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'RequestUriOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for RequestUri match conditions
        :param pulumi.Input[Union[str, 'RequestUriOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        RequestUriMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'RequestUriOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'RequestUriOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'RequestUriOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class ResourceReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Reference to another resource.
        :param pulumi.Input[str] id: Resource ID.
        """
        ResourceReferenceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class ResponseBasedOriginErrorDetectionParametersArgs:
    def __init__(__self__, *,
                 http_error_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['HttpErrorRangeParametersArgs']]]] = None,
                 response_based_detected_error_types: Optional[pulumi.Input['ResponseBasedDetectedErrorTypes']] = None,
                 response_based_failover_threshold_percentage: Optional[pulumi.Input[int]] = None):
        """
        The JSON object that contains the properties to determine origin health using real requests/responses.
        :param pulumi.Input[Sequence[pulumi.Input['HttpErrorRangeParametersArgs']]] http_error_ranges: The list of Http status code ranges that are considered as server errors for origin and it is marked as unhealthy.
        :param pulumi.Input['ResponseBasedDetectedErrorTypes'] response_based_detected_error_types: Type of response errors for real user requests for which origin will be deemed unhealthy
        :param pulumi.Input[int] response_based_failover_threshold_percentage: The percentage of failed requests in the sample where failover should trigger.
        """
        ResponseBasedOriginErrorDetectionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_error_ranges=http_error_ranges,
            response_based_detected_error_types=response_based_detected_error_types,
            response_based_failover_threshold_percentage=response_based_failover_threshold_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_error_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['HttpErrorRangeParametersArgs']]]] = None,
             response_based_detected_error_types: Optional[pulumi.Input['ResponseBasedDetectedErrorTypes']] = None,
             response_based_failover_threshold_percentage: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if http_error_ranges is None and 'httpErrorRanges' in kwargs:
            http_error_ranges = kwargs['httpErrorRanges']
        if response_based_detected_error_types is None and 'responseBasedDetectedErrorTypes' in kwargs:
            response_based_detected_error_types = kwargs['responseBasedDetectedErrorTypes']
        if response_based_failover_threshold_percentage is None and 'responseBasedFailoverThresholdPercentage' in kwargs:
            response_based_failover_threshold_percentage = kwargs['responseBasedFailoverThresholdPercentage']

        if http_error_ranges is not None:
            _setter("http_error_ranges", http_error_ranges)
        if response_based_detected_error_types is not None:
            _setter("response_based_detected_error_types", response_based_detected_error_types)
        if response_based_failover_threshold_percentage is not None:
            _setter("response_based_failover_threshold_percentage", response_based_failover_threshold_percentage)

    @property
    @pulumi.getter(name="httpErrorRanges")
    def http_error_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpErrorRangeParametersArgs']]]]:
        """
        The list of Http status code ranges that are considered as server errors for origin and it is marked as unhealthy.
        """
        return pulumi.get(self, "http_error_ranges")

    @http_error_ranges.setter
    def http_error_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpErrorRangeParametersArgs']]]]):
        pulumi.set(self, "http_error_ranges", value)

    @property
    @pulumi.getter(name="responseBasedDetectedErrorTypes")
    def response_based_detected_error_types(self) -> Optional[pulumi.Input['ResponseBasedDetectedErrorTypes']]:
        """
        Type of response errors for real user requests for which origin will be deemed unhealthy
        """
        return pulumi.get(self, "response_based_detected_error_types")

    @response_based_detected_error_types.setter
    def response_based_detected_error_types(self, value: Optional[pulumi.Input['ResponseBasedDetectedErrorTypes']]):
        pulumi.set(self, "response_based_detected_error_types", value)

    @property
    @pulumi.getter(name="responseBasedFailoverThresholdPercentage")
    def response_based_failover_threshold_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        The percentage of failed requests in the sample where failover should trigger.
        """
        return pulumi.get(self, "response_based_failover_threshold_percentage")

    @response_based_failover_threshold_percentage.setter
    def response_based_failover_threshold_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "response_based_failover_threshold_percentage", value)


@pulumi.input_type
class RouteConfigurationOverrideActionParametersArgs:
    def __init__(__self__, *,
                 type_name: pulumi.Input[str],
                 cache_configuration: Optional[pulumi.Input['CacheConfigurationArgs']] = None,
                 origin_group_override: Optional[pulumi.Input['OriginGroupOverrideArgs']] = None):
        """
        Defines the parameters for the route configuration override action.
        :param pulumi.Input['CacheConfigurationArgs'] cache_configuration: The caching configuration associated with this rule. To disable caching, do not provide a cacheConfiguration object.
        :param pulumi.Input['OriginGroupOverrideArgs'] origin_group_override: A reference to the origin group override configuration. Leave empty to use the default origin group on route.
        """
        RouteConfigurationOverrideActionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type_name=type_name,
            cache_configuration=cache_configuration,
            origin_group_override=origin_group_override,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type_name: Optional[pulumi.Input[str]] = None,
             cache_configuration: Optional[pulumi.Input['CacheConfigurationArgs']] = None,
             origin_group_override: Optional[pulumi.Input['OriginGroupOverrideArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if cache_configuration is None and 'cacheConfiguration' in kwargs:
            cache_configuration = kwargs['cacheConfiguration']
        if origin_group_override is None and 'originGroupOverride' in kwargs:
            origin_group_override = kwargs['originGroupOverride']

        _setter("type_name", type_name)
        if cache_configuration is not None:
            _setter("cache_configuration", cache_configuration)
        if origin_group_override is not None:
            _setter("origin_group_override", origin_group_override)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="cacheConfiguration")
    def cache_configuration(self) -> Optional[pulumi.Input['CacheConfigurationArgs']]:
        """
        The caching configuration associated with this rule. To disable caching, do not provide a cacheConfiguration object.
        """
        return pulumi.get(self, "cache_configuration")

    @cache_configuration.setter
    def cache_configuration(self, value: Optional[pulumi.Input['CacheConfigurationArgs']]):
        pulumi.set(self, "cache_configuration", value)

    @property
    @pulumi.getter(name="originGroupOverride")
    def origin_group_override(self) -> Optional[pulumi.Input['OriginGroupOverrideArgs']]:
        """
        A reference to the origin group override configuration. Leave empty to use the default origin group on route.
        """
        return pulumi.get(self, "origin_group_override")

    @origin_group_override.setter
    def origin_group_override(self, value: Optional[pulumi.Input['OriginGroupOverrideArgs']]):
        pulumi.set(self, "origin_group_override", value)


@pulumi.input_type
class SecurityPolicyWebApplicationFirewallAssociationArgs:
    def __init__(__self__, *,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input['ActivatedResourceReferenceArgs']]]] = None,
                 patterns_to_match: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        settings for security policy patterns to match
        :param pulumi.Input[Sequence[pulumi.Input['ActivatedResourceReferenceArgs']]] domains: List of domains.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] patterns_to_match: List of paths
        """
        SecurityPolicyWebApplicationFirewallAssociationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domains=domains,
            patterns_to_match=patterns_to_match,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domains: Optional[pulumi.Input[Sequence[pulumi.Input['ActivatedResourceReferenceArgs']]]] = None,
             patterns_to_match: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if patterns_to_match is None and 'patternsToMatch' in kwargs:
            patterns_to_match = kwargs['patternsToMatch']

        if domains is not None:
            _setter("domains", domains)
        if patterns_to_match is not None:
            _setter("patterns_to_match", patterns_to_match)

    @property
    @pulumi.getter
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ActivatedResourceReferenceArgs']]]]:
        """
        List of domains.
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ActivatedResourceReferenceArgs']]]]):
        pulumi.set(self, "domains", value)

    @property
    @pulumi.getter(name="patternsToMatch")
    def patterns_to_match(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of paths
        """
        return pulumi.get(self, "patterns_to_match")

    @patterns_to_match.setter
    def patterns_to_match(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "patterns_to_match", value)


@pulumi.input_type
class SecurityPolicyWebApplicationFirewallParametersArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 associations: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityPolicyWebApplicationFirewallAssociationArgs']]]] = None,
                 waf_policy: Optional[pulumi.Input['ResourceReferenceArgs']] = None):
        """
        The json object containing security policy waf parameters
        :param pulumi.Input[str] type: The type of the Security policy to create.
               Expected value is 'WebApplicationFirewall'.
        :param pulumi.Input[Sequence[pulumi.Input['SecurityPolicyWebApplicationFirewallAssociationArgs']]] associations: Waf associations
        :param pulumi.Input['ResourceReferenceArgs'] waf_policy: Resource ID.
        """
        SecurityPolicyWebApplicationFirewallParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            associations=associations,
            waf_policy=waf_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             associations: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityPolicyWebApplicationFirewallAssociationArgs']]]] = None,
             waf_policy: Optional[pulumi.Input['ResourceReferenceArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type is None:
            raise TypeError("Missing 'type' argument")
        if waf_policy is None and 'wafPolicy' in kwargs:
            waf_policy = kwargs['wafPolicy']

        _setter("type", 'WebApplicationFirewall')
        if associations is not None:
            _setter("associations", associations)
        if waf_policy is not None:
            _setter("waf_policy", waf_policy)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the Security policy to create.
        Expected value is 'WebApplicationFirewall'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def associations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityPolicyWebApplicationFirewallAssociationArgs']]]]:
        """
        Waf associations
        """
        return pulumi.get(self, "associations")

    @associations.setter
    def associations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityPolicyWebApplicationFirewallAssociationArgs']]]]):
        pulumi.set(self, "associations", value)

    @property
    @pulumi.getter(name="wafPolicy")
    def waf_policy(self) -> Optional[pulumi.Input['ResourceReferenceArgs']]:
        """
        Resource ID.
        """
        return pulumi.get(self, "waf_policy")

    @waf_policy.setter
    def waf_policy(self, value: Optional[pulumi.Input['ResourceReferenceArgs']]):
        pulumi.set(self, "waf_policy", value)


@pulumi.input_type
class ServerPortMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'ServerPortOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for ServerPort match conditions
        :param pulumi.Input[Union[str, 'ServerPortOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        ServerPortMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'ServerPortOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'ServerPortOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'ServerPortOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class SharedPrivateLinkResourcePropertiesArgs:
    def __init__(__self__, *,
                 group_id: Optional[pulumi.Input[str]] = None,
                 private_link: Optional[pulumi.Input['ResourceReferenceArgs']] = None,
                 private_link_location: Optional[pulumi.Input[str]] = None,
                 request_message: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input['SharedPrivateLinkResourceStatus']] = None):
        """
        Describes the properties of an existing Shared Private Link Resource to use when connecting to a private origin.
        :param pulumi.Input[str] group_id: The group id from the provider of resource the shared private link resource is for.
        :param pulumi.Input['ResourceReferenceArgs'] private_link: The resource id of the resource the shared private link resource is for.
        :param pulumi.Input[str] private_link_location: The location of the shared private link resource
        :param pulumi.Input[str] request_message: The request message for requesting approval of the shared private link resource.
        :param pulumi.Input['SharedPrivateLinkResourceStatus'] status: Status of the shared private link resource. Can be Pending, Approved, Rejected, Disconnected, or Timeout.
        """
        SharedPrivateLinkResourcePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            private_link=private_link,
            private_link_location=private_link_location,
            request_message=request_message,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: Optional[pulumi.Input[str]] = None,
             private_link: Optional[pulumi.Input['ResourceReferenceArgs']] = None,
             private_link_location: Optional[pulumi.Input[str]] = None,
             request_message: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input['SharedPrivateLinkResourceStatus']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if group_id is None and 'groupId' in kwargs:
            group_id = kwargs['groupId']
        if private_link is None and 'privateLink' in kwargs:
            private_link = kwargs['privateLink']
        if private_link_location is None and 'privateLinkLocation' in kwargs:
            private_link_location = kwargs['privateLinkLocation']
        if request_message is None and 'requestMessage' in kwargs:
            request_message = kwargs['requestMessage']

        if group_id is not None:
            _setter("group_id", group_id)
        if private_link is not None:
            _setter("private_link", private_link)
        if private_link_location is not None:
            _setter("private_link_location", private_link_location)
        if request_message is not None:
            _setter("request_message", request_message)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The group id from the provider of resource the shared private link resource is for.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="privateLink")
    def private_link(self) -> Optional[pulumi.Input['ResourceReferenceArgs']]:
        """
        The resource id of the resource the shared private link resource is for.
        """
        return pulumi.get(self, "private_link")

    @private_link.setter
    def private_link(self, value: Optional[pulumi.Input['ResourceReferenceArgs']]):
        pulumi.set(self, "private_link", value)

    @property
    @pulumi.getter(name="privateLinkLocation")
    def private_link_location(self) -> Optional[pulumi.Input[str]]:
        """
        The location of the shared private link resource
        """
        return pulumi.get(self, "private_link_location")

    @private_link_location.setter
    def private_link_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_link_location", value)

    @property
    @pulumi.getter(name="requestMessage")
    def request_message(self) -> Optional[pulumi.Input[str]]:
        """
        The request message for requesting approval of the shared private link resource.
        """
        return pulumi.get(self, "request_message")

    @request_message.setter
    def request_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_message", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['SharedPrivateLinkResourceStatus']]:
        """
        Status of the shared private link resource. Can be Pending, Approved, Rejected, Disconnected, or Timeout.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['SharedPrivateLinkResourceStatus']]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[Union[str, 'SkuName']]] = None):
        """
        Standard_Verizon = The SKU name for a Standard Verizon CDN profile.
        Premium_Verizon = The SKU name for a Premium Verizon CDN profile.
        Custom_Verizon = The SKU name for a Custom Verizon CDN profile.
        Standard_Akamai = The SKU name for an Akamai CDN profile.
        Standard_ChinaCdn = The SKU name for a China CDN profile for VOD, Web and download scenarios using GB based billing model.
        Standard_Microsoft = The SKU name for a Standard Microsoft CDN profile.
        Standard_AzureFrontDoor =  The SKU name for an Azure Front Door Standard profile.
        Premium_AzureFrontDoor = The SKU name for an Azure Front Door Premium profile.
        Standard_955BandWidth_ChinaCdn = The SKU name for a China CDN profile for VOD, Web and download scenarios using 95-5 peak bandwidth billing model.
        Standard_AvgBandWidth_ChinaCdn = The SKU name for a China CDN profile for VOD, Web and download scenarios using monthly average peak bandwidth billing model.
        StandardPlus_ChinaCdn = The SKU name for a China CDN profile for live-streaming using GB based billing model.
        StandardPlus_955BandWidth_ChinaCdn = The SKU name for a China CDN live-streaming profile using 95-5 peak bandwidth billing model.
        StandardPlus_AvgBandWidth_ChinaCdn = The SKU name for a China CDN live-streaming profile using monthly average peak bandwidth billing model.

        :param pulumi.Input[Union[str, 'SkuName']] name: Name of the pricing tier.
        """
        SkuArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[Union[str, 'SkuName']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[Union[str, 'SkuName']]]:
        """
        Name of the pricing tier.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[Union[str, 'SkuName']]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SocketAddrMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'SocketAddrOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for SocketAddress match conditions
        :param pulumi.Input[Union[str, 'SocketAddrOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        SocketAddrMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'SocketAddrOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'SocketAddrOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'SocketAddrOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class SslProtocolMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'SslProtocolOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'SslProtocol']]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for SslProtocol match conditions
        :param pulumi.Input[Union[str, 'SslProtocolOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'SslProtocol']]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        SslProtocolMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'SslProtocolOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'SslProtocol']]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'SslProtocolOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'SslProtocolOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'SslProtocol']]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'SslProtocol']]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class UrlFileExtensionMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'UrlFileExtensionOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for UrlFileExtension match conditions
        :param pulumi.Input[Union[str, 'UrlFileExtensionOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        UrlFileExtensionMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'UrlFileExtensionOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'UrlFileExtensionOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'UrlFileExtensionOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class UrlFileNameMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'UrlFileNameOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for UrlFilename match conditions
        :param pulumi.Input[Union[str, 'UrlFileNameOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        UrlFileNameMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'UrlFileNameOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'UrlFileNameOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'UrlFileNameOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class UrlPathMatchConditionParametersArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'UrlPathOperator']],
                 type_name: pulumi.Input[str],
                 match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 negate_condition: Optional[pulumi.Input[bool]] = None,
                 transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None):
        """
        Defines the parameters for UrlPath match conditions
        :param pulumi.Input[Union[str, 'UrlPathOperator']] operator: Describes operator to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] match_values: The match value for the condition of the delivery rule
        :param pulumi.Input[bool] negate_condition: Describes if this is negate condition or not
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]] transforms: List of transforms
        """
        UrlPathMatchConditionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type_name=type_name,
            match_values=match_values,
            negate_condition=negate_condition,
            transforms=transforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[Union[str, 'UrlPathOperator']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             match_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             negate_condition: Optional[pulumi.Input[bool]] = None,
             transforms: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if operator is None:
            raise TypeError("Missing 'operator' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if match_values is None and 'matchValues' in kwargs:
            match_values = kwargs['matchValues']
        if negate_condition is None and 'negateCondition' in kwargs:
            negate_condition = kwargs['negateCondition']

        _setter("operator", operator)
        _setter("type_name", type_name)
        if match_values is not None:
            _setter("match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            _setter("negate_condition", negate_condition)
        if transforms is not None:
            _setter("transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'UrlPathOperator']]:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'UrlPathOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @match_values.setter
    def match_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_values", value)

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @negate_condition.setter
    def negate_condition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate_condition", value)

    @property
    @pulumi.getter
    def transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'Transform']]]]]):
        pulumi.set(self, "transforms", value)


@pulumi.input_type
class UrlRedirectActionParametersArgs:
    def __init__(__self__, *,
                 redirect_type: pulumi.Input[Union[str, 'RedirectType']],
                 type_name: pulumi.Input[str],
                 custom_fragment: Optional[pulumi.Input[str]] = None,
                 custom_hostname: Optional[pulumi.Input[str]] = None,
                 custom_path: Optional[pulumi.Input[str]] = None,
                 custom_query_string: Optional[pulumi.Input[str]] = None,
                 destination_protocol: Optional[pulumi.Input[Union[str, 'DestinationProtocol']]] = None):
        """
        Defines the parameters for the url redirect action.
        :param pulumi.Input[Union[str, 'RedirectType']] redirect_type: The redirect type the rule will use when redirecting traffic.
        :param pulumi.Input[str] custom_fragment: Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include the #.
        :param pulumi.Input[str] custom_hostname: Host to redirect. Leave empty to use the incoming host as the destination host.
        :param pulumi.Input[str] custom_path: The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path as destination path.
        :param pulumi.Input[str] custom_query_string: The set of query strings to be placed in the redirect URL. Setting this value would replace any existing query string; leave empty to preserve the incoming query string. Query string must be in <key>=<value> format. ? and & will be added automatically so do not include them.
        :param pulumi.Input[Union[str, 'DestinationProtocol']] destination_protocol: Protocol to use for the redirect. The default value is MatchRequest
        """
        UrlRedirectActionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            redirect_type=redirect_type,
            type_name=type_name,
            custom_fragment=custom_fragment,
            custom_hostname=custom_hostname,
            custom_path=custom_path,
            custom_query_string=custom_query_string,
            destination_protocol=destination_protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             redirect_type: Optional[pulumi.Input[Union[str, 'RedirectType']]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             custom_fragment: Optional[pulumi.Input[str]] = None,
             custom_hostname: Optional[pulumi.Input[str]] = None,
             custom_path: Optional[pulumi.Input[str]] = None,
             custom_query_string: Optional[pulumi.Input[str]] = None,
             destination_protocol: Optional[pulumi.Input[Union[str, 'DestinationProtocol']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if redirect_type is None and 'redirectType' in kwargs:
            redirect_type = kwargs['redirectType']
        if redirect_type is None:
            raise TypeError("Missing 'redirect_type' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if custom_fragment is None and 'customFragment' in kwargs:
            custom_fragment = kwargs['customFragment']
        if custom_hostname is None and 'customHostname' in kwargs:
            custom_hostname = kwargs['customHostname']
        if custom_path is None and 'customPath' in kwargs:
            custom_path = kwargs['customPath']
        if custom_query_string is None and 'customQueryString' in kwargs:
            custom_query_string = kwargs['customQueryString']
        if destination_protocol is None and 'destinationProtocol' in kwargs:
            destination_protocol = kwargs['destinationProtocol']

        _setter("redirect_type", redirect_type)
        _setter("type_name", type_name)
        if custom_fragment is not None:
            _setter("custom_fragment", custom_fragment)
        if custom_hostname is not None:
            _setter("custom_hostname", custom_hostname)
        if custom_path is not None:
            _setter("custom_path", custom_path)
        if custom_query_string is not None:
            _setter("custom_query_string", custom_query_string)
        if destination_protocol is not None:
            _setter("destination_protocol", destination_protocol)

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> pulumi.Input[Union[str, 'RedirectType']]:
        """
        The redirect type the rule will use when redirecting traffic.
        """
        return pulumi.get(self, "redirect_type")

    @redirect_type.setter
    def redirect_type(self, value: pulumi.Input[Union[str, 'RedirectType']]):
        pulumi.set(self, "redirect_type", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="customFragment")
    def custom_fragment(self) -> Optional[pulumi.Input[str]]:
        """
        Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include the #.
        """
        return pulumi.get(self, "custom_fragment")

    @custom_fragment.setter
    def custom_fragment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_fragment", value)

    @property
    @pulumi.getter(name="customHostname")
    def custom_hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Host to redirect. Leave empty to use the incoming host as the destination host.
        """
        return pulumi.get(self, "custom_hostname")

    @custom_hostname.setter
    def custom_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_hostname", value)

    @property
    @pulumi.getter(name="customPath")
    def custom_path(self) -> Optional[pulumi.Input[str]]:
        """
        The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path as destination path.
        """
        return pulumi.get(self, "custom_path")

    @custom_path.setter
    def custom_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_path", value)

    @property
    @pulumi.getter(name="customQueryString")
    def custom_query_string(self) -> Optional[pulumi.Input[str]]:
        """
        The set of query strings to be placed in the redirect URL. Setting this value would replace any existing query string; leave empty to preserve the incoming query string. Query string must be in <key>=<value> format. ? and & will be added automatically so do not include them.
        """
        return pulumi.get(self, "custom_query_string")

    @custom_query_string.setter
    def custom_query_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_query_string", value)

    @property
    @pulumi.getter(name="destinationProtocol")
    def destination_protocol(self) -> Optional[pulumi.Input[Union[str, 'DestinationProtocol']]]:
        """
        Protocol to use for the redirect. The default value is MatchRequest
        """
        return pulumi.get(self, "destination_protocol")

    @destination_protocol.setter
    def destination_protocol(self, value: Optional[pulumi.Input[Union[str, 'DestinationProtocol']]]):
        pulumi.set(self, "destination_protocol", value)


@pulumi.input_type
class UrlRedirectActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['UrlRedirectActionParametersArgs']):
        """
        Defines the url redirect action for the delivery rule.
        :param pulumi.Input[str] name: The name of the action for the delivery rule.
               Expected value is 'UrlRedirect'.
        :param pulumi.Input['UrlRedirectActionParametersArgs'] parameters: Defines the parameters for the action.
        """
        UrlRedirectActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['UrlRedirectActionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'UrlRedirect')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the action for the delivery rule.
        Expected value is 'UrlRedirect'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['UrlRedirectActionParametersArgs']:
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['UrlRedirectActionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class UrlRewriteActionParametersArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 source_pattern: pulumi.Input[str],
                 type_name: pulumi.Input[str],
                 preserve_unmatched_path: Optional[pulumi.Input[bool]] = None):
        """
        Defines the parameters for the url rewrite action.
        :param pulumi.Input[str] destination: Define the relative URL to which the above requests will be rewritten by.
        :param pulumi.Input[str] source_pattern: define a request URI pattern that identifies the type of requests that may be rewritten. If value is blank, all strings are matched.
        :param pulumi.Input[bool] preserve_unmatched_path: Whether to preserve unmatched path. Default value is true.
        """
        UrlRewriteActionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            source_pattern=source_pattern,
            type_name=type_name,
            preserve_unmatched_path=preserve_unmatched_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             source_pattern: Optional[pulumi.Input[str]] = None,
             type_name: Optional[pulumi.Input[str]] = None,
             preserve_unmatched_path: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if destination is None:
            raise TypeError("Missing 'destination' argument")
        if source_pattern is None and 'sourcePattern' in kwargs:
            source_pattern = kwargs['sourcePattern']
        if source_pattern is None:
            raise TypeError("Missing 'source_pattern' argument")
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if preserve_unmatched_path is None and 'preserveUnmatchedPath' in kwargs:
            preserve_unmatched_path = kwargs['preserveUnmatchedPath']

        _setter("destination", destination)
        _setter("source_pattern", source_pattern)
        _setter("type_name", type_name)
        if preserve_unmatched_path is not None:
            _setter("preserve_unmatched_path", preserve_unmatched_path)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        Define the relative URL to which the above requests will be rewritten by.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="sourcePattern")
    def source_pattern(self) -> pulumi.Input[str]:
        """
        define a request URI pattern that identifies the type of requests that may be rewritten. If value is blank, all strings are matched.
        """
        return pulumi.get(self, "source_pattern")

    @source_pattern.setter
    def source_pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_pattern", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter(name="preserveUnmatchedPath")
    def preserve_unmatched_path(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to preserve unmatched path. Default value is true.
        """
        return pulumi.get(self, "preserve_unmatched_path")

    @preserve_unmatched_path.setter
    def preserve_unmatched_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_unmatched_path", value)


@pulumi.input_type
class UrlRewriteActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['UrlRewriteActionParametersArgs']):
        """
        Defines the url rewrite action for the delivery rule.
        :param pulumi.Input[str] name: The name of the action for the delivery rule.
               Expected value is 'UrlRewrite'.
        :param pulumi.Input['UrlRewriteActionParametersArgs'] parameters: Defines the parameters for the action.
        """
        UrlRewriteActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['UrlRewriteActionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'UrlRewrite')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the action for the delivery rule.
        Expected value is 'UrlRewrite'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['UrlRewriteActionParametersArgs']:
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['UrlRewriteActionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class UrlSigningActionParametersArgs:
    def __init__(__self__, *,
                 type_name: pulumi.Input[str],
                 algorithm: Optional[pulumi.Input[Union[str, 'Algorithm']]] = None,
                 parameter_name_override: Optional[pulumi.Input[Sequence[pulumi.Input['UrlSigningParamIdentifierArgs']]]] = None):
        """
        Defines the parameters for the Url Signing action.
        :param pulumi.Input[Union[str, 'Algorithm']] algorithm: Algorithm to use for URL signing
        :param pulumi.Input[Sequence[pulumi.Input['UrlSigningParamIdentifierArgs']]] parameter_name_override: Defines which query string parameters in the url to be considered for expires, key id etc. 
        """
        UrlSigningActionParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type_name=type_name,
            algorithm=algorithm,
            parameter_name_override=parameter_name_override,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type_name: Optional[pulumi.Input[str]] = None,
             algorithm: Optional[pulumi.Input[Union[str, 'Algorithm']]] = None,
             parameter_name_override: Optional[pulumi.Input[Sequence[pulumi.Input['UrlSigningParamIdentifierArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type_name is None and 'typeName' in kwargs:
            type_name = kwargs['typeName']
        if type_name is None:
            raise TypeError("Missing 'type_name' argument")
        if parameter_name_override is None and 'parameterNameOverride' in kwargs:
            parameter_name_override = kwargs['parameterNameOverride']

        _setter("type_name", type_name)
        if algorithm is not None:
            _setter("algorithm", algorithm)
        if parameter_name_override is not None:
            _setter("parameter_name_override", parameter_name_override)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[Union[str, 'Algorithm']]]:
        """
        Algorithm to use for URL signing
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[Union[str, 'Algorithm']]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="parameterNameOverride")
    def parameter_name_override(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UrlSigningParamIdentifierArgs']]]]:
        """
        Defines which query string parameters in the url to be considered for expires, key id etc. 
        """
        return pulumi.get(self, "parameter_name_override")

    @parameter_name_override.setter
    def parameter_name_override(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UrlSigningParamIdentifierArgs']]]]):
        pulumi.set(self, "parameter_name_override", value)


@pulumi.input_type
class UrlSigningActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input['UrlSigningActionParametersArgs']):
        """
        Defines the url signing action for the delivery rule.
        :param pulumi.Input[str] name: The name of the action for the delivery rule.
               Expected value is 'UrlSigning'.
        :param pulumi.Input['UrlSigningActionParametersArgs'] parameters: Defines the parameters for the action.
        """
        UrlSigningActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input['UrlSigningActionParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if parameters is None:
            raise TypeError("Missing 'parameters' argument")

        _setter("name", 'UrlSigning')
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the action for the delivery rule.
        Expected value is 'UrlSigning'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input['UrlSigningActionParametersArgs']:
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input['UrlSigningActionParametersArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class UrlSigningKeyParametersArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[str],
                 secret_source: pulumi.Input['ResourceReferenceArgs'],
                 type: pulumi.Input[str],
                 secret_version: Optional[pulumi.Input[str]] = None):
        """
        Url signing key parameters
        :param pulumi.Input[str] key_id: Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form the hash.
        :param pulumi.Input['ResourceReferenceArgs'] secret_source: Resource reference to the Azure Key Vault secret. Expected to be in format of /subscriptions/{​​​​​​​​​subscriptionId}​​​​​​​​​/resourceGroups/{​​​​​​​​​resourceGroupName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/providers/Microsoft.KeyVault/vaults/{vaultName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/secrets/{secretName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
        :param pulumi.Input[str] type: The type of the secret resource.
               Expected value is 'UrlSigningKey'.
        :param pulumi.Input[str] secret_version: Version of the secret to be used
        """
        UrlSigningKeyParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_id=key_id,
            secret_source=secret_source,
            type=type,
            secret_version=secret_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_id: Optional[pulumi.Input[str]] = None,
             secret_source: Optional[pulumi.Input['ResourceReferenceArgs']] = None,
             type: Optional[pulumi.Input[str]] = None,
             secret_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_id is None and 'keyId' in kwargs:
            key_id = kwargs['keyId']
        if key_id is None:
            raise TypeError("Missing 'key_id' argument")
        if secret_source is None and 'secretSource' in kwargs:
            secret_source = kwargs['secretSource']
        if secret_source is None:
            raise TypeError("Missing 'secret_source' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if secret_version is None and 'secretVersion' in kwargs:
            secret_version = kwargs['secretVersion']

        _setter("key_id", key_id)
        _setter("secret_source", secret_source)
        _setter("type", 'UrlSigningKey')
        if secret_version is not None:
            _setter("secret_version", secret_version)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[str]:
        """
        Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form the hash.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter(name="secretSource")
    def secret_source(self) -> pulumi.Input['ResourceReferenceArgs']:
        """
        Resource reference to the Azure Key Vault secret. Expected to be in format of /subscriptions/{​​​​​​​​​subscriptionId}​​​​​​​​​/resourceGroups/{​​​​​​​​​resourceGroupName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/providers/Microsoft.KeyVault/vaults/{vaultName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/secrets/{secretName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
        """
        return pulumi.get(self, "secret_source")

    @secret_source.setter
    def secret_source(self, value: pulumi.Input['ResourceReferenceArgs']):
        pulumi.set(self, "secret_source", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the secret resource.
        Expected value is 'UrlSigningKey'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the secret to be used
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_version", value)


@pulumi.input_type
class UrlSigningKeyArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[str],
                 key_source_parameters: pulumi.Input['KeyVaultSigningKeyParametersArgs']):
        """
        Url signing key
        :param pulumi.Input[str] key_id: Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form the hash.
        :param pulumi.Input['KeyVaultSigningKeyParametersArgs'] key_source_parameters: Defines the parameters for using customer key vault for Url Signing Key.
        """
        UrlSigningKeyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_id=key_id,
            key_source_parameters=key_source_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_id: Optional[pulumi.Input[str]] = None,
             key_source_parameters: Optional[pulumi.Input['KeyVaultSigningKeyParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_id is None and 'keyId' in kwargs:
            key_id = kwargs['keyId']
        if key_id is None:
            raise TypeError("Missing 'key_id' argument")
        if key_source_parameters is None and 'keySourceParameters' in kwargs:
            key_source_parameters = kwargs['keySourceParameters']
        if key_source_parameters is None:
            raise TypeError("Missing 'key_source_parameters' argument")

        _setter("key_id", key_id)
        _setter("key_source_parameters", key_source_parameters)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[str]:
        """
        Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form the hash.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter(name="keySourceParameters")
    def key_source_parameters(self) -> pulumi.Input['KeyVaultSigningKeyParametersArgs']:
        """
        Defines the parameters for using customer key vault for Url Signing Key.
        """
        return pulumi.get(self, "key_source_parameters")

    @key_source_parameters.setter
    def key_source_parameters(self, value: pulumi.Input['KeyVaultSigningKeyParametersArgs']):
        pulumi.set(self, "key_source_parameters", value)


@pulumi.input_type
class UrlSigningParamIdentifierArgs:
    def __init__(__self__, *,
                 param_indicator: pulumi.Input[Union[str, 'ParamIndicator']],
                 param_name: pulumi.Input[str]):
        """
        Defines how to identify a parameter for a specific purpose e.g. expires
        :param pulumi.Input[Union[str, 'ParamIndicator']] param_indicator: Indicates the purpose of the parameter
        :param pulumi.Input[str] param_name: Parameter name
        """
        UrlSigningParamIdentifierArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            param_indicator=param_indicator,
            param_name=param_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             param_indicator: Optional[pulumi.Input[Union[str, 'ParamIndicator']]] = None,
             param_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if param_indicator is None and 'paramIndicator' in kwargs:
            param_indicator = kwargs['paramIndicator']
        if param_indicator is None:
            raise TypeError("Missing 'param_indicator' argument")
        if param_name is None and 'paramName' in kwargs:
            param_name = kwargs['paramName']
        if param_name is None:
            raise TypeError("Missing 'param_name' argument")

        _setter("param_indicator", param_indicator)
        _setter("param_name", param_name)

    @property
    @pulumi.getter(name="paramIndicator")
    def param_indicator(self) -> pulumi.Input[Union[str, 'ParamIndicator']]:
        """
        Indicates the purpose of the parameter
        """
        return pulumi.get(self, "param_indicator")

    @param_indicator.setter
    def param_indicator(self, value: pulumi.Input[Union[str, 'ParamIndicator']]):
        pulumi.set(self, "param_indicator", value)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> pulumi.Input[str]:
        """
        Parameter name
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "param_name", value)


