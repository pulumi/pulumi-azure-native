# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'CompressionSettingsArgs',
    'HealthProbeParametersArgs',
    'HttpErrorRangeParametersArgs',
    'LoadBalancingSettingsParametersArgs',
    'ResourceReferenceArgs',
    'ResponseBasedOriginErrorDetectionParametersArgs',
    'SkuArgs',
]

@pulumi.input_type
class CompressionSettingsArgs:
    def __init__(__self__, *,
                 content_types_to_compress: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_compression_enabled: Optional[pulumi.Input[bool]] = None):
        """
        settings for compression.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] content_types_to_compress: List of content types on which compression applies. The value should be a valid MIME type.
        :param pulumi.Input[bool] is_compression_enabled: Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        """
        if content_types_to_compress is not None:
            pulumi.set(__self__, "content_types_to_compress", content_types_to_compress)
        if is_compression_enabled is not None:
            pulumi.set(__self__, "is_compression_enabled", is_compression_enabled)

    @property
    @pulumi.getter(name="contentTypesToCompress")
    def content_types_to_compress(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of content types on which compression applies. The value should be a valid MIME type.
        """
        return pulumi.get(self, "content_types_to_compress")

    @content_types_to_compress.setter
    def content_types_to_compress(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "content_types_to_compress", value)

    @property
    @pulumi.getter(name="isCompressionEnabled")
    def is_compression_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        """
        return pulumi.get(self, "is_compression_enabled")

    @is_compression_enabled.setter
    def is_compression_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_compression_enabled", value)


@pulumi.input_type
class HealthProbeParametersArgs:
    def __init__(__self__, *,
                 probe_interval_in_seconds: Optional[pulumi.Input[int]] = None,
                 probe_path: Optional[pulumi.Input[str]] = None,
                 probe_protocol: Optional[pulumi.Input['ProbeProtocol']] = None,
                 probe_request_type: Optional[pulumi.Input['HealthProbeRequestType']] = None):
        """
        The JSON object that contains the properties to send health probes to origin.
        :param pulumi.Input[int] probe_interval_in_seconds: The number of seconds between health probes.Default is 240sec.
        :param pulumi.Input[str] probe_path: The path relative to the origin that is used to determine the health of the origin.
        :param pulumi.Input['ProbeProtocol'] probe_protocol: Protocol to use for health probe.
        :param pulumi.Input['HealthProbeRequestType'] probe_request_type: The type of health probe request that is made.
        """
        if probe_interval_in_seconds is not None:
            pulumi.set(__self__, "probe_interval_in_seconds", probe_interval_in_seconds)
        if probe_path is not None:
            pulumi.set(__self__, "probe_path", probe_path)
        if probe_protocol is not None:
            pulumi.set(__self__, "probe_protocol", probe_protocol)
        if probe_request_type is not None:
            pulumi.set(__self__, "probe_request_type", probe_request_type)

    @property
    @pulumi.getter(name="probeIntervalInSeconds")
    def probe_interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds between health probes.Default is 240sec.
        """
        return pulumi.get(self, "probe_interval_in_seconds")

    @probe_interval_in_seconds.setter
    def probe_interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "probe_interval_in_seconds", value)

    @property
    @pulumi.getter(name="probePath")
    def probe_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path relative to the origin that is used to determine the health of the origin.
        """
        return pulumi.get(self, "probe_path")

    @probe_path.setter
    def probe_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "probe_path", value)

    @property
    @pulumi.getter(name="probeProtocol")
    def probe_protocol(self) -> Optional[pulumi.Input['ProbeProtocol']]:
        """
        Protocol to use for health probe.
        """
        return pulumi.get(self, "probe_protocol")

    @probe_protocol.setter
    def probe_protocol(self, value: Optional[pulumi.Input['ProbeProtocol']]):
        pulumi.set(self, "probe_protocol", value)

    @property
    @pulumi.getter(name="probeRequestType")
    def probe_request_type(self) -> Optional[pulumi.Input['HealthProbeRequestType']]:
        """
        The type of health probe request that is made.
        """
        return pulumi.get(self, "probe_request_type")

    @probe_request_type.setter
    def probe_request_type(self, value: Optional[pulumi.Input['HealthProbeRequestType']]):
        pulumi.set(self, "probe_request_type", value)


@pulumi.input_type
class HttpErrorRangeParametersArgs:
    def __init__(__self__, *,
                 begin: Optional[pulumi.Input[int]] = None,
                 end: Optional[pulumi.Input[int]] = None):
        """
        The JSON object that represents the range for http status codes
        :param pulumi.Input[int] begin: The inclusive start of the http status code range.
        :param pulumi.Input[int] end: The inclusive end of the http status code range.
        """
        if begin is not None:
            pulumi.set(__self__, "begin", begin)
        if end is not None:
            pulumi.set(__self__, "end", end)

    @property
    @pulumi.getter
    def begin(self) -> Optional[pulumi.Input[int]]:
        """
        The inclusive start of the http status code range.
        """
        return pulumi.get(self, "begin")

    @begin.setter
    def begin(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "begin", value)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[int]]:
        """
        The inclusive end of the http status code range.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end", value)


@pulumi.input_type
class LoadBalancingSettingsParametersArgs:
    def __init__(__self__, *,
                 additional_latency_in_milliseconds: Optional[pulumi.Input[int]] = None,
                 sample_size: Optional[pulumi.Input[int]] = None,
                 successful_samples_required: Optional[pulumi.Input[int]] = None):
        """
        Round-Robin load balancing settings for a backend pool
        :param pulumi.Input[int] additional_latency_in_milliseconds: The additional latency in milliseconds for probes to fall into the lowest latency bucket
        :param pulumi.Input[int] sample_size: The number of samples to consider for load balancing decisions
        :param pulumi.Input[int] successful_samples_required: The number of samples within the sample period that must succeed
        """
        if additional_latency_in_milliseconds is not None:
            pulumi.set(__self__, "additional_latency_in_milliseconds", additional_latency_in_milliseconds)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)
        if successful_samples_required is not None:
            pulumi.set(__self__, "successful_samples_required", successful_samples_required)

    @property
    @pulumi.getter(name="additionalLatencyInMilliseconds")
    def additional_latency_in_milliseconds(self) -> Optional[pulumi.Input[int]]:
        """
        The additional latency in milliseconds for probes to fall into the lowest latency bucket
        """
        return pulumi.get(self, "additional_latency_in_milliseconds")

    @additional_latency_in_milliseconds.setter
    def additional_latency_in_milliseconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "additional_latency_in_milliseconds", value)

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[pulumi.Input[int]]:
        """
        The number of samples to consider for load balancing decisions
        """
        return pulumi.get(self, "sample_size")

    @sample_size.setter
    def sample_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sample_size", value)

    @property
    @pulumi.getter(name="successfulSamplesRequired")
    def successful_samples_required(self) -> Optional[pulumi.Input[int]]:
        """
        The number of samples within the sample period that must succeed
        """
        return pulumi.get(self, "successful_samples_required")

    @successful_samples_required.setter
    def successful_samples_required(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "successful_samples_required", value)


@pulumi.input_type
class ResourceReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Reference to another resource.
        :param pulumi.Input[str] id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class ResponseBasedOriginErrorDetectionParametersArgs:
    def __init__(__self__, *,
                 http_error_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['HttpErrorRangeParametersArgs']]]] = None,
                 response_based_detected_error_types: Optional[pulumi.Input['ResponseBasedDetectedErrorTypes']] = None,
                 response_based_failover_threshold_percentage: Optional[pulumi.Input[int]] = None):
        """
        The JSON object that contains the properties to determine origin health using real requests/responses.
        :param pulumi.Input[Sequence[pulumi.Input['HttpErrorRangeParametersArgs']]] http_error_ranges: The list of Http status code ranges that are considered as server errors for origin and it is marked as unhealthy.
        :param pulumi.Input['ResponseBasedDetectedErrorTypes'] response_based_detected_error_types: Type of response errors for real user requests for which origin will be deemed unhealthy
        :param pulumi.Input[int] response_based_failover_threshold_percentage: The percentage of failed requests in the sample where failover should trigger.
        """
        if http_error_ranges is not None:
            pulumi.set(__self__, "http_error_ranges", http_error_ranges)
        if response_based_detected_error_types is not None:
            pulumi.set(__self__, "response_based_detected_error_types", response_based_detected_error_types)
        if response_based_failover_threshold_percentage is not None:
            pulumi.set(__self__, "response_based_failover_threshold_percentage", response_based_failover_threshold_percentage)

    @property
    @pulumi.getter(name="httpErrorRanges")
    def http_error_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpErrorRangeParametersArgs']]]]:
        """
        The list of Http status code ranges that are considered as server errors for origin and it is marked as unhealthy.
        """
        return pulumi.get(self, "http_error_ranges")

    @http_error_ranges.setter
    def http_error_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpErrorRangeParametersArgs']]]]):
        pulumi.set(self, "http_error_ranges", value)

    @property
    @pulumi.getter(name="responseBasedDetectedErrorTypes")
    def response_based_detected_error_types(self) -> Optional[pulumi.Input['ResponseBasedDetectedErrorTypes']]:
        """
        Type of response errors for real user requests for which origin will be deemed unhealthy
        """
        return pulumi.get(self, "response_based_detected_error_types")

    @response_based_detected_error_types.setter
    def response_based_detected_error_types(self, value: Optional[pulumi.Input['ResponseBasedDetectedErrorTypes']]):
        pulumi.set(self, "response_based_detected_error_types", value)

    @property
    @pulumi.getter(name="responseBasedFailoverThresholdPercentage")
    def response_based_failover_threshold_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        The percentage of failed requests in the sample where failover should trigger.
        """
        return pulumi.get(self, "response_based_failover_threshold_percentage")

    @response_based_failover_threshold_percentage.setter
    def response_based_failover_threshold_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "response_based_failover_threshold_percentage", value)


@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[Union[str, 'SkuName']]] = None):
        """
        The pricing tier (defines a CDN provider, feature list and rate) of the CDN profile.
        :param pulumi.Input[Union[str, 'SkuName']] name: Name of the pricing tier.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[Union[str, 'SkuName']]]:
        """
        Name of the pricing tier.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[Union[str, 'SkuName']]]):
        pulumi.set(self, "name", value)


