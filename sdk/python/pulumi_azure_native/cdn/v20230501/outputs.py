# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AFDDomainHttpsParametersResponse',
    'ActivatedResourceReferenceResponse',
    'AfdRouteCacheConfigurationResponse',
    'AzureFirstPartyManagedCertificateParametersResponse',
    'CacheConfigurationResponse',
    'CacheExpirationActionParametersResponse',
    'CacheKeyQueryStringActionParametersResponse',
    'CdnCertificateSourceParametersResponse',
    'CdnEndpointResponse',
    'CdnManagedHttpsParametersResponse',
    'ClientPortMatchConditionParametersResponse',
    'CompressionSettingsResponse',
    'CookiesMatchConditionParametersResponse',
    'CustomRuleListResponse',
    'CustomRuleResponse',
    'CustomerCertificateParametersResponse',
    'DeepCreatedCustomDomainResponse',
    'DeepCreatedOriginGroupResponse',
    'DeepCreatedOriginResponse',
    'DeliveryRuleCacheExpirationActionResponse',
    'DeliveryRuleCacheKeyQueryStringActionResponse',
    'DeliveryRuleClientPortConditionResponse',
    'DeliveryRuleCookiesConditionResponse',
    'DeliveryRuleHostNameConditionResponse',
    'DeliveryRuleHttpVersionConditionResponse',
    'DeliveryRuleIsDeviceConditionResponse',
    'DeliveryRulePostArgsConditionResponse',
    'DeliveryRuleQueryStringConditionResponse',
    'DeliveryRuleRemoteAddressConditionResponse',
    'DeliveryRuleRequestBodyConditionResponse',
    'DeliveryRuleRequestHeaderActionResponse',
    'DeliveryRuleRequestHeaderConditionResponse',
    'DeliveryRuleRequestMethodConditionResponse',
    'DeliveryRuleRequestSchemeConditionResponse',
    'DeliveryRuleRequestUriConditionResponse',
    'DeliveryRuleResponse',
    'DeliveryRuleResponseHeaderActionResponse',
    'DeliveryRuleRouteConfigurationOverrideActionResponse',
    'DeliveryRuleServerPortConditionResponse',
    'DeliveryRuleSocketAddrConditionResponse',
    'DeliveryRuleSslProtocolConditionResponse',
    'DeliveryRuleUrlFileExtensionConditionResponse',
    'DeliveryRuleUrlFileNameConditionResponse',
    'DeliveryRuleUrlPathConditionResponse',
    'DomainValidationPropertiesResponse',
    'EndpointPropertiesUpdateParametersResponseDeliveryPolicy',
    'EndpointPropertiesUpdateParametersResponseWebApplicationFirewallPolicyLink',
    'GeoFilterResponse',
    'HeaderActionParametersResponse',
    'HealthProbeParametersResponse',
    'HostNameMatchConditionParametersResponse',
    'HttpErrorRangeParametersResponse',
    'HttpVersionMatchConditionParametersResponse',
    'IsDeviceMatchConditionParametersResponse',
    'KeyVaultCertificateSourceParametersResponse',
    'KeyVaultSigningKeyParametersResponse',
    'LoadBalancingSettingsParametersResponse',
    'ManagedCertificateParametersResponse',
    'ManagedRuleGroupOverrideResponse',
    'ManagedRuleOverrideResponse',
    'ManagedRuleSetListResponse',
    'ManagedRuleSetResponse',
    'ManagedServiceIdentityResponse',
    'MatchConditionResponse',
    'OriginGroupOverrideActionParametersResponse',
    'OriginGroupOverrideActionResponse',
    'OriginGroupOverrideResponse',
    'PolicySettingsResponse',
    'PostArgsMatchConditionParametersResponse',
    'QueryStringMatchConditionParametersResponse',
    'RateLimitRuleListResponse',
    'RateLimitRuleResponse',
    'RemoteAddressMatchConditionParametersResponse',
    'RequestBodyMatchConditionParametersResponse',
    'RequestHeaderMatchConditionParametersResponse',
    'RequestMethodMatchConditionParametersResponse',
    'RequestSchemeMatchConditionParametersResponse',
    'RequestUriMatchConditionParametersResponse',
    'ResourceReferenceResponse',
    'ResponseBasedOriginErrorDetectionParametersResponse',
    'RouteConfigurationOverrideActionParametersResponse',
    'SecurityPolicyWebApplicationFirewallAssociationResponse',
    'SecurityPolicyWebApplicationFirewallParametersResponse',
    'ServerPortMatchConditionParametersResponse',
    'SharedPrivateLinkResourcePropertiesResponse',
    'SkuResponse',
    'SocketAddrMatchConditionParametersResponse',
    'SslProtocolMatchConditionParametersResponse',
    'SystemDataResponse',
    'UrlFileExtensionMatchConditionParametersResponse',
    'UrlFileNameMatchConditionParametersResponse',
    'UrlPathMatchConditionParametersResponse',
    'UrlRedirectActionParametersResponse',
    'UrlRedirectActionResponse',
    'UrlRewriteActionParametersResponse',
    'UrlRewriteActionResponse',
    'UrlSigningActionParametersResponse',
    'UrlSigningActionResponse',
    'UrlSigningKeyParametersResponse',
    'UrlSigningKeyResponse',
    'UrlSigningParamIdentifierResponse',
    'UserAssignedIdentityResponse',
    'UserManagedHttpsParametersResponse',
]

@pulumi.output_type
class AFDDomainHttpsParametersResponse(dict):
    """
    The JSON object that contains the properties to secure a domain.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateType":
            suggest = "certificate_type"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AFDDomainHttpsParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AFDDomainHttpsParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AFDDomainHttpsParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_type: str,
                 minimum_tls_version: Optional[str] = None,
                 secret: Optional['outputs.ResourceReferenceResponse'] = None):
        """
        The JSON object that contains the properties to secure a domain.
        :param str certificate_type: Defines the source of the SSL certificate.
        :param str minimum_tls_version: TLS protocol version that will be used for Https
        :param 'ResourceReferenceResponse' secret: Resource reference to the secret. ie. subs/rg/profile/secret
        """
        pulumi.set(__self__, "certificate_type", certificate_type)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> str:
        """
        Defines the source of the SSL certificate.
        """
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        TLS protocol version that will be used for Https
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ResourceReferenceResponse']:
        """
        Resource reference to the secret. ie. subs/rg/profile/secret
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ActivatedResourceReferenceResponse(dict):
    """
    Reference to another resource along with its state.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isActive":
            suggest = "is_active"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActivatedResourceReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActivatedResourceReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActivatedResourceReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_active: bool,
                 id: Optional[str] = None):
        """
        Reference to another resource along with its state.
        :param bool is_active: Whether the resource is active or inactive
        :param str id: Resource ID.
        """
        pulumi.set(__self__, "is_active", is_active)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> bool:
        """
        Whether the resource is active or inactive
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class AfdRouteCacheConfigurationResponse(dict):
    """
    Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionSettings":
            suggest = "compression_settings"
        elif key == "queryParameters":
            suggest = "query_parameters"
        elif key == "queryStringCachingBehavior":
            suggest = "query_string_caching_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AfdRouteCacheConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AfdRouteCacheConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AfdRouteCacheConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_settings: Optional['outputs.CompressionSettingsResponse'] = None,
                 query_parameters: Optional[str] = None,
                 query_string_caching_behavior: Optional[str] = None):
        """
        Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
        :param 'CompressionSettingsResponse' compression_settings: compression settings.
        :param str query_parameters: query parameters to include or exclude (comma separated).
        :param str query_string_caching_behavior: Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
        """
        if compression_settings is not None:
            pulumi.set(__self__, "compression_settings", compression_settings)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if query_string_caching_behavior is not None:
            pulumi.set(__self__, "query_string_caching_behavior", query_string_caching_behavior)

    @property
    @pulumi.getter(name="compressionSettings")
    def compression_settings(self) -> Optional['outputs.CompressionSettingsResponse']:
        """
        compression settings.
        """
        return pulumi.get(self, "compression_settings")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[str]:
        """
        query parameters to include or exclude (comma separated).
        """
        return pulumi.get(self, "query_parameters")

    @property
    @pulumi.getter(name="queryStringCachingBehavior")
    def query_string_caching_behavior(self) -> Optional[str]:
        """
        Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
        """
        return pulumi.get(self, "query_string_caching_behavior")


@pulumi.output_type
class AzureFirstPartyManagedCertificateParametersResponse(dict):
    """
    Azure FirstParty Managed Certificate provided by other first party resource providers to enable HTTPS.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "expirationDate":
            suggest = "expiration_date"
        elif key == "secretSource":
            suggest = "secret_source"
        elif key == "subjectAlternativeNames":
            suggest = "subject_alternative_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFirstPartyManagedCertificateParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFirstPartyManagedCertificateParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFirstPartyManagedCertificateParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_authority: str,
                 expiration_date: str,
                 secret_source: 'outputs.ResourceReferenceResponse',
                 subject: str,
                 thumbprint: str,
                 type: str,
                 subject_alternative_names: Optional[Sequence[str]] = None):
        """
        Azure FirstParty Managed Certificate provided by other first party resource providers to enable HTTPS.
        :param str certificate_authority: Certificate issuing authority.
        :param str expiration_date: Certificate expiration date.
        :param 'ResourceReferenceResponse' secret_source: Resource reference to the Azure Key Vault certificate. Expected to be in format of /subscriptions/{​​​​​​​​​subscriptionId}​​​​​​​​​/resourceGroups/{​​​​​​​​​resourceGroupName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/providers/Microsoft.KeyVault/vaults/{vaultName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/secrets/{certificateName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
        :param str subject: Subject name in the certificate.
        :param str thumbprint: Certificate thumbprint.
        :param str type: The type of the secret resource.
               Expected value is 'AzureFirstPartyManagedCertificate'.
        :param Sequence[str] subject_alternative_names: The list of SANs.
        """
        pulumi.set(__self__, "certificate_authority", certificate_authority)
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "secret_source", secret_source)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "thumbprint", thumbprint)
        pulumi.set(__self__, "type", 'AzureFirstPartyManagedCertificate')
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> str:
        """
        Certificate issuing authority.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> str:
        """
        Certificate expiration date.
        """
        return pulumi.get(self, "expiration_date")

    @property
    @pulumi.getter(name="secretSource")
    def secret_source(self) -> 'outputs.ResourceReferenceResponse':
        """
        Resource reference to the Azure Key Vault certificate. Expected to be in format of /subscriptions/{​​​​​​​​​subscriptionId}​​​​​​​​​/resourceGroups/{​​​​​​​​​resourceGroupName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/providers/Microsoft.KeyVault/vaults/{vaultName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/secrets/{certificateName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
        """
        return pulumi.get(self, "secret_source")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        Subject name in the certificate.
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        """
        Certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the secret resource.
        Expected value is 'AzureFirstPartyManagedCertificate'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[Sequence[str]]:
        """
        The list of SANs.
        """
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class CacheConfigurationResponse(dict):
    """
    Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheBehavior":
            suggest = "cache_behavior"
        elif key == "cacheDuration":
            suggest = "cache_duration"
        elif key == "isCompressionEnabled":
            suggest = "is_compression_enabled"
        elif key == "queryParameters":
            suggest = "query_parameters"
        elif key == "queryStringCachingBehavior":
            suggest = "query_string_caching_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_behavior: Optional[str] = None,
                 cache_duration: Optional[str] = None,
                 is_compression_enabled: Optional[str] = None,
                 query_parameters: Optional[str] = None,
                 query_string_caching_behavior: Optional[str] = None):
        """
        Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
        :param str cache_behavior: Caching behavior for the requests
        :param str cache_duration: The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
        :param str is_compression_enabled: Indicates whether content compression is enabled. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        :param str query_parameters: query parameters to include or exclude (comma separated).
        :param str query_string_caching_behavior: Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
        """
        if cache_behavior is not None:
            pulumi.set(__self__, "cache_behavior", cache_behavior)
        if cache_duration is not None:
            pulumi.set(__self__, "cache_duration", cache_duration)
        if is_compression_enabled is not None:
            pulumi.set(__self__, "is_compression_enabled", is_compression_enabled)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if query_string_caching_behavior is not None:
            pulumi.set(__self__, "query_string_caching_behavior", query_string_caching_behavior)

    @property
    @pulumi.getter(name="cacheBehavior")
    def cache_behavior(self) -> Optional[str]:
        """
        Caching behavior for the requests
        """
        return pulumi.get(self, "cache_behavior")

    @property
    @pulumi.getter(name="cacheDuration")
    def cache_duration(self) -> Optional[str]:
        """
        The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
        """
        return pulumi.get(self, "cache_duration")

    @property
    @pulumi.getter(name="isCompressionEnabled")
    def is_compression_enabled(self) -> Optional[str]:
        """
        Indicates whether content compression is enabled. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        """
        return pulumi.get(self, "is_compression_enabled")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[str]:
        """
        query parameters to include or exclude (comma separated).
        """
        return pulumi.get(self, "query_parameters")

    @property
    @pulumi.getter(name="queryStringCachingBehavior")
    def query_string_caching_behavior(self) -> Optional[str]:
        """
        Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
        """
        return pulumi.get(self, "query_string_caching_behavior")


@pulumi.output_type
class CacheExpirationActionParametersResponse(dict):
    """
    Defines the parameters for the cache expiration action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheBehavior":
            suggest = "cache_behavior"
        elif key == "cacheType":
            suggest = "cache_type"
        elif key == "typeName":
            suggest = "type_name"
        elif key == "cacheDuration":
            suggest = "cache_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheExpirationActionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheExpirationActionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheExpirationActionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_behavior: str,
                 cache_type: str,
                 type_name: str,
                 cache_duration: Optional[str] = None):
        """
        Defines the parameters for the cache expiration action.
        :param str cache_behavior: Caching behavior for the requests
        :param str cache_type: The level at which the content needs to be cached.
        :param str cache_duration: The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
        """
        pulumi.set(__self__, "cache_behavior", cache_behavior)
        pulumi.set(__self__, "cache_type", cache_type)
        pulumi.set(__self__, "type_name", type_name)
        if cache_duration is not None:
            pulumi.set(__self__, "cache_duration", cache_duration)

    @property
    @pulumi.getter(name="cacheBehavior")
    def cache_behavior(self) -> str:
        """
        Caching behavior for the requests
        """
        return pulumi.get(self, "cache_behavior")

    @property
    @pulumi.getter(name="cacheType")
    def cache_type(self) -> str:
        """
        The level at which the content needs to be cached.
        """
        return pulumi.get(self, "cache_type")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="cacheDuration")
    def cache_duration(self) -> Optional[str]:
        """
        The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
        """
        return pulumi.get(self, "cache_duration")


@pulumi.output_type
class CacheKeyQueryStringActionParametersResponse(dict):
    """
    Defines the parameters for the cache-key query string action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryStringBehavior":
            suggest = "query_string_behavior"
        elif key == "typeName":
            suggest = "type_name"
        elif key == "queryParameters":
            suggest = "query_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheKeyQueryStringActionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheKeyQueryStringActionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheKeyQueryStringActionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_string_behavior: str,
                 type_name: str,
                 query_parameters: Optional[str] = None):
        """
        Defines the parameters for the cache-key query string action.
        :param str query_string_behavior: Caching behavior for the requests
        :param str query_parameters: query parameters to include or exclude (comma separated).
        """
        pulumi.set(__self__, "query_string_behavior", query_string_behavior)
        pulumi.set(__self__, "type_name", type_name)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)

    @property
    @pulumi.getter(name="queryStringBehavior")
    def query_string_behavior(self) -> str:
        """
        Caching behavior for the requests
        """
        return pulumi.get(self, "query_string_behavior")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[str]:
        """
        query parameters to include or exclude (comma separated).
        """
        return pulumi.get(self, "query_parameters")


@pulumi.output_type
class CdnCertificateSourceParametersResponse(dict):
    """
    Defines the parameters for using CDN managed certificate for securing custom domain.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateType":
            suggest = "certificate_type"
        elif key == "typeName":
            suggest = "type_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CdnCertificateSourceParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CdnCertificateSourceParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CdnCertificateSourceParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_type: str,
                 type_name: str):
        """
        Defines the parameters for using CDN managed certificate for securing custom domain.
        :param str certificate_type: Type of certificate used
        """
        pulumi.set(__self__, "certificate_type", certificate_type)
        pulumi.set(__self__, "type_name", type_name)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> str:
        """
        Type of certificate used
        """
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")


@pulumi.output_type
class CdnEndpointResponse(dict):
    """
    Defines the ARM Resource ID for the linked endpoints
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Defines the ARM Resource ID for the linked endpoints
        :param str id: ARM Resource ID string.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ARM Resource ID string.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CdnManagedHttpsParametersResponse(dict):
    """
    Defines the certificate source parameters using CDN managed certificate for enabling SSL.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateSource":
            suggest = "certificate_source"
        elif key == "certificateSourceParameters":
            suggest = "certificate_source_parameters"
        elif key == "protocolType":
            suggest = "protocol_type"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CdnManagedHttpsParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CdnManagedHttpsParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CdnManagedHttpsParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_source: str,
                 certificate_source_parameters: 'outputs.CdnCertificateSourceParametersResponse',
                 protocol_type: str,
                 minimum_tls_version: Optional[str] = None):
        """
        Defines the certificate source parameters using CDN managed certificate for enabling SSL.
        :param str certificate_source: Defines the source of the SSL certificate.
               Expected value is 'Cdn'.
        :param 'CdnCertificateSourceParametersResponse' certificate_source_parameters: Defines the certificate source parameters using CDN managed certificate for enabling SSL.
        :param str protocol_type: Defines the TLS extension protocol that is used for secure delivery.
        :param str minimum_tls_version: TLS protocol version that will be used for Https
        """
        pulumi.set(__self__, "certificate_source", 'Cdn')
        pulumi.set(__self__, "certificate_source_parameters", certificate_source_parameters)
        pulumi.set(__self__, "protocol_type", protocol_type)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)

    @property
    @pulumi.getter(name="certificateSource")
    def certificate_source(self) -> str:
        """
        Defines the source of the SSL certificate.
        Expected value is 'Cdn'.
        """
        return pulumi.get(self, "certificate_source")

    @property
    @pulumi.getter(name="certificateSourceParameters")
    def certificate_source_parameters(self) -> 'outputs.CdnCertificateSourceParametersResponse':
        """
        Defines the certificate source parameters using CDN managed certificate for enabling SSL.
        """
        return pulumi.get(self, "certificate_source_parameters")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> str:
        """
        Defines the TLS extension protocol that is used for secure delivery.
        """
        return pulumi.get(self, "protocol_type")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        TLS protocol version that will be used for Https
        """
        return pulumi.get(self, "minimum_tls_version")


@pulumi.output_type
class ClientPortMatchConditionParametersResponse(dict):
    """
    Defines the parameters for ClientPort match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientPortMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientPortMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientPortMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for ClientPort match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class CompressionSettingsResponse(dict):
    """
    settings for compression.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentTypesToCompress":
            suggest = "content_types_to_compress"
        elif key == "isCompressionEnabled":
            suggest = "is_compression_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CompressionSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CompressionSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CompressionSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_types_to_compress: Optional[Sequence[str]] = None,
                 is_compression_enabled: Optional[bool] = None):
        """
        settings for compression.
        :param Sequence[str] content_types_to_compress: List of content types on which compression applies. The value should be a valid MIME type.
        :param bool is_compression_enabled: Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        """
        if content_types_to_compress is not None:
            pulumi.set(__self__, "content_types_to_compress", content_types_to_compress)
        if is_compression_enabled is not None:
            pulumi.set(__self__, "is_compression_enabled", is_compression_enabled)

    @property
    @pulumi.getter(name="contentTypesToCompress")
    def content_types_to_compress(self) -> Optional[Sequence[str]]:
        """
        List of content types on which compression applies. The value should be a valid MIME type.
        """
        return pulumi.get(self, "content_types_to_compress")

    @property
    @pulumi.getter(name="isCompressionEnabled")
    def is_compression_enabled(self) -> Optional[bool]:
        """
        Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        """
        return pulumi.get(self, "is_compression_enabled")


@pulumi.output_type
class CookiesMatchConditionParametersResponse(dict):
    """
    Defines the parameters for Cookies match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CookiesMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CookiesMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CookiesMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 selector: Optional[str] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for Cookies match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param str selector: Name of Cookies to be matched
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        """
        Name of Cookies to be matched
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class CustomRuleListResponse(dict):
    """
    Defines contents of custom rules
    """
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.CustomRuleResponse']] = None):
        """
        Defines contents of custom rules
        :param Sequence['CustomRuleResponse'] rules: List of rules
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.CustomRuleResponse']]:
        """
        List of rules
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class CustomRuleResponse(dict):
    """
    Defines the common attributes for a custom rule that can be included in a waf policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchConditions":
            suggest = "match_conditions"
        elif key == "enabledState":
            suggest = "enabled_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 match_conditions: Sequence['outputs.MatchConditionResponse'],
                 name: str,
                 priority: int,
                 enabled_state: Optional[str] = None):
        """
        Defines the common attributes for a custom rule that can be included in a waf policy
        :param str action: Describes what action to be applied when rule matches
        :param Sequence['MatchConditionResponse'] match_conditions: List of match conditions.
        :param str name: Defines the name of the custom rule
        :param int priority: Defines in what order this rule be evaluated in the overall list of custom rules
        :param str enabled_state: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match_conditions", match_conditions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        if enabled_state is not None:
            pulumi.set(__self__, "enabled_state", enabled_state)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Describes what action to be applied when rule matches
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Sequence['outputs.MatchConditionResponse']:
        """
        List of match conditions.
        """
        return pulumi.get(self, "match_conditions")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Defines the name of the custom rule
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Defines in what order this rule be evaluated in the overall list of custom rules
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[str]:
        """
        Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
        """
        return pulumi.get(self, "enabled_state")


@pulumi.output_type
class CustomerCertificateParametersResponse(dict):
    """
    Customer Certificate used for https
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateAuthority":
            suggest = "certificate_authority"
        elif key == "expirationDate":
            suggest = "expiration_date"
        elif key == "secretSource":
            suggest = "secret_source"
        elif key == "secretVersion":
            suggest = "secret_version"
        elif key == "subjectAlternativeNames":
            suggest = "subject_alternative_names"
        elif key == "useLatestVersion":
            suggest = "use_latest_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomerCertificateParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomerCertificateParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomerCertificateParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_authority: str,
                 expiration_date: str,
                 secret_source: 'outputs.ResourceReferenceResponse',
                 subject: str,
                 thumbprint: str,
                 type: str,
                 secret_version: Optional[str] = None,
                 subject_alternative_names: Optional[Sequence[str]] = None,
                 use_latest_version: Optional[bool] = None):
        """
        Customer Certificate used for https
        :param str certificate_authority: Certificate issuing authority.
        :param str expiration_date: Certificate expiration date.
        :param 'ResourceReferenceResponse' secret_source: Resource reference to the Azure Key Vault certificate. Expected to be in format of /subscriptions/{​​​​​​​​​subscriptionId}​​​​​​​​​/resourceGroups/{​​​​​​​​​resourceGroupName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/providers/Microsoft.KeyVault/vaults/{vaultName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/secrets/{certificateName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
        :param str subject: Subject name in the certificate.
        :param str thumbprint: Certificate thumbprint.
        :param str type: The type of the secret resource.
               Expected value is 'CustomerCertificate'.
        :param str secret_version: Version of the secret to be used
        :param Sequence[str] subject_alternative_names: The list of SANs.
        :param bool use_latest_version: Whether to use the latest version for the certificate
        """
        pulumi.set(__self__, "certificate_authority", certificate_authority)
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "secret_source", secret_source)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "thumbprint", thumbprint)
        pulumi.set(__self__, "type", 'CustomerCertificate')
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)
        if use_latest_version is not None:
            pulumi.set(__self__, "use_latest_version", use_latest_version)

    @property
    @pulumi.getter(name="certificateAuthority")
    def certificate_authority(self) -> str:
        """
        Certificate issuing authority.
        """
        return pulumi.get(self, "certificate_authority")

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> str:
        """
        Certificate expiration date.
        """
        return pulumi.get(self, "expiration_date")

    @property
    @pulumi.getter(name="secretSource")
    def secret_source(self) -> 'outputs.ResourceReferenceResponse':
        """
        Resource reference to the Azure Key Vault certificate. Expected to be in format of /subscriptions/{​​​​​​​​​subscriptionId}​​​​​​​​​/resourceGroups/{​​​​​​​​​resourceGroupName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/providers/Microsoft.KeyVault/vaults/{vaultName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/secrets/{certificateName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
        """
        return pulumi.get(self, "secret_source")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        Subject name in the certificate.
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter
    def thumbprint(self) -> str:
        """
        Certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the secret resource.
        Expected value is 'CustomerCertificate'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[str]:
        """
        Version of the secret to be used
        """
        return pulumi.get(self, "secret_version")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[Sequence[str]]:
        """
        The list of SANs.
        """
        return pulumi.get(self, "subject_alternative_names")

    @property
    @pulumi.getter(name="useLatestVersion")
    def use_latest_version(self) -> Optional[bool]:
        """
        Whether to use the latest version for the certificate
        """
        return pulumi.get(self, "use_latest_version")


@pulumi.output_type
class DeepCreatedCustomDomainResponse(dict):
    """
    Custom domains created on the CDN endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"
        elif key == "validationData":
            suggest = "validation_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeepCreatedCustomDomainResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeepCreatedCustomDomainResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeepCreatedCustomDomainResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_name: str,
                 name: str,
                 validation_data: Optional[str] = None):
        """
        Custom domains created on the CDN endpoint.
        :param str host_name: The host name of the custom domain. Must be a domain name.
        :param str name: Custom domain name.
        :param str validation_data: Special validation or data may be required when delivering CDN to some regions due to local compliance reasons. E.g. ICP license number of a custom domain is required to deliver content in China.
        """
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "name", name)
        if validation_data is not None:
            pulumi.set(__self__, "validation_data", validation_data)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> str:
        """
        The host name of the custom domain. Must be a domain name.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Custom domain name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="validationData")
    def validation_data(self) -> Optional[str]:
        """
        Special validation or data may be required when delivering CDN to some regions due to local compliance reasons. E.g. ICP license number of a custom domain is required to deliver content in China.
        """
        return pulumi.get(self, "validation_data")


@pulumi.output_type
class DeepCreatedOriginGroupResponse(dict):
    """
    The origin group for CDN content which is added when creating a CDN endpoint. Traffic is sent to the origins within the origin group based on origin health.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "healthProbeSettings":
            suggest = "health_probe_settings"
        elif key == "responseBasedOriginErrorDetectionSettings":
            suggest = "response_based_origin_error_detection_settings"
        elif key == "trafficRestorationTimeToHealedOrNewEndpointsInMinutes":
            suggest = "traffic_restoration_time_to_healed_or_new_endpoints_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeepCreatedOriginGroupResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeepCreatedOriginGroupResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeepCreatedOriginGroupResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 origins: Sequence['outputs.ResourceReferenceResponse'],
                 health_probe_settings: Optional['outputs.HealthProbeParametersResponse'] = None,
                 response_based_origin_error_detection_settings: Optional['outputs.ResponseBasedOriginErrorDetectionParametersResponse'] = None,
                 traffic_restoration_time_to_healed_or_new_endpoints_in_minutes: Optional[int] = None):
        """
        The origin group for CDN content which is added when creating a CDN endpoint. Traffic is sent to the origins within the origin group based on origin health.
        :param str name: Origin group name which must be unique within the endpoint.
        :param Sequence['ResourceReferenceResponse'] origins: The source of the content being delivered via CDN within given origin group.
        :param 'HealthProbeParametersResponse' health_probe_settings: Health probe settings to the origin that is used to determine the health of the origin.
        :param 'ResponseBasedOriginErrorDetectionParametersResponse' response_based_origin_error_detection_settings: The JSON object that contains the properties to determine origin health using real requests/responses.This property is currently not supported.
        :param int traffic_restoration_time_to_healed_or_new_endpoints_in_minutes: Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not supported.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "origins", origins)
        if health_probe_settings is not None:
            pulumi.set(__self__, "health_probe_settings", health_probe_settings)
        if response_based_origin_error_detection_settings is not None:
            pulumi.set(__self__, "response_based_origin_error_detection_settings", response_based_origin_error_detection_settings)
        if traffic_restoration_time_to_healed_or_new_endpoints_in_minutes is not None:
            pulumi.set(__self__, "traffic_restoration_time_to_healed_or_new_endpoints_in_minutes", traffic_restoration_time_to_healed_or_new_endpoints_in_minutes)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Origin group name which must be unique within the endpoint.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def origins(self) -> Sequence['outputs.ResourceReferenceResponse']:
        """
        The source of the content being delivered via CDN within given origin group.
        """
        return pulumi.get(self, "origins")

    @property
    @pulumi.getter(name="healthProbeSettings")
    def health_probe_settings(self) -> Optional['outputs.HealthProbeParametersResponse']:
        """
        Health probe settings to the origin that is used to determine the health of the origin.
        """
        return pulumi.get(self, "health_probe_settings")

    @property
    @pulumi.getter(name="responseBasedOriginErrorDetectionSettings")
    def response_based_origin_error_detection_settings(self) -> Optional['outputs.ResponseBasedOriginErrorDetectionParametersResponse']:
        """
        The JSON object that contains the properties to determine origin health using real requests/responses.This property is currently not supported.
        """
        return pulumi.get(self, "response_based_origin_error_detection_settings")

    @property
    @pulumi.getter(name="trafficRestorationTimeToHealedOrNewEndpointsInMinutes")
    def traffic_restoration_time_to_healed_or_new_endpoints_in_minutes(self) -> Optional[int]:
        """
        Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not supported.
        """
        return pulumi.get(self, "traffic_restoration_time_to_healed_or_new_endpoints_in_minutes")


@pulumi.output_type
class DeepCreatedOriginResponse(dict):
    """
    The main origin of CDN content which is added when creating a CDN endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"
        elif key == "privateEndpointStatus":
            suggest = "private_endpoint_status"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "originHostHeader":
            suggest = "origin_host_header"
        elif key == "privateLinkAlias":
            suggest = "private_link_alias"
        elif key == "privateLinkApprovalMessage":
            suggest = "private_link_approval_message"
        elif key == "privateLinkLocation":
            suggest = "private_link_location"
        elif key == "privateLinkResourceId":
            suggest = "private_link_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeepCreatedOriginResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeepCreatedOriginResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeepCreatedOriginResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_name: str,
                 name: str,
                 private_endpoint_status: str,
                 enabled: Optional[bool] = None,
                 http_port: Optional[int] = None,
                 https_port: Optional[int] = None,
                 origin_host_header: Optional[str] = None,
                 priority: Optional[int] = None,
                 private_link_alias: Optional[str] = None,
                 private_link_approval_message: Optional[str] = None,
                 private_link_location: Optional[str] = None,
                 private_link_resource_id: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        The main origin of CDN content which is added when creating a CDN endpoint.
        :param str host_name: The address of the origin. It can be a domain name, IPv4 address, or IPv6 address. This should be unique across all origins in an endpoint.
        :param str name: Origin name which must be unique within the endpoint. 
        :param str private_endpoint_status: The approval status for the connection to the Private Link
        :param bool enabled: Origin is enabled for load balancing or not. By default, origin is always enabled.
        :param int http_port: The value of the HTTP port. Must be between 1 and 65535.
        :param int https_port: The value of the HTTPS port. Must be between 1 and 65535.
        :param str origin_host_header: The host header value sent to the origin with each request. If you leave this blank, the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host header value to match the origin hostname by default.
        :param int priority: Priority of origin in given origin group for load balancing. Higher priorities will not be used for load balancing if any lower priority origin is healthy.Must be between 1 and 5.
        :param str private_link_alias: The Alias of the Private Link resource. Populating this optional field indicates that this origin is 'Private'
        :param str private_link_approval_message: A custom message to be included in the approval request to connect to the Private Link.
        :param str private_link_location: The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
        :param str private_link_resource_id: The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
        :param int weight: Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
        """
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_endpoint_status", private_endpoint_status)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if origin_host_header is not None:
            pulumi.set(__self__, "origin_host_header", origin_host_header)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if private_link_alias is not None:
            pulumi.set(__self__, "private_link_alias", private_link_alias)
        if private_link_approval_message is not None:
            pulumi.set(__self__, "private_link_approval_message", private_link_approval_message)
        if private_link_location is not None:
            pulumi.set(__self__, "private_link_location", private_link_location)
        if private_link_resource_id is not None:
            pulumi.set(__self__, "private_link_resource_id", private_link_resource_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> str:
        """
        The address of the origin. It can be a domain name, IPv4 address, or IPv6 address. This should be unique across all origins in an endpoint.
        """
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Origin name which must be unique within the endpoint. 
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateEndpointStatus")
    def private_endpoint_status(self) -> str:
        """
        The approval status for the connection to the Private Link
        """
        return pulumi.get(self, "private_endpoint_status")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Origin is enabled for load balancing or not. By default, origin is always enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[int]:
        """
        The value of the HTTP port. Must be between 1 and 65535.
        """
        return pulumi.get(self, "http_port")

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[int]:
        """
        The value of the HTTPS port. Must be between 1 and 65535.
        """
        return pulumi.get(self, "https_port")

    @property
    @pulumi.getter(name="originHostHeader")
    def origin_host_header(self) -> Optional[str]:
        """
        The host header value sent to the origin with each request. If you leave this blank, the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host header value to match the origin hostname by default.
        """
        return pulumi.get(self, "origin_host_header")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Priority of origin in given origin group for load balancing. Higher priorities will not be used for load balancing if any lower priority origin is healthy.Must be between 1 and 5.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="privateLinkAlias")
    def private_link_alias(self) -> Optional[str]:
        """
        The Alias of the Private Link resource. Populating this optional field indicates that this origin is 'Private'
        """
        return pulumi.get(self, "private_link_alias")

    @property
    @pulumi.getter(name="privateLinkApprovalMessage")
    def private_link_approval_message(self) -> Optional[str]:
        """
        A custom message to be included in the approval request to connect to the Private Link.
        """
        return pulumi.get(self, "private_link_approval_message")

    @property
    @pulumi.getter(name="privateLinkLocation")
    def private_link_location(self) -> Optional[str]:
        """
        The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
        """
        return pulumi.get(self, "private_link_location")

    @property
    @pulumi.getter(name="privateLinkResourceId")
    def private_link_resource_id(self) -> Optional[str]:
        """
        The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
        """
        return pulumi.get(self, "private_link_resource_id")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class DeliveryRuleCacheExpirationActionResponse(dict):
    """
    Defines the cache expiration action for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.CacheExpirationActionParametersResponse'):
        """
        Defines the cache expiration action for the delivery rule.
        :param str name: The name of the action for the delivery rule.
               Expected value is 'CacheExpiration'.
        :param 'CacheExpirationActionParametersResponse' parameters: Defines the parameters for the action.
        """
        pulumi.set(__self__, "name", 'CacheExpiration')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the action for the delivery rule.
        Expected value is 'CacheExpiration'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.CacheExpirationActionParametersResponse':
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleCacheKeyQueryStringActionResponse(dict):
    """
    Defines the cache-key query string action for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.CacheKeyQueryStringActionParametersResponse'):
        """
        Defines the cache-key query string action for the delivery rule.
        :param str name: The name of the action for the delivery rule.
               Expected value is 'CacheKeyQueryString'.
        :param 'CacheKeyQueryStringActionParametersResponse' parameters: Defines the parameters for the action.
        """
        pulumi.set(__self__, "name", 'CacheKeyQueryString')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the action for the delivery rule.
        Expected value is 'CacheKeyQueryString'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.CacheKeyQueryStringActionParametersResponse':
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleClientPortConditionResponse(dict):
    """
    Defines the ClientPort condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.ClientPortMatchConditionParametersResponse'):
        """
        Defines the ClientPort condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'ClientPort'.
        :param 'ClientPortMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'ClientPort')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'ClientPort'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.ClientPortMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleCookiesConditionResponse(dict):
    """
    Defines the Cookies condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.CookiesMatchConditionParametersResponse'):
        """
        Defines the Cookies condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'Cookies'.
        :param 'CookiesMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'Cookies')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'Cookies'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.CookiesMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleHostNameConditionResponse(dict):
    """
    Defines the HostName condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.HostNameMatchConditionParametersResponse'):
        """
        Defines the HostName condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'HostName'.
        :param 'HostNameMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'HostName')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'HostName'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.HostNameMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleHttpVersionConditionResponse(dict):
    """
    Defines the HttpVersion condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.HttpVersionMatchConditionParametersResponse'):
        """
        Defines the HttpVersion condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'HttpVersion'.
        :param 'HttpVersionMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'HttpVersion')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'HttpVersion'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.HttpVersionMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleIsDeviceConditionResponse(dict):
    """
    Defines the IsDevice condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.IsDeviceMatchConditionParametersResponse'):
        """
        Defines the IsDevice condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'IsDevice'.
        :param 'IsDeviceMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'IsDevice')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'IsDevice'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.IsDeviceMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRulePostArgsConditionResponse(dict):
    """
    Defines the PostArgs condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.PostArgsMatchConditionParametersResponse'):
        """
        Defines the PostArgs condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'PostArgs'.
        :param 'PostArgsMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'PostArgs')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'PostArgs'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.PostArgsMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleQueryStringConditionResponse(dict):
    """
    Defines the QueryString condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.QueryStringMatchConditionParametersResponse'):
        """
        Defines the QueryString condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'QueryString'.
        :param 'QueryStringMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'QueryString')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'QueryString'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.QueryStringMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleRemoteAddressConditionResponse(dict):
    """
    Defines the RemoteAddress condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.RemoteAddressMatchConditionParametersResponse'):
        """
        Defines the RemoteAddress condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'RemoteAddress'.
        :param 'RemoteAddressMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'RemoteAddress')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'RemoteAddress'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.RemoteAddressMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleRequestBodyConditionResponse(dict):
    """
    Defines the RequestBody condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.RequestBodyMatchConditionParametersResponse'):
        """
        Defines the RequestBody condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'RequestBody'.
        :param 'RequestBodyMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'RequestBody')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'RequestBody'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.RequestBodyMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleRequestHeaderActionResponse(dict):
    """
    Defines the request header action for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.HeaderActionParametersResponse'):
        """
        Defines the request header action for the delivery rule.
        :param str name: The name of the action for the delivery rule.
               Expected value is 'ModifyRequestHeader'.
        :param 'HeaderActionParametersResponse' parameters: Defines the parameters for the action.
        """
        pulumi.set(__self__, "name", 'ModifyRequestHeader')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the action for the delivery rule.
        Expected value is 'ModifyRequestHeader'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.HeaderActionParametersResponse':
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleRequestHeaderConditionResponse(dict):
    """
    Defines the RequestHeader condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.RequestHeaderMatchConditionParametersResponse'):
        """
        Defines the RequestHeader condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'RequestHeader'.
        :param 'RequestHeaderMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'RequestHeader')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'RequestHeader'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.RequestHeaderMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleRequestMethodConditionResponse(dict):
    """
    Defines the RequestMethod condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.RequestMethodMatchConditionParametersResponse'):
        """
        Defines the RequestMethod condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'RequestMethod'.
        :param 'RequestMethodMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'RequestMethod')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'RequestMethod'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.RequestMethodMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleRequestSchemeConditionResponse(dict):
    """
    Defines the RequestScheme condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.RequestSchemeMatchConditionParametersResponse'):
        """
        Defines the RequestScheme condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'RequestScheme'.
        :param 'RequestSchemeMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'RequestScheme')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'RequestScheme'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.RequestSchemeMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleRequestUriConditionResponse(dict):
    """
    Defines the RequestUri condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.RequestUriMatchConditionParametersResponse'):
        """
        Defines the RequestUri condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'RequestUri'.
        :param 'RequestUriMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'RequestUri')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'RequestUri'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.RequestUriMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleResponse(dict):
    """
    A rule that specifies a set of actions and conditions
    """
    def __init__(__self__, *,
                 actions: Sequence[Any],
                 order: int,
                 conditions: Optional[Sequence[Any]] = None,
                 name: Optional[str] = None):
        """
        A rule that specifies a set of actions and conditions
        :param Sequence[Union['DeliveryRuleCacheExpirationActionResponse', 'DeliveryRuleCacheKeyQueryStringActionResponse', 'DeliveryRuleRequestHeaderActionResponse', 'DeliveryRuleResponseHeaderActionResponse', 'DeliveryRuleRouteConfigurationOverrideActionResponse', 'OriginGroupOverrideActionResponse', 'UrlRedirectActionResponse', 'UrlRewriteActionResponse', 'UrlSigningActionResponse']] actions: A list of actions that are executed when all the conditions of a rule are satisfied.
        :param int order: The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A rule with a lesser order will be applied before a rule with a greater order. Rule with order 0 is a special rule. It does not require any condition and actions listed in it will always be applied.
        :param Sequence[Union['DeliveryRuleClientPortConditionResponse', 'DeliveryRuleCookiesConditionResponse', 'DeliveryRuleHostNameConditionResponse', 'DeliveryRuleHttpVersionConditionResponse', 'DeliveryRuleIsDeviceConditionResponse', 'DeliveryRulePostArgsConditionResponse', 'DeliveryRuleQueryStringConditionResponse', 'DeliveryRuleRemoteAddressConditionResponse', 'DeliveryRuleRequestBodyConditionResponse', 'DeliveryRuleRequestHeaderConditionResponse', 'DeliveryRuleRequestMethodConditionResponse', 'DeliveryRuleRequestSchemeConditionResponse', 'DeliveryRuleRequestUriConditionResponse', 'DeliveryRuleServerPortConditionResponse', 'DeliveryRuleSocketAddrConditionResponse', 'DeliveryRuleSslProtocolConditionResponse', 'DeliveryRuleUrlFileExtensionConditionResponse', 'DeliveryRuleUrlFileNameConditionResponse', 'DeliveryRuleUrlPathConditionResponse']] conditions: A list of conditions that must be matched for the actions to be executed
        :param str name: Name of the rule
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "order", order)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def actions(self) -> Sequence[Any]:
        """
        A list of actions that are executed when all the conditions of a rule are satisfied.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def order(self) -> int:
        """
        The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A rule with a lesser order will be applied before a rule with a greater order. Rule with order 0 is a special rule. It does not require any condition and actions listed in it will always be applied.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence[Any]]:
        """
        A list of conditions that must be matched for the actions to be executed
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DeliveryRuleResponseHeaderActionResponse(dict):
    """
    Defines the response header action for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.HeaderActionParametersResponse'):
        """
        Defines the response header action for the delivery rule.
        :param str name: The name of the action for the delivery rule.
               Expected value is 'ModifyResponseHeader'.
        :param 'HeaderActionParametersResponse' parameters: Defines the parameters for the action.
        """
        pulumi.set(__self__, "name", 'ModifyResponseHeader')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the action for the delivery rule.
        Expected value is 'ModifyResponseHeader'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.HeaderActionParametersResponse':
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleRouteConfigurationOverrideActionResponse(dict):
    """
    Defines the route configuration override action for the delivery rule. Only applicable to Frontdoor Standard/Premium Profiles.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.RouteConfigurationOverrideActionParametersResponse'):
        """
        Defines the route configuration override action for the delivery rule. Only applicable to Frontdoor Standard/Premium Profiles.
        :param str name: The name of the action for the delivery rule.
               Expected value is 'RouteConfigurationOverride'.
        :param 'RouteConfigurationOverrideActionParametersResponse' parameters: Defines the parameters for the action.
        """
        pulumi.set(__self__, "name", 'RouteConfigurationOverride')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the action for the delivery rule.
        Expected value is 'RouteConfigurationOverride'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.RouteConfigurationOverrideActionParametersResponse':
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleServerPortConditionResponse(dict):
    """
    Defines the ServerPort condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.ServerPortMatchConditionParametersResponse'):
        """
        Defines the ServerPort condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'ServerPort'.
        :param 'ServerPortMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'ServerPort')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'ServerPort'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.ServerPortMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleSocketAddrConditionResponse(dict):
    """
    Defines the SocketAddress condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.SocketAddrMatchConditionParametersResponse'):
        """
        Defines the SocketAddress condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'SocketAddr'.
        :param 'SocketAddrMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'SocketAddr')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'SocketAddr'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.SocketAddrMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleSslProtocolConditionResponse(dict):
    """
    Defines the SslProtocol condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.SslProtocolMatchConditionParametersResponse'):
        """
        Defines the SslProtocol condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'SslProtocol'.
        :param 'SslProtocolMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'SslProtocol')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'SslProtocol'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.SslProtocolMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleUrlFileExtensionConditionResponse(dict):
    """
    Defines the UrlFileExtension condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.UrlFileExtensionMatchConditionParametersResponse'):
        """
        Defines the UrlFileExtension condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'UrlFileExtension'.
        :param 'UrlFileExtensionMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'UrlFileExtension')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'UrlFileExtension'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.UrlFileExtensionMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleUrlFileNameConditionResponse(dict):
    """
    Defines the UrlFileName condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.UrlFileNameMatchConditionParametersResponse'):
        """
        Defines the UrlFileName condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'UrlFileName'.
        :param 'UrlFileNameMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'UrlFileName')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'UrlFileName'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.UrlFileNameMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DeliveryRuleUrlPathConditionResponse(dict):
    """
    Defines the UrlPath condition for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.UrlPathMatchConditionParametersResponse'):
        """
        Defines the UrlPath condition for the delivery rule.
        :param str name: The name of the condition for the delivery rule.
               Expected value is 'UrlPath'.
        :param 'UrlPathMatchConditionParametersResponse' parameters: Defines the parameters for the condition.
        """
        pulumi.set(__self__, "name", 'UrlPath')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the condition for the delivery rule.
        Expected value is 'UrlPath'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.UrlPathMatchConditionParametersResponse':
        """
        Defines the parameters for the condition.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DomainValidationPropertiesResponse(dict):
    """
    The JSON object that contains the properties to validate a domain.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationDate":
            suggest = "expiration_date"
        elif key == "validationToken":
            suggest = "validation_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainValidationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainValidationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainValidationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expiration_date: str,
                 validation_token: str):
        """
        The JSON object that contains the properties to validate a domain.
        :param str expiration_date: The date time that the token expires
        :param str validation_token: Challenge used for DNS TXT record or file based validation
        """
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "validation_token", validation_token)

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> str:
        """
        The date time that the token expires
        """
        return pulumi.get(self, "expiration_date")

    @property
    @pulumi.getter(name="validationToken")
    def validation_token(self) -> str:
        """
        Challenge used for DNS TXT record or file based validation
        """
        return pulumi.get(self, "validation_token")


@pulumi.output_type
class EndpointPropertiesUpdateParametersResponseDeliveryPolicy(dict):
    """
    A policy that specifies the delivery rules to be used for an endpoint.
    """
    def __init__(__self__, *,
                 rules: Sequence['outputs.DeliveryRuleResponse'],
                 description: Optional[str] = None):
        """
        A policy that specifies the delivery rules to be used for an endpoint.
        :param Sequence['DeliveryRuleResponse'] rules: A list of the delivery rules.
        :param str description: User-friendly description of the policy.
        """
        pulumi.set(__self__, "rules", rules)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.DeliveryRuleResponse']:
        """
        A list of the delivery rules.
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        User-friendly description of the policy.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class EndpointPropertiesUpdateParametersResponseWebApplicationFirewallPolicyLink(dict):
    """
    Defines the Web Application Firewall policy for the endpoint (if applicable)
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Defines the Web Application Firewall policy for the endpoint (if applicable)
        :param str id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GeoFilterResponse(dict):
    """
    Rules defining user's geo access within a CDN endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryCodes":
            suggest = "country_codes"
        elif key == "relativePath":
            suggest = "relative_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GeoFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GeoFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GeoFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 country_codes: Sequence[str],
                 relative_path: str):
        """
        Rules defining user's geo access within a CDN endpoint.
        :param str action: Action of the geo filter, i.e. allow or block access.
        :param Sequence[str] country_codes: Two letter country or region codes defining user country or region access in a geo filter, e.g. AU, MX, US.
        :param str relative_path: Relative path applicable to geo filter. (e.g. '/mypictures', '/mypicture/kitty.jpg', and etc.)
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "country_codes", country_codes)
        pulumi.set(__self__, "relative_path", relative_path)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action of the geo filter, i.e. allow or block access.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="countryCodes")
    def country_codes(self) -> Sequence[str]:
        """
        Two letter country or region codes defining user country or region access in a geo filter, e.g. AU, MX, US.
        """
        return pulumi.get(self, "country_codes")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> str:
        """
        Relative path applicable to geo filter. (e.g. '/mypictures', '/mypicture/kitty.jpg', and etc.)
        """
        return pulumi.get(self, "relative_path")


@pulumi.output_type
class HeaderActionParametersResponse(dict):
    """
    Defines the parameters for the request header action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerAction":
            suggest = "header_action"
        elif key == "headerName":
            suggest = "header_name"
        elif key == "typeName":
            suggest = "type_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeaderActionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeaderActionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeaderActionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_action: str,
                 header_name: str,
                 type_name: str,
                 value: Optional[str] = None):
        """
        Defines the parameters for the request header action.
        :param str header_action: Action to perform
        :param str header_name: Name of the header to modify
        :param str value: Value for the specified action
        """
        pulumi.set(__self__, "header_action", header_action)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "type_name", type_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="headerAction")
    def header_action(self) -> str:
        """
        Action to perform
        """
        return pulumi.get(self, "header_action")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        Name of the header to modify
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value for the specified action
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HealthProbeParametersResponse(dict):
    """
    The JSON object that contains the properties to send health probes to origin.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "probeIntervalInSeconds":
            suggest = "probe_interval_in_seconds"
        elif key == "probePath":
            suggest = "probe_path"
        elif key == "probeProtocol":
            suggest = "probe_protocol"
        elif key == "probeRequestType":
            suggest = "probe_request_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthProbeParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthProbeParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthProbeParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 probe_interval_in_seconds: Optional[int] = None,
                 probe_path: Optional[str] = None,
                 probe_protocol: Optional[str] = None,
                 probe_request_type: Optional[str] = None):
        """
        The JSON object that contains the properties to send health probes to origin.
        :param int probe_interval_in_seconds: The number of seconds between health probes.Default is 240sec.
        :param str probe_path: The path relative to the origin that is used to determine the health of the origin.
        :param str probe_protocol: Protocol to use for health probe.
        :param str probe_request_type: The type of health probe request that is made.
        """
        if probe_interval_in_seconds is not None:
            pulumi.set(__self__, "probe_interval_in_seconds", probe_interval_in_seconds)
        if probe_path is not None:
            pulumi.set(__self__, "probe_path", probe_path)
        if probe_protocol is not None:
            pulumi.set(__self__, "probe_protocol", probe_protocol)
        if probe_request_type is not None:
            pulumi.set(__self__, "probe_request_type", probe_request_type)

    @property
    @pulumi.getter(name="probeIntervalInSeconds")
    def probe_interval_in_seconds(self) -> Optional[int]:
        """
        The number of seconds between health probes.Default is 240sec.
        """
        return pulumi.get(self, "probe_interval_in_seconds")

    @property
    @pulumi.getter(name="probePath")
    def probe_path(self) -> Optional[str]:
        """
        The path relative to the origin that is used to determine the health of the origin.
        """
        return pulumi.get(self, "probe_path")

    @property
    @pulumi.getter(name="probeProtocol")
    def probe_protocol(self) -> Optional[str]:
        """
        Protocol to use for health probe.
        """
        return pulumi.get(self, "probe_protocol")

    @property
    @pulumi.getter(name="probeRequestType")
    def probe_request_type(self) -> Optional[str]:
        """
        The type of health probe request that is made.
        """
        return pulumi.get(self, "probe_request_type")


@pulumi.output_type
class HostNameMatchConditionParametersResponse(dict):
    """
    Defines the parameters for HostName match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostNameMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostNameMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostNameMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for HostName match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class HttpErrorRangeParametersResponse(dict):
    """
    The JSON object that represents the range for http status codes
    """
    def __init__(__self__, *,
                 begin: Optional[int] = None,
                 end: Optional[int] = None):
        """
        The JSON object that represents the range for http status codes
        :param int begin: The inclusive start of the http status code range.
        :param int end: The inclusive end of the http status code range.
        """
        if begin is not None:
            pulumi.set(__self__, "begin", begin)
        if end is not None:
            pulumi.set(__self__, "end", end)

    @property
    @pulumi.getter
    def begin(self) -> Optional[int]:
        """
        The inclusive start of the http status code range.
        """
        return pulumi.get(self, "begin")

    @property
    @pulumi.getter
    def end(self) -> Optional[int]:
        """
        The inclusive end of the http status code range.
        """
        return pulumi.get(self, "end")


@pulumi.output_type
class HttpVersionMatchConditionParametersResponse(dict):
    """
    Defines the parameters for HttpVersion match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpVersionMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpVersionMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpVersionMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for HttpVersion match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class IsDeviceMatchConditionParametersResponse(dict):
    """
    Defines the parameters for IsDevice match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IsDeviceMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IsDeviceMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IsDeviceMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for IsDevice match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class KeyVaultCertificateSourceParametersResponse(dict):
    """
    Describes the parameters for using a user's KeyVault certificate for securing custom domain.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteRule":
            suggest = "delete_rule"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "secretName":
            suggest = "secret_name"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "typeName":
            suggest = "type_name"
        elif key == "updateRule":
            suggest = "update_rule"
        elif key == "vaultName":
            suggest = "vault_name"
        elif key == "secretVersion":
            suggest = "secret_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultCertificateSourceParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultCertificateSourceParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultCertificateSourceParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_rule: str,
                 resource_group_name: str,
                 secret_name: str,
                 subscription_id: str,
                 type_name: str,
                 update_rule: str,
                 vault_name: str,
                 secret_version: Optional[str] = None):
        """
        Describes the parameters for using a user's KeyVault certificate for securing custom domain.
        :param str delete_rule: Describes the action that shall be taken when the certificate is removed from Key Vault.
        :param str resource_group_name: Resource group of the user's Key Vault containing the SSL certificate
        :param str secret_name: The name of Key Vault Secret (representing the full certificate PFX) in Key Vault.
        :param str subscription_id: Subscription Id of the user's Key Vault containing the SSL certificate
        :param str update_rule: Describes the action that shall be taken when the certificate is updated in Key Vault.
        :param str vault_name: The name of the user's Key Vault containing the SSL certificate
        :param str secret_version: The version(GUID) of Key Vault Secret in Key Vault.
        """
        pulumi.set(__self__, "delete_rule", delete_rule)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "secret_name", secret_name)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "update_rule", update_rule)
        pulumi.set(__self__, "vault_name", vault_name)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="deleteRule")
    def delete_rule(self) -> str:
        """
        Describes the action that shall be taken when the certificate is removed from Key Vault.
        """
        return pulumi.get(self, "delete_rule")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Resource group of the user's Key Vault containing the SSL certificate
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of Key Vault Secret (representing the full certificate PFX) in Key Vault.
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        Subscription Id of the user's Key Vault containing the SSL certificate
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="updateRule")
    def update_rule(self) -> str:
        """
        Describes the action that shall be taken when the certificate is updated in Key Vault.
        """
        return pulumi.get(self, "update_rule")

    @property
    @pulumi.getter(name="vaultName")
    def vault_name(self) -> str:
        """
        The name of the user's Key Vault containing the SSL certificate
        """
        return pulumi.get(self, "vault_name")

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[str]:
        """
        The version(GUID) of Key Vault Secret in Key Vault.
        """
        return pulumi.get(self, "secret_version")


@pulumi.output_type
class KeyVaultSigningKeyParametersResponse(dict):
    """
    Describes the parameters for using a user's KeyVault for URL Signing Key.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "secretName":
            suggest = "secret_name"
        elif key == "secretVersion":
            suggest = "secret_version"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "typeName":
            suggest = "type_name"
        elif key == "vaultName":
            suggest = "vault_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultSigningKeyParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultSigningKeyParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultSigningKeyParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_group_name: str,
                 secret_name: str,
                 secret_version: str,
                 subscription_id: str,
                 type_name: str,
                 vault_name: str):
        """
        Describes the parameters for using a user's KeyVault for URL Signing Key.
        :param str resource_group_name: Resource group of the user's Key Vault containing the secret
        :param str secret_name: The name of secret in Key Vault.
        :param str secret_version: The version(GUID) of secret in Key Vault.
        :param str subscription_id: Subscription Id of the user's Key Vault containing the secret
        :param str vault_name: The name of the user's Key Vault containing the secret
        """
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "secret_name", secret_name)
        pulumi.set(__self__, "secret_version", secret_version)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "vault_name", vault_name)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Resource group of the user's Key Vault containing the secret
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> str:
        """
        The name of secret in Key Vault.
        """
        return pulumi.get(self, "secret_name")

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> str:
        """
        The version(GUID) of secret in Key Vault.
        """
        return pulumi.get(self, "secret_version")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        Subscription Id of the user's Key Vault containing the secret
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="vaultName")
    def vault_name(self) -> str:
        """
        The name of the user's Key Vault containing the secret
        """
        return pulumi.get(self, "vault_name")


@pulumi.output_type
class LoadBalancingSettingsParametersResponse(dict):
    """
    Round-Robin load balancing settings for a backend pool
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalLatencyInMilliseconds":
            suggest = "additional_latency_in_milliseconds"
        elif key == "sampleSize":
            suggest = "sample_size"
        elif key == "successfulSamplesRequired":
            suggest = "successful_samples_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancingSettingsParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancingSettingsParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancingSettingsParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_latency_in_milliseconds: Optional[int] = None,
                 sample_size: Optional[int] = None,
                 successful_samples_required: Optional[int] = None):
        """
        Round-Robin load balancing settings for a backend pool
        :param int additional_latency_in_milliseconds: The additional latency in milliseconds for probes to fall into the lowest latency bucket
        :param int sample_size: The number of samples to consider for load balancing decisions
        :param int successful_samples_required: The number of samples within the sample period that must succeed
        """
        if additional_latency_in_milliseconds is not None:
            pulumi.set(__self__, "additional_latency_in_milliseconds", additional_latency_in_milliseconds)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)
        if successful_samples_required is not None:
            pulumi.set(__self__, "successful_samples_required", successful_samples_required)

    @property
    @pulumi.getter(name="additionalLatencyInMilliseconds")
    def additional_latency_in_milliseconds(self) -> Optional[int]:
        """
        The additional latency in milliseconds for probes to fall into the lowest latency bucket
        """
        return pulumi.get(self, "additional_latency_in_milliseconds")

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[int]:
        """
        The number of samples to consider for load balancing decisions
        """
        return pulumi.get(self, "sample_size")

    @property
    @pulumi.getter(name="successfulSamplesRequired")
    def successful_samples_required(self) -> Optional[int]:
        """
        The number of samples within the sample period that must succeed
        """
        return pulumi.get(self, "successful_samples_required")


@pulumi.output_type
class ManagedCertificateParametersResponse(dict):
    """
    Managed Certificate used for https
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationDate":
            suggest = "expiration_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedCertificateParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedCertificateParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedCertificateParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expiration_date: str,
                 subject: str,
                 type: str):
        """
        Managed Certificate used for https
        :param str expiration_date: Certificate expiration date.
        :param str subject: Subject name in the certificate.
        :param str type: The type of the secret resource.
               Expected value is 'ManagedCertificate'.
        """
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "type", 'ManagedCertificate')

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> str:
        """
        Certificate expiration date.
        """
        return pulumi.get(self, "expiration_date")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        Subject name in the certificate.
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the secret resource.
        Expected value is 'ManagedCertificate'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ManagedRuleGroupOverrideResponse(dict):
    """
    Defines a managed rule group override setting.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleGroupName":
            suggest = "rule_group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedRuleGroupOverrideResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedRuleGroupOverrideResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedRuleGroupOverrideResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_group_name: str,
                 rules: Optional[Sequence['outputs.ManagedRuleOverrideResponse']] = None):
        """
        Defines a managed rule group override setting.
        :param str rule_group_name: Describes the managed rule group within the rule set to override
        :param Sequence['ManagedRuleOverrideResponse'] rules: List of rules that will be enabled. If none specified, all rules in the group will be disabled.
        """
        pulumi.set(__self__, "rule_group_name", rule_group_name)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="ruleGroupName")
    def rule_group_name(self) -> str:
        """
        Describes the managed rule group within the rule set to override
        """
        return pulumi.get(self, "rule_group_name")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.ManagedRuleOverrideResponse']]:
        """
        List of rules that will be enabled. If none specified, all rules in the group will be disabled.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ManagedRuleOverrideResponse(dict):
    """
    Defines a managed rule group override setting.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleId":
            suggest = "rule_id"
        elif key == "enabledState":
            suggest = "enabled_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedRuleOverrideResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedRuleOverrideResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedRuleOverrideResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_id: str,
                 action: Optional[str] = None,
                 enabled_state: Optional[str] = None):
        """
        Defines a managed rule group override setting.
        :param str rule_id: Identifier for the managed rule.
        :param str action: Describes the override action to be applied when rule matches.
        :param str enabled_state: Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
        """
        pulumi.set(__self__, "rule_id", rule_id)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled_state is not None:
            pulumi.set(__self__, "enabled_state", enabled_state)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        """
        Identifier for the managed rule.
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Describes the override action to be applied when rule matches.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[str]:
        """
        Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
        """
        return pulumi.get(self, "enabled_state")


@pulumi.output_type
class ManagedRuleSetListResponse(dict):
    """
    Defines the list of managed rule sets for the policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedRuleSets":
            suggest = "managed_rule_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedRuleSetListResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedRuleSetListResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedRuleSetListResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_rule_sets: Optional[Sequence['outputs.ManagedRuleSetResponse']] = None):
        """
        Defines the list of managed rule sets for the policy.
        :param Sequence['ManagedRuleSetResponse'] managed_rule_sets: List of rule sets.
        """
        if managed_rule_sets is not None:
            pulumi.set(__self__, "managed_rule_sets", managed_rule_sets)

    @property
    @pulumi.getter(name="managedRuleSets")
    def managed_rule_sets(self) -> Optional[Sequence['outputs.ManagedRuleSetResponse']]:
        """
        List of rule sets.
        """
        return pulumi.get(self, "managed_rule_sets")


@pulumi.output_type
class ManagedRuleSetResponse(dict):
    """
    Defines a managed rule set.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleSetType":
            suggest = "rule_set_type"
        elif key == "ruleSetVersion":
            suggest = "rule_set_version"
        elif key == "anomalyScore":
            suggest = "anomaly_score"
        elif key == "ruleGroupOverrides":
            suggest = "rule_group_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedRuleSetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedRuleSetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedRuleSetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_set_type: str,
                 rule_set_version: str,
                 anomaly_score: Optional[int] = None,
                 rule_group_overrides: Optional[Sequence['outputs.ManagedRuleGroupOverrideResponse']] = None):
        """
        Defines a managed rule set.
        :param str rule_set_type: Defines the rule set type to use.
        :param str rule_set_version: Defines the version of the rule set to use.
        :param int anomaly_score: Verizon only : If the rule set supports anomaly detection mode, this describes the threshold for blocking requests.
        :param Sequence['ManagedRuleGroupOverrideResponse'] rule_group_overrides: Defines the rule overrides to apply to the rule set.
        """
        pulumi.set(__self__, "rule_set_type", rule_set_type)
        pulumi.set(__self__, "rule_set_version", rule_set_version)
        if anomaly_score is not None:
            pulumi.set(__self__, "anomaly_score", anomaly_score)
        if rule_group_overrides is not None:
            pulumi.set(__self__, "rule_group_overrides", rule_group_overrides)

    @property
    @pulumi.getter(name="ruleSetType")
    def rule_set_type(self) -> str:
        """
        Defines the rule set type to use.
        """
        return pulumi.get(self, "rule_set_type")

    @property
    @pulumi.getter(name="ruleSetVersion")
    def rule_set_version(self) -> str:
        """
        Defines the version of the rule set to use.
        """
        return pulumi.get(self, "rule_set_version")

    @property
    @pulumi.getter(name="anomalyScore")
    def anomaly_score(self) -> Optional[int]:
        """
        Verizon only : If the rule set supports anomaly detection mode, this describes the threshold for blocking requests.
        """
        return pulumi.get(self, "anomaly_score")

    @property
    @pulumi.getter(name="ruleGroupOverrides")
    def rule_group_overrides(self) -> Optional[Sequence['outputs.ManagedRuleGroupOverrideResponse']]:
        """
        Defines the rule overrides to apply to the rule set.
        """
        return pulumi.get(self, "rule_group_overrides")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MatchConditionResponse(dict):
    """
    Define match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchValue":
            suggest = "match_value"
        elif key == "matchVariable":
            suggest = "match_variable"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MatchConditionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MatchConditionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MatchConditionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_value: Sequence[str],
                 match_variable: str,
                 operator: str,
                 negate_condition: Optional[bool] = None,
                 selector: Optional[str] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Define match conditions
        :param Sequence[str] match_value: List of possible match values.
        :param str match_variable: Match variable to compare against.
        :param str operator: Describes operator to be matched
        :param bool negate_condition: Describes if the result of this condition should be negated.
        :param str selector: Selector can used to match a specific key for QueryString, Cookies, RequestHeader or PostArgs.
        :param Sequence[str] transforms: List of transforms.
        """
        pulumi.set(__self__, "match_value", match_value)
        pulumi.set(__self__, "match_variable", match_variable)
        pulumi.set(__self__, "operator", operator)
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Sequence[str]:
        """
        List of possible match values.
        """
        return pulumi.get(self, "match_value")

    @property
    @pulumi.getter(name="matchVariable")
    def match_variable(self) -> str:
        """
        Match variable to compare against.
        """
        return pulumi.get(self, "match_variable")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if the result of this condition should be negated.
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        """
        Selector can used to match a specific key for QueryString, Cookies, RequestHeader or PostArgs.
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms.
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class OriginGroupOverrideActionParametersResponse(dict):
    """
    Defines the parameters for the origin group override action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originGroup":
            suggest = "origin_group"
        elif key == "typeName":
            suggest = "type_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OriginGroupOverrideActionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OriginGroupOverrideActionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OriginGroupOverrideActionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 origin_group: 'outputs.ResourceReferenceResponse',
                 type_name: str):
        """
        Defines the parameters for the origin group override action.
        :param 'ResourceReferenceResponse' origin_group: defines the OriginGroup that would override the DefaultOriginGroup.
        """
        pulumi.set(__self__, "origin_group", origin_group)
        pulumi.set(__self__, "type_name", type_name)

    @property
    @pulumi.getter(name="originGroup")
    def origin_group(self) -> 'outputs.ResourceReferenceResponse':
        """
        defines the OriginGroup that would override the DefaultOriginGroup.
        """
        return pulumi.get(self, "origin_group")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")


@pulumi.output_type
class OriginGroupOverrideActionResponse(dict):
    """
    Defines the origin group override action for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.OriginGroupOverrideActionParametersResponse'):
        """
        Defines the origin group override action for the delivery rule.
        :param str name: The name of the action for the delivery rule.
               Expected value is 'OriginGroupOverride'.
        :param 'OriginGroupOverrideActionParametersResponse' parameters: Defines the parameters for the action.
        """
        pulumi.set(__self__, "name", 'OriginGroupOverride')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the action for the delivery rule.
        Expected value is 'OriginGroupOverride'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.OriginGroupOverrideActionParametersResponse':
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class OriginGroupOverrideResponse(dict):
    """
    Defines the parameters for the origin group override configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardingProtocol":
            suggest = "forwarding_protocol"
        elif key == "originGroup":
            suggest = "origin_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OriginGroupOverrideResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OriginGroupOverrideResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OriginGroupOverrideResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forwarding_protocol: Optional[str] = None,
                 origin_group: Optional['outputs.ResourceReferenceResponse'] = None):
        """
        Defines the parameters for the origin group override configuration.
        :param str forwarding_protocol: Protocol this rule will use when forwarding traffic to backends.
        :param 'ResourceReferenceResponse' origin_group: defines the OriginGroup that would override the DefaultOriginGroup on route.
        """
        if forwarding_protocol is not None:
            pulumi.set(__self__, "forwarding_protocol", forwarding_protocol)
        if origin_group is not None:
            pulumi.set(__self__, "origin_group", origin_group)

    @property
    @pulumi.getter(name="forwardingProtocol")
    def forwarding_protocol(self) -> Optional[str]:
        """
        Protocol this rule will use when forwarding traffic to backends.
        """
        return pulumi.get(self, "forwarding_protocol")

    @property
    @pulumi.getter(name="originGroup")
    def origin_group(self) -> Optional['outputs.ResourceReferenceResponse']:
        """
        defines the OriginGroup that would override the DefaultOriginGroup on route.
        """
        return pulumi.get(self, "origin_group")


@pulumi.output_type
class PolicySettingsResponse(dict):
    """
    Defines contents of a web application firewall global configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultCustomBlockResponseBody":
            suggest = "default_custom_block_response_body"
        elif key == "defaultCustomBlockResponseStatusCode":
            suggest = "default_custom_block_response_status_code"
        elif key == "defaultRedirectUrl":
            suggest = "default_redirect_url"
        elif key == "enabledState":
            suggest = "enabled_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_custom_block_response_body: Optional[str] = None,
                 default_custom_block_response_status_code: Optional[int] = None,
                 default_redirect_url: Optional[str] = None,
                 enabled_state: Optional[str] = None,
                 mode: Optional[str] = None):
        """
        Defines contents of a web application firewall global configuration
        :param str default_custom_block_response_body: If the action type is block, customer can override the response body. The body must be specified in base64 encoding.
        :param int default_custom_block_response_status_code: If the action type is block, this field defines the default customer overridable http response status code.
        :param str default_redirect_url: If action type is redirect, this field represents the default redirect URL for the client.
        :param str enabled_state: describes if the policy is in enabled state or disabled state
        :param str mode: Describes if it is in detection mode or prevention mode at policy level.
        """
        if default_custom_block_response_body is not None:
            pulumi.set(__self__, "default_custom_block_response_body", default_custom_block_response_body)
        if default_custom_block_response_status_code is not None:
            pulumi.set(__self__, "default_custom_block_response_status_code", default_custom_block_response_status_code)
        if default_redirect_url is not None:
            pulumi.set(__self__, "default_redirect_url", default_redirect_url)
        if enabled_state is not None:
            pulumi.set(__self__, "enabled_state", enabled_state)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="defaultCustomBlockResponseBody")
    def default_custom_block_response_body(self) -> Optional[str]:
        """
        If the action type is block, customer can override the response body. The body must be specified in base64 encoding.
        """
        return pulumi.get(self, "default_custom_block_response_body")

    @property
    @pulumi.getter(name="defaultCustomBlockResponseStatusCode")
    def default_custom_block_response_status_code(self) -> Optional[int]:
        """
        If the action type is block, this field defines the default customer overridable http response status code.
        """
        return pulumi.get(self, "default_custom_block_response_status_code")

    @property
    @pulumi.getter(name="defaultRedirectUrl")
    def default_redirect_url(self) -> Optional[str]:
        """
        If action type is redirect, this field represents the default redirect URL for the client.
        """
        return pulumi.get(self, "default_redirect_url")

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[str]:
        """
        describes if the policy is in enabled state or disabled state
        """
        return pulumi.get(self, "enabled_state")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Describes if it is in detection mode or prevention mode at policy level.
        """
        return pulumi.get(self, "mode")


@pulumi.output_type
class PostArgsMatchConditionParametersResponse(dict):
    """
    Defines the parameters for PostArgs match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PostArgsMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PostArgsMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PostArgsMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 selector: Optional[str] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for PostArgs match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param str selector: Name of PostArg to be matched
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        """
        Name of PostArg to be matched
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class QueryStringMatchConditionParametersResponse(dict):
    """
    Defines the parameters for QueryString match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryStringMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryStringMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryStringMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for QueryString match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class RateLimitRuleListResponse(dict):
    """
    Defines contents of rate limit rules
    """
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.RateLimitRuleResponse']] = None):
        """
        Defines contents of rate limit rules
        :param Sequence['RateLimitRuleResponse'] rules: List of rules
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.RateLimitRuleResponse']]:
        """
        List of rules
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class RateLimitRuleResponse(dict):
    """
    Defines a rate limiting rule that can be included in a waf policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchConditions":
            suggest = "match_conditions"
        elif key == "rateLimitDurationInMinutes":
            suggest = "rate_limit_duration_in_minutes"
        elif key == "rateLimitThreshold":
            suggest = "rate_limit_threshold"
        elif key == "enabledState":
            suggest = "enabled_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RateLimitRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RateLimitRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RateLimitRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 match_conditions: Sequence['outputs.MatchConditionResponse'],
                 name: str,
                 priority: int,
                 rate_limit_duration_in_minutes: int,
                 rate_limit_threshold: int,
                 enabled_state: Optional[str] = None):
        """
        Defines a rate limiting rule that can be included in a waf policy
        :param str action: Describes what action to be applied when rule matches
        :param Sequence['MatchConditionResponse'] match_conditions: List of match conditions.
        :param str name: Defines the name of the custom rule
        :param int priority: Defines in what order this rule be evaluated in the overall list of custom rules
        :param int rate_limit_duration_in_minutes: Defines rate limit duration. Default is 1 minute.
        :param int rate_limit_threshold: Defines rate limit threshold.
        :param str enabled_state: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match_conditions", match_conditions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rate_limit_duration_in_minutes", rate_limit_duration_in_minutes)
        pulumi.set(__self__, "rate_limit_threshold", rate_limit_threshold)
        if enabled_state is not None:
            pulumi.set(__self__, "enabled_state", enabled_state)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Describes what action to be applied when rule matches
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="matchConditions")
    def match_conditions(self) -> Sequence['outputs.MatchConditionResponse']:
        """
        List of match conditions.
        """
        return pulumi.get(self, "match_conditions")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Defines the name of the custom rule
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Defines in what order this rule be evaluated in the overall list of custom rules
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="rateLimitDurationInMinutes")
    def rate_limit_duration_in_minutes(self) -> int:
        """
        Defines rate limit duration. Default is 1 minute.
        """
        return pulumi.get(self, "rate_limit_duration_in_minutes")

    @property
    @pulumi.getter(name="rateLimitThreshold")
    def rate_limit_threshold(self) -> int:
        """
        Defines rate limit threshold.
        """
        return pulumi.get(self, "rate_limit_threshold")

    @property
    @pulumi.getter(name="enabledState")
    def enabled_state(self) -> Optional[str]:
        """
        Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
        """
        return pulumi.get(self, "enabled_state")


@pulumi.output_type
class RemoteAddressMatchConditionParametersResponse(dict):
    """
    Defines the parameters for RemoteAddress match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemoteAddressMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemoteAddressMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemoteAddressMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for RemoteAddress match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator this match condition is considered a match.
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator this match condition is considered a match.
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class RequestBodyMatchConditionParametersResponse(dict):
    """
    Defines the parameters for RequestBody match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestBodyMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestBodyMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestBodyMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for RequestBody match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class RequestHeaderMatchConditionParametersResponse(dict):
    """
    Defines the parameters for RequestHeader match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestHeaderMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestHeaderMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestHeaderMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 selector: Optional[str] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for RequestHeader match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param str selector: Name of Header to be matched
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def selector(self) -> Optional[str]:
        """
        Name of Header to be matched
        """
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class RequestMethodMatchConditionParametersResponse(dict):
    """
    Defines the parameters for RequestMethod match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestMethodMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestMethodMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestMethodMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for RequestMethod match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class RequestSchemeMatchConditionParametersResponse(dict):
    """
    Defines the parameters for RequestScheme match conditions 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestSchemeMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestSchemeMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestSchemeMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for RequestScheme match conditions 
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class RequestUriMatchConditionParametersResponse(dict):
    """
    Defines the parameters for RequestUri match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RequestUriMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RequestUriMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RequestUriMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for RequestUri match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class ResourceReferenceResponse(dict):
    """
    Reference to another resource.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Reference to another resource.
        :param str id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ResponseBasedOriginErrorDetectionParametersResponse(dict):
    """
    The JSON object that contains the properties to determine origin health using real requests/responses.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpErrorRanges":
            suggest = "http_error_ranges"
        elif key == "responseBasedDetectedErrorTypes":
            suggest = "response_based_detected_error_types"
        elif key == "responseBasedFailoverThresholdPercentage":
            suggest = "response_based_failover_threshold_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponseBasedOriginErrorDetectionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponseBasedOriginErrorDetectionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponseBasedOriginErrorDetectionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_error_ranges: Optional[Sequence['outputs.HttpErrorRangeParametersResponse']] = None,
                 response_based_detected_error_types: Optional[str] = None,
                 response_based_failover_threshold_percentage: Optional[int] = None):
        """
        The JSON object that contains the properties to determine origin health using real requests/responses.
        :param Sequence['HttpErrorRangeParametersResponse'] http_error_ranges: The list of Http status code ranges that are considered as server errors for origin and it is marked as unhealthy.
        :param str response_based_detected_error_types: Type of response errors for real user requests for which origin will be deemed unhealthy
        :param int response_based_failover_threshold_percentage: The percentage of failed requests in the sample where failover should trigger.
        """
        if http_error_ranges is not None:
            pulumi.set(__self__, "http_error_ranges", http_error_ranges)
        if response_based_detected_error_types is not None:
            pulumi.set(__self__, "response_based_detected_error_types", response_based_detected_error_types)
        if response_based_failover_threshold_percentage is not None:
            pulumi.set(__self__, "response_based_failover_threshold_percentage", response_based_failover_threshold_percentage)

    @property
    @pulumi.getter(name="httpErrorRanges")
    def http_error_ranges(self) -> Optional[Sequence['outputs.HttpErrorRangeParametersResponse']]:
        """
        The list of Http status code ranges that are considered as server errors for origin and it is marked as unhealthy.
        """
        return pulumi.get(self, "http_error_ranges")

    @property
    @pulumi.getter(name="responseBasedDetectedErrorTypes")
    def response_based_detected_error_types(self) -> Optional[str]:
        """
        Type of response errors for real user requests for which origin will be deemed unhealthy
        """
        return pulumi.get(self, "response_based_detected_error_types")

    @property
    @pulumi.getter(name="responseBasedFailoverThresholdPercentage")
    def response_based_failover_threshold_percentage(self) -> Optional[int]:
        """
        The percentage of failed requests in the sample where failover should trigger.
        """
        return pulumi.get(self, "response_based_failover_threshold_percentage")


@pulumi.output_type
class RouteConfigurationOverrideActionParametersResponse(dict):
    """
    Defines the parameters for the route configuration override action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "cacheConfiguration":
            suggest = "cache_configuration"
        elif key == "originGroupOverride":
            suggest = "origin_group_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteConfigurationOverrideActionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteConfigurationOverrideActionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteConfigurationOverrideActionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_name: str,
                 cache_configuration: Optional['outputs.CacheConfigurationResponse'] = None,
                 origin_group_override: Optional['outputs.OriginGroupOverrideResponse'] = None):
        """
        Defines the parameters for the route configuration override action.
        :param 'CacheConfigurationResponse' cache_configuration: The caching configuration associated with this rule. To disable caching, do not provide a cacheConfiguration object.
        :param 'OriginGroupOverrideResponse' origin_group_override: A reference to the origin group override configuration. Leave empty to use the default origin group on route.
        """
        pulumi.set(__self__, "type_name", type_name)
        if cache_configuration is not None:
            pulumi.set(__self__, "cache_configuration", cache_configuration)
        if origin_group_override is not None:
            pulumi.set(__self__, "origin_group_override", origin_group_override)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="cacheConfiguration")
    def cache_configuration(self) -> Optional['outputs.CacheConfigurationResponse']:
        """
        The caching configuration associated with this rule. To disable caching, do not provide a cacheConfiguration object.
        """
        return pulumi.get(self, "cache_configuration")

    @property
    @pulumi.getter(name="originGroupOverride")
    def origin_group_override(self) -> Optional['outputs.OriginGroupOverrideResponse']:
        """
        A reference to the origin group override configuration. Leave empty to use the default origin group on route.
        """
        return pulumi.get(self, "origin_group_override")


@pulumi.output_type
class SecurityPolicyWebApplicationFirewallAssociationResponse(dict):
    """
    settings for security policy patterns to match
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patternsToMatch":
            suggest = "patterns_to_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyWebApplicationFirewallAssociationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyWebApplicationFirewallAssociationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyWebApplicationFirewallAssociationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domains: Optional[Sequence['outputs.ActivatedResourceReferenceResponse']] = None,
                 patterns_to_match: Optional[Sequence[str]] = None):
        """
        settings for security policy patterns to match
        :param Sequence['ActivatedResourceReferenceResponse'] domains: List of domains.
        :param Sequence[str] patterns_to_match: List of paths
        """
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if patterns_to_match is not None:
            pulumi.set(__self__, "patterns_to_match", patterns_to_match)

    @property
    @pulumi.getter
    def domains(self) -> Optional[Sequence['outputs.ActivatedResourceReferenceResponse']]:
        """
        List of domains.
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter(name="patternsToMatch")
    def patterns_to_match(self) -> Optional[Sequence[str]]:
        """
        List of paths
        """
        return pulumi.get(self, "patterns_to_match")


@pulumi.output_type
class SecurityPolicyWebApplicationFirewallParametersResponse(dict):
    """
    The json object containing security policy waf parameters
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wafPolicy":
            suggest = "waf_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityPolicyWebApplicationFirewallParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityPolicyWebApplicationFirewallParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityPolicyWebApplicationFirewallParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 associations: Optional[Sequence['outputs.SecurityPolicyWebApplicationFirewallAssociationResponse']] = None,
                 waf_policy: Optional['outputs.ResourceReferenceResponse'] = None):
        """
        The json object containing security policy waf parameters
        :param str type: The type of the Security policy to create.
               Expected value is 'WebApplicationFirewall'.
        :param Sequence['SecurityPolicyWebApplicationFirewallAssociationResponse'] associations: Waf associations
        :param 'ResourceReferenceResponse' waf_policy: Resource ID.
        """
        pulumi.set(__self__, "type", 'WebApplicationFirewall')
        if associations is not None:
            pulumi.set(__self__, "associations", associations)
        if waf_policy is not None:
            pulumi.set(__self__, "waf_policy", waf_policy)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the Security policy to create.
        Expected value is 'WebApplicationFirewall'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def associations(self) -> Optional[Sequence['outputs.SecurityPolicyWebApplicationFirewallAssociationResponse']]:
        """
        Waf associations
        """
        return pulumi.get(self, "associations")

    @property
    @pulumi.getter(name="wafPolicy")
    def waf_policy(self) -> Optional['outputs.ResourceReferenceResponse']:
        """
        Resource ID.
        """
        return pulumi.get(self, "waf_policy")


@pulumi.output_type
class ServerPortMatchConditionParametersResponse(dict):
    """
    Defines the parameters for ServerPort match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServerPortMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServerPortMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServerPortMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for ServerPort match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class SharedPrivateLinkResourcePropertiesResponse(dict):
    """
    Describes the properties of an existing Shared Private Link Resource to use when connecting to a private origin.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "privateLink":
            suggest = "private_link"
        elif key == "privateLinkLocation":
            suggest = "private_link_location"
        elif key == "requestMessage":
            suggest = "request_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SharedPrivateLinkResourcePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SharedPrivateLinkResourcePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SharedPrivateLinkResourcePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: Optional[str] = None,
                 private_link: Optional['outputs.ResourceReferenceResponse'] = None,
                 private_link_location: Optional[str] = None,
                 request_message: Optional[str] = None,
                 status: Optional[str] = None):
        """
        Describes the properties of an existing Shared Private Link Resource to use when connecting to a private origin.
        :param str group_id: The group id from the provider of resource the shared private link resource is for.
        :param 'ResourceReferenceResponse' private_link: The resource id of the resource the shared private link resource is for.
        :param str private_link_location: The location of the shared private link resource
        :param str request_message: The request message for requesting approval of the shared private link resource.
        :param str status: Status of the shared private link resource. Can be Pending, Approved, Rejected, Disconnected, or Timeout.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if private_link is not None:
            pulumi.set(__self__, "private_link", private_link)
        if private_link_location is not None:
            pulumi.set(__self__, "private_link_location", private_link_location)
        if request_message is not None:
            pulumi.set(__self__, "request_message", request_message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The group id from the provider of resource the shared private link resource is for.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="privateLink")
    def private_link(self) -> Optional['outputs.ResourceReferenceResponse']:
        """
        The resource id of the resource the shared private link resource is for.
        """
        return pulumi.get(self, "private_link")

    @property
    @pulumi.getter(name="privateLinkLocation")
    def private_link_location(self) -> Optional[str]:
        """
        The location of the shared private link resource
        """
        return pulumi.get(self, "private_link_location")

    @property
    @pulumi.getter(name="requestMessage")
    def request_message(self) -> Optional[str]:
        """
        The request message for requesting approval of the shared private link resource.
        """
        return pulumi.get(self, "request_message")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the shared private link resource. Can be Pending, Approved, Rejected, Disconnected, or Timeout.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SkuResponse(dict):
    """
    Standard_Verizon = The SKU name for a Standard Verizon CDN profile.
    Premium_Verizon = The SKU name for a Premium Verizon CDN profile.
    Custom_Verizon = The SKU name for a Custom Verizon CDN profile.
    Standard_Akamai = The SKU name for an Akamai CDN profile.
    Standard_ChinaCdn = The SKU name for a China CDN profile for VOD, Web and download scenarios using GB based billing model.
    Standard_Microsoft = The SKU name for a Standard Microsoft CDN profile.
    Standard_AzureFrontDoor =  The SKU name for an Azure Front Door Standard profile.
    Premium_AzureFrontDoor = The SKU name for an Azure Front Door Premium profile.
    Standard_955BandWidth_ChinaCdn = The SKU name for a China CDN profile for VOD, Web and download scenarios using 95-5 peak bandwidth billing model.
    Standard_AvgBandWidth_ChinaCdn = The SKU name for a China CDN profile for VOD, Web and download scenarios using monthly average peak bandwidth billing model.
    StandardPlus_ChinaCdn = The SKU name for a China CDN profile for live-streaming using GB based billing model.
    StandardPlus_955BandWidth_ChinaCdn = The SKU name for a China CDN live-streaming profile using 95-5 peak bandwidth billing model.
    StandardPlus_AvgBandWidth_ChinaCdn = The SKU name for a China CDN live-streaming profile using monthly average peak bandwidth billing model.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        Standard_Verizon = The SKU name for a Standard Verizon CDN profile.
        Premium_Verizon = The SKU name for a Premium Verizon CDN profile.
        Custom_Verizon = The SKU name for a Custom Verizon CDN profile.
        Standard_Akamai = The SKU name for an Akamai CDN profile.
        Standard_ChinaCdn = The SKU name for a China CDN profile for VOD, Web and download scenarios using GB based billing model.
        Standard_Microsoft = The SKU name for a Standard Microsoft CDN profile.
        Standard_AzureFrontDoor =  The SKU name for an Azure Front Door Standard profile.
        Premium_AzureFrontDoor = The SKU name for an Azure Front Door Premium profile.
        Standard_955BandWidth_ChinaCdn = The SKU name for a China CDN profile for VOD, Web and download scenarios using 95-5 peak bandwidth billing model.
        Standard_AvgBandWidth_ChinaCdn = The SKU name for a China CDN profile for VOD, Web and download scenarios using monthly average peak bandwidth billing model.
        StandardPlus_ChinaCdn = The SKU name for a China CDN profile for live-streaming using GB based billing model.
        StandardPlus_955BandWidth_ChinaCdn = The SKU name for a China CDN live-streaming profile using 95-5 peak bandwidth billing model.
        StandardPlus_AvgBandWidth_ChinaCdn = The SKU name for a China CDN live-streaming profile using monthly average peak bandwidth billing model.

        :param str name: Name of the pricing tier.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the pricing tier.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SocketAddrMatchConditionParametersResponse(dict):
    """
    Defines the parameters for SocketAddress match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SocketAddrMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SocketAddrMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SocketAddrMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for SocketAddress match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class SslProtocolMatchConditionParametersResponse(dict):
    """
    Defines the parameters for SslProtocol match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslProtocolMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslProtocolMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslProtocolMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for SslProtocol match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Read only system data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Read only system data
        :param str created_at: The timestamp of resource creation (UTC)
        :param str created_by: An identifier for the identity that created the resource
        :param str created_by_type: The type of identity that created the resource
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: An identifier for the identity that last modified the resource
        :param str last_modified_by_type: The type of identity that last modified the resource
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC)
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        An identifier for the identity that created the resource
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        An identifier for the identity that last modified the resource
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UrlFileExtensionMatchConditionParametersResponse(dict):
    """
    Defines the parameters for UrlFileExtension match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlFileExtensionMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlFileExtensionMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlFileExtensionMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for UrlFileExtension match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class UrlFileNameMatchConditionParametersResponse(dict):
    """
    Defines the parameters for UrlFilename match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlFileNameMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlFileNameMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlFileNameMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for UrlFilename match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class UrlPathMatchConditionParametersResponse(dict):
    """
    Defines the parameters for UrlPath match conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "matchValues":
            suggest = "match_values"
        elif key == "negateCondition":
            suggest = "negate_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlPathMatchConditionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlPathMatchConditionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlPathMatchConditionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator: str,
                 type_name: str,
                 match_values: Optional[Sequence[str]] = None,
                 negate_condition: Optional[bool] = None,
                 transforms: Optional[Sequence[str]] = None):
        """
        Defines the parameters for UrlPath match conditions
        :param str operator: Describes operator to be matched
        :param Sequence[str] match_values: The match value for the condition of the delivery rule
        :param bool negate_condition: Describes if this is negate condition or not
        :param Sequence[str] transforms: List of transforms
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type_name", type_name)
        if match_values is not None:
            pulumi.set(__self__, "match_values", match_values)
        if negate_condition is None:
            negate_condition = False
        if negate_condition is not None:
            pulumi.set(__self__, "negate_condition", negate_condition)
        if transforms is not None:
            pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Describes operator to be matched
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="matchValues")
    def match_values(self) -> Optional[Sequence[str]]:
        """
        The match value for the condition of the delivery rule
        """
        return pulumi.get(self, "match_values")

    @property
    @pulumi.getter(name="negateCondition")
    def negate_condition(self) -> Optional[bool]:
        """
        Describes if this is negate condition or not
        """
        return pulumi.get(self, "negate_condition")

    @property
    @pulumi.getter
    def transforms(self) -> Optional[Sequence[str]]:
        """
        List of transforms
        """
        return pulumi.get(self, "transforms")


@pulumi.output_type
class UrlRedirectActionParametersResponse(dict):
    """
    Defines the parameters for the url redirect action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectType":
            suggest = "redirect_type"
        elif key == "typeName":
            suggest = "type_name"
        elif key == "customFragment":
            suggest = "custom_fragment"
        elif key == "customHostname":
            suggest = "custom_hostname"
        elif key == "customPath":
            suggest = "custom_path"
        elif key == "customQueryString":
            suggest = "custom_query_string"
        elif key == "destinationProtocol":
            suggest = "destination_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlRedirectActionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlRedirectActionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlRedirectActionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_type: str,
                 type_name: str,
                 custom_fragment: Optional[str] = None,
                 custom_hostname: Optional[str] = None,
                 custom_path: Optional[str] = None,
                 custom_query_string: Optional[str] = None,
                 destination_protocol: Optional[str] = None):
        """
        Defines the parameters for the url redirect action.
        :param str redirect_type: The redirect type the rule will use when redirecting traffic.
        :param str custom_fragment: Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include the #.
        :param str custom_hostname: Host to redirect. Leave empty to use the incoming host as the destination host.
        :param str custom_path: The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path as destination path.
        :param str custom_query_string: The set of query strings to be placed in the redirect URL. Setting this value would replace any existing query string; leave empty to preserve the incoming query string. Query string must be in <key>=<value> format. ? and & will be added automatically so do not include them.
        :param str destination_protocol: Protocol to use for the redirect. The default value is MatchRequest
        """
        pulumi.set(__self__, "redirect_type", redirect_type)
        pulumi.set(__self__, "type_name", type_name)
        if custom_fragment is not None:
            pulumi.set(__self__, "custom_fragment", custom_fragment)
        if custom_hostname is not None:
            pulumi.set(__self__, "custom_hostname", custom_hostname)
        if custom_path is not None:
            pulumi.set(__self__, "custom_path", custom_path)
        if custom_query_string is not None:
            pulumi.set(__self__, "custom_query_string", custom_query_string)
        if destination_protocol is not None:
            pulumi.set(__self__, "destination_protocol", destination_protocol)

    @property
    @pulumi.getter(name="redirectType")
    def redirect_type(self) -> str:
        """
        The redirect type the rule will use when redirecting traffic.
        """
        return pulumi.get(self, "redirect_type")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="customFragment")
    def custom_fragment(self) -> Optional[str]:
        """
        Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include the #.
        """
        return pulumi.get(self, "custom_fragment")

    @property
    @pulumi.getter(name="customHostname")
    def custom_hostname(self) -> Optional[str]:
        """
        Host to redirect. Leave empty to use the incoming host as the destination host.
        """
        return pulumi.get(self, "custom_hostname")

    @property
    @pulumi.getter(name="customPath")
    def custom_path(self) -> Optional[str]:
        """
        The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path as destination path.
        """
        return pulumi.get(self, "custom_path")

    @property
    @pulumi.getter(name="customQueryString")
    def custom_query_string(self) -> Optional[str]:
        """
        The set of query strings to be placed in the redirect URL. Setting this value would replace any existing query string; leave empty to preserve the incoming query string. Query string must be in <key>=<value> format. ? and & will be added automatically so do not include them.
        """
        return pulumi.get(self, "custom_query_string")

    @property
    @pulumi.getter(name="destinationProtocol")
    def destination_protocol(self) -> Optional[str]:
        """
        Protocol to use for the redirect. The default value is MatchRequest
        """
        return pulumi.get(self, "destination_protocol")


@pulumi.output_type
class UrlRedirectActionResponse(dict):
    """
    Defines the url redirect action for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.UrlRedirectActionParametersResponse'):
        """
        Defines the url redirect action for the delivery rule.
        :param str name: The name of the action for the delivery rule.
               Expected value is 'UrlRedirect'.
        :param 'UrlRedirectActionParametersResponse' parameters: Defines the parameters for the action.
        """
        pulumi.set(__self__, "name", 'UrlRedirect')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the action for the delivery rule.
        Expected value is 'UrlRedirect'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.UrlRedirectActionParametersResponse':
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class UrlRewriteActionParametersResponse(dict):
    """
    Defines the parameters for the url rewrite action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourcePattern":
            suggest = "source_pattern"
        elif key == "typeName":
            suggest = "type_name"
        elif key == "preserveUnmatchedPath":
            suggest = "preserve_unmatched_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlRewriteActionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlRewriteActionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlRewriteActionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: str,
                 source_pattern: str,
                 type_name: str,
                 preserve_unmatched_path: Optional[bool] = None):
        """
        Defines the parameters for the url rewrite action.
        :param str destination: Define the relative URL to which the above requests will be rewritten by.
        :param str source_pattern: define a request URI pattern that identifies the type of requests that may be rewritten. If value is blank, all strings are matched.
        :param bool preserve_unmatched_path: Whether to preserve unmatched path. Default value is true.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "source_pattern", source_pattern)
        pulumi.set(__self__, "type_name", type_name)
        if preserve_unmatched_path is not None:
            pulumi.set(__self__, "preserve_unmatched_path", preserve_unmatched_path)

    @property
    @pulumi.getter
    def destination(self) -> str:
        """
        Define the relative URL to which the above requests will be rewritten by.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="sourcePattern")
    def source_pattern(self) -> str:
        """
        define a request URI pattern that identifies the type of requests that may be rewritten. If value is blank, all strings are matched.
        """
        return pulumi.get(self, "source_pattern")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="preserveUnmatchedPath")
    def preserve_unmatched_path(self) -> Optional[bool]:
        """
        Whether to preserve unmatched path. Default value is true.
        """
        return pulumi.get(self, "preserve_unmatched_path")


@pulumi.output_type
class UrlRewriteActionResponse(dict):
    """
    Defines the url rewrite action for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.UrlRewriteActionParametersResponse'):
        """
        Defines the url rewrite action for the delivery rule.
        :param str name: The name of the action for the delivery rule.
               Expected value is 'UrlRewrite'.
        :param 'UrlRewriteActionParametersResponse' parameters: Defines the parameters for the action.
        """
        pulumi.set(__self__, "name", 'UrlRewrite')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the action for the delivery rule.
        Expected value is 'UrlRewrite'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.UrlRewriteActionParametersResponse':
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class UrlSigningActionParametersResponse(dict):
    """
    Defines the parameters for the Url Signing action.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "parameterNameOverride":
            suggest = "parameter_name_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlSigningActionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlSigningActionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlSigningActionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_name: str,
                 algorithm: Optional[str] = None,
                 parameter_name_override: Optional[Sequence['outputs.UrlSigningParamIdentifierResponse']] = None):
        """
        Defines the parameters for the Url Signing action.
        :param str algorithm: Algorithm to use for URL signing
        :param Sequence['UrlSigningParamIdentifierResponse'] parameter_name_override: Defines which query string parameters in the url to be considered for expires, key id etc. 
        """
        pulumi.set(__self__, "type_name", type_name)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if parameter_name_override is not None:
            pulumi.set(__self__, "parameter_name_override", parameter_name_override)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[str]:
        """
        Algorithm to use for URL signing
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="parameterNameOverride")
    def parameter_name_override(self) -> Optional[Sequence['outputs.UrlSigningParamIdentifierResponse']]:
        """
        Defines which query string parameters in the url to be considered for expires, key id etc. 
        """
        return pulumi.get(self, "parameter_name_override")


@pulumi.output_type
class UrlSigningActionResponse(dict):
    """
    Defines the url signing action for the delivery rule.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: 'outputs.UrlSigningActionParametersResponse'):
        """
        Defines the url signing action for the delivery rule.
        :param str name: The name of the action for the delivery rule.
               Expected value is 'UrlSigning'.
        :param 'UrlSigningActionParametersResponse' parameters: Defines the parameters for the action.
        """
        pulumi.set(__self__, "name", 'UrlSigning')
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the action for the delivery rule.
        Expected value is 'UrlSigning'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> 'outputs.UrlSigningActionParametersResponse':
        """
        Defines the parameters for the action.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class UrlSigningKeyParametersResponse(dict):
    """
    Url signing key parameters
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"
        elif key == "secretSource":
            suggest = "secret_source"
        elif key == "secretVersion":
            suggest = "secret_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlSigningKeyParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlSigningKeyParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlSigningKeyParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_id: str,
                 secret_source: 'outputs.ResourceReferenceResponse',
                 type: str,
                 secret_version: Optional[str] = None):
        """
        Url signing key parameters
        :param str key_id: Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form the hash.
        :param 'ResourceReferenceResponse' secret_source: Resource reference to the Azure Key Vault secret. Expected to be in format of /subscriptions/{​​​​​​​​​subscriptionId}​​​​​​​​​/resourceGroups/{​​​​​​​​​resourceGroupName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/providers/Microsoft.KeyVault/vaults/{vaultName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/secrets/{secretName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
        :param str type: The type of the secret resource.
               Expected value is 'UrlSigningKey'.
        :param str secret_version: Version of the secret to be used
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "secret_source", secret_source)
        pulumi.set(__self__, "type", 'UrlSigningKey')
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> str:
        """
        Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form the hash.
        """
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter(name="secretSource")
    def secret_source(self) -> 'outputs.ResourceReferenceResponse':
        """
        Resource reference to the Azure Key Vault secret. Expected to be in format of /subscriptions/{​​​​​​​​​subscriptionId}​​​​​​​​​/resourceGroups/{​​​​​​​​​resourceGroupName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/providers/Microsoft.KeyVault/vaults/{vaultName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​/secrets/{secretName}​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
        """
        return pulumi.get(self, "secret_source")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the secret resource.
        Expected value is 'UrlSigningKey'.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[str]:
        """
        Version of the secret to be used
        """
        return pulumi.get(self, "secret_version")


@pulumi.output_type
class UrlSigningKeyResponse(dict):
    """
    Url signing key
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"
        elif key == "keySourceParameters":
            suggest = "key_source_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlSigningKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlSigningKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlSigningKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_id: str,
                 key_source_parameters: 'outputs.KeyVaultSigningKeyParametersResponse'):
        """
        Url signing key
        :param str key_id: Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form the hash.
        :param 'KeyVaultSigningKeyParametersResponse' key_source_parameters: Defines the parameters for using customer key vault for Url Signing Key.
        """
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "key_source_parameters", key_source_parameters)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> str:
        """
        Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form the hash.
        """
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter(name="keySourceParameters")
    def key_source_parameters(self) -> 'outputs.KeyVaultSigningKeyParametersResponse':
        """
        Defines the parameters for using customer key vault for Url Signing Key.
        """
        return pulumi.get(self, "key_source_parameters")


@pulumi.output_type
class UrlSigningParamIdentifierResponse(dict):
    """
    Defines how to identify a parameter for a specific purpose e.g. expires
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paramIndicator":
            suggest = "param_indicator"
        elif key == "paramName":
            suggest = "param_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlSigningParamIdentifierResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlSigningParamIdentifierResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlSigningParamIdentifierResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 param_indicator: str,
                 param_name: str):
        """
        Defines how to identify a parameter for a specific purpose e.g. expires
        :param str param_indicator: Indicates the purpose of the parameter
        :param str param_name: Parameter name
        """
        pulumi.set(__self__, "param_indicator", param_indicator)
        pulumi.set(__self__, "param_name", param_name)

    @property
    @pulumi.getter(name="paramIndicator")
    def param_indicator(self) -> str:
        """
        Indicates the purpose of the parameter
        """
        return pulumi.get(self, "param_indicator")

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> str:
        """
        Parameter name
        """
        return pulumi.get(self, "param_name")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        User assigned identity properties
        :param str client_id: The client ID of the assigned identity.
        :param str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class UserManagedHttpsParametersResponse(dict):
    """
    Defines the certificate source parameters using user's keyvault certificate for enabling SSL.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateSource":
            suggest = "certificate_source"
        elif key == "certificateSourceParameters":
            suggest = "certificate_source_parameters"
        elif key == "protocolType":
            suggest = "protocol_type"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserManagedHttpsParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserManagedHttpsParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserManagedHttpsParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_source: str,
                 certificate_source_parameters: 'outputs.KeyVaultCertificateSourceParametersResponse',
                 protocol_type: str,
                 minimum_tls_version: Optional[str] = None):
        """
        Defines the certificate source parameters using user's keyvault certificate for enabling SSL.
        :param str certificate_source: Defines the source of the SSL certificate.
               Expected value is 'AzureKeyVault'.
        :param 'KeyVaultCertificateSourceParametersResponse' certificate_source_parameters: Defines the certificate source parameters using user's keyvault certificate for enabling SSL.
        :param str protocol_type: Defines the TLS extension protocol that is used for secure delivery.
        :param str minimum_tls_version: TLS protocol version that will be used for Https
        """
        pulumi.set(__self__, "certificate_source", 'AzureKeyVault')
        pulumi.set(__self__, "certificate_source_parameters", certificate_source_parameters)
        pulumi.set(__self__, "protocol_type", protocol_type)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)

    @property
    @pulumi.getter(name="certificateSource")
    def certificate_source(self) -> str:
        """
        Defines the source of the SSL certificate.
        Expected value is 'AzureKeyVault'.
        """
        return pulumi.get(self, "certificate_source")

    @property
    @pulumi.getter(name="certificateSourceParameters")
    def certificate_source_parameters(self) -> 'outputs.KeyVaultCertificateSourceParametersResponse':
        """
        Defines the certificate source parameters using user's keyvault certificate for enabling SSL.
        """
        return pulumi.get(self, "certificate_source_parameters")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> str:
        """
        Defines the TLS extension protocol that is used for secure delivery.
        """
        return pulumi.get(self, "protocol_type")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        TLS protocol version that will be used for Https
        """
        return pulumi.get(self, "minimum_tls_version")


