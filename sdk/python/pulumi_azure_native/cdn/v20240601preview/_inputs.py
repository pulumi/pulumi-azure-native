# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AFDDomainHttpsCustomizedCipherSuiteSetArgs',
    'AFDDomainHttpsCustomizedCipherSuiteSetArgsDict',
    'AFDDomainHttpsParametersArgs',
    'AFDDomainHttpsParametersArgsDict',
    'AFDDomainMtlsParametersArgs',
    'AFDDomainMtlsParametersArgsDict',
    'ActivatedResourceReferenceArgs',
    'ActivatedResourceReferenceArgsDict',
    'AfdRouteCacheConfigurationArgs',
    'AfdRouteCacheConfigurationArgsDict',
    'CompressionSettingsArgs',
    'CompressionSettingsArgsDict',
    'ResourceReferenceArgs',
    'ResourceReferenceArgsDict',
    'TargetEndpointArgs',
    'TargetEndpointArgsDict',
]

MYPY = False

if not MYPY:
    class AFDDomainHttpsCustomizedCipherSuiteSetArgsDict(TypedDict):
        """
        Customized cipher suite set object that will be used for Https when cipherSuiteSetType is Customized.
        """
        cipher_suite_set_for_tls10: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls10']]]]]
        """
        Cipher suites for TLS 1.0. Required at least one in minimumTlsVersion TLS 1.0.
        """
        cipher_suite_set_for_tls12: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls12']]]]]
        """
        Cipher suites for TLS 1.2. Required at least one in minimumTlsVersion TLS 1.2, option in minimumTlsVersion TLS 1.0.
        """
        cipher_suite_set_for_tls13: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls13']]]]]
        """
        Cipher suites for TLS 1.3. Required at least one in minimumTlsVersion TLS 1.0, TLS 1.2, TLS 1.3.
        """
elif False:
    AFDDomainHttpsCustomizedCipherSuiteSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AFDDomainHttpsCustomizedCipherSuiteSetArgs:
    def __init__(__self__, *,
                 cipher_suite_set_for_tls10: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls10']]]]] = None,
                 cipher_suite_set_for_tls12: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls12']]]]] = None,
                 cipher_suite_set_for_tls13: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls13']]]]] = None):
        """
        Customized cipher suite set object that will be used for Https when cipherSuiteSetType is Customized.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls10']]]] cipher_suite_set_for_tls10: Cipher suites for TLS 1.0. Required at least one in minimumTlsVersion TLS 1.0.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls12']]]] cipher_suite_set_for_tls12: Cipher suites for TLS 1.2. Required at least one in minimumTlsVersion TLS 1.2, option in minimumTlsVersion TLS 1.0.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls13']]]] cipher_suite_set_for_tls13: Cipher suites for TLS 1.3. Required at least one in minimumTlsVersion TLS 1.0, TLS 1.2, TLS 1.3.
        """
        if cipher_suite_set_for_tls10 is not None:
            pulumi.set(__self__, "cipher_suite_set_for_tls10", cipher_suite_set_for_tls10)
        if cipher_suite_set_for_tls12 is not None:
            pulumi.set(__self__, "cipher_suite_set_for_tls12", cipher_suite_set_for_tls12)
        if cipher_suite_set_for_tls13 is not None:
            pulumi.set(__self__, "cipher_suite_set_for_tls13", cipher_suite_set_for_tls13)

    @property
    @pulumi.getter(name="cipherSuiteSetForTls10")
    def cipher_suite_set_for_tls10(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls10']]]]]:
        """
        Cipher suites for TLS 1.0. Required at least one in minimumTlsVersion TLS 1.0.
        """
        return pulumi.get(self, "cipher_suite_set_for_tls10")

    @cipher_suite_set_for_tls10.setter
    def cipher_suite_set_for_tls10(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls10']]]]]):
        pulumi.set(self, "cipher_suite_set_for_tls10", value)

    @property
    @pulumi.getter(name="cipherSuiteSetForTls12")
    def cipher_suite_set_for_tls12(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls12']]]]]:
        """
        Cipher suites for TLS 1.2. Required at least one in minimumTlsVersion TLS 1.2, option in minimumTlsVersion TLS 1.0.
        """
        return pulumi.get(self, "cipher_suite_set_for_tls12")

    @cipher_suite_set_for_tls12.setter
    def cipher_suite_set_for_tls12(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls12']]]]]):
        pulumi.set(self, "cipher_suite_set_for_tls12", value)

    @property
    @pulumi.getter(name="cipherSuiteSetForTls13")
    def cipher_suite_set_for_tls13(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls13']]]]]:
        """
        Cipher suites for TLS 1.3. Required at least one in minimumTlsVersion TLS 1.0, TLS 1.2, TLS 1.3.
        """
        return pulumi.get(self, "cipher_suite_set_for_tls13")

    @cipher_suite_set_for_tls13.setter
    def cipher_suite_set_for_tls13(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'AfdCustomizedCipherSuiteForTls13']]]]]):
        pulumi.set(self, "cipher_suite_set_for_tls13", value)


if not MYPY:
    class AFDDomainHttpsParametersArgsDict(TypedDict):
        """
        The JSON object that contains the properties to secure a domain.
        """
        certificate_type: pulumi.Input[Union[str, 'AfdCertificateType']]
        """
        Defines the source of the SSL certificate.
        """
        cipher_suite_set_type: NotRequired[pulumi.Input[Union[str, 'AfdCipherSuiteSetType']]]
        """
        cipher suite set type that will be used for Https
        """
        customized_cipher_suite_set: NotRequired[pulumi.Input['AFDDomainHttpsCustomizedCipherSuiteSetArgsDict']]
        """
        Customized cipher suites object that will be used for Https when cipherSuiteSetType is Customized.
        """
        minimum_tls_version: NotRequired[pulumi.Input['AfdMinimumTlsVersion']]
        """
        TLS protocol version that will be used for Https when cipherSuiteSetType is Customized.
        """
        secret: NotRequired[pulumi.Input['ResourceReferenceArgsDict']]
        """
        Resource reference to the secret. ie. subs/rg/profile/secret
        """
elif False:
    AFDDomainHttpsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AFDDomainHttpsParametersArgs:
    def __init__(__self__, *,
                 certificate_type: pulumi.Input[Union[str, 'AfdCertificateType']],
                 cipher_suite_set_type: Optional[pulumi.Input[Union[str, 'AfdCipherSuiteSetType']]] = None,
                 customized_cipher_suite_set: Optional[pulumi.Input['AFDDomainHttpsCustomizedCipherSuiteSetArgs']] = None,
                 minimum_tls_version: Optional[pulumi.Input['AfdMinimumTlsVersion']] = None,
                 secret: Optional[pulumi.Input['ResourceReferenceArgs']] = None):
        """
        The JSON object that contains the properties to secure a domain.
        :param pulumi.Input[Union[str, 'AfdCertificateType']] certificate_type: Defines the source of the SSL certificate.
        :param pulumi.Input[Union[str, 'AfdCipherSuiteSetType']] cipher_suite_set_type: cipher suite set type that will be used for Https
        :param pulumi.Input['AFDDomainHttpsCustomizedCipherSuiteSetArgs'] customized_cipher_suite_set: Customized cipher suites object that will be used for Https when cipherSuiteSetType is Customized.
        :param pulumi.Input['AfdMinimumTlsVersion'] minimum_tls_version: TLS protocol version that will be used for Https when cipherSuiteSetType is Customized.
        :param pulumi.Input['ResourceReferenceArgs'] secret: Resource reference to the secret. ie. subs/rg/profile/secret
        """
        pulumi.set(__self__, "certificate_type", certificate_type)
        if cipher_suite_set_type is not None:
            pulumi.set(__self__, "cipher_suite_set_type", cipher_suite_set_type)
        if customized_cipher_suite_set is not None:
            pulumi.set(__self__, "customized_cipher_suite_set", customized_cipher_suite_set)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> pulumi.Input[Union[str, 'AfdCertificateType']]:
        """
        Defines the source of the SSL certificate.
        """
        return pulumi.get(self, "certificate_type")

    @certificate_type.setter
    def certificate_type(self, value: pulumi.Input[Union[str, 'AfdCertificateType']]):
        pulumi.set(self, "certificate_type", value)

    @property
    @pulumi.getter(name="cipherSuiteSetType")
    def cipher_suite_set_type(self) -> Optional[pulumi.Input[Union[str, 'AfdCipherSuiteSetType']]]:
        """
        cipher suite set type that will be used for Https
        """
        return pulumi.get(self, "cipher_suite_set_type")

    @cipher_suite_set_type.setter
    def cipher_suite_set_type(self, value: Optional[pulumi.Input[Union[str, 'AfdCipherSuiteSetType']]]):
        pulumi.set(self, "cipher_suite_set_type", value)

    @property
    @pulumi.getter(name="customizedCipherSuiteSet")
    def customized_cipher_suite_set(self) -> Optional[pulumi.Input['AFDDomainHttpsCustomizedCipherSuiteSetArgs']]:
        """
        Customized cipher suites object that will be used for Https when cipherSuiteSetType is Customized.
        """
        return pulumi.get(self, "customized_cipher_suite_set")

    @customized_cipher_suite_set.setter
    def customized_cipher_suite_set(self, value: Optional[pulumi.Input['AFDDomainHttpsCustomizedCipherSuiteSetArgs']]):
        pulumi.set(self, "customized_cipher_suite_set", value)

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[pulumi.Input['AfdMinimumTlsVersion']]:
        """
        TLS protocol version that will be used for Https when cipherSuiteSetType is Customized.
        """
        return pulumi.get(self, "minimum_tls_version")

    @minimum_tls_version.setter
    def minimum_tls_version(self, value: Optional[pulumi.Input['AfdMinimumTlsVersion']]):
        pulumi.set(self, "minimum_tls_version", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ResourceReferenceArgs']]:
        """
        Resource reference to the secret. ie. subs/rg/profile/secret
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ResourceReferenceArgs']]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class AFDDomainMtlsParametersArgsDict(TypedDict):
        """
        The JSON object that contains the properties to configure mutual TLS for a custom domain with FQDN. Mutual TLS cannot be configured for custom domains with wildcard host names.
        """
        certificate_passthrough: NotRequired[pulumi.Input[Union[str, 'EnabledState']]]
        """
        Set to Disabled by default. If set to Enabled, then selected client certificate chain(s) are sent directly to origin using reserved header.
        """
        certificate_validation: NotRequired[pulumi.Input[Union[str, 'EnabledState']]]
        """
        Set to Enabled by default. If set to Disabled, validation of client certificate chain for mutual TLS handshake will be skipped.
        """
        ocsp: NotRequired[pulumi.Input[Union[str, 'EnabledState']]]
        """
        Set to Enabled by default. If set to Disabled, revocation status of client certificate chain will be checked before establishing mutual TLS connection.
        """
        other_allowed_fqdn: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of FQDN that will be accepted for mutual TLS validation in addition to custom domain's hostname.
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResourceReferenceArgsDict']]]]
        """
        List of one or two of Resource References (ie. subs/rg/profile/secret) to Secrets of type MtlsCertificateChain to use in mutual TLS handshake.
        """
elif False:
    AFDDomainMtlsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AFDDomainMtlsParametersArgs:
    def __init__(__self__, *,
                 certificate_passthrough: Optional[pulumi.Input[Union[str, 'EnabledState']]] = None,
                 certificate_validation: Optional[pulumi.Input[Union[str, 'EnabledState']]] = None,
                 ocsp: Optional[pulumi.Input[Union[str, 'EnabledState']]] = None,
                 other_allowed_fqdn: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceReferenceArgs']]]] = None):
        """
        The JSON object that contains the properties to configure mutual TLS for a custom domain with FQDN. Mutual TLS cannot be configured for custom domains with wildcard host names.
        :param pulumi.Input[Union[str, 'EnabledState']] certificate_passthrough: Set to Disabled by default. If set to Enabled, then selected client certificate chain(s) are sent directly to origin using reserved header.
        :param pulumi.Input[Union[str, 'EnabledState']] certificate_validation: Set to Enabled by default. If set to Disabled, validation of client certificate chain for mutual TLS handshake will be skipped.
        :param pulumi.Input[Union[str, 'EnabledState']] ocsp: Set to Enabled by default. If set to Disabled, revocation status of client certificate chain will be checked before establishing mutual TLS connection.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] other_allowed_fqdn: List of FQDN that will be accepted for mutual TLS validation in addition to custom domain's hostname.
        :param pulumi.Input[Sequence[pulumi.Input['ResourceReferenceArgs']]] secrets: List of one or two of Resource References (ie. subs/rg/profile/secret) to Secrets of type MtlsCertificateChain to use in mutual TLS handshake.
        """
        if certificate_passthrough is not None:
            pulumi.set(__self__, "certificate_passthrough", certificate_passthrough)
        if certificate_validation is not None:
            pulumi.set(__self__, "certificate_validation", certificate_validation)
        if ocsp is not None:
            pulumi.set(__self__, "ocsp", ocsp)
        if other_allowed_fqdn is not None:
            pulumi.set(__self__, "other_allowed_fqdn", other_allowed_fqdn)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter(name="certificatePassthrough")
    def certificate_passthrough(self) -> Optional[pulumi.Input[Union[str, 'EnabledState']]]:
        """
        Set to Disabled by default. If set to Enabled, then selected client certificate chain(s) are sent directly to origin using reserved header.
        """
        return pulumi.get(self, "certificate_passthrough")

    @certificate_passthrough.setter
    def certificate_passthrough(self, value: Optional[pulumi.Input[Union[str, 'EnabledState']]]):
        pulumi.set(self, "certificate_passthrough", value)

    @property
    @pulumi.getter(name="certificateValidation")
    def certificate_validation(self) -> Optional[pulumi.Input[Union[str, 'EnabledState']]]:
        """
        Set to Enabled by default. If set to Disabled, validation of client certificate chain for mutual TLS handshake will be skipped.
        """
        return pulumi.get(self, "certificate_validation")

    @certificate_validation.setter
    def certificate_validation(self, value: Optional[pulumi.Input[Union[str, 'EnabledState']]]):
        pulumi.set(self, "certificate_validation", value)

    @property
    @pulumi.getter
    def ocsp(self) -> Optional[pulumi.Input[Union[str, 'EnabledState']]]:
        """
        Set to Enabled by default. If set to Disabled, revocation status of client certificate chain will be checked before establishing mutual TLS connection.
        """
        return pulumi.get(self, "ocsp")

    @ocsp.setter
    def ocsp(self, value: Optional[pulumi.Input[Union[str, 'EnabledState']]]):
        pulumi.set(self, "ocsp", value)

    @property
    @pulumi.getter(name="otherAllowedFqdn")
    def other_allowed_fqdn(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of FQDN that will be accepted for mutual TLS validation in addition to custom domain's hostname.
        """
        return pulumi.get(self, "other_allowed_fqdn")

    @other_allowed_fqdn.setter
    def other_allowed_fqdn(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "other_allowed_fqdn", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourceReferenceArgs']]]]:
        """
        List of one or two of Resource References (ie. subs/rg/profile/secret) to Secrets of type MtlsCertificateChain to use in mutual TLS handshake.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceReferenceArgs']]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class ActivatedResourceReferenceArgsDict(TypedDict):
        """
        Reference to another resource along with its state.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Resource ID.
        """
elif False:
    ActivatedResourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActivatedResourceReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Reference to another resource along with its state.
        :param pulumi.Input[str] id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AfdRouteCacheConfigurationArgsDict(TypedDict):
        """
        Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
        """
        compression_settings: NotRequired[pulumi.Input['CompressionSettingsArgsDict']]
        """
        compression settings.
        """
        query_parameters: NotRequired[pulumi.Input[str]]
        """
        query parameters to include or exclude (comma separated).
        """
        query_string_caching_behavior: NotRequired[pulumi.Input[Union[str, 'AfdQueryStringCachingBehavior']]]
        """
        Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
        """
elif False:
    AfdRouteCacheConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AfdRouteCacheConfigurationArgs:
    def __init__(__self__, *,
                 compression_settings: Optional[pulumi.Input['CompressionSettingsArgs']] = None,
                 query_parameters: Optional[pulumi.Input[str]] = None,
                 query_string_caching_behavior: Optional[pulumi.Input[Union[str, 'AfdQueryStringCachingBehavior']]] = None):
        """
        Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
        :param pulumi.Input['CompressionSettingsArgs'] compression_settings: compression settings.
        :param pulumi.Input[str] query_parameters: query parameters to include or exclude (comma separated).
        :param pulumi.Input[Union[str, 'AfdQueryStringCachingBehavior']] query_string_caching_behavior: Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
        """
        if compression_settings is not None:
            pulumi.set(__self__, "compression_settings", compression_settings)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if query_string_caching_behavior is not None:
            pulumi.set(__self__, "query_string_caching_behavior", query_string_caching_behavior)

    @property
    @pulumi.getter(name="compressionSettings")
    def compression_settings(self) -> Optional[pulumi.Input['CompressionSettingsArgs']]:
        """
        compression settings.
        """
        return pulumi.get(self, "compression_settings")

    @compression_settings.setter
    def compression_settings(self, value: Optional[pulumi.Input['CompressionSettingsArgs']]):
        pulumi.set(self, "compression_settings", value)

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[pulumi.Input[str]]:
        """
        query parameters to include or exclude (comma separated).
        """
        return pulumi.get(self, "query_parameters")

    @query_parameters.setter
    def query_parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_parameters", value)

    @property
    @pulumi.getter(name="queryStringCachingBehavior")
    def query_string_caching_behavior(self) -> Optional[pulumi.Input[Union[str, 'AfdQueryStringCachingBehavior']]]:
        """
        Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
        """
        return pulumi.get(self, "query_string_caching_behavior")

    @query_string_caching_behavior.setter
    def query_string_caching_behavior(self, value: Optional[pulumi.Input[Union[str, 'AfdQueryStringCachingBehavior']]]):
        pulumi.set(self, "query_string_caching_behavior", value)


if not MYPY:
    class CompressionSettingsArgsDict(TypedDict):
        """
        settings for compression.
        """
        content_types_to_compress: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of content types on which compression applies. The value should be a valid MIME type.
        """
        is_compression_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        """
elif False:
    CompressionSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CompressionSettingsArgs:
    def __init__(__self__, *,
                 content_types_to_compress: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_compression_enabled: Optional[pulumi.Input[bool]] = None):
        """
        settings for compression.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] content_types_to_compress: List of content types on which compression applies. The value should be a valid MIME type.
        :param pulumi.Input[bool] is_compression_enabled: Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        """
        if content_types_to_compress is not None:
            pulumi.set(__self__, "content_types_to_compress", content_types_to_compress)
        if is_compression_enabled is not None:
            pulumi.set(__self__, "is_compression_enabled", is_compression_enabled)

    @property
    @pulumi.getter(name="contentTypesToCompress")
    def content_types_to_compress(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of content types on which compression applies. The value should be a valid MIME type.
        """
        return pulumi.get(self, "content_types_to_compress")

    @content_types_to_compress.setter
    def content_types_to_compress(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "content_types_to_compress", value)

    @property
    @pulumi.getter(name="isCompressionEnabled")
    def is_compression_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        """
        return pulumi.get(self, "is_compression_enabled")

    @is_compression_enabled.setter
    def is_compression_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_compression_enabled", value)


if not MYPY:
    class ResourceReferenceArgsDict(TypedDict):
        """
        Reference to another resource.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Resource ID.
        """
elif False:
    ResourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceReferenceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        Reference to another resource.
        :param pulumi.Input[str] id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class TargetEndpointArgsDict(TypedDict):
        """
        TargetEndpoint object that forms a traffic endpoint.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The Ports to be allowed for the FQDN.
        """
        target_fqdn: NotRequired[pulumi.Input[str]]
        """
        The FQDN for traffic endpoint.
        """
elif False:
    TargetEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetEndpointArgs:
    def __init__(__self__, *,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 target_fqdn: Optional[pulumi.Input[str]] = None):
        """
        TargetEndpoint object that forms a traffic endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: The Ports to be allowed for the FQDN.
        :param pulumi.Input[str] target_fqdn: The FQDN for traffic endpoint.
        """
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if target_fqdn is not None:
            pulumi.set(__self__, "target_fqdn", target_fqdn)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The Ports to be allowed for the FQDN.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter(name="targetFqdn")
    def target_fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        The FQDN for traffic endpoint.
        """
        return pulumi.get(self, "target_fqdn")

    @target_fqdn.setter
    def target_fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_fqdn", value)


