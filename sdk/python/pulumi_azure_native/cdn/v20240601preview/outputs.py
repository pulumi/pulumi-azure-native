# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AFDDomainHttpsCustomizedCipherSuiteSetResponse',
    'AFDDomainHttpsParametersResponse',
    'AFDDomainMtlsParametersResponse',
    'AFDDomainReferencedRoutePathResponse',
    'ActivatedResourceReferenceResponse',
    'AfdRouteCacheConfigurationResponse',
    'CompressionSettingsResponse',
    'DomainValidationPropertiesResponse',
    'ResourceReferenceResponse',
    'SystemDataResponse',
    'TargetEndpointResponse',
]

@pulumi.output_type
class AFDDomainHttpsCustomizedCipherSuiteSetResponse(dict):
    """
    Customized cipher suite set object that will be used for Https when cipherSuiteSetType is Customized.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cipherSuiteSetForTls10":
            suggest = "cipher_suite_set_for_tls10"
        elif key == "cipherSuiteSetForTls12":
            suggest = "cipher_suite_set_for_tls12"
        elif key == "cipherSuiteSetForTls13":
            suggest = "cipher_suite_set_for_tls13"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AFDDomainHttpsCustomizedCipherSuiteSetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AFDDomainHttpsCustomizedCipherSuiteSetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AFDDomainHttpsCustomizedCipherSuiteSetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cipher_suite_set_for_tls10: Optional[Sequence[str]] = None,
                 cipher_suite_set_for_tls12: Optional[Sequence[str]] = None,
                 cipher_suite_set_for_tls13: Optional[Sequence[str]] = None):
        """
        Customized cipher suite set object that will be used for Https when cipherSuiteSetType is Customized.
        :param Sequence[str] cipher_suite_set_for_tls10: Cipher suites for TLS 1.0. Required at least one in minimumTlsVersion TLS 1.0.
        :param Sequence[str] cipher_suite_set_for_tls12: Cipher suites for TLS 1.2. Required at least one in minimumTlsVersion TLS 1.2, option in minimumTlsVersion TLS 1.0.
        :param Sequence[str] cipher_suite_set_for_tls13: Cipher suites for TLS 1.3. Required at least one in minimumTlsVersion TLS 1.0, TLS 1.2, TLS 1.3.
        """
        if cipher_suite_set_for_tls10 is not None:
            pulumi.set(__self__, "cipher_suite_set_for_tls10", cipher_suite_set_for_tls10)
        if cipher_suite_set_for_tls12 is not None:
            pulumi.set(__self__, "cipher_suite_set_for_tls12", cipher_suite_set_for_tls12)
        if cipher_suite_set_for_tls13 is not None:
            pulumi.set(__self__, "cipher_suite_set_for_tls13", cipher_suite_set_for_tls13)

    @property
    @pulumi.getter(name="cipherSuiteSetForTls10")
    def cipher_suite_set_for_tls10(self) -> Optional[Sequence[str]]:
        """
        Cipher suites for TLS 1.0. Required at least one in minimumTlsVersion TLS 1.0.
        """
        return pulumi.get(self, "cipher_suite_set_for_tls10")

    @property
    @pulumi.getter(name="cipherSuiteSetForTls12")
    def cipher_suite_set_for_tls12(self) -> Optional[Sequence[str]]:
        """
        Cipher suites for TLS 1.2. Required at least one in minimumTlsVersion TLS 1.2, option in minimumTlsVersion TLS 1.0.
        """
        return pulumi.get(self, "cipher_suite_set_for_tls12")

    @property
    @pulumi.getter(name="cipherSuiteSetForTls13")
    def cipher_suite_set_for_tls13(self) -> Optional[Sequence[str]]:
        """
        Cipher suites for TLS 1.3. Required at least one in minimumTlsVersion TLS 1.0, TLS 1.2, TLS 1.3.
        """
        return pulumi.get(self, "cipher_suite_set_for_tls13")


@pulumi.output_type
class AFDDomainHttpsParametersResponse(dict):
    """
    The JSON object that contains the properties to secure a domain.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateType":
            suggest = "certificate_type"
        elif key == "cipherSuiteSetType":
            suggest = "cipher_suite_set_type"
        elif key == "customizedCipherSuiteSet":
            suggest = "customized_cipher_suite_set"
        elif key == "minimumTlsVersion":
            suggest = "minimum_tls_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AFDDomainHttpsParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AFDDomainHttpsParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AFDDomainHttpsParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_type: str,
                 cipher_suite_set_type: Optional[str] = None,
                 customized_cipher_suite_set: Optional['outputs.AFDDomainHttpsCustomizedCipherSuiteSetResponse'] = None,
                 minimum_tls_version: Optional[str] = None,
                 secret: Optional['outputs.ResourceReferenceResponse'] = None):
        """
        The JSON object that contains the properties to secure a domain.
        :param str certificate_type: Defines the source of the SSL certificate.
        :param str cipher_suite_set_type: cipher suite set type that will be used for Https
        :param 'AFDDomainHttpsCustomizedCipherSuiteSetResponse' customized_cipher_suite_set: Customized cipher suites object that will be used for Https when cipherSuiteSetType is Customized.
        :param str minimum_tls_version: TLS protocol version that will be used for Https when cipherSuiteSetType is Customized.
        :param 'ResourceReferenceResponse' secret: Resource reference to the secret. ie. subs/rg/profile/secret
        """
        pulumi.set(__self__, "certificate_type", certificate_type)
        if cipher_suite_set_type is not None:
            pulumi.set(__self__, "cipher_suite_set_type", cipher_suite_set_type)
        if customized_cipher_suite_set is not None:
            pulumi.set(__self__, "customized_cipher_suite_set", customized_cipher_suite_set)
        if minimum_tls_version is not None:
            pulumi.set(__self__, "minimum_tls_version", minimum_tls_version)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> str:
        """
        Defines the source of the SSL certificate.
        """
        return pulumi.get(self, "certificate_type")

    @property
    @pulumi.getter(name="cipherSuiteSetType")
    def cipher_suite_set_type(self) -> Optional[str]:
        """
        cipher suite set type that will be used for Https
        """
        return pulumi.get(self, "cipher_suite_set_type")

    @property
    @pulumi.getter(name="customizedCipherSuiteSet")
    def customized_cipher_suite_set(self) -> Optional['outputs.AFDDomainHttpsCustomizedCipherSuiteSetResponse']:
        """
        Customized cipher suites object that will be used for Https when cipherSuiteSetType is Customized.
        """
        return pulumi.get(self, "customized_cipher_suite_set")

    @property
    @pulumi.getter(name="minimumTlsVersion")
    def minimum_tls_version(self) -> Optional[str]:
        """
        TLS protocol version that will be used for Https when cipherSuiteSetType is Customized.
        """
        return pulumi.get(self, "minimum_tls_version")

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ResourceReferenceResponse']:
        """
        Resource reference to the secret. ie. subs/rg/profile/secret
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class AFDDomainMtlsParametersResponse(dict):
    """
    The JSON object that contains the properties to configure mutual TLS for a custom domain with FQDN. Mutual TLS cannot be configured for custom domains with wildcard host names.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificatePassthrough":
            suggest = "certificate_passthrough"
        elif key == "certificateValidation":
            suggest = "certificate_validation"
        elif key == "otherAllowedFqdn":
            suggest = "other_allowed_fqdn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AFDDomainMtlsParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AFDDomainMtlsParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AFDDomainMtlsParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_passthrough: Optional[str] = None,
                 certificate_validation: Optional[str] = None,
                 ocsp: Optional[str] = None,
                 other_allowed_fqdn: Optional[Sequence[str]] = None,
                 secrets: Optional[Sequence['outputs.ResourceReferenceResponse']] = None):
        """
        The JSON object that contains the properties to configure mutual TLS for a custom domain with FQDN. Mutual TLS cannot be configured for custom domains with wildcard host names.
        :param str certificate_passthrough: Set to Disabled by default. If set to Enabled, then selected client certificate chain(s) are sent directly to origin using reserved header.
        :param str certificate_validation: Set to Enabled by default. If set to Disabled, validation of client certificate chain for mutual TLS handshake will be skipped.
        :param str ocsp: Set to Enabled by default. If set to Disabled, revocation status of client certificate chain will be checked before establishing mutual TLS connection.
        :param Sequence[str] other_allowed_fqdn: List of FQDN that will be accepted for mutual TLS validation in addition to custom domain's hostname.
        :param Sequence['ResourceReferenceResponse'] secrets: List of one or two of Resource References (ie. subs/rg/profile/secret) to Secrets of type MtlsCertificateChain to use in mutual TLS handshake.
        """
        if certificate_passthrough is not None:
            pulumi.set(__self__, "certificate_passthrough", certificate_passthrough)
        if certificate_validation is not None:
            pulumi.set(__self__, "certificate_validation", certificate_validation)
        if ocsp is not None:
            pulumi.set(__self__, "ocsp", ocsp)
        if other_allowed_fqdn is not None:
            pulumi.set(__self__, "other_allowed_fqdn", other_allowed_fqdn)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter(name="certificatePassthrough")
    def certificate_passthrough(self) -> Optional[str]:
        """
        Set to Disabled by default. If set to Enabled, then selected client certificate chain(s) are sent directly to origin using reserved header.
        """
        return pulumi.get(self, "certificate_passthrough")

    @property
    @pulumi.getter(name="certificateValidation")
    def certificate_validation(self) -> Optional[str]:
        """
        Set to Enabled by default. If set to Disabled, validation of client certificate chain for mutual TLS handshake will be skipped.
        """
        return pulumi.get(self, "certificate_validation")

    @property
    @pulumi.getter
    def ocsp(self) -> Optional[str]:
        """
        Set to Enabled by default. If set to Disabled, revocation status of client certificate chain will be checked before establishing mutual TLS connection.
        """
        return pulumi.get(self, "ocsp")

    @property
    @pulumi.getter(name="otherAllowedFqdn")
    def other_allowed_fqdn(self) -> Optional[Sequence[str]]:
        """
        List of FQDN that will be accepted for mutual TLS validation in addition to custom domain's hostname.
        """
        return pulumi.get(self, "other_allowed_fqdn")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.ResourceReferenceResponse']]:
        """
        List of one or two of Resource References (ie. subs/rg/profile/secret) to Secrets of type MtlsCertificateChain to use in mutual TLS handshake.
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class AFDDomainReferencedRoutePathResponse(dict):
    """
    route configuration of the shared custom domain.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeId":
            suggest = "route_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AFDDomainReferencedRoutePathResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AFDDomainReferencedRoutePathResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AFDDomainReferencedRoutePathResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 paths: Optional[Sequence[str]] = None,
                 route_id: Optional['outputs.ResourceReferenceResponse'] = None):
        """
        route configuration of the shared custom domain.
        :param Sequence[str] paths: List of paths of the route.
        :param 'ResourceReferenceResponse' route_id: Resource reference to the route.
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if route_id is not None:
            pulumi.set(__self__, "route_id", route_id)

    @property
    @pulumi.getter
    def paths(self) -> Optional[Sequence[str]]:
        """
        List of paths of the route.
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="routeId")
    def route_id(self) -> Optional['outputs.ResourceReferenceResponse']:
        """
        Resource reference to the route.
        """
        return pulumi.get(self, "route_id")


@pulumi.output_type
class ActivatedResourceReferenceResponse(dict):
    """
    Reference to another resource along with its state.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isActive":
            suggest = "is_active"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActivatedResourceReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActivatedResourceReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActivatedResourceReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_active: bool,
                 id: Optional[str] = None):
        """
        Reference to another resource along with its state.
        :param bool is_active: Whether the resource is active or inactive
        :param str id: Resource ID.
        """
        pulumi.set(__self__, "is_active", is_active)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> bool:
        """
        Whether the resource is active or inactive
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class AfdRouteCacheConfigurationResponse(dict):
    """
    Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionSettings":
            suggest = "compression_settings"
        elif key == "queryParameters":
            suggest = "query_parameters"
        elif key == "queryStringCachingBehavior":
            suggest = "query_string_caching_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AfdRouteCacheConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AfdRouteCacheConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AfdRouteCacheConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_settings: Optional['outputs.CompressionSettingsResponse'] = None,
                 query_parameters: Optional[str] = None,
                 query_string_caching_behavior: Optional[str] = None):
        """
        Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
        :param 'CompressionSettingsResponse' compression_settings: compression settings.
        :param str query_parameters: query parameters to include or exclude (comma separated).
        :param str query_string_caching_behavior: Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
        """
        if compression_settings is not None:
            pulumi.set(__self__, "compression_settings", compression_settings)
        if query_parameters is not None:
            pulumi.set(__self__, "query_parameters", query_parameters)
        if query_string_caching_behavior is not None:
            pulumi.set(__self__, "query_string_caching_behavior", query_string_caching_behavior)

    @property
    @pulumi.getter(name="compressionSettings")
    def compression_settings(self) -> Optional['outputs.CompressionSettingsResponse']:
        """
        compression settings.
        """
        return pulumi.get(self, "compression_settings")

    @property
    @pulumi.getter(name="queryParameters")
    def query_parameters(self) -> Optional[str]:
        """
        query parameters to include or exclude (comma separated).
        """
        return pulumi.get(self, "query_parameters")

    @property
    @pulumi.getter(name="queryStringCachingBehavior")
    def query_string_caching_behavior(self) -> Optional[str]:
        """
        Defines how Frontdoor caches requests that include query strings. You can ignore any query strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query strings.
        """
        return pulumi.get(self, "query_string_caching_behavior")


@pulumi.output_type
class CompressionSettingsResponse(dict):
    """
    settings for compression.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentTypesToCompress":
            suggest = "content_types_to_compress"
        elif key == "isCompressionEnabled":
            suggest = "is_compression_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CompressionSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CompressionSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CompressionSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_types_to_compress: Optional[Sequence[str]] = None,
                 is_compression_enabled: Optional[bool] = None):
        """
        settings for compression.
        :param Sequence[str] content_types_to_compress: List of content types on which compression applies. The value should be a valid MIME type.
        :param bool is_compression_enabled: Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        """
        if content_types_to_compress is not None:
            pulumi.set(__self__, "content_types_to_compress", content_types_to_compress)
        if is_compression_enabled is not None:
            pulumi.set(__self__, "is_compression_enabled", is_compression_enabled)

    @property
    @pulumi.getter(name="contentTypesToCompress")
    def content_types_to_compress(self) -> Optional[Sequence[str]]:
        """
        List of content types on which compression applies. The value should be a valid MIME type.
        """
        return pulumi.get(self, "content_types_to_compress")

    @property
    @pulumi.getter(name="isCompressionEnabled")
    def is_compression_enabled(self) -> Optional[bool]:
        """
        Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when requested content is smaller than 1 byte or larger than 1 MB.
        """
        return pulumi.get(self, "is_compression_enabled")


@pulumi.output_type
class DomainValidationPropertiesResponse(dict):
    """
    The JSON object that contains the properties to validate a domain.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationDate":
            suggest = "expiration_date"
        elif key == "validationToken":
            suggest = "validation_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainValidationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainValidationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainValidationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expiration_date: str,
                 validation_token: str):
        """
        The JSON object that contains the properties to validate a domain.
        :param str expiration_date: The date time that the token expires
        :param str validation_token: Challenge used for DNS TXT record or file based validation
        """
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "validation_token", validation_token)

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> str:
        """
        The date time that the token expires
        """
        return pulumi.get(self, "expiration_date")

    @property
    @pulumi.getter(name="validationToken")
    def validation_token(self) -> str:
        """
        Challenge used for DNS TXT record or file based validation
        """
        return pulumi.get(self, "validation_token")


@pulumi.output_type
class ResourceReferenceResponse(dict):
    """
    Reference to another resource.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Reference to another resource.
        :param str id: Resource ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Read only system data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Read only system data
        :param str created_at: The timestamp of resource creation (UTC)
        :param str created_by: An identifier for the identity that created the resource
        :param str created_by_type: The type of identity that created the resource
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: An identifier for the identity that last modified the resource
        :param str last_modified_by_type: The type of identity that last modified the resource
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC)
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        An identifier for the identity that created the resource
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        An identifier for the identity that last modified the resource
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TargetEndpointResponse(dict):
    """
    TargetEndpoint object that forms a traffic endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetFqdn":
            suggest = "target_fqdn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ports: Optional[Sequence[int]] = None,
                 target_fqdn: Optional[str] = None):
        """
        TargetEndpoint object that forms a traffic endpoint.
        :param Sequence[int] ports: The Ports to be allowed for the FQDN.
        :param str target_fqdn: The FQDN for traffic endpoint.
        """
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if target_fqdn is not None:
            pulumi.set(__self__, "target_fqdn", target_fqdn)

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[int]]:
        """
        The Ports to be allowed for the FQDN.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="targetFqdn")
    def target_fqdn(self) -> Optional[str]:
        """
        The FQDN for traffic endpoint.
        """
        return pulumi.get(self, "target_fqdn")


