# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ExecutionParametersArgs',
    'ExecutionParametersArgsDict',
    'NotificationPropertiesArgs',
    'NotificationPropertiesArgsDict',
    'RetryPolicyArgs',
    'RetryPolicyArgsDict',
    'ScheduledActionPropertiesArgs',
    'ScheduledActionPropertiesArgsDict',
    'ScheduledActionsScheduleArgs',
    'ScheduledActionsScheduleArgsDict',
]

MYPY = False

if not MYPY:
    class ExecutionParametersArgsDict(TypedDict):
        """
        Extra details needed to run the user's request
        """
        optimization_preference: NotRequired[pulumi.Input[Union[builtins.str, 'OptimizationPreference']]]
        """
        Details that could optimize the user's request
        """
        retry_policy: NotRequired[pulumi.Input['RetryPolicyArgsDict']]
        """
        Retry policy the user can pass
        """
elif False:
    ExecutionParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExecutionParametersArgs:
    def __init__(__self__, *,
                 optimization_preference: Optional[pulumi.Input[Union[builtins.str, 'OptimizationPreference']]] = None,
                 retry_policy: Optional[pulumi.Input['RetryPolicyArgs']] = None):
        """
        Extra details needed to run the user's request
        :param pulumi.Input[Union[builtins.str, 'OptimizationPreference']] optimization_preference: Details that could optimize the user's request
        :param pulumi.Input['RetryPolicyArgs'] retry_policy: Retry policy the user can pass
        """
        if optimization_preference is not None:
            pulumi.set(__self__, "optimization_preference", optimization_preference)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)

    @property
    @pulumi.getter(name="optimizationPreference")
    def optimization_preference(self) -> Optional[pulumi.Input[Union[builtins.str, 'OptimizationPreference']]]:
        """
        Details that could optimize the user's request
        """
        return pulumi.get(self, "optimization_preference")

    @optimization_preference.setter
    def optimization_preference(self, value: Optional[pulumi.Input[Union[builtins.str, 'OptimizationPreference']]]):
        pulumi.set(self, "optimization_preference", value)

    @property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional[pulumi.Input['RetryPolicyArgs']]:
        """
        Retry policy the user can pass
        """
        return pulumi.get(self, "retry_policy")

    @retry_policy.setter
    def retry_policy(self, value: Optional[pulumi.Input['RetryPolicyArgs']]):
        pulumi.set(self, "retry_policy", value)


if not MYPY:
    class NotificationPropertiesArgsDict(TypedDict):
        """
        The information about notifications to be send to about upcoming operations.
        """
        destination: pulumi.Input[builtins.str]
        """
        Where the notification should be sent. For email, it should follow email format.
        """
        language: pulumi.Input[Union[builtins.str, 'Language']]
        """
        The language the notification should be sent on.
        """
        type: pulumi.Input[Union[builtins.str, 'NotificationType']]
        """
        Type of notification to be sent.
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Tells if the notification is enabled or not.
        """
elif False:
    NotificationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationPropertiesArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[builtins.str],
                 language: pulumi.Input[Union[builtins.str, 'Language']],
                 type: pulumi.Input[Union[builtins.str, 'NotificationType']],
                 disabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        The information about notifications to be send to about upcoming operations.
        :param pulumi.Input[builtins.str] destination: Where the notification should be sent. For email, it should follow email format.
        :param pulumi.Input[Union[builtins.str, 'Language']] language: The language the notification should be sent on.
        :param pulumi.Input[Union[builtins.str, 'NotificationType']] type: Type of notification to be sent.
        :param pulumi.Input[builtins.bool] disabled: Tells if the notification is enabled or not.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "language", language)
        pulumi.set(__self__, "type", type)
        if disabled is None:
            disabled = False
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[builtins.str]:
        """
        Where the notification should be sent. For email, it should follow email format.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def language(self) -> pulumi.Input[Union[builtins.str, 'Language']]:
        """
        The language the notification should be sent on.
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: pulumi.Input[Union[builtins.str, 'Language']]):
        pulumi.set(self, "language", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[builtins.str, 'NotificationType']]:
        """
        Type of notification to be sent.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[builtins.str, 'NotificationType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Tells if the notification is enabled or not.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class RetryPolicyArgsDict(TypedDict):
        """
        The retry policy for the user request
        """
        retry_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Retry count for user request
        """
        retry_window_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Retry window in minutes for user request
        """
elif False:
    RetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RetryPolicyArgs:
    def __init__(__self__, *,
                 retry_count: Optional[pulumi.Input[builtins.int]] = None,
                 retry_window_in_minutes: Optional[pulumi.Input[builtins.int]] = None):
        """
        The retry policy for the user request
        :param pulumi.Input[builtins.int] retry_count: Retry count for user request
        :param pulumi.Input[builtins.int] retry_window_in_minutes: Retry window in minutes for user request
        """
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if retry_window_in_minutes is not None:
            pulumi.set(__self__, "retry_window_in_minutes", retry_window_in_minutes)

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Retry count for user request
        """
        return pulumi.get(self, "retry_count")

    @retry_count.setter
    def retry_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retry_count", value)

    @property
    @pulumi.getter(name="retryWindowInMinutes")
    def retry_window_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Retry window in minutes for user request
        """
        return pulumi.get(self, "retry_window_in_minutes")

    @retry_window_in_minutes.setter
    def retry_window_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retry_window_in_minutes", value)


if not MYPY:
    class ScheduledActionPropertiesArgsDict(TypedDict):
        """
        Scheduled action properties
        """
        action_type: pulumi.Input[Union[builtins.str, 'ActionType']]
        """
        The action the scheduled action should perform in the resources
        """
        notification_settings: pulumi.Input[Sequence[pulumi.Input['NotificationPropertiesArgsDict']]]
        """
        The notification settings for the scheduled action
        """
        resource_type: pulumi.Input[Union[builtins.str, 'ResourceType']]
        """
        The type of resource the scheduled action is targeting
        """
        schedule: pulumi.Input['ScheduledActionsScheduleArgsDict']
        """
        The schedule the scheduled action is supposed to follow
        """
        start_time: pulumi.Input[builtins.str]
        """
        The time which the scheduled action is supposed to start running
        """
        disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Tell if the scheduled action is disabled or not
        """
        end_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The time when the scheduled action is supposed to stop scheduling
        """
elif False:
    ScheduledActionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledActionPropertiesArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[Union[builtins.str, 'ActionType']],
                 notification_settings: pulumi.Input[Sequence[pulumi.Input['NotificationPropertiesArgs']]],
                 resource_type: pulumi.Input[Union[builtins.str, 'ResourceType']],
                 schedule: pulumi.Input['ScheduledActionsScheduleArgs'],
                 start_time: pulumi.Input[builtins.str],
                 disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 end_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        Scheduled action properties
        :param pulumi.Input[Union[builtins.str, 'ActionType']] action_type: The action the scheduled action should perform in the resources
        :param pulumi.Input[Sequence[pulumi.Input['NotificationPropertiesArgs']]] notification_settings: The notification settings for the scheduled action
        :param pulumi.Input[Union[builtins.str, 'ResourceType']] resource_type: The type of resource the scheduled action is targeting
        :param pulumi.Input['ScheduledActionsScheduleArgs'] schedule: The schedule the scheduled action is supposed to follow
        :param pulumi.Input[builtins.str] start_time: The time which the scheduled action is supposed to start running
        :param pulumi.Input[builtins.bool] disabled: Tell if the scheduled action is disabled or not
        :param pulumi.Input[builtins.str] end_time: The time when the scheduled action is supposed to stop scheduling
        """
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "notification_settings", notification_settings)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "start_time", start_time)
        if disabled is None:
            disabled = False
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[Union[builtins.str, 'ActionType']]:
        """
        The action the scheduled action should perform in the resources
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[Union[builtins.str, 'ActionType']]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> pulumi.Input[Sequence[pulumi.Input['NotificationPropertiesArgs']]]:
        """
        The notification settings for the scheduled action
        """
        return pulumi.get(self, "notification_settings")

    @notification_settings.setter
    def notification_settings(self, value: pulumi.Input[Sequence[pulumi.Input['NotificationPropertiesArgs']]]):
        pulumi.set(self, "notification_settings", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[Union[builtins.str, 'ResourceType']]:
        """
        The type of resource the scheduled action is targeting
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[Union[builtins.str, 'ResourceType']]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['ScheduledActionsScheduleArgs']:
        """
        The schedule the scheduled action is supposed to follow
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['ScheduledActionsScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[builtins.str]:
        """
        The time which the scheduled action is supposed to start running
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Tell if the scheduled action is disabled or not
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The time when the scheduled action is supposed to stop scheduling
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_time", value)


if not MYPY:
    class ScheduledActionsScheduleArgsDict(TypedDict):
        """
        Specify the schedule in which the scheduled action is supposed to follow
        """
        requested_days_of_the_month: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]
        """
        The days of the month the scheduled action is supposed to run on. If empty, it means it will run on every day of the month.
        """
        requested_months: pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'Month']]]]
        """
        The months the scheduled action is supposed to run on
        """
        requested_week_days: pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'WeekDay']]]]
        """
        The week days the scheduled action is supposed to run on
        """
        scheduled_time: pulumi.Input[builtins.str]
        """
        The time the scheduled action is supposed to run on
        """
        time_zone: pulumi.Input[builtins.str]
        """
        The timezone the scheduled time is specified on
        """
        deadline_type: NotRequired[pulumi.Input[Union[builtins.str, 'DeadlineType']]]
        """
        The type of deadline the scheduled action is supposed to follow for the schedule. If no value is passed, it will default to InitiateAt.
        """
        execution_parameters: NotRequired[pulumi.Input['ExecutionParametersArgsDict']]
        """
        The execution parameters the scheduled action is supposed to follow
        """
elif False:
    ScheduledActionsScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledActionsScheduleArgs:
    def __init__(__self__, *,
                 requested_days_of_the_month: pulumi.Input[Sequence[pulumi.Input[builtins.int]]],
                 requested_months: pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'Month']]]],
                 requested_week_days: pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'WeekDay']]]],
                 scheduled_time: pulumi.Input[builtins.str],
                 time_zone: pulumi.Input[builtins.str],
                 deadline_type: Optional[pulumi.Input[Union[builtins.str, 'DeadlineType']]] = None,
                 execution_parameters: Optional[pulumi.Input['ExecutionParametersArgs']] = None):
        """
        Specify the schedule in which the scheduled action is supposed to follow
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] requested_days_of_the_month: The days of the month the scheduled action is supposed to run on. If empty, it means it will run on every day of the month.
        :param pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'Month']]]] requested_months: The months the scheduled action is supposed to run on
        :param pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'WeekDay']]]] requested_week_days: The week days the scheduled action is supposed to run on
        :param pulumi.Input[builtins.str] scheduled_time: The time the scheduled action is supposed to run on
        :param pulumi.Input[builtins.str] time_zone: The timezone the scheduled time is specified on
        :param pulumi.Input[Union[builtins.str, 'DeadlineType']] deadline_type: The type of deadline the scheduled action is supposed to follow for the schedule. If no value is passed, it will default to InitiateAt.
        :param pulumi.Input['ExecutionParametersArgs'] execution_parameters: The execution parameters the scheduled action is supposed to follow
        """
        pulumi.set(__self__, "requested_days_of_the_month", requested_days_of_the_month)
        pulumi.set(__self__, "requested_months", requested_months)
        pulumi.set(__self__, "requested_week_days", requested_week_days)
        pulumi.set(__self__, "scheduled_time", scheduled_time)
        pulumi.set(__self__, "time_zone", time_zone)
        if deadline_type is not None:
            pulumi.set(__self__, "deadline_type", deadline_type)
        if execution_parameters is not None:
            pulumi.set(__self__, "execution_parameters", execution_parameters)

    @property
    @pulumi.getter(name="requestedDaysOfTheMonth")
    def requested_days_of_the_month(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.int]]]:
        """
        The days of the month the scheduled action is supposed to run on. If empty, it means it will run on every day of the month.
        """
        return pulumi.get(self, "requested_days_of_the_month")

    @requested_days_of_the_month.setter
    def requested_days_of_the_month(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        pulumi.set(self, "requested_days_of_the_month", value)

    @property
    @pulumi.getter(name="requestedMonths")
    def requested_months(self) -> pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'Month']]]]:
        """
        The months the scheduled action is supposed to run on
        """
        return pulumi.get(self, "requested_months")

    @requested_months.setter
    def requested_months(self, value: pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'Month']]]]):
        pulumi.set(self, "requested_months", value)

    @property
    @pulumi.getter(name="requestedWeekDays")
    def requested_week_days(self) -> pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'WeekDay']]]]:
        """
        The week days the scheduled action is supposed to run on
        """
        return pulumi.get(self, "requested_week_days")

    @requested_week_days.setter
    def requested_week_days(self, value: pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'WeekDay']]]]):
        pulumi.set(self, "requested_week_days", value)

    @property
    @pulumi.getter(name="scheduledTime")
    def scheduled_time(self) -> pulumi.Input[builtins.str]:
        """
        The time the scheduled action is supposed to run on
        """
        return pulumi.get(self, "scheduled_time")

    @scheduled_time.setter
    def scheduled_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "scheduled_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[builtins.str]:
        """
        The timezone the scheduled time is specified on
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="deadlineType")
    def deadline_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'DeadlineType']]]:
        """
        The type of deadline the scheduled action is supposed to follow for the schedule. If no value is passed, it will default to InitiateAt.
        """
        return pulumi.get(self, "deadline_type")

    @deadline_type.setter
    def deadline_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'DeadlineType']]]):
        pulumi.set(self, "deadline_type", value)

    @property
    @pulumi.getter(name="executionParameters")
    def execution_parameters(self) -> Optional[pulumi.Input['ExecutionParametersArgs']]:
        """
        The execution parameters the scheduled action is supposed to follow
        """
        return pulumi.get(self, "execution_parameters")

    @execution_parameters.setter
    def execution_parameters(self, value: Optional[pulumi.Input['ExecutionParametersArgs']]):
        pulumi.set(self, "execution_parameters", value)


