# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ExecutionParametersResponse',
    'NotificationPropertiesResponse',
    'RetryPolicyResponse',
    'ScheduledActionPropertiesResponse',
    'ScheduledActionsScheduleResponse',
    'SystemDataResponse',
]

@pulumi.output_type
class ExecutionParametersResponse(dict):
    """
    Extra details needed to run the user's request
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optimizationPreference":
            suggest = "optimization_preference"
        elif key == "retryPolicy":
            suggest = "retry_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExecutionParametersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExecutionParametersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExecutionParametersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 optimization_preference: Optional[_builtins.str] = None,
                 retry_policy: Optional['outputs.RetryPolicyResponse'] = None):
        """
        Extra details needed to run the user's request
        :param _builtins.str optimization_preference: Details that could optimize the user's request
        :param 'RetryPolicyResponse' retry_policy: Retry policy the user can pass
        """
        if optimization_preference is not None:
            pulumi.set(__self__, "optimization_preference", optimization_preference)
        if retry_policy is not None:
            pulumi.set(__self__, "retry_policy", retry_policy)

    @_builtins.property
    @pulumi.getter(name="optimizationPreference")
    def optimization_preference(self) -> Optional[_builtins.str]:
        """
        Details that could optimize the user's request
        """
        return pulumi.get(self, "optimization_preference")

    @_builtins.property
    @pulumi.getter(name="retryPolicy")
    def retry_policy(self) -> Optional['outputs.RetryPolicyResponse']:
        """
        Retry policy the user can pass
        """
        return pulumi.get(self, "retry_policy")


@pulumi.output_type
class NotificationPropertiesResponse(dict):
    """
    The information about notifications to be send to about upcoming operations.
    """
    def __init__(__self__, *,
                 destination: _builtins.str,
                 language: _builtins.str,
                 type: _builtins.str,
                 disabled: Optional[_builtins.bool] = None):
        """
        The information about notifications to be send to about upcoming operations.
        :param _builtins.str destination: Where the notification should be sent. For email, it should follow email format.
        :param _builtins.str language: The language the notification should be sent on.
        :param _builtins.str type: Type of notification to be sent.
        :param _builtins.bool disabled: Tells if the notification is enabled or not.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "language", language)
        pulumi.set(__self__, "type", type)
        if disabled is None:
            disabled = False
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> _builtins.str:
        """
        Where the notification should be sent. For email, it should follow email format.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def language(self) -> _builtins.str:
        """
        The language the notification should be sent on.
        """
        return pulumi.get(self, "language")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of notification to be sent.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Tells if the notification is enabled or not.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class RetryPolicyResponse(dict):
    """
    The retry policy for the user request
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryCount":
            suggest = "retry_count"
        elif key == "retryWindowInMinutes":
            suggest = "retry_window_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RetryPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RetryPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RetryPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retry_count: Optional[_builtins.int] = None,
                 retry_window_in_minutes: Optional[_builtins.int] = None):
        """
        The retry policy for the user request
        :param _builtins.int retry_count: Retry count for user request
        :param _builtins.int retry_window_in_minutes: Retry window in minutes for user request
        """
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if retry_window_in_minutes is not None:
            pulumi.set(__self__, "retry_window_in_minutes", retry_window_in_minutes)

    @_builtins.property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[_builtins.int]:
        """
        Retry count for user request
        """
        return pulumi.get(self, "retry_count")

    @_builtins.property
    @pulumi.getter(name="retryWindowInMinutes")
    def retry_window_in_minutes(self) -> Optional[_builtins.int]:
        """
        Retry window in minutes for user request
        """
        return pulumi.get(self, "retry_window_in_minutes")


@pulumi.output_type
class ScheduledActionPropertiesResponse(dict):
    """
    Scheduled action properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "notificationSettings":
            suggest = "notification_settings"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "endTime":
            suggest = "end_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledActionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledActionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledActionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: _builtins.str,
                 notification_settings: Sequence['outputs.NotificationPropertiesResponse'],
                 provisioning_state: _builtins.str,
                 resource_type: _builtins.str,
                 schedule: 'outputs.ScheduledActionsScheduleResponse',
                 start_time: _builtins.str,
                 disabled: Optional[_builtins.bool] = None,
                 end_time: Optional[_builtins.str] = None):
        """
        Scheduled action properties
        :param _builtins.str action_type: The action the scheduled action should perform in the resources
        :param Sequence['NotificationPropertiesResponse'] notification_settings: The notification settings for the scheduled action
        :param _builtins.str provisioning_state: The status of the last provisioning operation performed on the resource.
        :param _builtins.str resource_type: The type of resource the scheduled action is targeting
        :param 'ScheduledActionsScheduleResponse' schedule: The schedule the scheduled action is supposed to follow
        :param _builtins.str start_time: The time which the scheduled action is supposed to start running
        :param _builtins.bool disabled: Tell if the scheduled action is disabled or not
        :param _builtins.str end_time: The time when the scheduled action is supposed to stop scheduling
        """
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "notification_settings", notification_settings)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "schedule", schedule)
        pulumi.set(__self__, "start_time", start_time)
        if disabled is None:
            disabled = False
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)

    @_builtins.property
    @pulumi.getter(name="actionType")
    def action_type(self) -> _builtins.str:
        """
        The action the scheduled action should perform in the resources
        """
        return pulumi.get(self, "action_type")

    @_builtins.property
    @pulumi.getter(name="notificationSettings")
    def notification_settings(self) -> Sequence['outputs.NotificationPropertiesResponse']:
        """
        The notification settings for the scheduled action
        """
        return pulumi.get(self, "notification_settings")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The status of the last provisioning operation performed on the resource.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        The type of resource the scheduled action is targeting
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> 'outputs.ScheduledActionsScheduleResponse':
        """
        The schedule the scheduled action is supposed to follow
        """
        return pulumi.get(self, "schedule")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The time which the scheduled action is supposed to start running
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Tell if the scheduled action is disabled or not
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        The time when the scheduled action is supposed to stop scheduling
        """
        return pulumi.get(self, "end_time")


@pulumi.output_type
class ScheduledActionsScheduleResponse(dict):
    """
    Specify the schedule in which the scheduled action is supposed to follow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestedDaysOfTheMonth":
            suggest = "requested_days_of_the_month"
        elif key == "requestedMonths":
            suggest = "requested_months"
        elif key == "requestedWeekDays":
            suggest = "requested_week_days"
        elif key == "scheduledTime":
            suggest = "scheduled_time"
        elif key == "timeZone":
            suggest = "time_zone"
        elif key == "deadlineType":
            suggest = "deadline_type"
        elif key == "executionParameters":
            suggest = "execution_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledActionsScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledActionsScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledActionsScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requested_days_of_the_month: Sequence[_builtins.int],
                 requested_months: Sequence[_builtins.str],
                 requested_week_days: Sequence[_builtins.str],
                 scheduled_time: _builtins.str,
                 time_zone: _builtins.str,
                 deadline_type: Optional[_builtins.str] = None,
                 execution_parameters: Optional['outputs.ExecutionParametersResponse'] = None):
        """
        Specify the schedule in which the scheduled action is supposed to follow
        :param Sequence[_builtins.int] requested_days_of_the_month: The days of the month the scheduled action is supposed to run on. If empty, it means it will run on every day of the month.
        :param Sequence[_builtins.str] requested_months: The months the scheduled action is supposed to run on
        :param Sequence[_builtins.str] requested_week_days: The week days the scheduled action is supposed to run on
        :param _builtins.str scheduled_time: The time the scheduled action is supposed to run on
        :param _builtins.str time_zone: The timezone the scheduled time is specified on
        :param _builtins.str deadline_type: The type of deadline the scheduled action is supposed to follow for the schedule. If no value is passed, it will default to InitiateAt.
        :param 'ExecutionParametersResponse' execution_parameters: The execution parameters the scheduled action is supposed to follow
        """
        pulumi.set(__self__, "requested_days_of_the_month", requested_days_of_the_month)
        pulumi.set(__self__, "requested_months", requested_months)
        pulumi.set(__self__, "requested_week_days", requested_week_days)
        pulumi.set(__self__, "scheduled_time", scheduled_time)
        pulumi.set(__self__, "time_zone", time_zone)
        if deadline_type is not None:
            pulumi.set(__self__, "deadline_type", deadline_type)
        if execution_parameters is not None:
            pulumi.set(__self__, "execution_parameters", execution_parameters)

    @_builtins.property
    @pulumi.getter(name="requestedDaysOfTheMonth")
    def requested_days_of_the_month(self) -> Sequence[_builtins.int]:
        """
        The days of the month the scheduled action is supposed to run on. If empty, it means it will run on every day of the month.
        """
        return pulumi.get(self, "requested_days_of_the_month")

    @_builtins.property
    @pulumi.getter(name="requestedMonths")
    def requested_months(self) -> Sequence[_builtins.str]:
        """
        The months the scheduled action is supposed to run on
        """
        return pulumi.get(self, "requested_months")

    @_builtins.property
    @pulumi.getter(name="requestedWeekDays")
    def requested_week_days(self) -> Sequence[_builtins.str]:
        """
        The week days the scheduled action is supposed to run on
        """
        return pulumi.get(self, "requested_week_days")

    @_builtins.property
    @pulumi.getter(name="scheduledTime")
    def scheduled_time(self) -> _builtins.str:
        """
        The time the scheduled action is supposed to run on
        """
        return pulumi.get(self, "scheduled_time")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The timezone the scheduled time is specified on
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="deadlineType")
    def deadline_type(self) -> Optional[_builtins.str]:
        """
        The type of deadline the scheduled action is supposed to follow for the schedule. If no value is passed, it will default to InitiateAt.
        """
        return pulumi.get(self, "deadline_type")

    @_builtins.property
    @pulumi.getter(name="executionParameters")
    def execution_parameters(self) -> Optional['outputs.ExecutionParametersResponse']:
        """
        The execution parameters the scheduled action is supposed to follow
        """
        return pulumi.get(self, "execution_parameters")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


