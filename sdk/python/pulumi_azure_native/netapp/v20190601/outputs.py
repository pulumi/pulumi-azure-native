# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ActiveDirectoryResponse',
    'ExportPolicyRuleResponse',
    'MountTargetPropertiesResponse',
    'PoolPropertiesResponse',
    'VolumePropertiesResponse',
    'VolumePropertiesResponseExportPolicy',
]

@pulumi.output_type
class ActiveDirectoryResponse(dict):
    """
    Active Directory
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectoryId":
            suggest = "active_directory_id"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"
        elif key == "smbServerName":
            suggest = "smb_server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveDirectoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveDirectoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveDirectoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_directory_id: Optional[str] = None,
                 dns: Optional[str] = None,
                 domain: Optional[str] = None,
                 organizational_unit: Optional[str] = None,
                 password: Optional[str] = None,
                 smb_server_name: Optional[str] = None,
                 status: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Active Directory
        :param str active_directory_id: Id of the Active Directory
        :param str dns: Comma separated list of DNS server IP addresses for the Active Directory domain
        :param str domain: Name of the Active Directory domain
        :param str organizational_unit: The Organizational Unit (OU) within the Windows Active Directory
        :param str password: Plain text password of Active Directory domain administrator
        :param str smb_server_name: NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
        :param str status: Status of the Active Directory
        :param str username: Username of Active Directory domain administrator
        """
        if active_directory_id is not None:
            pulumi.set(__self__, "active_directory_id", active_directory_id)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if smb_server_name is not None:
            pulumi.set(__self__, "smb_server_name", smb_server_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="activeDirectoryId")
    def active_directory_id(self) -> Optional[str]:
        """
        Id of the Active Directory
        """
        return pulumi.get(self, "active_directory_id")

    @property
    @pulumi.getter
    def dns(self) -> Optional[str]:
        """
        Comma separated list of DNS server IP addresses for the Active Directory domain
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Name of the Active Directory domain
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[str]:
        """
        The Organizational Unit (OU) within the Windows Active Directory
        """
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Plain text password of Active Directory domain administrator
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="smbServerName")
    def smb_server_name(self) -> Optional[str]:
        """
        NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
        """
        return pulumi.get(self, "smb_server_name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the Active Directory
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username of Active Directory domain administrator
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ExportPolicyRuleResponse(dict):
    """
    Volume Export Policy Rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedClients":
            suggest = "allowed_clients"
        elif key == "ruleIndex":
            suggest = "rule_index"
        elif key == "unixReadOnly":
            suggest = "unix_read_only"
        elif key == "unixReadWrite":
            suggest = "unix_read_write"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportPolicyRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportPolicyRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportPolicyRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_clients: Optional[str] = None,
                 cifs: Optional[bool] = None,
                 nfsv3: Optional[bool] = None,
                 nfsv4: Optional[bool] = None,
                 rule_index: Optional[int] = None,
                 unix_read_only: Optional[bool] = None,
                 unix_read_write: Optional[bool] = None):
        """
        Volume Export Policy Rule
        :param str allowed_clients: Client ingress specification as comma separated string with IPv4 CIDRs, IPv4 host addresses and host names
        :param bool cifs: Allows CIFS protocol
        :param bool nfsv3: Allows NFSv3 protocol
        :param bool nfsv4: Deprecated: Will use the NFSv4.1 protocol, please use swagger version 2019-07-01 or later
        :param int rule_index: Order index
        :param bool unix_read_only: Read only access
        :param bool unix_read_write: Read and write access
        """
        if allowed_clients is not None:
            pulumi.set(__self__, "allowed_clients", allowed_clients)
        if cifs is not None:
            pulumi.set(__self__, "cifs", cifs)
        if nfsv3 is not None:
            pulumi.set(__self__, "nfsv3", nfsv3)
        if nfsv4 is not None:
            pulumi.set(__self__, "nfsv4", nfsv4)
        if rule_index is not None:
            pulumi.set(__self__, "rule_index", rule_index)
        if unix_read_only is not None:
            pulumi.set(__self__, "unix_read_only", unix_read_only)
        if unix_read_write is not None:
            pulumi.set(__self__, "unix_read_write", unix_read_write)

    @property
    @pulumi.getter(name="allowedClients")
    def allowed_clients(self) -> Optional[str]:
        """
        Client ingress specification as comma separated string with IPv4 CIDRs, IPv4 host addresses and host names
        """
        return pulumi.get(self, "allowed_clients")

    @property
    @pulumi.getter
    def cifs(self) -> Optional[bool]:
        """
        Allows CIFS protocol
        """
        return pulumi.get(self, "cifs")

    @property
    @pulumi.getter
    def nfsv3(self) -> Optional[bool]:
        """
        Allows NFSv3 protocol
        """
        return pulumi.get(self, "nfsv3")

    @property
    @pulumi.getter
    def nfsv4(self) -> Optional[bool]:
        """
        Deprecated: Will use the NFSv4.1 protocol, please use swagger version 2019-07-01 or later
        """
        return pulumi.get(self, "nfsv4")

    @property
    @pulumi.getter(name="ruleIndex")
    def rule_index(self) -> Optional[int]:
        """
        Order index
        """
        return pulumi.get(self, "rule_index")

    @property
    @pulumi.getter(name="unixReadOnly")
    def unix_read_only(self) -> Optional[bool]:
        """
        Read only access
        """
        return pulumi.get(self, "unix_read_only")

    @property
    @pulumi.getter(name="unixReadWrite")
    def unix_read_write(self) -> Optional[bool]:
        """
        Read and write access
        """
        return pulumi.get(self, "unix_read_write")


@pulumi.output_type
class MountTargetPropertiesResponse(dict):
    """
    Mount target properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemId":
            suggest = "file_system_id"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "mountTargetId":
            suggest = "mount_target_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "endIp":
            suggest = "end_ip"
        elif key == "smbServerFqdn":
            suggest = "smb_server_fqdn"
        elif key == "startIp":
            suggest = "start_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountTargetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountTargetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountTargetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_id: str,
                 ip_address: str,
                 mount_target_id: str,
                 provisioning_state: str,
                 end_ip: Optional[str] = None,
                 gateway: Optional[str] = None,
                 netmask: Optional[str] = None,
                 smb_server_fqdn: Optional[str] = None,
                 start_ip: Optional[str] = None,
                 subnet: Optional[str] = None):
        """
        Mount target properties
        :param str file_system_id: UUID v4 used to identify the MountTarget
        :param str ip_address: The mount target's IPv4 address
        :param str mount_target_id: UUID v4 used to identify the MountTarget
        :param str provisioning_state: Azure lifecycle management
        :param str end_ip: The end of IPv4 address range to use when creating a new mount target
        :param str gateway: The gateway of the IPv4 address range to use when creating a new mount target
        :param str netmask: The netmask of the IPv4 address range to use when creating a new mount target
        :param str smb_server_fqdn: The SMB server's Fully Qualified Domain Name, FQDN
        :param str start_ip: The start of IPv4 address range to use when creating a new mount target
        :param str subnet: The subnet
        """
        pulumi.set(__self__, "file_system_id", file_system_id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "mount_target_id", mount_target_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if end_ip is not None:
            pulumi.set(__self__, "end_ip", end_ip)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)
        if smb_server_fqdn is not None:
            pulumi.set(__self__, "smb_server_fqdn", smb_server_fqdn)
        if start_ip is not None:
            pulumi.set(__self__, "start_ip", start_ip)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> str:
        """
        UUID v4 used to identify the MountTarget
        """
        return pulumi.get(self, "file_system_id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The mount target's IPv4 address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="mountTargetId")
    def mount_target_id(self) -> str:
        """
        UUID v4 used to identify the MountTarget
        """
        return pulumi.get(self, "mount_target_id")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Azure lifecycle management
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="endIp")
    def end_ip(self) -> Optional[str]:
        """
        The end of IPv4 address range to use when creating a new mount target
        """
        return pulumi.get(self, "end_ip")

    @property
    @pulumi.getter
    def gateway(self) -> Optional[str]:
        """
        The gateway of the IPv4 address range to use when creating a new mount target
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def netmask(self) -> Optional[str]:
        """
        The netmask of the IPv4 address range to use when creating a new mount target
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="smbServerFqdn")
    def smb_server_fqdn(self) -> Optional[str]:
        """
        The SMB server's Fully Qualified Domain Name, FQDN
        """
        return pulumi.get(self, "smb_server_fqdn")

    @property
    @pulumi.getter(name="startIp")
    def start_ip(self) -> Optional[str]:
        """
        The start of IPv4 address range to use when creating a new mount target
        """
        return pulumi.get(self, "start_ip")

    @property
    @pulumi.getter
    def subnet(self) -> Optional[str]:
        """
        The subnet
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class PoolPropertiesResponse(dict):
    """
    Pool properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolId":
            suggest = "pool_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "serviceLevel":
            suggest = "service_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PoolPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PoolPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PoolPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_id: str,
                 provisioning_state: str,
                 service_level: str,
                 size: float):
        """
        Pool properties
        :param str pool_id: UUID v4 used to identify the Pool
        :param str provisioning_state: Azure lifecycle management
        :param str service_level: The service level of the file system
        :param float size: Provisioned size of the pool (in bytes). Allowed values are in 4TiB chunks (value must be multiply of 4398046511104).
        """
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if service_level is None:
            service_level = 'Premium'
        pulumi.set(__self__, "service_level", service_level)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> str:
        """
        UUID v4 used to identify the Pool
        """
        return pulumi.get(self, "pool_id")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Azure lifecycle management
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="serviceLevel")
    def service_level(self) -> str:
        """
        The service level of the file system
        """
        return pulumi.get(self, "service_level")

    @property
    @pulumi.getter
    def size(self) -> float:
        """
        Provisioned size of the pool (in bytes). Allowed values are in 4TiB chunks (value must be multiply of 4398046511104).
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class VolumePropertiesResponse(dict):
    """
    Volume properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baremetalTenantId":
            suggest = "baremetal_tenant_id"
        elif key == "creationToken":
            suggest = "creation_token"
        elif key == "fileSystemId":
            suggest = "file_system_id"
        elif key == "mountTargets":
            suggest = "mount_targets"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "usageThreshold":
            suggest = "usage_threshold"
        elif key == "exportPolicy":
            suggest = "export_policy"
        elif key == "protocolTypes":
            suggest = "protocol_types"
        elif key == "serviceLevel":
            suggest = "service_level"
        elif key == "snapshotId":
            suggest = "snapshot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 baremetal_tenant_id: str,
                 creation_token: str,
                 file_system_id: str,
                 mount_targets: Sequence['outputs.MountTargetPropertiesResponse'],
                 provisioning_state: str,
                 subnet_id: str,
                 usage_threshold: float,
                 export_policy: Optional['outputs.VolumePropertiesResponseExportPolicy'] = None,
                 protocol_types: Optional[Sequence[str]] = None,
                 service_level: Optional[str] = None,
                 snapshot_id: Optional[str] = None):
        """
        Volume properties
        :param str baremetal_tenant_id: Unique Baremetal Tenant Identifier.
        :param str creation_token: A unique file path for the volume. Used when creating mount targets
        :param str file_system_id: Unique FileSystem Identifier.
        :param Sequence['MountTargetPropertiesResponse'] mount_targets: List of mount targets
        :param str provisioning_state: Azure lifecycle management
        :param str subnet_id: The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        :param float usage_threshold: Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB. Specified in bytes.
        :param 'VolumePropertiesResponseExportPolicy' export_policy: Set of export policy rules
        :param Sequence[str] protocol_types: Set of protocol types
        :param str service_level: The service level of the file system
        :param str snapshot_id: UUID v4 or resource identifier used to identify the Snapshot.
        """
        pulumi.set(__self__, "baremetal_tenant_id", baremetal_tenant_id)
        pulumi.set(__self__, "creation_token", creation_token)
        pulumi.set(__self__, "file_system_id", file_system_id)
        pulumi.set(__self__, "mount_targets", mount_targets)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if usage_threshold is None:
            usage_threshold = 107374182400
        pulumi.set(__self__, "usage_threshold", usage_threshold)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if protocol_types is not None:
            pulumi.set(__self__, "protocol_types", protocol_types)
        if service_level is None:
            service_level = 'Premium'
        if service_level is not None:
            pulumi.set(__self__, "service_level", service_level)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)

    @property
    @pulumi.getter(name="baremetalTenantId")
    def baremetal_tenant_id(self) -> str:
        """
        Unique Baremetal Tenant Identifier.
        """
        return pulumi.get(self, "baremetal_tenant_id")

    @property
    @pulumi.getter(name="creationToken")
    def creation_token(self) -> str:
        """
        A unique file path for the volume. Used when creating mount targets
        """
        return pulumi.get(self, "creation_token")

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> str:
        """
        Unique FileSystem Identifier.
        """
        return pulumi.get(self, "file_system_id")

    @property
    @pulumi.getter(name="mountTargets")
    def mount_targets(self) -> Sequence['outputs.MountTargetPropertiesResponse']:
        """
        List of mount targets
        """
        return pulumi.get(self, "mount_targets")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Azure lifecycle management
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="usageThreshold")
    def usage_threshold(self) -> float:
        """
        Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB. Specified in bytes.
        """
        return pulumi.get(self, "usage_threshold")

    @property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional['outputs.VolumePropertiesResponseExportPolicy']:
        """
        Set of export policy rules
        """
        return pulumi.get(self, "export_policy")

    @property
    @pulumi.getter(name="protocolTypes")
    def protocol_types(self) -> Optional[Sequence[str]]:
        """
        Set of protocol types
        """
        return pulumi.get(self, "protocol_types")

    @property
    @pulumi.getter(name="serviceLevel")
    def service_level(self) -> Optional[str]:
        """
        The service level of the file system
        """
        return pulumi.get(self, "service_level")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        UUID v4 or resource identifier used to identify the Snapshot.
        """
        return pulumi.get(self, "snapshot_id")


@pulumi.output_type
class VolumePropertiesResponseExportPolicy(dict):
    """
    Set of export policy rules
    """
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.ExportPolicyRuleResponse']] = None):
        """
        Set of export policy rules
        :param Sequence['ExportPolicyRuleResponse'] rules: Export policy rule
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.ExportPolicyRuleResponse']]:
        """
        Export policy rule
        """
        return pulumi.get(self, "rules")


