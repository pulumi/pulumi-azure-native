# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AccountEncryptionResponse',
    'ActiveDirectoryResponse',
    'DailyScheduleResponse',
    'EncryptionIdentityResponse',
    'ExportPolicyRuleResponse',
    'HourlyScheduleResponse',
    'KeyVaultPropertiesResponse',
    'LdapSearchScopeOptResponse',
    'ManagedServiceIdentityResponse',
    'MonthlyScheduleResponse',
    'MountTargetPropertiesResponse',
    'PlacementKeyValuePairsResponse',
    'ReplicationObjectResponse',
    'ReplicationResponse',
    'SystemDataResponse',
    'UserAssignedIdentityResponse',
    'VolumeBackupPropertiesResponse',
    'VolumeBackupsResponse',
    'VolumeGroupMetaDataResponse',
    'VolumeGroupVolumePropertiesResponse',
    'VolumePropertiesResponseDataProtection',
    'VolumePropertiesResponseExportPolicy',
    'VolumeRelocationPropertiesResponse',
    'VolumeSnapshotPropertiesResponse',
    'WeeklyScheduleResponse',
]

@pulumi.output_type
class AccountEncryptionResponse(dict):
    """
    Encryption settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keySource":
            suggest = "key_source"
        elif key == "keyVaultProperties":
            suggest = "key_vault_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountEncryptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountEncryptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountEncryptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: Optional['outputs.EncryptionIdentityResponse'] = None,
                 key_source: Optional[str] = None,
                 key_vault_properties: Optional['outputs.KeyVaultPropertiesResponse'] = None):
        """
        Encryption settings
        :param 'EncryptionIdentityResponse' identity: Identity used to authenticate to KeyVault. Applicable if keySource is 'Microsoft.KeyVault'.
        :param str key_source: The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault
        :param 'KeyVaultPropertiesResponse' key_vault_properties: Properties provided by KeVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        AccountEncryptionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            identity=identity,
            key_source=key_source,
            key_vault_properties=key_vault_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             identity: Optional['outputs.EncryptionIdentityResponse'] = None,
             key_source: Optional[str] = None,
             key_vault_properties: Optional['outputs.KeyVaultPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_source is None and 'keySource' in kwargs:
            key_source = kwargs['keySource']
        if key_vault_properties is None and 'keyVaultProperties' in kwargs:
            key_vault_properties = kwargs['keyVaultProperties']

        if identity is not None:
            _setter("identity", identity)
        if key_source is None:
            key_source = 'Microsoft.NetApp'
        if key_source is not None:
            _setter("key_source", key_source)
        if key_vault_properties is not None:
            _setter("key_vault_properties", key_vault_properties)

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.EncryptionIdentityResponse']:
        """
        Identity used to authenticate to KeyVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="keySource")
    def key_source(self) -> Optional[str]:
        """
        The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault
        """
        return pulumi.get(self, "key_source")

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> Optional['outputs.KeyVaultPropertiesResponse']:
        """
        Properties provided by KeVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "key_vault_properties")


@pulumi.output_type
class ActiveDirectoryResponse(dict):
    """
    Active Directory
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusDetails":
            suggest = "status_details"
        elif key == "activeDirectoryId":
            suggest = "active_directory_id"
        elif key == "adName":
            suggest = "ad_name"
        elif key == "aesEncryption":
            suggest = "aes_encryption"
        elif key == "allowLocalNfsUsersWithLdap":
            suggest = "allow_local_nfs_users_with_ldap"
        elif key == "backupOperators":
            suggest = "backup_operators"
        elif key == "encryptDCConnections":
            suggest = "encrypt_dc_connections"
        elif key == "kdcIP":
            suggest = "kdc_ip"
        elif key == "ldapOverTLS":
            suggest = "ldap_over_tls"
        elif key == "ldapSearchScope":
            suggest = "ldap_search_scope"
        elif key == "ldapSigning":
            suggest = "ldap_signing"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"
        elif key == "preferredServersForLdapClient":
            suggest = "preferred_servers_for_ldap_client"
        elif key == "securityOperators":
            suggest = "security_operators"
        elif key == "serverRootCACertificate":
            suggest = "server_root_ca_certificate"
        elif key == "smbServerName":
            suggest = "smb_server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveDirectoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveDirectoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveDirectoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 status_details: str,
                 active_directory_id: Optional[str] = None,
                 ad_name: Optional[str] = None,
                 administrators: Optional[Sequence[str]] = None,
                 aes_encryption: Optional[bool] = None,
                 allow_local_nfs_users_with_ldap: Optional[bool] = None,
                 backup_operators: Optional[Sequence[str]] = None,
                 dns: Optional[str] = None,
                 domain: Optional[str] = None,
                 encrypt_dc_connections: Optional[bool] = None,
                 kdc_ip: Optional[str] = None,
                 ldap_over_tls: Optional[bool] = None,
                 ldap_search_scope: Optional['outputs.LdapSearchScopeOptResponse'] = None,
                 ldap_signing: Optional[bool] = None,
                 organizational_unit: Optional[str] = None,
                 password: Optional[str] = None,
                 preferred_servers_for_ldap_client: Optional[str] = None,
                 security_operators: Optional[Sequence[str]] = None,
                 server_root_ca_certificate: Optional[str] = None,
                 site: Optional[str] = None,
                 smb_server_name: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Active Directory
        :param str status: Status of the Active Directory
        :param str status_details: Any details in regards to the Status of the Active Directory
        :param str active_directory_id: Id of the Active Directory
        :param str ad_name: Name of the active directory machine. This optional parameter is used only while creating kerberos volume
        :param Sequence[str] administrators: Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier
        :param bool aes_encryption: If enabled, AES encryption will be enabled for SMB communication.
        :param bool allow_local_nfs_users_with_ldap:  If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes.
        :param Sequence[str] backup_operators: Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier
        :param str dns: Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain
        :param str domain: Name of the Active Directory domain
        :param bool encrypt_dc_connections: If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted.
        :param str kdc_ip: kdc server IP addresses for the active directory machine. This optional parameter is used only while creating kerberos volume.
        :param bool ldap_over_tls: Specifies whether or not the LDAP traffic needs to be secured via TLS.
        :param 'LdapSearchScopeOptResponse' ldap_search_scope: LDAP Search scope options
        :param bool ldap_signing: Specifies whether or not the LDAP traffic needs to be signed.
        :param str organizational_unit: The Organizational Unit (OU) within the Windows Active Directory
        :param str password: Plain text password of Active Directory domain administrator, value is masked in the response
        :param str preferred_servers_for_ldap_client: Comma separated list of IPv4 addresses of preferred servers for LDAP client. At most two comma separated IPv4 addresses can be passed.
        :param Sequence[str] security_operators: Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier
        :param str server_root_ca_certificate: When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes.
        :param str site: The Active Directory site the service will limit Domain Controller discovery to
        :param str smb_server_name: NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
        :param str username: A domain user account with permission to create machine accounts
        """
        ActiveDirectoryResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
            status_details=status_details,
            active_directory_id=active_directory_id,
            ad_name=ad_name,
            administrators=administrators,
            aes_encryption=aes_encryption,
            allow_local_nfs_users_with_ldap=allow_local_nfs_users_with_ldap,
            backup_operators=backup_operators,
            dns=dns,
            domain=domain,
            encrypt_dc_connections=encrypt_dc_connections,
            kdc_ip=kdc_ip,
            ldap_over_tls=ldap_over_tls,
            ldap_search_scope=ldap_search_scope,
            ldap_signing=ldap_signing,
            organizational_unit=organizational_unit,
            password=password,
            preferred_servers_for_ldap_client=preferred_servers_for_ldap_client,
            security_operators=security_operators,
            server_root_ca_certificate=server_root_ca_certificate,
            site=site,
            smb_server_name=smb_server_name,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: Optional[str] = None,
             status_details: Optional[str] = None,
             active_directory_id: Optional[str] = None,
             ad_name: Optional[str] = None,
             administrators: Optional[Sequence[str]] = None,
             aes_encryption: Optional[bool] = None,
             allow_local_nfs_users_with_ldap: Optional[bool] = None,
             backup_operators: Optional[Sequence[str]] = None,
             dns: Optional[str] = None,
             domain: Optional[str] = None,
             encrypt_dc_connections: Optional[bool] = None,
             kdc_ip: Optional[str] = None,
             ldap_over_tls: Optional[bool] = None,
             ldap_search_scope: Optional['outputs.LdapSearchScopeOptResponse'] = None,
             ldap_signing: Optional[bool] = None,
             organizational_unit: Optional[str] = None,
             password: Optional[str] = None,
             preferred_servers_for_ldap_client: Optional[str] = None,
             security_operators: Optional[Sequence[str]] = None,
             server_root_ca_certificate: Optional[str] = None,
             site: Optional[str] = None,
             smb_server_name: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if status is None:
            raise TypeError("Missing 'status' argument")
        if status_details is None and 'statusDetails' in kwargs:
            status_details = kwargs['statusDetails']
        if status_details is None:
            raise TypeError("Missing 'status_details' argument")
        if active_directory_id is None and 'activeDirectoryId' in kwargs:
            active_directory_id = kwargs['activeDirectoryId']
        if ad_name is None and 'adName' in kwargs:
            ad_name = kwargs['adName']
        if aes_encryption is None and 'aesEncryption' in kwargs:
            aes_encryption = kwargs['aesEncryption']
        if allow_local_nfs_users_with_ldap is None and 'allowLocalNfsUsersWithLdap' in kwargs:
            allow_local_nfs_users_with_ldap = kwargs['allowLocalNfsUsersWithLdap']
        if backup_operators is None and 'backupOperators' in kwargs:
            backup_operators = kwargs['backupOperators']
        if encrypt_dc_connections is None and 'encryptDCConnections' in kwargs:
            encrypt_dc_connections = kwargs['encryptDCConnections']
        if kdc_ip is None and 'kdcIP' in kwargs:
            kdc_ip = kwargs['kdcIP']
        if ldap_over_tls is None and 'ldapOverTLS' in kwargs:
            ldap_over_tls = kwargs['ldapOverTLS']
        if ldap_search_scope is None and 'ldapSearchScope' in kwargs:
            ldap_search_scope = kwargs['ldapSearchScope']
        if ldap_signing is None and 'ldapSigning' in kwargs:
            ldap_signing = kwargs['ldapSigning']
        if organizational_unit is None and 'organizationalUnit' in kwargs:
            organizational_unit = kwargs['organizationalUnit']
        if preferred_servers_for_ldap_client is None and 'preferredServersForLdapClient' in kwargs:
            preferred_servers_for_ldap_client = kwargs['preferredServersForLdapClient']
        if security_operators is None and 'securityOperators' in kwargs:
            security_operators = kwargs['securityOperators']
        if server_root_ca_certificate is None and 'serverRootCACertificate' in kwargs:
            server_root_ca_certificate = kwargs['serverRootCACertificate']
        if smb_server_name is None and 'smbServerName' in kwargs:
            smb_server_name = kwargs['smbServerName']

        _setter("status", status)
        _setter("status_details", status_details)
        if active_directory_id is not None:
            _setter("active_directory_id", active_directory_id)
        if ad_name is not None:
            _setter("ad_name", ad_name)
        if administrators is not None:
            _setter("administrators", administrators)
        if aes_encryption is not None:
            _setter("aes_encryption", aes_encryption)
        if allow_local_nfs_users_with_ldap is not None:
            _setter("allow_local_nfs_users_with_ldap", allow_local_nfs_users_with_ldap)
        if backup_operators is not None:
            _setter("backup_operators", backup_operators)
        if dns is not None:
            _setter("dns", dns)
        if domain is not None:
            _setter("domain", domain)
        if encrypt_dc_connections is not None:
            _setter("encrypt_dc_connections", encrypt_dc_connections)
        if kdc_ip is not None:
            _setter("kdc_ip", kdc_ip)
        if ldap_over_tls is not None:
            _setter("ldap_over_tls", ldap_over_tls)
        if ldap_search_scope is not None:
            _setter("ldap_search_scope", ldap_search_scope)
        if ldap_signing is not None:
            _setter("ldap_signing", ldap_signing)
        if organizational_unit is None:
            organizational_unit = 'CN=Computers'
        if organizational_unit is not None:
            _setter("organizational_unit", organizational_unit)
        if password is not None:
            _setter("password", password)
        if preferred_servers_for_ldap_client is not None:
            _setter("preferred_servers_for_ldap_client", preferred_servers_for_ldap_client)
        if security_operators is not None:
            _setter("security_operators", security_operators)
        if server_root_ca_certificate is not None:
            _setter("server_root_ca_certificate", server_root_ca_certificate)
        if site is not None:
            _setter("site", site)
        if smb_server_name is not None:
            _setter("smb_server_name", smb_server_name)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the Active Directory
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusDetails")
    def status_details(self) -> str:
        """
        Any details in regards to the Status of the Active Directory
        """
        return pulumi.get(self, "status_details")

    @property
    @pulumi.getter(name="activeDirectoryId")
    def active_directory_id(self) -> Optional[str]:
        """
        Id of the Active Directory
        """
        return pulumi.get(self, "active_directory_id")

    @property
    @pulumi.getter(name="adName")
    def ad_name(self) -> Optional[str]:
        """
        Name of the active directory machine. This optional parameter is used only while creating kerberos volume
        """
        return pulumi.get(self, "ad_name")

    @property
    @pulumi.getter
    def administrators(self) -> Optional[Sequence[str]]:
        """
        Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "administrators")

    @property
    @pulumi.getter(name="aesEncryption")
    def aes_encryption(self) -> Optional[bool]:
        """
        If enabled, AES encryption will be enabled for SMB communication.
        """
        return pulumi.get(self, "aes_encryption")

    @property
    @pulumi.getter(name="allowLocalNfsUsersWithLdap")
    def allow_local_nfs_users_with_ldap(self) -> Optional[bool]:
        """
         If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes.
        """
        return pulumi.get(self, "allow_local_nfs_users_with_ldap")

    @property
    @pulumi.getter(name="backupOperators")
    def backup_operators(self) -> Optional[Sequence[str]]:
        """
        Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "backup_operators")

    @property
    @pulumi.getter
    def dns(self) -> Optional[str]:
        """
        Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Name of the Active Directory domain
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="encryptDCConnections")
    def encrypt_dc_connections(self) -> Optional[bool]:
        """
        If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted.
        """
        return pulumi.get(self, "encrypt_dc_connections")

    @property
    @pulumi.getter(name="kdcIP")
    def kdc_ip(self) -> Optional[str]:
        """
        kdc server IP addresses for the active directory machine. This optional parameter is used only while creating kerberos volume.
        """
        return pulumi.get(self, "kdc_ip")

    @property
    @pulumi.getter(name="ldapOverTLS")
    def ldap_over_tls(self) -> Optional[bool]:
        """
        Specifies whether or not the LDAP traffic needs to be secured via TLS.
        """
        return pulumi.get(self, "ldap_over_tls")

    @property
    @pulumi.getter(name="ldapSearchScope")
    def ldap_search_scope(self) -> Optional['outputs.LdapSearchScopeOptResponse']:
        """
        LDAP Search scope options
        """
        return pulumi.get(self, "ldap_search_scope")

    @property
    @pulumi.getter(name="ldapSigning")
    def ldap_signing(self) -> Optional[bool]:
        """
        Specifies whether or not the LDAP traffic needs to be signed.
        """
        return pulumi.get(self, "ldap_signing")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[str]:
        """
        The Organizational Unit (OU) within the Windows Active Directory
        """
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Plain text password of Active Directory domain administrator, value is masked in the response
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="preferredServersForLdapClient")
    def preferred_servers_for_ldap_client(self) -> Optional[str]:
        """
        Comma separated list of IPv4 addresses of preferred servers for LDAP client. At most two comma separated IPv4 addresses can be passed.
        """
        return pulumi.get(self, "preferred_servers_for_ldap_client")

    @property
    @pulumi.getter(name="securityOperators")
    def security_operators(self) -> Optional[Sequence[str]]:
        """
        Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "security_operators")

    @property
    @pulumi.getter(name="serverRootCACertificate")
    def server_root_ca_certificate(self) -> Optional[str]:
        """
        When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes.
        """
        return pulumi.get(self, "server_root_ca_certificate")

    @property
    @pulumi.getter
    def site(self) -> Optional[str]:
        """
        The Active Directory site the service will limit Domain Controller discovery to
        """
        return pulumi.get(self, "site")

    @property
    @pulumi.getter(name="smbServerName")
    def smb_server_name(self) -> Optional[str]:
        """
        NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
        """
        return pulumi.get(self, "smb_server_name")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A domain user account with permission to create machine accounts
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DailyScheduleResponse(dict):
    """
    Daily Schedule properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotsToKeep":
            suggest = "snapshots_to_keep"
        elif key == "usedBytes":
            suggest = "used_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DailyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DailyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DailyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hour: Optional[int] = None,
                 minute: Optional[int] = None,
                 snapshots_to_keep: Optional[int] = None,
                 used_bytes: Optional[float] = None):
        """
        Daily Schedule properties
        :param int hour: Indicates which hour in UTC timezone a snapshot should be taken
        :param int minute: Indicates which minute snapshot should be taken
        :param int snapshots_to_keep: Daily snapshot count to keep
        :param float used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        DailyScheduleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hour=hour,
            minute=minute,
            snapshots_to_keep=snapshots_to_keep,
            used_bytes=used_bytes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hour: Optional[int] = None,
             minute: Optional[int] = None,
             snapshots_to_keep: Optional[int] = None,
             used_bytes: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if snapshots_to_keep is None and 'snapshotsToKeep' in kwargs:
            snapshots_to_keep = kwargs['snapshotsToKeep']
        if used_bytes is None and 'usedBytes' in kwargs:
            used_bytes = kwargs['usedBytes']

        if hour is not None:
            _setter("hour", hour)
        if minute is not None:
            _setter("minute", minute)
        if snapshots_to_keep is not None:
            _setter("snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            _setter("used_bytes", used_bytes)

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def minute(self) -> Optional[int]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[int]:
        """
        Daily snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[float]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")


@pulumi.output_type
class EncryptionIdentityResponse(dict):
    """
    Identity used to authenticate with key vault.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 user_assigned_identity: Optional[str] = None):
        """
        Identity used to authenticate with key vault.
        :param str principal_id: The principal ID (object ID) of the identity used to authenticate with key vault. Read-only.
        :param str user_assigned_identity: The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities.
        """
        EncryptionIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            user_assigned_identity=user_assigned_identity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: Optional[str] = None,
             user_assigned_identity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")
        if user_assigned_identity is None and 'userAssignedIdentity' in kwargs:
            user_assigned_identity = kwargs['userAssignedIdentity']

        _setter("principal_id", principal_id)
        if user_assigned_identity is not None:
            _setter("user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID (object ID) of the identity used to authenticate with key vault. Read-only.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[str]:
        """
        The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities.
        """
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class ExportPolicyRuleResponse(dict):
    """
    Volume Export Policy Rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedClients":
            suggest = "allowed_clients"
        elif key == "chownMode":
            suggest = "chown_mode"
        elif key == "hasRootAccess":
            suggest = "has_root_access"
        elif key == "kerberos5ReadOnly":
            suggest = "kerberos5_read_only"
        elif key == "kerberos5ReadWrite":
            suggest = "kerberos5_read_write"
        elif key == "kerberos5iReadOnly":
            suggest = "kerberos5i_read_only"
        elif key == "kerberos5iReadWrite":
            suggest = "kerberos5i_read_write"
        elif key == "kerberos5pReadOnly":
            suggest = "kerberos5p_read_only"
        elif key == "kerberos5pReadWrite":
            suggest = "kerberos5p_read_write"
        elif key == "ruleIndex":
            suggest = "rule_index"
        elif key == "unixReadOnly":
            suggest = "unix_read_only"
        elif key == "unixReadWrite":
            suggest = "unix_read_write"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportPolicyRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportPolicyRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportPolicyRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_clients: Optional[str] = None,
                 chown_mode: Optional[str] = None,
                 cifs: Optional[bool] = None,
                 has_root_access: Optional[bool] = None,
                 kerberos5_read_only: Optional[bool] = None,
                 kerberos5_read_write: Optional[bool] = None,
                 kerberos5i_read_only: Optional[bool] = None,
                 kerberos5i_read_write: Optional[bool] = None,
                 kerberos5p_read_only: Optional[bool] = None,
                 kerberos5p_read_write: Optional[bool] = None,
                 nfsv3: Optional[bool] = None,
                 nfsv41: Optional[bool] = None,
                 rule_index: Optional[int] = None,
                 unix_read_only: Optional[bool] = None,
                 unix_read_write: Optional[bool] = None):
        """
        Volume Export Policy Rule
        :param str allowed_clients: Client ingress specification as comma separated string with IPv4 CIDRs, IPv4 host addresses and host names
        :param str chown_mode: This parameter specifies who is authorized to change the ownership of a file. restricted - Only root user can change the ownership of the file. unrestricted - Non-root users can change ownership of files that they own.
        :param bool cifs: Allows CIFS protocol
        :param bool has_root_access: Has root access to volume
        :param bool kerberos5_read_only: Kerberos5 Read only access. To be use with swagger version 2020-05-01 or later
        :param bool kerberos5_read_write: Kerberos5 Read and write access. To be use with swagger version 2020-05-01 or later
        :param bool kerberos5i_read_only: Kerberos5i Read only access. To be use with swagger version 2020-05-01 or later
        :param bool kerberos5i_read_write: Kerberos5i Read and write access. To be use with swagger version 2020-05-01 or later
        :param bool kerberos5p_read_only: Kerberos5p Read only access. To be use with swagger version 2020-05-01 or later
        :param bool kerberos5p_read_write: Kerberos5p Read and write access. To be use with swagger version 2020-05-01 or later
        :param bool nfsv3: Allows NFSv3 protocol. Enable only for NFSv3 type volumes
        :param bool nfsv41: Allows NFSv4.1 protocol. Enable only for NFSv4.1 type volumes
        :param int rule_index: Order index
        :param bool unix_read_only: Read only access
        :param bool unix_read_write: Read and write access
        """
        ExportPolicyRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_clients=allowed_clients,
            chown_mode=chown_mode,
            cifs=cifs,
            has_root_access=has_root_access,
            kerberos5_read_only=kerberos5_read_only,
            kerberos5_read_write=kerberos5_read_write,
            kerberos5i_read_only=kerberos5i_read_only,
            kerberos5i_read_write=kerberos5i_read_write,
            kerberos5p_read_only=kerberos5p_read_only,
            kerberos5p_read_write=kerberos5p_read_write,
            nfsv3=nfsv3,
            nfsv41=nfsv41,
            rule_index=rule_index,
            unix_read_only=unix_read_only,
            unix_read_write=unix_read_write,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_clients: Optional[str] = None,
             chown_mode: Optional[str] = None,
             cifs: Optional[bool] = None,
             has_root_access: Optional[bool] = None,
             kerberos5_read_only: Optional[bool] = None,
             kerberos5_read_write: Optional[bool] = None,
             kerberos5i_read_only: Optional[bool] = None,
             kerberos5i_read_write: Optional[bool] = None,
             kerberos5p_read_only: Optional[bool] = None,
             kerberos5p_read_write: Optional[bool] = None,
             nfsv3: Optional[bool] = None,
             nfsv41: Optional[bool] = None,
             rule_index: Optional[int] = None,
             unix_read_only: Optional[bool] = None,
             unix_read_write: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allowed_clients is None and 'allowedClients' in kwargs:
            allowed_clients = kwargs['allowedClients']
        if chown_mode is None and 'chownMode' in kwargs:
            chown_mode = kwargs['chownMode']
        if has_root_access is None and 'hasRootAccess' in kwargs:
            has_root_access = kwargs['hasRootAccess']
        if kerberos5_read_only is None and 'kerberos5ReadOnly' in kwargs:
            kerberos5_read_only = kwargs['kerberos5ReadOnly']
        if kerberos5_read_write is None and 'kerberos5ReadWrite' in kwargs:
            kerberos5_read_write = kwargs['kerberos5ReadWrite']
        if kerberos5i_read_only is None and 'kerberos5iReadOnly' in kwargs:
            kerberos5i_read_only = kwargs['kerberos5iReadOnly']
        if kerberos5i_read_write is None and 'kerberos5iReadWrite' in kwargs:
            kerberos5i_read_write = kwargs['kerberos5iReadWrite']
        if kerberos5p_read_only is None and 'kerberos5pReadOnly' in kwargs:
            kerberos5p_read_only = kwargs['kerberos5pReadOnly']
        if kerberos5p_read_write is None and 'kerberos5pReadWrite' in kwargs:
            kerberos5p_read_write = kwargs['kerberos5pReadWrite']
        if rule_index is None and 'ruleIndex' in kwargs:
            rule_index = kwargs['ruleIndex']
        if unix_read_only is None and 'unixReadOnly' in kwargs:
            unix_read_only = kwargs['unixReadOnly']
        if unix_read_write is None and 'unixReadWrite' in kwargs:
            unix_read_write = kwargs['unixReadWrite']

        if allowed_clients is not None:
            _setter("allowed_clients", allowed_clients)
        if chown_mode is None:
            chown_mode = 'Restricted'
        if chown_mode is not None:
            _setter("chown_mode", chown_mode)
        if cifs is not None:
            _setter("cifs", cifs)
        if has_root_access is None:
            has_root_access = True
        if has_root_access is not None:
            _setter("has_root_access", has_root_access)
        if kerberos5_read_only is None:
            kerberos5_read_only = False
        if kerberos5_read_only is not None:
            _setter("kerberos5_read_only", kerberos5_read_only)
        if kerberos5_read_write is None:
            kerberos5_read_write = False
        if kerberos5_read_write is not None:
            _setter("kerberos5_read_write", kerberos5_read_write)
        if kerberos5i_read_only is None:
            kerberos5i_read_only = False
        if kerberos5i_read_only is not None:
            _setter("kerberos5i_read_only", kerberos5i_read_only)
        if kerberos5i_read_write is None:
            kerberos5i_read_write = False
        if kerberos5i_read_write is not None:
            _setter("kerberos5i_read_write", kerberos5i_read_write)
        if kerberos5p_read_only is None:
            kerberos5p_read_only = False
        if kerberos5p_read_only is not None:
            _setter("kerberos5p_read_only", kerberos5p_read_only)
        if kerberos5p_read_write is None:
            kerberos5p_read_write = False
        if kerberos5p_read_write is not None:
            _setter("kerberos5p_read_write", kerberos5p_read_write)
        if nfsv3 is not None:
            _setter("nfsv3", nfsv3)
        if nfsv41 is not None:
            _setter("nfsv41", nfsv41)
        if rule_index is not None:
            _setter("rule_index", rule_index)
        if unix_read_only is not None:
            _setter("unix_read_only", unix_read_only)
        if unix_read_write is not None:
            _setter("unix_read_write", unix_read_write)

    @property
    @pulumi.getter(name="allowedClients")
    def allowed_clients(self) -> Optional[str]:
        """
        Client ingress specification as comma separated string with IPv4 CIDRs, IPv4 host addresses and host names
        """
        return pulumi.get(self, "allowed_clients")

    @property
    @pulumi.getter(name="chownMode")
    def chown_mode(self) -> Optional[str]:
        """
        This parameter specifies who is authorized to change the ownership of a file. restricted - Only root user can change the ownership of the file. unrestricted - Non-root users can change ownership of files that they own.
        """
        return pulumi.get(self, "chown_mode")

    @property
    @pulumi.getter
    def cifs(self) -> Optional[bool]:
        """
        Allows CIFS protocol
        """
        return pulumi.get(self, "cifs")

    @property
    @pulumi.getter(name="hasRootAccess")
    def has_root_access(self) -> Optional[bool]:
        """
        Has root access to volume
        """
        return pulumi.get(self, "has_root_access")

    @property
    @pulumi.getter(name="kerberos5ReadOnly")
    def kerberos5_read_only(self) -> Optional[bool]:
        """
        Kerberos5 Read only access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5_read_only")

    @property
    @pulumi.getter(name="kerberos5ReadWrite")
    def kerberos5_read_write(self) -> Optional[bool]:
        """
        Kerberos5 Read and write access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5_read_write")

    @property
    @pulumi.getter(name="kerberos5iReadOnly")
    def kerberos5i_read_only(self) -> Optional[bool]:
        """
        Kerberos5i Read only access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5i_read_only")

    @property
    @pulumi.getter(name="kerberos5iReadWrite")
    def kerberos5i_read_write(self) -> Optional[bool]:
        """
        Kerberos5i Read and write access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5i_read_write")

    @property
    @pulumi.getter(name="kerberos5pReadOnly")
    def kerberos5p_read_only(self) -> Optional[bool]:
        """
        Kerberos5p Read only access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5p_read_only")

    @property
    @pulumi.getter(name="kerberos5pReadWrite")
    def kerberos5p_read_write(self) -> Optional[bool]:
        """
        Kerberos5p Read and write access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5p_read_write")

    @property
    @pulumi.getter
    def nfsv3(self) -> Optional[bool]:
        """
        Allows NFSv3 protocol. Enable only for NFSv3 type volumes
        """
        return pulumi.get(self, "nfsv3")

    @property
    @pulumi.getter
    def nfsv41(self) -> Optional[bool]:
        """
        Allows NFSv4.1 protocol. Enable only for NFSv4.1 type volumes
        """
        return pulumi.get(self, "nfsv41")

    @property
    @pulumi.getter(name="ruleIndex")
    def rule_index(self) -> Optional[int]:
        """
        Order index
        """
        return pulumi.get(self, "rule_index")

    @property
    @pulumi.getter(name="unixReadOnly")
    def unix_read_only(self) -> Optional[bool]:
        """
        Read only access
        """
        return pulumi.get(self, "unix_read_only")

    @property
    @pulumi.getter(name="unixReadWrite")
    def unix_read_write(self) -> Optional[bool]:
        """
        Read and write access
        """
        return pulumi.get(self, "unix_read_write")


@pulumi.output_type
class HourlyScheduleResponse(dict):
    """
    Hourly Schedule properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotsToKeep":
            suggest = "snapshots_to_keep"
        elif key == "usedBytes":
            suggest = "used_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HourlyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HourlyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HourlyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minute: Optional[int] = None,
                 snapshots_to_keep: Optional[int] = None,
                 used_bytes: Optional[float] = None):
        """
        Hourly Schedule properties
        :param int minute: Indicates which minute snapshot should be taken
        :param int snapshots_to_keep: Hourly snapshot count to keep
        :param float used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        HourlyScheduleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            minute=minute,
            snapshots_to_keep=snapshots_to_keep,
            used_bytes=used_bytes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             minute: Optional[int] = None,
             snapshots_to_keep: Optional[int] = None,
             used_bytes: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if snapshots_to_keep is None and 'snapshotsToKeep' in kwargs:
            snapshots_to_keep = kwargs['snapshotsToKeep']
        if used_bytes is None and 'usedBytes' in kwargs:
            used_bytes = kwargs['usedBytes']

        if minute is not None:
            _setter("minute", minute)
        if snapshots_to_keep is not None:
            _setter("snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            _setter("used_bytes", used_bytes)

    @property
    @pulumi.getter
    def minute(self) -> Optional[int]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[int]:
        """
        Hourly snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[float]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")


@pulumi.output_type
class KeyVaultPropertiesResponse(dict):
    """
    Properties of key vault.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyName":
            suggest = "key_name"
        elif key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "keyVaultResourceId":
            suggest = "key_vault_resource_id"
        elif key == "keyVaultUri":
            suggest = "key_vault_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_name: str,
                 key_vault_id: str,
                 key_vault_resource_id: str,
                 key_vault_uri: str,
                 status: str):
        """
        Properties of key vault.
        :param str key_name: The name of KeyVault key.
        :param str key_vault_id: UUID v4 used to identify the Azure Key Vault configuration
        :param str key_vault_resource_id: The resource ID of KeyVault.
        :param str key_vault_uri: The Uri of KeyVault.
        :param str status: Status of the KeyVault connection.
        """
        KeyVaultPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_name=key_name,
            key_vault_id=key_vault_id,
            key_vault_resource_id=key_vault_resource_id,
            key_vault_uri=key_vault_uri,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_name: Optional[str] = None,
             key_vault_id: Optional[str] = None,
             key_vault_resource_id: Optional[str] = None,
             key_vault_uri: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_name is None and 'keyName' in kwargs:
            key_name = kwargs['keyName']
        if key_name is None:
            raise TypeError("Missing 'key_name' argument")
        if key_vault_id is None and 'keyVaultId' in kwargs:
            key_vault_id = kwargs['keyVaultId']
        if key_vault_id is None:
            raise TypeError("Missing 'key_vault_id' argument")
        if key_vault_resource_id is None and 'keyVaultResourceId' in kwargs:
            key_vault_resource_id = kwargs['keyVaultResourceId']
        if key_vault_resource_id is None:
            raise TypeError("Missing 'key_vault_resource_id' argument")
        if key_vault_uri is None and 'keyVaultUri' in kwargs:
            key_vault_uri = kwargs['keyVaultUri']
        if key_vault_uri is None:
            raise TypeError("Missing 'key_vault_uri' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")

        _setter("key_name", key_name)
        _setter("key_vault_id", key_vault_id)
        _setter("key_vault_resource_id", key_vault_resource_id)
        _setter("key_vault_uri", key_vault_uri)
        _setter("status", status)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        The name of KeyVault key.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        UUID v4 used to identify the Azure Key Vault configuration
        """
        return pulumi.get(self, "key_vault_id")

    @property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> str:
        """
        The resource ID of KeyVault.
        """
        return pulumi.get(self, "key_vault_resource_id")

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> str:
        """
        The Uri of KeyVault.
        """
        return pulumi.get(self, "key_vault_uri")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the KeyVault connection.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class LdapSearchScopeOptResponse(dict):
    """
    LDAP search scope 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupDN":
            suggest = "group_dn"
        elif key == "groupMembershipFilter":
            suggest = "group_membership_filter"
        elif key == "userDN":
            suggest = "user_dn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LdapSearchScopeOptResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LdapSearchScopeOptResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LdapSearchScopeOptResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_dn: Optional[str] = None,
                 group_membership_filter: Optional[str] = None,
                 user_dn: Optional[str] = None):
        """
        LDAP search scope 
        :param str group_dn: This specifies the group DN, which overrides the base DN for group lookups.
        :param str group_membership_filter: This specifies the custom LDAP search filter to be used when looking up group membership from LDAP server.
        :param str user_dn: This specifies the user DN, which overrides the base DN for user lookups.
        """
        LdapSearchScopeOptResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_dn=group_dn,
            group_membership_filter=group_membership_filter,
            user_dn=user_dn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_dn: Optional[str] = None,
             group_membership_filter: Optional[str] = None,
             user_dn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if group_dn is None and 'groupDN' in kwargs:
            group_dn = kwargs['groupDN']
        if group_membership_filter is None and 'groupMembershipFilter' in kwargs:
            group_membership_filter = kwargs['groupMembershipFilter']
        if user_dn is None and 'userDN' in kwargs:
            user_dn = kwargs['userDN']

        if group_dn is not None:
            _setter("group_dn", group_dn)
        if group_membership_filter is not None:
            _setter("group_membership_filter", group_membership_filter)
        if user_dn is not None:
            _setter("user_dn", user_dn)

    @property
    @pulumi.getter(name="groupDN")
    def group_dn(self) -> Optional[str]:
        """
        This specifies the group DN, which overrides the base DN for group lookups.
        """
        return pulumi.get(self, "group_dn")

    @property
    @pulumi.getter(name="groupMembershipFilter")
    def group_membership_filter(self) -> Optional[str]:
        """
        This specifies the custom LDAP search filter to be used when looking up group membership from LDAP server.
        """
        return pulumi.get(self, "group_membership_filter")

    @property
    @pulumi.getter(name="userDN")
    def user_dn(self) -> Optional[str]:
        """
        This specifies the user DN, which overrides the base DN for user lookups.
        """
        return pulumi.get(self, "user_dn")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        ManagedServiceIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             type: Optional[str] = None,
             user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if user_assigned_identities is None and 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        _setter("principal_id", principal_id)
        _setter("tenant_id", tenant_id)
        _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MonthlyScheduleResponse(dict):
    """
    Monthly Schedule properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfMonth":
            suggest = "days_of_month"
        elif key == "snapshotsToKeep":
            suggest = "snapshots_to_keep"
        elif key == "usedBytes":
            suggest = "used_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonthlyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonthlyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonthlyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_month: Optional[str] = None,
                 hour: Optional[int] = None,
                 minute: Optional[int] = None,
                 snapshots_to_keep: Optional[int] = None,
                 used_bytes: Optional[float] = None):
        """
        Monthly Schedule properties
        :param str days_of_month: Indicates which days of the month snapshot should be taken. A comma delimited string.
        :param int hour: Indicates which hour in UTC timezone a snapshot should be taken
        :param int minute: Indicates which minute snapshot should be taken
        :param int snapshots_to_keep: Monthly snapshot count to keep
        :param float used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        MonthlyScheduleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days_of_month=days_of_month,
            hour=hour,
            minute=minute,
            snapshots_to_keep=snapshots_to_keep,
            used_bytes=used_bytes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days_of_month: Optional[str] = None,
             hour: Optional[int] = None,
             minute: Optional[int] = None,
             snapshots_to_keep: Optional[int] = None,
             used_bytes: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if days_of_month is None and 'daysOfMonth' in kwargs:
            days_of_month = kwargs['daysOfMonth']
        if snapshots_to_keep is None and 'snapshotsToKeep' in kwargs:
            snapshots_to_keep = kwargs['snapshotsToKeep']
        if used_bytes is None and 'usedBytes' in kwargs:
            used_bytes = kwargs['usedBytes']

        if days_of_month is not None:
            _setter("days_of_month", days_of_month)
        if hour is not None:
            _setter("hour", hour)
        if minute is not None:
            _setter("minute", minute)
        if snapshots_to_keep is not None:
            _setter("snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            _setter("used_bytes", used_bytes)

    @property
    @pulumi.getter(name="daysOfMonth")
    def days_of_month(self) -> Optional[str]:
        """
        Indicates which days of the month snapshot should be taken. A comma delimited string.
        """
        return pulumi.get(self, "days_of_month")

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def minute(self) -> Optional[int]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[int]:
        """
        Monthly snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[float]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")


@pulumi.output_type
class MountTargetPropertiesResponse(dict):
    """
    Mount target properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemId":
            suggest = "file_system_id"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "mountTargetId":
            suggest = "mount_target_id"
        elif key == "smbServerFqdn":
            suggest = "smb_server_fqdn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountTargetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountTargetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountTargetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_id: str,
                 ip_address: str,
                 mount_target_id: str,
                 smb_server_fqdn: Optional[str] = None):
        """
        Mount target properties
        :param str file_system_id: UUID v4 used to identify the MountTarget
        :param str ip_address: The mount target's IPv4 address
        :param str mount_target_id: UUID v4 used to identify the MountTarget
        :param str smb_server_fqdn: The SMB server's Fully Qualified Domain Name, FQDN
        """
        MountTargetPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file_system_id=file_system_id,
            ip_address=ip_address,
            mount_target_id=mount_target_id,
            smb_server_fqdn=smb_server_fqdn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file_system_id: Optional[str] = None,
             ip_address: Optional[str] = None,
             mount_target_id: Optional[str] = None,
             smb_server_fqdn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if file_system_id is None and 'fileSystemId' in kwargs:
            file_system_id = kwargs['fileSystemId']
        if file_system_id is None:
            raise TypeError("Missing 'file_system_id' argument")
        if ip_address is None and 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if ip_address is None:
            raise TypeError("Missing 'ip_address' argument")
        if mount_target_id is None and 'mountTargetId' in kwargs:
            mount_target_id = kwargs['mountTargetId']
        if mount_target_id is None:
            raise TypeError("Missing 'mount_target_id' argument")
        if smb_server_fqdn is None and 'smbServerFqdn' in kwargs:
            smb_server_fqdn = kwargs['smbServerFqdn']

        _setter("file_system_id", file_system_id)
        _setter("ip_address", ip_address)
        _setter("mount_target_id", mount_target_id)
        if smb_server_fqdn is not None:
            _setter("smb_server_fqdn", smb_server_fqdn)

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> str:
        """
        UUID v4 used to identify the MountTarget
        """
        return pulumi.get(self, "file_system_id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The mount target's IPv4 address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="mountTargetId")
    def mount_target_id(self) -> str:
        """
        UUID v4 used to identify the MountTarget
        """
        return pulumi.get(self, "mount_target_id")

    @property
    @pulumi.getter(name="smbServerFqdn")
    def smb_server_fqdn(self) -> Optional[str]:
        """
        The SMB server's Fully Qualified Domain Name, FQDN
        """
        return pulumi.get(self, "smb_server_fqdn")


@pulumi.output_type
class PlacementKeyValuePairsResponse(dict):
    """
    Application specific parameters for the placement of volumes in the volume group
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        Application specific parameters for the placement of volumes in the volume group
        :param str key: Key for an application specific parameter for the placement of volumes in the volume group
        :param str value: Value for an application specific parameter for the placement of volumes in the volume group
        """
        PlacementKeyValuePairsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for an application specific parameter for the placement of volumes in the volume group
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for an application specific parameter for the placement of volumes in the volume group
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ReplicationObjectResponse(dict):
    """
    Replication properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteVolumeResourceId":
            suggest = "remote_volume_resource_id"
        elif key == "endpointType":
            suggest = "endpoint_type"
        elif key == "remoteVolumeRegion":
            suggest = "remote_volume_region"
        elif key == "replicationId":
            suggest = "replication_id"
        elif key == "replicationSchedule":
            suggest = "replication_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationObjectResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationObjectResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationObjectResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remote_volume_resource_id: str,
                 endpoint_type: Optional[str] = None,
                 remote_volume_region: Optional[str] = None,
                 replication_id: Optional[str] = None,
                 replication_schedule: Optional[str] = None):
        """
        Replication properties
        :param str remote_volume_resource_id: The resource ID of the remote volume.
        :param str endpoint_type: Indicates whether the local volume is the source or destination for the Volume Replication
        :param str remote_volume_region: The remote region for the other end of the Volume Replication.
        :param str replication_id: Id
        :param str replication_schedule: Schedule
        """
        ReplicationObjectResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            remote_volume_resource_id=remote_volume_resource_id,
            endpoint_type=endpoint_type,
            remote_volume_region=remote_volume_region,
            replication_id=replication_id,
            replication_schedule=replication_schedule,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             remote_volume_resource_id: Optional[str] = None,
             endpoint_type: Optional[str] = None,
             remote_volume_region: Optional[str] = None,
             replication_id: Optional[str] = None,
             replication_schedule: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if remote_volume_resource_id is None and 'remoteVolumeResourceId' in kwargs:
            remote_volume_resource_id = kwargs['remoteVolumeResourceId']
        if remote_volume_resource_id is None:
            raise TypeError("Missing 'remote_volume_resource_id' argument")
        if endpoint_type is None and 'endpointType' in kwargs:
            endpoint_type = kwargs['endpointType']
        if remote_volume_region is None and 'remoteVolumeRegion' in kwargs:
            remote_volume_region = kwargs['remoteVolumeRegion']
        if replication_id is None and 'replicationId' in kwargs:
            replication_id = kwargs['replicationId']
        if replication_schedule is None and 'replicationSchedule' in kwargs:
            replication_schedule = kwargs['replicationSchedule']

        _setter("remote_volume_resource_id", remote_volume_resource_id)
        if endpoint_type is not None:
            _setter("endpoint_type", endpoint_type)
        if remote_volume_region is not None:
            _setter("remote_volume_region", remote_volume_region)
        if replication_id is not None:
            _setter("replication_id", replication_id)
        if replication_schedule is not None:
            _setter("replication_schedule", replication_schedule)

    @property
    @pulumi.getter(name="remoteVolumeResourceId")
    def remote_volume_resource_id(self) -> str:
        """
        The resource ID of the remote volume.
        """
        return pulumi.get(self, "remote_volume_resource_id")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[str]:
        """
        Indicates whether the local volume is the source or destination for the Volume Replication
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="remoteVolumeRegion")
    def remote_volume_region(self) -> Optional[str]:
        """
        The remote region for the other end of the Volume Replication.
        """
        return pulumi.get(self, "remote_volume_region")

    @property
    @pulumi.getter(name="replicationId")
    def replication_id(self) -> Optional[str]:
        """
        Id
        """
        return pulumi.get(self, "replication_id")

    @property
    @pulumi.getter(name="replicationSchedule")
    def replication_schedule(self) -> Optional[str]:
        """
        Schedule
        """
        return pulumi.get(self, "replication_schedule")


@pulumi.output_type
class ReplicationResponse(dict):
    """
    Replication properties
    """
    def __init__(__self__, *,
                 remote_volume_resource_id: str,
                 endpoint_type: Optional[str] = None,
                 remote_volume_region: Optional[str] = None,
                 replication_schedule: Optional[str] = None):
        """
        Replication properties
        :param str remote_volume_resource_id: The resource ID of the remote volume.
        :param str endpoint_type: Indicates whether the local volume is the source or destination for the Volume Replication
        :param str remote_volume_region: The remote region for the other end of the Volume Replication.
        :param str replication_schedule: Schedule
        """
        ReplicationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            remote_volume_resource_id=remote_volume_resource_id,
            endpoint_type=endpoint_type,
            remote_volume_region=remote_volume_region,
            replication_schedule=replication_schedule,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             remote_volume_resource_id: Optional[str] = None,
             endpoint_type: Optional[str] = None,
             remote_volume_region: Optional[str] = None,
             replication_schedule: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if remote_volume_resource_id is None and 'remoteVolumeResourceId' in kwargs:
            remote_volume_resource_id = kwargs['remoteVolumeResourceId']
        if remote_volume_resource_id is None:
            raise TypeError("Missing 'remote_volume_resource_id' argument")
        if endpoint_type is None and 'endpointType' in kwargs:
            endpoint_type = kwargs['endpointType']
        if remote_volume_region is None and 'remoteVolumeRegion' in kwargs:
            remote_volume_region = kwargs['remoteVolumeRegion']
        if replication_schedule is None and 'replicationSchedule' in kwargs:
            replication_schedule = kwargs['replicationSchedule']

        _setter("remote_volume_resource_id", remote_volume_resource_id)
        if endpoint_type is not None:
            _setter("endpoint_type", endpoint_type)
        if remote_volume_region is not None:
            _setter("remote_volume_region", remote_volume_region)
        if replication_schedule is not None:
            _setter("replication_schedule", replication_schedule)

    @property
    @pulumi.getter(name="remoteVolumeResourceId")
    def remote_volume_resource_id(self) -> str:
        """
        The resource ID of the remote volume.
        """
        return pulumi.get(self, "remote_volume_resource_id")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[str]:
        """
        Indicates whether the local volume is the source or destination for the Volume Replication
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="remoteVolumeRegion")
    def remote_volume_region(self) -> Optional[str]:
        """
        The remote region for the other end of the Volume Replication.
        """
        return pulumi.get(self, "remote_volume_region")

    @property
    @pulumi.getter(name="replicationSchedule")
    def replication_schedule(self) -> Optional[str]:
        """
        Schedule
        """
        return pulumi.get(self, "replication_schedule")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        User assigned identity properties
        :param str client_id: The client ID of the assigned identity.
        :param str principal_id: The principal ID of the assigned identity.
        """
        UserAssignedIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            principal_id=principal_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             principal_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")

        _setter("client_id", client_id)
        _setter("principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VolumeBackupPropertiesResponse(dict):
    """
    Volume Backup Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupEnabled":
            suggest = "backup_enabled"
        elif key == "backupPolicyId":
            suggest = "backup_policy_id"
        elif key == "policyEnforced":
            suggest = "policy_enforced"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeBackupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeBackupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeBackupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_enabled: Optional[bool] = None,
                 backup_policy_id: Optional[str] = None,
                 policy_enforced: Optional[bool] = None):
        """
        Volume Backup Properties
        :param bool backup_enabled: Backup Enabled
        :param str backup_policy_id: Backup Policy Resource ID
        :param bool policy_enforced: Policy Enforced
        """
        VolumeBackupPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_enabled=backup_enabled,
            backup_policy_id=backup_policy_id,
            policy_enforced=policy_enforced,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_enabled: Optional[bool] = None,
             backup_policy_id: Optional[str] = None,
             policy_enforced: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backup_enabled is None and 'backupEnabled' in kwargs:
            backup_enabled = kwargs['backupEnabled']
        if backup_policy_id is None and 'backupPolicyId' in kwargs:
            backup_policy_id = kwargs['backupPolicyId']
        if policy_enforced is None and 'policyEnforced' in kwargs:
            policy_enforced = kwargs['policyEnforced']

        if backup_enabled is not None:
            _setter("backup_enabled", backup_enabled)
        if backup_policy_id is not None:
            _setter("backup_policy_id", backup_policy_id)
        if policy_enforced is not None:
            _setter("policy_enforced", policy_enforced)

    @property
    @pulumi.getter(name="backupEnabled")
    def backup_enabled(self) -> Optional[bool]:
        """
        Backup Enabled
        """
        return pulumi.get(self, "backup_enabled")

    @property
    @pulumi.getter(name="backupPolicyId")
    def backup_policy_id(self) -> Optional[str]:
        """
        Backup Policy Resource ID
        """
        return pulumi.get(self, "backup_policy_id")

    @property
    @pulumi.getter(name="policyEnforced")
    def policy_enforced(self) -> Optional[bool]:
        """
        Policy Enforced
        """
        return pulumi.get(self, "policy_enforced")


@pulumi.output_type
class VolumeBackupsResponse(dict):
    """
    Volume details using the backup policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupsCount":
            suggest = "backups_count"
        elif key == "policyEnabled":
            suggest = "policy_enabled"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeBackupsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeBackupsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeBackupsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backups_count: Optional[int] = None,
                 policy_enabled: Optional[bool] = None,
                 volume_name: Optional[str] = None):
        """
        Volume details using the backup policy
        :param int backups_count: Total count of backups for volume
        :param bool policy_enabled: Policy enabled
        :param str volume_name: Volume name
        """
        VolumeBackupsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backups_count=backups_count,
            policy_enabled=policy_enabled,
            volume_name=volume_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backups_count: Optional[int] = None,
             policy_enabled: Optional[bool] = None,
             volume_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if backups_count is None and 'backupsCount' in kwargs:
            backups_count = kwargs['backupsCount']
        if policy_enabled is None and 'policyEnabled' in kwargs:
            policy_enabled = kwargs['policyEnabled']
        if volume_name is None and 'volumeName' in kwargs:
            volume_name = kwargs['volumeName']

        if backups_count is not None:
            _setter("backups_count", backups_count)
        if policy_enabled is not None:
            _setter("policy_enabled", policy_enabled)
        if volume_name is not None:
            _setter("volume_name", volume_name)

    @property
    @pulumi.getter(name="backupsCount")
    def backups_count(self) -> Optional[int]:
        """
        Total count of backups for volume
        """
        return pulumi.get(self, "backups_count")

    @property
    @pulumi.getter(name="policyEnabled")
    def policy_enabled(self) -> Optional[bool]:
        """
        Policy enabled
        """
        return pulumi.get(self, "policy_enabled")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[str]:
        """
        Volume name
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class VolumeGroupMetaDataResponse(dict):
    """
    Volume group properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumesCount":
            suggest = "volumes_count"
        elif key == "applicationIdentifier":
            suggest = "application_identifier"
        elif key == "applicationType":
            suggest = "application_type"
        elif key == "deploymentSpecId":
            suggest = "deployment_spec_id"
        elif key == "globalPlacementRules":
            suggest = "global_placement_rules"
        elif key == "groupDescription":
            suggest = "group_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeGroupMetaDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeGroupMetaDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeGroupMetaDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volumes_count: float,
                 application_identifier: Optional[str] = None,
                 application_type: Optional[str] = None,
                 deployment_spec_id: Optional[str] = None,
                 global_placement_rules: Optional[Sequence['outputs.PlacementKeyValuePairsResponse']] = None,
                 group_description: Optional[str] = None):
        """
        Volume group properties
        :param float volumes_count: Number of volumes in volume group
        :param str application_identifier: Application specific identifier
        :param str application_type: Application Type
        :param str deployment_spec_id: Application specific identifier of deployment rules for the volume group
        :param Sequence['PlacementKeyValuePairsResponse'] global_placement_rules: Application specific placement rules for the volume group
        :param str group_description: Group Description
        """
        VolumeGroupMetaDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            volumes_count=volumes_count,
            application_identifier=application_identifier,
            application_type=application_type,
            deployment_spec_id=deployment_spec_id,
            global_placement_rules=global_placement_rules,
            group_description=group_description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             volumes_count: Optional[float] = None,
             application_identifier: Optional[str] = None,
             application_type: Optional[str] = None,
             deployment_spec_id: Optional[str] = None,
             global_placement_rules: Optional[Sequence['outputs.PlacementKeyValuePairsResponse']] = None,
             group_description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if volumes_count is None and 'volumesCount' in kwargs:
            volumes_count = kwargs['volumesCount']
        if volumes_count is None:
            raise TypeError("Missing 'volumes_count' argument")
        if application_identifier is None and 'applicationIdentifier' in kwargs:
            application_identifier = kwargs['applicationIdentifier']
        if application_type is None and 'applicationType' in kwargs:
            application_type = kwargs['applicationType']
        if deployment_spec_id is None and 'deploymentSpecId' in kwargs:
            deployment_spec_id = kwargs['deploymentSpecId']
        if global_placement_rules is None and 'globalPlacementRules' in kwargs:
            global_placement_rules = kwargs['globalPlacementRules']
        if group_description is None and 'groupDescription' in kwargs:
            group_description = kwargs['groupDescription']

        _setter("volumes_count", volumes_count)
        if application_identifier is not None:
            _setter("application_identifier", application_identifier)
        if application_type is not None:
            _setter("application_type", application_type)
        if deployment_spec_id is not None:
            _setter("deployment_spec_id", deployment_spec_id)
        if global_placement_rules is not None:
            _setter("global_placement_rules", global_placement_rules)
        if group_description is not None:
            _setter("group_description", group_description)

    @property
    @pulumi.getter(name="volumesCount")
    def volumes_count(self) -> float:
        """
        Number of volumes in volume group
        """
        return pulumi.get(self, "volumes_count")

    @property
    @pulumi.getter(name="applicationIdentifier")
    def application_identifier(self) -> Optional[str]:
        """
        Application specific identifier
        """
        return pulumi.get(self, "application_identifier")

    @property
    @pulumi.getter(name="applicationType")
    def application_type(self) -> Optional[str]:
        """
        Application Type
        """
        return pulumi.get(self, "application_type")

    @property
    @pulumi.getter(name="deploymentSpecId")
    def deployment_spec_id(self) -> Optional[str]:
        """
        Application specific identifier of deployment rules for the volume group
        """
        return pulumi.get(self, "deployment_spec_id")

    @property
    @pulumi.getter(name="globalPlacementRules")
    def global_placement_rules(self) -> Optional[Sequence['outputs.PlacementKeyValuePairsResponse']]:
        """
        Application specific placement rules for the volume group
        """
        return pulumi.get(self, "global_placement_rules")

    @property
    @pulumi.getter(name="groupDescription")
    def group_description(self) -> Optional[str]:
        """
        Group Description
        """
        return pulumi.get(self, "group_description")


@pulumi.output_type
class VolumeGroupVolumePropertiesResponse(dict):
    """
    Volume resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actualThroughputMibps":
            suggest = "actual_throughput_mibps"
        elif key == "baremetalTenantId":
            suggest = "baremetal_tenant_id"
        elif key == "cloneProgress":
            suggest = "clone_progress"
        elif key == "creationToken":
            suggest = "creation_token"
        elif key == "dataStoreResourceId":
            suggest = "data_store_resource_id"
        elif key == "fileAccessLogs":
            suggest = "file_access_logs"
        elif key == "fileSystemId":
            suggest = "file_system_id"
        elif key == "maximumNumberOfFiles":
            suggest = "maximum_number_of_files"
        elif key == "mountTargets":
            suggest = "mount_targets"
        elif key == "networkSiblingSetId":
            suggest = "network_sibling_set_id"
        elif key == "originatingResourceId":
            suggest = "originating_resource_id"
        elif key == "provisionedAvailabilityZone":
            suggest = "provisioned_availability_zone"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "storageToNetworkProximity":
            suggest = "storage_to_network_proximity"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "t2Network":
            suggest = "t2_network"
        elif key == "usageThreshold":
            suggest = "usage_threshold"
        elif key == "volumeGroupName":
            suggest = "volume_group_name"
        elif key == "avsDataStore":
            suggest = "avs_data_store"
        elif key == "backupId":
            suggest = "backup_id"
        elif key == "capacityPoolResourceId":
            suggest = "capacity_pool_resource_id"
        elif key == "coolAccess":
            suggest = "cool_access"
        elif key == "coolnessPeriod":
            suggest = "coolness_period"
        elif key == "dataProtection":
            suggest = "data_protection"
        elif key == "defaultGroupQuotaInKiBs":
            suggest = "default_group_quota_in_ki_bs"
        elif key == "defaultUserQuotaInKiBs":
            suggest = "default_user_quota_in_ki_bs"
        elif key == "deleteBaseSnapshot":
            suggest = "delete_base_snapshot"
        elif key == "enableSubvolumes":
            suggest = "enable_subvolumes"
        elif key == "encryptionKeySource":
            suggest = "encryption_key_source"
        elif key == "exportPolicy":
            suggest = "export_policy"
        elif key == "isDefaultQuotaEnabled":
            suggest = "is_default_quota_enabled"
        elif key == "isLargeVolume":
            suggest = "is_large_volume"
        elif key == "isRestoring":
            suggest = "is_restoring"
        elif key == "kerberosEnabled":
            suggest = "kerberos_enabled"
        elif key == "keyVaultPrivateEndpointResourceId":
            suggest = "key_vault_private_endpoint_resource_id"
        elif key == "ldapEnabled":
            suggest = "ldap_enabled"
        elif key == "networkFeatures":
            suggest = "network_features"
        elif key == "placementRules":
            suggest = "placement_rules"
        elif key == "protocolTypes":
            suggest = "protocol_types"
        elif key == "proximityPlacementGroup":
            suggest = "proximity_placement_group"
        elif key == "securityStyle":
            suggest = "security_style"
        elif key == "serviceLevel":
            suggest = "service_level"
        elif key == "smbAccessBasedEnumeration":
            suggest = "smb_access_based_enumeration"
        elif key == "smbContinuouslyAvailable":
            suggest = "smb_continuously_available"
        elif key == "smbEncryption":
            suggest = "smb_encryption"
        elif key == "smbNonBrowsable":
            suggest = "smb_non_browsable"
        elif key == "snapshotDirectoryVisible":
            suggest = "snapshot_directory_visible"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "throughputMibps":
            suggest = "throughput_mibps"
        elif key == "unixPermissions":
            suggest = "unix_permissions"
        elif key == "volumeSpecName":
            suggest = "volume_spec_name"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeGroupVolumePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeGroupVolumePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeGroupVolumePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actual_throughput_mibps: float,
                 baremetal_tenant_id: str,
                 clone_progress: int,
                 creation_token: str,
                 data_store_resource_id: Sequence[str],
                 encrypted: bool,
                 file_access_logs: Optional[str] = None,
                 file_system_id: str,
                 id: str,
                 maximum_number_of_files: float,
                 mount_targets: Sequence['outputs.MountTargetPropertiesResponse'],
                 network_sibling_set_id: str,
                 originating_resource_id: str,
                 provisioned_availability_zone: str,
                 provisioning_state: str,
                 storage_to_network_proximity: str,
                 subnet_id: str,
                 t2_network: str,
                 type: str,
                 usage_threshold: Optional[float] = None,
                 volume_group_name: str,
                 avs_data_store: Optional[str] = None,
                 backup_id: Optional[str] = None,
                 capacity_pool_resource_id: Optional[str] = None,
                 cool_access: Optional[bool] = None,
                 coolness_period: Optional[int] = None,
                 data_protection: Optional['outputs.VolumePropertiesResponseDataProtection'] = None,
                 default_group_quota_in_ki_bs: Optional[float] = None,
                 default_user_quota_in_ki_bs: Optional[float] = None,
                 delete_base_snapshot: Optional[bool] = None,
                 enable_subvolumes: Optional[str] = None,
                 encryption_key_source: Optional[str] = None,
                 export_policy: Optional['outputs.VolumePropertiesResponseExportPolicy'] = None,
                 is_default_quota_enabled: Optional[bool] = None,
                 is_large_volume: Optional[bool] = None,
                 is_restoring: Optional[bool] = None,
                 kerberos_enabled: Optional[bool] = None,
                 key_vault_private_endpoint_resource_id: Optional[str] = None,
                 ldap_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 network_features: Optional[str] = None,
                 placement_rules: Optional[Sequence['outputs.PlacementKeyValuePairsResponse']] = None,
                 protocol_types: Optional[Sequence[str]] = None,
                 proximity_placement_group: Optional[str] = None,
                 security_style: Optional[str] = None,
                 service_level: Optional[str] = None,
                 smb_access_based_enumeration: Optional[str] = None,
                 smb_continuously_available: Optional[bool] = None,
                 smb_encryption: Optional[bool] = None,
                 smb_non_browsable: Optional[str] = None,
                 snapshot_directory_visible: Optional[bool] = None,
                 snapshot_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 throughput_mibps: Optional[float] = None,
                 unix_permissions: Optional[str] = None,
                 volume_spec_name: Optional[str] = None,
                 volume_type: Optional[str] = None):
        """
        Volume resource
        :param float actual_throughput_mibps: Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
        :param str baremetal_tenant_id: Unique Baremetal Tenant Identifier.
        :param int clone_progress: When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process. When this value is empty/null there is no cloning process currently happening on this volume. This value will update every 5 minutes during cloning.
        :param str creation_token: A unique file path for the volume. Used when creating mount targets
        :param Sequence[str] data_store_resource_id: Data store resource unique identifier
        :param bool encrypted: Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
        :param str file_access_logs: Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the volume.
        :param str file_system_id: Unique FileSystem Identifier.
        :param str id: Resource Id
        :param float maximum_number_of_files: Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume quota is more than 4TiB.
        :param Sequence['MountTargetPropertiesResponse'] mount_targets: List of mount targets
        :param str network_sibling_set_id: Network Sibling Set ID for the the group of volumes sharing networking resources.
        :param str originating_resource_id: Id of the snapshot or backup that the volume is restored from.
        :param str provisioned_availability_zone: The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
        :param str provisioning_state: Azure lifecycle management
        :param str storage_to_network_proximity: Provides storage to network proximity information for the volume.
        :param str subnet_id: The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        :param str t2_network: T2 network information
        :param str type: Resource type
        :param float usage_threshold: Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume. Specified in bytes.
        :param str volume_group_name: Volume Group Name
        :param str avs_data_store: Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        :param str backup_id: UUID v4 or resource identifier used to identify the Backup.
        :param str capacity_pool_resource_id: Pool Resource Id used in case of creating a volume through volume group
        :param bool cool_access: Specifies whether Cool Access(tiering) is enabled for the volume.
        :param int coolness_period: Specifies the number of days after which data that is not accessed by clients will be tiered.
        :param 'VolumePropertiesResponseDataProtection' data_protection: DataProtection type volumes include an object containing details of the replication
        :param float default_group_quota_in_ki_bs: Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        :param float default_user_quota_in_ki_bs: Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        :param bool delete_base_snapshot: If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false
        :param str enable_subvolumes: Flag indicating whether subvolume operations are enabled on the volume
        :param str encryption_key_source: Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        :param 'VolumePropertiesResponseExportPolicy' export_policy: Set of export policy rules
        :param bool is_default_quota_enabled: Specifies if default quota is enabled for the volume.
        :param bool is_large_volume: Specifies whether volume is a Large Volume or Regular Volume.
        :param bool is_restoring: Restoring
        :param bool kerberos_enabled: Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        :param str key_vault_private_endpoint_resource_id: The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'.
        :param bool ldap_enabled: Specifies whether LDAP is enabled or not for a given NFS volume.
        :param str name: Resource name
        :param str network_features: Basic network, or Standard features available to the volume.
        :param Sequence['PlacementKeyValuePairsResponse'] placement_rules: Application specific placement rules for the particular volume
        :param Sequence[str] protocol_types: Set of protocol types, default NFSv3, CIFS for SMB protocol
        :param str proximity_placement_group: Proximity placement group associated with the volume
        :param str security_style: The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        :param str service_level: The service level of the file system
        :param str smb_access_based_enumeration: Enables access based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        :param bool smb_continuously_available: Enables continuously available share property for smb volume. Only applicable for SMB volume
        :param bool smb_encryption: Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later
        :param str smb_non_browsable: Enables non browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        :param bool snapshot_directory_visible: If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true).
        :param str snapshot_id: UUID v4 or resource identifier used to identify the Snapshot.
        :param Mapping[str, str] tags: Resource tags
        :param str unix_permissions: UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users.
        :param str volume_spec_name: Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log
        :param str volume_type: What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection
        """
        VolumeGroupVolumePropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actual_throughput_mibps=actual_throughput_mibps,
            baremetal_tenant_id=baremetal_tenant_id,
            clone_progress=clone_progress,
            creation_token=creation_token,
            data_store_resource_id=data_store_resource_id,
            encrypted=encrypted,
            file_access_logs=file_access_logs,
            file_system_id=file_system_id,
            id=id,
            maximum_number_of_files=maximum_number_of_files,
            mount_targets=mount_targets,
            network_sibling_set_id=network_sibling_set_id,
            originating_resource_id=originating_resource_id,
            provisioned_availability_zone=provisioned_availability_zone,
            provisioning_state=provisioning_state,
            storage_to_network_proximity=storage_to_network_proximity,
            subnet_id=subnet_id,
            t2_network=t2_network,
            type=type,
            usage_threshold=usage_threshold,
            volume_group_name=volume_group_name,
            avs_data_store=avs_data_store,
            backup_id=backup_id,
            capacity_pool_resource_id=capacity_pool_resource_id,
            cool_access=cool_access,
            coolness_period=coolness_period,
            data_protection=data_protection,
            default_group_quota_in_ki_bs=default_group_quota_in_ki_bs,
            default_user_quota_in_ki_bs=default_user_quota_in_ki_bs,
            delete_base_snapshot=delete_base_snapshot,
            enable_subvolumes=enable_subvolumes,
            encryption_key_source=encryption_key_source,
            export_policy=export_policy,
            is_default_quota_enabled=is_default_quota_enabled,
            is_large_volume=is_large_volume,
            is_restoring=is_restoring,
            kerberos_enabled=kerberos_enabled,
            key_vault_private_endpoint_resource_id=key_vault_private_endpoint_resource_id,
            ldap_enabled=ldap_enabled,
            name=name,
            network_features=network_features,
            placement_rules=placement_rules,
            protocol_types=protocol_types,
            proximity_placement_group=proximity_placement_group,
            security_style=security_style,
            service_level=service_level,
            smb_access_based_enumeration=smb_access_based_enumeration,
            smb_continuously_available=smb_continuously_available,
            smb_encryption=smb_encryption,
            smb_non_browsable=smb_non_browsable,
            snapshot_directory_visible=snapshot_directory_visible,
            snapshot_id=snapshot_id,
            tags=tags,
            throughput_mibps=throughput_mibps,
            unix_permissions=unix_permissions,
            volume_spec_name=volume_spec_name,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actual_throughput_mibps: Optional[float] = None,
             baremetal_tenant_id: Optional[str] = None,
             clone_progress: Optional[int] = None,
             creation_token: Optional[str] = None,
             data_store_resource_id: Optional[Sequence[str]] = None,
             encrypted: Optional[bool] = None,
             file_access_logs: Optional[str] = None,
             file_system_id: Optional[str] = None,
             id: Optional[str] = None,
             maximum_number_of_files: Optional[float] = None,
             mount_targets: Optional[Sequence['outputs.MountTargetPropertiesResponse']] = None,
             network_sibling_set_id: Optional[str] = None,
             originating_resource_id: Optional[str] = None,
             provisioned_availability_zone: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             storage_to_network_proximity: Optional[str] = None,
             subnet_id: Optional[str] = None,
             t2_network: Optional[str] = None,
             type: Optional[str] = None,
             usage_threshold: Optional[float] = None,
             volume_group_name: Optional[str] = None,
             avs_data_store: Optional[str] = None,
             backup_id: Optional[str] = None,
             capacity_pool_resource_id: Optional[str] = None,
             cool_access: Optional[bool] = None,
             coolness_period: Optional[int] = None,
             data_protection: Optional['outputs.VolumePropertiesResponseDataProtection'] = None,
             default_group_quota_in_ki_bs: Optional[float] = None,
             default_user_quota_in_ki_bs: Optional[float] = None,
             delete_base_snapshot: Optional[bool] = None,
             enable_subvolumes: Optional[str] = None,
             encryption_key_source: Optional[str] = None,
             export_policy: Optional['outputs.VolumePropertiesResponseExportPolicy'] = None,
             is_default_quota_enabled: Optional[bool] = None,
             is_large_volume: Optional[bool] = None,
             is_restoring: Optional[bool] = None,
             kerberos_enabled: Optional[bool] = None,
             key_vault_private_endpoint_resource_id: Optional[str] = None,
             ldap_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             network_features: Optional[str] = None,
             placement_rules: Optional[Sequence['outputs.PlacementKeyValuePairsResponse']] = None,
             protocol_types: Optional[Sequence[str]] = None,
             proximity_placement_group: Optional[str] = None,
             security_style: Optional[str] = None,
             service_level: Optional[str] = None,
             smb_access_based_enumeration: Optional[str] = None,
             smb_continuously_available: Optional[bool] = None,
             smb_encryption: Optional[bool] = None,
             smb_non_browsable: Optional[str] = None,
             snapshot_directory_visible: Optional[bool] = None,
             snapshot_id: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             throughput_mibps: Optional[float] = None,
             unix_permissions: Optional[str] = None,
             volume_spec_name: Optional[str] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actual_throughput_mibps is None and 'actualThroughputMibps' in kwargs:
            actual_throughput_mibps = kwargs['actualThroughputMibps']
        if actual_throughput_mibps is None:
            raise TypeError("Missing 'actual_throughput_mibps' argument")
        if baremetal_tenant_id is None and 'baremetalTenantId' in kwargs:
            baremetal_tenant_id = kwargs['baremetalTenantId']
        if baremetal_tenant_id is None:
            raise TypeError("Missing 'baremetal_tenant_id' argument")
        if clone_progress is None and 'cloneProgress' in kwargs:
            clone_progress = kwargs['cloneProgress']
        if clone_progress is None:
            raise TypeError("Missing 'clone_progress' argument")
        if creation_token is None and 'creationToken' in kwargs:
            creation_token = kwargs['creationToken']
        if creation_token is None:
            raise TypeError("Missing 'creation_token' argument")
        if data_store_resource_id is None and 'dataStoreResourceId' in kwargs:
            data_store_resource_id = kwargs['dataStoreResourceId']
        if data_store_resource_id is None:
            raise TypeError("Missing 'data_store_resource_id' argument")
        if encrypted is None:
            raise TypeError("Missing 'encrypted' argument")
        if file_access_logs is None and 'fileAccessLogs' in kwargs:
            file_access_logs = kwargs['fileAccessLogs']
        if file_system_id is None and 'fileSystemId' in kwargs:
            file_system_id = kwargs['fileSystemId']
        if file_system_id is None:
            raise TypeError("Missing 'file_system_id' argument")
        if id is None:
            raise TypeError("Missing 'id' argument")
        if maximum_number_of_files is None and 'maximumNumberOfFiles' in kwargs:
            maximum_number_of_files = kwargs['maximumNumberOfFiles']
        if maximum_number_of_files is None:
            raise TypeError("Missing 'maximum_number_of_files' argument")
        if mount_targets is None and 'mountTargets' in kwargs:
            mount_targets = kwargs['mountTargets']
        if mount_targets is None:
            raise TypeError("Missing 'mount_targets' argument")
        if network_sibling_set_id is None and 'networkSiblingSetId' in kwargs:
            network_sibling_set_id = kwargs['networkSiblingSetId']
        if network_sibling_set_id is None:
            raise TypeError("Missing 'network_sibling_set_id' argument")
        if originating_resource_id is None and 'originatingResourceId' in kwargs:
            originating_resource_id = kwargs['originatingResourceId']
        if originating_resource_id is None:
            raise TypeError("Missing 'originating_resource_id' argument")
        if provisioned_availability_zone is None and 'provisionedAvailabilityZone' in kwargs:
            provisioned_availability_zone = kwargs['provisionedAvailabilityZone']
        if provisioned_availability_zone is None:
            raise TypeError("Missing 'provisioned_availability_zone' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if storage_to_network_proximity is None and 'storageToNetworkProximity' in kwargs:
            storage_to_network_proximity = kwargs['storageToNetworkProximity']
        if storage_to_network_proximity is None:
            raise TypeError("Missing 'storage_to_network_proximity' argument")
        if subnet_id is None and 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if subnet_id is None:
            raise TypeError("Missing 'subnet_id' argument")
        if t2_network is None and 't2Network' in kwargs:
            t2_network = kwargs['t2Network']
        if t2_network is None:
            raise TypeError("Missing 't2_network' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if usage_threshold is None and 'usageThreshold' in kwargs:
            usage_threshold = kwargs['usageThreshold']
        if volume_group_name is None and 'volumeGroupName' in kwargs:
            volume_group_name = kwargs['volumeGroupName']
        if volume_group_name is None:
            raise TypeError("Missing 'volume_group_name' argument")
        if avs_data_store is None and 'avsDataStore' in kwargs:
            avs_data_store = kwargs['avsDataStore']
        if backup_id is None and 'backupId' in kwargs:
            backup_id = kwargs['backupId']
        if capacity_pool_resource_id is None and 'capacityPoolResourceId' in kwargs:
            capacity_pool_resource_id = kwargs['capacityPoolResourceId']
        if cool_access is None and 'coolAccess' in kwargs:
            cool_access = kwargs['coolAccess']
        if coolness_period is None and 'coolnessPeriod' in kwargs:
            coolness_period = kwargs['coolnessPeriod']
        if data_protection is None and 'dataProtection' in kwargs:
            data_protection = kwargs['dataProtection']
        if default_group_quota_in_ki_bs is None and 'defaultGroupQuotaInKiBs' in kwargs:
            default_group_quota_in_ki_bs = kwargs['defaultGroupQuotaInKiBs']
        if default_user_quota_in_ki_bs is None and 'defaultUserQuotaInKiBs' in kwargs:
            default_user_quota_in_ki_bs = kwargs['defaultUserQuotaInKiBs']
        if delete_base_snapshot is None and 'deleteBaseSnapshot' in kwargs:
            delete_base_snapshot = kwargs['deleteBaseSnapshot']
        if enable_subvolumes is None and 'enableSubvolumes' in kwargs:
            enable_subvolumes = kwargs['enableSubvolumes']
        if encryption_key_source is None and 'encryptionKeySource' in kwargs:
            encryption_key_source = kwargs['encryptionKeySource']
        if export_policy is None and 'exportPolicy' in kwargs:
            export_policy = kwargs['exportPolicy']
        if is_default_quota_enabled is None and 'isDefaultQuotaEnabled' in kwargs:
            is_default_quota_enabled = kwargs['isDefaultQuotaEnabled']
        if is_large_volume is None and 'isLargeVolume' in kwargs:
            is_large_volume = kwargs['isLargeVolume']
        if is_restoring is None and 'isRestoring' in kwargs:
            is_restoring = kwargs['isRestoring']
        if kerberos_enabled is None and 'kerberosEnabled' in kwargs:
            kerberos_enabled = kwargs['kerberosEnabled']
        if key_vault_private_endpoint_resource_id is None and 'keyVaultPrivateEndpointResourceId' in kwargs:
            key_vault_private_endpoint_resource_id = kwargs['keyVaultPrivateEndpointResourceId']
        if ldap_enabled is None and 'ldapEnabled' in kwargs:
            ldap_enabled = kwargs['ldapEnabled']
        if network_features is None and 'networkFeatures' in kwargs:
            network_features = kwargs['networkFeatures']
        if placement_rules is None and 'placementRules' in kwargs:
            placement_rules = kwargs['placementRules']
        if protocol_types is None and 'protocolTypes' in kwargs:
            protocol_types = kwargs['protocolTypes']
        if proximity_placement_group is None and 'proximityPlacementGroup' in kwargs:
            proximity_placement_group = kwargs['proximityPlacementGroup']
        if security_style is None and 'securityStyle' in kwargs:
            security_style = kwargs['securityStyle']
        if service_level is None and 'serviceLevel' in kwargs:
            service_level = kwargs['serviceLevel']
        if smb_access_based_enumeration is None and 'smbAccessBasedEnumeration' in kwargs:
            smb_access_based_enumeration = kwargs['smbAccessBasedEnumeration']
        if smb_continuously_available is None and 'smbContinuouslyAvailable' in kwargs:
            smb_continuously_available = kwargs['smbContinuouslyAvailable']
        if smb_encryption is None and 'smbEncryption' in kwargs:
            smb_encryption = kwargs['smbEncryption']
        if smb_non_browsable is None and 'smbNonBrowsable' in kwargs:
            smb_non_browsable = kwargs['smbNonBrowsable']
        if snapshot_directory_visible is None and 'snapshotDirectoryVisible' in kwargs:
            snapshot_directory_visible = kwargs['snapshotDirectoryVisible']
        if snapshot_id is None and 'snapshotId' in kwargs:
            snapshot_id = kwargs['snapshotId']
        if throughput_mibps is None and 'throughputMibps' in kwargs:
            throughput_mibps = kwargs['throughputMibps']
        if unix_permissions is None and 'unixPermissions' in kwargs:
            unix_permissions = kwargs['unixPermissions']
        if volume_spec_name is None and 'volumeSpecName' in kwargs:
            volume_spec_name = kwargs['volumeSpecName']
        if volume_type is None and 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        _setter("actual_throughput_mibps", actual_throughput_mibps)
        _setter("baremetal_tenant_id", baremetal_tenant_id)
        _setter("clone_progress", clone_progress)
        _setter("creation_token", creation_token)
        _setter("data_store_resource_id", data_store_resource_id)
        _setter("encrypted", encrypted)
        if file_access_logs is None:
            file_access_logs = 'Disabled'
        _setter("file_access_logs", file_access_logs)
        _setter("file_system_id", file_system_id)
        _setter("id", id)
        _setter("maximum_number_of_files", maximum_number_of_files)
        _setter("mount_targets", mount_targets)
        _setter("network_sibling_set_id", network_sibling_set_id)
        _setter("originating_resource_id", originating_resource_id)
        _setter("provisioned_availability_zone", provisioned_availability_zone)
        _setter("provisioning_state", provisioning_state)
        _setter("storage_to_network_proximity", storage_to_network_proximity)
        _setter("subnet_id", subnet_id)
        _setter("t2_network", t2_network)
        _setter("type", type)
        if usage_threshold is None:
            usage_threshold = 107374182400
        _setter("usage_threshold", usage_threshold)
        _setter("volume_group_name", volume_group_name)
        if avs_data_store is None:
            avs_data_store = 'Disabled'
        if avs_data_store is not None:
            _setter("avs_data_store", avs_data_store)
        if backup_id is not None:
            _setter("backup_id", backup_id)
        if capacity_pool_resource_id is not None:
            _setter("capacity_pool_resource_id", capacity_pool_resource_id)
        if cool_access is None:
            cool_access = False
        if cool_access is not None:
            _setter("cool_access", cool_access)
        if coolness_period is not None:
            _setter("coolness_period", coolness_period)
        if data_protection is not None:
            _setter("data_protection", data_protection)
        if default_group_quota_in_ki_bs is None:
            default_group_quota_in_ki_bs = 0
        if default_group_quota_in_ki_bs is not None:
            _setter("default_group_quota_in_ki_bs", default_group_quota_in_ki_bs)
        if default_user_quota_in_ki_bs is None:
            default_user_quota_in_ki_bs = 0
        if default_user_quota_in_ki_bs is not None:
            _setter("default_user_quota_in_ki_bs", default_user_quota_in_ki_bs)
        if delete_base_snapshot is not None:
            _setter("delete_base_snapshot", delete_base_snapshot)
        if enable_subvolumes is None:
            enable_subvolumes = 'Disabled'
        if enable_subvolumes is not None:
            _setter("enable_subvolumes", enable_subvolumes)
        if encryption_key_source is None:
            encryption_key_source = 'Microsoft.NetApp'
        if encryption_key_source is not None:
            _setter("encryption_key_source", encryption_key_source)
        if export_policy is not None:
            _setter("export_policy", export_policy)
        if is_default_quota_enabled is None:
            is_default_quota_enabled = False
        if is_default_quota_enabled is not None:
            _setter("is_default_quota_enabled", is_default_quota_enabled)
        if is_large_volume is None:
            is_large_volume = False
        if is_large_volume is not None:
            _setter("is_large_volume", is_large_volume)
        if is_restoring is not None:
            _setter("is_restoring", is_restoring)
        if kerberos_enabled is None:
            kerberos_enabled = False
        if kerberos_enabled is not None:
            _setter("kerberos_enabled", kerberos_enabled)
        if key_vault_private_endpoint_resource_id is not None:
            _setter("key_vault_private_endpoint_resource_id", key_vault_private_endpoint_resource_id)
        if ldap_enabled is None:
            ldap_enabled = False
        if ldap_enabled is not None:
            _setter("ldap_enabled", ldap_enabled)
        if name is not None:
            _setter("name", name)
        if network_features is None:
            network_features = 'Basic'
        if network_features is not None:
            _setter("network_features", network_features)
        if placement_rules is not None:
            _setter("placement_rules", placement_rules)
        if protocol_types is not None:
            _setter("protocol_types", protocol_types)
        if proximity_placement_group is not None:
            _setter("proximity_placement_group", proximity_placement_group)
        if security_style is None:
            security_style = 'unix'
        if security_style is not None:
            _setter("security_style", security_style)
        if service_level is not None:
            _setter("service_level", service_level)
        if smb_access_based_enumeration is not None:
            _setter("smb_access_based_enumeration", smb_access_based_enumeration)
        if smb_continuously_available is None:
            smb_continuously_available = False
        if smb_continuously_available is not None:
            _setter("smb_continuously_available", smb_continuously_available)
        if smb_encryption is None:
            smb_encryption = False
        if smb_encryption is not None:
            _setter("smb_encryption", smb_encryption)
        if smb_non_browsable is not None:
            _setter("smb_non_browsable", smb_non_browsable)
        if snapshot_directory_visible is None:
            snapshot_directory_visible = True
        if snapshot_directory_visible is not None:
            _setter("snapshot_directory_visible", snapshot_directory_visible)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if tags is not None:
            _setter("tags", tags)
        if throughput_mibps is not None:
            _setter("throughput_mibps", throughput_mibps)
        if unix_permissions is None:
            unix_permissions = '0770'
        if unix_permissions is not None:
            _setter("unix_permissions", unix_permissions)
        if volume_spec_name is not None:
            _setter("volume_spec_name", volume_spec_name)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="actualThroughputMibps")
    def actual_throughput_mibps(self) -> float:
        """
        Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
        """
        return pulumi.get(self, "actual_throughput_mibps")

    @property
    @pulumi.getter(name="baremetalTenantId")
    def baremetal_tenant_id(self) -> str:
        """
        Unique Baremetal Tenant Identifier.
        """
        return pulumi.get(self, "baremetal_tenant_id")

    @property
    @pulumi.getter(name="cloneProgress")
    def clone_progress(self) -> int:
        """
        When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process. When this value is empty/null there is no cloning process currently happening on this volume. This value will update every 5 minutes during cloning.
        """
        return pulumi.get(self, "clone_progress")

    @property
    @pulumi.getter(name="creationToken")
    def creation_token(self) -> str:
        """
        A unique file path for the volume. Used when creating mount targets
        """
        return pulumi.get(self, "creation_token")

    @property
    @pulumi.getter(name="dataStoreResourceId")
    def data_store_resource_id(self) -> Sequence[str]:
        """
        Data store resource unique identifier
        """
        return pulumi.get(self, "data_store_resource_id")

    @property
    @pulumi.getter
    def encrypted(self) -> bool:
        """
        Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="fileAccessLogs")
    def file_access_logs(self) -> str:
        """
        Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the volume.
        """
        return pulumi.get(self, "file_access_logs")

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> str:
        """
        Unique FileSystem Identifier.
        """
        return pulumi.get(self, "file_system_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource Id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maximumNumberOfFiles")
    def maximum_number_of_files(self) -> float:
        """
        Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume quota is more than 4TiB.
        """
        return pulumi.get(self, "maximum_number_of_files")

    @property
    @pulumi.getter(name="mountTargets")
    def mount_targets(self) -> Sequence['outputs.MountTargetPropertiesResponse']:
        """
        List of mount targets
        """
        return pulumi.get(self, "mount_targets")

    @property
    @pulumi.getter(name="networkSiblingSetId")
    def network_sibling_set_id(self) -> str:
        """
        Network Sibling Set ID for the the group of volumes sharing networking resources.
        """
        return pulumi.get(self, "network_sibling_set_id")

    @property
    @pulumi.getter(name="originatingResourceId")
    def originating_resource_id(self) -> str:
        """
        Id of the snapshot or backup that the volume is restored from.
        """
        return pulumi.get(self, "originating_resource_id")

    @property
    @pulumi.getter(name="provisionedAvailabilityZone")
    def provisioned_availability_zone(self) -> str:
        """
        The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
        """
        return pulumi.get(self, "provisioned_availability_zone")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Azure lifecycle management
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="storageToNetworkProximity")
    def storage_to_network_proximity(self) -> str:
        """
        Provides storage to network proximity information for the volume.
        """
        return pulumi.get(self, "storage_to_network_proximity")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="t2Network")
    def t2_network(self) -> str:
        """
        T2 network information
        """
        return pulumi.get(self, "t2_network")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="usageThreshold")
    def usage_threshold(self) -> float:
        """
        Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume. Specified in bytes.
        """
        return pulumi.get(self, "usage_threshold")

    @property
    @pulumi.getter(name="volumeGroupName")
    def volume_group_name(self) -> str:
        """
        Volume Group Name
        """
        return pulumi.get(self, "volume_group_name")

    @property
    @pulumi.getter(name="avsDataStore")
    def avs_data_store(self) -> Optional[str]:
        """
        Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        """
        return pulumi.get(self, "avs_data_store")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[str]:
        """
        UUID v4 or resource identifier used to identify the Backup.
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="capacityPoolResourceId")
    def capacity_pool_resource_id(self) -> Optional[str]:
        """
        Pool Resource Id used in case of creating a volume through volume group
        """
        return pulumi.get(self, "capacity_pool_resource_id")

    @property
    @pulumi.getter(name="coolAccess")
    def cool_access(self) -> Optional[bool]:
        """
        Specifies whether Cool Access(tiering) is enabled for the volume.
        """
        return pulumi.get(self, "cool_access")

    @property
    @pulumi.getter(name="coolnessPeriod")
    def coolness_period(self) -> Optional[int]:
        """
        Specifies the number of days after which data that is not accessed by clients will be tiered.
        """
        return pulumi.get(self, "coolness_period")

    @property
    @pulumi.getter(name="dataProtection")
    def data_protection(self) -> Optional['outputs.VolumePropertiesResponseDataProtection']:
        """
        DataProtection type volumes include an object containing details of the replication
        """
        return pulumi.get(self, "data_protection")

    @property
    @pulumi.getter(name="defaultGroupQuotaInKiBs")
    def default_group_quota_in_ki_bs(self) -> Optional[float]:
        """
        Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        """
        return pulumi.get(self, "default_group_quota_in_ki_bs")

    @property
    @pulumi.getter(name="defaultUserQuotaInKiBs")
    def default_user_quota_in_ki_bs(self) -> Optional[float]:
        """
        Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        """
        return pulumi.get(self, "default_user_quota_in_ki_bs")

    @property
    @pulumi.getter(name="deleteBaseSnapshot")
    def delete_base_snapshot(self) -> Optional[bool]:
        """
        If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false
        """
        return pulumi.get(self, "delete_base_snapshot")

    @property
    @pulumi.getter(name="enableSubvolumes")
    def enable_subvolumes(self) -> Optional[str]:
        """
        Flag indicating whether subvolume operations are enabled on the volume
        """
        return pulumi.get(self, "enable_subvolumes")

    @property
    @pulumi.getter(name="encryptionKeySource")
    def encryption_key_source(self) -> Optional[str]:
        """
        Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        """
        return pulumi.get(self, "encryption_key_source")

    @property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional['outputs.VolumePropertiesResponseExportPolicy']:
        """
        Set of export policy rules
        """
        return pulumi.get(self, "export_policy")

    @property
    @pulumi.getter(name="isDefaultQuotaEnabled")
    def is_default_quota_enabled(self) -> Optional[bool]:
        """
        Specifies if default quota is enabled for the volume.
        """
        return pulumi.get(self, "is_default_quota_enabled")

    @property
    @pulumi.getter(name="isLargeVolume")
    def is_large_volume(self) -> Optional[bool]:
        """
        Specifies whether volume is a Large Volume or Regular Volume.
        """
        return pulumi.get(self, "is_large_volume")

    @property
    @pulumi.getter(name="isRestoring")
    def is_restoring(self) -> Optional[bool]:
        """
        Restoring
        """
        return pulumi.get(self, "is_restoring")

    @property
    @pulumi.getter(name="kerberosEnabled")
    def kerberos_enabled(self) -> Optional[bool]:
        """
        Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos_enabled")

    @property
    @pulumi.getter(name="keyVaultPrivateEndpointResourceId")
    def key_vault_private_endpoint_resource_id(self) -> Optional[str]:
        """
        The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "key_vault_private_endpoint_resource_id")

    @property
    @pulumi.getter(name="ldapEnabled")
    def ldap_enabled(self) -> Optional[bool]:
        """
        Specifies whether LDAP is enabled or not for a given NFS volume.
        """
        return pulumi.get(self, "ldap_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Resource name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkFeatures")
    def network_features(self) -> Optional[str]:
        """
        Basic network, or Standard features available to the volume.
        """
        return pulumi.get(self, "network_features")

    @property
    @pulumi.getter(name="placementRules")
    def placement_rules(self) -> Optional[Sequence['outputs.PlacementKeyValuePairsResponse']]:
        """
        Application specific placement rules for the particular volume
        """
        return pulumi.get(self, "placement_rules")

    @property
    @pulumi.getter(name="protocolTypes")
    def protocol_types(self) -> Optional[Sequence[str]]:
        """
        Set of protocol types, default NFSv3, CIFS for SMB protocol
        """
        return pulumi.get(self, "protocol_types")

    @property
    @pulumi.getter(name="proximityPlacementGroup")
    def proximity_placement_group(self) -> Optional[str]:
        """
        Proximity placement group associated with the volume
        """
        return pulumi.get(self, "proximity_placement_group")

    @property
    @pulumi.getter(name="securityStyle")
    def security_style(self) -> Optional[str]:
        """
        The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        """
        return pulumi.get(self, "security_style")

    @property
    @pulumi.getter(name="serviceLevel")
    def service_level(self) -> Optional[str]:
        """
        The service level of the file system
        """
        return pulumi.get(self, "service_level")

    @property
    @pulumi.getter(name="smbAccessBasedEnumeration")
    def smb_access_based_enumeration(self) -> Optional[str]:
        """
        Enables access based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        """
        return pulumi.get(self, "smb_access_based_enumeration")

    @property
    @pulumi.getter(name="smbContinuouslyAvailable")
    def smb_continuously_available(self) -> Optional[bool]:
        """
        Enables continuously available share property for smb volume. Only applicable for SMB volume
        """
        return pulumi.get(self, "smb_continuously_available")

    @property
    @pulumi.getter(name="smbEncryption")
    def smb_encryption(self) -> Optional[bool]:
        """
        Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later
        """
        return pulumi.get(self, "smb_encryption")

    @property
    @pulumi.getter(name="smbNonBrowsable")
    def smb_non_browsable(self) -> Optional[str]:
        """
        Enables non browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        """
        return pulumi.get(self, "smb_non_browsable")

    @property
    @pulumi.getter(name="snapshotDirectoryVisible")
    def snapshot_directory_visible(self) -> Optional[bool]:
        """
        If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true).
        """
        return pulumi.get(self, "snapshot_directory_visible")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        UUID v4 or resource identifier used to identify the Snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="throughputMibps")
    def throughput_mibps(self) -> Optional[float]:
        return pulumi.get(self, "throughput_mibps")

    @property
    @pulumi.getter(name="unixPermissions")
    def unix_permissions(self) -> Optional[str]:
        """
        UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users.
        """
        return pulumi.get(self, "unix_permissions")

    @property
    @pulumi.getter(name="volumeSpecName")
    def volume_spec_name(self) -> Optional[str]:
        """
        Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log
        """
        return pulumi.get(self, "volume_spec_name")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class VolumePropertiesResponseDataProtection(dict):
    """
    DataProtection type volumes include an object containing details of the replication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeRelocation":
            suggest = "volume_relocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumePropertiesResponseDataProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumePropertiesResponseDataProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumePropertiesResponseDataProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup: Optional['outputs.VolumeBackupPropertiesResponse'] = None,
                 replication: Optional['outputs.ReplicationObjectResponse'] = None,
                 snapshot: Optional['outputs.VolumeSnapshotPropertiesResponse'] = None,
                 volume_relocation: Optional['outputs.VolumeRelocationPropertiesResponse'] = None):
        """
        DataProtection type volumes include an object containing details of the replication
        :param 'VolumeBackupPropertiesResponse' backup: Backup Properties
        :param 'ReplicationObjectResponse' replication: Replication properties
        :param 'VolumeSnapshotPropertiesResponse' snapshot: Snapshot properties.
        :param 'VolumeRelocationPropertiesResponse' volume_relocation: VolumeRelocation properties
        """
        VolumePropertiesResponseDataProtection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup=backup,
            replication=replication,
            snapshot=snapshot,
            volume_relocation=volume_relocation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup: Optional['outputs.VolumeBackupPropertiesResponse'] = None,
             replication: Optional['outputs.ReplicationObjectResponse'] = None,
             snapshot: Optional['outputs.VolumeSnapshotPropertiesResponse'] = None,
             volume_relocation: Optional['outputs.VolumeRelocationPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if volume_relocation is None and 'volumeRelocation' in kwargs:
            volume_relocation = kwargs['volumeRelocation']

        if backup is not None:
            _setter("backup", backup)
        if replication is not None:
            _setter("replication", replication)
        if snapshot is not None:
            _setter("snapshot", snapshot)
        if volume_relocation is not None:
            _setter("volume_relocation", volume_relocation)

    @property
    @pulumi.getter
    def backup(self) -> Optional['outputs.VolumeBackupPropertiesResponse']:
        """
        Backup Properties
        """
        return pulumi.get(self, "backup")

    @property
    @pulumi.getter
    def replication(self) -> Optional['outputs.ReplicationObjectResponse']:
        """
        Replication properties
        """
        return pulumi.get(self, "replication")

    @property
    @pulumi.getter
    def snapshot(self) -> Optional['outputs.VolumeSnapshotPropertiesResponse']:
        """
        Snapshot properties.
        """
        return pulumi.get(self, "snapshot")

    @property
    @pulumi.getter(name="volumeRelocation")
    def volume_relocation(self) -> Optional['outputs.VolumeRelocationPropertiesResponse']:
        """
        VolumeRelocation properties
        """
        return pulumi.get(self, "volume_relocation")


@pulumi.output_type
class VolumePropertiesResponseExportPolicy(dict):
    """
    Set of export policy rules
    """
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.ExportPolicyRuleResponse']] = None):
        """
        Set of export policy rules
        :param Sequence['ExportPolicyRuleResponse'] rules: Export policy rule
        """
        VolumePropertiesResponseExportPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[Sequence['outputs.ExportPolicyRuleResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.ExportPolicyRuleResponse']]:
        """
        Export policy rule
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class VolumeRelocationPropertiesResponse(dict):
    """
    Volume relocation properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readyToBeFinalized":
            suggest = "ready_to_be_finalized"
        elif key == "relocationRequested":
            suggest = "relocation_requested"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeRelocationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeRelocationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeRelocationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ready_to_be_finalized: bool,
                 relocation_requested: Optional[bool] = None):
        """
        Volume relocation properties
        :param bool ready_to_be_finalized: Has relocation finished and is ready to be cleaned up
        :param bool relocation_requested: Has relocation been requested for this volume
        """
        VolumeRelocationPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ready_to_be_finalized=ready_to_be_finalized,
            relocation_requested=relocation_requested,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ready_to_be_finalized: Optional[bool] = None,
             relocation_requested: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ready_to_be_finalized is None and 'readyToBeFinalized' in kwargs:
            ready_to_be_finalized = kwargs['readyToBeFinalized']
        if ready_to_be_finalized is None:
            raise TypeError("Missing 'ready_to_be_finalized' argument")
        if relocation_requested is None and 'relocationRequested' in kwargs:
            relocation_requested = kwargs['relocationRequested']

        _setter("ready_to_be_finalized", ready_to_be_finalized)
        if relocation_requested is not None:
            _setter("relocation_requested", relocation_requested)

    @property
    @pulumi.getter(name="readyToBeFinalized")
    def ready_to_be_finalized(self) -> bool:
        """
        Has relocation finished and is ready to be cleaned up
        """
        return pulumi.get(self, "ready_to_be_finalized")

    @property
    @pulumi.getter(name="relocationRequested")
    def relocation_requested(self) -> Optional[bool]:
        """
        Has relocation been requested for this volume
        """
        return pulumi.get(self, "relocation_requested")


@pulumi.output_type
class VolumeSnapshotPropertiesResponse(dict):
    """
    Volume Snapshot Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotPolicyId":
            suggest = "snapshot_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSnapshotPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSnapshotPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSnapshotPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 snapshot_policy_id: Optional[str] = None):
        """
        Volume Snapshot Properties
        :param str snapshot_policy_id: Snapshot Policy ResourceId
        """
        VolumeSnapshotPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            snapshot_policy_id=snapshot_policy_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             snapshot_policy_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if snapshot_policy_id is None and 'snapshotPolicyId' in kwargs:
            snapshot_policy_id = kwargs['snapshotPolicyId']

        if snapshot_policy_id is not None:
            _setter("snapshot_policy_id", snapshot_policy_id)

    @property
    @pulumi.getter(name="snapshotPolicyId")
    def snapshot_policy_id(self) -> Optional[str]:
        """
        Snapshot Policy ResourceId
        """
        return pulumi.get(self, "snapshot_policy_id")


@pulumi.output_type
class WeeklyScheduleResponse(dict):
    """
    Weekly Schedule properties, make a snapshot every week at a specific day or days
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotsToKeep":
            suggest = "snapshots_to_keep"
        elif key == "usedBytes":
            suggest = "used_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WeeklyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WeeklyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WeeklyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day: Optional[str] = None,
                 hour: Optional[int] = None,
                 minute: Optional[int] = None,
                 snapshots_to_keep: Optional[int] = None,
                 used_bytes: Optional[float] = None):
        """
        Weekly Schedule properties, make a snapshot every week at a specific day or days
        :param str day: Indicates which weekdays snapshot should be taken, accepts a comma separated list of week day names in english
        :param int hour: Indicates which hour in UTC timezone a snapshot should be taken
        :param int minute: Indicates which minute snapshot should be taken
        :param int snapshots_to_keep: Weekly snapshot count to keep
        :param float used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        WeeklyScheduleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day=day,
            hour=hour,
            minute=minute,
            snapshots_to_keep=snapshots_to_keep,
            used_bytes=used_bytes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day: Optional[str] = None,
             hour: Optional[int] = None,
             minute: Optional[int] = None,
             snapshots_to_keep: Optional[int] = None,
             used_bytes: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if snapshots_to_keep is None and 'snapshotsToKeep' in kwargs:
            snapshots_to_keep = kwargs['snapshotsToKeep']
        if used_bytes is None and 'usedBytes' in kwargs:
            used_bytes = kwargs['usedBytes']

        if day is not None:
            _setter("day", day)
        if hour is not None:
            _setter("hour", hour)
        if minute is not None:
            _setter("minute", minute)
        if snapshots_to_keep is not None:
            _setter("snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            _setter("used_bytes", used_bytes)

    @property
    @pulumi.getter
    def day(self) -> Optional[str]:
        """
        Indicates which weekdays snapshot should be taken, accepts a comma separated list of week day names in english
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def minute(self) -> Optional[int]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[int]:
        """
        Weekly snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[float]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")


