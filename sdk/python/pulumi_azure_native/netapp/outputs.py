# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AccountEncryptionResponse',
    'ActiveDirectoryResponse',
    'DailyScheduleResponse',
    'EncryptionIdentityResponse',
    'ExportPolicyRuleResponse',
    'HourlyScheduleResponse',
    'KeyVaultPropertiesResponse',
    'LdapSearchScopeOptResponse',
    'ManagedServiceIdentityResponse',
    'MonthlyScheduleResponse',
    'MountTargetPropertiesResponse',
    'PlacementKeyValuePairsResponse',
    'QuotaReportResponse',
    'ReplicationObjectResponse',
    'ReplicationResponse',
    'SystemDataResponse',
    'UserAssignedIdentityResponse',
    'VolumeBackupPropertiesResponse',
    'VolumeBackupsResponse',
    'VolumeGroupMetaDataResponse',
    'VolumeGroupVolumePropertiesResponse',
    'VolumePropertiesResponseDataProtection',
    'VolumePropertiesResponseExportPolicy',
    'VolumeRelocationPropertiesResponse',
    'VolumeSnapshotPropertiesResponse',
    'WeeklyScheduleResponse',
]

@pulumi.output_type
class AccountEncryptionResponse(dict):
    """
    Encryption settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keySource":
            suggest = "key_source"
        elif key == "keyVaultProperties":
            suggest = "key_vault_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountEncryptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountEncryptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountEncryptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: Optional['outputs.EncryptionIdentityResponse'] = None,
                 key_source: Optional[str] = None,
                 key_vault_properties: Optional['outputs.KeyVaultPropertiesResponse'] = None):
        """
        Encryption settings
        :param 'EncryptionIdentityResponse' identity: Identity used to authenticate to KeyVault. Applicable if keySource is 'Microsoft.KeyVault'.
        :param str key_source: The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault
        :param 'KeyVaultPropertiesResponse' key_vault_properties: Properties provided by KeVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if key_source is None:
            key_source = 'Microsoft.NetApp'
        if key_source is not None:
            pulumi.set(__self__, "key_source", key_source)
        if key_vault_properties is not None:
            pulumi.set(__self__, "key_vault_properties", key_vault_properties)

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.EncryptionIdentityResponse']:
        """
        Identity used to authenticate to KeyVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="keySource")
    def key_source(self) -> Optional[str]:
        """
        The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault
        """
        return pulumi.get(self, "key_source")

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> Optional['outputs.KeyVaultPropertiesResponse']:
        """
        Properties provided by KeVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "key_vault_properties")


@pulumi.output_type
class ActiveDirectoryResponse(dict):
    """
    Active Directory
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusDetails":
            suggest = "status_details"
        elif key == "activeDirectoryId":
            suggest = "active_directory_id"
        elif key == "adName":
            suggest = "ad_name"
        elif key == "aesEncryption":
            suggest = "aes_encryption"
        elif key == "allowLocalNfsUsersWithLdap":
            suggest = "allow_local_nfs_users_with_ldap"
        elif key == "backupOperators":
            suggest = "backup_operators"
        elif key == "encryptDCConnections":
            suggest = "encrypt_dc_connections"
        elif key == "kdcIP":
            suggest = "kdc_ip"
        elif key == "ldapOverTLS":
            suggest = "ldap_over_tls"
        elif key == "ldapSearchScope":
            suggest = "ldap_search_scope"
        elif key == "ldapSigning":
            suggest = "ldap_signing"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"
        elif key == "preferredServersForLdapClient":
            suggest = "preferred_servers_for_ldap_client"
        elif key == "securityOperators":
            suggest = "security_operators"
        elif key == "serverRootCACertificate":
            suggest = "server_root_ca_certificate"
        elif key == "smbServerName":
            suggest = "smb_server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveDirectoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveDirectoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveDirectoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 status_details: str,
                 active_directory_id: Optional[str] = None,
                 ad_name: Optional[str] = None,
                 administrators: Optional[Sequence[str]] = None,
                 aes_encryption: Optional[bool] = None,
                 allow_local_nfs_users_with_ldap: Optional[bool] = None,
                 backup_operators: Optional[Sequence[str]] = None,
                 dns: Optional[str] = None,
                 domain: Optional[str] = None,
                 encrypt_dc_connections: Optional[bool] = None,
                 kdc_ip: Optional[str] = None,
                 ldap_over_tls: Optional[bool] = None,
                 ldap_search_scope: Optional['outputs.LdapSearchScopeOptResponse'] = None,
                 ldap_signing: Optional[bool] = None,
                 organizational_unit: Optional[str] = None,
                 password: Optional[str] = None,
                 preferred_servers_for_ldap_client: Optional[str] = None,
                 security_operators: Optional[Sequence[str]] = None,
                 server_root_ca_certificate: Optional[str] = None,
                 site: Optional[str] = None,
                 smb_server_name: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Active Directory
        :param str status: Status of the Active Directory
        :param str status_details: Any details in regards to the Status of the Active Directory
        :param str active_directory_id: Id of the Active Directory
        :param str ad_name: Name of the active directory machine. This optional parameter is used only while creating kerberos volume
        :param Sequence[str] administrators: Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier
        :param bool aes_encryption: If enabled, AES encryption will be enabled for SMB communication.
        :param bool allow_local_nfs_users_with_ldap:  If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes.
        :param Sequence[str] backup_operators: Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier
        :param str dns: Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain
        :param str domain: Name of the Active Directory domain
        :param bool encrypt_dc_connections: If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted.
        :param str kdc_ip: kdc server IP addresses for the active directory machine. This optional parameter is used only while creating kerberos volume.
        :param bool ldap_over_tls: Specifies whether or not the LDAP traffic needs to be secured via TLS.
        :param 'LdapSearchScopeOptResponse' ldap_search_scope: LDAP Search scope options
        :param bool ldap_signing: Specifies whether or not the LDAP traffic needs to be signed.
        :param str organizational_unit: The Organizational Unit (OU) within the Windows Active Directory
        :param str password: Plain text password of Active Directory domain administrator, value is masked in the response
        :param str preferred_servers_for_ldap_client: Comma separated list of IPv4 addresses of preferred servers for LDAP client. At most two comma separated IPv4 addresses can be passed.
        :param Sequence[str] security_operators: Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier
        :param str server_root_ca_certificate: When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes.
        :param str site: The Active Directory site the service will limit Domain Controller discovery to
        :param str smb_server_name: NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
        :param str username: A domain user account with permission to create machine accounts
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_details", status_details)
        if active_directory_id is not None:
            pulumi.set(__self__, "active_directory_id", active_directory_id)
        if ad_name is not None:
            pulumi.set(__self__, "ad_name", ad_name)
        if administrators is not None:
            pulumi.set(__self__, "administrators", administrators)
        if aes_encryption is not None:
            pulumi.set(__self__, "aes_encryption", aes_encryption)
        if allow_local_nfs_users_with_ldap is not None:
            pulumi.set(__self__, "allow_local_nfs_users_with_ldap", allow_local_nfs_users_with_ldap)
        if backup_operators is not None:
            pulumi.set(__self__, "backup_operators", backup_operators)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if encrypt_dc_connections is not None:
            pulumi.set(__self__, "encrypt_dc_connections", encrypt_dc_connections)
        if kdc_ip is not None:
            pulumi.set(__self__, "kdc_ip", kdc_ip)
        if ldap_over_tls is not None:
            pulumi.set(__self__, "ldap_over_tls", ldap_over_tls)
        if ldap_search_scope is not None:
            pulumi.set(__self__, "ldap_search_scope", ldap_search_scope)
        if ldap_signing is not None:
            pulumi.set(__self__, "ldap_signing", ldap_signing)
        if organizational_unit is None:
            organizational_unit = 'CN=Computers'
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if preferred_servers_for_ldap_client is not None:
            pulumi.set(__self__, "preferred_servers_for_ldap_client", preferred_servers_for_ldap_client)
        if security_operators is not None:
            pulumi.set(__self__, "security_operators", security_operators)
        if server_root_ca_certificate is not None:
            pulumi.set(__self__, "server_root_ca_certificate", server_root_ca_certificate)
        if site is not None:
            pulumi.set(__self__, "site", site)
        if smb_server_name is not None:
            pulumi.set(__self__, "smb_server_name", smb_server_name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the Active Directory
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusDetails")
    def status_details(self) -> str:
        """
        Any details in regards to the Status of the Active Directory
        """
        return pulumi.get(self, "status_details")

    @property
    @pulumi.getter(name="activeDirectoryId")
    def active_directory_id(self) -> Optional[str]:
        """
        Id of the Active Directory
        """
        return pulumi.get(self, "active_directory_id")

    @property
    @pulumi.getter(name="adName")
    def ad_name(self) -> Optional[str]:
        """
        Name of the active directory machine. This optional parameter is used only while creating kerberos volume
        """
        return pulumi.get(self, "ad_name")

    @property
    @pulumi.getter
    def administrators(self) -> Optional[Sequence[str]]:
        """
        Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "administrators")

    @property
    @pulumi.getter(name="aesEncryption")
    def aes_encryption(self) -> Optional[bool]:
        """
        If enabled, AES encryption will be enabled for SMB communication.
        """
        return pulumi.get(self, "aes_encryption")

    @property
    @pulumi.getter(name="allowLocalNfsUsersWithLdap")
    def allow_local_nfs_users_with_ldap(self) -> Optional[bool]:
        """
         If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes.
        """
        return pulumi.get(self, "allow_local_nfs_users_with_ldap")

    @property
    @pulumi.getter(name="backupOperators")
    def backup_operators(self) -> Optional[Sequence[str]]:
        """
        Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "backup_operators")

    @property
    @pulumi.getter
    def dns(self) -> Optional[str]:
        """
        Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Name of the Active Directory domain
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="encryptDCConnections")
    def encrypt_dc_connections(self) -> Optional[bool]:
        """
        If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted.
        """
        return pulumi.get(self, "encrypt_dc_connections")

    @property
    @pulumi.getter(name="kdcIP")
    def kdc_ip(self) -> Optional[str]:
        """
        kdc server IP addresses for the active directory machine. This optional parameter is used only while creating kerberos volume.
        """
        return pulumi.get(self, "kdc_ip")

    @property
    @pulumi.getter(name="ldapOverTLS")
    def ldap_over_tls(self) -> Optional[bool]:
        """
        Specifies whether or not the LDAP traffic needs to be secured via TLS.
        """
        return pulumi.get(self, "ldap_over_tls")

    @property
    @pulumi.getter(name="ldapSearchScope")
    def ldap_search_scope(self) -> Optional['outputs.LdapSearchScopeOptResponse']:
        """
        LDAP Search scope options
        """
        return pulumi.get(self, "ldap_search_scope")

    @property
    @pulumi.getter(name="ldapSigning")
    def ldap_signing(self) -> Optional[bool]:
        """
        Specifies whether or not the LDAP traffic needs to be signed.
        """
        return pulumi.get(self, "ldap_signing")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[str]:
        """
        The Organizational Unit (OU) within the Windows Active Directory
        """
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Plain text password of Active Directory domain administrator, value is masked in the response
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="preferredServersForLdapClient")
    def preferred_servers_for_ldap_client(self) -> Optional[str]:
        """
        Comma separated list of IPv4 addresses of preferred servers for LDAP client. At most two comma separated IPv4 addresses can be passed.
        """
        return pulumi.get(self, "preferred_servers_for_ldap_client")

    @property
    @pulumi.getter(name="securityOperators")
    def security_operators(self) -> Optional[Sequence[str]]:
        """
        Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "security_operators")

    @property
    @pulumi.getter(name="serverRootCACertificate")
    def server_root_ca_certificate(self) -> Optional[str]:
        """
        When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes.
        """
        return pulumi.get(self, "server_root_ca_certificate")

    @property
    @pulumi.getter
    def site(self) -> Optional[str]:
        """
        The Active Directory site the service will limit Domain Controller discovery to
        """
        return pulumi.get(self, "site")

    @property
    @pulumi.getter(name="smbServerName")
    def smb_server_name(self) -> Optional[str]:
        """
        NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
        """
        return pulumi.get(self, "smb_server_name")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A domain user account with permission to create machine accounts
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DailyScheduleResponse(dict):
    """
    Daily Schedule properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotsToKeep":
            suggest = "snapshots_to_keep"
        elif key == "usedBytes":
            suggest = "used_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DailyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DailyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DailyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hour: Optional[int] = None,
                 minute: Optional[int] = None,
                 snapshots_to_keep: Optional[int] = None,
                 used_bytes: Optional[float] = None):
        """
        Daily Schedule properties
        :param int hour: Indicates which hour in UTC timezone a snapshot should be taken
        :param int minute: Indicates which minute snapshot should be taken
        :param int snapshots_to_keep: Daily snapshot count to keep
        :param float used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if snapshots_to_keep is not None:
            pulumi.set(__self__, "snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            pulumi.set(__self__, "used_bytes", used_bytes)

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def minute(self) -> Optional[int]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[int]:
        """
        Daily snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[float]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")


@pulumi.output_type
class EncryptionIdentityResponse(dict):
    """
    Identity used to authenticate with key vault.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 user_assigned_identity: Optional[str] = None):
        """
        Identity used to authenticate with key vault.
        :param str principal_id: The principal ID (object ID) of the identity used to authenticate with key vault. Read-only.
        :param str user_assigned_identity: The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID (object ID) of the identity used to authenticate with key vault. Read-only.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[str]:
        """
        The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities.
        """
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class ExportPolicyRuleResponse(dict):
    """
    Volume Export Policy Rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedClients":
            suggest = "allowed_clients"
        elif key == "chownMode":
            suggest = "chown_mode"
        elif key == "hasRootAccess":
            suggest = "has_root_access"
        elif key == "kerberos5ReadOnly":
            suggest = "kerberos5_read_only"
        elif key == "kerberos5ReadWrite":
            suggest = "kerberos5_read_write"
        elif key == "kerberos5iReadOnly":
            suggest = "kerberos5i_read_only"
        elif key == "kerberos5iReadWrite":
            suggest = "kerberos5i_read_write"
        elif key == "kerberos5pReadOnly":
            suggest = "kerberos5p_read_only"
        elif key == "kerberos5pReadWrite":
            suggest = "kerberos5p_read_write"
        elif key == "ruleIndex":
            suggest = "rule_index"
        elif key == "unixReadOnly":
            suggest = "unix_read_only"
        elif key == "unixReadWrite":
            suggest = "unix_read_write"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportPolicyRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportPolicyRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportPolicyRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_clients: Optional[str] = None,
                 chown_mode: Optional[str] = None,
                 cifs: Optional[bool] = None,
                 has_root_access: Optional[bool] = None,
                 kerberos5_read_only: Optional[bool] = None,
                 kerberos5_read_write: Optional[bool] = None,
                 kerberos5i_read_only: Optional[bool] = None,
                 kerberos5i_read_write: Optional[bool] = None,
                 kerberos5p_read_only: Optional[bool] = None,
                 kerberos5p_read_write: Optional[bool] = None,
                 nfsv3: Optional[bool] = None,
                 nfsv41: Optional[bool] = None,
                 rule_index: Optional[int] = None,
                 unix_read_only: Optional[bool] = None,
                 unix_read_write: Optional[bool] = None):
        """
        Volume Export Policy Rule
        :param str allowed_clients: Client ingress specification as comma separated string with IPv4 CIDRs, IPv4 host addresses and host names
        :param str chown_mode: This parameter specifies who is authorized to change the ownership of a file. restricted - Only root user can change the ownership of the file. unrestricted - Non-root users can change ownership of files that they own.
        :param bool cifs: Allows CIFS protocol
        :param bool has_root_access: Has root access to volume
        :param bool kerberos5_read_only: Kerberos5 Read only access. To be use with swagger version 2020-05-01 or later
        :param bool kerberos5_read_write: Kerberos5 Read and write access. To be use with swagger version 2020-05-01 or later
        :param bool kerberos5i_read_only: Kerberos5i Read only access. To be use with swagger version 2020-05-01 or later
        :param bool kerberos5i_read_write: Kerberos5i Read and write access. To be use with swagger version 2020-05-01 or later
        :param bool kerberos5p_read_only: Kerberos5p Read only access. To be use with swagger version 2020-05-01 or later
        :param bool kerberos5p_read_write: Kerberos5p Read and write access. To be use with swagger version 2020-05-01 or later
        :param bool nfsv3: Allows NFSv3 protocol. Enable only for NFSv3 type volumes
        :param bool nfsv41: Allows NFSv4.1 protocol. Enable only for NFSv4.1 type volumes
        :param int rule_index: Order index
        :param bool unix_read_only: Read only access
        :param bool unix_read_write: Read and write access
        """
        if allowed_clients is not None:
            pulumi.set(__self__, "allowed_clients", allowed_clients)
        if chown_mode is None:
            chown_mode = 'Restricted'
        if chown_mode is not None:
            pulumi.set(__self__, "chown_mode", chown_mode)
        if cifs is not None:
            pulumi.set(__self__, "cifs", cifs)
        if has_root_access is None:
            has_root_access = True
        if has_root_access is not None:
            pulumi.set(__self__, "has_root_access", has_root_access)
        if kerberos5_read_only is None:
            kerberos5_read_only = False
        if kerberos5_read_only is not None:
            pulumi.set(__self__, "kerberos5_read_only", kerberos5_read_only)
        if kerberos5_read_write is None:
            kerberos5_read_write = False
        if kerberos5_read_write is not None:
            pulumi.set(__self__, "kerberos5_read_write", kerberos5_read_write)
        if kerberos5i_read_only is None:
            kerberos5i_read_only = False
        if kerberos5i_read_only is not None:
            pulumi.set(__self__, "kerberos5i_read_only", kerberos5i_read_only)
        if kerberos5i_read_write is None:
            kerberos5i_read_write = False
        if kerberos5i_read_write is not None:
            pulumi.set(__self__, "kerberos5i_read_write", kerberos5i_read_write)
        if kerberos5p_read_only is None:
            kerberos5p_read_only = False
        if kerberos5p_read_only is not None:
            pulumi.set(__self__, "kerberos5p_read_only", kerberos5p_read_only)
        if kerberos5p_read_write is None:
            kerberos5p_read_write = False
        if kerberos5p_read_write is not None:
            pulumi.set(__self__, "kerberos5p_read_write", kerberos5p_read_write)
        if nfsv3 is not None:
            pulumi.set(__self__, "nfsv3", nfsv3)
        if nfsv41 is not None:
            pulumi.set(__self__, "nfsv41", nfsv41)
        if rule_index is not None:
            pulumi.set(__self__, "rule_index", rule_index)
        if unix_read_only is not None:
            pulumi.set(__self__, "unix_read_only", unix_read_only)
        if unix_read_write is not None:
            pulumi.set(__self__, "unix_read_write", unix_read_write)

    @property
    @pulumi.getter(name="allowedClients")
    def allowed_clients(self) -> Optional[str]:
        """
        Client ingress specification as comma separated string with IPv4 CIDRs, IPv4 host addresses and host names
        """
        return pulumi.get(self, "allowed_clients")

    @property
    @pulumi.getter(name="chownMode")
    def chown_mode(self) -> Optional[str]:
        """
        This parameter specifies who is authorized to change the ownership of a file. restricted - Only root user can change the ownership of the file. unrestricted - Non-root users can change ownership of files that they own.
        """
        return pulumi.get(self, "chown_mode")

    @property
    @pulumi.getter
    def cifs(self) -> Optional[bool]:
        """
        Allows CIFS protocol
        """
        return pulumi.get(self, "cifs")

    @property
    @pulumi.getter(name="hasRootAccess")
    def has_root_access(self) -> Optional[bool]:
        """
        Has root access to volume
        """
        return pulumi.get(self, "has_root_access")

    @property
    @pulumi.getter(name="kerberos5ReadOnly")
    def kerberos5_read_only(self) -> Optional[bool]:
        """
        Kerberos5 Read only access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5_read_only")

    @property
    @pulumi.getter(name="kerberos5ReadWrite")
    def kerberos5_read_write(self) -> Optional[bool]:
        """
        Kerberos5 Read and write access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5_read_write")

    @property
    @pulumi.getter(name="kerberos5iReadOnly")
    def kerberos5i_read_only(self) -> Optional[bool]:
        """
        Kerberos5i Read only access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5i_read_only")

    @property
    @pulumi.getter(name="kerberos5iReadWrite")
    def kerberos5i_read_write(self) -> Optional[bool]:
        """
        Kerberos5i Read and write access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5i_read_write")

    @property
    @pulumi.getter(name="kerberos5pReadOnly")
    def kerberos5p_read_only(self) -> Optional[bool]:
        """
        Kerberos5p Read only access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5p_read_only")

    @property
    @pulumi.getter(name="kerberos5pReadWrite")
    def kerberos5p_read_write(self) -> Optional[bool]:
        """
        Kerberos5p Read and write access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5p_read_write")

    @property
    @pulumi.getter
    def nfsv3(self) -> Optional[bool]:
        """
        Allows NFSv3 protocol. Enable only for NFSv3 type volumes
        """
        return pulumi.get(self, "nfsv3")

    @property
    @pulumi.getter
    def nfsv41(self) -> Optional[bool]:
        """
        Allows NFSv4.1 protocol. Enable only for NFSv4.1 type volumes
        """
        return pulumi.get(self, "nfsv41")

    @property
    @pulumi.getter(name="ruleIndex")
    def rule_index(self) -> Optional[int]:
        """
        Order index
        """
        return pulumi.get(self, "rule_index")

    @property
    @pulumi.getter(name="unixReadOnly")
    def unix_read_only(self) -> Optional[bool]:
        """
        Read only access
        """
        return pulumi.get(self, "unix_read_only")

    @property
    @pulumi.getter(name="unixReadWrite")
    def unix_read_write(self) -> Optional[bool]:
        """
        Read and write access
        """
        return pulumi.get(self, "unix_read_write")


@pulumi.output_type
class HourlyScheduleResponse(dict):
    """
    Hourly Schedule properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotsToKeep":
            suggest = "snapshots_to_keep"
        elif key == "usedBytes":
            suggest = "used_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HourlyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HourlyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HourlyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minute: Optional[int] = None,
                 snapshots_to_keep: Optional[int] = None,
                 used_bytes: Optional[float] = None):
        """
        Hourly Schedule properties
        :param int minute: Indicates which minute snapshot should be taken
        :param int snapshots_to_keep: Hourly snapshot count to keep
        :param float used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if snapshots_to_keep is not None:
            pulumi.set(__self__, "snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            pulumi.set(__self__, "used_bytes", used_bytes)

    @property
    @pulumi.getter
    def minute(self) -> Optional[int]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[int]:
        """
        Hourly snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[float]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")


@pulumi.output_type
class KeyVaultPropertiesResponse(dict):
    """
    Properties of key vault.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyName":
            suggest = "key_name"
        elif key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "keyVaultResourceId":
            suggest = "key_vault_resource_id"
        elif key == "keyVaultUri":
            suggest = "key_vault_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_name: str,
                 key_vault_id: str,
                 key_vault_resource_id: str,
                 key_vault_uri: str,
                 status: str):
        """
        Properties of key vault.
        :param str key_name: The name of KeyVault key.
        :param str key_vault_id: UUID v4 used to identify the Azure Key Vault configuration
        :param str key_vault_resource_id: The resource ID of KeyVault.
        :param str key_vault_uri: The Uri of KeyVault.
        :param str status: Status of the KeyVault connection.
        """
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "key_vault_id", key_vault_id)
        pulumi.set(__self__, "key_vault_resource_id", key_vault_resource_id)
        pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        The name of KeyVault key.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        UUID v4 used to identify the Azure Key Vault configuration
        """
        return pulumi.get(self, "key_vault_id")

    @property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> str:
        """
        The resource ID of KeyVault.
        """
        return pulumi.get(self, "key_vault_resource_id")

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> str:
        """
        The Uri of KeyVault.
        """
        return pulumi.get(self, "key_vault_uri")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the KeyVault connection.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class LdapSearchScopeOptResponse(dict):
    """
    LDAP search scope 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupDN":
            suggest = "group_dn"
        elif key == "groupMembershipFilter":
            suggest = "group_membership_filter"
        elif key == "userDN":
            suggest = "user_dn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LdapSearchScopeOptResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LdapSearchScopeOptResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LdapSearchScopeOptResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_dn: Optional[str] = None,
                 group_membership_filter: Optional[str] = None,
                 user_dn: Optional[str] = None):
        """
        LDAP search scope 
        :param str group_dn: This specifies the group DN, which overrides the base DN for group lookups.
        :param str group_membership_filter: This specifies the custom LDAP search filter to be used when looking up group membership from LDAP server.
        :param str user_dn: This specifies the user DN, which overrides the base DN for user lookups.
        """
        if group_dn is not None:
            pulumi.set(__self__, "group_dn", group_dn)
        if group_membership_filter is not None:
            pulumi.set(__self__, "group_membership_filter", group_membership_filter)
        if user_dn is not None:
            pulumi.set(__self__, "user_dn", user_dn)

    @property
    @pulumi.getter(name="groupDN")
    def group_dn(self) -> Optional[str]:
        """
        This specifies the group DN, which overrides the base DN for group lookups.
        """
        return pulumi.get(self, "group_dn")

    @property
    @pulumi.getter(name="groupMembershipFilter")
    def group_membership_filter(self) -> Optional[str]:
        """
        This specifies the custom LDAP search filter to be used when looking up group membership from LDAP server.
        """
        return pulumi.get(self, "group_membership_filter")

    @property
    @pulumi.getter(name="userDN")
    def user_dn(self) -> Optional[str]:
        """
        This specifies the user DN, which overrides the base DN for user lookups.
        """
        return pulumi.get(self, "user_dn")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MonthlyScheduleResponse(dict):
    """
    Monthly Schedule properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfMonth":
            suggest = "days_of_month"
        elif key == "snapshotsToKeep":
            suggest = "snapshots_to_keep"
        elif key == "usedBytes":
            suggest = "used_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonthlyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonthlyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonthlyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_month: Optional[str] = None,
                 hour: Optional[int] = None,
                 minute: Optional[int] = None,
                 snapshots_to_keep: Optional[int] = None,
                 used_bytes: Optional[float] = None):
        """
        Monthly Schedule properties
        :param str days_of_month: Indicates which days of the month snapshot should be taken. A comma delimited string.
        :param int hour: Indicates which hour in UTC timezone a snapshot should be taken
        :param int minute: Indicates which minute snapshot should be taken
        :param int snapshots_to_keep: Monthly snapshot count to keep
        :param float used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        if days_of_month is not None:
            pulumi.set(__self__, "days_of_month", days_of_month)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if snapshots_to_keep is not None:
            pulumi.set(__self__, "snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            pulumi.set(__self__, "used_bytes", used_bytes)

    @property
    @pulumi.getter(name="daysOfMonth")
    def days_of_month(self) -> Optional[str]:
        """
        Indicates which days of the month snapshot should be taken. A comma delimited string.
        """
        return pulumi.get(self, "days_of_month")

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def minute(self) -> Optional[int]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[int]:
        """
        Monthly snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[float]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")


@pulumi.output_type
class MountTargetPropertiesResponse(dict):
    """
    Mount target properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemId":
            suggest = "file_system_id"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "mountTargetId":
            suggest = "mount_target_id"
        elif key == "smbServerFqdn":
            suggest = "smb_server_fqdn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountTargetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountTargetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountTargetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_id: str,
                 ip_address: str,
                 mount_target_id: str,
                 smb_server_fqdn: Optional[str] = None):
        """
        Mount target properties
        :param str file_system_id: UUID v4 used to identify the MountTarget
        :param str ip_address: The mount target's IPv4 address
        :param str mount_target_id: UUID v4 used to identify the MountTarget
        :param str smb_server_fqdn: The SMB server's Fully Qualified Domain Name, FQDN
        """
        pulumi.set(__self__, "file_system_id", file_system_id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "mount_target_id", mount_target_id)
        if smb_server_fqdn is not None:
            pulumi.set(__self__, "smb_server_fqdn", smb_server_fqdn)

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> str:
        """
        UUID v4 used to identify the MountTarget
        """
        return pulumi.get(self, "file_system_id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The mount target's IPv4 address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="mountTargetId")
    def mount_target_id(self) -> str:
        """
        UUID v4 used to identify the MountTarget
        """
        return pulumi.get(self, "mount_target_id")

    @property
    @pulumi.getter(name="smbServerFqdn")
    def smb_server_fqdn(self) -> Optional[str]:
        """
        The SMB server's Fully Qualified Domain Name, FQDN
        """
        return pulumi.get(self, "smb_server_fqdn")


@pulumi.output_type
class PlacementKeyValuePairsResponse(dict):
    """
    Application specific parameters for the placement of volumes in the volume group
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        Application specific parameters for the placement of volumes in the volume group
        :param str key: Key for an application specific parameter for the placement of volumes in the volume group
        :param str value: Value for an application specific parameter for the placement of volumes in the volume group
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key for an application specific parameter for the placement of volumes in the volume group
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for an application specific parameter for the placement of volumes in the volume group
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class QuotaReportResponse(dict):
    """
    Quota report record properties
    """
    def __init__(__self__, *,
                 is_derived_quota: Optional[bool] = None,
                 percentage_used: Optional[float] = None,
                 quota_limit_total_in_ki_bs: Optional[float] = None,
                 quota_limit_used_in_ki_bs: Optional[float] = None,
                 quota_target: Optional[str] = None,
                 quota_type: Optional[str] = None):
        """
        Quota report record properties
        :param bool is_derived_quota: Flag to indicate whether the quota is derived from default quota.
        :param float percentage_used: Percentage of used size compared to total size.
        :param float quota_limit_total_in_ki_bs: Specifies the total size limit in kibibytes for the user/group quota.
        :param float quota_limit_used_in_ki_bs: Specifies the current usage in kibibytes for the user/group quota.
        :param str quota_target: UserID/GroupID/SID based on the quota target type. UserID and groupID can be found by running id or getent command for the user or group and SID can be found by running <wmic useraccount where name='user-name' get sid>
        :param str quota_type: Type of quota
        """
        if is_derived_quota is not None:
            pulumi.set(__self__, "is_derived_quota", is_derived_quota)
        if percentage_used is not None:
            pulumi.set(__self__, "percentage_used", percentage_used)
        if quota_limit_total_in_ki_bs is not None:
            pulumi.set(__self__, "quota_limit_total_in_ki_bs", quota_limit_total_in_ki_bs)
        if quota_limit_used_in_ki_bs is not None:
            pulumi.set(__self__, "quota_limit_used_in_ki_bs", quota_limit_used_in_ki_bs)
        if quota_target is not None:
            pulumi.set(__self__, "quota_target", quota_target)
        if quota_type is not None:
            pulumi.set(__self__, "quota_type", quota_type)

    @property
    @pulumi.getter(name="isDerivedQuota")
    def is_derived_quota(self) -> Optional[bool]:
        """
        Flag to indicate whether the quota is derived from default quota.
        """
        return pulumi.get(self, "is_derived_quota")

    @property
    @pulumi.getter(name="percentageUsed")
    def percentage_used(self) -> Optional[float]:
        """
        Percentage of used size compared to total size.
        """
        return pulumi.get(self, "percentage_used")

    @property
    @pulumi.getter(name="quotaLimitTotalInKiBs")
    def quota_limit_total_in_ki_bs(self) -> Optional[float]:
        """
        Specifies the total size limit in kibibytes for the user/group quota.
        """
        return pulumi.get(self, "quota_limit_total_in_ki_bs")

    @property
    @pulumi.getter(name="quotaLimitUsedInKiBs")
    def quota_limit_used_in_ki_bs(self) -> Optional[float]:
        """
        Specifies the current usage in kibibytes for the user/group quota.
        """
        return pulumi.get(self, "quota_limit_used_in_ki_bs")

    @property
    @pulumi.getter(name="quotaTarget")
    def quota_target(self) -> Optional[str]:
        """
        UserID/GroupID/SID based on the quota target type. UserID and groupID can be found by running id or getent command for the user or group and SID can be found by running <wmic useraccount where name='user-name' get sid>
        """
        return pulumi.get(self, "quota_target")

    @property
    @pulumi.getter(name="quotaType")
    def quota_type(self) -> Optional[str]:
        """
        Type of quota
        """
        return pulumi.get(self, "quota_type")


@pulumi.output_type
class ReplicationObjectResponse(dict):
    """
    Replication properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteVolumeResourceId":
            suggest = "remote_volume_resource_id"
        elif key == "endpointType":
            suggest = "endpoint_type"
        elif key == "remoteVolumeRegion":
            suggest = "remote_volume_region"
        elif key == "replicationId":
            suggest = "replication_id"
        elif key == "replicationSchedule":
            suggest = "replication_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationObjectResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationObjectResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationObjectResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remote_volume_resource_id: str,
                 endpoint_type: Optional[str] = None,
                 remote_volume_region: Optional[str] = None,
                 replication_id: Optional[str] = None,
                 replication_schedule: Optional[str] = None):
        """
        Replication properties
        :param str remote_volume_resource_id: The resource ID of the remote volume.
        :param str endpoint_type: Indicates whether the local volume is the source or destination for the Volume Replication
        :param str remote_volume_region: The remote region for the other end of the Volume Replication.
        :param str replication_id: Id
        :param str replication_schedule: Schedule
        """
        pulumi.set(__self__, "remote_volume_resource_id", remote_volume_resource_id)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if remote_volume_region is not None:
            pulumi.set(__self__, "remote_volume_region", remote_volume_region)
        if replication_id is not None:
            pulumi.set(__self__, "replication_id", replication_id)
        if replication_schedule is not None:
            pulumi.set(__self__, "replication_schedule", replication_schedule)

    @property
    @pulumi.getter(name="remoteVolumeResourceId")
    def remote_volume_resource_id(self) -> str:
        """
        The resource ID of the remote volume.
        """
        return pulumi.get(self, "remote_volume_resource_id")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[str]:
        """
        Indicates whether the local volume is the source or destination for the Volume Replication
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="remoteVolumeRegion")
    def remote_volume_region(self) -> Optional[str]:
        """
        The remote region for the other end of the Volume Replication.
        """
        return pulumi.get(self, "remote_volume_region")

    @property
    @pulumi.getter(name="replicationId")
    def replication_id(self) -> Optional[str]:
        """
        Id
        """
        return pulumi.get(self, "replication_id")

    @property
    @pulumi.getter(name="replicationSchedule")
    def replication_schedule(self) -> Optional[str]:
        """
        Schedule
        """
        return pulumi.get(self, "replication_schedule")


@pulumi.output_type
class ReplicationResponse(dict):
    """
    Replication properties
    """
    def __init__(__self__, *,
                 remote_volume_resource_id: str,
                 endpoint_type: Optional[str] = None,
                 remote_volume_region: Optional[str] = None,
                 replication_schedule: Optional[str] = None):
        """
        Replication properties
        :param str remote_volume_resource_id: The resource ID of the remote volume.
        :param str endpoint_type: Indicates whether the local volume is the source or destination for the Volume Replication
        :param str remote_volume_region: The remote region for the other end of the Volume Replication.
        :param str replication_schedule: Schedule
        """
        pulumi.set(__self__, "remote_volume_resource_id", remote_volume_resource_id)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if remote_volume_region is not None:
            pulumi.set(__self__, "remote_volume_region", remote_volume_region)
        if replication_schedule is not None:
            pulumi.set(__self__, "replication_schedule", replication_schedule)

    @property
    @pulumi.getter(name="remoteVolumeResourceId")
    def remote_volume_resource_id(self) -> str:
        """
        The resource ID of the remote volume.
        """
        return pulumi.get(self, "remote_volume_resource_id")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[str]:
        """
        Indicates whether the local volume is the source or destination for the Volume Replication
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="remoteVolumeRegion")
    def remote_volume_region(self) -> Optional[str]:
        """
        The remote region for the other end of the Volume Replication.
        """
        return pulumi.get(self, "remote_volume_region")

    @property
    @pulumi.getter(name="replicationSchedule")
    def replication_schedule(self) -> Optional[str]:
        """
        Schedule
        """
        return pulumi.get(self, "replication_schedule")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        User assigned identity properties
        :param str client_id: The client ID of the assigned identity.
        :param str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VolumeBackupPropertiesResponse(dict):
    """
    Volume Backup Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupEnabled":
            suggest = "backup_enabled"
        elif key == "backupPolicyId":
            suggest = "backup_policy_id"
        elif key == "policyEnforced":
            suggest = "policy_enforced"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeBackupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeBackupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeBackupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_enabled: Optional[bool] = None,
                 backup_policy_id: Optional[str] = None,
                 policy_enforced: Optional[bool] = None):
        """
        Volume Backup Properties
        :param bool backup_enabled: Backup Enabled
        :param str backup_policy_id: Backup Policy Resource ID
        :param bool policy_enforced: Policy Enforced
        """
        if backup_enabled is not None:
            pulumi.set(__self__, "backup_enabled", backup_enabled)
        if backup_policy_id is not None:
            pulumi.set(__self__, "backup_policy_id", backup_policy_id)
        if policy_enforced is not None:
            pulumi.set(__self__, "policy_enforced", policy_enforced)

    @property
    @pulumi.getter(name="backupEnabled")
    def backup_enabled(self) -> Optional[bool]:
        """
        Backup Enabled
        """
        return pulumi.get(self, "backup_enabled")

    @property
    @pulumi.getter(name="backupPolicyId")
    def backup_policy_id(self) -> Optional[str]:
        """
        Backup Policy Resource ID
        """
        return pulumi.get(self, "backup_policy_id")

    @property
    @pulumi.getter(name="policyEnforced")
    def policy_enforced(self) -> Optional[bool]:
        """
        Policy Enforced
        """
        return pulumi.get(self, "policy_enforced")


@pulumi.output_type
class VolumeBackupsResponse(dict):
    """
    Volume details using the backup policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupsCount":
            suggest = "backups_count"
        elif key == "policyEnabled":
            suggest = "policy_enabled"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeBackupsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeBackupsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeBackupsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backups_count: Optional[int] = None,
                 policy_enabled: Optional[bool] = None,
                 volume_name: Optional[str] = None):
        """
        Volume details using the backup policy
        :param int backups_count: Total count of backups for volume
        :param bool policy_enabled: Policy enabled
        :param str volume_name: Volume name
        """
        if backups_count is not None:
            pulumi.set(__self__, "backups_count", backups_count)
        if policy_enabled is not None:
            pulumi.set(__self__, "policy_enabled", policy_enabled)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="backupsCount")
    def backups_count(self) -> Optional[int]:
        """
        Total count of backups for volume
        """
        return pulumi.get(self, "backups_count")

    @property
    @pulumi.getter(name="policyEnabled")
    def policy_enabled(self) -> Optional[bool]:
        """
        Policy enabled
        """
        return pulumi.get(self, "policy_enabled")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[str]:
        """
        Volume name
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class VolumeGroupMetaDataResponse(dict):
    """
    Volume group properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumesCount":
            suggest = "volumes_count"
        elif key == "applicationIdentifier":
            suggest = "application_identifier"
        elif key == "applicationType":
            suggest = "application_type"
        elif key == "deploymentSpecId":
            suggest = "deployment_spec_id"
        elif key == "globalPlacementRules":
            suggest = "global_placement_rules"
        elif key == "groupDescription":
            suggest = "group_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeGroupMetaDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeGroupMetaDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeGroupMetaDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volumes_count: float,
                 application_identifier: Optional[str] = None,
                 application_type: Optional[str] = None,
                 deployment_spec_id: Optional[str] = None,
                 global_placement_rules: Optional[Sequence['outputs.PlacementKeyValuePairsResponse']] = None,
                 group_description: Optional[str] = None):
        """
        Volume group properties
        :param float volumes_count: Number of volumes in volume group
        :param str application_identifier: Application specific identifier
        :param str application_type: Application Type
        :param str deployment_spec_id: Application specific identifier of deployment rules for the volume group
        :param Sequence['PlacementKeyValuePairsResponse'] global_placement_rules: Application specific placement rules for the volume group
        :param str group_description: Group Description
        """
        pulumi.set(__self__, "volumes_count", volumes_count)
        if application_identifier is not None:
            pulumi.set(__self__, "application_identifier", application_identifier)
        if application_type is not None:
            pulumi.set(__self__, "application_type", application_type)
        if deployment_spec_id is not None:
            pulumi.set(__self__, "deployment_spec_id", deployment_spec_id)
        if global_placement_rules is not None:
            pulumi.set(__self__, "global_placement_rules", global_placement_rules)
        if group_description is not None:
            pulumi.set(__self__, "group_description", group_description)

    @property
    @pulumi.getter(name="volumesCount")
    def volumes_count(self) -> float:
        """
        Number of volumes in volume group
        """
        return pulumi.get(self, "volumes_count")

    @property
    @pulumi.getter(name="applicationIdentifier")
    def application_identifier(self) -> Optional[str]:
        """
        Application specific identifier
        """
        return pulumi.get(self, "application_identifier")

    @property
    @pulumi.getter(name="applicationType")
    def application_type(self) -> Optional[str]:
        """
        Application Type
        """
        return pulumi.get(self, "application_type")

    @property
    @pulumi.getter(name="deploymentSpecId")
    def deployment_spec_id(self) -> Optional[str]:
        """
        Application specific identifier of deployment rules for the volume group
        """
        return pulumi.get(self, "deployment_spec_id")

    @property
    @pulumi.getter(name="globalPlacementRules")
    def global_placement_rules(self) -> Optional[Sequence['outputs.PlacementKeyValuePairsResponse']]:
        """
        Application specific placement rules for the volume group
        """
        return pulumi.get(self, "global_placement_rules")

    @property
    @pulumi.getter(name="groupDescription")
    def group_description(self) -> Optional[str]:
        """
        Group Description
        """
        return pulumi.get(self, "group_description")


@pulumi.output_type
class VolumeGroupVolumePropertiesResponse(dict):
    """
    Volume resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actualThroughputMibps":
            suggest = "actual_throughput_mibps"
        elif key == "baremetalTenantId":
            suggest = "baremetal_tenant_id"
        elif key == "cloneProgress":
            suggest = "clone_progress"
        elif key == "creationToken":
            suggest = "creation_token"
        elif key == "dataStoreResourceId":
            suggest = "data_store_resource_id"
        elif key == "fileAccessLogs":
            suggest = "file_access_logs"
        elif key == "fileSystemId":
            suggest = "file_system_id"
        elif key == "maximumNumberOfFiles":
            suggest = "maximum_number_of_files"
        elif key == "mountTargets":
            suggest = "mount_targets"
        elif key == "networkSiblingSetId":
            suggest = "network_sibling_set_id"
        elif key == "originatingResourceId":
            suggest = "originating_resource_id"
        elif key == "provisionedAvailabilityZone":
            suggest = "provisioned_availability_zone"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "storageToNetworkProximity":
            suggest = "storage_to_network_proximity"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "t2Network":
            suggest = "t2_network"
        elif key == "usageThreshold":
            suggest = "usage_threshold"
        elif key == "volumeGroupName":
            suggest = "volume_group_name"
        elif key == "avsDataStore":
            suggest = "avs_data_store"
        elif key == "backupId":
            suggest = "backup_id"
        elif key == "capacityPoolResourceId":
            suggest = "capacity_pool_resource_id"
        elif key == "coolAccess":
            suggest = "cool_access"
        elif key == "coolnessPeriod":
            suggest = "coolness_period"
        elif key == "dataProtection":
            suggest = "data_protection"
        elif key == "defaultGroupQuotaInKiBs":
            suggest = "default_group_quota_in_ki_bs"
        elif key == "defaultUserQuotaInKiBs":
            suggest = "default_user_quota_in_ki_bs"
        elif key == "deleteBaseSnapshot":
            suggest = "delete_base_snapshot"
        elif key == "enableSubvolumes":
            suggest = "enable_subvolumes"
        elif key == "encryptionKeySource":
            suggest = "encryption_key_source"
        elif key == "exportPolicy":
            suggest = "export_policy"
        elif key == "isDefaultQuotaEnabled":
            suggest = "is_default_quota_enabled"
        elif key == "isLargeVolume":
            suggest = "is_large_volume"
        elif key == "isRestoring":
            suggest = "is_restoring"
        elif key == "kerberosEnabled":
            suggest = "kerberos_enabled"
        elif key == "keyVaultPrivateEndpointResourceId":
            suggest = "key_vault_private_endpoint_resource_id"
        elif key == "ldapEnabled":
            suggest = "ldap_enabled"
        elif key == "networkFeatures":
            suggest = "network_features"
        elif key == "placementRules":
            suggest = "placement_rules"
        elif key == "protocolTypes":
            suggest = "protocol_types"
        elif key == "proximityPlacementGroup":
            suggest = "proximity_placement_group"
        elif key == "securityStyle":
            suggest = "security_style"
        elif key == "serviceLevel":
            suggest = "service_level"
        elif key == "smbAccessBasedEnumeration":
            suggest = "smb_access_based_enumeration"
        elif key == "smbContinuouslyAvailable":
            suggest = "smb_continuously_available"
        elif key == "smbEncryption":
            suggest = "smb_encryption"
        elif key == "smbNonBrowsable":
            suggest = "smb_non_browsable"
        elif key == "snapshotDirectoryVisible":
            suggest = "snapshot_directory_visible"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "throughputMibps":
            suggest = "throughput_mibps"
        elif key == "unixPermissions":
            suggest = "unix_permissions"
        elif key == "volumeSpecName":
            suggest = "volume_spec_name"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeGroupVolumePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeGroupVolumePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeGroupVolumePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actual_throughput_mibps: float,
                 baremetal_tenant_id: str,
                 clone_progress: int,
                 creation_token: str,
                 data_store_resource_id: Sequence[str],
                 encrypted: bool,
                 file_access_logs: Optional[str] = None,
                 file_system_id: str,
                 id: str,
                 maximum_number_of_files: float,
                 mount_targets: Sequence['outputs.MountTargetPropertiesResponse'],
                 network_sibling_set_id: str,
                 originating_resource_id: str,
                 provisioned_availability_zone: str,
                 provisioning_state: str,
                 storage_to_network_proximity: str,
                 subnet_id: str,
                 t2_network: str,
                 type: str,
                 usage_threshold: Optional[float] = None,
                 volume_group_name: str,
                 avs_data_store: Optional[str] = None,
                 backup_id: Optional[str] = None,
                 capacity_pool_resource_id: Optional[str] = None,
                 cool_access: Optional[bool] = None,
                 coolness_period: Optional[int] = None,
                 data_protection: Optional['outputs.VolumePropertiesResponseDataProtection'] = None,
                 default_group_quota_in_ki_bs: Optional[float] = None,
                 default_user_quota_in_ki_bs: Optional[float] = None,
                 delete_base_snapshot: Optional[bool] = None,
                 enable_subvolumes: Optional[str] = None,
                 encryption_key_source: Optional[str] = None,
                 export_policy: Optional['outputs.VolumePropertiesResponseExportPolicy'] = None,
                 is_default_quota_enabled: Optional[bool] = None,
                 is_large_volume: Optional[bool] = None,
                 is_restoring: Optional[bool] = None,
                 kerberos_enabled: Optional[bool] = None,
                 key_vault_private_endpoint_resource_id: Optional[str] = None,
                 ldap_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 network_features: Optional[str] = None,
                 placement_rules: Optional[Sequence['outputs.PlacementKeyValuePairsResponse']] = None,
                 protocol_types: Optional[Sequence[str]] = None,
                 proximity_placement_group: Optional[str] = None,
                 security_style: Optional[str] = None,
                 service_level: Optional[str] = None,
                 smb_access_based_enumeration: Optional[str] = None,
                 smb_continuously_available: Optional[bool] = None,
                 smb_encryption: Optional[bool] = None,
                 smb_non_browsable: Optional[str] = None,
                 snapshot_directory_visible: Optional[bool] = None,
                 snapshot_id: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 throughput_mibps: Optional[float] = None,
                 unix_permissions: Optional[str] = None,
                 volume_spec_name: Optional[str] = None,
                 volume_type: Optional[str] = None):
        """
        Volume resource
        :param float actual_throughput_mibps: Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
        :param str baremetal_tenant_id: Unique Baremetal Tenant Identifier.
        :param int clone_progress: When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process. When this value is empty/null there is no cloning process currently happening on this volume. This value will update every 5 minutes during cloning.
        :param str creation_token: A unique file path for the volume. Used when creating mount targets
        :param Sequence[str] data_store_resource_id: Data store resource unique identifier
        :param bool encrypted: Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
        :param str file_access_logs: Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the volume.
        :param str file_system_id: Unique FileSystem Identifier.
        :param str id: Resource Id
        :param float maximum_number_of_files: Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume quota is more than 4TiB.
        :param Sequence['MountTargetPropertiesResponse'] mount_targets: List of mount targets
        :param str network_sibling_set_id: Network Sibling Set ID for the the group of volumes sharing networking resources.
        :param str originating_resource_id: Id of the snapshot or backup that the volume is restored from.
        :param str provisioned_availability_zone: The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
        :param str provisioning_state: Azure lifecycle management
        :param str storage_to_network_proximity: Provides storage to network proximity information for the volume.
        :param str subnet_id: The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        :param str t2_network: T2 network information
        :param str type: Resource type
        :param float usage_threshold: Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume. Specified in bytes.
        :param str volume_group_name: Volume Group Name
        :param str avs_data_store: Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        :param str backup_id: UUID v4 or resource identifier used to identify the Backup.
        :param str capacity_pool_resource_id: Pool Resource Id used in case of creating a volume through volume group
        :param bool cool_access: Specifies whether Cool Access(tiering) is enabled for the volume.
        :param int coolness_period: Specifies the number of days after which data that is not accessed by clients will be tiered.
        :param 'VolumePropertiesResponseDataProtection' data_protection: DataProtection type volumes include an object containing details of the replication
        :param float default_group_quota_in_ki_bs: Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        :param float default_user_quota_in_ki_bs: Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        :param bool delete_base_snapshot: If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false
        :param str enable_subvolumes: Flag indicating whether subvolume operations are enabled on the volume
        :param str encryption_key_source: Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        :param 'VolumePropertiesResponseExportPolicy' export_policy: Set of export policy rules
        :param bool is_default_quota_enabled: Specifies if default quota is enabled for the volume.
        :param bool is_large_volume: Specifies whether volume is a Large Volume or Regular Volume.
        :param bool is_restoring: Restoring
        :param bool kerberos_enabled: Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        :param str key_vault_private_endpoint_resource_id: The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'.
        :param bool ldap_enabled: Specifies whether LDAP is enabled or not for a given NFS volume.
        :param str name: Resource name
        :param str network_features: Basic network, or Standard features available to the volume.
        :param Sequence['PlacementKeyValuePairsResponse'] placement_rules: Application specific placement rules for the particular volume
        :param Sequence[str] protocol_types: Set of protocol types, default NFSv3, CIFS for SMB protocol
        :param str proximity_placement_group: Proximity placement group associated with the volume
        :param str security_style: The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        :param str service_level: The service level of the file system
        :param str smb_access_based_enumeration: Enables access based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        :param bool smb_continuously_available: Enables continuously available share property for smb volume. Only applicable for SMB volume
        :param bool smb_encryption: Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later
        :param str smb_non_browsable: Enables non browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        :param bool snapshot_directory_visible: If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true).
        :param str snapshot_id: UUID v4 or resource identifier used to identify the Snapshot.
        :param Mapping[str, str] tags: Resource tags
        :param str unix_permissions: UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users.
        :param str volume_spec_name: Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log
        :param str volume_type: What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection
        """
        pulumi.set(__self__, "actual_throughput_mibps", actual_throughput_mibps)
        pulumi.set(__self__, "baremetal_tenant_id", baremetal_tenant_id)
        pulumi.set(__self__, "clone_progress", clone_progress)
        pulumi.set(__self__, "creation_token", creation_token)
        pulumi.set(__self__, "data_store_resource_id", data_store_resource_id)
        pulumi.set(__self__, "encrypted", encrypted)
        if file_access_logs is None:
            file_access_logs = 'Disabled'
        pulumi.set(__self__, "file_access_logs", file_access_logs)
        pulumi.set(__self__, "file_system_id", file_system_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "maximum_number_of_files", maximum_number_of_files)
        pulumi.set(__self__, "mount_targets", mount_targets)
        pulumi.set(__self__, "network_sibling_set_id", network_sibling_set_id)
        pulumi.set(__self__, "originating_resource_id", originating_resource_id)
        pulumi.set(__self__, "provisioned_availability_zone", provisioned_availability_zone)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "storage_to_network_proximity", storage_to_network_proximity)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "t2_network", t2_network)
        pulumi.set(__self__, "type", type)
        if usage_threshold is None:
            usage_threshold = 107374182400
        pulumi.set(__self__, "usage_threshold", usage_threshold)
        pulumi.set(__self__, "volume_group_name", volume_group_name)
        if avs_data_store is None:
            avs_data_store = 'Disabled'
        if avs_data_store is not None:
            pulumi.set(__self__, "avs_data_store", avs_data_store)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if capacity_pool_resource_id is not None:
            pulumi.set(__self__, "capacity_pool_resource_id", capacity_pool_resource_id)
        if cool_access is None:
            cool_access = False
        if cool_access is not None:
            pulumi.set(__self__, "cool_access", cool_access)
        if coolness_period is not None:
            pulumi.set(__self__, "coolness_period", coolness_period)
        if data_protection is not None:
            pulumi.set(__self__, "data_protection", data_protection)
        if default_group_quota_in_ki_bs is None:
            default_group_quota_in_ki_bs = 0
        if default_group_quota_in_ki_bs is not None:
            pulumi.set(__self__, "default_group_quota_in_ki_bs", default_group_quota_in_ki_bs)
        if default_user_quota_in_ki_bs is None:
            default_user_quota_in_ki_bs = 0
        if default_user_quota_in_ki_bs is not None:
            pulumi.set(__self__, "default_user_quota_in_ki_bs", default_user_quota_in_ki_bs)
        if delete_base_snapshot is not None:
            pulumi.set(__self__, "delete_base_snapshot", delete_base_snapshot)
        if enable_subvolumes is None:
            enable_subvolumes = 'Disabled'
        if enable_subvolumes is not None:
            pulumi.set(__self__, "enable_subvolumes", enable_subvolumes)
        if encryption_key_source is None:
            encryption_key_source = 'Microsoft.NetApp'
        if encryption_key_source is not None:
            pulumi.set(__self__, "encryption_key_source", encryption_key_source)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if is_default_quota_enabled is None:
            is_default_quota_enabled = False
        if is_default_quota_enabled is not None:
            pulumi.set(__self__, "is_default_quota_enabled", is_default_quota_enabled)
        if is_large_volume is None:
            is_large_volume = False
        if is_large_volume is not None:
            pulumi.set(__self__, "is_large_volume", is_large_volume)
        if is_restoring is not None:
            pulumi.set(__self__, "is_restoring", is_restoring)
        if kerberos_enabled is None:
            kerberos_enabled = False
        if kerberos_enabled is not None:
            pulumi.set(__self__, "kerberos_enabled", kerberos_enabled)
        if key_vault_private_endpoint_resource_id is not None:
            pulumi.set(__self__, "key_vault_private_endpoint_resource_id", key_vault_private_endpoint_resource_id)
        if ldap_enabled is None:
            ldap_enabled = False
        if ldap_enabled is not None:
            pulumi.set(__self__, "ldap_enabled", ldap_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_features is None:
            network_features = 'Basic'
        if network_features is not None:
            pulumi.set(__self__, "network_features", network_features)
        if placement_rules is not None:
            pulumi.set(__self__, "placement_rules", placement_rules)
        if protocol_types is not None:
            pulumi.set(__self__, "protocol_types", protocol_types)
        if proximity_placement_group is not None:
            pulumi.set(__self__, "proximity_placement_group", proximity_placement_group)
        if security_style is None:
            security_style = 'unix'
        if security_style is not None:
            pulumi.set(__self__, "security_style", security_style)
        if service_level is not None:
            pulumi.set(__self__, "service_level", service_level)
        if smb_access_based_enumeration is not None:
            pulumi.set(__self__, "smb_access_based_enumeration", smb_access_based_enumeration)
        if smb_continuously_available is None:
            smb_continuously_available = False
        if smb_continuously_available is not None:
            pulumi.set(__self__, "smb_continuously_available", smb_continuously_available)
        if smb_encryption is None:
            smb_encryption = False
        if smb_encryption is not None:
            pulumi.set(__self__, "smb_encryption", smb_encryption)
        if smb_non_browsable is not None:
            pulumi.set(__self__, "smb_non_browsable", smb_non_browsable)
        if snapshot_directory_visible is None:
            snapshot_directory_visible = True
        if snapshot_directory_visible is not None:
            pulumi.set(__self__, "snapshot_directory_visible", snapshot_directory_visible)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if throughput_mibps is not None:
            pulumi.set(__self__, "throughput_mibps", throughput_mibps)
        if unix_permissions is None:
            unix_permissions = '0770'
        if unix_permissions is not None:
            pulumi.set(__self__, "unix_permissions", unix_permissions)
        if volume_spec_name is not None:
            pulumi.set(__self__, "volume_spec_name", volume_spec_name)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="actualThroughputMibps")
    def actual_throughput_mibps(self) -> float:
        """
        Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
        """
        return pulumi.get(self, "actual_throughput_mibps")

    @property
    @pulumi.getter(name="baremetalTenantId")
    def baremetal_tenant_id(self) -> str:
        """
        Unique Baremetal Tenant Identifier.
        """
        return pulumi.get(self, "baremetal_tenant_id")

    @property
    @pulumi.getter(name="cloneProgress")
    def clone_progress(self) -> int:
        """
        When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process. When this value is empty/null there is no cloning process currently happening on this volume. This value will update every 5 minutes during cloning.
        """
        return pulumi.get(self, "clone_progress")

    @property
    @pulumi.getter(name="creationToken")
    def creation_token(self) -> str:
        """
        A unique file path for the volume. Used when creating mount targets
        """
        return pulumi.get(self, "creation_token")

    @property
    @pulumi.getter(name="dataStoreResourceId")
    def data_store_resource_id(self) -> Sequence[str]:
        """
        Data store resource unique identifier
        """
        return pulumi.get(self, "data_store_resource_id")

    @property
    @pulumi.getter
    def encrypted(self) -> bool:
        """
        Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="fileAccessLogs")
    def file_access_logs(self) -> str:
        """
        Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the volume.
        """
        return pulumi.get(self, "file_access_logs")

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> str:
        """
        Unique FileSystem Identifier.
        """
        return pulumi.get(self, "file_system_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Resource Id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maximumNumberOfFiles")
    def maximum_number_of_files(self) -> float:
        """
        Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume quota is more than 4TiB.
        """
        return pulumi.get(self, "maximum_number_of_files")

    @property
    @pulumi.getter(name="mountTargets")
    def mount_targets(self) -> Sequence['outputs.MountTargetPropertiesResponse']:
        """
        List of mount targets
        """
        return pulumi.get(self, "mount_targets")

    @property
    @pulumi.getter(name="networkSiblingSetId")
    def network_sibling_set_id(self) -> str:
        """
        Network Sibling Set ID for the the group of volumes sharing networking resources.
        """
        return pulumi.get(self, "network_sibling_set_id")

    @property
    @pulumi.getter(name="originatingResourceId")
    def originating_resource_id(self) -> str:
        """
        Id of the snapshot or backup that the volume is restored from.
        """
        return pulumi.get(self, "originating_resource_id")

    @property
    @pulumi.getter(name="provisionedAvailabilityZone")
    def provisioned_availability_zone(self) -> str:
        """
        The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
        """
        return pulumi.get(self, "provisioned_availability_zone")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Azure lifecycle management
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="storageToNetworkProximity")
    def storage_to_network_proximity(self) -> str:
        """
        Provides storage to network proximity information for the volume.
        """
        return pulumi.get(self, "storage_to_network_proximity")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="t2Network")
    def t2_network(self) -> str:
        """
        T2 network information
        """
        return pulumi.get(self, "t2_network")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Resource type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="usageThreshold")
    def usage_threshold(self) -> float:
        """
        Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume. Specified in bytes.
        """
        return pulumi.get(self, "usage_threshold")

    @property
    @pulumi.getter(name="volumeGroupName")
    def volume_group_name(self) -> str:
        """
        Volume Group Name
        """
        return pulumi.get(self, "volume_group_name")

    @property
    @pulumi.getter(name="avsDataStore")
    def avs_data_store(self) -> Optional[str]:
        """
        Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        """
        return pulumi.get(self, "avs_data_store")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[str]:
        """
        UUID v4 or resource identifier used to identify the Backup.
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="capacityPoolResourceId")
    def capacity_pool_resource_id(self) -> Optional[str]:
        """
        Pool Resource Id used in case of creating a volume through volume group
        """
        return pulumi.get(self, "capacity_pool_resource_id")

    @property
    @pulumi.getter(name="coolAccess")
    def cool_access(self) -> Optional[bool]:
        """
        Specifies whether Cool Access(tiering) is enabled for the volume.
        """
        return pulumi.get(self, "cool_access")

    @property
    @pulumi.getter(name="coolnessPeriod")
    def coolness_period(self) -> Optional[int]:
        """
        Specifies the number of days after which data that is not accessed by clients will be tiered.
        """
        return pulumi.get(self, "coolness_period")

    @property
    @pulumi.getter(name="dataProtection")
    def data_protection(self) -> Optional['outputs.VolumePropertiesResponseDataProtection']:
        """
        DataProtection type volumes include an object containing details of the replication
        """
        return pulumi.get(self, "data_protection")

    @property
    @pulumi.getter(name="defaultGroupQuotaInKiBs")
    def default_group_quota_in_ki_bs(self) -> Optional[float]:
        """
        Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        """
        return pulumi.get(self, "default_group_quota_in_ki_bs")

    @property
    @pulumi.getter(name="defaultUserQuotaInKiBs")
    def default_user_quota_in_ki_bs(self) -> Optional[float]:
        """
        Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        """
        return pulumi.get(self, "default_user_quota_in_ki_bs")

    @property
    @pulumi.getter(name="deleteBaseSnapshot")
    def delete_base_snapshot(self) -> Optional[bool]:
        """
        If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false
        """
        return pulumi.get(self, "delete_base_snapshot")

    @property
    @pulumi.getter(name="enableSubvolumes")
    def enable_subvolumes(self) -> Optional[str]:
        """
        Flag indicating whether subvolume operations are enabled on the volume
        """
        return pulumi.get(self, "enable_subvolumes")

    @property
    @pulumi.getter(name="encryptionKeySource")
    def encryption_key_source(self) -> Optional[str]:
        """
        Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        """
        return pulumi.get(self, "encryption_key_source")

    @property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional['outputs.VolumePropertiesResponseExportPolicy']:
        """
        Set of export policy rules
        """
        return pulumi.get(self, "export_policy")

    @property
    @pulumi.getter(name="isDefaultQuotaEnabled")
    def is_default_quota_enabled(self) -> Optional[bool]:
        """
        Specifies if default quota is enabled for the volume.
        """
        return pulumi.get(self, "is_default_quota_enabled")

    @property
    @pulumi.getter(name="isLargeVolume")
    def is_large_volume(self) -> Optional[bool]:
        """
        Specifies whether volume is a Large Volume or Regular Volume.
        """
        return pulumi.get(self, "is_large_volume")

    @property
    @pulumi.getter(name="isRestoring")
    def is_restoring(self) -> Optional[bool]:
        """
        Restoring
        """
        return pulumi.get(self, "is_restoring")

    @property
    @pulumi.getter(name="kerberosEnabled")
    def kerberos_enabled(self) -> Optional[bool]:
        """
        Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos_enabled")

    @property
    @pulumi.getter(name="keyVaultPrivateEndpointResourceId")
    def key_vault_private_endpoint_resource_id(self) -> Optional[str]:
        """
        The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "key_vault_private_endpoint_resource_id")

    @property
    @pulumi.getter(name="ldapEnabled")
    def ldap_enabled(self) -> Optional[bool]:
        """
        Specifies whether LDAP is enabled or not for a given NFS volume.
        """
        return pulumi.get(self, "ldap_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Resource name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkFeatures")
    def network_features(self) -> Optional[str]:
        """
        Basic network, or Standard features available to the volume.
        """
        return pulumi.get(self, "network_features")

    @property
    @pulumi.getter(name="placementRules")
    def placement_rules(self) -> Optional[Sequence['outputs.PlacementKeyValuePairsResponse']]:
        """
        Application specific placement rules for the particular volume
        """
        return pulumi.get(self, "placement_rules")

    @property
    @pulumi.getter(name="protocolTypes")
    def protocol_types(self) -> Optional[Sequence[str]]:
        """
        Set of protocol types, default NFSv3, CIFS for SMB protocol
        """
        return pulumi.get(self, "protocol_types")

    @property
    @pulumi.getter(name="proximityPlacementGroup")
    def proximity_placement_group(self) -> Optional[str]:
        """
        Proximity placement group associated with the volume
        """
        return pulumi.get(self, "proximity_placement_group")

    @property
    @pulumi.getter(name="securityStyle")
    def security_style(self) -> Optional[str]:
        """
        The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        """
        return pulumi.get(self, "security_style")

    @property
    @pulumi.getter(name="serviceLevel")
    def service_level(self) -> Optional[str]:
        """
        The service level of the file system
        """
        return pulumi.get(self, "service_level")

    @property
    @pulumi.getter(name="smbAccessBasedEnumeration")
    def smb_access_based_enumeration(self) -> Optional[str]:
        """
        Enables access based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        """
        return pulumi.get(self, "smb_access_based_enumeration")

    @property
    @pulumi.getter(name="smbContinuouslyAvailable")
    def smb_continuously_available(self) -> Optional[bool]:
        """
        Enables continuously available share property for smb volume. Only applicable for SMB volume
        """
        return pulumi.get(self, "smb_continuously_available")

    @property
    @pulumi.getter(name="smbEncryption")
    def smb_encryption(self) -> Optional[bool]:
        """
        Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later
        """
        return pulumi.get(self, "smb_encryption")

    @property
    @pulumi.getter(name="smbNonBrowsable")
    def smb_non_browsable(self) -> Optional[str]:
        """
        Enables non browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        """
        return pulumi.get(self, "smb_non_browsable")

    @property
    @pulumi.getter(name="snapshotDirectoryVisible")
    def snapshot_directory_visible(self) -> Optional[bool]:
        """
        If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true).
        """
        return pulumi.get(self, "snapshot_directory_visible")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        UUID v4 or resource identifier used to identify the Snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="throughputMibps")
    def throughput_mibps(self) -> Optional[float]:
        return pulumi.get(self, "throughput_mibps")

    @property
    @pulumi.getter(name="unixPermissions")
    def unix_permissions(self) -> Optional[str]:
        """
        UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users.
        """
        return pulumi.get(self, "unix_permissions")

    @property
    @pulumi.getter(name="volumeSpecName")
    def volume_spec_name(self) -> Optional[str]:
        """
        Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log
        """
        return pulumi.get(self, "volume_spec_name")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class VolumePropertiesResponseDataProtection(dict):
    """
    DataProtection type volumes include an object containing details of the replication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeRelocation":
            suggest = "volume_relocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumePropertiesResponseDataProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumePropertiesResponseDataProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumePropertiesResponseDataProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup: Optional['outputs.VolumeBackupPropertiesResponse'] = None,
                 replication: Optional['outputs.ReplicationObjectResponse'] = None,
                 snapshot: Optional['outputs.VolumeSnapshotPropertiesResponse'] = None,
                 volume_relocation: Optional['outputs.VolumeRelocationPropertiesResponse'] = None):
        """
        DataProtection type volumes include an object containing details of the replication
        :param 'VolumeBackupPropertiesResponse' backup: Backup Properties
        :param 'ReplicationObjectResponse' replication: Replication properties
        :param 'VolumeSnapshotPropertiesResponse' snapshot: Snapshot properties.
        :param 'VolumeRelocationPropertiesResponse' volume_relocation: VolumeRelocation properties
        """
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if replication is not None:
            pulumi.set(__self__, "replication", replication)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if volume_relocation is not None:
            pulumi.set(__self__, "volume_relocation", volume_relocation)

    @property
    @pulumi.getter
    def backup(self) -> Optional['outputs.VolumeBackupPropertiesResponse']:
        """
        Backup Properties
        """
        return pulumi.get(self, "backup")

    @property
    @pulumi.getter
    def replication(self) -> Optional['outputs.ReplicationObjectResponse']:
        """
        Replication properties
        """
        return pulumi.get(self, "replication")

    @property
    @pulumi.getter
    def snapshot(self) -> Optional['outputs.VolumeSnapshotPropertiesResponse']:
        """
        Snapshot properties.
        """
        return pulumi.get(self, "snapshot")

    @property
    @pulumi.getter(name="volumeRelocation")
    def volume_relocation(self) -> Optional['outputs.VolumeRelocationPropertiesResponse']:
        """
        VolumeRelocation properties
        """
        return pulumi.get(self, "volume_relocation")


@pulumi.output_type
class VolumePropertiesResponseExportPolicy(dict):
    """
    Set of export policy rules
    """
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.ExportPolicyRuleResponse']] = None):
        """
        Set of export policy rules
        :param Sequence['ExportPolicyRuleResponse'] rules: Export policy rule
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.ExportPolicyRuleResponse']]:
        """
        Export policy rule
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class VolumeRelocationPropertiesResponse(dict):
    """
    Volume relocation properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readyToBeFinalized":
            suggest = "ready_to_be_finalized"
        elif key == "relocationRequested":
            suggest = "relocation_requested"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeRelocationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeRelocationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeRelocationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ready_to_be_finalized: bool,
                 relocation_requested: Optional[bool] = None):
        """
        Volume relocation properties
        :param bool ready_to_be_finalized: Has relocation finished and is ready to be cleaned up
        :param bool relocation_requested: Has relocation been requested for this volume
        """
        pulumi.set(__self__, "ready_to_be_finalized", ready_to_be_finalized)
        if relocation_requested is not None:
            pulumi.set(__self__, "relocation_requested", relocation_requested)

    @property
    @pulumi.getter(name="readyToBeFinalized")
    def ready_to_be_finalized(self) -> bool:
        """
        Has relocation finished and is ready to be cleaned up
        """
        return pulumi.get(self, "ready_to_be_finalized")

    @property
    @pulumi.getter(name="relocationRequested")
    def relocation_requested(self) -> Optional[bool]:
        """
        Has relocation been requested for this volume
        """
        return pulumi.get(self, "relocation_requested")


@pulumi.output_type
class VolumeSnapshotPropertiesResponse(dict):
    """
    Volume Snapshot Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotPolicyId":
            suggest = "snapshot_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSnapshotPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSnapshotPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSnapshotPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 snapshot_policy_id: Optional[str] = None):
        """
        Volume Snapshot Properties
        :param str snapshot_policy_id: Snapshot Policy ResourceId
        """
        if snapshot_policy_id is not None:
            pulumi.set(__self__, "snapshot_policy_id", snapshot_policy_id)

    @property
    @pulumi.getter(name="snapshotPolicyId")
    def snapshot_policy_id(self) -> Optional[str]:
        """
        Snapshot Policy ResourceId
        """
        return pulumi.get(self, "snapshot_policy_id")


@pulumi.output_type
class WeeklyScheduleResponse(dict):
    """
    Weekly Schedule properties, make a snapshot every week at a specific day or days
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotsToKeep":
            suggest = "snapshots_to_keep"
        elif key == "usedBytes":
            suggest = "used_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WeeklyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WeeklyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WeeklyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day: Optional[str] = None,
                 hour: Optional[int] = None,
                 minute: Optional[int] = None,
                 snapshots_to_keep: Optional[int] = None,
                 used_bytes: Optional[float] = None):
        """
        Weekly Schedule properties, make a snapshot every week at a specific day or days
        :param str day: Indicates which weekdays snapshot should be taken, accepts a comma separated list of week day names in english
        :param int hour: Indicates which hour in UTC timezone a snapshot should be taken
        :param int minute: Indicates which minute snapshot should be taken
        :param int snapshots_to_keep: Weekly snapshot count to keep
        :param float used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if snapshots_to_keep is not None:
            pulumi.set(__self__, "snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            pulumi.set(__self__, "used_bytes", used_bytes)

    @property
    @pulumi.getter
    def day(self) -> Optional[str]:
        """
        Indicates which weekdays snapshot should be taken, accepts a comma separated list of week day names in english
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def minute(self) -> Optional[int]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[int]:
        """
        Weekly snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[float]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")


