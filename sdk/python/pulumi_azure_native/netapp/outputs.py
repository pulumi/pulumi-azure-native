# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AccountEncryptionResponse',
    'ActiveDirectoryResponse',
    'BucketServerPropertiesResponse',
    'CifsUserResponse',
    'DailyScheduleResponse',
    'EncryptionIdentityResponse',
    'ExportPolicyRuleResponse',
    'FileSystemUserResponse',
    'HourlyScheduleResponse',
    'KeyVaultPrivateEndpointResponse',
    'KeyVaultPropertiesResponse',
    'LdapSearchScopeOptResponse',
    'ManagedServiceIdentityResponse',
    'MonthlyScheduleResponse',
    'MountTargetPropertiesResponse',
    'NfsUserResponse',
    'PlacementKeyValuePairsResponse',
    'QuotaReportResponse',
    'RemotePathResponse',
    'ReplicationObjectResponse',
    'ReplicationResponse',
    'SystemDataResponse',
    'UserAssignedIdentityResponse',
    'VolumeBackupPropertiesResponse',
    'VolumeBackupsResponse',
    'VolumeGroupMetaDataResponse',
    'VolumeGroupVolumePropertiesResponse',
    'VolumePropertiesResponseDataProtection',
    'VolumePropertiesResponseExportPolicy',
    'VolumeRelocationPropertiesResponse',
    'VolumeSnapshotPropertiesResponse',
    'WeeklyScheduleResponse',
]

@pulumi.output_type
class AccountEncryptionResponse(dict):
    """
    Encryption settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keySource":
            suggest = "key_source"
        elif key == "keyVaultProperties":
            suggest = "key_vault_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountEncryptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountEncryptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountEncryptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: Optional['outputs.EncryptionIdentityResponse'] = None,
                 key_source: Optional[builtins.str] = None,
                 key_vault_properties: Optional['outputs.KeyVaultPropertiesResponse'] = None):
        """
        Encryption settings
        :param 'EncryptionIdentityResponse' identity: Identity used to authenticate to KeyVault. Applicable if keySource is 'Microsoft.KeyVault'.
        :param builtins.str key_source: The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault
        :param 'KeyVaultPropertiesResponse' key_vault_properties: Properties provided by KeVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if key_source is None:
            key_source = 'Microsoft.NetApp'
        if key_source is not None:
            pulumi.set(__self__, "key_source", key_source)
        if key_vault_properties is not None:
            pulumi.set(__self__, "key_vault_properties", key_vault_properties)

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.EncryptionIdentityResponse']:
        """
        Identity used to authenticate to KeyVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="keySource")
    def key_source(self) -> Optional[builtins.str]:
        """
        The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault
        """
        return pulumi.get(self, "key_source")

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> Optional['outputs.KeyVaultPropertiesResponse']:
        """
        Properties provided by KeVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "key_vault_properties")


@pulumi.output_type
class ActiveDirectoryResponse(dict):
    """
    Active Directory
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusDetails":
            suggest = "status_details"
        elif key == "activeDirectoryId":
            suggest = "active_directory_id"
        elif key == "adName":
            suggest = "ad_name"
        elif key == "aesEncryption":
            suggest = "aes_encryption"
        elif key == "allowLocalNfsUsersWithLdap":
            suggest = "allow_local_nfs_users_with_ldap"
        elif key == "backupOperators":
            suggest = "backup_operators"
        elif key == "encryptDCConnections":
            suggest = "encrypt_dc_connections"
        elif key == "kdcIP":
            suggest = "kdc_ip"
        elif key == "ldapOverTLS":
            suggest = "ldap_over_tls"
        elif key == "ldapSearchScope":
            suggest = "ldap_search_scope"
        elif key == "ldapSigning":
            suggest = "ldap_signing"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"
        elif key == "preferredServersForLdapClient":
            suggest = "preferred_servers_for_ldap_client"
        elif key == "securityOperators":
            suggest = "security_operators"
        elif key == "serverRootCACertificate":
            suggest = "server_root_ca_certificate"
        elif key == "smbServerName":
            suggest = "smb_server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveDirectoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveDirectoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveDirectoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: builtins.str,
                 status_details: builtins.str,
                 active_directory_id: Optional[builtins.str] = None,
                 ad_name: Optional[builtins.str] = None,
                 administrators: Optional[Sequence[builtins.str]] = None,
                 aes_encryption: Optional[builtins.bool] = None,
                 allow_local_nfs_users_with_ldap: Optional[builtins.bool] = None,
                 backup_operators: Optional[Sequence[builtins.str]] = None,
                 dns: Optional[builtins.str] = None,
                 domain: Optional[builtins.str] = None,
                 encrypt_dc_connections: Optional[builtins.bool] = None,
                 kdc_ip: Optional[builtins.str] = None,
                 ldap_over_tls: Optional[builtins.bool] = None,
                 ldap_search_scope: Optional['outputs.LdapSearchScopeOptResponse'] = None,
                 ldap_signing: Optional[builtins.bool] = None,
                 organizational_unit: Optional[builtins.str] = None,
                 password: Optional[builtins.str] = None,
                 preferred_servers_for_ldap_client: Optional[builtins.str] = None,
                 security_operators: Optional[Sequence[builtins.str]] = None,
                 server_root_ca_certificate: Optional[builtins.str] = None,
                 site: Optional[builtins.str] = None,
                 smb_server_name: Optional[builtins.str] = None,
                 username: Optional[builtins.str] = None):
        """
        Active Directory
        :param builtins.str status: Status of the Active Directory
        :param builtins.str status_details: Any details in regards to the Status of the Active Directory
        :param builtins.str active_directory_id: Id of the Active Directory
        :param builtins.str ad_name: Name of the active directory machine. This optional parameter is used only while creating kerberos volume
        :param Sequence[builtins.str] administrators: Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier
        :param builtins.bool aes_encryption: If enabled, AES encryption will be enabled for SMB communication.
        :param builtins.bool allow_local_nfs_users_with_ldap:  If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes.
        :param Sequence[builtins.str] backup_operators: Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier
        :param builtins.str dns: Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain
        :param builtins.str domain: Name of the Active Directory domain
        :param builtins.bool encrypt_dc_connections: If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted.
        :param builtins.str kdc_ip: kdc server IP address for the active directory machine. This optional parameter is used only while creating kerberos volume.
        :param builtins.bool ldap_over_tls: Specifies whether or not the LDAP traffic needs to be secured via TLS.
        :param 'LdapSearchScopeOptResponse' ldap_search_scope: LDAP Search scope options
        :param builtins.bool ldap_signing: Specifies whether or not the LDAP traffic needs to be signed.
        :param builtins.str organizational_unit: The Organizational Unit (OU) within the Windows Active Directory
        :param builtins.str password: Plain text password of Active Directory domain administrator, value is masked in the response
        :param builtins.str preferred_servers_for_ldap_client: Comma separated list of IPv4 addresses of preferred servers for LDAP client. At most two comma separated IPv4 addresses can be passed.
        :param Sequence[builtins.str] security_operators: Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier
        :param builtins.str server_root_ca_certificate: When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes.
        :param builtins.str site: The Active Directory site the service will limit Domain Controller discovery to
        :param builtins.str smb_server_name: NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
        :param builtins.str username: A domain user account with permission to create machine accounts
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_details", status_details)
        if active_directory_id is not None:
            pulumi.set(__self__, "active_directory_id", active_directory_id)
        if ad_name is not None:
            pulumi.set(__self__, "ad_name", ad_name)
        if administrators is not None:
            pulumi.set(__self__, "administrators", administrators)
        if aes_encryption is not None:
            pulumi.set(__self__, "aes_encryption", aes_encryption)
        if allow_local_nfs_users_with_ldap is not None:
            pulumi.set(__self__, "allow_local_nfs_users_with_ldap", allow_local_nfs_users_with_ldap)
        if backup_operators is not None:
            pulumi.set(__self__, "backup_operators", backup_operators)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if encrypt_dc_connections is not None:
            pulumi.set(__self__, "encrypt_dc_connections", encrypt_dc_connections)
        if kdc_ip is not None:
            pulumi.set(__self__, "kdc_ip", kdc_ip)
        if ldap_over_tls is not None:
            pulumi.set(__self__, "ldap_over_tls", ldap_over_tls)
        if ldap_search_scope is not None:
            pulumi.set(__self__, "ldap_search_scope", ldap_search_scope)
        if ldap_signing is not None:
            pulumi.set(__self__, "ldap_signing", ldap_signing)
        if organizational_unit is None:
            organizational_unit = 'CN=Computers'
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if preferred_servers_for_ldap_client is not None:
            pulumi.set(__self__, "preferred_servers_for_ldap_client", preferred_servers_for_ldap_client)
        if security_operators is not None:
            pulumi.set(__self__, "security_operators", security_operators)
        if server_root_ca_certificate is not None:
            pulumi.set(__self__, "server_root_ca_certificate", server_root_ca_certificate)
        if site is not None:
            pulumi.set(__self__, "site", site)
        if smb_server_name is not None:
            pulumi.set(__self__, "smb_server_name", smb_server_name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the Active Directory
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusDetails")
    def status_details(self) -> builtins.str:
        """
        Any details in regards to the Status of the Active Directory
        """
        return pulumi.get(self, "status_details")

    @property
    @pulumi.getter(name="activeDirectoryId")
    def active_directory_id(self) -> Optional[builtins.str]:
        """
        Id of the Active Directory
        """
        return pulumi.get(self, "active_directory_id")

    @property
    @pulumi.getter(name="adName")
    def ad_name(self) -> Optional[builtins.str]:
        """
        Name of the active directory machine. This optional parameter is used only while creating kerberos volume
        """
        return pulumi.get(self, "ad_name")

    @property
    @pulumi.getter
    def administrators(self) -> Optional[Sequence[builtins.str]]:
        """
        Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "administrators")

    @property
    @pulumi.getter(name="aesEncryption")
    def aes_encryption(self) -> Optional[builtins.bool]:
        """
        If enabled, AES encryption will be enabled for SMB communication.
        """
        return pulumi.get(self, "aes_encryption")

    @property
    @pulumi.getter(name="allowLocalNfsUsersWithLdap")
    def allow_local_nfs_users_with_ldap(self) -> Optional[builtins.bool]:
        """
         If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes.
        """
        return pulumi.get(self, "allow_local_nfs_users_with_ldap")

    @property
    @pulumi.getter(name="backupOperators")
    def backup_operators(self) -> Optional[Sequence[builtins.str]]:
        """
        Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "backup_operators")

    @property
    @pulumi.getter
    def dns(self) -> Optional[builtins.str]:
        """
        Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def domain(self) -> Optional[builtins.str]:
        """
        Name of the Active Directory domain
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="encryptDCConnections")
    def encrypt_dc_connections(self) -> Optional[builtins.bool]:
        """
        If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted.
        """
        return pulumi.get(self, "encrypt_dc_connections")

    @property
    @pulumi.getter(name="kdcIP")
    def kdc_ip(self) -> Optional[builtins.str]:
        """
        kdc server IP address for the active directory machine. This optional parameter is used only while creating kerberos volume.
        """
        return pulumi.get(self, "kdc_ip")

    @property
    @pulumi.getter(name="ldapOverTLS")
    def ldap_over_tls(self) -> Optional[builtins.bool]:
        """
        Specifies whether or not the LDAP traffic needs to be secured via TLS.
        """
        return pulumi.get(self, "ldap_over_tls")

    @property
    @pulumi.getter(name="ldapSearchScope")
    def ldap_search_scope(self) -> Optional['outputs.LdapSearchScopeOptResponse']:
        """
        LDAP Search scope options
        """
        return pulumi.get(self, "ldap_search_scope")

    @property
    @pulumi.getter(name="ldapSigning")
    def ldap_signing(self) -> Optional[builtins.bool]:
        """
        Specifies whether or not the LDAP traffic needs to be signed.
        """
        return pulumi.get(self, "ldap_signing")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[builtins.str]:
        """
        The Organizational Unit (OU) within the Windows Active Directory
        """
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        """
        Plain text password of Active Directory domain administrator, value is masked in the response
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="preferredServersForLdapClient")
    def preferred_servers_for_ldap_client(self) -> Optional[builtins.str]:
        """
        Comma separated list of IPv4 addresses of preferred servers for LDAP client. At most two comma separated IPv4 addresses can be passed.
        """
        return pulumi.get(self, "preferred_servers_for_ldap_client")

    @property
    @pulumi.getter(name="securityOperators")
    def security_operators(self) -> Optional[Sequence[builtins.str]]:
        """
        Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "security_operators")

    @property
    @pulumi.getter(name="serverRootCACertificate")
    def server_root_ca_certificate(self) -> Optional[builtins.str]:
        """
        When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes.
        """
        return pulumi.get(self, "server_root_ca_certificate")

    @property
    @pulumi.getter
    def site(self) -> Optional[builtins.str]:
        """
        The Active Directory site the service will limit Domain Controller discovery to
        """
        return pulumi.get(self, "site")

    @property
    @pulumi.getter(name="smbServerName")
    def smb_server_name(self) -> Optional[builtins.str]:
        """
        NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
        """
        return pulumi.get(self, "smb_server_name")

    @property
    @pulumi.getter
    def username(self) -> Optional[builtins.str]:
        """
        A domain user account with permission to create machine accounts
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class BucketServerPropertiesResponse(dict):
    """
    Properties of the server managing the lifecycle of volume buckets
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateCommonName":
            suggest = "certificate_common_name"
        elif key == "certificateExpiryDate":
            suggest = "certificate_expiry_date"
        elif key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BucketServerPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BucketServerPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BucketServerPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_common_name: builtins.str,
                 certificate_expiry_date: builtins.str,
                 ip_address: builtins.str,
                 fqdn: Optional[builtins.str] = None):
        """
        Properties of the server managing the lifecycle of volume buckets
        :param builtins.str certificate_common_name: Certificate Common Name taken from the certificate installed on the bucket server
        :param builtins.str certificate_expiry_date: The bucket server's certificate expiry date.
        :param builtins.str ip_address: The bucket server's IPv4 address
        :param builtins.str fqdn: The host part of the bucket URL, resolving to the bucket IP address and allowed by the server certificate.
        """
        pulumi.set(__self__, "certificate_common_name", certificate_common_name)
        pulumi.set(__self__, "certificate_expiry_date", certificate_expiry_date)
        pulumi.set(__self__, "ip_address", ip_address)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @property
    @pulumi.getter(name="certificateCommonName")
    def certificate_common_name(self) -> builtins.str:
        """
        Certificate Common Name taken from the certificate installed on the bucket server
        """
        return pulumi.get(self, "certificate_common_name")

    @property
    @pulumi.getter(name="certificateExpiryDate")
    def certificate_expiry_date(self) -> builtins.str:
        """
        The bucket server's certificate expiry date.
        """
        return pulumi.get(self, "certificate_expiry_date")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> builtins.str:
        """
        The bucket server's IPv4 address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[builtins.str]:
        """
        The host part of the bucket URL, resolving to the bucket IP address and allowed by the server certificate.
        """
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class CifsUserResponse(dict):
    """
    The effective CIFS username when accessing the volume data.
    """
    def __init__(__self__, *,
                 username: Optional[builtins.str] = None):
        """
        The effective CIFS username when accessing the volume data.
        :param builtins.str username: The CIFS user's username
        """
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def username(self) -> Optional[builtins.str]:
        """
        The CIFS user's username
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DailyScheduleResponse(dict):
    """
    Daily Schedule properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotsToKeep":
            suggest = "snapshots_to_keep"
        elif key == "usedBytes":
            suggest = "used_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DailyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DailyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DailyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hour: Optional[builtins.int] = None,
                 minute: Optional[builtins.int] = None,
                 snapshots_to_keep: Optional[builtins.int] = None,
                 used_bytes: Optional[builtins.float] = None):
        """
        Daily Schedule properties
        :param builtins.int hour: Indicates which hour in UTC timezone a snapshot should be taken
        :param builtins.int minute: Indicates which minute snapshot should be taken
        :param builtins.int snapshots_to_keep: Daily snapshot count to keep
        :param builtins.float used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if snapshots_to_keep is not None:
            pulumi.set(__self__, "snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            pulumi.set(__self__, "used_bytes", used_bytes)

    @property
    @pulumi.getter
    def hour(self) -> Optional[builtins.int]:
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def minute(self) -> Optional[builtins.int]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[builtins.int]:
        """
        Daily snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[builtins.float]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")


@pulumi.output_type
class EncryptionIdentityResponse(dict):
    """
    Identity used to authenticate with key vault.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: builtins.str,
                 user_assigned_identity: Optional[builtins.str] = None):
        """
        Identity used to authenticate with key vault.
        :param builtins.str principal_id: The principal ID (object ID) of the identity used to authenticate with key vault. Read-only.
        :param builtins.str user_assigned_identity: The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The principal ID (object ID) of the identity used to authenticate with key vault. Read-only.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[builtins.str]:
        """
        The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities.
        """
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class ExportPolicyRuleResponse(dict):
    """
    Volume Export Policy Rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedClients":
            suggest = "allowed_clients"
        elif key == "chownMode":
            suggest = "chown_mode"
        elif key == "hasRootAccess":
            suggest = "has_root_access"
        elif key == "kerberos5ReadOnly":
            suggest = "kerberos5_read_only"
        elif key == "kerberos5ReadWrite":
            suggest = "kerberos5_read_write"
        elif key == "kerberos5iReadOnly":
            suggest = "kerberos5i_read_only"
        elif key == "kerberos5iReadWrite":
            suggest = "kerberos5i_read_write"
        elif key == "kerberos5pReadOnly":
            suggest = "kerberos5p_read_only"
        elif key == "kerberos5pReadWrite":
            suggest = "kerberos5p_read_write"
        elif key == "ruleIndex":
            suggest = "rule_index"
        elif key == "unixReadOnly":
            suggest = "unix_read_only"
        elif key == "unixReadWrite":
            suggest = "unix_read_write"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportPolicyRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportPolicyRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportPolicyRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_clients: Optional[builtins.str] = None,
                 chown_mode: Optional[builtins.str] = None,
                 cifs: Optional[builtins.bool] = None,
                 has_root_access: Optional[builtins.bool] = None,
                 kerberos5_read_only: Optional[builtins.bool] = None,
                 kerberos5_read_write: Optional[builtins.bool] = None,
                 kerberos5i_read_only: Optional[builtins.bool] = None,
                 kerberos5i_read_write: Optional[builtins.bool] = None,
                 kerberos5p_read_only: Optional[builtins.bool] = None,
                 kerberos5p_read_write: Optional[builtins.bool] = None,
                 nfsv3: Optional[builtins.bool] = None,
                 nfsv41: Optional[builtins.bool] = None,
                 rule_index: Optional[builtins.int] = None,
                 unix_read_only: Optional[builtins.bool] = None,
                 unix_read_write: Optional[builtins.bool] = None):
        """
        Volume Export Policy Rule
        :param builtins.str allowed_clients: Client ingress specification as comma separated string with IPv4 CIDRs, IPv4 host addresses and host names
        :param builtins.str chown_mode: This parameter specifies who is authorized to change the ownership of a file. restricted - Only root user can change the ownership of the file. unrestricted - Non-root users can change ownership of files that they own.
        :param builtins.bool cifs: Allows CIFS protocol
        :param builtins.bool has_root_access: Has root access to volume
        :param builtins.bool kerberos5_read_only: Kerberos5 Read only access. To be use with swagger version 2020-05-01 or later
        :param builtins.bool kerberos5_read_write: Kerberos5 Read and write access. To be use with swagger version 2020-05-01 or later
        :param builtins.bool kerberos5i_read_only: Kerberos5i Read only access. To be use with swagger version 2020-05-01 or later
        :param builtins.bool kerberos5i_read_write: Kerberos5i Read and write access. To be use with swagger version 2020-05-01 or later
        :param builtins.bool kerberos5p_read_only: Kerberos5p Read only access. To be use with swagger version 2020-05-01 or later
        :param builtins.bool kerberos5p_read_write: Kerberos5p Read and write access. To be use with swagger version 2020-05-01 or later
        :param builtins.bool nfsv3: Allows NFSv3 protocol. Enable only for NFSv3 type volumes
        :param builtins.bool nfsv41: Allows NFSv4.1 protocol. Enable only for NFSv4.1 type volumes
        :param builtins.int rule_index: Order index
        :param builtins.bool unix_read_only: Read only access
        :param builtins.bool unix_read_write: Read and write access
        """
        if allowed_clients is not None:
            pulumi.set(__self__, "allowed_clients", allowed_clients)
        if chown_mode is None:
            chown_mode = 'Restricted'
        if chown_mode is not None:
            pulumi.set(__self__, "chown_mode", chown_mode)
        if cifs is not None:
            pulumi.set(__self__, "cifs", cifs)
        if has_root_access is None:
            has_root_access = True
        if has_root_access is not None:
            pulumi.set(__self__, "has_root_access", has_root_access)
        if kerberos5_read_only is None:
            kerberos5_read_only = False
        if kerberos5_read_only is not None:
            pulumi.set(__self__, "kerberos5_read_only", kerberos5_read_only)
        if kerberos5_read_write is None:
            kerberos5_read_write = False
        if kerberos5_read_write is not None:
            pulumi.set(__self__, "kerberos5_read_write", kerberos5_read_write)
        if kerberos5i_read_only is None:
            kerberos5i_read_only = False
        if kerberos5i_read_only is not None:
            pulumi.set(__self__, "kerberos5i_read_only", kerberos5i_read_only)
        if kerberos5i_read_write is None:
            kerberos5i_read_write = False
        if kerberos5i_read_write is not None:
            pulumi.set(__self__, "kerberos5i_read_write", kerberos5i_read_write)
        if kerberos5p_read_only is None:
            kerberos5p_read_only = False
        if kerberos5p_read_only is not None:
            pulumi.set(__self__, "kerberos5p_read_only", kerberos5p_read_only)
        if kerberos5p_read_write is None:
            kerberos5p_read_write = False
        if kerberos5p_read_write is not None:
            pulumi.set(__self__, "kerberos5p_read_write", kerberos5p_read_write)
        if nfsv3 is not None:
            pulumi.set(__self__, "nfsv3", nfsv3)
        if nfsv41 is not None:
            pulumi.set(__self__, "nfsv41", nfsv41)
        if rule_index is not None:
            pulumi.set(__self__, "rule_index", rule_index)
        if unix_read_only is not None:
            pulumi.set(__self__, "unix_read_only", unix_read_only)
        if unix_read_write is not None:
            pulumi.set(__self__, "unix_read_write", unix_read_write)

    @property
    @pulumi.getter(name="allowedClients")
    def allowed_clients(self) -> Optional[builtins.str]:
        """
        Client ingress specification as comma separated string with IPv4 CIDRs, IPv4 host addresses and host names
        """
        return pulumi.get(self, "allowed_clients")

    @property
    @pulumi.getter(name="chownMode")
    def chown_mode(self) -> Optional[builtins.str]:
        """
        This parameter specifies who is authorized to change the ownership of a file. restricted - Only root user can change the ownership of the file. unrestricted - Non-root users can change ownership of files that they own.
        """
        return pulumi.get(self, "chown_mode")

    @property
    @pulumi.getter
    def cifs(self) -> Optional[builtins.bool]:
        """
        Allows CIFS protocol
        """
        return pulumi.get(self, "cifs")

    @property
    @pulumi.getter(name="hasRootAccess")
    def has_root_access(self) -> Optional[builtins.bool]:
        """
        Has root access to volume
        """
        return pulumi.get(self, "has_root_access")

    @property
    @pulumi.getter(name="kerberos5ReadOnly")
    def kerberos5_read_only(self) -> Optional[builtins.bool]:
        """
        Kerberos5 Read only access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5_read_only")

    @property
    @pulumi.getter(name="kerberos5ReadWrite")
    def kerberos5_read_write(self) -> Optional[builtins.bool]:
        """
        Kerberos5 Read and write access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5_read_write")

    @property
    @pulumi.getter(name="kerberos5iReadOnly")
    def kerberos5i_read_only(self) -> Optional[builtins.bool]:
        """
        Kerberos5i Read only access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5i_read_only")

    @property
    @pulumi.getter(name="kerberos5iReadWrite")
    def kerberos5i_read_write(self) -> Optional[builtins.bool]:
        """
        Kerberos5i Read and write access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5i_read_write")

    @property
    @pulumi.getter(name="kerberos5pReadOnly")
    def kerberos5p_read_only(self) -> Optional[builtins.bool]:
        """
        Kerberos5p Read only access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5p_read_only")

    @property
    @pulumi.getter(name="kerberos5pReadWrite")
    def kerberos5p_read_write(self) -> Optional[builtins.bool]:
        """
        Kerberos5p Read and write access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5p_read_write")

    @property
    @pulumi.getter
    def nfsv3(self) -> Optional[builtins.bool]:
        """
        Allows NFSv3 protocol. Enable only for NFSv3 type volumes
        """
        return pulumi.get(self, "nfsv3")

    @property
    @pulumi.getter
    def nfsv41(self) -> Optional[builtins.bool]:
        """
        Allows NFSv4.1 protocol. Enable only for NFSv4.1 type volumes
        """
        return pulumi.get(self, "nfsv41")

    @property
    @pulumi.getter(name="ruleIndex")
    def rule_index(self) -> Optional[builtins.int]:
        """
        Order index
        """
        return pulumi.get(self, "rule_index")

    @property
    @pulumi.getter(name="unixReadOnly")
    def unix_read_only(self) -> Optional[builtins.bool]:
        """
        Read only access
        """
        return pulumi.get(self, "unix_read_only")

    @property
    @pulumi.getter(name="unixReadWrite")
    def unix_read_write(self) -> Optional[builtins.bool]:
        """
        Read and write access
        """
        return pulumi.get(self, "unix_read_write")


@pulumi.output_type
class FileSystemUserResponse(dict):
    """
    File System user having access to volume data. For Unix, this is the user's uid and gid. For Windows, this is the user's username. Note that the Unix and Windows user details are mutually exclusive, meaning one or other must be supplied, but not both.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cifsUser":
            suggest = "cifs_user"
        elif key == "nfsUser":
            suggest = "nfs_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FileSystemUserResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FileSystemUserResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FileSystemUserResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cifs_user: Optional['outputs.CifsUserResponse'] = None,
                 nfs_user: Optional['outputs.NfsUserResponse'] = None):
        """
        File System user having access to volume data. For Unix, this is the user's uid and gid. For Windows, this is the user's username. Note that the Unix and Windows user details are mutually exclusive, meaning one or other must be supplied, but not both.
        :param 'CifsUserResponse' cifs_user: The effective CIFS username when accessing the volume data.
        :param 'NfsUserResponse' nfs_user: The effective NFS User ID and Group ID when accessing the volume data.
        """
        if cifs_user is not None:
            pulumi.set(__self__, "cifs_user", cifs_user)
        if nfs_user is not None:
            pulumi.set(__self__, "nfs_user", nfs_user)

    @property
    @pulumi.getter(name="cifsUser")
    def cifs_user(self) -> Optional['outputs.CifsUserResponse']:
        """
        The effective CIFS username when accessing the volume data.
        """
        return pulumi.get(self, "cifs_user")

    @property
    @pulumi.getter(name="nfsUser")
    def nfs_user(self) -> Optional['outputs.NfsUserResponse']:
        """
        The effective NFS User ID and Group ID when accessing the volume data.
        """
        return pulumi.get(self, "nfs_user")


@pulumi.output_type
class HourlyScheduleResponse(dict):
    """
    Hourly Schedule properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotsToKeep":
            suggest = "snapshots_to_keep"
        elif key == "usedBytes":
            suggest = "used_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HourlyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HourlyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HourlyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minute: Optional[builtins.int] = None,
                 snapshots_to_keep: Optional[builtins.int] = None,
                 used_bytes: Optional[builtins.float] = None):
        """
        Hourly Schedule properties
        :param builtins.int minute: Indicates which minute snapshot should be taken
        :param builtins.int snapshots_to_keep: Hourly snapshot count to keep
        :param builtins.float used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if snapshots_to_keep is not None:
            pulumi.set(__self__, "snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            pulumi.set(__self__, "used_bytes", used_bytes)

    @property
    @pulumi.getter
    def minute(self) -> Optional[builtins.int]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[builtins.int]:
        """
        Hourly snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[builtins.float]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")


@pulumi.output_type
class KeyVaultPrivateEndpointResponse(dict):
    """
    Pairs of virtual network ID and private endpoint ID. Every virtual network that has volumes encrypted with customer-managed keys needs its own key vault private endpoint.
    """
    def __init__(__self__, *,
                 private_endpoint_id: Optional[builtins.str] = None,
                 virtual_network_id: Optional[builtins.str] = None):
        """
        Pairs of virtual network ID and private endpoint ID. Every virtual network that has volumes encrypted with customer-managed keys needs its own key vault private endpoint.
        :param builtins.str private_endpoint_id: Identifier of the private endpoint to reach the Azure Key Vault
        :param builtins.str virtual_network_id: Identifier for the virtual network id
        """
        if private_endpoint_id is not None:
            pulumi.set(__self__, "private_endpoint_id", private_endpoint_id)
        if virtual_network_id is not None:
            pulumi.set(__self__, "virtual_network_id", virtual_network_id)

    @property
    @pulumi.getter(name="privateEndpointId")
    def private_endpoint_id(self) -> Optional[builtins.str]:
        """
        Identifier of the private endpoint to reach the Azure Key Vault
        """
        return pulumi.get(self, "private_endpoint_id")

    @property
    @pulumi.getter(name="virtualNetworkId")
    def virtual_network_id(self) -> Optional[builtins.str]:
        """
        Identifier for the virtual network id
        """
        return pulumi.get(self, "virtual_network_id")


@pulumi.output_type
class KeyVaultPropertiesResponse(dict):
    """
    Properties of key vault.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyName":
            suggest = "key_name"
        elif key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "keyVaultUri":
            suggest = "key_vault_uri"
        elif key == "keyVaultResourceId":
            suggest = "key_vault_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_name: builtins.str,
                 key_vault_id: builtins.str,
                 key_vault_uri: builtins.str,
                 status: builtins.str,
                 key_vault_resource_id: Optional[builtins.str] = None):
        """
        Properties of key vault.
        :param builtins.str key_name: The name of KeyVault key.
        :param builtins.str key_vault_id: UUID v4 used to identify the Azure Key Vault configuration
        :param builtins.str key_vault_uri: The Uri of KeyVault.
        :param builtins.str status: Status of the KeyVault connection.
        :param builtins.str key_vault_resource_id: The resource ID of KeyVault.
        """
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "key_vault_id", key_vault_id)
        pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        pulumi.set(__self__, "status", status)
        if key_vault_resource_id is not None:
            pulumi.set(__self__, "key_vault_resource_id", key_vault_resource_id)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> builtins.str:
        """
        The name of KeyVault key.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> builtins.str:
        """
        UUID v4 used to identify the Azure Key Vault configuration
        """
        return pulumi.get(self, "key_vault_id")

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> builtins.str:
        """
        The Uri of KeyVault.
        """
        return pulumi.get(self, "key_vault_uri")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        Status of the KeyVault connection.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> Optional[builtins.str]:
        """
        The resource ID of KeyVault.
        """
        return pulumi.get(self, "key_vault_resource_id")


@pulumi.output_type
class LdapSearchScopeOptResponse(dict):
    """
    LDAP search scope 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupDN":
            suggest = "group_dn"
        elif key == "groupMembershipFilter":
            suggest = "group_membership_filter"
        elif key == "userDN":
            suggest = "user_dn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LdapSearchScopeOptResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LdapSearchScopeOptResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LdapSearchScopeOptResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_dn: Optional[builtins.str] = None,
                 group_membership_filter: Optional[builtins.str] = None,
                 user_dn: Optional[builtins.str] = None):
        """
        LDAP search scope 
        :param builtins.str group_dn: This specifies the group DN, which overrides the base DN for group lookups.
        :param builtins.str group_membership_filter: This specifies the custom LDAP search filter to be used when looking up group membership from LDAP server.
        :param builtins.str user_dn: This specifies the user DN, which overrides the base DN for user lookups.
        """
        if group_dn is not None:
            pulumi.set(__self__, "group_dn", group_dn)
        if group_membership_filter is not None:
            pulumi.set(__self__, "group_membership_filter", group_membership_filter)
        if user_dn is not None:
            pulumi.set(__self__, "user_dn", user_dn)

    @property
    @pulumi.getter(name="groupDN")
    def group_dn(self) -> Optional[builtins.str]:
        """
        This specifies the group DN, which overrides the base DN for group lookups.
        """
        return pulumi.get(self, "group_dn")

    @property
    @pulumi.getter(name="groupMembershipFilter")
    def group_membership_filter(self) -> Optional[builtins.str]:
        """
        This specifies the custom LDAP search filter to be used when looking up group membership from LDAP server.
        """
        return pulumi.get(self, "group_membership_filter")

    @property
    @pulumi.getter(name="userDN")
    def user_dn(self) -> Optional[builtins.str]:
        """
        This specifies the user DN, which overrides the base DN for user lookups.
        """
        return pulumi.get(self, "user_dn")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: builtins.str,
                 tenant_id: builtins.str,
                 type: builtins.str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param builtins.str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MonthlyScheduleResponse(dict):
    """
    Monthly Schedule properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfMonth":
            suggest = "days_of_month"
        elif key == "snapshotsToKeep":
            suggest = "snapshots_to_keep"
        elif key == "usedBytes":
            suggest = "used_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonthlyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonthlyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonthlyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_month: Optional[builtins.str] = None,
                 hour: Optional[builtins.int] = None,
                 minute: Optional[builtins.int] = None,
                 snapshots_to_keep: Optional[builtins.int] = None,
                 used_bytes: Optional[builtins.float] = None):
        """
        Monthly Schedule properties
        :param builtins.str days_of_month: Indicates which days of the month snapshot should be taken. A comma delimited string.
        :param builtins.int hour: Indicates which hour in UTC timezone a snapshot should be taken
        :param builtins.int minute: Indicates which minute snapshot should be taken
        :param builtins.int snapshots_to_keep: Monthly snapshot count to keep
        :param builtins.float used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        if days_of_month is not None:
            pulumi.set(__self__, "days_of_month", days_of_month)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if snapshots_to_keep is not None:
            pulumi.set(__self__, "snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            pulumi.set(__self__, "used_bytes", used_bytes)

    @property
    @pulumi.getter(name="daysOfMonth")
    def days_of_month(self) -> Optional[builtins.str]:
        """
        Indicates which days of the month snapshot should be taken. A comma delimited string.
        """
        return pulumi.get(self, "days_of_month")

    @property
    @pulumi.getter
    def hour(self) -> Optional[builtins.int]:
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def minute(self) -> Optional[builtins.int]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[builtins.int]:
        """
        Monthly snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[builtins.float]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")


@pulumi.output_type
class MountTargetPropertiesResponse(dict):
    """
    Mount target properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemId":
            suggest = "file_system_id"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "mountTargetId":
            suggest = "mount_target_id"
        elif key == "smbServerFqdn":
            suggest = "smb_server_fqdn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MountTargetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MountTargetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MountTargetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_system_id: builtins.str,
                 ip_address: builtins.str,
                 mount_target_id: builtins.str,
                 smb_server_fqdn: Optional[builtins.str] = None):
        """
        Mount target properties
        :param builtins.str file_system_id: UUID v4 used to identify the MountTarget
        :param builtins.str ip_address: The mount target's IPv4 address
        :param builtins.str mount_target_id: UUID v4 used to identify the MountTarget
        :param builtins.str smb_server_fqdn: The SMB server's Fully Qualified Domain Name, FQDN
        """
        pulumi.set(__self__, "file_system_id", file_system_id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "mount_target_id", mount_target_id)
        if smb_server_fqdn is not None:
            pulumi.set(__self__, "smb_server_fqdn", smb_server_fqdn)

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> builtins.str:
        """
        UUID v4 used to identify the MountTarget
        """
        return pulumi.get(self, "file_system_id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> builtins.str:
        """
        The mount target's IPv4 address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="mountTargetId")
    def mount_target_id(self) -> builtins.str:
        """
        UUID v4 used to identify the MountTarget
        """
        return pulumi.get(self, "mount_target_id")

    @property
    @pulumi.getter(name="smbServerFqdn")
    def smb_server_fqdn(self) -> Optional[builtins.str]:
        """
        The SMB server's Fully Qualified Domain Name, FQDN
        """
        return pulumi.get(self, "smb_server_fqdn")


@pulumi.output_type
class NfsUserResponse(dict):
    """
    The effective NFS User ID and Group ID when accessing the volume data.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NfsUserResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NfsUserResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NfsUserResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: Optional[builtins.float] = None,
                 user_id: Optional[builtins.float] = None):
        """
        The effective NFS User ID and Group ID when accessing the volume data.
        :param builtins.float group_id: The NFS user's GID
        :param builtins.float user_id: The NFS user's UID
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[builtins.float]:
        """
        The NFS user's GID
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[builtins.float]:
        """
        The NFS user's UID
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class PlacementKeyValuePairsResponse(dict):
    """
    Application specific parameters for the placement of volumes in the volume group
    """
    def __init__(__self__, *,
                 key: builtins.str,
                 value: builtins.str):
        """
        Application specific parameters for the placement of volumes in the volume group
        :param builtins.str key: Key for an application specific parameter for the placement of volumes in the volume group
        :param builtins.str value: Value for an application specific parameter for the placement of volumes in the volume group
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        Key for an application specific parameter for the placement of volumes in the volume group
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        Value for an application specific parameter for the placement of volumes in the volume group
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class QuotaReportResponse(dict):
    """
    Quota report record properties
    """
    def __init__(__self__, *,
                 is_derived_quota: Optional[builtins.bool] = None,
                 percentage_used: Optional[builtins.float] = None,
                 quota_limit_total_in_ki_bs: Optional[builtins.float] = None,
                 quota_limit_used_in_ki_bs: Optional[builtins.float] = None,
                 quota_target: Optional[builtins.str] = None,
                 quota_type: Optional[builtins.str] = None):
        """
        Quota report record properties
        :param builtins.bool is_derived_quota: Flag to indicate whether the quota is derived from default quota.
        :param builtins.float percentage_used: Percentage of used size compared to total size.
        :param builtins.float quota_limit_total_in_ki_bs: Specifies the total size limit in kibibytes for the user/group quota.
        :param builtins.float quota_limit_used_in_ki_bs: Specifies the current usage in kibibytes for the user/group quota.
        :param builtins.str quota_target: UserID/GroupID/SID based on the quota target type. UserID and groupID can be found by running id or getent command for the user or group and SID can be found by running <wmic useraccount where name='user-name' get sid>
        :param builtins.str quota_type: Type of quota
        """
        if is_derived_quota is not None:
            pulumi.set(__self__, "is_derived_quota", is_derived_quota)
        if percentage_used is not None:
            pulumi.set(__self__, "percentage_used", percentage_used)
        if quota_limit_total_in_ki_bs is not None:
            pulumi.set(__self__, "quota_limit_total_in_ki_bs", quota_limit_total_in_ki_bs)
        if quota_limit_used_in_ki_bs is not None:
            pulumi.set(__self__, "quota_limit_used_in_ki_bs", quota_limit_used_in_ki_bs)
        if quota_target is not None:
            pulumi.set(__self__, "quota_target", quota_target)
        if quota_type is not None:
            pulumi.set(__self__, "quota_type", quota_type)

    @property
    @pulumi.getter(name="isDerivedQuota")
    def is_derived_quota(self) -> Optional[builtins.bool]:
        """
        Flag to indicate whether the quota is derived from default quota.
        """
        return pulumi.get(self, "is_derived_quota")

    @property
    @pulumi.getter(name="percentageUsed")
    def percentage_used(self) -> Optional[builtins.float]:
        """
        Percentage of used size compared to total size.
        """
        return pulumi.get(self, "percentage_used")

    @property
    @pulumi.getter(name="quotaLimitTotalInKiBs")
    def quota_limit_total_in_ki_bs(self) -> Optional[builtins.float]:
        """
        Specifies the total size limit in kibibytes for the user/group quota.
        """
        return pulumi.get(self, "quota_limit_total_in_ki_bs")

    @property
    @pulumi.getter(name="quotaLimitUsedInKiBs")
    def quota_limit_used_in_ki_bs(self) -> Optional[builtins.float]:
        """
        Specifies the current usage in kibibytes for the user/group quota.
        """
        return pulumi.get(self, "quota_limit_used_in_ki_bs")

    @property
    @pulumi.getter(name="quotaTarget")
    def quota_target(self) -> Optional[builtins.str]:
        """
        UserID/GroupID/SID based on the quota target type. UserID and groupID can be found by running id or getent command for the user or group and SID can be found by running <wmic useraccount where name='user-name' get sid>
        """
        return pulumi.get(self, "quota_target")

    @property
    @pulumi.getter(name="quotaType")
    def quota_type(self) -> Optional[builtins.str]:
        """
        Type of quota
        """
        return pulumi.get(self, "quota_type")


@pulumi.output_type
class RemotePathResponse(dict):
    """
    The full path to a volume that is to be migrated into ANF. Required for Migration volumes
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalHostName":
            suggest = "external_host_name"
        elif key == "serverName":
            suggest = "server_name"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RemotePathResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RemotePathResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RemotePathResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_host_name: builtins.str,
                 server_name: builtins.str,
                 volume_name: builtins.str):
        """
        The full path to a volume that is to be migrated into ANF. Required for Migration volumes
        :param builtins.str external_host_name: The Path to a ONTAP Host
        :param builtins.str server_name: The name of a server on the ONTAP Host
        :param builtins.str volume_name: The name of a volume on the server
        """
        pulumi.set(__self__, "external_host_name", external_host_name)
        pulumi.set(__self__, "server_name", server_name)
        pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="externalHostName")
    def external_host_name(self) -> builtins.str:
        """
        The Path to a ONTAP Host
        """
        return pulumi.get(self, "external_host_name")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> builtins.str:
        """
        The name of a server on the ONTAP Host
        """
        return pulumi.get(self, "server_name")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> builtins.str:
        """
        The name of a volume on the server
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class ReplicationObjectResponse(dict):
    """
    Replication properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicationId":
            suggest = "replication_id"
        elif key == "endpointType":
            suggest = "endpoint_type"
        elif key == "remotePath":
            suggest = "remote_path"
        elif key == "remoteVolumeRegion":
            suggest = "remote_volume_region"
        elif key == "remoteVolumeResourceId":
            suggest = "remote_volume_resource_id"
        elif key == "replicationSchedule":
            suggest = "replication_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReplicationObjectResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReplicationObjectResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReplicationObjectResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replication_id: builtins.str,
                 endpoint_type: Optional[builtins.str] = None,
                 remote_path: Optional['outputs.RemotePathResponse'] = None,
                 remote_volume_region: Optional[builtins.str] = None,
                 remote_volume_resource_id: Optional[builtins.str] = None,
                 replication_schedule: Optional[builtins.str] = None):
        """
        Replication properties
        :param builtins.str replication_id: Id
        :param builtins.str endpoint_type: Indicates whether the local volume is the source or destination for the Volume Replication
        :param 'RemotePathResponse' remote_path: The full path to a volume that is to be migrated into ANF. Required for Migration volumes
        :param builtins.str remote_volume_region: The remote region for the other end of the Volume Replication.
        :param builtins.str remote_volume_resource_id: The resource ID of the remote volume. Required for cross region and cross zone replication
        :param builtins.str replication_schedule: Schedule
        """
        pulumi.set(__self__, "replication_id", replication_id)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if remote_path is not None:
            pulumi.set(__self__, "remote_path", remote_path)
        if remote_volume_region is not None:
            pulumi.set(__self__, "remote_volume_region", remote_volume_region)
        if remote_volume_resource_id is not None:
            pulumi.set(__self__, "remote_volume_resource_id", remote_volume_resource_id)
        if replication_schedule is not None:
            pulumi.set(__self__, "replication_schedule", replication_schedule)

    @property
    @pulumi.getter(name="replicationId")
    def replication_id(self) -> builtins.str:
        """
        Id
        """
        return pulumi.get(self, "replication_id")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[builtins.str]:
        """
        Indicates whether the local volume is the source or destination for the Volume Replication
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="remotePath")
    def remote_path(self) -> Optional['outputs.RemotePathResponse']:
        """
        The full path to a volume that is to be migrated into ANF. Required for Migration volumes
        """
        return pulumi.get(self, "remote_path")

    @property
    @pulumi.getter(name="remoteVolumeRegion")
    def remote_volume_region(self) -> Optional[builtins.str]:
        """
        The remote region for the other end of the Volume Replication.
        """
        return pulumi.get(self, "remote_volume_region")

    @property
    @pulumi.getter(name="remoteVolumeResourceId")
    def remote_volume_resource_id(self) -> Optional[builtins.str]:
        """
        The resource ID of the remote volume. Required for cross region and cross zone replication
        """
        return pulumi.get(self, "remote_volume_resource_id")

    @property
    @pulumi.getter(name="replicationSchedule")
    def replication_schedule(self) -> Optional[builtins.str]:
        """
        Schedule
        """
        return pulumi.get(self, "replication_schedule")


@pulumi.output_type
class ReplicationResponse(dict):
    """
    Replication properties
    """
    def __init__(__self__, *,
                 remote_volume_resource_id: builtins.str,
                 replication_id: builtins.str,
                 endpoint_type: Optional[builtins.str] = None,
                 remote_volume_region: Optional[builtins.str] = None,
                 replication_schedule: Optional[builtins.str] = None):
        """
        Replication properties
        :param builtins.str remote_volume_resource_id: The resource ID of the remote volume.
        :param builtins.str replication_id: UUID v4 used to identify the replication.
        :param builtins.str endpoint_type: Indicates whether the local volume is the source or destination for the Volume Replication
        :param builtins.str remote_volume_region: The remote region for the other end of the Volume Replication.
        :param builtins.str replication_schedule: Schedule
        """
        pulumi.set(__self__, "remote_volume_resource_id", remote_volume_resource_id)
        pulumi.set(__self__, "replication_id", replication_id)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if remote_volume_region is not None:
            pulumi.set(__self__, "remote_volume_region", remote_volume_region)
        if replication_schedule is not None:
            pulumi.set(__self__, "replication_schedule", replication_schedule)

    @property
    @pulumi.getter(name="remoteVolumeResourceId")
    def remote_volume_resource_id(self) -> builtins.str:
        """
        The resource ID of the remote volume.
        """
        return pulumi.get(self, "remote_volume_resource_id")

    @property
    @pulumi.getter(name="replicationId")
    def replication_id(self) -> builtins.str:
        """
        UUID v4 used to identify the replication.
        """
        return pulumi.get(self, "replication_id")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[builtins.str]:
        """
        Indicates whether the local volume is the source or destination for the Volume Replication
        """
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter(name="remoteVolumeRegion")
    def remote_volume_region(self) -> Optional[builtins.str]:
        """
        The remote region for the other end of the Volume Replication.
        """
        return pulumi.get(self, "remote_volume_region")

    @property
    @pulumi.getter(name="replicationSchedule")
    def replication_schedule(self) -> Optional[builtins.str]:
        """
        Schedule
        """
        return pulumi.get(self, "replication_schedule")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[builtins.str] = None,
                 created_by: Optional[builtins.str] = None,
                 created_by_type: Optional[builtins.str] = None,
                 last_modified_at: Optional[builtins.str] = None,
                 last_modified_by: Optional[builtins.str] = None,
                 last_modified_by_type: Optional[builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param builtins.str created_at: The timestamp of resource creation (UTC).
        :param builtins.str created_by: The identity that created the resource.
        :param builtins.str created_by_type: The type of identity that created the resource.
        :param builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param builtins.str last_modified_by: The identity that last modified the resource.
        :param builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: builtins.str,
                 principal_id: builtins.str):
        """
        User assigned identity properties
        :param builtins.str client_id: The client ID of the assigned identity.
        :param builtins.str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VolumeBackupPropertiesResponse(dict):
    """
    Volume Backup Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupPolicyId":
            suggest = "backup_policy_id"
        elif key == "backupVaultId":
            suggest = "backup_vault_id"
        elif key == "policyEnforced":
            suggest = "policy_enforced"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeBackupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeBackupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeBackupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_policy_id: Optional[builtins.str] = None,
                 backup_vault_id: Optional[builtins.str] = None,
                 policy_enforced: Optional[builtins.bool] = None):
        """
        Volume Backup Properties
        :param builtins.str backup_policy_id: Backup Policy Resource ID
        :param builtins.str backup_vault_id: Backup Vault Resource ID
        :param builtins.bool policy_enforced: Policy Enforced
        """
        if backup_policy_id is not None:
            pulumi.set(__self__, "backup_policy_id", backup_policy_id)
        if backup_vault_id is not None:
            pulumi.set(__self__, "backup_vault_id", backup_vault_id)
        if policy_enforced is not None:
            pulumi.set(__self__, "policy_enforced", policy_enforced)

    @property
    @pulumi.getter(name="backupPolicyId")
    def backup_policy_id(self) -> Optional[builtins.str]:
        """
        Backup Policy Resource ID
        """
        return pulumi.get(self, "backup_policy_id")

    @property
    @pulumi.getter(name="backupVaultId")
    def backup_vault_id(self) -> Optional[builtins.str]:
        """
        Backup Vault Resource ID
        """
        return pulumi.get(self, "backup_vault_id")

    @property
    @pulumi.getter(name="policyEnforced")
    def policy_enforced(self) -> Optional[builtins.bool]:
        """
        Policy Enforced
        """
        return pulumi.get(self, "policy_enforced")


@pulumi.output_type
class VolumeBackupsResponse(dict):
    """
    Volume details using the backup policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupsCount":
            suggest = "backups_count"
        elif key == "policyEnabled":
            suggest = "policy_enabled"
        elif key == "volumeName":
            suggest = "volume_name"
        elif key == "volumeResourceId":
            suggest = "volume_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeBackupsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeBackupsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeBackupsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backups_count: Optional[builtins.int] = None,
                 policy_enabled: Optional[builtins.bool] = None,
                 volume_name: Optional[builtins.str] = None,
                 volume_resource_id: Optional[builtins.str] = None):
        """
        Volume details using the backup policy
        :param builtins.int backups_count: Total count of backups for volume
        :param builtins.bool policy_enabled: Policy enabled
        :param builtins.str volume_name: Volume name
        :param builtins.str volume_resource_id: ResourceId used to identify the Volume
        """
        if backups_count is not None:
            pulumi.set(__self__, "backups_count", backups_count)
        if policy_enabled is not None:
            pulumi.set(__self__, "policy_enabled", policy_enabled)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)
        if volume_resource_id is not None:
            pulumi.set(__self__, "volume_resource_id", volume_resource_id)

    @property
    @pulumi.getter(name="backupsCount")
    def backups_count(self) -> Optional[builtins.int]:
        """
        Total count of backups for volume
        """
        return pulumi.get(self, "backups_count")

    @property
    @pulumi.getter(name="policyEnabled")
    def policy_enabled(self) -> Optional[builtins.bool]:
        """
        Policy enabled
        """
        return pulumi.get(self, "policy_enabled")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[builtins.str]:
        """
        Volume name
        """
        return pulumi.get(self, "volume_name")

    @property
    @pulumi.getter(name="volumeResourceId")
    def volume_resource_id(self) -> Optional[builtins.str]:
        """
        ResourceId used to identify the Volume
        """
        return pulumi.get(self, "volume_resource_id")


@pulumi.output_type
class VolumeGroupMetaDataResponse(dict):
    """
    Volume group properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumesCount":
            suggest = "volumes_count"
        elif key == "applicationIdentifier":
            suggest = "application_identifier"
        elif key == "applicationType":
            suggest = "application_type"
        elif key == "globalPlacementRules":
            suggest = "global_placement_rules"
        elif key == "groupDescription":
            suggest = "group_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeGroupMetaDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeGroupMetaDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeGroupMetaDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volumes_count: builtins.float,
                 application_identifier: Optional[builtins.str] = None,
                 application_type: Optional[builtins.str] = None,
                 global_placement_rules: Optional[Sequence['outputs.PlacementKeyValuePairsResponse']] = None,
                 group_description: Optional[builtins.str] = None):
        """
        Volume group properties
        :param builtins.float volumes_count: Number of volumes in volume group
        :param builtins.str application_identifier: Application specific identifier
        :param builtins.str application_type: Application Type
        :param Sequence['PlacementKeyValuePairsResponse'] global_placement_rules: Application specific placement rules for the volume group
        :param builtins.str group_description: Group Description
        """
        pulumi.set(__self__, "volumes_count", volumes_count)
        if application_identifier is not None:
            pulumi.set(__self__, "application_identifier", application_identifier)
        if application_type is not None:
            pulumi.set(__self__, "application_type", application_type)
        if global_placement_rules is not None:
            pulumi.set(__self__, "global_placement_rules", global_placement_rules)
        if group_description is not None:
            pulumi.set(__self__, "group_description", group_description)

    @property
    @pulumi.getter(name="volumesCount")
    def volumes_count(self) -> builtins.float:
        """
        Number of volumes in volume group
        """
        return pulumi.get(self, "volumes_count")

    @property
    @pulumi.getter(name="applicationIdentifier")
    def application_identifier(self) -> Optional[builtins.str]:
        """
        Application specific identifier
        """
        return pulumi.get(self, "application_identifier")

    @property
    @pulumi.getter(name="applicationType")
    def application_type(self) -> Optional[builtins.str]:
        """
        Application Type
        """
        return pulumi.get(self, "application_type")

    @property
    @pulumi.getter(name="globalPlacementRules")
    def global_placement_rules(self) -> Optional[Sequence['outputs.PlacementKeyValuePairsResponse']]:
        """
        Application specific placement rules for the volume group
        """
        return pulumi.get(self, "global_placement_rules")

    @property
    @pulumi.getter(name="groupDescription")
    def group_description(self) -> Optional[builtins.str]:
        """
        Group Description
        """
        return pulumi.get(self, "group_description")


@pulumi.output_type
class VolumeGroupVolumePropertiesResponse(dict):
    """
    Volume resource
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actualThroughputMibps":
            suggest = "actual_throughput_mibps"
        elif key == "baremetalTenantId":
            suggest = "baremetal_tenant_id"
        elif key == "cloneProgress":
            suggest = "clone_progress"
        elif key == "creationToken":
            suggest = "creation_token"
        elif key == "dataStoreResourceId":
            suggest = "data_store_resource_id"
        elif key == "effectiveNetworkFeatures":
            suggest = "effective_network_features"
        elif key == "fileAccessLogs":
            suggest = "file_access_logs"
        elif key == "fileSystemId":
            suggest = "file_system_id"
        elif key == "maximumNumberOfFiles":
            suggest = "maximum_number_of_files"
        elif key == "mountTargets":
            suggest = "mount_targets"
        elif key == "networkSiblingSetId":
            suggest = "network_sibling_set_id"
        elif key == "originatingResourceId":
            suggest = "originating_resource_id"
        elif key == "provisionedAvailabilityZone":
            suggest = "provisioned_availability_zone"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "storageToNetworkProximity":
            suggest = "storage_to_network_proximity"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "t2Network":
            suggest = "t2_network"
        elif key == "usageThreshold":
            suggest = "usage_threshold"
        elif key == "volumeGroupName":
            suggest = "volume_group_name"
        elif key == "avsDataStore":
            suggest = "avs_data_store"
        elif key == "backupId":
            suggest = "backup_id"
        elif key == "capacityPoolResourceId":
            suggest = "capacity_pool_resource_id"
        elif key == "coolAccess":
            suggest = "cool_access"
        elif key == "coolAccessRetrievalPolicy":
            suggest = "cool_access_retrieval_policy"
        elif key == "coolAccessTieringPolicy":
            suggest = "cool_access_tiering_policy"
        elif key == "coolnessPeriod":
            suggest = "coolness_period"
        elif key == "dataProtection":
            suggest = "data_protection"
        elif key == "defaultGroupQuotaInKiBs":
            suggest = "default_group_quota_in_ki_bs"
        elif key == "defaultUserQuotaInKiBs":
            suggest = "default_user_quota_in_ki_bs"
        elif key == "deleteBaseSnapshot":
            suggest = "delete_base_snapshot"
        elif key == "enableSubvolumes":
            suggest = "enable_subvolumes"
        elif key == "encryptionKeySource":
            suggest = "encryption_key_source"
        elif key == "exportPolicy":
            suggest = "export_policy"
        elif key == "isDefaultQuotaEnabled":
            suggest = "is_default_quota_enabled"
        elif key == "isLargeVolume":
            suggest = "is_large_volume"
        elif key == "isRestoring":
            suggest = "is_restoring"
        elif key == "kerberosEnabled":
            suggest = "kerberos_enabled"
        elif key == "keyVaultPrivateEndpointResourceId":
            suggest = "key_vault_private_endpoint_resource_id"
        elif key == "ldapEnabled":
            suggest = "ldap_enabled"
        elif key == "networkFeatures":
            suggest = "network_features"
        elif key == "placementRules":
            suggest = "placement_rules"
        elif key == "protocolTypes":
            suggest = "protocol_types"
        elif key == "proximityPlacementGroup":
            suggest = "proximity_placement_group"
        elif key == "securityStyle":
            suggest = "security_style"
        elif key == "serviceLevel":
            suggest = "service_level"
        elif key == "smbAccessBasedEnumeration":
            suggest = "smb_access_based_enumeration"
        elif key == "smbContinuouslyAvailable":
            suggest = "smb_continuously_available"
        elif key == "smbEncryption":
            suggest = "smb_encryption"
        elif key == "smbNonBrowsable":
            suggest = "smb_non_browsable"
        elif key == "snapshotDirectoryVisible":
            suggest = "snapshot_directory_visible"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "throughputMibps":
            suggest = "throughput_mibps"
        elif key == "unixPermissions":
            suggest = "unix_permissions"
        elif key == "volumeSpecName":
            suggest = "volume_spec_name"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeGroupVolumePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeGroupVolumePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeGroupVolumePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actual_throughput_mibps: builtins.float,
                 baremetal_tenant_id: builtins.str,
                 clone_progress: builtins.int,
                 creation_token: builtins.str,
                 data_store_resource_id: Sequence[builtins.str],
                 effective_network_features: builtins.str,
                 encrypted: builtins.bool,
                 file_access_logs: Optional[builtins.str] = None,
                 file_system_id: builtins.str,
                 id: builtins.str,
                 maximum_number_of_files: builtins.float,
                 mount_targets: Sequence['outputs.MountTargetPropertiesResponse'],
                 network_sibling_set_id: builtins.str,
                 originating_resource_id: builtins.str,
                 provisioned_availability_zone: builtins.str,
                 provisioning_state: builtins.str,
                 storage_to_network_proximity: builtins.str,
                 subnet_id: builtins.str,
                 t2_network: builtins.str,
                 type: builtins.str,
                 usage_threshold: Optional[builtins.float] = None,
                 volume_group_name: builtins.str,
                 avs_data_store: Optional[builtins.str] = None,
                 backup_id: Optional[builtins.str] = None,
                 capacity_pool_resource_id: Optional[builtins.str] = None,
                 cool_access: Optional[builtins.bool] = None,
                 cool_access_retrieval_policy: Optional[builtins.str] = None,
                 cool_access_tiering_policy: Optional[builtins.str] = None,
                 coolness_period: Optional[builtins.int] = None,
                 data_protection: Optional['outputs.VolumePropertiesResponseDataProtection'] = None,
                 default_group_quota_in_ki_bs: Optional[builtins.float] = None,
                 default_user_quota_in_ki_bs: Optional[builtins.float] = None,
                 delete_base_snapshot: Optional[builtins.bool] = None,
                 enable_subvolumes: Optional[builtins.str] = None,
                 encryption_key_source: Optional[builtins.str] = None,
                 export_policy: Optional['outputs.VolumePropertiesResponseExportPolicy'] = None,
                 is_default_quota_enabled: Optional[builtins.bool] = None,
                 is_large_volume: Optional[builtins.bool] = None,
                 is_restoring: Optional[builtins.bool] = None,
                 kerberos_enabled: Optional[builtins.bool] = None,
                 key_vault_private_endpoint_resource_id: Optional[builtins.str] = None,
                 ldap_enabled: Optional[builtins.bool] = None,
                 name: Optional[builtins.str] = None,
                 network_features: Optional[builtins.str] = None,
                 placement_rules: Optional[Sequence['outputs.PlacementKeyValuePairsResponse']] = None,
                 protocol_types: Optional[Sequence[builtins.str]] = None,
                 proximity_placement_group: Optional[builtins.str] = None,
                 security_style: Optional[builtins.str] = None,
                 service_level: Optional[builtins.str] = None,
                 smb_access_based_enumeration: Optional[builtins.str] = None,
                 smb_continuously_available: Optional[builtins.bool] = None,
                 smb_encryption: Optional[builtins.bool] = None,
                 smb_non_browsable: Optional[builtins.str] = None,
                 snapshot_directory_visible: Optional[builtins.bool] = None,
                 snapshot_id: Optional[builtins.str] = None,
                 tags: Optional[Mapping[str, builtins.str]] = None,
                 throughput_mibps: Optional[builtins.float] = None,
                 unix_permissions: Optional[builtins.str] = None,
                 volume_spec_name: Optional[builtins.str] = None,
                 volume_type: Optional[builtins.str] = None,
                 zones: Optional[Sequence[builtins.str]] = None):
        """
        Volume resource
        :param builtins.float actual_throughput_mibps: Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
        :param builtins.str baremetal_tenant_id: Unique Baremetal Tenant Identifier.
        :param builtins.int clone_progress: When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process. When this value is empty/null there is no cloning process currently happening on this volume. This value will update every 5 minutes during cloning.
        :param builtins.str creation_token: A unique file path for the volume. Used when creating mount targets
        :param Sequence[builtins.str] data_store_resource_id: Data store resource unique identifier
        :param builtins.str effective_network_features: The effective value of the network features type available to the volume, or current effective state of update.
        :param builtins.bool encrypted: Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
        :param builtins.str file_access_logs: Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the volume.
        :param builtins.str file_system_id: Unique FileSystem Identifier.
        :param builtins.str id: Resource Id
        :param builtins.float maximum_number_of_files: Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume quota is more than 4TiB.
        :param Sequence['MountTargetPropertiesResponse'] mount_targets: List of mount targets
        :param builtins.str network_sibling_set_id: Network Sibling Set ID for the the group of volumes sharing networking resources.
        :param builtins.str originating_resource_id: Id of the snapshot or backup that the volume is restored from.
        :param builtins.str provisioned_availability_zone: The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
        :param builtins.str provisioning_state: Azure lifecycle management
        :param builtins.str storage_to_network_proximity: Provides storage to network proximity information for the volume.
        :param builtins.str subnet_id: The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        :param builtins.str t2_network: T2 network information
        :param builtins.str type: Resource type
        :param builtins.float usage_threshold: Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. For regular volumes, valid values are in the range 50GiB to 100TiB. For large volumes, valid values are in the range 100TiB to 500TiB, and on an exceptional basis, from to 2400GiB to 2400TiB. Values expressed in bytes as multiples of 1 GiB.
        :param builtins.str volume_group_name: Volume Group Name
        :param builtins.str avs_data_store: Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        :param builtins.str backup_id: Resource identifier used to identify the Backup.
        :param builtins.str capacity_pool_resource_id: Pool Resource Id used in case of creating a volume through volume group
        :param builtins.bool cool_access: Specifies whether Cool Access(tiering) is enabled for the volume.
        :param builtins.str cool_access_retrieval_policy: coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are: 
                Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
                OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
                Never - No client-driven data is pulled from cool tier to standard storage.
        :param builtins.str cool_access_tiering_policy: coolAccessTieringPolicy determines which cold data blocks are moved to cool tier. The possible values for this field are: Auto - Moves cold user data blocks in both the Snapshot copies and the active file system to the cool tier tier. This policy is the default. SnapshotOnly - Moves user data blocks of the Volume Snapshot copies that are not associated with the active file system to the cool tier.
        :param builtins.int coolness_period: Specifies the number of days after which data that is not accessed by clients will be tiered.
        :param 'VolumePropertiesResponseDataProtection' data_protection: DataProtection type volumes include an object containing details of the replication
        :param builtins.float default_group_quota_in_ki_bs: Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        :param builtins.float default_user_quota_in_ki_bs: Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        :param builtins.bool delete_base_snapshot: If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false
        :param builtins.str enable_subvolumes: Flag indicating whether subvolume operations are enabled on the volume
        :param builtins.str encryption_key_source: Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        :param 'VolumePropertiesResponseExportPolicy' export_policy: Set of export policy rules
        :param builtins.bool is_default_quota_enabled: Specifies if default quota is enabled for the volume.
        :param builtins.bool is_large_volume: Specifies whether volume is a Large Volume or Regular Volume.
        :param builtins.bool is_restoring: Restoring
        :param builtins.bool kerberos_enabled: Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        :param builtins.str key_vault_private_endpoint_resource_id: The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'.
        :param builtins.bool ldap_enabled: Specifies whether LDAP is enabled or not for a given NFS volume.
        :param builtins.str name: Resource name
        :param builtins.str network_features: The original value of the network features type available to the volume at the time it was created.
        :param Sequence['PlacementKeyValuePairsResponse'] placement_rules: Application specific placement rules for the particular volume
        :param Sequence[builtins.str] protocol_types: Set of protocol types, default NFSv3, CIFS for SMB protocol
        :param builtins.str proximity_placement_group: Proximity placement group associated with the volume
        :param builtins.str security_style: The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        :param builtins.str service_level: The service level of the file system
        :param builtins.str smb_access_based_enumeration: Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        :param builtins.bool smb_continuously_available: Enables continuously available share property for smb volume. Only applicable for SMB volume
        :param builtins.bool smb_encryption: Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later
        :param builtins.str smb_non_browsable: Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        :param builtins.bool snapshot_directory_visible: If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true).
        :param builtins.str snapshot_id: Resource identifier used to identify the Snapshot.
        :param Mapping[str, builtins.str] tags: Resource tags
        :param builtins.str unix_permissions: UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users.
        :param builtins.str volume_spec_name: Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log
        :param builtins.str volume_type: What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection
        :param Sequence[builtins.str] zones: Availability Zone
        """
        pulumi.set(__self__, "actual_throughput_mibps", actual_throughput_mibps)
        pulumi.set(__self__, "baremetal_tenant_id", baremetal_tenant_id)
        pulumi.set(__self__, "clone_progress", clone_progress)
        pulumi.set(__self__, "creation_token", creation_token)
        pulumi.set(__self__, "data_store_resource_id", data_store_resource_id)
        pulumi.set(__self__, "effective_network_features", effective_network_features)
        pulumi.set(__self__, "encrypted", encrypted)
        if file_access_logs is None:
            file_access_logs = 'Disabled'
        pulumi.set(__self__, "file_access_logs", file_access_logs)
        pulumi.set(__self__, "file_system_id", file_system_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "maximum_number_of_files", maximum_number_of_files)
        pulumi.set(__self__, "mount_targets", mount_targets)
        pulumi.set(__self__, "network_sibling_set_id", network_sibling_set_id)
        pulumi.set(__self__, "originating_resource_id", originating_resource_id)
        pulumi.set(__self__, "provisioned_availability_zone", provisioned_availability_zone)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "storage_to_network_proximity", storage_to_network_proximity)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "t2_network", t2_network)
        pulumi.set(__self__, "type", type)
        if usage_threshold is None:
            usage_threshold = 107374182400
        pulumi.set(__self__, "usage_threshold", usage_threshold)
        pulumi.set(__self__, "volume_group_name", volume_group_name)
        if avs_data_store is None:
            avs_data_store = 'Disabled'
        if avs_data_store is not None:
            pulumi.set(__self__, "avs_data_store", avs_data_store)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if capacity_pool_resource_id is not None:
            pulumi.set(__self__, "capacity_pool_resource_id", capacity_pool_resource_id)
        if cool_access is None:
            cool_access = False
        if cool_access is not None:
            pulumi.set(__self__, "cool_access", cool_access)
        if cool_access_retrieval_policy is not None:
            pulumi.set(__self__, "cool_access_retrieval_policy", cool_access_retrieval_policy)
        if cool_access_tiering_policy is not None:
            pulumi.set(__self__, "cool_access_tiering_policy", cool_access_tiering_policy)
        if coolness_period is not None:
            pulumi.set(__self__, "coolness_period", coolness_period)
        if data_protection is not None:
            pulumi.set(__self__, "data_protection", data_protection)
        if default_group_quota_in_ki_bs is None:
            default_group_quota_in_ki_bs = 0
        if default_group_quota_in_ki_bs is not None:
            pulumi.set(__self__, "default_group_quota_in_ki_bs", default_group_quota_in_ki_bs)
        if default_user_quota_in_ki_bs is None:
            default_user_quota_in_ki_bs = 0
        if default_user_quota_in_ki_bs is not None:
            pulumi.set(__self__, "default_user_quota_in_ki_bs", default_user_quota_in_ki_bs)
        if delete_base_snapshot is not None:
            pulumi.set(__self__, "delete_base_snapshot", delete_base_snapshot)
        if enable_subvolumes is None:
            enable_subvolumes = 'Disabled'
        if enable_subvolumes is not None:
            pulumi.set(__self__, "enable_subvolumes", enable_subvolumes)
        if encryption_key_source is None:
            encryption_key_source = 'Microsoft.NetApp'
        if encryption_key_source is not None:
            pulumi.set(__self__, "encryption_key_source", encryption_key_source)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if is_default_quota_enabled is None:
            is_default_quota_enabled = False
        if is_default_quota_enabled is not None:
            pulumi.set(__self__, "is_default_quota_enabled", is_default_quota_enabled)
        if is_large_volume is None:
            is_large_volume = False
        if is_large_volume is not None:
            pulumi.set(__self__, "is_large_volume", is_large_volume)
        if is_restoring is not None:
            pulumi.set(__self__, "is_restoring", is_restoring)
        if kerberos_enabled is None:
            kerberos_enabled = False
        if kerberos_enabled is not None:
            pulumi.set(__self__, "kerberos_enabled", kerberos_enabled)
        if key_vault_private_endpoint_resource_id is not None:
            pulumi.set(__self__, "key_vault_private_endpoint_resource_id", key_vault_private_endpoint_resource_id)
        if ldap_enabled is None:
            ldap_enabled = False
        if ldap_enabled is not None:
            pulumi.set(__self__, "ldap_enabled", ldap_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_features is not None:
            pulumi.set(__self__, "network_features", network_features)
        if placement_rules is not None:
            pulumi.set(__self__, "placement_rules", placement_rules)
        if protocol_types is not None:
            pulumi.set(__self__, "protocol_types", protocol_types)
        if proximity_placement_group is not None:
            pulumi.set(__self__, "proximity_placement_group", proximity_placement_group)
        if security_style is None:
            security_style = 'unix'
        if security_style is not None:
            pulumi.set(__self__, "security_style", security_style)
        if service_level is not None:
            pulumi.set(__self__, "service_level", service_level)
        if smb_access_based_enumeration is not None:
            pulumi.set(__self__, "smb_access_based_enumeration", smb_access_based_enumeration)
        if smb_continuously_available is None:
            smb_continuously_available = False
        if smb_continuously_available is not None:
            pulumi.set(__self__, "smb_continuously_available", smb_continuously_available)
        if smb_encryption is None:
            smb_encryption = False
        if smb_encryption is not None:
            pulumi.set(__self__, "smb_encryption", smb_encryption)
        if smb_non_browsable is not None:
            pulumi.set(__self__, "smb_non_browsable", smb_non_browsable)
        if snapshot_directory_visible is None:
            snapshot_directory_visible = True
        if snapshot_directory_visible is not None:
            pulumi.set(__self__, "snapshot_directory_visible", snapshot_directory_visible)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if throughput_mibps is not None:
            pulumi.set(__self__, "throughput_mibps", throughput_mibps)
        if unix_permissions is not None:
            pulumi.set(__self__, "unix_permissions", unix_permissions)
        if volume_spec_name is not None:
            pulumi.set(__self__, "volume_spec_name", volume_spec_name)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter(name="actualThroughputMibps")
    def actual_throughput_mibps(self) -> builtins.float:
        """
        Actual throughput in MiB/s for auto qosType volumes calculated based on size and serviceLevel
        """
        return pulumi.get(self, "actual_throughput_mibps")

    @property
    @pulumi.getter(name="baremetalTenantId")
    def baremetal_tenant_id(self) -> builtins.str:
        """
        Unique Baremetal Tenant Identifier.
        """
        return pulumi.get(self, "baremetal_tenant_id")

    @property
    @pulumi.getter(name="cloneProgress")
    def clone_progress(self) -> builtins.int:
        """
        When a volume is being restored from another volume's snapshot, will show the percentage completion of this cloning process. When this value is empty/null there is no cloning process currently happening on this volume. This value will update every 5 minutes during cloning.
        """
        return pulumi.get(self, "clone_progress")

    @property
    @pulumi.getter(name="creationToken")
    def creation_token(self) -> builtins.str:
        """
        A unique file path for the volume. Used when creating mount targets
        """
        return pulumi.get(self, "creation_token")

    @property
    @pulumi.getter(name="dataStoreResourceId")
    def data_store_resource_id(self) -> Sequence[builtins.str]:
        """
        Data store resource unique identifier
        """
        return pulumi.get(self, "data_store_resource_id")

    @property
    @pulumi.getter(name="effectiveNetworkFeatures")
    def effective_network_features(self) -> builtins.str:
        """
        The effective value of the network features type available to the volume, or current effective state of update.
        """
        return pulumi.get(self, "effective_network_features")

    @property
    @pulumi.getter
    def encrypted(self) -> builtins.bool:
        """
        Specifies if the volume is encrypted or not. Only available on volumes created or updated after 2022-01-01.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="fileAccessLogs")
    def file_access_logs(self) -> builtins.str:
        """
        Flag indicating whether file access logs are enabled for the volume, based on active diagnostic settings present on the volume.
        """
        return pulumi.get(self, "file_access_logs")

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> builtins.str:
        """
        Unique FileSystem Identifier.
        """
        return pulumi.get(self, "file_system_id")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Resource Id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maximumNumberOfFiles")
    def maximum_number_of_files(self) -> builtins.float:
        """
        Maximum number of files allowed. Needs a service request in order to be changed. Only allowed to be changed if volume quota is more than 4TiB.
        """
        return pulumi.get(self, "maximum_number_of_files")

    @property
    @pulumi.getter(name="mountTargets")
    def mount_targets(self) -> Sequence['outputs.MountTargetPropertiesResponse']:
        """
        List of mount targets
        """
        return pulumi.get(self, "mount_targets")

    @property
    @pulumi.getter(name="networkSiblingSetId")
    def network_sibling_set_id(self) -> builtins.str:
        """
        Network Sibling Set ID for the the group of volumes sharing networking resources.
        """
        return pulumi.get(self, "network_sibling_set_id")

    @property
    @pulumi.getter(name="originatingResourceId")
    def originating_resource_id(self) -> builtins.str:
        """
        Id of the snapshot or backup that the volume is restored from.
        """
        return pulumi.get(self, "originating_resource_id")

    @property
    @pulumi.getter(name="provisionedAvailabilityZone")
    def provisioned_availability_zone(self) -> builtins.str:
        """
        The availability zone where the volume is provisioned. This refers to the logical availability zone where the volume resides.
        """
        return pulumi.get(self, "provisioned_availability_zone")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> builtins.str:
        """
        Azure lifecycle management
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="storageToNetworkProximity")
    def storage_to_network_proximity(self) -> builtins.str:
        """
        Provides storage to network proximity information for the volume.
        """
        return pulumi.get(self, "storage_to_network_proximity")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="t2Network")
    def t2_network(self) -> builtins.str:
        """
        T2 network information
        """
        return pulumi.get(self, "t2_network")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Resource type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="usageThreshold")
    def usage_threshold(self) -> builtins.float:
        """
        Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. For regular volumes, valid values are in the range 50GiB to 100TiB. For large volumes, valid values are in the range 100TiB to 500TiB, and on an exceptional basis, from to 2400GiB to 2400TiB. Values expressed in bytes as multiples of 1 GiB.
        """
        return pulumi.get(self, "usage_threshold")

    @property
    @pulumi.getter(name="volumeGroupName")
    def volume_group_name(self) -> builtins.str:
        """
        Volume Group Name
        """
        return pulumi.get(self, "volume_group_name")

    @property
    @pulumi.getter(name="avsDataStore")
    def avs_data_store(self) -> Optional[builtins.str]:
        """
        Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        """
        return pulumi.get(self, "avs_data_store")

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[builtins.str]:
        """
        Resource identifier used to identify the Backup.
        """
        return pulumi.get(self, "backup_id")

    @property
    @pulumi.getter(name="capacityPoolResourceId")
    def capacity_pool_resource_id(self) -> Optional[builtins.str]:
        """
        Pool Resource Id used in case of creating a volume through volume group
        """
        return pulumi.get(self, "capacity_pool_resource_id")

    @property
    @pulumi.getter(name="coolAccess")
    def cool_access(self) -> Optional[builtins.bool]:
        """
        Specifies whether Cool Access(tiering) is enabled for the volume.
        """
        return pulumi.get(self, "cool_access")

    @property
    @pulumi.getter(name="coolAccessRetrievalPolicy")
    def cool_access_retrieval_policy(self) -> Optional[builtins.str]:
        """
        coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are: 
         Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
         OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
         Never - No client-driven data is pulled from cool tier to standard storage.
        """
        return pulumi.get(self, "cool_access_retrieval_policy")

    @property
    @pulumi.getter(name="coolAccessTieringPolicy")
    def cool_access_tiering_policy(self) -> Optional[builtins.str]:
        """
        coolAccessTieringPolicy determines which cold data blocks are moved to cool tier. The possible values for this field are: Auto - Moves cold user data blocks in both the Snapshot copies and the active file system to the cool tier tier. This policy is the default. SnapshotOnly - Moves user data blocks of the Volume Snapshot copies that are not associated with the active file system to the cool tier.
        """
        return pulumi.get(self, "cool_access_tiering_policy")

    @property
    @pulumi.getter(name="coolnessPeriod")
    def coolness_period(self) -> Optional[builtins.int]:
        """
        Specifies the number of days after which data that is not accessed by clients will be tiered.
        """
        return pulumi.get(self, "coolness_period")

    @property
    @pulumi.getter(name="dataProtection")
    def data_protection(self) -> Optional['outputs.VolumePropertiesResponseDataProtection']:
        """
        DataProtection type volumes include an object containing details of the replication
        """
        return pulumi.get(self, "data_protection")

    @property
    @pulumi.getter(name="defaultGroupQuotaInKiBs")
    def default_group_quota_in_ki_bs(self) -> Optional[builtins.float]:
        """
        Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        """
        return pulumi.get(self, "default_group_quota_in_ki_bs")

    @property
    @pulumi.getter(name="defaultUserQuotaInKiBs")
    def default_user_quota_in_ki_bs(self) -> Optional[builtins.float]:
        """
        Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        """
        return pulumi.get(self, "default_user_quota_in_ki_bs")

    @property
    @pulumi.getter(name="deleteBaseSnapshot")
    def delete_base_snapshot(self) -> Optional[builtins.bool]:
        """
        If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false
        """
        return pulumi.get(self, "delete_base_snapshot")

    @property
    @pulumi.getter(name="enableSubvolumes")
    def enable_subvolumes(self) -> Optional[builtins.str]:
        """
        Flag indicating whether subvolume operations are enabled on the volume
        """
        return pulumi.get(self, "enable_subvolumes")

    @property
    @pulumi.getter(name="encryptionKeySource")
    def encryption_key_source(self) -> Optional[builtins.str]:
        """
        Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        """
        return pulumi.get(self, "encryption_key_source")

    @property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional['outputs.VolumePropertiesResponseExportPolicy']:
        """
        Set of export policy rules
        """
        return pulumi.get(self, "export_policy")

    @property
    @pulumi.getter(name="isDefaultQuotaEnabled")
    def is_default_quota_enabled(self) -> Optional[builtins.bool]:
        """
        Specifies if default quota is enabled for the volume.
        """
        return pulumi.get(self, "is_default_quota_enabled")

    @property
    @pulumi.getter(name="isLargeVolume")
    def is_large_volume(self) -> Optional[builtins.bool]:
        """
        Specifies whether volume is a Large Volume or Regular Volume.
        """
        return pulumi.get(self, "is_large_volume")

    @property
    @pulumi.getter(name="isRestoring")
    def is_restoring(self) -> Optional[builtins.bool]:
        """
        Restoring
        """
        return pulumi.get(self, "is_restoring")

    @property
    @pulumi.getter(name="kerberosEnabled")
    def kerberos_enabled(self) -> Optional[builtins.bool]:
        """
        Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos_enabled")

    @property
    @pulumi.getter(name="keyVaultPrivateEndpointResourceId")
    def key_vault_private_endpoint_resource_id(self) -> Optional[builtins.str]:
        """
        The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "key_vault_private_endpoint_resource_id")

    @property
    @pulumi.getter(name="ldapEnabled")
    def ldap_enabled(self) -> Optional[builtins.bool]:
        """
        Specifies whether LDAP is enabled or not for a given NFS volume.
        """
        return pulumi.get(self, "ldap_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Resource name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkFeatures")
    def network_features(self) -> Optional[builtins.str]:
        """
        The original value of the network features type available to the volume at the time it was created.
        """
        return pulumi.get(self, "network_features")

    @property
    @pulumi.getter(name="placementRules")
    def placement_rules(self) -> Optional[Sequence['outputs.PlacementKeyValuePairsResponse']]:
        """
        Application specific placement rules for the particular volume
        """
        return pulumi.get(self, "placement_rules")

    @property
    @pulumi.getter(name="protocolTypes")
    def protocol_types(self) -> Optional[Sequence[builtins.str]]:
        """
        Set of protocol types, default NFSv3, CIFS for SMB protocol
        """
        return pulumi.get(self, "protocol_types")

    @property
    @pulumi.getter(name="proximityPlacementGroup")
    def proximity_placement_group(self) -> Optional[builtins.str]:
        """
        Proximity placement group associated with the volume
        """
        return pulumi.get(self, "proximity_placement_group")

    @property
    @pulumi.getter(name="securityStyle")
    def security_style(self) -> Optional[builtins.str]:
        """
        The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        """
        return pulumi.get(self, "security_style")

    @property
    @pulumi.getter(name="serviceLevel")
    def service_level(self) -> Optional[builtins.str]:
        """
        The service level of the file system
        """
        return pulumi.get(self, "service_level")

    @property
    @pulumi.getter(name="smbAccessBasedEnumeration")
    def smb_access_based_enumeration(self) -> Optional[builtins.str]:
        """
        Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        """
        return pulumi.get(self, "smb_access_based_enumeration")

    @property
    @pulumi.getter(name="smbContinuouslyAvailable")
    def smb_continuously_available(self) -> Optional[builtins.bool]:
        """
        Enables continuously available share property for smb volume. Only applicable for SMB volume
        """
        return pulumi.get(self, "smb_continuously_available")

    @property
    @pulumi.getter(name="smbEncryption")
    def smb_encryption(self) -> Optional[builtins.bool]:
        """
        Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later
        """
        return pulumi.get(self, "smb_encryption")

    @property
    @pulumi.getter(name="smbNonBrowsable")
    def smb_non_browsable(self) -> Optional[builtins.str]:
        """
        Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        """
        return pulumi.get(self, "smb_non_browsable")

    @property
    @pulumi.getter(name="snapshotDirectoryVisible")
    def snapshot_directory_visible(self) -> Optional[builtins.bool]:
        """
        If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true).
        """
        return pulumi.get(self, "snapshot_directory_visible")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[builtins.str]:
        """
        Resource identifier used to identify the Snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Resource tags
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="throughputMibps")
    def throughput_mibps(self) -> Optional[builtins.float]:
        return pulumi.get(self, "throughput_mibps")

    @property
    @pulumi.getter(name="unixPermissions")
    def unix_permissions(self) -> Optional[builtins.str]:
        """
        UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users.
        """
        return pulumi.get(self, "unix_permissions")

    @property
    @pulumi.getter(name="volumeSpecName")
    def volume_spec_name(self) -> Optional[builtins.str]:
        """
        Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log
        """
        return pulumi.get(self, "volume_spec_name")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[builtins.str]:
        """
        What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection
        """
        return pulumi.get(self, "volume_type")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[builtins.str]]:
        """
        Availability Zone
        """
        return pulumi.get(self, "zones")


@pulumi.output_type
class VolumePropertiesResponseDataProtection(dict):
    """
    DataProtection type volumes include an object containing details of the replication
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeRelocation":
            suggest = "volume_relocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumePropertiesResponseDataProtection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumePropertiesResponseDataProtection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumePropertiesResponseDataProtection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup: Optional['outputs.VolumeBackupPropertiesResponse'] = None,
                 replication: Optional['outputs.ReplicationObjectResponse'] = None,
                 snapshot: Optional['outputs.VolumeSnapshotPropertiesResponse'] = None,
                 volume_relocation: Optional['outputs.VolumeRelocationPropertiesResponse'] = None):
        """
        DataProtection type volumes include an object containing details of the replication
        :param 'VolumeBackupPropertiesResponse' backup: Backup Properties
        :param 'ReplicationObjectResponse' replication: Replication properties
        :param 'VolumeSnapshotPropertiesResponse' snapshot: Snapshot properties.
        :param 'VolumeRelocationPropertiesResponse' volume_relocation: VolumeRelocation properties
        """
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if replication is not None:
            pulumi.set(__self__, "replication", replication)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if volume_relocation is not None:
            pulumi.set(__self__, "volume_relocation", volume_relocation)

    @property
    @pulumi.getter
    def backup(self) -> Optional['outputs.VolumeBackupPropertiesResponse']:
        """
        Backup Properties
        """
        return pulumi.get(self, "backup")

    @property
    @pulumi.getter
    def replication(self) -> Optional['outputs.ReplicationObjectResponse']:
        """
        Replication properties
        """
        return pulumi.get(self, "replication")

    @property
    @pulumi.getter
    def snapshot(self) -> Optional['outputs.VolumeSnapshotPropertiesResponse']:
        """
        Snapshot properties.
        """
        return pulumi.get(self, "snapshot")

    @property
    @pulumi.getter(name="volumeRelocation")
    def volume_relocation(self) -> Optional['outputs.VolumeRelocationPropertiesResponse']:
        """
        VolumeRelocation properties
        """
        return pulumi.get(self, "volume_relocation")


@pulumi.output_type
class VolumePropertiesResponseExportPolicy(dict):
    """
    Set of export policy rules
    """
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.ExportPolicyRuleResponse']] = None):
        """
        Set of export policy rules
        :param Sequence['ExportPolicyRuleResponse'] rules: Export policy rule
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.ExportPolicyRuleResponse']]:
        """
        Export policy rule
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class VolumeRelocationPropertiesResponse(dict):
    """
    Volume relocation properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readyToBeFinalized":
            suggest = "ready_to_be_finalized"
        elif key == "relocationRequested":
            suggest = "relocation_requested"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeRelocationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeRelocationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeRelocationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ready_to_be_finalized: builtins.bool,
                 relocation_requested: Optional[builtins.bool] = None):
        """
        Volume relocation properties
        :param builtins.bool ready_to_be_finalized: Has relocation finished and is ready to be cleaned up
        :param builtins.bool relocation_requested: Has relocation been requested for this volume
        """
        pulumi.set(__self__, "ready_to_be_finalized", ready_to_be_finalized)
        if relocation_requested is not None:
            pulumi.set(__self__, "relocation_requested", relocation_requested)

    @property
    @pulumi.getter(name="readyToBeFinalized")
    def ready_to_be_finalized(self) -> builtins.bool:
        """
        Has relocation finished and is ready to be cleaned up
        """
        return pulumi.get(self, "ready_to_be_finalized")

    @property
    @pulumi.getter(name="relocationRequested")
    def relocation_requested(self) -> Optional[builtins.bool]:
        """
        Has relocation been requested for this volume
        """
        return pulumi.get(self, "relocation_requested")


@pulumi.output_type
class VolumeSnapshotPropertiesResponse(dict):
    """
    Volume Snapshot Properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotPolicyId":
            suggest = "snapshot_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSnapshotPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSnapshotPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSnapshotPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 snapshot_policy_id: Optional[builtins.str] = None):
        """
        Volume Snapshot Properties
        :param builtins.str snapshot_policy_id: Snapshot Policy ResourceId
        """
        if snapshot_policy_id is not None:
            pulumi.set(__self__, "snapshot_policy_id", snapshot_policy_id)

    @property
    @pulumi.getter(name="snapshotPolicyId")
    def snapshot_policy_id(self) -> Optional[builtins.str]:
        """
        Snapshot Policy ResourceId
        """
        return pulumi.get(self, "snapshot_policy_id")


@pulumi.output_type
class WeeklyScheduleResponse(dict):
    """
    Weekly Schedule properties, make a snapshot every week at a specific day or days
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotsToKeep":
            suggest = "snapshots_to_keep"
        elif key == "usedBytes":
            suggest = "used_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WeeklyScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WeeklyScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WeeklyScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day: Optional[builtins.str] = None,
                 hour: Optional[builtins.int] = None,
                 minute: Optional[builtins.int] = None,
                 snapshots_to_keep: Optional[builtins.int] = None,
                 used_bytes: Optional[builtins.float] = None):
        """
        Weekly Schedule properties, make a snapshot every week at a specific day or days
        :param builtins.str day: Indicates which weekdays snapshot should be taken, accepts a comma separated list of week day names in english
        :param builtins.int hour: Indicates which hour in UTC timezone a snapshot should be taken
        :param builtins.int minute: Indicates which minute snapshot should be taken
        :param builtins.int snapshots_to_keep: Weekly snapshot count to keep
        :param builtins.float used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if snapshots_to_keep is not None:
            pulumi.set(__self__, "snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            pulumi.set(__self__, "used_bytes", used_bytes)

    @property
    @pulumi.getter
    def day(self) -> Optional[builtins.str]:
        """
        Indicates which weekdays snapshot should be taken, accepts a comma separated list of week day names in english
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter
    def hour(self) -> Optional[builtins.int]:
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def minute(self) -> Optional[builtins.int]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[builtins.int]:
        """
        Weekly snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[builtins.float]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")


