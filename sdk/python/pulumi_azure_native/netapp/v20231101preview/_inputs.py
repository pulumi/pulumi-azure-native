# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AccountEncryptionArgs',
    'AccountEncryptionArgsDict',
    'ActiveDirectoryArgs',
    'ActiveDirectoryArgsDict',
    'DailyScheduleArgs',
    'DailyScheduleArgsDict',
    'EncryptionIdentityArgs',
    'EncryptionIdentityArgsDict',
    'ExportPolicyRuleArgs',
    'ExportPolicyRuleArgsDict',
    'HourlyScheduleArgs',
    'HourlyScheduleArgsDict',
    'KeyVaultPropertiesArgs',
    'KeyVaultPropertiesArgsDict',
    'LdapSearchScopeOptArgs',
    'LdapSearchScopeOptArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'MonthlyScheduleArgs',
    'MonthlyScheduleArgsDict',
    'PlacementKeyValuePairsArgs',
    'PlacementKeyValuePairsArgsDict',
    'RemotePathArgs',
    'RemotePathArgsDict',
    'ReplicationObjectArgs',
    'ReplicationObjectArgsDict',
    'VolumeBackupPropertiesArgs',
    'VolumeBackupPropertiesArgsDict',
    'VolumeGroupMetaDataArgs',
    'VolumeGroupMetaDataArgsDict',
    'VolumeGroupVolumePropertiesArgs',
    'VolumeGroupVolumePropertiesArgsDict',
    'VolumePropertiesDataProtectionArgs',
    'VolumePropertiesDataProtectionArgsDict',
    'VolumePropertiesExportPolicyArgs',
    'VolumePropertiesExportPolicyArgsDict',
    'VolumeRelocationPropertiesArgs',
    'VolumeRelocationPropertiesArgsDict',
    'VolumeSnapshotPropertiesArgs',
    'VolumeSnapshotPropertiesArgsDict',
    'WeeklyScheduleArgs',
    'WeeklyScheduleArgsDict',
]

MYPY = False

if not MYPY:
    class AccountEncryptionArgsDict(TypedDict):
        """
        Encryption settings
        """
        identity: NotRequired[pulumi.Input['EncryptionIdentityArgsDict']]
        """
        Identity used to authenticate to KeyVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        key_source: NotRequired[pulumi.Input[Union[str, 'KeySource']]]
        """
        The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault
        """
        key_vault_properties: NotRequired[pulumi.Input['KeyVaultPropertiesArgsDict']]
        """
        Properties provided by KeVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
elif False:
    AccountEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountEncryptionArgs:
    def __init__(__self__, *,
                 identity: Optional[pulumi.Input['EncryptionIdentityArgs']] = None,
                 key_source: Optional[pulumi.Input[Union[str, 'KeySource']]] = None,
                 key_vault_properties: Optional[pulumi.Input['KeyVaultPropertiesArgs']] = None):
        """
        Encryption settings
        :param pulumi.Input['EncryptionIdentityArgs'] identity: Identity used to authenticate to KeyVault. Applicable if keySource is 'Microsoft.KeyVault'.
        :param pulumi.Input[Union[str, 'KeySource']] key_source: The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault
        :param pulumi.Input['KeyVaultPropertiesArgs'] key_vault_properties: Properties provided by KeVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if key_source is None:
            key_source = 'Microsoft.NetApp'
        if key_source is not None:
            pulumi.set(__self__, "key_source", key_source)
        if key_vault_properties is not None:
            pulumi.set(__self__, "key_vault_properties", key_vault_properties)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input['EncryptionIdentityArgs']]:
        """
        Identity used to authenticate to KeyVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input['EncryptionIdentityArgs']]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter(name="keySource")
    def key_source(self) -> Optional[pulumi.Input[Union[str, 'KeySource']]]:
        """
        The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault
        """
        return pulumi.get(self, "key_source")

    @key_source.setter
    def key_source(self, value: Optional[pulumi.Input[Union[str, 'KeySource']]]):
        pulumi.set(self, "key_source", value)

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> Optional[pulumi.Input['KeyVaultPropertiesArgs']]:
        """
        Properties provided by KeVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "key_vault_properties")

    @key_vault_properties.setter
    def key_vault_properties(self, value: Optional[pulumi.Input['KeyVaultPropertiesArgs']]):
        pulumi.set(self, "key_vault_properties", value)


if not MYPY:
    class ActiveDirectoryArgsDict(TypedDict):
        """
        Active Directory
        """
        active_directory_id: NotRequired[pulumi.Input[str]]
        """
        Id of the Active Directory
        """
        ad_name: NotRequired[pulumi.Input[str]]
        """
        Name of the active directory machine. This optional parameter is used only while creating kerberos volume
        """
        administrators: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier
        """
        aes_encryption: NotRequired[pulumi.Input[bool]]
        """
        If enabled, AES encryption will be enabled for SMB communication.
        """
        allow_local_nfs_users_with_ldap: NotRequired[pulumi.Input[bool]]
        """
         If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes.
        """
        backup_operators: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier
        """
        dns: NotRequired[pulumi.Input[str]]
        """
        Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain
        """
        domain: NotRequired[pulumi.Input[str]]
        """
        Name of the Active Directory domain
        """
        encrypt_dc_connections: NotRequired[pulumi.Input[bool]]
        """
        If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted.
        """
        kdc_ip: NotRequired[pulumi.Input[str]]
        """
        kdc server IP addresses for the active directory machine. This optional parameter is used only while creating kerberos volume.
        """
        ldap_over_tls: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether or not the LDAP traffic needs to be secured via TLS.
        """
        ldap_search_scope: NotRequired[pulumi.Input['LdapSearchScopeOptArgsDict']]
        """
        LDAP Search scope options
        """
        ldap_signing: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether or not the LDAP traffic needs to be signed.
        """
        organizational_unit: NotRequired[pulumi.Input[str]]
        """
        The Organizational Unit (OU) within the Windows Active Directory
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Plain text password of Active Directory domain administrator, value is masked in the response
        """
        preferred_servers_for_ldap_client: NotRequired[pulumi.Input[str]]
        """
        Comma separated list of IPv4 addresses of preferred servers for LDAP client. At most two comma separated IPv4 addresses can be passed.
        """
        security_operators: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier
        """
        server_root_ca_certificate: NotRequired[pulumi.Input[str]]
        """
        When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes.
        """
        site: NotRequired[pulumi.Input[str]]
        """
        The Active Directory site the service will limit Domain Controller discovery to
        """
        smb_server_name: NotRequired[pulumi.Input[str]]
        """
        NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
        """
        username: NotRequired[pulumi.Input[str]]
        """
        A domain user account with permission to create machine accounts
        """
elif False:
    ActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActiveDirectoryArgs:
    def __init__(__self__, *,
                 active_directory_id: Optional[pulumi.Input[str]] = None,
                 ad_name: Optional[pulumi.Input[str]] = None,
                 administrators: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 aes_encryption: Optional[pulumi.Input[bool]] = None,
                 allow_local_nfs_users_with_ldap: Optional[pulumi.Input[bool]] = None,
                 backup_operators: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dns: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 encrypt_dc_connections: Optional[pulumi.Input[bool]] = None,
                 kdc_ip: Optional[pulumi.Input[str]] = None,
                 ldap_over_tls: Optional[pulumi.Input[bool]] = None,
                 ldap_search_scope: Optional[pulumi.Input['LdapSearchScopeOptArgs']] = None,
                 ldap_signing: Optional[pulumi.Input[bool]] = None,
                 organizational_unit: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 preferred_servers_for_ldap_client: Optional[pulumi.Input[str]] = None,
                 security_operators: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 server_root_ca_certificate: Optional[pulumi.Input[str]] = None,
                 site: Optional[pulumi.Input[str]] = None,
                 smb_server_name: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Active Directory
        :param pulumi.Input[str] active_directory_id: Id of the Active Directory
        :param pulumi.Input[str] ad_name: Name of the active directory machine. This optional parameter is used only while creating kerberos volume
        :param pulumi.Input[Sequence[pulumi.Input[str]]] administrators: Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier
        :param pulumi.Input[bool] aes_encryption: If enabled, AES encryption will be enabled for SMB communication.
        :param pulumi.Input[bool] allow_local_nfs_users_with_ldap:  If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] backup_operators: Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier
        :param pulumi.Input[str] dns: Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain
        :param pulumi.Input[str] domain: Name of the Active Directory domain
        :param pulumi.Input[bool] encrypt_dc_connections: If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted.
        :param pulumi.Input[str] kdc_ip: kdc server IP addresses for the active directory machine. This optional parameter is used only while creating kerberos volume.
        :param pulumi.Input[bool] ldap_over_tls: Specifies whether or not the LDAP traffic needs to be secured via TLS.
        :param pulumi.Input['LdapSearchScopeOptArgs'] ldap_search_scope: LDAP Search scope options
        :param pulumi.Input[bool] ldap_signing: Specifies whether or not the LDAP traffic needs to be signed.
        :param pulumi.Input[str] organizational_unit: The Organizational Unit (OU) within the Windows Active Directory
        :param pulumi.Input[str] password: Plain text password of Active Directory domain administrator, value is masked in the response
        :param pulumi.Input[str] preferred_servers_for_ldap_client: Comma separated list of IPv4 addresses of preferred servers for LDAP client. At most two comma separated IPv4 addresses can be passed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_operators: Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier
        :param pulumi.Input[str] server_root_ca_certificate: When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes.
        :param pulumi.Input[str] site: The Active Directory site the service will limit Domain Controller discovery to
        :param pulumi.Input[str] smb_server_name: NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
        :param pulumi.Input[str] username: A domain user account with permission to create machine accounts
        """
        if active_directory_id is not None:
            pulumi.set(__self__, "active_directory_id", active_directory_id)
        if ad_name is not None:
            pulumi.set(__self__, "ad_name", ad_name)
        if administrators is not None:
            pulumi.set(__self__, "administrators", administrators)
        if aes_encryption is not None:
            pulumi.set(__self__, "aes_encryption", aes_encryption)
        if allow_local_nfs_users_with_ldap is not None:
            pulumi.set(__self__, "allow_local_nfs_users_with_ldap", allow_local_nfs_users_with_ldap)
        if backup_operators is not None:
            pulumi.set(__self__, "backup_operators", backup_operators)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if encrypt_dc_connections is not None:
            pulumi.set(__self__, "encrypt_dc_connections", encrypt_dc_connections)
        if kdc_ip is not None:
            pulumi.set(__self__, "kdc_ip", kdc_ip)
        if ldap_over_tls is not None:
            pulumi.set(__self__, "ldap_over_tls", ldap_over_tls)
        if ldap_search_scope is not None:
            pulumi.set(__self__, "ldap_search_scope", ldap_search_scope)
        if ldap_signing is not None:
            pulumi.set(__self__, "ldap_signing", ldap_signing)
        if organizational_unit is None:
            organizational_unit = 'CN=Computers'
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if preferred_servers_for_ldap_client is not None:
            pulumi.set(__self__, "preferred_servers_for_ldap_client", preferred_servers_for_ldap_client)
        if security_operators is not None:
            pulumi.set(__self__, "security_operators", security_operators)
        if server_root_ca_certificate is not None:
            pulumi.set(__self__, "server_root_ca_certificate", server_root_ca_certificate)
        if site is not None:
            pulumi.set(__self__, "site", site)
        if smb_server_name is not None:
            pulumi.set(__self__, "smb_server_name", smb_server_name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="activeDirectoryId")
    def active_directory_id(self) -> Optional[pulumi.Input[str]]:
        """
        Id of the Active Directory
        """
        return pulumi.get(self, "active_directory_id")

    @active_directory_id.setter
    def active_directory_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "active_directory_id", value)

    @property
    @pulumi.getter(name="adName")
    def ad_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the active directory machine. This optional parameter is used only while creating kerberos volume
        """
        return pulumi.get(self, "ad_name")

    @ad_name.setter
    def ad_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ad_name", value)

    @property
    @pulumi.getter
    def administrators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "administrators")

    @administrators.setter
    def administrators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "administrators", value)

    @property
    @pulumi.getter(name="aesEncryption")
    def aes_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, AES encryption will be enabled for SMB communication.
        """
        return pulumi.get(self, "aes_encryption")

    @aes_encryption.setter
    def aes_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "aes_encryption", value)

    @property
    @pulumi.getter(name="allowLocalNfsUsersWithLdap")
    def allow_local_nfs_users_with_ldap(self) -> Optional[pulumi.Input[bool]]:
        """
         If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes.
        """
        return pulumi.get(self, "allow_local_nfs_users_with_ldap")

    @allow_local_nfs_users_with_ldap.setter
    def allow_local_nfs_users_with_ldap(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_local_nfs_users_with_ldap", value)

    @property
    @pulumi.getter(name="backupOperators")
    def backup_operators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "backup_operators")

    @backup_operators.setter
    def backup_operators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "backup_operators", value)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[str]]:
        """
        Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Active Directory domain
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="encryptDCConnections")
    def encrypt_dc_connections(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted.
        """
        return pulumi.get(self, "encrypt_dc_connections")

    @encrypt_dc_connections.setter
    def encrypt_dc_connections(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypt_dc_connections", value)

    @property
    @pulumi.getter(name="kdcIP")
    def kdc_ip(self) -> Optional[pulumi.Input[str]]:
        """
        kdc server IP addresses for the active directory machine. This optional parameter is used only while creating kerberos volume.
        """
        return pulumi.get(self, "kdc_ip")

    @kdc_ip.setter
    def kdc_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kdc_ip", value)

    @property
    @pulumi.getter(name="ldapOverTLS")
    def ldap_over_tls(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether or not the LDAP traffic needs to be secured via TLS.
        """
        return pulumi.get(self, "ldap_over_tls")

    @ldap_over_tls.setter
    def ldap_over_tls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ldap_over_tls", value)

    @property
    @pulumi.getter(name="ldapSearchScope")
    def ldap_search_scope(self) -> Optional[pulumi.Input['LdapSearchScopeOptArgs']]:
        """
        LDAP Search scope options
        """
        return pulumi.get(self, "ldap_search_scope")

    @ldap_search_scope.setter
    def ldap_search_scope(self, value: Optional[pulumi.Input['LdapSearchScopeOptArgs']]):
        pulumi.set(self, "ldap_search_scope", value)

    @property
    @pulumi.getter(name="ldapSigning")
    def ldap_signing(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether or not the LDAP traffic needs to be signed.
        """
        return pulumi.get(self, "ldap_signing")

    @ldap_signing.setter
    def ldap_signing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ldap_signing", value)

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The Organizational Unit (OU) within the Windows Active Directory
        """
        return pulumi.get(self, "organizational_unit")

    @organizational_unit.setter
    def organizational_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organizational_unit", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Plain text password of Active Directory domain administrator, value is masked in the response
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="preferredServersForLdapClient")
    def preferred_servers_for_ldap_client(self) -> Optional[pulumi.Input[str]]:
        """
        Comma separated list of IPv4 addresses of preferred servers for LDAP client. At most two comma separated IPv4 addresses can be passed.
        """
        return pulumi.get(self, "preferred_servers_for_ldap_client")

    @preferred_servers_for_ldap_client.setter
    def preferred_servers_for_ldap_client(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preferred_servers_for_ldap_client", value)

    @property
    @pulumi.getter(name="securityOperators")
    def security_operators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "security_operators")

    @security_operators.setter
    def security_operators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_operators", value)

    @property
    @pulumi.getter(name="serverRootCACertificate")
    def server_root_ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes.
        """
        return pulumi.get(self, "server_root_ca_certificate")

    @server_root_ca_certificate.setter
    def server_root_ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_root_ca_certificate", value)

    @property
    @pulumi.getter
    def site(self) -> Optional[pulumi.Input[str]]:
        """
        The Active Directory site the service will limit Domain Controller discovery to
        """
        return pulumi.get(self, "site")

    @site.setter
    def site(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "site", value)

    @property
    @pulumi.getter(name="smbServerName")
    def smb_server_name(self) -> Optional[pulumi.Input[str]]:
        """
        NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
        """
        return pulumi.get(self, "smb_server_name")

    @smb_server_name.setter
    def smb_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "smb_server_name", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A domain user account with permission to create machine accounts
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class DailyScheduleArgsDict(TypedDict):
        """
        Daily Schedule properties
        """
        hour: NotRequired[pulumi.Input[int]]
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        minute: NotRequired[pulumi.Input[int]]
        """
        Indicates which minute snapshot should be taken
        """
        snapshots_to_keep: NotRequired[pulumi.Input[int]]
        """
        Daily snapshot count to keep
        """
        used_bytes: NotRequired[pulumi.Input[float]]
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
elif False:
    DailyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DailyScheduleArgs:
    def __init__(__self__, *,
                 hour: Optional[pulumi.Input[int]] = None,
                 minute: Optional[pulumi.Input[int]] = None,
                 snapshots_to_keep: Optional[pulumi.Input[int]] = None,
                 used_bytes: Optional[pulumi.Input[float]] = None):
        """
        Daily Schedule properties
        :param pulumi.Input[int] hour: Indicates which hour in UTC timezone a snapshot should be taken
        :param pulumi.Input[int] minute: Indicates which minute snapshot should be taken
        :param pulumi.Input[int] snapshots_to_keep: Daily snapshot count to keep
        :param pulumi.Input[float] used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if snapshots_to_keep is not None:
            pulumi.set(__self__, "snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            pulumi.set(__self__, "used_bytes", used_bytes)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)

    @property
    @pulumi.getter
    def minute(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @minute.setter
    def minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minute", value)

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[pulumi.Input[int]]:
        """
        Daily snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @snapshots_to_keep.setter
    def snapshots_to_keep(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshots_to_keep", value)

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[pulumi.Input[float]]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")

    @used_bytes.setter
    def used_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "used_bytes", value)


if not MYPY:
    class EncryptionIdentityArgsDict(TypedDict):
        """
        Identity used to authenticate with key vault.
        """
        user_assigned_identity: NotRequired[pulumi.Input[str]]
        """
        The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities.
        """
elif False:
    EncryptionIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionIdentityArgs:
    def __init__(__self__, *,
                 user_assigned_identity: Optional[pulumi.Input[str]] = None):
        """
        Identity used to authenticate with key vault.
        :param pulumi.Input[str] user_assigned_identity: The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities.
        """
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[pulumi.Input[str]]:
        """
        The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities.
        """
        return pulumi.get(self, "user_assigned_identity")

    @user_assigned_identity.setter
    def user_assigned_identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_assigned_identity", value)


if not MYPY:
    class ExportPolicyRuleArgsDict(TypedDict):
        """
        Volume Export Policy Rule
        """
        allowed_clients: NotRequired[pulumi.Input[str]]
        """
        Client ingress specification as comma separated string with IPv4 CIDRs, IPv4 host addresses and host names
        """
        chown_mode: NotRequired[pulumi.Input[Union[str, 'ChownMode']]]
        """
        This parameter specifies who is authorized to change the ownership of a file. restricted - Only root user can change the ownership of the file. unrestricted - Non-root users can change ownership of files that they own.
        """
        cifs: NotRequired[pulumi.Input[bool]]
        """
        Allows CIFS protocol
        """
        has_root_access: NotRequired[pulumi.Input[bool]]
        """
        Has root access to volume
        """
        kerberos5_read_only: NotRequired[pulumi.Input[bool]]
        """
        Kerberos5 Read only access. To be use with swagger version 2020-05-01 or later
        """
        kerberos5_read_write: NotRequired[pulumi.Input[bool]]
        """
        Kerberos5 Read and write access. To be use with swagger version 2020-05-01 or later
        """
        kerberos5i_read_only: NotRequired[pulumi.Input[bool]]
        """
        Kerberos5i Read only access. To be use with swagger version 2020-05-01 or later
        """
        kerberos5i_read_write: NotRequired[pulumi.Input[bool]]
        """
        Kerberos5i Read and write access. To be use with swagger version 2020-05-01 or later
        """
        kerberos5p_read_only: NotRequired[pulumi.Input[bool]]
        """
        Kerberos5p Read only access. To be use with swagger version 2020-05-01 or later
        """
        kerberos5p_read_write: NotRequired[pulumi.Input[bool]]
        """
        Kerberos5p Read and write access. To be use with swagger version 2020-05-01 or later
        """
        nfsv3: NotRequired[pulumi.Input[bool]]
        """
        Allows NFSv3 protocol. Enable only for NFSv3 type volumes
        """
        nfsv41: NotRequired[pulumi.Input[bool]]
        """
        Allows NFSv4.1 protocol. Enable only for NFSv4.1 type volumes
        """
        rule_index: NotRequired[pulumi.Input[int]]
        """
        Order index
        """
        unix_read_only: NotRequired[pulumi.Input[bool]]
        """
        Read only access
        """
        unix_read_write: NotRequired[pulumi.Input[bool]]
        """
        Read and write access
        """
elif False:
    ExportPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExportPolicyRuleArgs:
    def __init__(__self__, *,
                 allowed_clients: Optional[pulumi.Input[str]] = None,
                 chown_mode: Optional[pulumi.Input[Union[str, 'ChownMode']]] = None,
                 cifs: Optional[pulumi.Input[bool]] = None,
                 has_root_access: Optional[pulumi.Input[bool]] = None,
                 kerberos5_read_only: Optional[pulumi.Input[bool]] = None,
                 kerberos5_read_write: Optional[pulumi.Input[bool]] = None,
                 kerberos5i_read_only: Optional[pulumi.Input[bool]] = None,
                 kerberos5i_read_write: Optional[pulumi.Input[bool]] = None,
                 kerberos5p_read_only: Optional[pulumi.Input[bool]] = None,
                 kerberos5p_read_write: Optional[pulumi.Input[bool]] = None,
                 nfsv3: Optional[pulumi.Input[bool]] = None,
                 nfsv41: Optional[pulumi.Input[bool]] = None,
                 rule_index: Optional[pulumi.Input[int]] = None,
                 unix_read_only: Optional[pulumi.Input[bool]] = None,
                 unix_read_write: Optional[pulumi.Input[bool]] = None):
        """
        Volume Export Policy Rule
        :param pulumi.Input[str] allowed_clients: Client ingress specification as comma separated string with IPv4 CIDRs, IPv4 host addresses and host names
        :param pulumi.Input[Union[str, 'ChownMode']] chown_mode: This parameter specifies who is authorized to change the ownership of a file. restricted - Only root user can change the ownership of the file. unrestricted - Non-root users can change ownership of files that they own.
        :param pulumi.Input[bool] cifs: Allows CIFS protocol
        :param pulumi.Input[bool] has_root_access: Has root access to volume
        :param pulumi.Input[bool] kerberos5_read_only: Kerberos5 Read only access. To be use with swagger version 2020-05-01 or later
        :param pulumi.Input[bool] kerberos5_read_write: Kerberos5 Read and write access. To be use with swagger version 2020-05-01 or later
        :param pulumi.Input[bool] kerberos5i_read_only: Kerberos5i Read only access. To be use with swagger version 2020-05-01 or later
        :param pulumi.Input[bool] kerberos5i_read_write: Kerberos5i Read and write access. To be use with swagger version 2020-05-01 or later
        :param pulumi.Input[bool] kerberos5p_read_only: Kerberos5p Read only access. To be use with swagger version 2020-05-01 or later
        :param pulumi.Input[bool] kerberos5p_read_write: Kerberos5p Read and write access. To be use with swagger version 2020-05-01 or later
        :param pulumi.Input[bool] nfsv3: Allows NFSv3 protocol. Enable only for NFSv3 type volumes
        :param pulumi.Input[bool] nfsv41: Allows NFSv4.1 protocol. Enable only for NFSv4.1 type volumes
        :param pulumi.Input[int] rule_index: Order index
        :param pulumi.Input[bool] unix_read_only: Read only access
        :param pulumi.Input[bool] unix_read_write: Read and write access
        """
        if allowed_clients is not None:
            pulumi.set(__self__, "allowed_clients", allowed_clients)
        if chown_mode is None:
            chown_mode = 'Restricted'
        if chown_mode is not None:
            pulumi.set(__self__, "chown_mode", chown_mode)
        if cifs is not None:
            pulumi.set(__self__, "cifs", cifs)
        if has_root_access is None:
            has_root_access = True
        if has_root_access is not None:
            pulumi.set(__self__, "has_root_access", has_root_access)
        if kerberos5_read_only is None:
            kerberos5_read_only = False
        if kerberos5_read_only is not None:
            pulumi.set(__self__, "kerberos5_read_only", kerberos5_read_only)
        if kerberos5_read_write is None:
            kerberos5_read_write = False
        if kerberos5_read_write is not None:
            pulumi.set(__self__, "kerberos5_read_write", kerberos5_read_write)
        if kerberos5i_read_only is None:
            kerberos5i_read_only = False
        if kerberos5i_read_only is not None:
            pulumi.set(__self__, "kerberos5i_read_only", kerberos5i_read_only)
        if kerberos5i_read_write is None:
            kerberos5i_read_write = False
        if kerberos5i_read_write is not None:
            pulumi.set(__self__, "kerberos5i_read_write", kerberos5i_read_write)
        if kerberos5p_read_only is None:
            kerberos5p_read_only = False
        if kerberos5p_read_only is not None:
            pulumi.set(__self__, "kerberos5p_read_only", kerberos5p_read_only)
        if kerberos5p_read_write is None:
            kerberos5p_read_write = False
        if kerberos5p_read_write is not None:
            pulumi.set(__self__, "kerberos5p_read_write", kerberos5p_read_write)
        if nfsv3 is not None:
            pulumi.set(__self__, "nfsv3", nfsv3)
        if nfsv41 is not None:
            pulumi.set(__self__, "nfsv41", nfsv41)
        if rule_index is not None:
            pulumi.set(__self__, "rule_index", rule_index)
        if unix_read_only is not None:
            pulumi.set(__self__, "unix_read_only", unix_read_only)
        if unix_read_write is not None:
            pulumi.set(__self__, "unix_read_write", unix_read_write)

    @property
    @pulumi.getter(name="allowedClients")
    def allowed_clients(self) -> Optional[pulumi.Input[str]]:
        """
        Client ingress specification as comma separated string with IPv4 CIDRs, IPv4 host addresses and host names
        """
        return pulumi.get(self, "allowed_clients")

    @allowed_clients.setter
    def allowed_clients(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allowed_clients", value)

    @property
    @pulumi.getter(name="chownMode")
    def chown_mode(self) -> Optional[pulumi.Input[Union[str, 'ChownMode']]]:
        """
        This parameter specifies who is authorized to change the ownership of a file. restricted - Only root user can change the ownership of the file. unrestricted - Non-root users can change ownership of files that they own.
        """
        return pulumi.get(self, "chown_mode")

    @chown_mode.setter
    def chown_mode(self, value: Optional[pulumi.Input[Union[str, 'ChownMode']]]):
        pulumi.set(self, "chown_mode", value)

    @property
    @pulumi.getter
    def cifs(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows CIFS protocol
        """
        return pulumi.get(self, "cifs")

    @cifs.setter
    def cifs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cifs", value)

    @property
    @pulumi.getter(name="hasRootAccess")
    def has_root_access(self) -> Optional[pulumi.Input[bool]]:
        """
        Has root access to volume
        """
        return pulumi.get(self, "has_root_access")

    @has_root_access.setter
    def has_root_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_root_access", value)

    @property
    @pulumi.getter(name="kerberos5ReadOnly")
    def kerberos5_read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Kerberos5 Read only access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5_read_only")

    @kerberos5_read_only.setter
    def kerberos5_read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "kerberos5_read_only", value)

    @property
    @pulumi.getter(name="kerberos5ReadWrite")
    def kerberos5_read_write(self) -> Optional[pulumi.Input[bool]]:
        """
        Kerberos5 Read and write access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5_read_write")

    @kerberos5_read_write.setter
    def kerberos5_read_write(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "kerberos5_read_write", value)

    @property
    @pulumi.getter(name="kerberos5iReadOnly")
    def kerberos5i_read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Kerberos5i Read only access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5i_read_only")

    @kerberos5i_read_only.setter
    def kerberos5i_read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "kerberos5i_read_only", value)

    @property
    @pulumi.getter(name="kerberos5iReadWrite")
    def kerberos5i_read_write(self) -> Optional[pulumi.Input[bool]]:
        """
        Kerberos5i Read and write access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5i_read_write")

    @kerberos5i_read_write.setter
    def kerberos5i_read_write(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "kerberos5i_read_write", value)

    @property
    @pulumi.getter(name="kerberos5pReadOnly")
    def kerberos5p_read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Kerberos5p Read only access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5p_read_only")

    @kerberos5p_read_only.setter
    def kerberos5p_read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "kerberos5p_read_only", value)

    @property
    @pulumi.getter(name="kerberos5pReadWrite")
    def kerberos5p_read_write(self) -> Optional[pulumi.Input[bool]]:
        """
        Kerberos5p Read and write access. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos5p_read_write")

    @kerberos5p_read_write.setter
    def kerberos5p_read_write(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "kerberos5p_read_write", value)

    @property
    @pulumi.getter
    def nfsv3(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows NFSv3 protocol. Enable only for NFSv3 type volumes
        """
        return pulumi.get(self, "nfsv3")

    @nfsv3.setter
    def nfsv3(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nfsv3", value)

    @property
    @pulumi.getter
    def nfsv41(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows NFSv4.1 protocol. Enable only for NFSv4.1 type volumes
        """
        return pulumi.get(self, "nfsv41")

    @nfsv41.setter
    def nfsv41(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nfsv41", value)

    @property
    @pulumi.getter(name="ruleIndex")
    def rule_index(self) -> Optional[pulumi.Input[int]]:
        """
        Order index
        """
        return pulumi.get(self, "rule_index")

    @rule_index.setter
    def rule_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rule_index", value)

    @property
    @pulumi.getter(name="unixReadOnly")
    def unix_read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Read only access
        """
        return pulumi.get(self, "unix_read_only")

    @unix_read_only.setter
    def unix_read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unix_read_only", value)

    @property
    @pulumi.getter(name="unixReadWrite")
    def unix_read_write(self) -> Optional[pulumi.Input[bool]]:
        """
        Read and write access
        """
        return pulumi.get(self, "unix_read_write")

    @unix_read_write.setter
    def unix_read_write(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unix_read_write", value)


if not MYPY:
    class HourlyScheduleArgsDict(TypedDict):
        """
        Hourly Schedule properties
        """
        minute: NotRequired[pulumi.Input[int]]
        """
        Indicates which minute snapshot should be taken
        """
        snapshots_to_keep: NotRequired[pulumi.Input[int]]
        """
        Hourly snapshot count to keep
        """
        used_bytes: NotRequired[pulumi.Input[float]]
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
elif False:
    HourlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HourlyScheduleArgs:
    def __init__(__self__, *,
                 minute: Optional[pulumi.Input[int]] = None,
                 snapshots_to_keep: Optional[pulumi.Input[int]] = None,
                 used_bytes: Optional[pulumi.Input[float]] = None):
        """
        Hourly Schedule properties
        :param pulumi.Input[int] minute: Indicates which minute snapshot should be taken
        :param pulumi.Input[int] snapshots_to_keep: Hourly snapshot count to keep
        :param pulumi.Input[float] used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if snapshots_to_keep is not None:
            pulumi.set(__self__, "snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            pulumi.set(__self__, "used_bytes", used_bytes)

    @property
    @pulumi.getter
    def minute(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @minute.setter
    def minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minute", value)

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[pulumi.Input[int]]:
        """
        Hourly snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @snapshots_to_keep.setter
    def snapshots_to_keep(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshots_to_keep", value)

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[pulumi.Input[float]]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")

    @used_bytes.setter
    def used_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "used_bytes", value)


if not MYPY:
    class KeyVaultPropertiesArgsDict(TypedDict):
        """
        Properties of key vault.
        """
        key_name: pulumi.Input[str]
        """
        The name of KeyVault key.
        """
        key_vault_resource_id: pulumi.Input[str]
        """
        The resource ID of KeyVault.
        """
        key_vault_uri: pulumi.Input[str]
        """
        The Uri of KeyVault.
        """
elif False:
    KeyVaultPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyVaultPropertiesArgs:
    def __init__(__self__, *,
                 key_name: pulumi.Input[str],
                 key_vault_resource_id: pulumi.Input[str],
                 key_vault_uri: pulumi.Input[str]):
        """
        Properties of key vault.
        :param pulumi.Input[str] key_name: The name of KeyVault key.
        :param pulumi.Input[str] key_vault_resource_id: The resource ID of KeyVault.
        :param pulumi.Input[str] key_vault_uri: The Uri of KeyVault.
        """
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "key_vault_resource_id", key_vault_resource_id)
        pulumi.set(__self__, "key_vault_uri", key_vault_uri)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> pulumi.Input[str]:
        """
        The name of KeyVault key.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_name", value)

    @property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> pulumi.Input[str]:
        """
        The resource ID of KeyVault.
        """
        return pulumi.get(self, "key_vault_resource_id")

    @key_vault_resource_id.setter
    def key_vault_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_resource_id", value)

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> pulumi.Input[str]:
        """
        The Uri of KeyVault.
        """
        return pulumi.get(self, "key_vault_uri")

    @key_vault_uri.setter
    def key_vault_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_uri", value)


if not MYPY:
    class LdapSearchScopeOptArgsDict(TypedDict):
        """
        LDAP search scope 
        """
        group_dn: NotRequired[pulumi.Input[str]]
        """
        This specifies the group DN, which overrides the base DN for group lookups.
        """
        group_membership_filter: NotRequired[pulumi.Input[str]]
        """
        This specifies the custom LDAP search filter to be used when looking up group membership from LDAP server.
        """
        user_dn: NotRequired[pulumi.Input[str]]
        """
        This specifies the user DN, which overrides the base DN for user lookups.
        """
elif False:
    LdapSearchScopeOptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LdapSearchScopeOptArgs:
    def __init__(__self__, *,
                 group_dn: Optional[pulumi.Input[str]] = None,
                 group_membership_filter: Optional[pulumi.Input[str]] = None,
                 user_dn: Optional[pulumi.Input[str]] = None):
        """
        LDAP search scope 
        :param pulumi.Input[str] group_dn: This specifies the group DN, which overrides the base DN for group lookups.
        :param pulumi.Input[str] group_membership_filter: This specifies the custom LDAP search filter to be used when looking up group membership from LDAP server.
        :param pulumi.Input[str] user_dn: This specifies the user DN, which overrides the base DN for user lookups.
        """
        if group_dn is not None:
            pulumi.set(__self__, "group_dn", group_dn)
        if group_membership_filter is not None:
            pulumi.set(__self__, "group_membership_filter", group_membership_filter)
        if user_dn is not None:
            pulumi.set(__self__, "user_dn", user_dn)

    @property
    @pulumi.getter(name="groupDN")
    def group_dn(self) -> Optional[pulumi.Input[str]]:
        """
        This specifies the group DN, which overrides the base DN for group lookups.
        """
        return pulumi.get(self, "group_dn")

    @group_dn.setter
    def group_dn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_dn", value)

    @property
    @pulumi.getter(name="groupMembershipFilter")
    def group_membership_filter(self) -> Optional[pulumi.Input[str]]:
        """
        This specifies the custom LDAP search filter to be used when looking up group membership from LDAP server.
        """
        return pulumi.get(self, "group_membership_filter")

    @group_membership_filter.setter
    def group_membership_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_membership_filter", value)

    @property
    @pulumi.getter(name="userDN")
    def user_dn(self) -> Optional[pulumi.Input[str]]:
        """
        This specifies the user DN, which overrides the base DN for user lookups.
        """
        return pulumi.get(self, "user_dn")

    @user_dn.setter
    def user_dn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_dn", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class MonthlyScheduleArgsDict(TypedDict):
        """
        Monthly Schedule properties
        """
        days_of_month: NotRequired[pulumi.Input[str]]
        """
        Indicates which days of the month snapshot should be taken. A comma delimited string.
        """
        hour: NotRequired[pulumi.Input[int]]
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        minute: NotRequired[pulumi.Input[int]]
        """
        Indicates which minute snapshot should be taken
        """
        snapshots_to_keep: NotRequired[pulumi.Input[int]]
        """
        Monthly snapshot count to keep
        """
        used_bytes: NotRequired[pulumi.Input[float]]
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
elif False:
    MonthlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonthlyScheduleArgs:
    def __init__(__self__, *,
                 days_of_month: Optional[pulumi.Input[str]] = None,
                 hour: Optional[pulumi.Input[int]] = None,
                 minute: Optional[pulumi.Input[int]] = None,
                 snapshots_to_keep: Optional[pulumi.Input[int]] = None,
                 used_bytes: Optional[pulumi.Input[float]] = None):
        """
        Monthly Schedule properties
        :param pulumi.Input[str] days_of_month: Indicates which days of the month snapshot should be taken. A comma delimited string.
        :param pulumi.Input[int] hour: Indicates which hour in UTC timezone a snapshot should be taken
        :param pulumi.Input[int] minute: Indicates which minute snapshot should be taken
        :param pulumi.Input[int] snapshots_to_keep: Monthly snapshot count to keep
        :param pulumi.Input[float] used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        if days_of_month is not None:
            pulumi.set(__self__, "days_of_month", days_of_month)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if snapshots_to_keep is not None:
            pulumi.set(__self__, "snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            pulumi.set(__self__, "used_bytes", used_bytes)

    @property
    @pulumi.getter(name="daysOfMonth")
    def days_of_month(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates which days of the month snapshot should be taken. A comma delimited string.
        """
        return pulumi.get(self, "days_of_month")

    @days_of_month.setter
    def days_of_month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "days_of_month", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)

    @property
    @pulumi.getter
    def minute(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @minute.setter
    def minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minute", value)

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[pulumi.Input[int]]:
        """
        Monthly snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @snapshots_to_keep.setter
    def snapshots_to_keep(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshots_to_keep", value)

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[pulumi.Input[float]]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")

    @used_bytes.setter
    def used_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "used_bytes", value)


if not MYPY:
    class PlacementKeyValuePairsArgsDict(TypedDict):
        """
        Application specific parameters for the placement of volumes in the volume group
        """
        key: pulumi.Input[str]
        """
        Key for an application specific parameter for the placement of volumes in the volume group
        """
        value: pulumi.Input[str]
        """
        Value for an application specific parameter for the placement of volumes in the volume group
        """
elif False:
    PlacementKeyValuePairsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlacementKeyValuePairsArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        Application specific parameters for the placement of volumes in the volume group
        :param pulumi.Input[str] key: Key for an application specific parameter for the placement of volumes in the volume group
        :param pulumi.Input[str] value: Value for an application specific parameter for the placement of volumes in the volume group
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key for an application specific parameter for the placement of volumes in the volume group
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value for an application specific parameter for the placement of volumes in the volume group
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RemotePathArgsDict(TypedDict):
        """
        The full path to a volume that is to be migrated into ANF. Required for Migration volumes
        """
        external_host_name: pulumi.Input[str]
        """
        The Path to a ONTAP Host
        """
        server_name: pulumi.Input[str]
        """
        The name of a server on the ONTAP Host
        """
        volume_name: pulumi.Input[str]
        """
        The name of a volume on the server
        """
elif False:
    RemotePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RemotePathArgs:
    def __init__(__self__, *,
                 external_host_name: pulumi.Input[str],
                 server_name: pulumi.Input[str],
                 volume_name: pulumi.Input[str]):
        """
        The full path to a volume that is to be migrated into ANF. Required for Migration volumes
        :param pulumi.Input[str] external_host_name: The Path to a ONTAP Host
        :param pulumi.Input[str] server_name: The name of a server on the ONTAP Host
        :param pulumi.Input[str] volume_name: The name of a volume on the server
        """
        pulumi.set(__self__, "external_host_name", external_host_name)
        pulumi.set(__self__, "server_name", server_name)
        pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="externalHostName")
    def external_host_name(self) -> pulumi.Input[str]:
        """
        The Path to a ONTAP Host
        """
        return pulumi.get(self, "external_host_name")

    @external_host_name.setter
    def external_host_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "external_host_name", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> pulumi.Input[str]:
        """
        The name of a server on the ONTAP Host
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_name", value)

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> pulumi.Input[str]:
        """
        The name of a volume on the server
        """
        return pulumi.get(self, "volume_name")

    @volume_name.setter
    def volume_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume_name", value)


if not MYPY:
    class ReplicationObjectArgsDict(TypedDict):
        """
        Replication properties
        """
        remote_volume_resource_id: pulumi.Input[str]
        """
        The resource ID of the remote volume. Required for cross region and cross zone replication
        """
        endpoint_type: NotRequired[pulumi.Input[Union[str, 'EndpointType']]]
        """
        Indicates whether the local volume is the source or destination for the Volume Replication
        """
        remote_path: NotRequired[pulumi.Input['RemotePathArgsDict']]
        """
        The full path to a volume that is to be migrated into ANF. Required for Migration volumes
        """
        remote_volume_region: NotRequired[pulumi.Input[str]]
        """
        The remote region for the other end of the Volume Replication.
        """
        replication_schedule: NotRequired[pulumi.Input[Union[str, 'ReplicationSchedule']]]
        """
        Schedule
        """
elif False:
    ReplicationObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReplicationObjectArgs:
    def __init__(__self__, *,
                 remote_volume_resource_id: pulumi.Input[str],
                 endpoint_type: Optional[pulumi.Input[Union[str, 'EndpointType']]] = None,
                 remote_path: Optional[pulumi.Input['RemotePathArgs']] = None,
                 remote_volume_region: Optional[pulumi.Input[str]] = None,
                 replication_schedule: Optional[pulumi.Input[Union[str, 'ReplicationSchedule']]] = None):
        """
        Replication properties
        :param pulumi.Input[str] remote_volume_resource_id: The resource ID of the remote volume. Required for cross region and cross zone replication
        :param pulumi.Input[Union[str, 'EndpointType']] endpoint_type: Indicates whether the local volume is the source or destination for the Volume Replication
        :param pulumi.Input['RemotePathArgs'] remote_path: The full path to a volume that is to be migrated into ANF. Required for Migration volumes
        :param pulumi.Input[str] remote_volume_region: The remote region for the other end of the Volume Replication.
        :param pulumi.Input[Union[str, 'ReplicationSchedule']] replication_schedule: Schedule
        """
        pulumi.set(__self__, "remote_volume_resource_id", remote_volume_resource_id)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if remote_path is not None:
            pulumi.set(__self__, "remote_path", remote_path)
        if remote_volume_region is not None:
            pulumi.set(__self__, "remote_volume_region", remote_volume_region)
        if replication_schedule is not None:
            pulumi.set(__self__, "replication_schedule", replication_schedule)

    @property
    @pulumi.getter(name="remoteVolumeResourceId")
    def remote_volume_resource_id(self) -> pulumi.Input[str]:
        """
        The resource ID of the remote volume. Required for cross region and cross zone replication
        """
        return pulumi.get(self, "remote_volume_resource_id")

    @remote_volume_resource_id.setter
    def remote_volume_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "remote_volume_resource_id", value)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[pulumi.Input[Union[str, 'EndpointType']]]:
        """
        Indicates whether the local volume is the source or destination for the Volume Replication
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: Optional[pulumi.Input[Union[str, 'EndpointType']]]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="remotePath")
    def remote_path(self) -> Optional[pulumi.Input['RemotePathArgs']]:
        """
        The full path to a volume that is to be migrated into ANF. Required for Migration volumes
        """
        return pulumi.get(self, "remote_path")

    @remote_path.setter
    def remote_path(self, value: Optional[pulumi.Input['RemotePathArgs']]):
        pulumi.set(self, "remote_path", value)

    @property
    @pulumi.getter(name="remoteVolumeRegion")
    def remote_volume_region(self) -> Optional[pulumi.Input[str]]:
        """
        The remote region for the other end of the Volume Replication.
        """
        return pulumi.get(self, "remote_volume_region")

    @remote_volume_region.setter
    def remote_volume_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_volume_region", value)

    @property
    @pulumi.getter(name="replicationSchedule")
    def replication_schedule(self) -> Optional[pulumi.Input[Union[str, 'ReplicationSchedule']]]:
        """
        Schedule
        """
        return pulumi.get(self, "replication_schedule")

    @replication_schedule.setter
    def replication_schedule(self, value: Optional[pulumi.Input[Union[str, 'ReplicationSchedule']]]):
        pulumi.set(self, "replication_schedule", value)


if not MYPY:
    class VolumeBackupPropertiesArgsDict(TypedDict):
        """
        Volume Backup Properties
        """
        backup_policy_id: NotRequired[pulumi.Input[str]]
        """
        Backup Policy Resource ID
        """
        backup_vault_id: NotRequired[pulumi.Input[str]]
        """
        Backup Vault Resource ID
        """
        policy_enforced: NotRequired[pulumi.Input[bool]]
        """
        Policy Enforced
        """
elif False:
    VolumeBackupPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeBackupPropertiesArgs:
    def __init__(__self__, *,
                 backup_policy_id: Optional[pulumi.Input[str]] = None,
                 backup_vault_id: Optional[pulumi.Input[str]] = None,
                 policy_enforced: Optional[pulumi.Input[bool]] = None):
        """
        Volume Backup Properties
        :param pulumi.Input[str] backup_policy_id: Backup Policy Resource ID
        :param pulumi.Input[str] backup_vault_id: Backup Vault Resource ID
        :param pulumi.Input[bool] policy_enforced: Policy Enforced
        """
        if backup_policy_id is not None:
            pulumi.set(__self__, "backup_policy_id", backup_policy_id)
        if backup_vault_id is not None:
            pulumi.set(__self__, "backup_vault_id", backup_vault_id)
        if policy_enforced is not None:
            pulumi.set(__self__, "policy_enforced", policy_enforced)

    @property
    @pulumi.getter(name="backupPolicyId")
    def backup_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        Backup Policy Resource ID
        """
        return pulumi.get(self, "backup_policy_id")

    @backup_policy_id.setter
    def backup_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_policy_id", value)

    @property
    @pulumi.getter(name="backupVaultId")
    def backup_vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        Backup Vault Resource ID
        """
        return pulumi.get(self, "backup_vault_id")

    @backup_vault_id.setter
    def backup_vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_vault_id", value)

    @property
    @pulumi.getter(name="policyEnforced")
    def policy_enforced(self) -> Optional[pulumi.Input[bool]]:
        """
        Policy Enforced
        """
        return pulumi.get(self, "policy_enforced")

    @policy_enforced.setter
    def policy_enforced(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "policy_enforced", value)


if not MYPY:
    class VolumeGroupMetaDataArgsDict(TypedDict):
        """
        Volume group properties
        """
        application_identifier: NotRequired[pulumi.Input[str]]
        """
        Application specific identifier
        """
        application_type: NotRequired[pulumi.Input[Union[str, 'ApplicationType']]]
        """
        Application Type
        """
        global_placement_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlacementKeyValuePairsArgsDict']]]]
        """
        Application specific placement rules for the volume group
        """
        group_description: NotRequired[pulumi.Input[str]]
        """
        Group Description
        """
elif False:
    VolumeGroupMetaDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupMetaDataArgs:
    def __init__(__self__, *,
                 application_identifier: Optional[pulumi.Input[str]] = None,
                 application_type: Optional[pulumi.Input[Union[str, 'ApplicationType']]] = None,
                 global_placement_rules: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementKeyValuePairsArgs']]]] = None,
                 group_description: Optional[pulumi.Input[str]] = None):
        """
        Volume group properties
        :param pulumi.Input[str] application_identifier: Application specific identifier
        :param pulumi.Input[Union[str, 'ApplicationType']] application_type: Application Type
        :param pulumi.Input[Sequence[pulumi.Input['PlacementKeyValuePairsArgs']]] global_placement_rules: Application specific placement rules for the volume group
        :param pulumi.Input[str] group_description: Group Description
        """
        if application_identifier is not None:
            pulumi.set(__self__, "application_identifier", application_identifier)
        if application_type is not None:
            pulumi.set(__self__, "application_type", application_type)
        if global_placement_rules is not None:
            pulumi.set(__self__, "global_placement_rules", global_placement_rules)
        if group_description is not None:
            pulumi.set(__self__, "group_description", group_description)

    @property
    @pulumi.getter(name="applicationIdentifier")
    def application_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        Application specific identifier
        """
        return pulumi.get(self, "application_identifier")

    @application_identifier.setter
    def application_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_identifier", value)

    @property
    @pulumi.getter(name="applicationType")
    def application_type(self) -> Optional[pulumi.Input[Union[str, 'ApplicationType']]]:
        """
        Application Type
        """
        return pulumi.get(self, "application_type")

    @application_type.setter
    def application_type(self, value: Optional[pulumi.Input[Union[str, 'ApplicationType']]]):
        pulumi.set(self, "application_type", value)

    @property
    @pulumi.getter(name="globalPlacementRules")
    def global_placement_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlacementKeyValuePairsArgs']]]]:
        """
        Application specific placement rules for the volume group
        """
        return pulumi.get(self, "global_placement_rules")

    @global_placement_rules.setter
    def global_placement_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementKeyValuePairsArgs']]]]):
        pulumi.set(self, "global_placement_rules", value)

    @property
    @pulumi.getter(name="groupDescription")
    def group_description(self) -> Optional[pulumi.Input[str]]:
        """
        Group Description
        """
        return pulumi.get(self, "group_description")

    @group_description.setter
    def group_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_description", value)


if not MYPY:
    class VolumeGroupVolumePropertiesArgsDict(TypedDict):
        """
        Volume resource
        """
        creation_token: pulumi.Input[str]
        """
        A unique file path for the volume. Used when creating mount targets
        """
        subnet_id: pulumi.Input[str]
        """
        The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        """
        usage_threshold: pulumi.Input[float]
        """
        Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes.
        """
        accept_grow_capacity_pool_for_short_term_clone_split: NotRequired[pulumi.Input[Union[str, 'AcceptGrowCapacityPoolForShortTermCloneSplit']]]
        """
        While auto splitting the short term clone volume, if the parent pool does not have enough space to accommodate the volume after split, it will be automatically resized, which will lead to increased billing. To accept capacity pool size auto grow and create a short term clone volume, set the property as accepted.
        """
        avs_data_store: NotRequired[pulumi.Input[Union[str, 'AvsDataStore']]]
        """
        Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        """
        backup_id: NotRequired[pulumi.Input[str]]
        """
        Resource identifier used to identify the Backup.
        """
        capacity_pool_resource_id: NotRequired[pulumi.Input[str]]
        """
        Pool Resource Id used in case of creating a volume through volume group
        """
        cool_access: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether Cool Access(tiering) is enabled for the volume.
        """
        cool_access_retrieval_policy: NotRequired[pulumi.Input[Union[str, 'CoolAccessRetrievalPolicy']]]
        """
        coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are: 
         Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
         OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
         Never - No client-driven data is pulled from cool tier to standard storage.
        """
        coolness_period: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of days after which data that is not accessed by clients will be tiered.
        """
        data_protection: NotRequired[pulumi.Input['VolumePropertiesDataProtectionArgsDict']]
        """
        DataProtection type volumes include an object containing details of the replication
        """
        default_group_quota_in_ki_bs: NotRequired[pulumi.Input[float]]
        """
        Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        """
        default_user_quota_in_ki_bs: NotRequired[pulumi.Input[float]]
        """
        Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        """
        delete_base_snapshot: NotRequired[pulumi.Input[bool]]
        """
        If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false
        """
        enable_subvolumes: NotRequired[pulumi.Input[Union[str, 'EnableSubvolumes']]]
        """
        Flag indicating whether subvolume operations are enabled on the volume
        """
        encryption_key_source: NotRequired[pulumi.Input[Union[str, 'EncryptionKeySource']]]
        """
        Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        """
        export_policy: NotRequired[pulumi.Input['VolumePropertiesExportPolicyArgsDict']]
        """
        Set of export policy rules
        """
        is_default_quota_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies if default quota is enabled for the volume.
        """
        is_large_volume: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether volume is a Large Volume or Regular Volume.
        """
        is_restoring: NotRequired[pulumi.Input[bool]]
        """
        Restoring
        """
        kerberos_enabled: NotRequired[pulumi.Input[bool]]
        """
        Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        """
        key_vault_private_endpoint_resource_id: NotRequired[pulumi.Input[str]]
        """
        The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'.
        """
        language: NotRequired[pulumi.Input[Union[str, 'VolumeLanguage']]]
        """
        Language supported for volume.
        """
        ldap_enabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether LDAP is enabled or not for a given NFS volume.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Resource name
        """
        network_features: NotRequired[pulumi.Input[Union[str, 'NetworkFeatures']]]
        """
        Network features available to the volume, or current state of update.
        """
        placement_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['PlacementKeyValuePairsArgsDict']]]]
        """
        Application specific placement rules for the particular volume
        """
        protocol_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of protocol types, default NFSv3, CIFS for SMB protocol
        """
        proximity_placement_group: NotRequired[pulumi.Input[str]]
        """
        Proximity placement group associated with the volume
        """
        security_style: NotRequired[pulumi.Input[Union[str, 'SecurityStyle']]]
        """
        The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        """
        service_level: NotRequired[pulumi.Input[Union[str, 'ServiceLevel']]]
        """
        The service level of the file system
        """
        smb_access_based_enumeration: NotRequired[pulumi.Input[Union[str, 'SmbAccessBasedEnumeration']]]
        """
        Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        """
        smb_continuously_available: NotRequired[pulumi.Input[bool]]
        """
        Enables continuously available share property for smb volume. Only applicable for SMB volume
        """
        smb_encryption: NotRequired[pulumi.Input[bool]]
        """
        Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later
        """
        smb_non_browsable: NotRequired[pulumi.Input[Union[str, 'SmbNonBrowsable']]]
        """
        Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        """
        snapshot_directory_visible: NotRequired[pulumi.Input[bool]]
        """
        If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true).
        """
        snapshot_id: NotRequired[pulumi.Input[str]]
        """
        Resource identifier used to identify the Snapshot.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Resource tags
        """
        throughput_mibps: NotRequired[pulumi.Input[float]]
        unix_permissions: NotRequired[pulumi.Input[str]]
        """
        UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users.
        """
        volume_spec_name: NotRequired[pulumi.Input[str]]
        """
        Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log
        """
        volume_type: NotRequired[pulumi.Input[str]]
        """
        What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection. For creating clone volume, set type to ShortTermClone
        """
        zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Availability Zone
        """
elif False:
    VolumeGroupVolumePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupVolumePropertiesArgs:
    def __init__(__self__, *,
                 creation_token: pulumi.Input[str],
                 subnet_id: pulumi.Input[str],
                 usage_threshold: Optional[pulumi.Input[float]] = None,
                 accept_grow_capacity_pool_for_short_term_clone_split: Optional[pulumi.Input[Union[str, 'AcceptGrowCapacityPoolForShortTermCloneSplit']]] = None,
                 avs_data_store: Optional[pulumi.Input[Union[str, 'AvsDataStore']]] = None,
                 backup_id: Optional[pulumi.Input[str]] = None,
                 capacity_pool_resource_id: Optional[pulumi.Input[str]] = None,
                 cool_access: Optional[pulumi.Input[bool]] = None,
                 cool_access_retrieval_policy: Optional[pulumi.Input[Union[str, 'CoolAccessRetrievalPolicy']]] = None,
                 coolness_period: Optional[pulumi.Input[int]] = None,
                 data_protection: Optional[pulumi.Input['VolumePropertiesDataProtectionArgs']] = None,
                 default_group_quota_in_ki_bs: Optional[pulumi.Input[float]] = None,
                 default_user_quota_in_ki_bs: Optional[pulumi.Input[float]] = None,
                 delete_base_snapshot: Optional[pulumi.Input[bool]] = None,
                 enable_subvolumes: Optional[pulumi.Input[Union[str, 'EnableSubvolumes']]] = None,
                 encryption_key_source: Optional[pulumi.Input[Union[str, 'EncryptionKeySource']]] = None,
                 export_policy: Optional[pulumi.Input['VolumePropertiesExportPolicyArgs']] = None,
                 is_default_quota_enabled: Optional[pulumi.Input[bool]] = None,
                 is_large_volume: Optional[pulumi.Input[bool]] = None,
                 is_restoring: Optional[pulumi.Input[bool]] = None,
                 kerberos_enabled: Optional[pulumi.Input[bool]] = None,
                 key_vault_private_endpoint_resource_id: Optional[pulumi.Input[str]] = None,
                 language: Optional[pulumi.Input[Union[str, 'VolumeLanguage']]] = None,
                 ldap_enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network_features: Optional[pulumi.Input[Union[str, 'NetworkFeatures']]] = None,
                 placement_rules: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementKeyValuePairsArgs']]]] = None,
                 protocol_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 proximity_placement_group: Optional[pulumi.Input[str]] = None,
                 security_style: Optional[pulumi.Input[Union[str, 'SecurityStyle']]] = None,
                 service_level: Optional[pulumi.Input[Union[str, 'ServiceLevel']]] = None,
                 smb_access_based_enumeration: Optional[pulumi.Input[Union[str, 'SmbAccessBasedEnumeration']]] = None,
                 smb_continuously_available: Optional[pulumi.Input[bool]] = None,
                 smb_encryption: Optional[pulumi.Input[bool]] = None,
                 smb_non_browsable: Optional[pulumi.Input[Union[str, 'SmbNonBrowsable']]] = None,
                 snapshot_directory_visible: Optional[pulumi.Input[bool]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 throughput_mibps: Optional[pulumi.Input[float]] = None,
                 unix_permissions: Optional[pulumi.Input[str]] = None,
                 volume_spec_name: Optional[pulumi.Input[str]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Volume resource
        :param pulumi.Input[str] creation_token: A unique file path for the volume. Used when creating mount targets
        :param pulumi.Input[str] subnet_id: The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        :param pulumi.Input[float] usage_threshold: Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes.
        :param pulumi.Input[Union[str, 'AcceptGrowCapacityPoolForShortTermCloneSplit']] accept_grow_capacity_pool_for_short_term_clone_split: While auto splitting the short term clone volume, if the parent pool does not have enough space to accommodate the volume after split, it will be automatically resized, which will lead to increased billing. To accept capacity pool size auto grow and create a short term clone volume, set the property as accepted.
        :param pulumi.Input[Union[str, 'AvsDataStore']] avs_data_store: Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        :param pulumi.Input[str] backup_id: Resource identifier used to identify the Backup.
        :param pulumi.Input[str] capacity_pool_resource_id: Pool Resource Id used in case of creating a volume through volume group
        :param pulumi.Input[bool] cool_access: Specifies whether Cool Access(tiering) is enabled for the volume.
        :param pulumi.Input[Union[str, 'CoolAccessRetrievalPolicy']] cool_access_retrieval_policy: coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are: 
                Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
                OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
                Never - No client-driven data is pulled from cool tier to standard storage.
        :param pulumi.Input[int] coolness_period: Specifies the number of days after which data that is not accessed by clients will be tiered.
        :param pulumi.Input['VolumePropertiesDataProtectionArgs'] data_protection: DataProtection type volumes include an object containing details of the replication
        :param pulumi.Input[float] default_group_quota_in_ki_bs: Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        :param pulumi.Input[float] default_user_quota_in_ki_bs: Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        :param pulumi.Input[bool] delete_base_snapshot: If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false
        :param pulumi.Input[Union[str, 'EnableSubvolumes']] enable_subvolumes: Flag indicating whether subvolume operations are enabled on the volume
        :param pulumi.Input[Union[str, 'EncryptionKeySource']] encryption_key_source: Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        :param pulumi.Input['VolumePropertiesExportPolicyArgs'] export_policy: Set of export policy rules
        :param pulumi.Input[bool] is_default_quota_enabled: Specifies if default quota is enabled for the volume.
        :param pulumi.Input[bool] is_large_volume: Specifies whether volume is a Large Volume or Regular Volume.
        :param pulumi.Input[bool] is_restoring: Restoring
        :param pulumi.Input[bool] kerberos_enabled: Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        :param pulumi.Input[str] key_vault_private_endpoint_resource_id: The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'.
        :param pulumi.Input[Union[str, 'VolumeLanguage']] language: Language supported for volume.
        :param pulumi.Input[bool] ldap_enabled: Specifies whether LDAP is enabled or not for a given NFS volume.
        :param pulumi.Input[str] name: Resource name
        :param pulumi.Input[Union[str, 'NetworkFeatures']] network_features: Network features available to the volume, or current state of update.
        :param pulumi.Input[Sequence[pulumi.Input['PlacementKeyValuePairsArgs']]] placement_rules: Application specific placement rules for the particular volume
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocol_types: Set of protocol types, default NFSv3, CIFS for SMB protocol
        :param pulumi.Input[str] proximity_placement_group: Proximity placement group associated with the volume
        :param pulumi.Input[Union[str, 'SecurityStyle']] security_style: The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        :param pulumi.Input[Union[str, 'ServiceLevel']] service_level: The service level of the file system
        :param pulumi.Input[Union[str, 'SmbAccessBasedEnumeration']] smb_access_based_enumeration: Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        :param pulumi.Input[bool] smb_continuously_available: Enables continuously available share property for smb volume. Only applicable for SMB volume
        :param pulumi.Input[bool] smb_encryption: Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later
        :param pulumi.Input[Union[str, 'SmbNonBrowsable']] smb_non_browsable: Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        :param pulumi.Input[bool] snapshot_directory_visible: If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true).
        :param pulumi.Input[str] snapshot_id: Resource identifier used to identify the Snapshot.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Resource tags
        :param pulumi.Input[str] unix_permissions: UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users.
        :param pulumi.Input[str] volume_spec_name: Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log
        :param pulumi.Input[str] volume_type: What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection. For creating clone volume, set type to ShortTermClone
        :param pulumi.Input[Sequence[pulumi.Input[str]]] zones: Availability Zone
        """
        pulumi.set(__self__, "creation_token", creation_token)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if usage_threshold is None:
            usage_threshold = 107374182400
        pulumi.set(__self__, "usage_threshold", usage_threshold)
        if accept_grow_capacity_pool_for_short_term_clone_split is not None:
            pulumi.set(__self__, "accept_grow_capacity_pool_for_short_term_clone_split", accept_grow_capacity_pool_for_short_term_clone_split)
        if avs_data_store is None:
            avs_data_store = 'Disabled'
        if avs_data_store is not None:
            pulumi.set(__self__, "avs_data_store", avs_data_store)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if capacity_pool_resource_id is not None:
            pulumi.set(__self__, "capacity_pool_resource_id", capacity_pool_resource_id)
        if cool_access is None:
            cool_access = False
        if cool_access is not None:
            pulumi.set(__self__, "cool_access", cool_access)
        if cool_access_retrieval_policy is not None:
            pulumi.set(__self__, "cool_access_retrieval_policy", cool_access_retrieval_policy)
        if coolness_period is not None:
            pulumi.set(__self__, "coolness_period", coolness_period)
        if data_protection is not None:
            pulumi.set(__self__, "data_protection", data_protection)
        if default_group_quota_in_ki_bs is None:
            default_group_quota_in_ki_bs = 0
        if default_group_quota_in_ki_bs is not None:
            pulumi.set(__self__, "default_group_quota_in_ki_bs", default_group_quota_in_ki_bs)
        if default_user_quota_in_ki_bs is None:
            default_user_quota_in_ki_bs = 0
        if default_user_quota_in_ki_bs is not None:
            pulumi.set(__self__, "default_user_quota_in_ki_bs", default_user_quota_in_ki_bs)
        if delete_base_snapshot is not None:
            pulumi.set(__self__, "delete_base_snapshot", delete_base_snapshot)
        if enable_subvolumes is None:
            enable_subvolumes = 'Disabled'
        if enable_subvolumes is not None:
            pulumi.set(__self__, "enable_subvolumes", enable_subvolumes)
        if encryption_key_source is None:
            encryption_key_source = 'Microsoft.NetApp'
        if encryption_key_source is not None:
            pulumi.set(__self__, "encryption_key_source", encryption_key_source)
        if export_policy is not None:
            pulumi.set(__self__, "export_policy", export_policy)
        if is_default_quota_enabled is None:
            is_default_quota_enabled = False
        if is_default_quota_enabled is not None:
            pulumi.set(__self__, "is_default_quota_enabled", is_default_quota_enabled)
        if is_large_volume is None:
            is_large_volume = False
        if is_large_volume is not None:
            pulumi.set(__self__, "is_large_volume", is_large_volume)
        if is_restoring is not None:
            pulumi.set(__self__, "is_restoring", is_restoring)
        if kerberos_enabled is None:
            kerberos_enabled = False
        if kerberos_enabled is not None:
            pulumi.set(__self__, "kerberos_enabled", kerberos_enabled)
        if key_vault_private_endpoint_resource_id is not None:
            pulumi.set(__self__, "key_vault_private_endpoint_resource_id", key_vault_private_endpoint_resource_id)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if ldap_enabled is None:
            ldap_enabled = False
        if ldap_enabled is not None:
            pulumi.set(__self__, "ldap_enabled", ldap_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_features is not None:
            pulumi.set(__self__, "network_features", network_features)
        if placement_rules is not None:
            pulumi.set(__self__, "placement_rules", placement_rules)
        if protocol_types is not None:
            pulumi.set(__self__, "protocol_types", protocol_types)
        if proximity_placement_group is not None:
            pulumi.set(__self__, "proximity_placement_group", proximity_placement_group)
        if security_style is None:
            security_style = 'unix'
        if security_style is not None:
            pulumi.set(__self__, "security_style", security_style)
        if service_level is not None:
            pulumi.set(__self__, "service_level", service_level)
        if smb_access_based_enumeration is not None:
            pulumi.set(__self__, "smb_access_based_enumeration", smb_access_based_enumeration)
        if smb_continuously_available is None:
            smb_continuously_available = False
        if smb_continuously_available is not None:
            pulumi.set(__self__, "smb_continuously_available", smb_continuously_available)
        if smb_encryption is None:
            smb_encryption = False
        if smb_encryption is not None:
            pulumi.set(__self__, "smb_encryption", smb_encryption)
        if smb_non_browsable is not None:
            pulumi.set(__self__, "smb_non_browsable", smb_non_browsable)
        if snapshot_directory_visible is None:
            snapshot_directory_visible = True
        if snapshot_directory_visible is not None:
            pulumi.set(__self__, "snapshot_directory_visible", snapshot_directory_visible)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if throughput_mibps is not None:
            pulumi.set(__self__, "throughput_mibps", throughput_mibps)
        if unix_permissions is not None:
            pulumi.set(__self__, "unix_permissions", unix_permissions)
        if volume_spec_name is not None:
            pulumi.set(__self__, "volume_spec_name", volume_spec_name)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @property
    @pulumi.getter(name="creationToken")
    def creation_token(self) -> pulumi.Input[str]:
        """
        A unique file path for the volume. Used when creating mount targets
        """
        return pulumi.get(self, "creation_token")

    @creation_token.setter
    def creation_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "creation_token", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The Azure Resource URI for a delegated subnet. Must have the delegation Microsoft.NetApp/volumes
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="usageThreshold")
    def usage_threshold(self) -> pulumi.Input[float]:
        """
        Maximum storage quota allowed for a file system in bytes. This is a soft quota used for alerting only. Minimum size is 100 GiB. Upper limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional basis. Specified in bytes.
        """
        return pulumi.get(self, "usage_threshold")

    @usage_threshold.setter
    def usage_threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "usage_threshold", value)

    @property
    @pulumi.getter(name="acceptGrowCapacityPoolForShortTermCloneSplit")
    def accept_grow_capacity_pool_for_short_term_clone_split(self) -> Optional[pulumi.Input[Union[str, 'AcceptGrowCapacityPoolForShortTermCloneSplit']]]:
        """
        While auto splitting the short term clone volume, if the parent pool does not have enough space to accommodate the volume after split, it will be automatically resized, which will lead to increased billing. To accept capacity pool size auto grow and create a short term clone volume, set the property as accepted.
        """
        return pulumi.get(self, "accept_grow_capacity_pool_for_short_term_clone_split")

    @accept_grow_capacity_pool_for_short_term_clone_split.setter
    def accept_grow_capacity_pool_for_short_term_clone_split(self, value: Optional[pulumi.Input[Union[str, 'AcceptGrowCapacityPoolForShortTermCloneSplit']]]):
        pulumi.set(self, "accept_grow_capacity_pool_for_short_term_clone_split", value)

    @property
    @pulumi.getter(name="avsDataStore")
    def avs_data_store(self) -> Optional[pulumi.Input[Union[str, 'AvsDataStore']]]:
        """
        Specifies whether the volume is enabled for Azure VMware Solution (AVS) datastore purpose
        """
        return pulumi.get(self, "avs_data_store")

    @avs_data_store.setter
    def avs_data_store(self, value: Optional[pulumi.Input[Union[str, 'AvsDataStore']]]):
        pulumi.set(self, "avs_data_store", value)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource identifier used to identify the Backup.
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter(name="capacityPoolResourceId")
    def capacity_pool_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        Pool Resource Id used in case of creating a volume through volume group
        """
        return pulumi.get(self, "capacity_pool_resource_id")

    @capacity_pool_resource_id.setter
    def capacity_pool_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capacity_pool_resource_id", value)

    @property
    @pulumi.getter(name="coolAccess")
    def cool_access(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Cool Access(tiering) is enabled for the volume.
        """
        return pulumi.get(self, "cool_access")

    @cool_access.setter
    def cool_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cool_access", value)

    @property
    @pulumi.getter(name="coolAccessRetrievalPolicy")
    def cool_access_retrieval_policy(self) -> Optional[pulumi.Input[Union[str, 'CoolAccessRetrievalPolicy']]]:
        """
        coolAccessRetrievalPolicy determines the data retrieval behavior from the cool tier to standard storage based on the read pattern for cool access enabled volumes. The possible values for this field are: 
         Default - Data will be pulled from cool tier to standard storage on random reads. This policy is the default.
         OnRead - All client-driven data read is pulled from cool tier to standard storage on both sequential and random reads.
         Never - No client-driven data is pulled from cool tier to standard storage.
        """
        return pulumi.get(self, "cool_access_retrieval_policy")

    @cool_access_retrieval_policy.setter
    def cool_access_retrieval_policy(self, value: Optional[pulumi.Input[Union[str, 'CoolAccessRetrievalPolicy']]]):
        pulumi.set(self, "cool_access_retrieval_policy", value)

    @property
    @pulumi.getter(name="coolnessPeriod")
    def coolness_period(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days after which data that is not accessed by clients will be tiered.
        """
        return pulumi.get(self, "coolness_period")

    @coolness_period.setter
    def coolness_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "coolness_period", value)

    @property
    @pulumi.getter(name="dataProtection")
    def data_protection(self) -> Optional[pulumi.Input['VolumePropertiesDataProtectionArgs']]:
        """
        DataProtection type volumes include an object containing details of the replication
        """
        return pulumi.get(self, "data_protection")

    @data_protection.setter
    def data_protection(self, value: Optional[pulumi.Input['VolumePropertiesDataProtectionArgs']]):
        pulumi.set(self, "data_protection", value)

    @property
    @pulumi.getter(name="defaultGroupQuotaInKiBs")
    def default_group_quota_in_ki_bs(self) -> Optional[pulumi.Input[float]]:
        """
        Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        """
        return pulumi.get(self, "default_group_quota_in_ki_bs")

    @default_group_quota_in_ki_bs.setter
    def default_group_quota_in_ki_bs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "default_group_quota_in_ki_bs", value)

    @property
    @pulumi.getter(name="defaultUserQuotaInKiBs")
    def default_user_quota_in_ki_bs(self) -> Optional[pulumi.Input[float]]:
        """
        Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        """
        return pulumi.get(self, "default_user_quota_in_ki_bs")

    @default_user_quota_in_ki_bs.setter
    def default_user_quota_in_ki_bs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "default_user_quota_in_ki_bs", value)

    @property
    @pulumi.getter(name="deleteBaseSnapshot")
    def delete_base_snapshot(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled (true) the snapshot the volume was created from will be automatically deleted after the volume create operation has finished.  Defaults to false
        """
        return pulumi.get(self, "delete_base_snapshot")

    @delete_base_snapshot.setter
    def delete_base_snapshot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_base_snapshot", value)

    @property
    @pulumi.getter(name="enableSubvolumes")
    def enable_subvolumes(self) -> Optional[pulumi.Input[Union[str, 'EnableSubvolumes']]]:
        """
        Flag indicating whether subvolume operations are enabled on the volume
        """
        return pulumi.get(self, "enable_subvolumes")

    @enable_subvolumes.setter
    def enable_subvolumes(self, value: Optional[pulumi.Input[Union[str, 'EnableSubvolumes']]]):
        pulumi.set(self, "enable_subvolumes", value)

    @property
    @pulumi.getter(name="encryptionKeySource")
    def encryption_key_source(self) -> Optional[pulumi.Input[Union[str, 'EncryptionKeySource']]]:
        """
        Source of key used to encrypt data in volume. Applicable if NetApp account has encryption.keySource = 'Microsoft.KeyVault'. Possible values (case-insensitive) are: 'Microsoft.NetApp, Microsoft.KeyVault'
        """
        return pulumi.get(self, "encryption_key_source")

    @encryption_key_source.setter
    def encryption_key_source(self, value: Optional[pulumi.Input[Union[str, 'EncryptionKeySource']]]):
        pulumi.set(self, "encryption_key_source", value)

    @property
    @pulumi.getter(name="exportPolicy")
    def export_policy(self) -> Optional[pulumi.Input['VolumePropertiesExportPolicyArgs']]:
        """
        Set of export policy rules
        """
        return pulumi.get(self, "export_policy")

    @export_policy.setter
    def export_policy(self, value: Optional[pulumi.Input['VolumePropertiesExportPolicyArgs']]):
        pulumi.set(self, "export_policy", value)

    @property
    @pulumi.getter(name="isDefaultQuotaEnabled")
    def is_default_quota_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if default quota is enabled for the volume.
        """
        return pulumi.get(self, "is_default_quota_enabled")

    @is_default_quota_enabled.setter
    def is_default_quota_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_default_quota_enabled", value)

    @property
    @pulumi.getter(name="isLargeVolume")
    def is_large_volume(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether volume is a Large Volume or Regular Volume.
        """
        return pulumi.get(self, "is_large_volume")

    @is_large_volume.setter
    def is_large_volume(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_large_volume", value)

    @property
    @pulumi.getter(name="isRestoring")
    def is_restoring(self) -> Optional[pulumi.Input[bool]]:
        """
        Restoring
        """
        return pulumi.get(self, "is_restoring")

    @is_restoring.setter
    def is_restoring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_restoring", value)

    @property
    @pulumi.getter(name="kerberosEnabled")
    def kerberos_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Describe if a volume is KerberosEnabled. To be use with swagger version 2020-05-01 or later
        """
        return pulumi.get(self, "kerberos_enabled")

    @kerberos_enabled.setter
    def kerberos_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "kerberos_enabled", value)

    @property
    @pulumi.getter(name="keyVaultPrivateEndpointResourceId")
    def key_vault_private_endpoint_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource ID of private endpoint for KeyVault. It must reside in the same VNET as the volume. Only applicable if encryptionKeySource = 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "key_vault_private_endpoint_resource_id")

    @key_vault_private_endpoint_resource_id.setter
    def key_vault_private_endpoint_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_private_endpoint_resource_id", value)

    @property
    @pulumi.getter
    def language(self) -> Optional[pulumi.Input[Union[str, 'VolumeLanguage']]]:
        """
        Language supported for volume.
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: Optional[pulumi.Input[Union[str, 'VolumeLanguage']]]):
        pulumi.set(self, "language", value)

    @property
    @pulumi.getter(name="ldapEnabled")
    def ldap_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether LDAP is enabled or not for a given NFS volume.
        """
        return pulumi.get(self, "ldap_enabled")

    @ldap_enabled.setter
    def ldap_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ldap_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Resource name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkFeatures")
    def network_features(self) -> Optional[pulumi.Input[Union[str, 'NetworkFeatures']]]:
        """
        Network features available to the volume, or current state of update.
        """
        return pulumi.get(self, "network_features")

    @network_features.setter
    def network_features(self, value: Optional[pulumi.Input[Union[str, 'NetworkFeatures']]]):
        pulumi.set(self, "network_features", value)

    @property
    @pulumi.getter(name="placementRules")
    def placement_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PlacementKeyValuePairsArgs']]]]:
        """
        Application specific placement rules for the particular volume
        """
        return pulumi.get(self, "placement_rules")

    @placement_rules.setter
    def placement_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PlacementKeyValuePairsArgs']]]]):
        pulumi.set(self, "placement_rules", value)

    @property
    @pulumi.getter(name="protocolTypes")
    def protocol_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of protocol types, default NFSv3, CIFS for SMB protocol
        """
        return pulumi.get(self, "protocol_types")

    @protocol_types.setter
    def protocol_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "protocol_types", value)

    @property
    @pulumi.getter(name="proximityPlacementGroup")
    def proximity_placement_group(self) -> Optional[pulumi.Input[str]]:
        """
        Proximity placement group associated with the volume
        """
        return pulumi.get(self, "proximity_placement_group")

    @proximity_placement_group.setter
    def proximity_placement_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proximity_placement_group", value)

    @property
    @pulumi.getter(name="securityStyle")
    def security_style(self) -> Optional[pulumi.Input[Union[str, 'SecurityStyle']]]:
        """
        The security style of volume, default unix, defaults to ntfs for dual protocol or CIFS protocol
        """
        return pulumi.get(self, "security_style")

    @security_style.setter
    def security_style(self, value: Optional[pulumi.Input[Union[str, 'SecurityStyle']]]):
        pulumi.set(self, "security_style", value)

    @property
    @pulumi.getter(name="serviceLevel")
    def service_level(self) -> Optional[pulumi.Input[Union[str, 'ServiceLevel']]]:
        """
        The service level of the file system
        """
        return pulumi.get(self, "service_level")

    @service_level.setter
    def service_level(self, value: Optional[pulumi.Input[Union[str, 'ServiceLevel']]]):
        pulumi.set(self, "service_level", value)

    @property
    @pulumi.getter(name="smbAccessBasedEnumeration")
    def smb_access_based_enumeration(self) -> Optional[pulumi.Input[Union[str, 'SmbAccessBasedEnumeration']]]:
        """
        Enables access-based enumeration share property for SMB Shares. Only applicable for SMB/DualProtocol volume
        """
        return pulumi.get(self, "smb_access_based_enumeration")

    @smb_access_based_enumeration.setter
    def smb_access_based_enumeration(self, value: Optional[pulumi.Input[Union[str, 'SmbAccessBasedEnumeration']]]):
        pulumi.set(self, "smb_access_based_enumeration", value)

    @property
    @pulumi.getter(name="smbContinuouslyAvailable")
    def smb_continuously_available(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables continuously available share property for smb volume. Only applicable for SMB volume
        """
        return pulumi.get(self, "smb_continuously_available")

    @smb_continuously_available.setter
    def smb_continuously_available(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "smb_continuously_available", value)

    @property
    @pulumi.getter(name="smbEncryption")
    def smb_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables encryption for in-flight smb3 data. Only applicable for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or later
        """
        return pulumi.get(self, "smb_encryption")

    @smb_encryption.setter
    def smb_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "smb_encryption", value)

    @property
    @pulumi.getter(name="smbNonBrowsable")
    def smb_non_browsable(self) -> Optional[pulumi.Input[Union[str, 'SmbNonBrowsable']]]:
        """
        Enables non-browsable property for SMB Shares. Only applicable for SMB/DualProtocol volume
        """
        return pulumi.get(self, "smb_non_browsable")

    @smb_non_browsable.setter
    def smb_non_browsable(self, value: Optional[pulumi.Input[Union[str, 'SmbNonBrowsable']]]):
        pulumi.set(self, "smb_non_browsable", value)

    @property
    @pulumi.getter(name="snapshotDirectoryVisible")
    def snapshot_directory_visible(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled (true) the volume will contain a read-only snapshot directory which provides access to each of the volume's snapshots (defaults to true).
        """
        return pulumi.get(self, "snapshot_directory_visible")

    @snapshot_directory_visible.setter
    def snapshot_directory_visible(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "snapshot_directory_visible", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource identifier used to identify the Snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Resource tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="throughputMibps")
    def throughput_mibps(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "throughput_mibps")

    @throughput_mibps.setter
    def throughput_mibps(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "throughput_mibps", value)

    @property
    @pulumi.getter(name="unixPermissions")
    def unix_permissions(self) -> Optional[pulumi.Input[str]]:
        """
        UNIX permissions for NFS volume accepted in octal 4 digit format. First digit selects the set user ID(4), set group ID (2) and sticky (1) attributes. Second digit selects permission for the owner of the file: read (4), write (2) and execute (1). Third selects permissions for other users in the same group. the fourth for other users not in the group. 0755 - gives read/write/execute permissions to owner and read/execute to group and other users.
        """
        return pulumi.get(self, "unix_permissions")

    @unix_permissions.setter
    def unix_permissions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unix_permissions", value)

    @property
    @pulumi.getter(name="volumeSpecName")
    def volume_spec_name(self) -> Optional[pulumi.Input[str]]:
        """
        Volume spec name is the application specific designation or identifier for the particular volume in a volume group for e.g. data, log
        """
        return pulumi.get(self, "volume_spec_name")

    @volume_spec_name.setter
    def volume_spec_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_spec_name", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        What type of volume is this. For destination volumes in Cross Region Replication, set type to DataProtection. For creating clone volume, set type to ShortTermClone
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)

    @property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Availability Zone
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "zones", value)


if not MYPY:
    class VolumePropertiesDataProtectionArgsDict(TypedDict):
        """
        DataProtection type volumes include an object containing details of the replication
        """
        backup: NotRequired[pulumi.Input['VolumeBackupPropertiesArgsDict']]
        """
        Backup Properties
        """
        replication: NotRequired[pulumi.Input['ReplicationObjectArgsDict']]
        """
        Replication properties
        """
        snapshot: NotRequired[pulumi.Input['VolumeSnapshotPropertiesArgsDict']]
        """
        Snapshot properties.
        """
        volume_relocation: NotRequired[pulumi.Input['VolumeRelocationPropertiesArgsDict']]
        """
        VolumeRelocation properties
        """
elif False:
    VolumePropertiesDataProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumePropertiesDataProtectionArgs:
    def __init__(__self__, *,
                 backup: Optional[pulumi.Input['VolumeBackupPropertiesArgs']] = None,
                 replication: Optional[pulumi.Input['ReplicationObjectArgs']] = None,
                 snapshot: Optional[pulumi.Input['VolumeSnapshotPropertiesArgs']] = None,
                 volume_relocation: Optional[pulumi.Input['VolumeRelocationPropertiesArgs']] = None):
        """
        DataProtection type volumes include an object containing details of the replication
        :param pulumi.Input['VolumeBackupPropertiesArgs'] backup: Backup Properties
        :param pulumi.Input['ReplicationObjectArgs'] replication: Replication properties
        :param pulumi.Input['VolumeSnapshotPropertiesArgs'] snapshot: Snapshot properties.
        :param pulumi.Input['VolumeRelocationPropertiesArgs'] volume_relocation: VolumeRelocation properties
        """
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if replication is not None:
            pulumi.set(__self__, "replication", replication)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if volume_relocation is not None:
            pulumi.set(__self__, "volume_relocation", volume_relocation)

    @property
    @pulumi.getter
    def backup(self) -> Optional[pulumi.Input['VolumeBackupPropertiesArgs']]:
        """
        Backup Properties
        """
        return pulumi.get(self, "backup")

    @backup.setter
    def backup(self, value: Optional[pulumi.Input['VolumeBackupPropertiesArgs']]):
        pulumi.set(self, "backup", value)

    @property
    @pulumi.getter
    def replication(self) -> Optional[pulumi.Input['ReplicationObjectArgs']]:
        """
        Replication properties
        """
        return pulumi.get(self, "replication")

    @replication.setter
    def replication(self, value: Optional[pulumi.Input['ReplicationObjectArgs']]):
        pulumi.set(self, "replication", value)

    @property
    @pulumi.getter
    def snapshot(self) -> Optional[pulumi.Input['VolumeSnapshotPropertiesArgs']]:
        """
        Snapshot properties.
        """
        return pulumi.get(self, "snapshot")

    @snapshot.setter
    def snapshot(self, value: Optional[pulumi.Input['VolumeSnapshotPropertiesArgs']]):
        pulumi.set(self, "snapshot", value)

    @property
    @pulumi.getter(name="volumeRelocation")
    def volume_relocation(self) -> Optional[pulumi.Input['VolumeRelocationPropertiesArgs']]:
        """
        VolumeRelocation properties
        """
        return pulumi.get(self, "volume_relocation")

    @volume_relocation.setter
    def volume_relocation(self, value: Optional[pulumi.Input['VolumeRelocationPropertiesArgs']]):
        pulumi.set(self, "volume_relocation", value)


if not MYPY:
    class VolumePropertiesExportPolicyArgsDict(TypedDict):
        """
        Set of export policy rules
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExportPolicyRuleArgsDict']]]]
        """
        Export policy rule
        """
elif False:
    VolumePropertiesExportPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumePropertiesExportPolicyArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['ExportPolicyRuleArgs']]]] = None):
        """
        Set of export policy rules
        :param pulumi.Input[Sequence[pulumi.Input['ExportPolicyRuleArgs']]] rules: Export policy rule
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExportPolicyRuleArgs']]]]:
        """
        Export policy rule
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExportPolicyRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class VolumeRelocationPropertiesArgsDict(TypedDict):
        """
        Volume relocation properties
        """
        relocation_requested: NotRequired[pulumi.Input[bool]]
        """
        Has relocation been requested for this volume
        """
elif False:
    VolumeRelocationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeRelocationPropertiesArgs:
    def __init__(__self__, *,
                 relocation_requested: Optional[pulumi.Input[bool]] = None):
        """
        Volume relocation properties
        :param pulumi.Input[bool] relocation_requested: Has relocation been requested for this volume
        """
        if relocation_requested is not None:
            pulumi.set(__self__, "relocation_requested", relocation_requested)

    @property
    @pulumi.getter(name="relocationRequested")
    def relocation_requested(self) -> Optional[pulumi.Input[bool]]:
        """
        Has relocation been requested for this volume
        """
        return pulumi.get(self, "relocation_requested")

    @relocation_requested.setter
    def relocation_requested(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "relocation_requested", value)


if not MYPY:
    class VolumeSnapshotPropertiesArgsDict(TypedDict):
        """
        Volume Snapshot Properties
        """
        snapshot_policy_id: NotRequired[pulumi.Input[str]]
        """
        Snapshot Policy ResourceId
        """
elif False:
    VolumeSnapshotPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeSnapshotPropertiesArgs:
    def __init__(__self__, *,
                 snapshot_policy_id: Optional[pulumi.Input[str]] = None):
        """
        Volume Snapshot Properties
        :param pulumi.Input[str] snapshot_policy_id: Snapshot Policy ResourceId
        """
        if snapshot_policy_id is not None:
            pulumi.set(__self__, "snapshot_policy_id", snapshot_policy_id)

    @property
    @pulumi.getter(name="snapshotPolicyId")
    def snapshot_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        Snapshot Policy ResourceId
        """
        return pulumi.get(self, "snapshot_policy_id")

    @snapshot_policy_id.setter
    def snapshot_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_policy_id", value)


if not MYPY:
    class WeeklyScheduleArgsDict(TypedDict):
        """
        Weekly Schedule properties, make a snapshot every week at a specific day or days
        """
        day: NotRequired[pulumi.Input[str]]
        """
        Indicates which weekdays snapshot should be taken, accepts a comma separated list of week day names in english
        """
        hour: NotRequired[pulumi.Input[int]]
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        minute: NotRequired[pulumi.Input[int]]
        """
        Indicates which minute snapshot should be taken
        """
        snapshots_to_keep: NotRequired[pulumi.Input[int]]
        """
        Weekly snapshot count to keep
        """
        used_bytes: NotRequired[pulumi.Input[float]]
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
elif False:
    WeeklyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WeeklyScheduleArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[str]] = None,
                 hour: Optional[pulumi.Input[int]] = None,
                 minute: Optional[pulumi.Input[int]] = None,
                 snapshots_to_keep: Optional[pulumi.Input[int]] = None,
                 used_bytes: Optional[pulumi.Input[float]] = None):
        """
        Weekly Schedule properties, make a snapshot every week at a specific day or days
        :param pulumi.Input[str] day: Indicates which weekdays snapshot should be taken, accepts a comma separated list of week day names in english
        :param pulumi.Input[int] hour: Indicates which hour in UTC timezone a snapshot should be taken
        :param pulumi.Input[int] minute: Indicates which minute snapshot should be taken
        :param pulumi.Input[int] snapshots_to_keep: Weekly snapshot count to keep
        :param pulumi.Input[float] used_bytes: Resource size in bytes, current storage usage for the volume in bytes
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if snapshots_to_keep is not None:
            pulumi.set(__self__, "snapshots_to_keep", snapshots_to_keep)
        if used_bytes is not None:
            pulumi.set(__self__, "used_bytes", used_bytes)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates which weekdays snapshot should be taken, accepts a comma separated list of week day names in english
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates which hour in UTC timezone a snapshot should be taken
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)

    @property
    @pulumi.getter
    def minute(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates which minute snapshot should be taken
        """
        return pulumi.get(self, "minute")

    @minute.setter
    def minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minute", value)

    @property
    @pulumi.getter(name="snapshotsToKeep")
    def snapshots_to_keep(self) -> Optional[pulumi.Input[int]]:
        """
        Weekly snapshot count to keep
        """
        return pulumi.get(self, "snapshots_to_keep")

    @snapshots_to_keep.setter
    def snapshots_to_keep(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshots_to_keep", value)

    @property
    @pulumi.getter(name="usedBytes")
    def used_bytes(self) -> Optional[pulumi.Input[float]]:
        """
        Resource size in bytes, current storage usage for the volume in bytes
        """
        return pulumi.get(self, "used_bytes")

    @used_bytes.setter
    def used_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "used_bytes", value)


