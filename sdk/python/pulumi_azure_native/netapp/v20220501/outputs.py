# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AccountEncryptionResponse',
    'ActiveDirectoryResponse',
    'EncryptionIdentityResponse',
    'IdentityResponse',
    'KeyVaultPropertiesResponse',
    'LdapSearchScopeOptResponse',
    'SystemDataResponse',
    'UserAssignedIdentityResponse',
]

@pulumi.output_type
class AccountEncryptionResponse(dict):
    """
    Encryption settings
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keySource":
            suggest = "key_source"
        elif key == "keyVaultProperties":
            suggest = "key_vault_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountEncryptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountEncryptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountEncryptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: Optional['outputs.EncryptionIdentityResponse'] = None,
                 key_source: Optional[str] = None,
                 key_vault_properties: Optional['outputs.KeyVaultPropertiesResponse'] = None):
        """
        Encryption settings
        :param 'EncryptionIdentityResponse' identity: Identity used to authenticate to KeyVault. Applicable if keySource is 'Microsoft.KeyVault'.
        :param str key_source: The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault
        :param 'KeyVaultPropertiesResponse' key_vault_properties: Properties provided by KeVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if key_source is None:
            key_source = 'Microsoft.NetApp'
        if key_source is not None:
            pulumi.set(__self__, "key_source", key_source)
        if key_vault_properties is not None:
            pulumi.set(__self__, "key_vault_properties", key_vault_properties)

    @property
    @pulumi.getter
    def identity(self) -> Optional['outputs.EncryptionIdentityResponse']:
        """
        Identity used to authenticate to KeyVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="keySource")
    def key_source(self) -> Optional[str]:
        """
        The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.NetApp, Microsoft.KeyVault
        """
        return pulumi.get(self, "key_source")

    @property
    @pulumi.getter(name="keyVaultProperties")
    def key_vault_properties(self) -> Optional['outputs.KeyVaultPropertiesResponse']:
        """
        Properties provided by KeVault. Applicable if keySource is 'Microsoft.KeyVault'.
        """
        return pulumi.get(self, "key_vault_properties")


@pulumi.output_type
class ActiveDirectoryResponse(dict):
    """
    Active Directory
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusDetails":
            suggest = "status_details"
        elif key == "activeDirectoryId":
            suggest = "active_directory_id"
        elif key == "adName":
            suggest = "ad_name"
        elif key == "aesEncryption":
            suggest = "aes_encryption"
        elif key == "allowLocalNfsUsersWithLdap":
            suggest = "allow_local_nfs_users_with_ldap"
        elif key == "backupOperators":
            suggest = "backup_operators"
        elif key == "encryptDCConnections":
            suggest = "encrypt_dc_connections"
        elif key == "kdcIP":
            suggest = "kdc_ip"
        elif key == "ldapOverTLS":
            suggest = "ldap_over_tls"
        elif key == "ldapSearchScope":
            suggest = "ldap_search_scope"
        elif key == "ldapSigning":
            suggest = "ldap_signing"
        elif key == "organizationalUnit":
            suggest = "organizational_unit"
        elif key == "securityOperators":
            suggest = "security_operators"
        elif key == "serverRootCACertificate":
            suggest = "server_root_ca_certificate"
        elif key == "smbServerName":
            suggest = "smb_server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ActiveDirectoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ActiveDirectoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ActiveDirectoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 status_details: str,
                 active_directory_id: Optional[str] = None,
                 ad_name: Optional[str] = None,
                 administrators: Optional[Sequence[str]] = None,
                 aes_encryption: Optional[bool] = None,
                 allow_local_nfs_users_with_ldap: Optional[bool] = None,
                 backup_operators: Optional[Sequence[str]] = None,
                 dns: Optional[str] = None,
                 domain: Optional[str] = None,
                 encrypt_dc_connections: Optional[bool] = None,
                 kdc_ip: Optional[str] = None,
                 ldap_over_tls: Optional[bool] = None,
                 ldap_search_scope: Optional['outputs.LdapSearchScopeOptResponse'] = None,
                 ldap_signing: Optional[bool] = None,
                 organizational_unit: Optional[str] = None,
                 password: Optional[str] = None,
                 security_operators: Optional[Sequence[str]] = None,
                 server_root_ca_certificate: Optional[str] = None,
                 site: Optional[str] = None,
                 smb_server_name: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Active Directory
        :param str status: Status of the Active Directory
        :param str status_details: Any details in regards to the Status of the Active Directory
        :param str active_directory_id: Id of the Active Directory
        :param str ad_name: Name of the active directory machine. This optional parameter is used only while creating kerberos volume
        :param Sequence[str] administrators: Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier
        :param bool aes_encryption: If enabled, AES encryption will be enabled for SMB communication.
        :param bool allow_local_nfs_users_with_ldap:  If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes.
        :param Sequence[str] backup_operators: Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier
        :param str dns: Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain
        :param str domain: Name of the Active Directory domain
        :param bool encrypt_dc_connections: If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted.
        :param str kdc_ip: kdc server IP addresses for the active directory machine. This optional parameter is used only while creating kerberos volume.
        :param bool ldap_over_tls: Specifies whether or not the LDAP traffic needs to be secured via TLS.
        :param 'LdapSearchScopeOptResponse' ldap_search_scope: LDAP Search scope options
        :param bool ldap_signing: Specifies whether or not the LDAP traffic needs to be signed.
        :param str organizational_unit: The Organizational Unit (OU) within the Windows Active Directory
        :param str password: Plain text password of Active Directory domain administrator, value is masked in the response
        :param Sequence[str] security_operators: Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier
        :param str server_root_ca_certificate: When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes.
        :param str site: The Active Directory site the service will limit Domain Controller discovery to
        :param str smb_server_name: NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
        :param str username: A domain user account with permission to create machine accounts
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_details", status_details)
        if active_directory_id is not None:
            pulumi.set(__self__, "active_directory_id", active_directory_id)
        if ad_name is not None:
            pulumi.set(__self__, "ad_name", ad_name)
        if administrators is not None:
            pulumi.set(__self__, "administrators", administrators)
        if aes_encryption is not None:
            pulumi.set(__self__, "aes_encryption", aes_encryption)
        if allow_local_nfs_users_with_ldap is not None:
            pulumi.set(__self__, "allow_local_nfs_users_with_ldap", allow_local_nfs_users_with_ldap)
        if backup_operators is not None:
            pulumi.set(__self__, "backup_operators", backup_operators)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if encrypt_dc_connections is not None:
            pulumi.set(__self__, "encrypt_dc_connections", encrypt_dc_connections)
        if kdc_ip is not None:
            pulumi.set(__self__, "kdc_ip", kdc_ip)
        if ldap_over_tls is not None:
            pulumi.set(__self__, "ldap_over_tls", ldap_over_tls)
        if ldap_search_scope is not None:
            pulumi.set(__self__, "ldap_search_scope", ldap_search_scope)
        if ldap_signing is not None:
            pulumi.set(__self__, "ldap_signing", ldap_signing)
        if organizational_unit is None:
            organizational_unit = 'CN=Computers'
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if security_operators is not None:
            pulumi.set(__self__, "security_operators", security_operators)
        if server_root_ca_certificate is not None:
            pulumi.set(__self__, "server_root_ca_certificate", server_root_ca_certificate)
        if site is not None:
            pulumi.set(__self__, "site", site)
        if smb_server_name is not None:
            pulumi.set(__self__, "smb_server_name", smb_server_name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the Active Directory
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusDetails")
    def status_details(self) -> str:
        """
        Any details in regards to the Status of the Active Directory
        """
        return pulumi.get(self, "status_details")

    @property
    @pulumi.getter(name="activeDirectoryId")
    def active_directory_id(self) -> Optional[str]:
        """
        Id of the Active Directory
        """
        return pulumi.get(self, "active_directory_id")

    @property
    @pulumi.getter(name="adName")
    def ad_name(self) -> Optional[str]:
        """
        Name of the active directory machine. This optional parameter is used only while creating kerberos volume
        """
        return pulumi.get(self, "ad_name")

    @property
    @pulumi.getter
    def administrators(self) -> Optional[Sequence[str]]:
        """
        Users to be added to the Built-in Administrators active directory group. A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "administrators")

    @property
    @pulumi.getter(name="aesEncryption")
    def aes_encryption(self) -> Optional[bool]:
        """
        If enabled, AES encryption will be enabled for SMB communication.
        """
        return pulumi.get(self, "aes_encryption")

    @property
    @pulumi.getter(name="allowLocalNfsUsersWithLdap")
    def allow_local_nfs_users_with_ldap(self) -> Optional[bool]:
        """
         If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes.
        """
        return pulumi.get(self, "allow_local_nfs_users_with_ldap")

    @property
    @pulumi.getter(name="backupOperators")
    def backup_operators(self) -> Optional[Sequence[str]]:
        """
        Users to be added to the Built-in Backup Operator active directory group. A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "backup_operators")

    @property
    @pulumi.getter
    def dns(self) -> Optional[str]:
        """
        Comma separated list of DNS server IP addresses (IPv4 only) for the Active Directory domain
        """
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Name of the Active Directory domain
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="encryptDCConnections")
    def encrypt_dc_connections(self) -> Optional[bool]:
        """
        If enabled, Traffic between the SMB server to Domain Controller (DC) will be encrypted.
        """
        return pulumi.get(self, "encrypt_dc_connections")

    @property
    @pulumi.getter(name="kdcIP")
    def kdc_ip(self) -> Optional[str]:
        """
        kdc server IP addresses for the active directory machine. This optional parameter is used only while creating kerberos volume.
        """
        return pulumi.get(self, "kdc_ip")

    @property
    @pulumi.getter(name="ldapOverTLS")
    def ldap_over_tls(self) -> Optional[bool]:
        """
        Specifies whether or not the LDAP traffic needs to be secured via TLS.
        """
        return pulumi.get(self, "ldap_over_tls")

    @property
    @pulumi.getter(name="ldapSearchScope")
    def ldap_search_scope(self) -> Optional['outputs.LdapSearchScopeOptResponse']:
        """
        LDAP Search scope options
        """
        return pulumi.get(self, "ldap_search_scope")

    @property
    @pulumi.getter(name="ldapSigning")
    def ldap_signing(self) -> Optional[bool]:
        """
        Specifies whether or not the LDAP traffic needs to be signed.
        """
        return pulumi.get(self, "ldap_signing")

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[str]:
        """
        The Organizational Unit (OU) within the Windows Active Directory
        """
        return pulumi.get(self, "organizational_unit")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Plain text password of Active Directory domain administrator, value is masked in the response
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="securityOperators")
    def security_operators(self) -> Optional[Sequence[str]]:
        """
        Domain Users in the Active directory to be given SeSecurityPrivilege privilege (Needed for SMB Continuously available shares for SQL). A list of unique usernames without domain specifier
        """
        return pulumi.get(self, "security_operators")

    @property
    @pulumi.getter(name="serverRootCACertificate")
    def server_root_ca_certificate(self) -> Optional[str]:
        """
        When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes.
        """
        return pulumi.get(self, "server_root_ca_certificate")

    @property
    @pulumi.getter
    def site(self) -> Optional[str]:
        """
        The Active Directory site the service will limit Domain Controller discovery to
        """
        return pulumi.get(self, "site")

    @property
    @pulumi.getter(name="smbServerName")
    def smb_server_name(self) -> Optional[str]:
        """
        NetBIOS name of the SMB server. This name will be registered as a computer account in the AD and used to mount volumes
        """
        return pulumi.get(self, "smb_server_name")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A domain user account with permission to create machine accounts
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class EncryptionIdentityResponse(dict):
    """
    Identity used to authenticate with key vault.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "userAssignedIdentity":
            suggest = "user_assigned_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 user_assigned_identity: Optional[str] = None):
        """
        Identity used to authenticate with key vault.
        :param str principal_id: The principal ID (object ID) of the identity used to authenticate with key vault. Read-only.
        :param str user_assigned_identity: The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        if user_assigned_identity is not None:
            pulumi.set(__self__, "user_assigned_identity", user_assigned_identity)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID (object ID) of the identity used to authenticate with key vault. Read-only.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="userAssignedIdentity")
    def user_assigned_identity(self) -> Optional[str]:
        """
        The ARM resource identifier of the user assigned identity used to authenticate with key vault. Applicable if identity.type has 'UserAssigned'. It should match key of identity.userAssignedIdentities.
        """
        return pulumi.get(self, "user_assigned_identity")


@pulumi.output_type
class IdentityResponse(dict):
    """
    Identity for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Identity for the resource.
        :param str principal_id: The principal ID of resource identity.
        :param str tenant_id: The tenant ID of resource.
        :param str type: The identity type.
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: Gets or sets a list of key value pairs that describe the set of User Assigned identities that will be used with this storage account. The key is the ARM resource identifier of the identity. Only 1 User Assigned identity is permitted here.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        Gets or sets a list of key value pairs that describe the set of User Assigned identities that will be used with this storage account. The key is the ARM resource identifier of the identity. Only 1 User Assigned identity is permitted here.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class KeyVaultPropertiesResponse(dict):
    """
    Properties of key vault.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyName":
            suggest = "key_name"
        elif key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "keyVaultResourceId":
            suggest = "key_vault_resource_id"
        elif key == "keyVaultUri":
            suggest = "key_vault_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_name: str,
                 key_vault_id: str,
                 key_vault_resource_id: str,
                 key_vault_uri: str,
                 status: str):
        """
        Properties of key vault.
        :param str key_name: The name of KeyVault key.
        :param str key_vault_id: UUID v4 used to identify the Azure Key Vault configuration
        :param str key_vault_resource_id: The resource ID of KeyVault.
        :param str key_vault_uri: The Uri of KeyVault.
        :param str status: Status of the KeyVault connection.
        """
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "key_vault_id", key_vault_id)
        pulumi.set(__self__, "key_vault_resource_id", key_vault_resource_id)
        pulumi.set(__self__, "key_vault_uri", key_vault_uri)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> str:
        """
        The name of KeyVault key.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        UUID v4 used to identify the Azure Key Vault configuration
        """
        return pulumi.get(self, "key_vault_id")

    @property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> str:
        """
        The resource ID of KeyVault.
        """
        return pulumi.get(self, "key_vault_resource_id")

    @property
    @pulumi.getter(name="keyVaultUri")
    def key_vault_uri(self) -> str:
        """
        The Uri of KeyVault.
        """
        return pulumi.get(self, "key_vault_uri")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the KeyVault connection.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class LdapSearchScopeOptResponse(dict):
    """
    LDAP search scope 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupDN":
            suggest = "group_dn"
        elif key == "groupMembershipFilter":
            suggest = "group_membership_filter"
        elif key == "userDN":
            suggest = "user_dn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LdapSearchScopeOptResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LdapSearchScopeOptResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LdapSearchScopeOptResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_dn: Optional[str] = None,
                 group_membership_filter: Optional[str] = None,
                 user_dn: Optional[str] = None):
        """
        LDAP search scope 
        :param str group_dn: This specifies the group DN, which overrides the base DN for group lookups.
        :param str group_membership_filter: This specifies the custom LDAP search filter to be used when looking up group membership from LDAP server.
        :param str user_dn: This specifies the user DN, which overrides the base DN for user lookups.
        """
        if group_dn is not None:
            pulumi.set(__self__, "group_dn", group_dn)
        if group_membership_filter is not None:
            pulumi.set(__self__, "group_membership_filter", group_membership_filter)
        if user_dn is not None:
            pulumi.set(__self__, "user_dn", user_dn)

    @property
    @pulumi.getter(name="groupDN")
    def group_dn(self) -> Optional[str]:
        """
        This specifies the group DN, which overrides the base DN for group lookups.
        """
        return pulumi.get(self, "group_dn")

    @property
    @pulumi.getter(name="groupMembershipFilter")
    def group_membership_filter(self) -> Optional[str]:
        """
        This specifies the custom LDAP search filter to be used when looking up group membership from LDAP server.
        """
        return pulumi.get(self, "group_membership_filter")

    @property
    @pulumi.getter(name="userDN")
    def user_dn(self) -> Optional[str]:
        """
        This specifies the user DN, which overrides the base DN for user lookups.
        """
        return pulumi.get(self, "user_dn")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    UserAssignedIdentity for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        UserAssignedIdentity for the resource.
        :param str client_id: The client ID of the identity.
        :param str principal_id: The principal ID of the identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the identity.
        """
        return pulumi.get(self, "principal_id")


