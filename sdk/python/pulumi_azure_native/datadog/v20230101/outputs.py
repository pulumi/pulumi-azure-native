# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'DatadogApiKeyResponse',
    'DatadogHostMetadataResponse',
    'DatadogHostResponse',
    'DatadogInstallMethodResponse',
    'DatadogLogsAgentResponse',
    'DatadogOrganizationPropertiesResponse',
    'FilteringTagResponse',
    'IdentityPropertiesResponse',
    'LinkedResourceResponse',
    'LogRulesResponse',
    'MetricRulesResponse',
    'MonitorPropertiesResponse',
    'MonitoredResourceResponse',
    'MonitoredSubscriptionResponse',
    'MonitoringTagRulesPropertiesResponse',
    'ResourceSkuResponse',
    'SubscriptionListResponse',
    'SystemDataResponse',
    'UserInfoResponse',
]

@pulumi.output_type
class DatadogApiKeyResponse(dict):
    def __init__(__self__, *,
                 key: str,
                 created: Optional[str] = None,
                 created_by: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str key: The value of the API key.
        :param str created: The time of creation of the API key.
        :param str created_by: The user that created the API key.
        :param str name: The name of the API key.
        """
        DatadogApiKeyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            created=created,
            created_by=created_by,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             created: Optional[str] = None,
             created_by: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdBy' in kwargs:
            created_by = kwargs['createdBy']

        _setter("key", key)
        if created is not None:
            _setter("created", created)
        if created_by is not None:
            _setter("created_by", created_by)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The value of the API key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def created(self) -> Optional[str]:
        """
        The time of creation of the API key.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The user that created the API key.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the API key.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DatadogHostMetadataResponse(dict):
    def __init__(__self__, *,
                 agent_version: Optional[str] = None,
                 install_method: Optional['outputs.DatadogInstallMethodResponse'] = None,
                 logs_agent: Optional['outputs.DatadogLogsAgentResponse'] = None):
        """
        :param str agent_version: The agent version.
        """
        DatadogHostMetadataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            agent_version=agent_version,
            install_method=install_method,
            logs_agent=logs_agent,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             agent_version: Optional[str] = None,
             install_method: Optional['outputs.DatadogInstallMethodResponse'] = None,
             logs_agent: Optional['outputs.DatadogLogsAgentResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'agentVersion' in kwargs:
            agent_version = kwargs['agentVersion']
        if 'installMethod' in kwargs:
            install_method = kwargs['installMethod']
        if 'logsAgent' in kwargs:
            logs_agent = kwargs['logsAgent']

        if agent_version is not None:
            _setter("agent_version", agent_version)
        if install_method is not None:
            _setter("install_method", install_method)
        if logs_agent is not None:
            _setter("logs_agent", logs_agent)

    @property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> Optional[str]:
        """
        The agent version.
        """
        return pulumi.get(self, "agent_version")

    @property
    @pulumi.getter(name="installMethod")
    def install_method(self) -> Optional['outputs.DatadogInstallMethodResponse']:
        return pulumi.get(self, "install_method")

    @property
    @pulumi.getter(name="logsAgent")
    def logs_agent(self) -> Optional['outputs.DatadogLogsAgentResponse']:
        return pulumi.get(self, "logs_agent")


@pulumi.output_type
class DatadogHostResponse(dict):
    def __init__(__self__, *,
                 aliases: Optional[Sequence[str]] = None,
                 apps: Optional[Sequence[str]] = None,
                 meta: Optional['outputs.DatadogHostMetadataResponse'] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] aliases: The aliases for the host installed via the Datadog agent.
        :param Sequence[str] apps: The Datadog integrations reporting metrics for the host.
        :param str name: The name of the host.
        """
        DatadogHostResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aliases=aliases,
            apps=apps,
            meta=meta,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aliases: Optional[Sequence[str]] = None,
             apps: Optional[Sequence[str]] = None,
             meta: Optional['outputs.DatadogHostMetadataResponse'] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if aliases is not None:
            _setter("aliases", aliases)
        if apps is not None:
            _setter("apps", apps)
        if meta is not None:
            _setter("meta", meta)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[Sequence[str]]:
        """
        The aliases for the host installed via the Datadog agent.
        """
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter
    def apps(self) -> Optional[Sequence[str]]:
        """
        The Datadog integrations reporting metrics for the host.
        """
        return pulumi.get(self, "apps")

    @property
    @pulumi.getter
    def meta(self) -> Optional['outputs.DatadogHostMetadataResponse']:
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the host.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DatadogInstallMethodResponse(dict):
    def __init__(__self__, *,
                 installer_version: Optional[str] = None,
                 tool: Optional[str] = None,
                 tool_version: Optional[str] = None):
        """
        :param str installer_version: The installer version.
        :param str tool: The tool.
        :param str tool_version: The tool version.
        """
        DatadogInstallMethodResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            installer_version=installer_version,
            tool=tool,
            tool_version=tool_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             installer_version: Optional[str] = None,
             tool: Optional[str] = None,
             tool_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'installerVersion' in kwargs:
            installer_version = kwargs['installerVersion']
        if 'toolVersion' in kwargs:
            tool_version = kwargs['toolVersion']

        if installer_version is not None:
            _setter("installer_version", installer_version)
        if tool is not None:
            _setter("tool", tool)
        if tool_version is not None:
            _setter("tool_version", tool_version)

    @property
    @pulumi.getter(name="installerVersion")
    def installer_version(self) -> Optional[str]:
        """
        The installer version.
        """
        return pulumi.get(self, "installer_version")

    @property
    @pulumi.getter
    def tool(self) -> Optional[str]:
        """
        The tool.
        """
        return pulumi.get(self, "tool")

    @property
    @pulumi.getter(name="toolVersion")
    def tool_version(self) -> Optional[str]:
        """
        The tool version.
        """
        return pulumi.get(self, "tool_version")


@pulumi.output_type
class DatadogLogsAgentResponse(dict):
    def __init__(__self__, *,
                 transport: Optional[str] = None):
        """
        :param str transport: The transport.
        """
        DatadogLogsAgentResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            transport=transport,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             transport: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if transport is not None:
            _setter("transport", transport)

    @property
    @pulumi.getter
    def transport(self) -> Optional[str]:
        """
        The transport.
        """
        return pulumi.get(self, "transport")


@pulumi.output_type
class DatadogOrganizationPropertiesResponse(dict):
    """
    Specify the Datadog organization name. In the case of linking to existing organizations, Id, ApiKey, and Applicationkey is required as well.
    """
    def __init__(__self__, *,
                 cspm: Optional[bool] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Specify the Datadog organization name. In the case of linking to existing organizations, Id, ApiKey, and Applicationkey is required as well.
        :param bool cspm: The configuration which describes the state of cloud security posture management. This collects configuration information for all resources in a subscription and track conformance to industry benchmarks.
        :param str id: Id of the Datadog organization.
        :param str name: Name of the Datadog organization.
        """
        DatadogOrganizationPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cspm=cspm,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cspm: Optional[bool] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if cspm is not None:
            _setter("cspm", cspm)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def cspm(self) -> Optional[bool]:
        """
        The configuration which describes the state of cloud security posture management. This collects configuration information for all resources in a subscription and track conformance to industry benchmarks.
        """
        return pulumi.get(self, "cspm")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Id of the Datadog organization.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Datadog organization.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FilteringTagResponse(dict):
    """
    The definition of a filtering tag. Filtering tags are used for capturing resources and include/exclude them from being monitored.
    """
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        The definition of a filtering tag. Filtering tags are used for capturing resources and include/exclude them from being monitored.
        :param str action: Valid actions for a filtering tag. Exclusion takes priority over inclusion.
        :param str name: The name (also known as the key) of the tag.
        :param str value: The value of the tag.
        """
        FilteringTagResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if action is not None:
            _setter("action", action)
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Valid actions for a filtering tag. Exclusion takes priority over inclusion.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name (also known as the key) of the tag.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IdentityPropertiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None):
        """
        :param str principal_id: The identity ID.
        :param str tenant_id: The tenant ID of resource.
        :param str type: Specifies the identity type of the Datadog Monitor. At this time the only allowed value is 'SystemAssigned'.
        """
        IdentityPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: str,
             tenant_id: str,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']

        _setter("principal_id", principal_id)
        _setter("tenant_id", tenant_id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The identity ID.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Specifies the identity type of the Datadog Monitor. At this time the only allowed value is 'SystemAssigned'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LinkedResourceResponse(dict):
    """
    The definition of a linked resource.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        The definition of a linked resource.
        :param str id: The ARM id of the linked resource.
        """
        LinkedResourceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ARM id of the linked resource.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class LogRulesResponse(dict):
    """
    Set of rules for sending logs for the Monitor resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filteringTags":
            suggest = "filtering_tags"
        elif key == "sendAadLogs":
            suggest = "send_aad_logs"
        elif key == "sendResourceLogs":
            suggest = "send_resource_logs"
        elif key == "sendSubscriptionLogs":
            suggest = "send_subscription_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogRulesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogRulesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogRulesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filtering_tags: Optional[Sequence['outputs.FilteringTagResponse']] = None,
                 send_aad_logs: Optional[bool] = None,
                 send_resource_logs: Optional[bool] = None,
                 send_subscription_logs: Optional[bool] = None):
        """
        Set of rules for sending logs for the Monitor resource.
        :param Sequence['FilteringTagResponse'] filtering_tags: List of filtering tags to be used for capturing logs. This only takes effect if SendResourceLogs flag is enabled. If empty, all resources will be captured. If only Exclude action is specified, the rules will apply to the list of all available resources. If Include actions are specified, the rules will only include resources with the associated tags.
        :param bool send_aad_logs: Flag specifying if AAD logs should be sent for the Monitor resource.
        :param bool send_resource_logs: Flag specifying if Azure resource logs should be sent for the Monitor resource.
        :param bool send_subscription_logs: Flag specifying if Azure subscription logs should be sent for the Monitor resource.
        """
        LogRulesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filtering_tags=filtering_tags,
            send_aad_logs=send_aad_logs,
            send_resource_logs=send_resource_logs,
            send_subscription_logs=send_subscription_logs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filtering_tags: Optional[Sequence['outputs.FilteringTagResponse']] = None,
             send_aad_logs: Optional[bool] = None,
             send_resource_logs: Optional[bool] = None,
             send_subscription_logs: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'filteringTags' in kwargs:
            filtering_tags = kwargs['filteringTags']
        if 'sendAadLogs' in kwargs:
            send_aad_logs = kwargs['sendAadLogs']
        if 'sendResourceLogs' in kwargs:
            send_resource_logs = kwargs['sendResourceLogs']
        if 'sendSubscriptionLogs' in kwargs:
            send_subscription_logs = kwargs['sendSubscriptionLogs']

        if filtering_tags is not None:
            _setter("filtering_tags", filtering_tags)
        if send_aad_logs is not None:
            _setter("send_aad_logs", send_aad_logs)
        if send_resource_logs is not None:
            _setter("send_resource_logs", send_resource_logs)
        if send_subscription_logs is not None:
            _setter("send_subscription_logs", send_subscription_logs)

    @property
    @pulumi.getter(name="filteringTags")
    def filtering_tags(self) -> Optional[Sequence['outputs.FilteringTagResponse']]:
        """
        List of filtering tags to be used for capturing logs. This only takes effect if SendResourceLogs flag is enabled. If empty, all resources will be captured. If only Exclude action is specified, the rules will apply to the list of all available resources. If Include actions are specified, the rules will only include resources with the associated tags.
        """
        return pulumi.get(self, "filtering_tags")

    @property
    @pulumi.getter(name="sendAadLogs")
    def send_aad_logs(self) -> Optional[bool]:
        """
        Flag specifying if AAD logs should be sent for the Monitor resource.
        """
        return pulumi.get(self, "send_aad_logs")

    @property
    @pulumi.getter(name="sendResourceLogs")
    def send_resource_logs(self) -> Optional[bool]:
        """
        Flag specifying if Azure resource logs should be sent for the Monitor resource.
        """
        return pulumi.get(self, "send_resource_logs")

    @property
    @pulumi.getter(name="sendSubscriptionLogs")
    def send_subscription_logs(self) -> Optional[bool]:
        """
        Flag specifying if Azure subscription logs should be sent for the Monitor resource.
        """
        return pulumi.get(self, "send_subscription_logs")


@pulumi.output_type
class MetricRulesResponse(dict):
    """
    Set of rules for sending metrics for the Monitor resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filteringTags":
            suggest = "filtering_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricRulesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricRulesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricRulesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filtering_tags: Optional[Sequence['outputs.FilteringTagResponse']] = None):
        """
        Set of rules for sending metrics for the Monitor resource.
        :param Sequence['FilteringTagResponse'] filtering_tags: List of filtering tags to be used for capturing metrics. If empty, all resources will be captured. If only Exclude action is specified, the rules will apply to the list of all available resources. If Include actions are specified, the rules will only include resources with the associated tags.
        """
        MetricRulesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filtering_tags=filtering_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filtering_tags: Optional[Sequence['outputs.FilteringTagResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'filteringTags' in kwargs:
            filtering_tags = kwargs['filteringTags']

        if filtering_tags is not None:
            _setter("filtering_tags", filtering_tags)

    @property
    @pulumi.getter(name="filteringTags")
    def filtering_tags(self) -> Optional[Sequence['outputs.FilteringTagResponse']]:
        """
        List of filtering tags to be used for capturing metrics. If empty, all resources will be captured. If only Exclude action is specified, the rules will apply to the list of all available resources. If Include actions are specified, the rules will only include resources with the associated tags.
        """
        return pulumi.get(self, "filtering_tags")


@pulumi.output_type
class MonitorPropertiesResponse(dict):
    """
    Properties specific to the monitor resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liftrResourceCategory":
            suggest = "liftr_resource_category"
        elif key == "liftrResourcePreference":
            suggest = "liftr_resource_preference"
        elif key == "marketplaceSubscriptionStatus":
            suggest = "marketplace_subscription_status"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "datadogOrganizationProperties":
            suggest = "datadog_organization_properties"
        elif key == "monitoringStatus":
            suggest = "monitoring_status"
        elif key == "userInfo":
            suggest = "user_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 liftr_resource_category: str,
                 liftr_resource_preference: int,
                 marketplace_subscription_status: str,
                 provisioning_state: str,
                 datadog_organization_properties: Optional['outputs.DatadogOrganizationPropertiesResponse'] = None,
                 monitoring_status: Optional[str] = None,
                 user_info: Optional['outputs.UserInfoResponse'] = None):
        """
        Properties specific to the monitor resource.
        :param int liftr_resource_preference: The priority of the resource.
        :param str marketplace_subscription_status: Flag specifying the Marketplace Subscription Status of the resource. If payment is not made in time, the resource will go in Suspended state.
        :param 'DatadogOrganizationPropertiesResponse' datadog_organization_properties: Specify the Datadog organization name. In the case of linking to existing organizations, Id, ApiKey, and Applicationkey is required as well.
        :param str monitoring_status: Flag specifying if the resource monitoring is enabled or disabled.
        :param 'UserInfoResponse' user_info: Includes name, email and optionally, phone number. User Information can't be null.
        """
        MonitorPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            liftr_resource_category=liftr_resource_category,
            liftr_resource_preference=liftr_resource_preference,
            marketplace_subscription_status=marketplace_subscription_status,
            provisioning_state=provisioning_state,
            datadog_organization_properties=datadog_organization_properties,
            monitoring_status=monitoring_status,
            user_info=user_info,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             liftr_resource_category: str,
             liftr_resource_preference: int,
             marketplace_subscription_status: str,
             provisioning_state: str,
             datadog_organization_properties: Optional['outputs.DatadogOrganizationPropertiesResponse'] = None,
             monitoring_status: Optional[str] = None,
             user_info: Optional['outputs.UserInfoResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'liftrResourceCategory' in kwargs:
            liftr_resource_category = kwargs['liftrResourceCategory']
        if 'liftrResourcePreference' in kwargs:
            liftr_resource_preference = kwargs['liftrResourcePreference']
        if 'marketplaceSubscriptionStatus' in kwargs:
            marketplace_subscription_status = kwargs['marketplaceSubscriptionStatus']
        if 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if 'datadogOrganizationProperties' in kwargs:
            datadog_organization_properties = kwargs['datadogOrganizationProperties']
        if 'monitoringStatus' in kwargs:
            monitoring_status = kwargs['monitoringStatus']
        if 'userInfo' in kwargs:
            user_info = kwargs['userInfo']

        _setter("liftr_resource_category", liftr_resource_category)
        _setter("liftr_resource_preference", liftr_resource_preference)
        _setter("marketplace_subscription_status", marketplace_subscription_status)
        _setter("provisioning_state", provisioning_state)
        if datadog_organization_properties is not None:
            _setter("datadog_organization_properties", datadog_organization_properties)
        if monitoring_status is not None:
            _setter("monitoring_status", monitoring_status)
        if user_info is not None:
            _setter("user_info", user_info)

    @property
    @pulumi.getter(name="liftrResourceCategory")
    def liftr_resource_category(self) -> str:
        return pulumi.get(self, "liftr_resource_category")

    @property
    @pulumi.getter(name="liftrResourcePreference")
    def liftr_resource_preference(self) -> int:
        """
        The priority of the resource.
        """
        return pulumi.get(self, "liftr_resource_preference")

    @property
    @pulumi.getter(name="marketplaceSubscriptionStatus")
    def marketplace_subscription_status(self) -> str:
        """
        Flag specifying the Marketplace Subscription Status of the resource. If payment is not made in time, the resource will go in Suspended state.
        """
        return pulumi.get(self, "marketplace_subscription_status")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="datadogOrganizationProperties")
    def datadog_organization_properties(self) -> Optional['outputs.DatadogOrganizationPropertiesResponse']:
        """
        Specify the Datadog organization name. In the case of linking to existing organizations, Id, ApiKey, and Applicationkey is required as well.
        """
        return pulumi.get(self, "datadog_organization_properties")

    @property
    @pulumi.getter(name="monitoringStatus")
    def monitoring_status(self) -> Optional[str]:
        """
        Flag specifying if the resource monitoring is enabled or disabled.
        """
        return pulumi.get(self, "monitoring_status")

    @property
    @pulumi.getter(name="userInfo")
    def user_info(self) -> Optional['outputs.UserInfoResponse']:
        """
        Includes name, email and optionally, phone number. User Information can't be null.
        """
        return pulumi.get(self, "user_info")


@pulumi.output_type
class MonitoredResourceResponse(dict):
    """
    The properties of a resource currently being monitored by the Datadog monitor resource.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 reason_for_logs_status: Optional[str] = None,
                 reason_for_metrics_status: Optional[str] = None,
                 sending_logs: Optional[bool] = None,
                 sending_metrics: Optional[bool] = None):
        """
        The properties of a resource currently being monitored by the Datadog monitor resource.
        :param str id: The ARM id of the resource.
        :param str reason_for_logs_status: Reason for why the resource is sending logs (or why it is not sending).
        :param str reason_for_metrics_status: Reason for why the resource is sending metrics (or why it is not sending).
        :param bool sending_logs: Flag indicating if resource is sending logs to Datadog.
        :param bool sending_metrics: Flag indicating if resource is sending metrics to Datadog.
        """
        MonitoredResourceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            reason_for_logs_status=reason_for_logs_status,
            reason_for_metrics_status=reason_for_metrics_status,
            sending_logs=sending_logs,
            sending_metrics=sending_metrics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             reason_for_logs_status: Optional[str] = None,
             reason_for_metrics_status: Optional[str] = None,
             sending_logs: Optional[bool] = None,
             sending_metrics: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'reasonForLogsStatus' in kwargs:
            reason_for_logs_status = kwargs['reasonForLogsStatus']
        if 'reasonForMetricsStatus' in kwargs:
            reason_for_metrics_status = kwargs['reasonForMetricsStatus']
        if 'sendingLogs' in kwargs:
            sending_logs = kwargs['sendingLogs']
        if 'sendingMetrics' in kwargs:
            sending_metrics = kwargs['sendingMetrics']

        if id is not None:
            _setter("id", id)
        if reason_for_logs_status is not None:
            _setter("reason_for_logs_status", reason_for_logs_status)
        if reason_for_metrics_status is not None:
            _setter("reason_for_metrics_status", reason_for_metrics_status)
        if sending_logs is not None:
            _setter("sending_logs", sending_logs)
        if sending_metrics is not None:
            _setter("sending_metrics", sending_metrics)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ARM id of the resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="reasonForLogsStatus")
    def reason_for_logs_status(self) -> Optional[str]:
        """
        Reason for why the resource is sending logs (or why it is not sending).
        """
        return pulumi.get(self, "reason_for_logs_status")

    @property
    @pulumi.getter(name="reasonForMetricsStatus")
    def reason_for_metrics_status(self) -> Optional[str]:
        """
        Reason for why the resource is sending metrics (or why it is not sending).
        """
        return pulumi.get(self, "reason_for_metrics_status")

    @property
    @pulumi.getter(name="sendingLogs")
    def sending_logs(self) -> Optional[bool]:
        """
        Flag indicating if resource is sending logs to Datadog.
        """
        return pulumi.get(self, "sending_logs")

    @property
    @pulumi.getter(name="sendingMetrics")
    def sending_metrics(self) -> Optional[bool]:
        """
        Flag indicating if resource is sending metrics to Datadog.
        """
        return pulumi.get(self, "sending_metrics")


@pulumi.output_type
class MonitoredSubscriptionResponse(dict):
    """
    The list of subscriptions and it's monitoring status by current Datadog monitor.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tagRules":
            suggest = "tag_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoredSubscriptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoredSubscriptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoredSubscriptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: Optional[str] = None,
                 status: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tag_rules: Optional['outputs.MonitoringTagRulesPropertiesResponse'] = None):
        """
        The list of subscriptions and it's monitoring status by current Datadog monitor.
        :param str error: The reason of not monitoring the subscription.
        :param str status: The state of monitoring.
        :param str subscription_id: The subscriptionId to be monitored.
        :param 'MonitoringTagRulesPropertiesResponse' tag_rules: Definition of the properties for a TagRules resource.
        """
        MonitoredSubscriptionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error=error,
            status=status,
            subscription_id=subscription_id,
            tag_rules=tag_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error: Optional[str] = None,
             status: Optional[str] = None,
             subscription_id: Optional[str] = None,
             tag_rules: Optional['outputs.MonitoringTagRulesPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'subscriptionId' in kwargs:
            subscription_id = kwargs['subscriptionId']
        if 'tagRules' in kwargs:
            tag_rules = kwargs['tagRules']

        if error is not None:
            _setter("error", error)
        if status is not None:
            _setter("status", status)
        if subscription_id is not None:
            _setter("subscription_id", subscription_id)
        if tag_rules is not None:
            _setter("tag_rules", tag_rules)

    @property
    @pulumi.getter
    def error(self) -> Optional[str]:
        """
        The reason of not monitoring the subscription.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The state of monitoring.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        The subscriptionId to be monitored.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tagRules")
    def tag_rules(self) -> Optional['outputs.MonitoringTagRulesPropertiesResponse']:
        """
        Definition of the properties for a TagRules resource.
        """
        return pulumi.get(self, "tag_rules")


@pulumi.output_type
class MonitoringTagRulesPropertiesResponse(dict):
    """
    Definition of the properties for a TagRules resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "logRules":
            suggest = "log_rules"
        elif key == "metricRules":
            suggest = "metric_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoringTagRulesPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoringTagRulesPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoringTagRulesPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 automuting: Optional[bool] = None,
                 log_rules: Optional['outputs.LogRulesResponse'] = None,
                 metric_rules: Optional['outputs.MetricRulesResponse'] = None):
        """
        Definition of the properties for a TagRules resource.
        :param bool automuting: Configuration to enable/disable auto-muting flag
        :param 'LogRulesResponse' log_rules: Set of rules for sending logs for the Monitor resource.
        :param 'MetricRulesResponse' metric_rules: Set of rules for sending metrics for the Monitor resource.
        """
        MonitoringTagRulesPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provisioning_state=provisioning_state,
            automuting=automuting,
            log_rules=log_rules,
            metric_rules=metric_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provisioning_state: str,
             automuting: Optional[bool] = None,
             log_rules: Optional['outputs.LogRulesResponse'] = None,
             metric_rules: Optional['outputs.MetricRulesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if 'logRules' in kwargs:
            log_rules = kwargs['logRules']
        if 'metricRules' in kwargs:
            metric_rules = kwargs['metricRules']

        _setter("provisioning_state", provisioning_state)
        if automuting is not None:
            _setter("automuting", automuting)
        if log_rules is not None:
            _setter("log_rules", log_rules)
        if metric_rules is not None:
            _setter("metric_rules", metric_rules)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def automuting(self) -> Optional[bool]:
        """
        Configuration to enable/disable auto-muting flag
        """
        return pulumi.get(self, "automuting")

    @property
    @pulumi.getter(name="logRules")
    def log_rules(self) -> Optional['outputs.LogRulesResponse']:
        """
        Set of rules for sending logs for the Monitor resource.
        """
        return pulumi.get(self, "log_rules")

    @property
    @pulumi.getter(name="metricRules")
    def metric_rules(self) -> Optional['outputs.MetricRulesResponse']:
        """
        Set of rules for sending metrics for the Monitor resource.
        """
        return pulumi.get(self, "metric_rules")


@pulumi.output_type
class ResourceSkuResponse(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Name of the SKU in {PlanId} format. For Terraform, the only allowed value is 'linking'.
        """
        ResourceSkuResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the SKU in {PlanId} format. For Terraform, the only allowed value is 'linking'.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SubscriptionListResponse(dict):
    """
    The request to update subscriptions needed to be monitored by the Datadog monitor resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitoredSubscriptionList":
            suggest = "monitored_subscription_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionListResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionListResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionListResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitored_subscription_list: Optional[Sequence['outputs.MonitoredSubscriptionResponse']] = None):
        """
        The request to update subscriptions needed to be monitored by the Datadog monitor resource.
        :param Sequence['MonitoredSubscriptionResponse'] monitored_subscription_list: List of subscriptions and the state of the monitoring.
        """
        SubscriptionListResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            monitored_subscription_list=monitored_subscription_list,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             monitored_subscription_list: Optional[Sequence['outputs.MonitoredSubscriptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'monitoredSubscriptionList' in kwargs:
            monitored_subscription_list = kwargs['monitoredSubscriptionList']

        if monitored_subscription_list is not None:
            _setter("monitored_subscription_list", monitored_subscription_list)

    @property
    @pulumi.getter(name="monitoredSubscriptionList")
    def monitored_subscription_list(self) -> Optional[Sequence['outputs.MonitoredSubscriptionResponse']]:
        """
        List of subscriptions and the state of the monitoring.
        """
        return pulumi.get(self, "monitored_subscription_list")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UserInfoResponse(dict):
    """
    Includes name, email and optionally, phone number. User Information can't be null.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailAddress":
            suggest = "email_address"
        elif key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_address: Optional[str] = None,
                 name: Optional[str] = None,
                 phone_number: Optional[str] = None):
        """
        Includes name, email and optionally, phone number. User Information can't be null.
        :param str email_address: Email of the user used by Datadog for contacting them if needed
        :param str name: Name of the user
        :param str phone_number: Phone number of the user used by Datadog for contacting them if needed
        """
        UserInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email_address=email_address,
            name=name,
            phone_number=phone_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email_address: Optional[str] = None,
             name: Optional[str] = None,
             phone_number: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'emailAddress' in kwargs:
            email_address = kwargs['emailAddress']
        if 'phoneNumber' in kwargs:
            phone_number = kwargs['phoneNumber']

        if email_address is not None:
            _setter("email_address", email_address)
        if name is not None:
            _setter("name", name)
        if phone_number is not None:
            _setter("phone_number", phone_number)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[str]:
        """
        Email of the user used by Datadog for contacting them if needed
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the user
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[str]:
        """
        Phone number of the user used by Datadog for contacting them if needed
        """
        return pulumi.get(self, "phone_number")


