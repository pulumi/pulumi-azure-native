# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AksClusterProfileResponseAksClusterAgentPoolIdentityProfile',
    'AuthorizationProfileResponse',
    'AutoscaleProfileResponse',
    'CatalogOptionsResponse',
    'ClusterConfigFileResponse',
    'ClusterLogAnalyticsApplicationLogsResponse',
    'ClusterLogAnalyticsProfileResponse',
    'ClusterPoolResourcePropertiesResponseAksClusterProfile',
    'ClusterPoolResourcePropertiesResponseClusterPoolProfile',
    'ClusterPoolResourcePropertiesResponseComputeProfile',
    'ClusterPoolResourcePropertiesResponseLogAnalyticsProfile',
    'ClusterPoolResourcePropertiesResponseNetworkProfile',
    'ClusterProfileResponse',
    'ClusterProfileResponseComponents',
    'ClusterPrometheusProfileResponse',
    'ClusterServiceConfigResponse',
    'ClusterServiceConfigsProfileResponse',
    'ComparisonRuleResponse',
    'ComputeProfileResponse',
    'ComputeResourceDefinitionResponse',
    'ConnectivityProfileResponse',
    'ConnectivityProfileResponseWeb',
    'FlinkCatalogOptionsResponse',
    'FlinkHiveCatalogOptionResponse',
    'FlinkProfileResponse',
    'FlinkStorageProfileResponse',
    'HiveCatalogOptionResponse',
    'IdentityProfileResponse',
    'LoadBasedConfigResponse',
    'NodeProfileResponse',
    'ScalingRuleResponse',
    'ScheduleBasedConfigResponse',
    'ScheduleResponse',
    'ScriptActionProfileResponse',
    'SecretReferenceResponse',
    'SecretsProfileResponse',
    'SparkMetastoreSpecResponse',
    'SparkProfileResponse',
    'SparkUserPluginResponse',
    'SparkUserPluginsResponse',
    'SshConnectivityEndpointResponse',
    'SshProfileResponse',
    'SystemDataResponse',
    'TrinoCoordinatorResponse',
    'TrinoProfileResponse',
    'TrinoTelemetryConfigResponse',
    'TrinoUserPluginResponse',
    'TrinoUserPluginsResponse',
    'TrinoUserTelemetryResponse',
    'TrinoWorkerResponse',
]

@pulumi.output_type
class AksClusterProfileResponseAksClusterAgentPoolIdentityProfile(dict):
    """
    Identity properties of the AKS cluster agentpool MSI
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "msiClientId":
            suggest = "msi_client_id"
        elif key == "msiObjectId":
            suggest = "msi_object_id"
        elif key == "msiResourceId":
            suggest = "msi_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AksClusterProfileResponseAksClusterAgentPoolIdentityProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AksClusterProfileResponseAksClusterAgentPoolIdentityProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AksClusterProfileResponseAksClusterAgentPoolIdentityProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 msi_client_id: str,
                 msi_object_id: str,
                 msi_resource_id: str):
        """
        Identity properties of the AKS cluster agentpool MSI
        :param str msi_client_id: ClientId of the MSI.
        :param str msi_object_id: ObjectId of the MSI.
        :param str msi_resource_id: ResourceId of the MSI.
        """
        AksClusterProfileResponseAksClusterAgentPoolIdentityProfile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            msi_client_id=msi_client_id,
            msi_object_id=msi_object_id,
            msi_resource_id=msi_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             msi_client_id: str,
             msi_object_id: str,
             msi_resource_id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'msiClientId' in kwargs:
            msi_client_id = kwargs['msiClientId']
        if 'msiObjectId' in kwargs:
            msi_object_id = kwargs['msiObjectId']
        if 'msiResourceId' in kwargs:
            msi_resource_id = kwargs['msiResourceId']

        _setter("msi_client_id", msi_client_id)
        _setter("msi_object_id", msi_object_id)
        _setter("msi_resource_id", msi_resource_id)

    @property
    @pulumi.getter(name="msiClientId")
    def msi_client_id(self) -> str:
        """
        ClientId of the MSI.
        """
        return pulumi.get(self, "msi_client_id")

    @property
    @pulumi.getter(name="msiObjectId")
    def msi_object_id(self) -> str:
        """
        ObjectId of the MSI.
        """
        return pulumi.get(self, "msi_object_id")

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> str:
        """
        ResourceId of the MSI.
        """
        return pulumi.get(self, "msi_resource_id")


@pulumi.output_type
class AuthorizationProfileResponse(dict):
    """
    Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "userIds":
            suggest = "user_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizationProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizationProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizationProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Optional[Sequence[str]] = None,
                 user_ids: Optional[Sequence[str]] = None):
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        :param Sequence[str] group_ids: AAD group Ids authorized for data plane access.
        :param Sequence[str] user_ids: AAD user Ids authorized for data plane access.
        """
        AuthorizationProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_ids=group_ids,
            user_ids=user_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_ids: Optional[Sequence[str]] = None,
             user_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'groupIds' in kwargs:
            group_ids = kwargs['groupIds']
        if 'userIds' in kwargs:
            user_ids = kwargs['userIds']

        if group_ids is not None:
            _setter("group_ids", group_ids)
        if user_ids is not None:
            _setter("user_ids", user_ids)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[Sequence[str]]:
        """
        AAD group Ids authorized for data plane access.
        """
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[Sequence[str]]:
        """
        AAD user Ids authorized for data plane access.
        """
        return pulumi.get(self, "user_ids")


@pulumi.output_type
class AutoscaleProfileResponse(dict):
    """
    This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscaleType":
            suggest = "autoscale_type"
        elif key == "gracefulDecommissionTimeout":
            suggest = "graceful_decommission_timeout"
        elif key == "loadBasedConfig":
            suggest = "load_based_config"
        elif key == "scheduleBasedConfig":
            suggest = "schedule_based_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscaleProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscaleProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscaleProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 autoscale_type: Optional[str] = None,
                 graceful_decommission_timeout: Optional[int] = None,
                 load_based_config: Optional['outputs.LoadBasedConfigResponse'] = None,
                 schedule_based_config: Optional['outputs.ScheduleBasedConfigResponse'] = None):
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        :param bool enabled: This indicates whether auto scale is enabled on HDInsight on AKS cluster.
        :param str autoscale_type: User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        :param int graceful_decommission_timeout: This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        :param 'LoadBasedConfigResponse' load_based_config: Profiles of load based Autoscale.
        :param 'ScheduleBasedConfigResponse' schedule_based_config: Profiles of schedule based Autoscale.
        """
        AutoscaleProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            autoscale_type=autoscale_type,
            graceful_decommission_timeout=graceful_decommission_timeout,
            load_based_config=load_based_config,
            schedule_based_config=schedule_based_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             autoscale_type: Optional[str] = None,
             graceful_decommission_timeout: Optional[int] = None,
             load_based_config: Optional['outputs.LoadBasedConfigResponse'] = None,
             schedule_based_config: Optional['outputs.ScheduleBasedConfigResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'autoscaleType' in kwargs:
            autoscale_type = kwargs['autoscaleType']
        if 'gracefulDecommissionTimeout' in kwargs:
            graceful_decommission_timeout = kwargs['gracefulDecommissionTimeout']
        if 'loadBasedConfig' in kwargs:
            load_based_config = kwargs['loadBasedConfig']
        if 'scheduleBasedConfig' in kwargs:
            schedule_based_config = kwargs['scheduleBasedConfig']

        _setter("enabled", enabled)
        if autoscale_type is not None:
            _setter("autoscale_type", autoscale_type)
        if graceful_decommission_timeout is not None:
            _setter("graceful_decommission_timeout", graceful_decommission_timeout)
        if load_based_config is not None:
            _setter("load_based_config", load_based_config)
        if schedule_based_config is not None:
            _setter("schedule_based_config", schedule_based_config)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This indicates whether auto scale is enabled on HDInsight on AKS cluster.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="autoscaleType")
    def autoscale_type(self) -> Optional[str]:
        """
        User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        """
        return pulumi.get(self, "autoscale_type")

    @property
    @pulumi.getter(name="gracefulDecommissionTimeout")
    def graceful_decommission_timeout(self) -> Optional[int]:
        """
        This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        """
        return pulumi.get(self, "graceful_decommission_timeout")

    @property
    @pulumi.getter(name="loadBasedConfig")
    def load_based_config(self) -> Optional['outputs.LoadBasedConfigResponse']:
        """
        Profiles of load based Autoscale.
        """
        return pulumi.get(self, "load_based_config")

    @property
    @pulumi.getter(name="scheduleBasedConfig")
    def schedule_based_config(self) -> Optional['outputs.ScheduleBasedConfigResponse']:
        """
        Profiles of schedule based Autoscale.
        """
        return pulumi.get(self, "schedule_based_config")


@pulumi.output_type
class CatalogOptionsResponse(dict):
    """
    Trino cluster catalog options.
    """
    def __init__(__self__, *,
                 hive: Optional[Sequence['outputs.HiveCatalogOptionResponse']] = None):
        """
        Trino cluster catalog options.
        :param Sequence['HiveCatalogOptionResponse'] hive: hive catalog options.
        """
        CatalogOptionsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hive=hive,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hive: Optional[Sequence['outputs.HiveCatalogOptionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if hive is not None:
            _setter("hive", hive)

    @property
    @pulumi.getter
    def hive(self) -> Optional[Sequence['outputs.HiveCatalogOptionResponse']]:
        """
        hive catalog options.
        """
        return pulumi.get(self, "hive")


@pulumi.output_type
class ClusterConfigFileResponse(dict):
    """
    Cluster configuration files.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileName":
            suggest = "file_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConfigFileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConfigFileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConfigFileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_name: str,
                 content: Optional[str] = None,
                 encoding: Optional[str] = None,
                 path: Optional[str] = None,
                 values: Optional[Mapping[str, str]] = None):
        """
        Cluster configuration files.
        :param str file_name: Configuration file name.
        :param str content: Free form content of the entire configuration file.
        :param str encoding: This property indicates if the content is encoded and is case-insensitive. Please set the value to base64 if the content is base64 encoded. Set it to none or skip it if the content is plain text.
        :param str path: Path of the config file if content is specified.
        :param Mapping[str, str] values: List of key value pairs
               where key represents a valid service configuration name and value represents the value of the config.
        """
        ClusterConfigFileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file_name=file_name,
            content=content,
            encoding=encoding,
            path=path,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file_name: str,
             content: Optional[str] = None,
             encoding: Optional[str] = None,
             path: Optional[str] = None,
             values: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'fileName' in kwargs:
            file_name = kwargs['fileName']

        _setter("file_name", file_name)
        if content is not None:
            _setter("content", content)
        if encoding is not None:
            _setter("encoding", encoding)
        if path is not None:
            _setter("path", path)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> str:
        """
        Configuration file name.
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        Free form content of the entire configuration file.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        This property indicates if the content is encoded and is case-insensitive. Please set the value to base64 if the content is base64 encoded. Set it to none or skip it if the content is plain text.
        """
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path of the config file if content is specified.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def values(self) -> Optional[Mapping[str, str]]:
        """
        List of key value pairs
        where key represents a valid service configuration name and value represents the value of the config.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterLogAnalyticsApplicationLogsResponse(dict):
    """
    Collection of logs to be enabled or disabled for log analytics.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stdErrorEnabled":
            suggest = "std_error_enabled"
        elif key == "stdOutEnabled":
            suggest = "std_out_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterLogAnalyticsApplicationLogsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterLogAnalyticsApplicationLogsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterLogAnalyticsApplicationLogsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 std_error_enabled: Optional[bool] = None,
                 std_out_enabled: Optional[bool] = None):
        """
        Collection of logs to be enabled or disabled for log analytics.
        :param bool std_error_enabled: True if stderror is enabled, otherwise false.
        :param bool std_out_enabled: True if stdout is enabled, otherwise false.
        """
        ClusterLogAnalyticsApplicationLogsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            std_error_enabled=std_error_enabled,
            std_out_enabled=std_out_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             std_error_enabled: Optional[bool] = None,
             std_out_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'stdErrorEnabled' in kwargs:
            std_error_enabled = kwargs['stdErrorEnabled']
        if 'stdOutEnabled' in kwargs:
            std_out_enabled = kwargs['stdOutEnabled']

        if std_error_enabled is not None:
            _setter("std_error_enabled", std_error_enabled)
        if std_out_enabled is not None:
            _setter("std_out_enabled", std_out_enabled)

    @property
    @pulumi.getter(name="stdErrorEnabled")
    def std_error_enabled(self) -> Optional[bool]:
        """
        True if stderror is enabled, otherwise false.
        """
        return pulumi.get(self, "std_error_enabled")

    @property
    @pulumi.getter(name="stdOutEnabled")
    def std_out_enabled(self) -> Optional[bool]:
        """
        True if stdout is enabled, otherwise false.
        """
        return pulumi.get(self, "std_out_enabled")


@pulumi.output_type
class ClusterLogAnalyticsProfileResponse(dict):
    """
    Cluster log analytics profile to enable or disable OMS agent for cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "metricsEnabled":
            suggest = "metrics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterLogAnalyticsProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterLogAnalyticsProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterLogAnalyticsProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 application_logs: Optional['outputs.ClusterLogAnalyticsApplicationLogsResponse'] = None,
                 metrics_enabled: Optional[bool] = None):
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        :param bool enabled: True if log analytics is enabled for the cluster, otherwise false.
        :param 'ClusterLogAnalyticsApplicationLogsResponse' application_logs: Collection of logs to be enabled or disabled for log analytics.
        :param bool metrics_enabled: True if metrics are enabled, otherwise false.
        """
        ClusterLogAnalyticsProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            application_logs=application_logs,
            metrics_enabled=metrics_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             application_logs: Optional['outputs.ClusterLogAnalyticsApplicationLogsResponse'] = None,
             metrics_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'applicationLogs' in kwargs:
            application_logs = kwargs['applicationLogs']
        if 'metricsEnabled' in kwargs:
            metrics_enabled = kwargs['metricsEnabled']

        _setter("enabled", enabled)
        if application_logs is not None:
            _setter("application_logs", application_logs)
        if metrics_enabled is not None:
            _setter("metrics_enabled", metrics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if log analytics is enabled for the cluster, otherwise false.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.ClusterLogAnalyticsApplicationLogsResponse']:
        """
        Collection of logs to be enabled or disabled for log analytics.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="metricsEnabled")
    def metrics_enabled(self) -> Optional[bool]:
        """
        True if metrics are enabled, otherwise false.
        """
        return pulumi.get(self, "metrics_enabled")


@pulumi.output_type
class ClusterPoolResourcePropertiesResponseAksClusterProfile(dict):
    """
    Properties of underlying AKS cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aksVersion":
            suggest = "aks_version"
        elif key == "aksClusterAgentPoolIdentityProfile":
            suggest = "aks_cluster_agent_pool_identity_profile"
        elif key == "aksClusterResourceId":
            suggest = "aks_cluster_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPoolResourcePropertiesResponseAksClusterProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPoolResourcePropertiesResponseAksClusterProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPoolResourcePropertiesResponseAksClusterProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aks_version: str,
                 aks_cluster_agent_pool_identity_profile: Optional['outputs.AksClusterProfileResponseAksClusterAgentPoolIdentityProfile'] = None,
                 aks_cluster_resource_id: Optional[str] = None):
        """
        Properties of underlying AKS cluster.
        :param str aks_version: AKS control plane and default node pool version of this ClusterPool
        :param 'AksClusterProfileResponseAksClusterAgentPoolIdentityProfile' aks_cluster_agent_pool_identity_profile: Identity properties of the AKS cluster agentpool MSI
        :param str aks_cluster_resource_id: ARM Resource ID of the AKS cluster
        """
        ClusterPoolResourcePropertiesResponseAksClusterProfile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aks_version=aks_version,
            aks_cluster_agent_pool_identity_profile=aks_cluster_agent_pool_identity_profile,
            aks_cluster_resource_id=aks_cluster_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aks_version: str,
             aks_cluster_agent_pool_identity_profile: Optional['outputs.AksClusterProfileResponseAksClusterAgentPoolIdentityProfile'] = None,
             aks_cluster_resource_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'aksVersion' in kwargs:
            aks_version = kwargs['aksVersion']
        if 'aksClusterAgentPoolIdentityProfile' in kwargs:
            aks_cluster_agent_pool_identity_profile = kwargs['aksClusterAgentPoolIdentityProfile']
        if 'aksClusterResourceId' in kwargs:
            aks_cluster_resource_id = kwargs['aksClusterResourceId']

        _setter("aks_version", aks_version)
        if aks_cluster_agent_pool_identity_profile is not None:
            _setter("aks_cluster_agent_pool_identity_profile", aks_cluster_agent_pool_identity_profile)
        if aks_cluster_resource_id is not None:
            _setter("aks_cluster_resource_id", aks_cluster_resource_id)

    @property
    @pulumi.getter(name="aksVersion")
    def aks_version(self) -> str:
        """
        AKS control plane and default node pool version of this ClusterPool
        """
        return pulumi.get(self, "aks_version")

    @property
    @pulumi.getter(name="aksClusterAgentPoolIdentityProfile")
    def aks_cluster_agent_pool_identity_profile(self) -> Optional['outputs.AksClusterProfileResponseAksClusterAgentPoolIdentityProfile']:
        """
        Identity properties of the AKS cluster agentpool MSI
        """
        return pulumi.get(self, "aks_cluster_agent_pool_identity_profile")

    @property
    @pulumi.getter(name="aksClusterResourceId")
    def aks_cluster_resource_id(self) -> Optional[str]:
        """
        ARM Resource ID of the AKS cluster
        """
        return pulumi.get(self, "aks_cluster_resource_id")


@pulumi.output_type
class ClusterPoolResourcePropertiesResponseClusterPoolProfile(dict):
    """
    CLuster pool profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterPoolVersion":
            suggest = "cluster_pool_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPoolResourcePropertiesResponseClusterPoolProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPoolResourcePropertiesResponseClusterPoolProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPoolResourcePropertiesResponseClusterPoolProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_pool_version: str):
        """
        CLuster pool profile.
        :param str cluster_pool_version: Cluster pool version is a 2-part version.
        """
        ClusterPoolResourcePropertiesResponseClusterPoolProfile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_pool_version=cluster_pool_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_pool_version: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clusterPoolVersion' in kwargs:
            cluster_pool_version = kwargs['clusterPoolVersion']

        _setter("cluster_pool_version", cluster_pool_version)

    @property
    @pulumi.getter(name="clusterPoolVersion")
    def cluster_pool_version(self) -> str:
        """
        Cluster pool version is a 2-part version.
        """
        return pulumi.get(self, "cluster_pool_version")


@pulumi.output_type
class ClusterPoolResourcePropertiesResponseComputeProfile(dict):
    """
    CLuster pool compute profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPoolResourcePropertiesResponseComputeProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPoolResourcePropertiesResponseComputeProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPoolResourcePropertiesResponseComputeProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 vm_size: str):
        """
        CLuster pool compute profile.
        :param int count: The number of virtual machines.
        :param str vm_size: The virtual machine SKU.
        """
        ClusterPoolResourcePropertiesResponseComputeProfile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            vm_size=vm_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: int,
             vm_size: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'vmSize' in kwargs:
            vm_size = kwargs['vmSize']

        _setter("count", count)
        _setter("vm_size", vm_size)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of virtual machines.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The virtual machine SKU.
        """
        return pulumi.get(self, "vm_size")


@pulumi.output_type
class ClusterPoolResourcePropertiesResponseLogAnalyticsProfile(dict):
    """
    Cluster pool log analytics profile to enable OMS agent for AKS cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPoolResourcePropertiesResponseLogAnalyticsProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPoolResourcePropertiesResponseLogAnalyticsProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPoolResourcePropertiesResponseLogAnalyticsProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 workspace_id: Optional[str] = None):
        """
        Cluster pool log analytics profile to enable OMS agent for AKS cluster.
        :param bool enabled: True if log analytics is enabled for cluster pool, otherwise false.
        :param str workspace_id: Log analytics workspace to associate with the OMS agent.
        """
        ClusterPoolResourcePropertiesResponseLogAnalyticsProfile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            workspace_id=workspace_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             workspace_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'workspaceId' in kwargs:
            workspace_id = kwargs['workspaceId']

        _setter("enabled", enabled)
        if workspace_id is not None:
            _setter("workspace_id", workspace_id)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if log analytics is enabled for cluster pool, otherwise false.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> Optional[str]:
        """
        Log analytics workspace to associate with the OMS agent.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class ClusterPoolResourcePropertiesResponseNetworkProfile(dict):
    """
    Cluster pool network profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPoolResourcePropertiesResponseNetworkProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPoolResourcePropertiesResponseNetworkProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPoolResourcePropertiesResponseNetworkProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: str):
        """
        Cluster pool network profile.
        :param str subnet_id: Cluster pool subnet resource id.
        """
        ClusterPoolResourcePropertiesResponseNetworkProfile._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet_id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']

        _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        Cluster pool subnet resource id.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class ClusterProfileResponse(dict):
    """
    Cluster profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationProfile":
            suggest = "authorization_profile"
        elif key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "connectivityProfile":
            suggest = "connectivity_profile"
        elif key == "identityProfile":
            suggest = "identity_profile"
        elif key == "ossVersion":
            suggest = "oss_version"
        elif key == "autoscaleProfile":
            suggest = "autoscale_profile"
        elif key == "flinkProfile":
            suggest = "flink_profile"
        elif key == "kafkaProfile":
            suggest = "kafka_profile"
        elif key == "llapProfile":
            suggest = "llap_profile"
        elif key == "logAnalyticsProfile":
            suggest = "log_analytics_profile"
        elif key == "prometheusProfile":
            suggest = "prometheus_profile"
        elif key == "scriptActionProfiles":
            suggest = "script_action_profiles"
        elif key == "secretsProfile":
            suggest = "secrets_profile"
        elif key == "serviceConfigsProfiles":
            suggest = "service_configs_profiles"
        elif key == "sparkProfile":
            suggest = "spark_profile"
        elif key == "sshProfile":
            suggest = "ssh_profile"
        elif key == "stubProfile":
            suggest = "stub_profile"
        elif key == "trinoProfile":
            suggest = "trino_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_profile: 'outputs.AuthorizationProfileResponse',
                 cluster_version: str,
                 components: Sequence['outputs.ClusterProfileResponseComponents'],
                 connectivity_profile: 'outputs.ConnectivityProfileResponse',
                 identity_profile: 'outputs.IdentityProfileResponse',
                 oss_version: str,
                 autoscale_profile: Optional['outputs.AutoscaleProfileResponse'] = None,
                 flink_profile: Optional['outputs.FlinkProfileResponse'] = None,
                 kafka_profile: Optional[Any] = None,
                 llap_profile: Optional[Any] = None,
                 log_analytics_profile: Optional['outputs.ClusterLogAnalyticsProfileResponse'] = None,
                 prometheus_profile: Optional['outputs.ClusterPrometheusProfileResponse'] = None,
                 script_action_profiles: Optional[Sequence['outputs.ScriptActionProfileResponse']] = None,
                 secrets_profile: Optional['outputs.SecretsProfileResponse'] = None,
                 service_configs_profiles: Optional[Sequence['outputs.ClusterServiceConfigsProfileResponse']] = None,
                 spark_profile: Optional['outputs.SparkProfileResponse'] = None,
                 ssh_profile: Optional['outputs.SshProfileResponse'] = None,
                 stub_profile: Optional[Any] = None,
                 trino_profile: Optional['outputs.TrinoProfileResponse'] = None):
        """
        Cluster profile.
        :param 'AuthorizationProfileResponse' authorization_profile: Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        :param str cluster_version: Version with 3/4 part.
        :param Sequence['ClusterProfileResponseComponents'] components: Component list of this cluster type and version.
        :param 'ConnectivityProfileResponse' connectivity_profile: Cluster connectivity profile.
        :param 'IdentityProfileResponse' identity_profile: Identity Profile with details of an MSI.
        :param str oss_version: Version with three part.
        :param 'AutoscaleProfileResponse' autoscale_profile: This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        :param 'FlinkProfileResponse' flink_profile: The Flink cluster profile.
        :param Any kafka_profile: Kafka cluster profile.
        :param Any llap_profile: LLAP cluster profile.
        :param 'ClusterLogAnalyticsProfileResponse' log_analytics_profile: Cluster log analytics profile to enable or disable OMS agent for cluster.
        :param 'ClusterPrometheusProfileResponse' prometheus_profile: Cluster Prometheus profile.
        :param Sequence['ScriptActionProfileResponse'] script_action_profiles: The script action profile list.
        :param 'SecretsProfileResponse' secrets_profile: The cluster secret profile.
        :param Sequence['ClusterServiceConfigsProfileResponse'] service_configs_profiles: The service configs profiles.
        :param 'SparkProfileResponse' spark_profile: The spark cluster profile.
        :param 'SshProfileResponse' ssh_profile: Ssh profile for the cluster.
        :param Any stub_profile: Stub cluster profile.
        :param 'TrinoProfileResponse' trino_profile: Trino Cluster profile.
        """
        ClusterProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorization_profile=authorization_profile,
            cluster_version=cluster_version,
            components=components,
            connectivity_profile=connectivity_profile,
            identity_profile=identity_profile,
            oss_version=oss_version,
            autoscale_profile=autoscale_profile,
            flink_profile=flink_profile,
            kafka_profile=kafka_profile,
            llap_profile=llap_profile,
            log_analytics_profile=log_analytics_profile,
            prometheus_profile=prometheus_profile,
            script_action_profiles=script_action_profiles,
            secrets_profile=secrets_profile,
            service_configs_profiles=service_configs_profiles,
            spark_profile=spark_profile,
            ssh_profile=ssh_profile,
            stub_profile=stub_profile,
            trino_profile=trino_profile,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorization_profile: 'outputs.AuthorizationProfileResponse',
             cluster_version: str,
             components: Sequence['outputs.ClusterProfileResponseComponents'],
             connectivity_profile: 'outputs.ConnectivityProfileResponse',
             identity_profile: 'outputs.IdentityProfileResponse',
             oss_version: str,
             autoscale_profile: Optional['outputs.AutoscaleProfileResponse'] = None,
             flink_profile: Optional['outputs.FlinkProfileResponse'] = None,
             kafka_profile: Optional[Any] = None,
             llap_profile: Optional[Any] = None,
             log_analytics_profile: Optional['outputs.ClusterLogAnalyticsProfileResponse'] = None,
             prometheus_profile: Optional['outputs.ClusterPrometheusProfileResponse'] = None,
             script_action_profiles: Optional[Sequence['outputs.ScriptActionProfileResponse']] = None,
             secrets_profile: Optional['outputs.SecretsProfileResponse'] = None,
             service_configs_profiles: Optional[Sequence['outputs.ClusterServiceConfigsProfileResponse']] = None,
             spark_profile: Optional['outputs.SparkProfileResponse'] = None,
             ssh_profile: Optional['outputs.SshProfileResponse'] = None,
             stub_profile: Optional[Any] = None,
             trino_profile: Optional['outputs.TrinoProfileResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'authorizationProfile' in kwargs:
            authorization_profile = kwargs['authorizationProfile']
        if 'clusterVersion' in kwargs:
            cluster_version = kwargs['clusterVersion']
        if 'connectivityProfile' in kwargs:
            connectivity_profile = kwargs['connectivityProfile']
        if 'identityProfile' in kwargs:
            identity_profile = kwargs['identityProfile']
        if 'ossVersion' in kwargs:
            oss_version = kwargs['ossVersion']
        if 'autoscaleProfile' in kwargs:
            autoscale_profile = kwargs['autoscaleProfile']
        if 'flinkProfile' in kwargs:
            flink_profile = kwargs['flinkProfile']
        if 'kafkaProfile' in kwargs:
            kafka_profile = kwargs['kafkaProfile']
        if 'llapProfile' in kwargs:
            llap_profile = kwargs['llapProfile']
        if 'logAnalyticsProfile' in kwargs:
            log_analytics_profile = kwargs['logAnalyticsProfile']
        if 'prometheusProfile' in kwargs:
            prometheus_profile = kwargs['prometheusProfile']
        if 'scriptActionProfiles' in kwargs:
            script_action_profiles = kwargs['scriptActionProfiles']
        if 'secretsProfile' in kwargs:
            secrets_profile = kwargs['secretsProfile']
        if 'serviceConfigsProfiles' in kwargs:
            service_configs_profiles = kwargs['serviceConfigsProfiles']
        if 'sparkProfile' in kwargs:
            spark_profile = kwargs['sparkProfile']
        if 'sshProfile' in kwargs:
            ssh_profile = kwargs['sshProfile']
        if 'stubProfile' in kwargs:
            stub_profile = kwargs['stubProfile']
        if 'trinoProfile' in kwargs:
            trino_profile = kwargs['trinoProfile']

        _setter("authorization_profile", authorization_profile)
        _setter("cluster_version", cluster_version)
        _setter("components", components)
        _setter("connectivity_profile", connectivity_profile)
        _setter("identity_profile", identity_profile)
        _setter("oss_version", oss_version)
        if autoscale_profile is not None:
            _setter("autoscale_profile", autoscale_profile)
        if flink_profile is not None:
            _setter("flink_profile", flink_profile)
        if kafka_profile is not None:
            _setter("kafka_profile", kafka_profile)
        if llap_profile is not None:
            _setter("llap_profile", llap_profile)
        if log_analytics_profile is not None:
            _setter("log_analytics_profile", log_analytics_profile)
        if prometheus_profile is not None:
            _setter("prometheus_profile", prometheus_profile)
        if script_action_profiles is not None:
            _setter("script_action_profiles", script_action_profiles)
        if secrets_profile is not None:
            _setter("secrets_profile", secrets_profile)
        if service_configs_profiles is not None:
            _setter("service_configs_profiles", service_configs_profiles)
        if spark_profile is not None:
            _setter("spark_profile", spark_profile)
        if ssh_profile is not None:
            _setter("ssh_profile", ssh_profile)
        if stub_profile is not None:
            _setter("stub_profile", stub_profile)
        if trino_profile is not None:
            _setter("trino_profile", trino_profile)

    @property
    @pulumi.getter(name="authorizationProfile")
    def authorization_profile(self) -> 'outputs.AuthorizationProfileResponse':
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        """
        return pulumi.get(self, "authorization_profile")

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> str:
        """
        Version with 3/4 part.
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter
    def components(self) -> Sequence['outputs.ClusterProfileResponseComponents']:
        """
        Component list of this cluster type and version.
        """
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="connectivityProfile")
    def connectivity_profile(self) -> 'outputs.ConnectivityProfileResponse':
        """
        Cluster connectivity profile.
        """
        return pulumi.get(self, "connectivity_profile")

    @property
    @pulumi.getter(name="identityProfile")
    def identity_profile(self) -> 'outputs.IdentityProfileResponse':
        """
        Identity Profile with details of an MSI.
        """
        return pulumi.get(self, "identity_profile")

    @property
    @pulumi.getter(name="ossVersion")
    def oss_version(self) -> str:
        """
        Version with three part.
        """
        return pulumi.get(self, "oss_version")

    @property
    @pulumi.getter(name="autoscaleProfile")
    def autoscale_profile(self) -> Optional['outputs.AutoscaleProfileResponse']:
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        """
        return pulumi.get(self, "autoscale_profile")

    @property
    @pulumi.getter(name="flinkProfile")
    def flink_profile(self) -> Optional['outputs.FlinkProfileResponse']:
        """
        The Flink cluster profile.
        """
        return pulumi.get(self, "flink_profile")

    @property
    @pulumi.getter(name="kafkaProfile")
    def kafka_profile(self) -> Optional[Any]:
        """
        Kafka cluster profile.
        """
        return pulumi.get(self, "kafka_profile")

    @property
    @pulumi.getter(name="llapProfile")
    def llap_profile(self) -> Optional[Any]:
        """
        LLAP cluster profile.
        """
        return pulumi.get(self, "llap_profile")

    @property
    @pulumi.getter(name="logAnalyticsProfile")
    def log_analytics_profile(self) -> Optional['outputs.ClusterLogAnalyticsProfileResponse']:
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        """
        return pulumi.get(self, "log_analytics_profile")

    @property
    @pulumi.getter(name="prometheusProfile")
    def prometheus_profile(self) -> Optional['outputs.ClusterPrometheusProfileResponse']:
        """
        Cluster Prometheus profile.
        """
        return pulumi.get(self, "prometheus_profile")

    @property
    @pulumi.getter(name="scriptActionProfiles")
    def script_action_profiles(self) -> Optional[Sequence['outputs.ScriptActionProfileResponse']]:
        """
        The script action profile list.
        """
        return pulumi.get(self, "script_action_profiles")

    @property
    @pulumi.getter(name="secretsProfile")
    def secrets_profile(self) -> Optional['outputs.SecretsProfileResponse']:
        """
        The cluster secret profile.
        """
        return pulumi.get(self, "secrets_profile")

    @property
    @pulumi.getter(name="serviceConfigsProfiles")
    def service_configs_profiles(self) -> Optional[Sequence['outputs.ClusterServiceConfigsProfileResponse']]:
        """
        The service configs profiles.
        """
        return pulumi.get(self, "service_configs_profiles")

    @property
    @pulumi.getter(name="sparkProfile")
    def spark_profile(self) -> Optional['outputs.SparkProfileResponse']:
        """
        The spark cluster profile.
        """
        return pulumi.get(self, "spark_profile")

    @property
    @pulumi.getter(name="sshProfile")
    def ssh_profile(self) -> Optional['outputs.SshProfileResponse']:
        """
        Ssh profile for the cluster.
        """
        return pulumi.get(self, "ssh_profile")

    @property
    @pulumi.getter(name="stubProfile")
    def stub_profile(self) -> Optional[Any]:
        """
        Stub cluster profile.
        """
        return pulumi.get(self, "stub_profile")

    @property
    @pulumi.getter(name="trinoProfile")
    def trino_profile(self) -> Optional['outputs.TrinoProfileResponse']:
        """
        Trino Cluster profile.
        """
        return pulumi.get(self, "trino_profile")


@pulumi.output_type
class ClusterProfileResponseComponents(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        ClusterProfileResponseComponents._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterPrometheusProfileResponse(dict):
    """
    Cluster Prometheus profile.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Cluster Prometheus profile.
        :param bool enabled: Enable Prometheus for cluster or not.
        """
        ClusterPrometheusProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is None:
            enabled = False
        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable Prometheus for cluster or not.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterServiceConfigResponse(dict):
    """
    Cluster configs per component.
    """
    def __init__(__self__, *,
                 component: str,
                 files: Sequence['outputs.ClusterConfigFileResponse']):
        """
        Cluster configs per component.
        :param str component: Name of the component the config files should apply to.
        :param Sequence['ClusterConfigFileResponse'] files: List of Config Files.
        """
        ClusterServiceConfigResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            component=component,
            files=files,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             component: str,
             files: Sequence['outputs.ClusterConfigFileResponse'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("component", component)
        _setter("files", files)

    @property
    @pulumi.getter
    def component(self) -> str:
        """
        Name of the component the config files should apply to.
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.ClusterConfigFileResponse']:
        """
        List of Config Files.
        """
        return pulumi.get(self, "files")


@pulumi.output_type
class ClusterServiceConfigsProfileResponse(dict):
    """
    Cluster service configs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServiceConfigsProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServiceConfigsProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServiceConfigsProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configs: Sequence['outputs.ClusterServiceConfigResponse'],
                 service_name: str):
        """
        Cluster service configs.
        :param Sequence['ClusterServiceConfigResponse'] configs: List of service configs.
        :param str service_name: Name of the service the configurations should apply to.
        """
        ClusterServiceConfigsProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configs=configs,
            service_name=service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configs: Sequence['outputs.ClusterServiceConfigResponse'],
             service_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'serviceName' in kwargs:
            service_name = kwargs['serviceName']

        _setter("configs", configs)
        _setter("service_name", service_name)

    @property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.ClusterServiceConfigResponse']:
        """
        List of service configs.
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Name of the service the configurations should apply to.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class ComparisonRuleResponse(dict):
    """
    The comparison rule.
    """
    def __init__(__self__, *,
                 operator: str,
                 threshold: float):
        """
        The comparison rule.
        :param str operator: The comparison operator.
        :param float threshold: Threshold setting.
        """
        ComparisonRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            threshold=threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: str,
             threshold: float,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("operator", operator)
        _setter("threshold", threshold)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The comparison operator.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold setting.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class ComputeProfileResponse(dict):
    """
    The compute profile.
    """
    def __init__(__self__, *,
                 nodes: Sequence['outputs.NodeProfileResponse']):
        """
        The compute profile.
        :param Sequence['NodeProfileResponse'] nodes: The nodes definitions.
        """
        ComputeProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            nodes=nodes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             nodes: Sequence['outputs.NodeProfileResponse'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("nodes", nodes)

    @property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.NodeProfileResponse']:
        """
        The nodes definitions.
        """
        return pulumi.get(self, "nodes")


@pulumi.output_type
class ComputeResourceDefinitionResponse(dict):
    """
    The cpu and memory requirement definition.
    """
    def __init__(__self__, *,
                 cpu: float,
                 memory: float):
        """
        The cpu and memory requirement definition.
        :param float cpu: The required CPU.
        :param float memory: The required memory in MB, Container memory will be 110 percentile
        """
        ComputeResourceDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu=cpu,
            memory=memory,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu: float,
             memory: float,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("cpu", cpu)
        _setter("memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> float:
        """
        The required CPU.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> float:
        """
        The required memory in MB, Container memory will be 110 percentile
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ConnectivityProfileResponse(dict):
    """
    Cluster connectivity profile.
    """
    def __init__(__self__, *,
                 web: 'outputs.ConnectivityProfileResponseWeb',
                 ssh: Optional[Sequence['outputs.SshConnectivityEndpointResponse']] = None):
        """
        Cluster connectivity profile.
        :param 'ConnectivityProfileResponseWeb' web: Web connectivity endpoint details.
        :param Sequence['SshConnectivityEndpointResponse'] ssh: List of SSH connectivity endpoints.
        """
        ConnectivityProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            web=web,
            ssh=ssh,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             web: 'outputs.ConnectivityProfileResponseWeb',
             ssh: Optional[Sequence['outputs.SshConnectivityEndpointResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("web", web)
        if ssh is not None:
            _setter("ssh", ssh)

    @property
    @pulumi.getter
    def web(self) -> 'outputs.ConnectivityProfileResponseWeb':
        """
        Web connectivity endpoint details.
        """
        return pulumi.get(self, "web")

    @property
    @pulumi.getter
    def ssh(self) -> Optional[Sequence['outputs.SshConnectivityEndpointResponse']]:
        """
        List of SSH connectivity endpoints.
        """
        return pulumi.get(self, "ssh")


@pulumi.output_type
class ConnectivityProfileResponseWeb(dict):
    """
    Web connectivity endpoint details.
    """
    def __init__(__self__, *,
                 fqdn: str):
        """
        Web connectivity endpoint details.
        :param str fqdn: Web connectivity endpoint.
        """
        ConnectivityProfileResponseWeb._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fqdn=fqdn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fqdn: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("fqdn", fqdn)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        Web connectivity endpoint.
        """
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class FlinkCatalogOptionsResponse(dict):
    """
    Flink cluster catalog options.
    """
    def __init__(__self__, *,
                 hive: Optional['outputs.FlinkHiveCatalogOptionResponse'] = None):
        """
        Flink cluster catalog options.
        :param 'FlinkHiveCatalogOptionResponse' hive: Hive Catalog Option for Flink cluster.
        """
        FlinkCatalogOptionsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hive=hive,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hive: Optional['outputs.FlinkHiveCatalogOptionResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if hive is not None:
            _setter("hive", hive)

    @property
    @pulumi.getter
    def hive(self) -> Optional['outputs.FlinkHiveCatalogOptionResponse']:
        """
        Hive Catalog Option for Flink cluster.
        """
        return pulumi.get(self, "hive")


@pulumi.output_type
class FlinkHiveCatalogOptionResponse(dict):
    """
    Hive Catalog Option for Flink cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metastoreDbConnectionPasswordSecret":
            suggest = "metastore_db_connection_password_secret"
        elif key == "metastoreDbConnectionURL":
            suggest = "metastore_db_connection_url"
        elif key == "metastoreDbConnectionUserName":
            suggest = "metastore_db_connection_user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkHiveCatalogOptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkHiveCatalogOptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkHiveCatalogOptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metastore_db_connection_password_secret: str,
                 metastore_db_connection_url: str,
                 metastore_db_connection_user_name: str):
        """
        Hive Catalog Option for Flink cluster.
        :param str metastore_db_connection_password_secret: Secret reference name from secretsProfile.secrets containing password for database connection.
        :param str metastore_db_connection_url: Connection string for hive metastore database.
        :param str metastore_db_connection_user_name: User name for database connection.
        """
        FlinkHiveCatalogOptionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metastore_db_connection_password_secret=metastore_db_connection_password_secret,
            metastore_db_connection_url=metastore_db_connection_url,
            metastore_db_connection_user_name=metastore_db_connection_user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metastore_db_connection_password_secret: str,
             metastore_db_connection_url: str,
             metastore_db_connection_user_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'metastoreDbConnectionPasswordSecret' in kwargs:
            metastore_db_connection_password_secret = kwargs['metastoreDbConnectionPasswordSecret']
        if 'metastoreDbConnectionURL' in kwargs:
            metastore_db_connection_url = kwargs['metastoreDbConnectionURL']
        if 'metastoreDbConnectionUserName' in kwargs:
            metastore_db_connection_user_name = kwargs['metastoreDbConnectionUserName']

        _setter("metastore_db_connection_password_secret", metastore_db_connection_password_secret)
        _setter("metastore_db_connection_url", metastore_db_connection_url)
        _setter("metastore_db_connection_user_name", metastore_db_connection_user_name)

    @property
    @pulumi.getter(name="metastoreDbConnectionPasswordSecret")
    def metastore_db_connection_password_secret(self) -> str:
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_password_secret")

    @property
    @pulumi.getter(name="metastoreDbConnectionURL")
    def metastore_db_connection_url(self) -> str:
        """
        Connection string for hive metastore database.
        """
        return pulumi.get(self, "metastore_db_connection_url")

    @property
    @pulumi.getter(name="metastoreDbConnectionUserName")
    def metastore_db_connection_user_name(self) -> str:
        """
        User name for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_user_name")


@pulumi.output_type
class FlinkProfileResponse(dict):
    """
    The Flink cluster profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobManager":
            suggest = "job_manager"
        elif key == "taskManager":
            suggest = "task_manager"
        elif key == "catalogOptions":
            suggest = "catalog_options"
        elif key == "historyServer":
            suggest = "history_server"
        elif key == "numReplicas":
            suggest = "num_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_manager: 'outputs.ComputeResourceDefinitionResponse',
                 storage: 'outputs.FlinkStorageProfileResponse',
                 task_manager: 'outputs.ComputeResourceDefinitionResponse',
                 catalog_options: Optional['outputs.FlinkCatalogOptionsResponse'] = None,
                 history_server: Optional['outputs.ComputeResourceDefinitionResponse'] = None,
                 num_replicas: Optional[int] = None):
        """
        The Flink cluster profile.
        :param 'ComputeResourceDefinitionResponse' job_manager: Job Manager container/ process CPU and memory requirements
        :param 'FlinkStorageProfileResponse' storage: The storage profile
        :param 'ComputeResourceDefinitionResponse' task_manager: Task Manager container/ process CPU and memory requirements
        :param 'FlinkCatalogOptionsResponse' catalog_options: Flink cluster catalog options.
        :param 'ComputeResourceDefinitionResponse' history_server: History Server container/ process CPU and memory requirements
        :param int num_replicas: The number of task managers.
        """
        FlinkProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_manager=job_manager,
            storage=storage,
            task_manager=task_manager,
            catalog_options=catalog_options,
            history_server=history_server,
            num_replicas=num_replicas,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_manager: 'outputs.ComputeResourceDefinitionResponse',
             storage: 'outputs.FlinkStorageProfileResponse',
             task_manager: 'outputs.ComputeResourceDefinitionResponse',
             catalog_options: Optional['outputs.FlinkCatalogOptionsResponse'] = None,
             history_server: Optional['outputs.ComputeResourceDefinitionResponse'] = None,
             num_replicas: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'jobManager' in kwargs:
            job_manager = kwargs['jobManager']
        if 'taskManager' in kwargs:
            task_manager = kwargs['taskManager']
        if 'catalogOptions' in kwargs:
            catalog_options = kwargs['catalogOptions']
        if 'historyServer' in kwargs:
            history_server = kwargs['historyServer']
        if 'numReplicas' in kwargs:
            num_replicas = kwargs['numReplicas']

        _setter("job_manager", job_manager)
        _setter("storage", storage)
        _setter("task_manager", task_manager)
        if catalog_options is not None:
            _setter("catalog_options", catalog_options)
        if history_server is not None:
            _setter("history_server", history_server)
        if num_replicas is not None:
            _setter("num_replicas", num_replicas)

    @property
    @pulumi.getter(name="jobManager")
    def job_manager(self) -> 'outputs.ComputeResourceDefinitionResponse':
        """
        Job Manager container/ process CPU and memory requirements
        """
        return pulumi.get(self, "job_manager")

    @property
    @pulumi.getter
    def storage(self) -> 'outputs.FlinkStorageProfileResponse':
        """
        The storage profile
        """
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter(name="taskManager")
    def task_manager(self) -> 'outputs.ComputeResourceDefinitionResponse':
        """
        Task Manager container/ process CPU and memory requirements
        """
        return pulumi.get(self, "task_manager")

    @property
    @pulumi.getter(name="catalogOptions")
    def catalog_options(self) -> Optional['outputs.FlinkCatalogOptionsResponse']:
        """
        Flink cluster catalog options.
        """
        return pulumi.get(self, "catalog_options")

    @property
    @pulumi.getter(name="historyServer")
    def history_server(self) -> Optional['outputs.ComputeResourceDefinitionResponse']:
        """
        History Server container/ process CPU and memory requirements
        """
        return pulumi.get(self, "history_server")

    @property
    @pulumi.getter(name="numReplicas")
    def num_replicas(self) -> Optional[int]:
        """
        The number of task managers.
        """
        return pulumi.get(self, "num_replicas")


@pulumi.output_type
class FlinkStorageProfileResponse(dict):
    """
    The storage profile
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageUri":
            suggest = "storage_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkStorageProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkStorageProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkStorageProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_uri: str,
                 storagekey: Optional[str] = None):
        """
        The storage profile
        :param str storage_uri: Storage account uri which is used for savepoint and checkpoint state.
        :param str storagekey: Storage key is only required for wasb(s) storage.
        """
        FlinkStorageProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            storage_uri=storage_uri,
            storagekey=storagekey,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             storage_uri: str,
             storagekey: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'storageUri' in kwargs:
            storage_uri = kwargs['storageUri']

        _setter("storage_uri", storage_uri)
        if storagekey is not None:
            _setter("storagekey", storagekey)

    @property
    @pulumi.getter(name="storageUri")
    def storage_uri(self) -> str:
        """
        Storage account uri which is used for savepoint and checkpoint state.
        """
        return pulumi.get(self, "storage_uri")

    @property
    @pulumi.getter
    def storagekey(self) -> Optional[str]:
        """
        Storage key is only required for wasb(s) storage.
        """
        return pulumi.get(self, "storagekey")


@pulumi.output_type
class HiveCatalogOptionResponse(dict):
    """
    Hive Catalog Option
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogName":
            suggest = "catalog_name"
        elif key == "metastoreDbConnectionPasswordSecret":
            suggest = "metastore_db_connection_password_secret"
        elif key == "metastoreDbConnectionURL":
            suggest = "metastore_db_connection_url"
        elif key == "metastoreDbConnectionUserName":
            suggest = "metastore_db_connection_user_name"
        elif key == "metastoreWarehouseDir":
            suggest = "metastore_warehouse_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HiveCatalogOptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HiveCatalogOptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HiveCatalogOptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_name: str,
                 metastore_db_connection_password_secret: str,
                 metastore_db_connection_url: str,
                 metastore_db_connection_user_name: str,
                 metastore_warehouse_dir: str):
        """
        Hive Catalog Option
        :param str catalog_name: Name of trino catalog which should use specified hive metastore.
        :param str metastore_db_connection_password_secret: Secret reference name from secretsProfile.secrets containing password for database connection.
        :param str metastore_db_connection_url: Connection string for hive metastore database.
        :param str metastore_db_connection_user_name: User name for database connection.
        :param str metastore_warehouse_dir: Metastore root directory URI, format: abfs[s]://<container>@<account_name>.dfs.core.windows.net/<path>. More details: https://docs.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-introduction-abfs-uri
        """
        HiveCatalogOptionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog_name=catalog_name,
            metastore_db_connection_password_secret=metastore_db_connection_password_secret,
            metastore_db_connection_url=metastore_db_connection_url,
            metastore_db_connection_user_name=metastore_db_connection_user_name,
            metastore_warehouse_dir=metastore_warehouse_dir,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog_name: str,
             metastore_db_connection_password_secret: str,
             metastore_db_connection_url: str,
             metastore_db_connection_user_name: str,
             metastore_warehouse_dir: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'catalogName' in kwargs:
            catalog_name = kwargs['catalogName']
        if 'metastoreDbConnectionPasswordSecret' in kwargs:
            metastore_db_connection_password_secret = kwargs['metastoreDbConnectionPasswordSecret']
        if 'metastoreDbConnectionURL' in kwargs:
            metastore_db_connection_url = kwargs['metastoreDbConnectionURL']
        if 'metastoreDbConnectionUserName' in kwargs:
            metastore_db_connection_user_name = kwargs['metastoreDbConnectionUserName']
        if 'metastoreWarehouseDir' in kwargs:
            metastore_warehouse_dir = kwargs['metastoreWarehouseDir']

        _setter("catalog_name", catalog_name)
        _setter("metastore_db_connection_password_secret", metastore_db_connection_password_secret)
        _setter("metastore_db_connection_url", metastore_db_connection_url)
        _setter("metastore_db_connection_user_name", metastore_db_connection_user_name)
        _setter("metastore_warehouse_dir", metastore_warehouse_dir)

    @property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> str:
        """
        Name of trino catalog which should use specified hive metastore.
        """
        return pulumi.get(self, "catalog_name")

    @property
    @pulumi.getter(name="metastoreDbConnectionPasswordSecret")
    def metastore_db_connection_password_secret(self) -> str:
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_password_secret")

    @property
    @pulumi.getter(name="metastoreDbConnectionURL")
    def metastore_db_connection_url(self) -> str:
        """
        Connection string for hive metastore database.
        """
        return pulumi.get(self, "metastore_db_connection_url")

    @property
    @pulumi.getter(name="metastoreDbConnectionUserName")
    def metastore_db_connection_user_name(self) -> str:
        """
        User name for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_user_name")

    @property
    @pulumi.getter(name="metastoreWarehouseDir")
    def metastore_warehouse_dir(self) -> str:
        """
        Metastore root directory URI, format: abfs[s]://<container>@<account_name>.dfs.core.windows.net/<path>. More details: https://docs.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-introduction-abfs-uri
        """
        return pulumi.get(self, "metastore_warehouse_dir")


@pulumi.output_type
class IdentityProfileResponse(dict):
    """
    Identity Profile with details of an MSI.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "msiClientId":
            suggest = "msi_client_id"
        elif key == "msiObjectId":
            suggest = "msi_object_id"
        elif key == "msiResourceId":
            suggest = "msi_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 msi_client_id: str,
                 msi_object_id: str,
                 msi_resource_id: str):
        """
        Identity Profile with details of an MSI.
        :param str msi_client_id: ClientId of the MSI.
        :param str msi_object_id: ObjectId of the MSI.
        :param str msi_resource_id: ResourceId of the MSI.
        """
        IdentityProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            msi_client_id=msi_client_id,
            msi_object_id=msi_object_id,
            msi_resource_id=msi_resource_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             msi_client_id: str,
             msi_object_id: str,
             msi_resource_id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'msiClientId' in kwargs:
            msi_client_id = kwargs['msiClientId']
        if 'msiObjectId' in kwargs:
            msi_object_id = kwargs['msiObjectId']
        if 'msiResourceId' in kwargs:
            msi_resource_id = kwargs['msiResourceId']

        _setter("msi_client_id", msi_client_id)
        _setter("msi_object_id", msi_object_id)
        _setter("msi_resource_id", msi_resource_id)

    @property
    @pulumi.getter(name="msiClientId")
    def msi_client_id(self) -> str:
        """
        ClientId of the MSI.
        """
        return pulumi.get(self, "msi_client_id")

    @property
    @pulumi.getter(name="msiObjectId")
    def msi_object_id(self) -> str:
        """
        ObjectId of the MSI.
        """
        return pulumi.get(self, "msi_object_id")

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> str:
        """
        ResourceId of the MSI.
        """
        return pulumi.get(self, "msi_resource_id")


@pulumi.output_type
class LoadBasedConfigResponse(dict):
    """
    Profile of load based Autoscale.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNodes":
            suggest = "max_nodes"
        elif key == "minNodes":
            suggest = "min_nodes"
        elif key == "scalingRules":
            suggest = "scaling_rules"
        elif key == "cooldownPeriod":
            suggest = "cooldown_period"
        elif key == "pollInterval":
            suggest = "poll_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBasedConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBasedConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBasedConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_nodes: int,
                 min_nodes: int,
                 scaling_rules: Sequence['outputs.ScalingRuleResponse'],
                 cooldown_period: Optional[int] = None,
                 poll_interval: Optional[int] = None):
        """
        Profile of load based Autoscale.
        :param int max_nodes: User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        :param int min_nodes: User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        :param Sequence['ScalingRuleResponse'] scaling_rules: The scaling rules.
        :param int cooldown_period: This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.
        :param int poll_interval: User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.
        """
        LoadBasedConfigResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_nodes=max_nodes,
            min_nodes=min_nodes,
            scaling_rules=scaling_rules,
            cooldown_period=cooldown_period,
            poll_interval=poll_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_nodes: int,
             min_nodes: int,
             scaling_rules: Sequence['outputs.ScalingRuleResponse'],
             cooldown_period: Optional[int] = None,
             poll_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxNodes' in kwargs:
            max_nodes = kwargs['maxNodes']
        if 'minNodes' in kwargs:
            min_nodes = kwargs['minNodes']
        if 'scalingRules' in kwargs:
            scaling_rules = kwargs['scalingRules']
        if 'cooldownPeriod' in kwargs:
            cooldown_period = kwargs['cooldownPeriod']
        if 'pollInterval' in kwargs:
            poll_interval = kwargs['pollInterval']

        _setter("max_nodes", max_nodes)
        _setter("min_nodes", min_nodes)
        _setter("scaling_rules", scaling_rules)
        if cooldown_period is not None:
            _setter("cooldown_period", cooldown_period)
        if poll_interval is not None:
            _setter("poll_interval", poll_interval)

    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> int:
        """
        User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        return pulumi.get(self, "max_nodes")

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> int:
        """
        User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        return pulumi.get(self, "min_nodes")

    @property
    @pulumi.getter(name="scalingRules")
    def scaling_rules(self) -> Sequence['outputs.ScalingRuleResponse']:
        """
        The scaling rules.
        """
        return pulumi.get(self, "scaling_rules")

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[int]:
        """
        This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.
        """
        return pulumi.get(self, "cooldown_period")

    @property
    @pulumi.getter(name="pollInterval")
    def poll_interval(self) -> Optional[int]:
        """
        User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.
        """
        return pulumi.get(self, "poll_interval")


@pulumi.output_type
class NodeProfileResponse(dict):
    """
    The node profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 type: str,
                 vm_size: str):
        """
        The node profile.
        :param int count: The number of virtual machines.
        :param str type: The node type.
        :param str vm_size: The virtual machine SKU.
        """
        NodeProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            type=type,
            vm_size=vm_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: int,
             type: str,
             vm_size: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'vmSize' in kwargs:
            vm_size = kwargs['vmSize']

        _setter("count", count)
        _setter("type", type)
        _setter("vm_size", vm_size)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of virtual machines.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The node type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The virtual machine SKU.
        """
        return pulumi.get(self, "vm_size")


@pulumi.output_type
class ScalingRuleResponse(dict):
    """
    The scaling rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "comparisonRule":
            suggest = "comparison_rule"
        elif key == "evaluationCount":
            suggest = "evaluation_count"
        elif key == "scalingMetric":
            suggest = "scaling_metric"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 comparison_rule: 'outputs.ComparisonRuleResponse',
                 evaluation_count: int,
                 scaling_metric: str):
        """
        The scaling rule.
        :param str action_type: The action type.
        :param 'ComparisonRuleResponse' comparison_rule: The comparison rule.
        :param int evaluation_count: This is an evaluation count for a scaling condition, the number of times a trigger condition should be successful, before scaling activity is triggered.
        :param str scaling_metric: Metrics name for individual workloads. For example: cpu
        """
        ScalingRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_type=action_type,
            comparison_rule=comparison_rule,
            evaluation_count=evaluation_count,
            scaling_metric=scaling_metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_type: str,
             comparison_rule: 'outputs.ComparisonRuleResponse',
             evaluation_count: int,
             scaling_metric: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'actionType' in kwargs:
            action_type = kwargs['actionType']
        if 'comparisonRule' in kwargs:
            comparison_rule = kwargs['comparisonRule']
        if 'evaluationCount' in kwargs:
            evaluation_count = kwargs['evaluationCount']
        if 'scalingMetric' in kwargs:
            scaling_metric = kwargs['scalingMetric']

        _setter("action_type", action_type)
        _setter("comparison_rule", comparison_rule)
        _setter("evaluation_count", evaluation_count)
        _setter("scaling_metric", scaling_metric)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        The action type.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="comparisonRule")
    def comparison_rule(self) -> 'outputs.ComparisonRuleResponse':
        """
        The comparison rule.
        """
        return pulumi.get(self, "comparison_rule")

    @property
    @pulumi.getter(name="evaluationCount")
    def evaluation_count(self) -> int:
        """
        This is an evaluation count for a scaling condition, the number of times a trigger condition should be successful, before scaling activity is triggered.
        """
        return pulumi.get(self, "evaluation_count")

    @property
    @pulumi.getter(name="scalingMetric")
    def scaling_metric(self) -> str:
        """
        Metrics name for individual workloads. For example: cpu
        """
        return pulumi.get(self, "scaling_metric")


@pulumi.output_type
class ScheduleBasedConfigResponse(dict):
    """
    Profile of schedule based Autoscale.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultCount":
            suggest = "default_count"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleBasedConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleBasedConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleBasedConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_count: int,
                 schedules: Sequence['outputs.ScheduleResponse'],
                 time_zone: str):
        """
        Profile of schedule based Autoscale.
        :param int default_count: Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)
        :param Sequence['ScheduleResponse'] schedules: This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).
        :param str time_zone: User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        """
        ScheduleBasedConfigResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_count=default_count,
            schedules=schedules,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_count: int,
             schedules: Sequence['outputs.ScheduleResponse'],
             time_zone: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'defaultCount' in kwargs:
            default_count = kwargs['defaultCount']
        if 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        _setter("default_count", default_count)
        _setter("schedules", schedules)
        _setter("time_zone", time_zone)

    @property
    @pulumi.getter(name="defaultCount")
    def default_count(self) -> int:
        """
        Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)
        """
        return pulumi.get(self, "default_count")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.ScheduleResponse']:
        """
        This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class ScheduleResponse(dict):
    """
    Schedule definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 days: Sequence[str],
                 end_time: str,
                 start_time: str):
        """
        Schedule definition.
        :param int count: User has to set the node count anticipated at end of the scaling operation of the set current schedule configuration, format is integer.
        :param Sequence[str] days: User has to set the days where schedule has to be set for autoscale operation.
        :param str end_time: User has to set the end time of current schedule configuration, format like 10:30 (HH:MM).
        :param str start_time: User has to set the start time of current schedule configuration, format like 10:30 (HH:MM).
        """
        ScheduleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            days=days,
            end_time=end_time,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: int,
             days: Sequence[str],
             end_time: str,
             start_time: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endTime' in kwargs:
            end_time = kwargs['endTime']
        if 'startTime' in kwargs:
            start_time = kwargs['startTime']

        _setter("count", count)
        _setter("days", days)
        _setter("end_time", end_time)
        _setter("start_time", start_time)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        User has to set the node count anticipated at end of the scaling operation of the set current schedule configuration, format is integer.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def days(self) -> Sequence[str]:
        """
        User has to set the days where schedule has to be set for autoscale operation.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        User has to set the end time of current schedule configuration, format like 10:30 (HH:MM).
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        User has to set the start time of current schedule configuration, format like 10:30 (HH:MM).
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ScriptActionProfileResponse(dict):
    """
    The script action profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shouldPersist":
            suggest = "should_persist"
        elif key == "timeoutInMinutes":
            suggest = "timeout_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScriptActionProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScriptActionProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScriptActionProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 services: Sequence[str],
                 type: str,
                 url: str,
                 parameters: Optional[str] = None,
                 should_persist: Optional[bool] = None,
                 timeout_in_minutes: Optional[int] = None):
        """
        The script action profile.
        :param str name: Script name.
        :param Sequence[str] services: List of services to apply the script action.
        :param str type: Type of the script action. Supported type is bash scripts.
        :param str url: Url of the script file.
        :param str parameters: Additional parameters for the script action. It should be space-separated list of arguments required for script execution.
        :param bool should_persist: Specify if the script should persist on the cluster.
        :param int timeout_in_minutes: Timeout duration for the script action in minutes.
        """
        ScriptActionProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            services=services,
            type=type,
            url=url,
            parameters=parameters,
            should_persist=should_persist,
            timeout_in_minutes=timeout_in_minutes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             services: Sequence[str],
             type: str,
             url: str,
             parameters: Optional[str] = None,
             should_persist: Optional[bool] = None,
             timeout_in_minutes: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'shouldPersist' in kwargs:
            should_persist = kwargs['shouldPersist']
        if 'timeoutInMinutes' in kwargs:
            timeout_in_minutes = kwargs['timeoutInMinutes']

        _setter("name", name)
        _setter("services", services)
        _setter("type", type)
        _setter("url", url)
        if parameters is not None:
            _setter("parameters", parameters)
        if should_persist is None:
            should_persist = True
        if should_persist is not None:
            _setter("should_persist", should_persist)
        if timeout_in_minutes is not None:
            _setter("timeout_in_minutes", timeout_in_minutes)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Script name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def services(self) -> Sequence[str]:
        """
        List of services to apply the script action.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the script action. Supported type is bash scripts.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Url of the script file.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        Additional parameters for the script action. It should be space-separated list of arguments required for script execution.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="shouldPersist")
    def should_persist(self) -> Optional[bool]:
        """
        Specify if the script should persist on the cluster.
        """
        return pulumi.get(self, "should_persist")

    @property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[int]:
        """
        Timeout duration for the script action in minutes.
        """
        return pulumi.get(self, "timeout_in_minutes")


@pulumi.output_type
class SecretReferenceResponse(dict):
    """
    Secret reference and corresponding properties of a key vault secret.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultObjectName":
            suggest = "key_vault_object_name"
        elif key == "referenceName":
            suggest = "reference_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_object_name: str,
                 reference_name: str,
                 type: str,
                 version: Optional[str] = None):
        """
        Secret reference and corresponding properties of a key vault secret.
        :param str key_vault_object_name: Object identifier name of the secret in key vault.
        :param str reference_name: Reference name of the secret to be used in service configs.
        :param str type: Type of key vault object: secret, key or certificate.
        :param str version: Version of the secret in key vault.
        """
        SecretReferenceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_vault_object_name=key_vault_object_name,
            reference_name=reference_name,
            type=type,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_vault_object_name: str,
             reference_name: str,
             type: str,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'keyVaultObjectName' in kwargs:
            key_vault_object_name = kwargs['keyVaultObjectName']
        if 'referenceName' in kwargs:
            reference_name = kwargs['referenceName']

        _setter("key_vault_object_name", key_vault_object_name)
        _setter("reference_name", reference_name)
        _setter("type", type)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="keyVaultObjectName")
    def key_vault_object_name(self) -> str:
        """
        Object identifier name of the secret in key vault.
        """
        return pulumi.get(self, "key_vault_object_name")

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> str:
        """
        Reference name of the secret to be used in service configs.
        """
        return pulumi.get(self, "reference_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of key vault object: secret, key or certificate.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the secret in key vault.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SecretsProfileResponse(dict):
    """
    The cluster secret profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultResourceId":
            suggest = "key_vault_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretsProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretsProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretsProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_resource_id: str,
                 secrets: Optional[Sequence['outputs.SecretReferenceResponse']] = None):
        """
        The cluster secret profile.
        :param str key_vault_resource_id: Name of the user Key Vault where all the cluster specific user secrets are stored.
        :param Sequence['SecretReferenceResponse'] secrets: Properties of Key Vault secret.
        """
        SecretsProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_vault_resource_id=key_vault_resource_id,
            secrets=secrets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_vault_resource_id: str,
             secrets: Optional[Sequence['outputs.SecretReferenceResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'keyVaultResourceId' in kwargs:
            key_vault_resource_id = kwargs['keyVaultResourceId']

        _setter("key_vault_resource_id", key_vault_resource_id)
        if secrets is not None:
            _setter("secrets", secrets)

    @property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> str:
        """
        Name of the user Key Vault where all the cluster specific user secrets are stored.
        """
        return pulumi.get(self, "key_vault_resource_id")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.SecretReferenceResponse']]:
        """
        Properties of Key Vault secret.
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class SparkMetastoreSpecResponse(dict):
    """
    The metastore specification for Spark cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "dbPasswordSecretName":
            suggest = "db_password_secret_name"
        elif key == "dbServerHost":
            suggest = "db_server_host"
        elif key == "dbUserName":
            suggest = "db_user_name"
        elif key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "thriftUrl":
            suggest = "thrift_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkMetastoreSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkMetastoreSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkMetastoreSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: str,
                 db_password_secret_name: str,
                 db_server_host: str,
                 db_user_name: str,
                 key_vault_id: str,
                 thrift_url: Optional[str] = None):
        """
        The metastore specification for Spark cluster.
        :param str db_name: The database name.
        :param str db_password_secret_name: The secret name which contains the database user password.
        :param str db_server_host: The database server host.
        :param str db_user_name: The database user name.
        :param str key_vault_id: The key vault resource id.
        :param str thrift_url: The thrift url.
        """
        SparkMetastoreSpecResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_name=db_name,
            db_password_secret_name=db_password_secret_name,
            db_server_host=db_server_host,
            db_user_name=db_user_name,
            key_vault_id=key_vault_id,
            thrift_url=thrift_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_name: str,
             db_password_secret_name: str,
             db_server_host: str,
             db_user_name: str,
             key_vault_id: str,
             thrift_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dbName' in kwargs:
            db_name = kwargs['dbName']
        if 'dbPasswordSecretName' in kwargs:
            db_password_secret_name = kwargs['dbPasswordSecretName']
        if 'dbServerHost' in kwargs:
            db_server_host = kwargs['dbServerHost']
        if 'dbUserName' in kwargs:
            db_user_name = kwargs['dbUserName']
        if 'keyVaultId' in kwargs:
            key_vault_id = kwargs['keyVaultId']
        if 'thriftUrl' in kwargs:
            thrift_url = kwargs['thriftUrl']

        _setter("db_name", db_name)
        _setter("db_password_secret_name", db_password_secret_name)
        _setter("db_server_host", db_server_host)
        _setter("db_user_name", db_user_name)
        _setter("key_vault_id", key_vault_id)
        if thrift_url is not None:
            _setter("thrift_url", thrift_url)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The database name.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbPasswordSecretName")
    def db_password_secret_name(self) -> str:
        """
        The secret name which contains the database user password.
        """
        return pulumi.get(self, "db_password_secret_name")

    @property
    @pulumi.getter(name="dbServerHost")
    def db_server_host(self) -> str:
        """
        The database server host.
        """
        return pulumi.get(self, "db_server_host")

    @property
    @pulumi.getter(name="dbUserName")
    def db_user_name(self) -> str:
        """
        The database user name.
        """
        return pulumi.get(self, "db_user_name")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> str:
        """
        The key vault resource id.
        """
        return pulumi.get(self, "key_vault_id")

    @property
    @pulumi.getter(name="thriftUrl")
    def thrift_url(self) -> Optional[str]:
        """
        The thrift url.
        """
        return pulumi.get(self, "thrift_url")


@pulumi.output_type
class SparkProfileResponse(dict):
    """
    The spark cluster profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultStorageUrl":
            suggest = "default_storage_url"
        elif key == "metastoreSpec":
            suggest = "metastore_spec"
        elif key == "userPluginsSpec":
            suggest = "user_plugins_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_storage_url: Optional[str] = None,
                 metastore_spec: Optional['outputs.SparkMetastoreSpecResponse'] = None,
                 user_plugins_spec: Optional['outputs.SparkUserPluginsResponse'] = None):
        """
        The spark cluster profile.
        :param str default_storage_url: The default storage URL.
        :param 'SparkMetastoreSpecResponse' metastore_spec: The metastore specification for Spark cluster.
        :param 'SparkUserPluginsResponse' user_plugins_spec: Spark user plugins spec
        """
        SparkProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_storage_url=default_storage_url,
            metastore_spec=metastore_spec,
            user_plugins_spec=user_plugins_spec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_storage_url: Optional[str] = None,
             metastore_spec: Optional['outputs.SparkMetastoreSpecResponse'] = None,
             user_plugins_spec: Optional['outputs.SparkUserPluginsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'defaultStorageUrl' in kwargs:
            default_storage_url = kwargs['defaultStorageUrl']
        if 'metastoreSpec' in kwargs:
            metastore_spec = kwargs['metastoreSpec']
        if 'userPluginsSpec' in kwargs:
            user_plugins_spec = kwargs['userPluginsSpec']

        if default_storage_url is not None:
            _setter("default_storage_url", default_storage_url)
        if metastore_spec is not None:
            _setter("metastore_spec", metastore_spec)
        if user_plugins_spec is not None:
            _setter("user_plugins_spec", user_plugins_spec)

    @property
    @pulumi.getter(name="defaultStorageUrl")
    def default_storage_url(self) -> Optional[str]:
        """
        The default storage URL.
        """
        return pulumi.get(self, "default_storage_url")

    @property
    @pulumi.getter(name="metastoreSpec")
    def metastore_spec(self) -> Optional['outputs.SparkMetastoreSpecResponse']:
        """
        The metastore specification for Spark cluster.
        """
        return pulumi.get(self, "metastore_spec")

    @property
    @pulumi.getter(name="userPluginsSpec")
    def user_plugins_spec(self) -> Optional['outputs.SparkUserPluginsResponse']:
        """
        Spark user plugins spec
        """
        return pulumi.get(self, "user_plugins_spec")


@pulumi.output_type
class SparkUserPluginResponse(dict):
    """
    Spark user plugin.
    """
    def __init__(__self__, *,
                 path: str):
        """
        Spark user plugin.
        :param str path: Fully qualified path to the folder containing the plugins.
        """
        SparkUserPluginResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("path", path)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Fully qualified path to the folder containing the plugins.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class SparkUserPluginsResponse(dict):
    """
    Spark user plugins spec
    """
    def __init__(__self__, *,
                 plugins: Optional[Sequence['outputs.SparkUserPluginResponse']] = None):
        """
        Spark user plugins spec
        :param Sequence['SparkUserPluginResponse'] plugins: Spark user plugins.
        """
        SparkUserPluginsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            plugins=plugins,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             plugins: Optional[Sequence['outputs.SparkUserPluginResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if plugins is not None:
            _setter("plugins", plugins)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[Sequence['outputs.SparkUserPluginResponse']]:
        """
        Spark user plugins.
        """
        return pulumi.get(self, "plugins")


@pulumi.output_type
class SshConnectivityEndpointResponse(dict):
    """
    SSH connectivity endpoint details.
    """
    def __init__(__self__, *,
                 endpoint: str):
        """
        SSH connectivity endpoint details.
        :param str endpoint: SSH connectivity endpoint.
        """
        SshConnectivityEndpointResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("endpoint", endpoint)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        SSH connectivity endpoint.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class SshProfileResponse(dict):
    """
    Ssh profile for the cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podPrefix":
            suggest = "pod_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SshProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SshProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SshProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 pod_prefix: str):
        """
        Ssh profile for the cluster.
        :param int count: Number of ssh pods per cluster.
        :param str pod_prefix: Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at <clusterFqdn>/<sshBasePath>/<prefix>-<number>
        """
        SshProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            pod_prefix=pod_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: int,
             pod_prefix: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'podPrefix' in kwargs:
            pod_prefix = kwargs['podPrefix']

        _setter("count", count)
        _setter("pod_prefix", pod_prefix)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        Number of ssh pods per cluster.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="podPrefix")
    def pod_prefix(self) -> str:
        """
        Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at <clusterFqdn>/<sshBasePath>/<prefix>-<number>
        """
        return pulumi.get(self, "pod_prefix")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TrinoCoordinatorResponse(dict):
    """
    Trino Coordinator.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highAvailabilityEnabled":
            suggest = "high_availability_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrinoCoordinatorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrinoCoordinatorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrinoCoordinatorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 high_availability_enabled: Optional[bool] = None,
                 port: Optional[int] = None,
                 suspend: Optional[bool] = None):
        """
        Trino Coordinator.
        :param bool enable: The flag that if enable debug or not.
        :param bool high_availability_enabled: The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.
        :param int port: The debug port.
        :param bool suspend: The flag that if suspend debug or not.
        """
        TrinoCoordinatorResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable=enable,
            high_availability_enabled=high_availability_enabled,
            port=port,
            suspend=suspend,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable: Optional[bool] = None,
             high_availability_enabled: Optional[bool] = None,
             port: Optional[int] = None,
             suspend: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'highAvailabilityEnabled' in kwargs:
            high_availability_enabled = kwargs['highAvailabilityEnabled']

        if enable is None:
            enable = False
        if enable is not None:
            _setter("enable", enable)
        if high_availability_enabled is None:
            high_availability_enabled = True
        if high_availability_enabled is not None:
            _setter("high_availability_enabled", high_availability_enabled)
        if port is None:
            port = 8008
        if port is not None:
            _setter("port", port)
        if suspend is None:
            suspend = False
        if suspend is not None:
            _setter("suspend", suspend)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        The flag that if enable debug or not.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="highAvailabilityEnabled")
    def high_availability_enabled(self) -> Optional[bool]:
        """
        The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.
        """
        return pulumi.get(self, "high_availability_enabled")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The debug port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[bool]:
        """
        The flag that if suspend debug or not.
        """
        return pulumi.get(self, "suspend")


@pulumi.output_type
class TrinoProfileResponse(dict):
    """
    Trino Cluster profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogOptions":
            suggest = "catalog_options"
        elif key == "userPluginsSpec":
            suggest = "user_plugins_spec"
        elif key == "userTelemetrySpec":
            suggest = "user_telemetry_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrinoProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrinoProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrinoProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_options: Optional['outputs.CatalogOptionsResponse'] = None,
                 coordinator: Optional['outputs.TrinoCoordinatorResponse'] = None,
                 user_plugins_spec: Optional['outputs.TrinoUserPluginsResponse'] = None,
                 user_telemetry_spec: Optional['outputs.TrinoUserTelemetryResponse'] = None,
                 worker: Optional['outputs.TrinoWorkerResponse'] = None):
        """
        Trino Cluster profile.
        :param 'CatalogOptionsResponse' catalog_options: Trino cluster catalog options.
        :param 'TrinoCoordinatorResponse' coordinator: Trino Coordinator.
        :param 'TrinoUserPluginsResponse' user_plugins_spec: Trino user plugins spec
        :param 'TrinoUserTelemetryResponse' user_telemetry_spec: User telemetry
        :param 'TrinoWorkerResponse' worker: Trino worker.
        """
        TrinoProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog_options=catalog_options,
            coordinator=coordinator,
            user_plugins_spec=user_plugins_spec,
            user_telemetry_spec=user_telemetry_spec,
            worker=worker,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog_options: Optional['outputs.CatalogOptionsResponse'] = None,
             coordinator: Optional['outputs.TrinoCoordinatorResponse'] = None,
             user_plugins_spec: Optional['outputs.TrinoUserPluginsResponse'] = None,
             user_telemetry_spec: Optional['outputs.TrinoUserTelemetryResponse'] = None,
             worker: Optional['outputs.TrinoWorkerResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'catalogOptions' in kwargs:
            catalog_options = kwargs['catalogOptions']
        if 'userPluginsSpec' in kwargs:
            user_plugins_spec = kwargs['userPluginsSpec']
        if 'userTelemetrySpec' in kwargs:
            user_telemetry_spec = kwargs['userTelemetrySpec']

        if catalog_options is not None:
            _setter("catalog_options", catalog_options)
        if coordinator is not None:
            _setter("coordinator", coordinator)
        if user_plugins_spec is not None:
            _setter("user_plugins_spec", user_plugins_spec)
        if user_telemetry_spec is not None:
            _setter("user_telemetry_spec", user_telemetry_spec)
        if worker is not None:
            _setter("worker", worker)

    @property
    @pulumi.getter(name="catalogOptions")
    def catalog_options(self) -> Optional['outputs.CatalogOptionsResponse']:
        """
        Trino cluster catalog options.
        """
        return pulumi.get(self, "catalog_options")

    @property
    @pulumi.getter
    def coordinator(self) -> Optional['outputs.TrinoCoordinatorResponse']:
        """
        Trino Coordinator.
        """
        return pulumi.get(self, "coordinator")

    @property
    @pulumi.getter(name="userPluginsSpec")
    def user_plugins_spec(self) -> Optional['outputs.TrinoUserPluginsResponse']:
        """
        Trino user plugins spec
        """
        return pulumi.get(self, "user_plugins_spec")

    @property
    @pulumi.getter(name="userTelemetrySpec")
    def user_telemetry_spec(self) -> Optional['outputs.TrinoUserTelemetryResponse']:
        """
        User telemetry
        """
        return pulumi.get(self, "user_telemetry_spec")

    @property
    @pulumi.getter
    def worker(self) -> Optional['outputs.TrinoWorkerResponse']:
        """
        Trino worker.
        """
        return pulumi.get(self, "worker")


@pulumi.output_type
class TrinoTelemetryConfigResponse(dict):
    """
    Trino user telemetry definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hivecatalogName":
            suggest = "hivecatalog_name"
        elif key == "hivecatalogSchema":
            suggest = "hivecatalog_schema"
        elif key == "partitionRetentionInDays":
            suggest = "partition_retention_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrinoTelemetryConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrinoTelemetryConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrinoTelemetryConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hivecatalog_name: Optional[str] = None,
                 hivecatalog_schema: Optional[str] = None,
                 partition_retention_in_days: Optional[int] = None,
                 path: Optional[str] = None):
        """
        Trino user telemetry definition.
        :param str hivecatalog_name: Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        :param str hivecatalog_schema: Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.
        :param int partition_retention_in_days: Retention period for query log table partitions, this doesn't have any affect on actual data.
        :param str path: Azure storage location of the blobs.
        """
        TrinoTelemetryConfigResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hivecatalog_name=hivecatalog_name,
            hivecatalog_schema=hivecatalog_schema,
            partition_retention_in_days=partition_retention_in_days,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hivecatalog_name: Optional[str] = None,
             hivecatalog_schema: Optional[str] = None,
             partition_retention_in_days: Optional[int] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'hivecatalogName' in kwargs:
            hivecatalog_name = kwargs['hivecatalogName']
        if 'hivecatalogSchema' in kwargs:
            hivecatalog_schema = kwargs['hivecatalogSchema']
        if 'partitionRetentionInDays' in kwargs:
            partition_retention_in_days = kwargs['partitionRetentionInDays']

        if hivecatalog_name is not None:
            _setter("hivecatalog_name", hivecatalog_name)
        if hivecatalog_schema is None:
            hivecatalog_schema = 'trinologs'
        if hivecatalog_schema is not None:
            _setter("hivecatalog_schema", hivecatalog_schema)
        if partition_retention_in_days is None:
            partition_retention_in_days = 365
        if partition_retention_in_days is not None:
            _setter("partition_retention_in_days", partition_retention_in_days)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter(name="hivecatalogName")
    def hivecatalog_name(self) -> Optional[str]:
        """
        Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        """
        return pulumi.get(self, "hivecatalog_name")

    @property
    @pulumi.getter(name="hivecatalogSchema")
    def hivecatalog_schema(self) -> Optional[str]:
        """
        Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.
        """
        return pulumi.get(self, "hivecatalog_schema")

    @property
    @pulumi.getter(name="partitionRetentionInDays")
    def partition_retention_in_days(self) -> Optional[int]:
        """
        Retention period for query log table partitions, this doesn't have any affect on actual data.
        """
        return pulumi.get(self, "partition_retention_in_days")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Azure storage location of the blobs.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class TrinoUserPluginResponse(dict):
    """
    Trino user plugin.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 path: Optional[str] = None):
        """
        Trino user plugin.
        :param bool enabled: Denotes whether the plugin is active or not.
        :param str name: This field maps to the sub-directory in trino plugins location, that will contain all the plugins under path.
        :param str path: Fully qualified path to the folder containing the plugins.
        """
        TrinoUserPluginResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            name=name,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             name: Optional[str] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if name is not None:
            _setter("name", name)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Denotes whether the plugin is active or not.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        This field maps to the sub-directory in trino plugins location, that will contain all the plugins under path.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Fully qualified path to the folder containing the plugins.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class TrinoUserPluginsResponse(dict):
    """
    Trino user plugins spec
    """
    def __init__(__self__, *,
                 plugins: Optional[Sequence['outputs.TrinoUserPluginResponse']] = None):
        """
        Trino user plugins spec
        :param Sequence['TrinoUserPluginResponse'] plugins: Trino user plugins.
        """
        TrinoUserPluginsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            plugins=plugins,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             plugins: Optional[Sequence['outputs.TrinoUserPluginResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if plugins is not None:
            _setter("plugins", plugins)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[Sequence['outputs.TrinoUserPluginResponse']]:
        """
        Trino user plugins.
        """
        return pulumi.get(self, "plugins")


@pulumi.output_type
class TrinoUserTelemetryResponse(dict):
    """
    User telemetry
    """
    def __init__(__self__, *,
                 storage: Optional['outputs.TrinoTelemetryConfigResponse'] = None):
        """
        User telemetry
        :param 'TrinoTelemetryConfigResponse' storage: Trino user telemetry definition.
        """
        TrinoUserTelemetryResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             storage: Optional['outputs.TrinoTelemetryConfigResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def storage(self) -> Optional['outputs.TrinoTelemetryConfigResponse']:
        """
        Trino user telemetry definition.
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class TrinoWorkerResponse(dict):
    """
    Trino worker.
    """
    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 port: Optional[int] = None,
                 suspend: Optional[bool] = None):
        """
        Trino worker.
        :param bool enable: The flag that if enable debug or not.
        :param int port: The debug port.
        :param bool suspend: The flag that if suspend debug or not.
        """
        TrinoWorkerResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable=enable,
            port=port,
            suspend=suspend,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable: Optional[bool] = None,
             port: Optional[int] = None,
             suspend: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enable is None:
            enable = False
        if enable is not None:
            _setter("enable", enable)
        if port is None:
            port = 8008
        if port is not None:
            _setter("port", port)
        if suspend is None:
            suspend = False
        if suspend is not None:
            _setter("suspend", suspend)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        The flag that if enable debug or not.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The debug port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[bool]:
        """
        The flag that if suspend debug or not.
        """
        return pulumi.get(self, "suspend")


