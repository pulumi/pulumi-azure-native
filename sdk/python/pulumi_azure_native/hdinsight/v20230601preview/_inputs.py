# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AuthorizationProfileArgs',
    'AuthorizationProfileArgsDict',
    'AutoscaleProfileArgs',
    'AutoscaleProfileArgsDict',
    'CatalogOptionsArgs',
    'CatalogOptionsArgsDict',
    'ClusterConfigFileArgs',
    'ClusterConfigFileArgsDict',
    'ClusterLogAnalyticsApplicationLogsArgs',
    'ClusterLogAnalyticsApplicationLogsArgsDict',
    'ClusterLogAnalyticsProfileArgs',
    'ClusterLogAnalyticsProfileArgsDict',
    'ClusterPoolResourcePropertiesClusterPoolProfileArgs',
    'ClusterPoolResourcePropertiesClusterPoolProfileArgsDict',
    'ClusterPoolResourcePropertiesComputeProfileArgs',
    'ClusterPoolResourcePropertiesComputeProfileArgsDict',
    'ClusterPoolResourcePropertiesLogAnalyticsProfileArgs',
    'ClusterPoolResourcePropertiesLogAnalyticsProfileArgsDict',
    'ClusterPoolResourcePropertiesNetworkProfileArgs',
    'ClusterPoolResourcePropertiesNetworkProfileArgsDict',
    'ClusterProfileArgs',
    'ClusterProfileArgsDict',
    'ClusterPrometheusProfileArgs',
    'ClusterPrometheusProfileArgsDict',
    'ClusterServiceConfigsProfileArgs',
    'ClusterServiceConfigsProfileArgsDict',
    'ClusterServiceConfigArgs',
    'ClusterServiceConfigArgsDict',
    'ComparisonRuleArgs',
    'ComparisonRuleArgsDict',
    'ComputeProfileArgs',
    'ComputeProfileArgsDict',
    'ComputeResourceDefinitionArgs',
    'ComputeResourceDefinitionArgsDict',
    'FlinkCatalogOptionsArgs',
    'FlinkCatalogOptionsArgsDict',
    'FlinkHiveCatalogOptionArgs',
    'FlinkHiveCatalogOptionArgsDict',
    'FlinkProfileArgs',
    'FlinkProfileArgsDict',
    'FlinkStorageProfileArgs',
    'FlinkStorageProfileArgsDict',
    'HiveCatalogOptionArgs',
    'HiveCatalogOptionArgsDict',
    'IdentityProfileArgs',
    'IdentityProfileArgsDict',
    'LoadBasedConfigArgs',
    'LoadBasedConfigArgsDict',
    'NodeProfileArgs',
    'NodeProfileArgsDict',
    'ScalingRuleArgs',
    'ScalingRuleArgsDict',
    'ScheduleBasedConfigArgs',
    'ScheduleBasedConfigArgsDict',
    'ScheduleArgs',
    'ScheduleArgsDict',
    'ScriptActionProfileArgs',
    'ScriptActionProfileArgsDict',
    'SecretReferenceArgs',
    'SecretReferenceArgsDict',
    'SecretsProfileArgs',
    'SecretsProfileArgsDict',
    'SparkMetastoreSpecArgs',
    'SparkMetastoreSpecArgsDict',
    'SparkProfileArgs',
    'SparkProfileArgsDict',
    'SparkUserPluginsArgs',
    'SparkUserPluginsArgsDict',
    'SparkUserPluginArgs',
    'SparkUserPluginArgsDict',
    'SshProfileArgs',
    'SshProfileArgsDict',
    'TrinoCoordinatorArgs',
    'TrinoCoordinatorArgsDict',
    'TrinoProfileArgs',
    'TrinoProfileArgsDict',
    'TrinoTelemetryConfigArgs',
    'TrinoTelemetryConfigArgsDict',
    'TrinoUserPluginsArgs',
    'TrinoUserPluginsArgsDict',
    'TrinoUserPluginArgs',
    'TrinoUserPluginArgsDict',
    'TrinoUserTelemetryArgs',
    'TrinoUserTelemetryArgsDict',
    'TrinoWorkerArgs',
    'TrinoWorkerArgsDict',
]

MYPY = False

if not MYPY:
    class AuthorizationProfileArgsDict(TypedDict):
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        """
        group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        AAD group Ids authorized for data plane access.
        """
        user_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        AAD user Ids authorized for data plane access.
        """
elif False:
    AuthorizationProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationProfileArgs:
    def __init__(__self__, *,
                 group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_ids: AAD group Ids authorized for data plane access.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_ids: AAD user Ids authorized for data plane access.
        """
        if group_ids is not None:
            pulumi.set(__self__, "group_ids", group_ids)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        AAD group Ids authorized for data plane access.
        """
        return pulumi.get(self, "group_ids")

    @group_ids.setter
    def group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_ids", value)

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        AAD user Ids authorized for data plane access.
        """
        return pulumi.get(self, "user_ids")

    @user_ids.setter
    def user_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_ids", value)


if not MYPY:
    class AutoscaleProfileArgsDict(TypedDict):
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        """
        enabled: pulumi.Input[bool]
        """
        This indicates whether auto scale is enabled on HDInsight on AKS cluster.
        """
        autoscale_type: NotRequired[pulumi.Input[Union[str, 'AutoscaleType']]]
        """
        User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        """
        graceful_decommission_timeout: NotRequired[pulumi.Input[int]]
        """
        This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        """
        load_based_config: NotRequired[pulumi.Input['LoadBasedConfigArgsDict']]
        """
        Profiles of load based Autoscale.
        """
        schedule_based_config: NotRequired[pulumi.Input['ScheduleBasedConfigArgsDict']]
        """
        Profiles of schedule based Autoscale.
        """
elif False:
    AutoscaleProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleProfileArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 autoscale_type: Optional[pulumi.Input[Union[str, 'AutoscaleType']]] = None,
                 graceful_decommission_timeout: Optional[pulumi.Input[int]] = None,
                 load_based_config: Optional[pulumi.Input['LoadBasedConfigArgs']] = None,
                 schedule_based_config: Optional[pulumi.Input['ScheduleBasedConfigArgs']] = None):
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        :param pulumi.Input[bool] enabled: This indicates whether auto scale is enabled on HDInsight on AKS cluster.
        :param pulumi.Input[Union[str, 'AutoscaleType']] autoscale_type: User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        :param pulumi.Input[int] graceful_decommission_timeout: This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        :param pulumi.Input['LoadBasedConfigArgs'] load_based_config: Profiles of load based Autoscale.
        :param pulumi.Input['ScheduleBasedConfigArgs'] schedule_based_config: Profiles of schedule based Autoscale.
        """
        pulumi.set(__self__, "enabled", enabled)
        if autoscale_type is not None:
            pulumi.set(__self__, "autoscale_type", autoscale_type)
        if graceful_decommission_timeout is not None:
            pulumi.set(__self__, "graceful_decommission_timeout", graceful_decommission_timeout)
        if load_based_config is not None:
            pulumi.set(__self__, "load_based_config", load_based_config)
        if schedule_based_config is not None:
            pulumi.set(__self__, "schedule_based_config", schedule_based_config)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        This indicates whether auto scale is enabled on HDInsight on AKS cluster.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="autoscaleType")
    def autoscale_type(self) -> Optional[pulumi.Input[Union[str, 'AutoscaleType']]]:
        """
        User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        """
        return pulumi.get(self, "autoscale_type")

    @autoscale_type.setter
    def autoscale_type(self, value: Optional[pulumi.Input[Union[str, 'AutoscaleType']]]):
        pulumi.set(self, "autoscale_type", value)

    @property
    @pulumi.getter(name="gracefulDecommissionTimeout")
    def graceful_decommission_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        """
        return pulumi.get(self, "graceful_decommission_timeout")

    @graceful_decommission_timeout.setter
    def graceful_decommission_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "graceful_decommission_timeout", value)

    @property
    @pulumi.getter(name="loadBasedConfig")
    def load_based_config(self) -> Optional[pulumi.Input['LoadBasedConfigArgs']]:
        """
        Profiles of load based Autoscale.
        """
        return pulumi.get(self, "load_based_config")

    @load_based_config.setter
    def load_based_config(self, value: Optional[pulumi.Input['LoadBasedConfigArgs']]):
        pulumi.set(self, "load_based_config", value)

    @property
    @pulumi.getter(name="scheduleBasedConfig")
    def schedule_based_config(self) -> Optional[pulumi.Input['ScheduleBasedConfigArgs']]:
        """
        Profiles of schedule based Autoscale.
        """
        return pulumi.get(self, "schedule_based_config")

    @schedule_based_config.setter
    def schedule_based_config(self, value: Optional[pulumi.Input['ScheduleBasedConfigArgs']]):
        pulumi.set(self, "schedule_based_config", value)


if not MYPY:
    class CatalogOptionsArgsDict(TypedDict):
        """
        Trino cluster catalog options.
        """
        hive: NotRequired[pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgsDict']]]]
        """
        hive catalog options.
        """
elif False:
    CatalogOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogOptionsArgs:
    def __init__(__self__, *,
                 hive: Optional[pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgs']]]] = None):
        """
        Trino cluster catalog options.
        :param pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgs']]] hive: hive catalog options.
        """
        if hive is not None:
            pulumi.set(__self__, "hive", hive)

    @property
    @pulumi.getter
    def hive(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgs']]]]:
        """
        hive catalog options.
        """
        return pulumi.get(self, "hive")

    @hive.setter
    def hive(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgs']]]]):
        pulumi.set(self, "hive", value)


if not MYPY:
    class ClusterConfigFileArgsDict(TypedDict):
        """
        Cluster configuration files.
        """
        file_name: pulumi.Input[str]
        """
        Configuration file name.
        """
        content: NotRequired[pulumi.Input[str]]
        """
        Free form content of the entire configuration file.
        """
        encoding: NotRequired[pulumi.Input[Union[str, 'ContentEncoding']]]
        """
        This property indicates if the content is encoded and is case-insensitive. Please set the value to base64 if the content is base64 encoded. Set it to none or skip it if the content is plain text.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path of the config file if content is specified.
        """
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        List of key value pairs
        where key represents a valid service configuration name and value represents the value of the config.
        """
elif False:
    ClusterConfigFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterConfigFileArgs:
    def __init__(__self__, *,
                 file_name: pulumi.Input[str],
                 content: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[Union[str, 'ContentEncoding']]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Cluster configuration files.
        :param pulumi.Input[str] file_name: Configuration file name.
        :param pulumi.Input[str] content: Free form content of the entire configuration file.
        :param pulumi.Input[Union[str, 'ContentEncoding']] encoding: This property indicates if the content is encoded and is case-insensitive. Please set the value to base64 if the content is base64 encoded. Set it to none or skip it if the content is plain text.
        :param pulumi.Input[str] path: Path of the config file if content is specified.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] values: List of key value pairs
               where key represents a valid service configuration name and value represents the value of the config.
        """
        pulumi.set(__self__, "file_name", file_name)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> pulumi.Input[str]:
        """
        Configuration file name.
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Free form content of the entire configuration file.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[Union[str, 'ContentEncoding']]]:
        """
        This property indicates if the content is encoded and is case-insensitive. Please set the value to base64 if the content is base64 encoded. Set it to none or skip it if the content is plain text.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[Union[str, 'ContentEncoding']]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path of the config file if content is specified.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        List of key value pairs
        where key represents a valid service configuration name and value represents the value of the config.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ClusterLogAnalyticsApplicationLogsArgsDict(TypedDict):
        """
        Collection of logs to be enabled or disabled for log analytics.
        """
        std_error_enabled: NotRequired[pulumi.Input[bool]]
        """
        True if stderror is enabled, otherwise false.
        """
        std_out_enabled: NotRequired[pulumi.Input[bool]]
        """
        True if stdout is enabled, otherwise false.
        """
elif False:
    ClusterLogAnalyticsApplicationLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLogAnalyticsApplicationLogsArgs:
    def __init__(__self__, *,
                 std_error_enabled: Optional[pulumi.Input[bool]] = None,
                 std_out_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Collection of logs to be enabled or disabled for log analytics.
        :param pulumi.Input[bool] std_error_enabled: True if stderror is enabled, otherwise false.
        :param pulumi.Input[bool] std_out_enabled: True if stdout is enabled, otherwise false.
        """
        if std_error_enabled is not None:
            pulumi.set(__self__, "std_error_enabled", std_error_enabled)
        if std_out_enabled is not None:
            pulumi.set(__self__, "std_out_enabled", std_out_enabled)

    @property
    @pulumi.getter(name="stdErrorEnabled")
    def std_error_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if stderror is enabled, otherwise false.
        """
        return pulumi.get(self, "std_error_enabled")

    @std_error_enabled.setter
    def std_error_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "std_error_enabled", value)

    @property
    @pulumi.getter(name="stdOutEnabled")
    def std_out_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if stdout is enabled, otherwise false.
        """
        return pulumi.get(self, "std_out_enabled")

    @std_out_enabled.setter
    def std_out_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "std_out_enabled", value)


if not MYPY:
    class ClusterLogAnalyticsProfileArgsDict(TypedDict):
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        """
        enabled: pulumi.Input[bool]
        """
        True if log analytics is enabled for the cluster, otherwise false.
        """
        application_logs: NotRequired[pulumi.Input['ClusterLogAnalyticsApplicationLogsArgsDict']]
        """
        Collection of logs to be enabled or disabled for log analytics.
        """
        metrics_enabled: NotRequired[pulumi.Input[bool]]
        """
        True if metrics are enabled, otherwise false.
        """
elif False:
    ClusterLogAnalyticsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLogAnalyticsProfileArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 application_logs: Optional[pulumi.Input['ClusterLogAnalyticsApplicationLogsArgs']] = None,
                 metrics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        :param pulumi.Input[bool] enabled: True if log analytics is enabled for the cluster, otherwise false.
        :param pulumi.Input['ClusterLogAnalyticsApplicationLogsArgs'] application_logs: Collection of logs to be enabled or disabled for log analytics.
        :param pulumi.Input[bool] metrics_enabled: True if metrics are enabled, otherwise false.
        """
        pulumi.set(__self__, "enabled", enabled)
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if metrics_enabled is not None:
            pulumi.set(__self__, "metrics_enabled", metrics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        True if log analytics is enabled for the cluster, otherwise false.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional[pulumi.Input['ClusterLogAnalyticsApplicationLogsArgs']]:
        """
        Collection of logs to be enabled or disabled for log analytics.
        """
        return pulumi.get(self, "application_logs")

    @application_logs.setter
    def application_logs(self, value: Optional[pulumi.Input['ClusterLogAnalyticsApplicationLogsArgs']]):
        pulumi.set(self, "application_logs", value)

    @property
    @pulumi.getter(name="metricsEnabled")
    def metrics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if metrics are enabled, otherwise false.
        """
        return pulumi.get(self, "metrics_enabled")

    @metrics_enabled.setter
    def metrics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "metrics_enabled", value)


if not MYPY:
    class ClusterPoolResourcePropertiesClusterPoolProfileArgsDict(TypedDict):
        """
        CLuster pool profile.
        """
        cluster_pool_version: pulumi.Input[str]
        """
        Cluster pool version is a 2-part version.
        """
elif False:
    ClusterPoolResourcePropertiesClusterPoolProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPoolResourcePropertiesClusterPoolProfileArgs:
    def __init__(__self__, *,
                 cluster_pool_version: pulumi.Input[str]):
        """
        CLuster pool profile.
        :param pulumi.Input[str] cluster_pool_version: Cluster pool version is a 2-part version.
        """
        pulumi.set(__self__, "cluster_pool_version", cluster_pool_version)

    @property
    @pulumi.getter(name="clusterPoolVersion")
    def cluster_pool_version(self) -> pulumi.Input[str]:
        """
        Cluster pool version is a 2-part version.
        """
        return pulumi.get(self, "cluster_pool_version")

    @cluster_pool_version.setter
    def cluster_pool_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_pool_version", value)


if not MYPY:
    class ClusterPoolResourcePropertiesComputeProfileArgsDict(TypedDict):
        """
        CLuster pool compute profile.
        """
        vm_size: pulumi.Input[str]
        """
        The virtual machine SKU.
        """
elif False:
    ClusterPoolResourcePropertiesComputeProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPoolResourcePropertiesComputeProfileArgs:
    def __init__(__self__, *,
                 vm_size: pulumi.Input[str]):
        """
        CLuster pool compute profile.
        :param pulumi.Input[str] vm_size: The virtual machine SKU.
        """
        pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> pulumi.Input[str]:
        """
        The virtual machine SKU.
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_size", value)


if not MYPY:
    class ClusterPoolResourcePropertiesLogAnalyticsProfileArgsDict(TypedDict):
        """
        Cluster pool log analytics profile to enable OMS agent for AKS cluster.
        """
        enabled: pulumi.Input[bool]
        """
        True if log analytics is enabled for cluster pool, otherwise false.
        """
        workspace_id: NotRequired[pulumi.Input[str]]
        """
        Log analytics workspace to associate with the OMS agent.
        """
elif False:
    ClusterPoolResourcePropertiesLogAnalyticsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPoolResourcePropertiesLogAnalyticsProfileArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 workspace_id: Optional[pulumi.Input[str]] = None):
        """
        Cluster pool log analytics profile to enable OMS agent for AKS cluster.
        :param pulumi.Input[bool] enabled: True if log analytics is enabled for cluster pool, otherwise false.
        :param pulumi.Input[str] workspace_id: Log analytics workspace to associate with the OMS agent.
        """
        pulumi.set(__self__, "enabled", enabled)
        if workspace_id is not None:
            pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        True if log analytics is enabled for cluster pool, otherwise false.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> Optional[pulumi.Input[str]]:
        """
        Log analytics workspace to associate with the OMS agent.
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workspace_id", value)


if not MYPY:
    class ClusterPoolResourcePropertiesNetworkProfileArgsDict(TypedDict):
        """
        Cluster pool network profile.
        """
        subnet_id: pulumi.Input[str]
        """
        Cluster pool subnet resource id.
        """
elif False:
    ClusterPoolResourcePropertiesNetworkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPoolResourcePropertiesNetworkProfileArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str]):
        """
        Cluster pool network profile.
        :param pulumi.Input[str] subnet_id: Cluster pool subnet resource id.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        Cluster pool subnet resource id.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class ClusterProfileArgsDict(TypedDict):
        """
        Cluster profile.
        """
        authorization_profile: pulumi.Input['AuthorizationProfileArgsDict']
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        """
        cluster_version: pulumi.Input[str]
        """
        Version with 3/4 part.
        """
        identity_profile: pulumi.Input['IdentityProfileArgsDict']
        """
        Identity Profile with details of an MSI.
        """
        oss_version: pulumi.Input[str]
        """
        Version with three part.
        """
        autoscale_profile: NotRequired[pulumi.Input['AutoscaleProfileArgsDict']]
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        """
        flink_profile: NotRequired[pulumi.Input['FlinkProfileArgsDict']]
        """
        The Flink cluster profile.
        """
        kafka_profile: NotRequired[Any]
        """
        Kafka cluster profile.
        """
        llap_profile: NotRequired[Any]
        """
        LLAP cluster profile.
        """
        log_analytics_profile: NotRequired[pulumi.Input['ClusterLogAnalyticsProfileArgsDict']]
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        """
        prometheus_profile: NotRequired[pulumi.Input['ClusterPrometheusProfileArgsDict']]
        """
        Cluster Prometheus profile.
        """
        script_action_profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgsDict']]]]
        """
        The script action profile list.
        """
        secrets_profile: NotRequired[pulumi.Input['SecretsProfileArgsDict']]
        """
        The cluster secret profile.
        """
        service_configs_profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgsDict']]]]
        """
        The service configs profiles.
        """
        spark_profile: NotRequired[pulumi.Input['SparkProfileArgsDict']]
        """
        The spark cluster profile.
        """
        ssh_profile: NotRequired[pulumi.Input['SshProfileArgsDict']]
        """
        Ssh profile for the cluster.
        """
        stub_profile: NotRequired[Any]
        """
        Stub cluster profile.
        """
        trino_profile: NotRequired[pulumi.Input['TrinoProfileArgsDict']]
        """
        Trino Cluster profile.
        """
elif False:
    ClusterProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterProfileArgs:
    def __init__(__self__, *,
                 authorization_profile: pulumi.Input['AuthorizationProfileArgs'],
                 cluster_version: pulumi.Input[str],
                 identity_profile: pulumi.Input['IdentityProfileArgs'],
                 oss_version: pulumi.Input[str],
                 autoscale_profile: Optional[pulumi.Input['AutoscaleProfileArgs']] = None,
                 flink_profile: Optional[pulumi.Input['FlinkProfileArgs']] = None,
                 kafka_profile: Optional[Any] = None,
                 llap_profile: Optional[Any] = None,
                 log_analytics_profile: Optional[pulumi.Input['ClusterLogAnalyticsProfileArgs']] = None,
                 prometheus_profile: Optional[pulumi.Input['ClusterPrometheusProfileArgs']] = None,
                 script_action_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgs']]]] = None,
                 secrets_profile: Optional[pulumi.Input['SecretsProfileArgs']] = None,
                 service_configs_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgs']]]] = None,
                 spark_profile: Optional[pulumi.Input['SparkProfileArgs']] = None,
                 ssh_profile: Optional[pulumi.Input['SshProfileArgs']] = None,
                 stub_profile: Optional[Any] = None,
                 trino_profile: Optional[pulumi.Input['TrinoProfileArgs']] = None):
        """
        Cluster profile.
        :param pulumi.Input['AuthorizationProfileArgs'] authorization_profile: Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        :param pulumi.Input[str] cluster_version: Version with 3/4 part.
        :param pulumi.Input['IdentityProfileArgs'] identity_profile: Identity Profile with details of an MSI.
        :param pulumi.Input[str] oss_version: Version with three part.
        :param pulumi.Input['AutoscaleProfileArgs'] autoscale_profile: This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        :param pulumi.Input['FlinkProfileArgs'] flink_profile: The Flink cluster profile.
        :param Any kafka_profile: Kafka cluster profile.
        :param Any llap_profile: LLAP cluster profile.
        :param pulumi.Input['ClusterLogAnalyticsProfileArgs'] log_analytics_profile: Cluster log analytics profile to enable or disable OMS agent for cluster.
        :param pulumi.Input['ClusterPrometheusProfileArgs'] prometheus_profile: Cluster Prometheus profile.
        :param pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgs']]] script_action_profiles: The script action profile list.
        :param pulumi.Input['SecretsProfileArgs'] secrets_profile: The cluster secret profile.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgs']]] service_configs_profiles: The service configs profiles.
        :param pulumi.Input['SparkProfileArgs'] spark_profile: The spark cluster profile.
        :param pulumi.Input['SshProfileArgs'] ssh_profile: Ssh profile for the cluster.
        :param Any stub_profile: Stub cluster profile.
        :param pulumi.Input['TrinoProfileArgs'] trino_profile: Trino Cluster profile.
        """
        pulumi.set(__self__, "authorization_profile", authorization_profile)
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "identity_profile", identity_profile)
        pulumi.set(__self__, "oss_version", oss_version)
        if autoscale_profile is not None:
            pulumi.set(__self__, "autoscale_profile", autoscale_profile)
        if flink_profile is not None:
            pulumi.set(__self__, "flink_profile", flink_profile)
        if kafka_profile is not None:
            pulumi.set(__self__, "kafka_profile", kafka_profile)
        if llap_profile is not None:
            pulumi.set(__self__, "llap_profile", llap_profile)
        if log_analytics_profile is not None:
            pulumi.set(__self__, "log_analytics_profile", log_analytics_profile)
        if prometheus_profile is not None:
            pulumi.set(__self__, "prometheus_profile", prometheus_profile)
        if script_action_profiles is not None:
            pulumi.set(__self__, "script_action_profiles", script_action_profiles)
        if secrets_profile is not None:
            pulumi.set(__self__, "secrets_profile", secrets_profile)
        if service_configs_profiles is not None:
            pulumi.set(__self__, "service_configs_profiles", service_configs_profiles)
        if spark_profile is not None:
            pulumi.set(__self__, "spark_profile", spark_profile)
        if ssh_profile is not None:
            pulumi.set(__self__, "ssh_profile", ssh_profile)
        if stub_profile is not None:
            pulumi.set(__self__, "stub_profile", stub_profile)
        if trino_profile is not None:
            pulumi.set(__self__, "trino_profile", trino_profile)

    @property
    @pulumi.getter(name="authorizationProfile")
    def authorization_profile(self) -> pulumi.Input['AuthorizationProfileArgs']:
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        """
        return pulumi.get(self, "authorization_profile")

    @authorization_profile.setter
    def authorization_profile(self, value: pulumi.Input['AuthorizationProfileArgs']):
        pulumi.set(self, "authorization_profile", value)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> pulumi.Input[str]:
        """
        Version with 3/4 part.
        """
        return pulumi.get(self, "cluster_version")

    @cluster_version.setter
    def cluster_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_version", value)

    @property
    @pulumi.getter(name="identityProfile")
    def identity_profile(self) -> pulumi.Input['IdentityProfileArgs']:
        """
        Identity Profile with details of an MSI.
        """
        return pulumi.get(self, "identity_profile")

    @identity_profile.setter
    def identity_profile(self, value: pulumi.Input['IdentityProfileArgs']):
        pulumi.set(self, "identity_profile", value)

    @property
    @pulumi.getter(name="ossVersion")
    def oss_version(self) -> pulumi.Input[str]:
        """
        Version with three part.
        """
        return pulumi.get(self, "oss_version")

    @oss_version.setter
    def oss_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "oss_version", value)

    @property
    @pulumi.getter(name="autoscaleProfile")
    def autoscale_profile(self) -> Optional[pulumi.Input['AutoscaleProfileArgs']]:
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        """
        return pulumi.get(self, "autoscale_profile")

    @autoscale_profile.setter
    def autoscale_profile(self, value: Optional[pulumi.Input['AutoscaleProfileArgs']]):
        pulumi.set(self, "autoscale_profile", value)

    @property
    @pulumi.getter(name="flinkProfile")
    def flink_profile(self) -> Optional[pulumi.Input['FlinkProfileArgs']]:
        """
        The Flink cluster profile.
        """
        return pulumi.get(self, "flink_profile")

    @flink_profile.setter
    def flink_profile(self, value: Optional[pulumi.Input['FlinkProfileArgs']]):
        pulumi.set(self, "flink_profile", value)

    @property
    @pulumi.getter(name="kafkaProfile")
    def kafka_profile(self) -> Optional[Any]:
        """
        Kafka cluster profile.
        """
        return pulumi.get(self, "kafka_profile")

    @kafka_profile.setter
    def kafka_profile(self, value: Optional[Any]):
        pulumi.set(self, "kafka_profile", value)

    @property
    @pulumi.getter(name="llapProfile")
    def llap_profile(self) -> Optional[Any]:
        """
        LLAP cluster profile.
        """
        return pulumi.get(self, "llap_profile")

    @llap_profile.setter
    def llap_profile(self, value: Optional[Any]):
        pulumi.set(self, "llap_profile", value)

    @property
    @pulumi.getter(name="logAnalyticsProfile")
    def log_analytics_profile(self) -> Optional[pulumi.Input['ClusterLogAnalyticsProfileArgs']]:
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        """
        return pulumi.get(self, "log_analytics_profile")

    @log_analytics_profile.setter
    def log_analytics_profile(self, value: Optional[pulumi.Input['ClusterLogAnalyticsProfileArgs']]):
        pulumi.set(self, "log_analytics_profile", value)

    @property
    @pulumi.getter(name="prometheusProfile")
    def prometheus_profile(self) -> Optional[pulumi.Input['ClusterPrometheusProfileArgs']]:
        """
        Cluster Prometheus profile.
        """
        return pulumi.get(self, "prometheus_profile")

    @prometheus_profile.setter
    def prometheus_profile(self, value: Optional[pulumi.Input['ClusterPrometheusProfileArgs']]):
        pulumi.set(self, "prometheus_profile", value)

    @property
    @pulumi.getter(name="scriptActionProfiles")
    def script_action_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgs']]]]:
        """
        The script action profile list.
        """
        return pulumi.get(self, "script_action_profiles")

    @script_action_profiles.setter
    def script_action_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgs']]]]):
        pulumi.set(self, "script_action_profiles", value)

    @property
    @pulumi.getter(name="secretsProfile")
    def secrets_profile(self) -> Optional[pulumi.Input['SecretsProfileArgs']]:
        """
        The cluster secret profile.
        """
        return pulumi.get(self, "secrets_profile")

    @secrets_profile.setter
    def secrets_profile(self, value: Optional[pulumi.Input['SecretsProfileArgs']]):
        pulumi.set(self, "secrets_profile", value)

    @property
    @pulumi.getter(name="serviceConfigsProfiles")
    def service_configs_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgs']]]]:
        """
        The service configs profiles.
        """
        return pulumi.get(self, "service_configs_profiles")

    @service_configs_profiles.setter
    def service_configs_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgs']]]]):
        pulumi.set(self, "service_configs_profiles", value)

    @property
    @pulumi.getter(name="sparkProfile")
    def spark_profile(self) -> Optional[pulumi.Input['SparkProfileArgs']]:
        """
        The spark cluster profile.
        """
        return pulumi.get(self, "spark_profile")

    @spark_profile.setter
    def spark_profile(self, value: Optional[pulumi.Input['SparkProfileArgs']]):
        pulumi.set(self, "spark_profile", value)

    @property
    @pulumi.getter(name="sshProfile")
    def ssh_profile(self) -> Optional[pulumi.Input['SshProfileArgs']]:
        """
        Ssh profile for the cluster.
        """
        return pulumi.get(self, "ssh_profile")

    @ssh_profile.setter
    def ssh_profile(self, value: Optional[pulumi.Input['SshProfileArgs']]):
        pulumi.set(self, "ssh_profile", value)

    @property
    @pulumi.getter(name="stubProfile")
    def stub_profile(self) -> Optional[Any]:
        """
        Stub cluster profile.
        """
        return pulumi.get(self, "stub_profile")

    @stub_profile.setter
    def stub_profile(self, value: Optional[Any]):
        pulumi.set(self, "stub_profile", value)

    @property
    @pulumi.getter(name="trinoProfile")
    def trino_profile(self) -> Optional[pulumi.Input['TrinoProfileArgs']]:
        """
        Trino Cluster profile.
        """
        return pulumi.get(self, "trino_profile")

    @trino_profile.setter
    def trino_profile(self, value: Optional[pulumi.Input['TrinoProfileArgs']]):
        pulumi.set(self, "trino_profile", value)


if not MYPY:
    class ClusterPrometheusProfileArgsDict(TypedDict):
        """
        Cluster Prometheus profile.
        """
        enabled: pulumi.Input[bool]
        """
        Enable Prometheus for cluster or not.
        """
elif False:
    ClusterPrometheusProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPrometheusProfileArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Cluster Prometheus profile.
        :param pulumi.Input[bool] enabled: Enable Prometheus for cluster or not.
        """
        if enabled is None:
            enabled = False
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Enable Prometheus for cluster or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterServiceConfigsProfileArgsDict(TypedDict):
        """
        Cluster service configs.
        """
        configs: pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgsDict']]]
        """
        List of service configs.
        """
        service_name: pulumi.Input[str]
        """
        Name of the service the configurations should apply to.
        """
elif False:
    ClusterServiceConfigsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterServiceConfigsProfileArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgs']]],
                 service_name: pulumi.Input[str]):
        """
        Cluster service configs.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgs']]] configs: List of service configs.
        :param pulumi.Input[str] service_name: Name of the service the configurations should apply to.
        """
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgs']]]:
        """
        List of service configs.
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgs']]]):
        pulumi.set(self, "configs", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        """
        Name of the service the configurations should apply to.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class ClusterServiceConfigArgsDict(TypedDict):
        """
        Cluster configs per component.
        """
        component: pulumi.Input[str]
        """
        Name of the component the config files should apply to.
        """
        files: pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgsDict']]]
        """
        List of Config Files.
        """
elif False:
    ClusterServiceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterServiceConfigArgs:
    def __init__(__self__, *,
                 component: pulumi.Input[str],
                 files: pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgs']]]):
        """
        Cluster configs per component.
        :param pulumi.Input[str] component: Name of the component the config files should apply to.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgs']]] files: List of Config Files.
        """
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def component(self) -> pulumi.Input[str]:
        """
        Name of the component the config files should apply to.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: pulumi.Input[str]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def files(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgs']]]:
        """
        List of Config Files.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgs']]]):
        pulumi.set(self, "files", value)


if not MYPY:
    class ComparisonRuleArgsDict(TypedDict):
        """
        The comparison rule.
        """
        operator: pulumi.Input[Union[str, 'ComparisonOperator']]
        """
        The comparison operator.
        """
        threshold: pulumi.Input[float]
        """
        Threshold setting.
        """
elif False:
    ComparisonRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComparisonRuleArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'ComparisonOperator']],
                 threshold: pulumi.Input[float]):
        """
        The comparison rule.
        :param pulumi.Input[Union[str, 'ComparisonOperator']] operator: The comparison operator.
        :param pulumi.Input[float] threshold: Threshold setting.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'ComparisonOperator']]:
        """
        The comparison operator.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'ComparisonOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        Threshold setting.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class ComputeProfileArgsDict(TypedDict):
        """
        The compute profile.
        """
        nodes: pulumi.Input[Sequence[pulumi.Input['NodeProfileArgsDict']]]
        """
        The nodes definitions.
        """
elif False:
    ComputeProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeProfileArgs:
    def __init__(__self__, *,
                 nodes: pulumi.Input[Sequence[pulumi.Input['NodeProfileArgs']]]):
        """
        The compute profile.
        :param pulumi.Input[Sequence[pulumi.Input['NodeProfileArgs']]] nodes: The nodes definitions.
        """
        pulumi.set(__self__, "nodes", nodes)

    @property
    @pulumi.getter
    def nodes(self) -> pulumi.Input[Sequence[pulumi.Input['NodeProfileArgs']]]:
        """
        The nodes definitions.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: pulumi.Input[Sequence[pulumi.Input['NodeProfileArgs']]]):
        pulumi.set(self, "nodes", value)


if not MYPY:
    class ComputeResourceDefinitionArgsDict(TypedDict):
        """
        The cpu and memory requirement definition.
        """
        cpu: pulumi.Input[float]
        """
        The required CPU.
        """
        memory: pulumi.Input[float]
        """
        The required memory in MB, Container memory will be 110 percentile
        """
elif False:
    ComputeResourceDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeResourceDefinitionArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[float],
                 memory: pulumi.Input[float]):
        """
        The cpu and memory requirement definition.
        :param pulumi.Input[float] cpu: The required CPU.
        :param pulumi.Input[float] memory: The required memory in MB, Container memory will be 110 percentile
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[float]:
        """
        The required CPU.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[float]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[float]:
        """
        The required memory in MB, Container memory will be 110 percentile
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[float]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class FlinkCatalogOptionsArgsDict(TypedDict):
        """
        Flink cluster catalog options.
        """
        hive: NotRequired[pulumi.Input['FlinkHiveCatalogOptionArgsDict']]
        """
        Hive Catalog Option for Flink cluster.
        """
elif False:
    FlinkCatalogOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlinkCatalogOptionsArgs:
    def __init__(__self__, *,
                 hive: Optional[pulumi.Input['FlinkHiveCatalogOptionArgs']] = None):
        """
        Flink cluster catalog options.
        :param pulumi.Input['FlinkHiveCatalogOptionArgs'] hive: Hive Catalog Option for Flink cluster.
        """
        if hive is not None:
            pulumi.set(__self__, "hive", hive)

    @property
    @pulumi.getter
    def hive(self) -> Optional[pulumi.Input['FlinkHiveCatalogOptionArgs']]:
        """
        Hive Catalog Option for Flink cluster.
        """
        return pulumi.get(self, "hive")

    @hive.setter
    def hive(self, value: Optional[pulumi.Input['FlinkHiveCatalogOptionArgs']]):
        pulumi.set(self, "hive", value)


if not MYPY:
    class FlinkHiveCatalogOptionArgsDict(TypedDict):
        """
        Hive Catalog Option for Flink cluster.
        """
        metastore_db_connection_password_secret: pulumi.Input[str]
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        metastore_db_connection_url: pulumi.Input[str]
        """
        Connection string for hive metastore database.
        """
        metastore_db_connection_user_name: pulumi.Input[str]
        """
        User name for database connection.
        """
elif False:
    FlinkHiveCatalogOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlinkHiveCatalogOptionArgs:
    def __init__(__self__, *,
                 metastore_db_connection_password_secret: pulumi.Input[str],
                 metastore_db_connection_url: pulumi.Input[str],
                 metastore_db_connection_user_name: pulumi.Input[str]):
        """
        Hive Catalog Option for Flink cluster.
        :param pulumi.Input[str] metastore_db_connection_password_secret: Secret reference name from secretsProfile.secrets containing password for database connection.
        :param pulumi.Input[str] metastore_db_connection_url: Connection string for hive metastore database.
        :param pulumi.Input[str] metastore_db_connection_user_name: User name for database connection.
        """
        pulumi.set(__self__, "metastore_db_connection_password_secret", metastore_db_connection_password_secret)
        pulumi.set(__self__, "metastore_db_connection_url", metastore_db_connection_url)
        pulumi.set(__self__, "metastore_db_connection_user_name", metastore_db_connection_user_name)

    @property
    @pulumi.getter(name="metastoreDbConnectionPasswordSecret")
    def metastore_db_connection_password_secret(self) -> pulumi.Input[str]:
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_password_secret")

    @metastore_db_connection_password_secret.setter
    def metastore_db_connection_password_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_password_secret", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionURL")
    def metastore_db_connection_url(self) -> pulumi.Input[str]:
        """
        Connection string for hive metastore database.
        """
        return pulumi.get(self, "metastore_db_connection_url")

    @metastore_db_connection_url.setter
    def metastore_db_connection_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_url", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionUserName")
    def metastore_db_connection_user_name(self) -> pulumi.Input[str]:
        """
        User name for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_user_name")

    @metastore_db_connection_user_name.setter
    def metastore_db_connection_user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_user_name", value)


if not MYPY:
    class FlinkProfileArgsDict(TypedDict):
        """
        The Flink cluster profile.
        """
        job_manager: pulumi.Input['ComputeResourceDefinitionArgsDict']
        """
        Job Manager container/ process CPU and memory requirements
        """
        storage: pulumi.Input['FlinkStorageProfileArgsDict']
        """
        The storage profile
        """
        task_manager: pulumi.Input['ComputeResourceDefinitionArgsDict']
        """
        Task Manager container/ process CPU and memory requirements
        """
        catalog_options: NotRequired[pulumi.Input['FlinkCatalogOptionsArgsDict']]
        """
        Flink cluster catalog options.
        """
        history_server: NotRequired[pulumi.Input['ComputeResourceDefinitionArgsDict']]
        """
        History Server container/ process CPU and memory requirements
        """
        num_replicas: NotRequired[pulumi.Input[int]]
        """
        The number of task managers.
        """
elif False:
    FlinkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlinkProfileArgs:
    def __init__(__self__, *,
                 job_manager: pulumi.Input['ComputeResourceDefinitionArgs'],
                 storage: pulumi.Input['FlinkStorageProfileArgs'],
                 task_manager: pulumi.Input['ComputeResourceDefinitionArgs'],
                 catalog_options: Optional[pulumi.Input['FlinkCatalogOptionsArgs']] = None,
                 history_server: Optional[pulumi.Input['ComputeResourceDefinitionArgs']] = None,
                 num_replicas: Optional[pulumi.Input[int]] = None):
        """
        The Flink cluster profile.
        :param pulumi.Input['ComputeResourceDefinitionArgs'] job_manager: Job Manager container/ process CPU and memory requirements
        :param pulumi.Input['FlinkStorageProfileArgs'] storage: The storage profile
        :param pulumi.Input['ComputeResourceDefinitionArgs'] task_manager: Task Manager container/ process CPU and memory requirements
        :param pulumi.Input['FlinkCatalogOptionsArgs'] catalog_options: Flink cluster catalog options.
        :param pulumi.Input['ComputeResourceDefinitionArgs'] history_server: History Server container/ process CPU and memory requirements
        :param pulumi.Input[int] num_replicas: The number of task managers.
        """
        pulumi.set(__self__, "job_manager", job_manager)
        pulumi.set(__self__, "storage", storage)
        pulumi.set(__self__, "task_manager", task_manager)
        if catalog_options is not None:
            pulumi.set(__self__, "catalog_options", catalog_options)
        if history_server is not None:
            pulumi.set(__self__, "history_server", history_server)
        if num_replicas is not None:
            pulumi.set(__self__, "num_replicas", num_replicas)

    @property
    @pulumi.getter(name="jobManager")
    def job_manager(self) -> pulumi.Input['ComputeResourceDefinitionArgs']:
        """
        Job Manager container/ process CPU and memory requirements
        """
        return pulumi.get(self, "job_manager")

    @job_manager.setter
    def job_manager(self, value: pulumi.Input['ComputeResourceDefinitionArgs']):
        pulumi.set(self, "job_manager", value)

    @property
    @pulumi.getter
    def storage(self) -> pulumi.Input['FlinkStorageProfileArgs']:
        """
        The storage profile
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: pulumi.Input['FlinkStorageProfileArgs']):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter(name="taskManager")
    def task_manager(self) -> pulumi.Input['ComputeResourceDefinitionArgs']:
        """
        Task Manager container/ process CPU and memory requirements
        """
        return pulumi.get(self, "task_manager")

    @task_manager.setter
    def task_manager(self, value: pulumi.Input['ComputeResourceDefinitionArgs']):
        pulumi.set(self, "task_manager", value)

    @property
    @pulumi.getter(name="catalogOptions")
    def catalog_options(self) -> Optional[pulumi.Input['FlinkCatalogOptionsArgs']]:
        """
        Flink cluster catalog options.
        """
        return pulumi.get(self, "catalog_options")

    @catalog_options.setter
    def catalog_options(self, value: Optional[pulumi.Input['FlinkCatalogOptionsArgs']]):
        pulumi.set(self, "catalog_options", value)

    @property
    @pulumi.getter(name="historyServer")
    def history_server(self) -> Optional[pulumi.Input['ComputeResourceDefinitionArgs']]:
        """
        History Server container/ process CPU and memory requirements
        """
        return pulumi.get(self, "history_server")

    @history_server.setter
    def history_server(self, value: Optional[pulumi.Input['ComputeResourceDefinitionArgs']]):
        pulumi.set(self, "history_server", value)

    @property
    @pulumi.getter(name="numReplicas")
    def num_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of task managers.
        """
        return pulumi.get(self, "num_replicas")

    @num_replicas.setter
    def num_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_replicas", value)


if not MYPY:
    class FlinkStorageProfileArgsDict(TypedDict):
        """
        The storage profile
        """
        storage_uri: pulumi.Input[str]
        """
        Storage account uri which is used for savepoint and checkpoint state.
        """
        storagekey: NotRequired[pulumi.Input[str]]
        """
        Storage key is only required for wasb(s) storage.
        """
elif False:
    FlinkStorageProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlinkStorageProfileArgs:
    def __init__(__self__, *,
                 storage_uri: pulumi.Input[str],
                 storagekey: Optional[pulumi.Input[str]] = None):
        """
        The storage profile
        :param pulumi.Input[str] storage_uri: Storage account uri which is used for savepoint and checkpoint state.
        :param pulumi.Input[str] storagekey: Storage key is only required for wasb(s) storage.
        """
        pulumi.set(__self__, "storage_uri", storage_uri)
        if storagekey is not None:
            pulumi.set(__self__, "storagekey", storagekey)

    @property
    @pulumi.getter(name="storageUri")
    def storage_uri(self) -> pulumi.Input[str]:
        """
        Storage account uri which is used for savepoint and checkpoint state.
        """
        return pulumi.get(self, "storage_uri")

    @storage_uri.setter
    def storage_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_uri", value)

    @property
    @pulumi.getter
    def storagekey(self) -> Optional[pulumi.Input[str]]:
        """
        Storage key is only required for wasb(s) storage.
        """
        return pulumi.get(self, "storagekey")

    @storagekey.setter
    def storagekey(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storagekey", value)


if not MYPY:
    class HiveCatalogOptionArgsDict(TypedDict):
        """
        Hive Catalog Option
        """
        catalog_name: pulumi.Input[str]
        """
        Name of trino catalog which should use specified hive metastore.
        """
        metastore_db_connection_password_secret: pulumi.Input[str]
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        metastore_db_connection_url: pulumi.Input[str]
        """
        Connection string for hive metastore database.
        """
        metastore_db_connection_user_name: pulumi.Input[str]
        """
        User name for database connection.
        """
        metastore_warehouse_dir: pulumi.Input[str]
        """
        Metastore root directory URI, format: abfs[s]://<container>@<account_name>.dfs.core.windows.net/<path>. More details: https://docs.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-introduction-abfs-uri
        """
elif False:
    HiveCatalogOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HiveCatalogOptionArgs:
    def __init__(__self__, *,
                 catalog_name: pulumi.Input[str],
                 metastore_db_connection_password_secret: pulumi.Input[str],
                 metastore_db_connection_url: pulumi.Input[str],
                 metastore_db_connection_user_name: pulumi.Input[str],
                 metastore_warehouse_dir: pulumi.Input[str]):
        """
        Hive Catalog Option
        :param pulumi.Input[str] catalog_name: Name of trino catalog which should use specified hive metastore.
        :param pulumi.Input[str] metastore_db_connection_password_secret: Secret reference name from secretsProfile.secrets containing password for database connection.
        :param pulumi.Input[str] metastore_db_connection_url: Connection string for hive metastore database.
        :param pulumi.Input[str] metastore_db_connection_user_name: User name for database connection.
        :param pulumi.Input[str] metastore_warehouse_dir: Metastore root directory URI, format: abfs[s]://<container>@<account_name>.dfs.core.windows.net/<path>. More details: https://docs.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-introduction-abfs-uri
        """
        pulumi.set(__self__, "catalog_name", catalog_name)
        pulumi.set(__self__, "metastore_db_connection_password_secret", metastore_db_connection_password_secret)
        pulumi.set(__self__, "metastore_db_connection_url", metastore_db_connection_url)
        pulumi.set(__self__, "metastore_db_connection_user_name", metastore_db_connection_user_name)
        pulumi.set(__self__, "metastore_warehouse_dir", metastore_warehouse_dir)

    @property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> pulumi.Input[str]:
        """
        Name of trino catalog which should use specified hive metastore.
        """
        return pulumi.get(self, "catalog_name")

    @catalog_name.setter
    def catalog_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "catalog_name", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionPasswordSecret")
    def metastore_db_connection_password_secret(self) -> pulumi.Input[str]:
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_password_secret")

    @metastore_db_connection_password_secret.setter
    def metastore_db_connection_password_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_password_secret", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionURL")
    def metastore_db_connection_url(self) -> pulumi.Input[str]:
        """
        Connection string for hive metastore database.
        """
        return pulumi.get(self, "metastore_db_connection_url")

    @metastore_db_connection_url.setter
    def metastore_db_connection_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_url", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionUserName")
    def metastore_db_connection_user_name(self) -> pulumi.Input[str]:
        """
        User name for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_user_name")

    @metastore_db_connection_user_name.setter
    def metastore_db_connection_user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_user_name", value)

    @property
    @pulumi.getter(name="metastoreWarehouseDir")
    def metastore_warehouse_dir(self) -> pulumi.Input[str]:
        """
        Metastore root directory URI, format: abfs[s]://<container>@<account_name>.dfs.core.windows.net/<path>. More details: https://docs.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-introduction-abfs-uri
        """
        return pulumi.get(self, "metastore_warehouse_dir")

    @metastore_warehouse_dir.setter
    def metastore_warehouse_dir(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_warehouse_dir", value)


if not MYPY:
    class IdentityProfileArgsDict(TypedDict):
        """
        Identity Profile with details of an MSI.
        """
        msi_client_id: pulumi.Input[str]
        """
        ClientId of the MSI.
        """
        msi_object_id: pulumi.Input[str]
        """
        ObjectId of the MSI.
        """
        msi_resource_id: pulumi.Input[str]
        """
        ResourceId of the MSI.
        """
elif False:
    IdentityProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityProfileArgs:
    def __init__(__self__, *,
                 msi_client_id: pulumi.Input[str],
                 msi_object_id: pulumi.Input[str],
                 msi_resource_id: pulumi.Input[str]):
        """
        Identity Profile with details of an MSI.
        :param pulumi.Input[str] msi_client_id: ClientId of the MSI.
        :param pulumi.Input[str] msi_object_id: ObjectId of the MSI.
        :param pulumi.Input[str] msi_resource_id: ResourceId of the MSI.
        """
        pulumi.set(__self__, "msi_client_id", msi_client_id)
        pulumi.set(__self__, "msi_object_id", msi_object_id)
        pulumi.set(__self__, "msi_resource_id", msi_resource_id)

    @property
    @pulumi.getter(name="msiClientId")
    def msi_client_id(self) -> pulumi.Input[str]:
        """
        ClientId of the MSI.
        """
        return pulumi.get(self, "msi_client_id")

    @msi_client_id.setter
    def msi_client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "msi_client_id", value)

    @property
    @pulumi.getter(name="msiObjectId")
    def msi_object_id(self) -> pulumi.Input[str]:
        """
        ObjectId of the MSI.
        """
        return pulumi.get(self, "msi_object_id")

    @msi_object_id.setter
    def msi_object_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "msi_object_id", value)

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> pulumi.Input[str]:
        """
        ResourceId of the MSI.
        """
        return pulumi.get(self, "msi_resource_id")

    @msi_resource_id.setter
    def msi_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "msi_resource_id", value)


if not MYPY:
    class LoadBasedConfigArgsDict(TypedDict):
        """
        Profile of load based Autoscale.
        """
        max_nodes: pulumi.Input[int]
        """
        User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        min_nodes: pulumi.Input[int]
        """
        User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        scaling_rules: pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgsDict']]]
        """
        The scaling rules.
        """
        cooldown_period: NotRequired[pulumi.Input[int]]
        """
        This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.
        """
        poll_interval: NotRequired[pulumi.Input[int]]
        """
        User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.
        """
elif False:
    LoadBasedConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBasedConfigArgs:
    def __init__(__self__, *,
                 max_nodes: pulumi.Input[int],
                 min_nodes: pulumi.Input[int],
                 scaling_rules: pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgs']]],
                 cooldown_period: Optional[pulumi.Input[int]] = None,
                 poll_interval: Optional[pulumi.Input[int]] = None):
        """
        Profile of load based Autoscale.
        :param pulumi.Input[int] max_nodes: User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        :param pulumi.Input[int] min_nodes: User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        :param pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgs']]] scaling_rules: The scaling rules.
        :param pulumi.Input[int] cooldown_period: This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.
        :param pulumi.Input[int] poll_interval: User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.
        """
        pulumi.set(__self__, "max_nodes", max_nodes)
        pulumi.set(__self__, "min_nodes", min_nodes)
        pulumi.set(__self__, "scaling_rules", scaling_rules)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if poll_interval is not None:
            pulumi.set(__self__, "poll_interval", poll_interval)

    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> pulumi.Input[int]:
        """
        User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        return pulumi.get(self, "max_nodes")

    @max_nodes.setter
    def max_nodes(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_nodes", value)

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> pulumi.Input[int]:
        """
        User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        return pulumi.get(self, "min_nodes")

    @min_nodes.setter
    def min_nodes(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_nodes", value)

    @property
    @pulumi.getter(name="scalingRules")
    def scaling_rules(self) -> pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgs']]]:
        """
        The scaling rules.
        """
        return pulumi.get(self, "scaling_rules")

    @scaling_rules.setter
    def scaling_rules(self, value: pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgs']]]):
        pulumi.set(self, "scaling_rules", value)

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[pulumi.Input[int]]:
        """
        This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.
        """
        return pulumi.get(self, "cooldown_period")

    @cooldown_period.setter
    def cooldown_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown_period", value)

    @property
    @pulumi.getter(name="pollInterval")
    def poll_interval(self) -> Optional[pulumi.Input[int]]:
        """
        User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.
        """
        return pulumi.get(self, "poll_interval")

    @poll_interval.setter
    def poll_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "poll_interval", value)


if not MYPY:
    class NodeProfileArgsDict(TypedDict):
        """
        The node profile.
        """
        count: pulumi.Input[int]
        """
        The number of virtual machines.
        """
        type: pulumi.Input[str]
        """
        The node type.
        """
        vm_size: pulumi.Input[str]
        """
        The virtual machine SKU.
        """
elif False:
    NodeProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeProfileArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 type: pulumi.Input[str],
                 vm_size: pulumi.Input[str]):
        """
        The node profile.
        :param pulumi.Input[int] count: The number of virtual machines.
        :param pulumi.Input[str] type: The node type.
        :param pulumi.Input[str] vm_size: The virtual machine SKU.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of virtual machines.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The node type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> pulumi.Input[str]:
        """
        The virtual machine SKU.
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_size", value)


if not MYPY:
    class ScalingRuleArgsDict(TypedDict):
        """
        The scaling rule.
        """
        action_type: pulumi.Input[Union[str, 'ScaleActionType']]
        """
        The action type.
        """
        comparison_rule: pulumi.Input['ComparisonRuleArgsDict']
        """
        The comparison rule.
        """
        evaluation_count: pulumi.Input[int]
        """
        This is an evaluation count for a scaling condition, the number of times a trigger condition should be successful, before scaling activity is triggered.
        """
        scaling_metric: pulumi.Input[str]
        """
        Metrics name for individual workloads. For example: cpu
        """
elif False:
    ScalingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScalingRuleArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[Union[str, 'ScaleActionType']],
                 comparison_rule: pulumi.Input['ComparisonRuleArgs'],
                 evaluation_count: pulumi.Input[int],
                 scaling_metric: pulumi.Input[str]):
        """
        The scaling rule.
        :param pulumi.Input[Union[str, 'ScaleActionType']] action_type: The action type.
        :param pulumi.Input['ComparisonRuleArgs'] comparison_rule: The comparison rule.
        :param pulumi.Input[int] evaluation_count: This is an evaluation count for a scaling condition, the number of times a trigger condition should be successful, before scaling activity is triggered.
        :param pulumi.Input[str] scaling_metric: Metrics name for individual workloads. For example: cpu
        """
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "comparison_rule", comparison_rule)
        pulumi.set(__self__, "evaluation_count", evaluation_count)
        pulumi.set(__self__, "scaling_metric", scaling_metric)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[Union[str, 'ScaleActionType']]:
        """
        The action type.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[Union[str, 'ScaleActionType']]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="comparisonRule")
    def comparison_rule(self) -> pulumi.Input['ComparisonRuleArgs']:
        """
        The comparison rule.
        """
        return pulumi.get(self, "comparison_rule")

    @comparison_rule.setter
    def comparison_rule(self, value: pulumi.Input['ComparisonRuleArgs']):
        pulumi.set(self, "comparison_rule", value)

    @property
    @pulumi.getter(name="evaluationCount")
    def evaluation_count(self) -> pulumi.Input[int]:
        """
        This is an evaluation count for a scaling condition, the number of times a trigger condition should be successful, before scaling activity is triggered.
        """
        return pulumi.get(self, "evaluation_count")

    @evaluation_count.setter
    def evaluation_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "evaluation_count", value)

    @property
    @pulumi.getter(name="scalingMetric")
    def scaling_metric(self) -> pulumi.Input[str]:
        """
        Metrics name for individual workloads. For example: cpu
        """
        return pulumi.get(self, "scaling_metric")

    @scaling_metric.setter
    def scaling_metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "scaling_metric", value)


if not MYPY:
    class ScheduleBasedConfigArgsDict(TypedDict):
        """
        Profile of schedule based Autoscale.
        """
        default_count: pulumi.Input[int]
        """
        Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)
        """
        schedules: pulumi.Input[Sequence[pulumi.Input['ScheduleArgsDict']]]
        """
        This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).
        """
        time_zone: pulumi.Input[str]
        """
        User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        """
elif False:
    ScheduleBasedConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleBasedConfigArgs:
    def __init__(__self__, *,
                 default_count: pulumi.Input[int],
                 schedules: pulumi.Input[Sequence[pulumi.Input['ScheduleArgs']]],
                 time_zone: pulumi.Input[str]):
        """
        Profile of schedule based Autoscale.
        :param pulumi.Input[int] default_count: Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleArgs']]] schedules: This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).
        :param pulumi.Input[str] time_zone: User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        """
        pulumi.set(__self__, "default_count", default_count)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="defaultCount")
    def default_count(self) -> pulumi.Input[int]:
        """
        Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)
        """
        return pulumi.get(self, "default_count")

    @default_count.setter
    def default_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "default_count", value)

    @property
    @pulumi.getter
    def schedules(self) -> pulumi.Input[Sequence[pulumi.Input['ScheduleArgs']]]:
        """
        This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).
        """
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: pulumi.Input[Sequence[pulumi.Input['ScheduleArgs']]]):
        pulumi.set(self, "schedules", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[str]:
        """
        User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class ScheduleArgsDict(TypedDict):
        """
        Schedule definition.
        """
        count: pulumi.Input[int]
        """
        User has to set the node count anticipated at end of the scaling operation of the set current schedule configuration, format is integer.
        """
        days: pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]]
        """
        User has to set the days where schedule has to be set for autoscale operation.
        """
        end_time: pulumi.Input[str]
        """
        User has to set the end time of current schedule configuration, format like 10:30 (HH:MM).
        """
        start_time: pulumi.Input[str]
        """
        User has to set the start time of current schedule configuration, format like 10:30 (HH:MM).
        """
elif False:
    ScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 days: pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]],
                 end_time: pulumi.Input[str],
                 start_time: pulumi.Input[str]):
        """
        Schedule definition.
        :param pulumi.Input[int] count: User has to set the node count anticipated at end of the scaling operation of the set current schedule configuration, format is integer.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]] days: User has to set the days where schedule has to be set for autoscale operation.
        :param pulumi.Input[str] end_time: User has to set the end time of current schedule configuration, format like 10:30 (HH:MM).
        :param pulumi.Input[str] start_time: User has to set the start time of current schedule configuration, format like 10:30 (HH:MM).
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        User has to set the node count anticipated at end of the scaling operation of the set current schedule configuration, format is integer.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def days(self) -> pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]]:
        """
        User has to set the days where schedule has to be set for autoscale operation.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[str]:
        """
        User has to set the end time of current schedule configuration, format like 10:30 (HH:MM).
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        User has to set the start time of current schedule configuration, format like 10:30 (HH:MM).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class ScriptActionProfileArgsDict(TypedDict):
        """
        The script action profile.
        """
        name: pulumi.Input[str]
        """
        Script name.
        """
        services: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of services to apply the script action.
        """
        type: pulumi.Input[str]
        """
        Type of the script action. Supported type is bash scripts.
        """
        url: pulumi.Input[str]
        """
        Url of the script file.
        """
        parameters: NotRequired[pulumi.Input[str]]
        """
        Additional parameters for the script action. It should be space-separated list of arguments required for script execution.
        """
        should_persist: NotRequired[pulumi.Input[bool]]
        """
        Specify if the script should persist on the cluster.
        """
        timeout_in_minutes: NotRequired[pulumi.Input[int]]
        """
        Timeout duration for the script action in minutes.
        """
elif False:
    ScriptActionProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScriptActionProfileArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 services: pulumi.Input[Sequence[pulumi.Input[str]]],
                 type: pulumi.Input[str],
                 url: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[str]] = None,
                 should_persist: Optional[pulumi.Input[bool]] = None,
                 timeout_in_minutes: Optional[pulumi.Input[int]] = None):
        """
        The script action profile.
        :param pulumi.Input[str] name: Script name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of services to apply the script action.
        :param pulumi.Input[str] type: Type of the script action. Supported type is bash scripts.
        :param pulumi.Input[str] url: Url of the script file.
        :param pulumi.Input[str] parameters: Additional parameters for the script action. It should be space-separated list of arguments required for script execution.
        :param pulumi.Input[bool] should_persist: Specify if the script should persist on the cluster.
        :param pulumi.Input[int] timeout_in_minutes: Timeout duration for the script action in minutes.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if should_persist is None:
            should_persist = True
        if should_persist is not None:
            pulumi.set(__self__, "should_persist", should_persist)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Script name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def services(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of services to apply the script action.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the script action. Supported type is bash scripts.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Url of the script file.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional parameters for the script action. It should be space-separated list of arguments required for script execution.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="shouldPersist")
    def should_persist(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if the script should persist on the cluster.
        """
        return pulumi.get(self, "should_persist")

    @should_persist.setter
    def should_persist(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_persist", value)

    @property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout duration for the script action in minutes.
        """
        return pulumi.get(self, "timeout_in_minutes")

    @timeout_in_minutes.setter
    def timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_minutes", value)


if not MYPY:
    class SecretReferenceArgsDict(TypedDict):
        """
        Secret reference and corresponding properties of a key vault secret.
        """
        key_vault_object_name: pulumi.Input[str]
        """
        Object identifier name of the secret in key vault.
        """
        reference_name: pulumi.Input[str]
        """
        Reference name of the secret to be used in service configs.
        """
        type: pulumi.Input[Union[str, 'KeyVaultObjectType']]
        """
        Type of key vault object: secret, key or certificate.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the secret in key vault.
        """
elif False:
    SecretReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretReferenceArgs:
    def __init__(__self__, *,
                 key_vault_object_name: pulumi.Input[str],
                 reference_name: pulumi.Input[str],
                 type: pulumi.Input[Union[str, 'KeyVaultObjectType']],
                 version: Optional[pulumi.Input[str]] = None):
        """
        Secret reference and corresponding properties of a key vault secret.
        :param pulumi.Input[str] key_vault_object_name: Object identifier name of the secret in key vault.
        :param pulumi.Input[str] reference_name: Reference name of the secret to be used in service configs.
        :param pulumi.Input[Union[str, 'KeyVaultObjectType']] type: Type of key vault object: secret, key or certificate.
        :param pulumi.Input[str] version: Version of the secret in key vault.
        """
        pulumi.set(__self__, "key_vault_object_name", key_vault_object_name)
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="keyVaultObjectName")
    def key_vault_object_name(self) -> pulumi.Input[str]:
        """
        Object identifier name of the secret in key vault.
        """
        return pulumi.get(self, "key_vault_object_name")

    @key_vault_object_name.setter
    def key_vault_object_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_object_name", value)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> pulumi.Input[str]:
        """
        Reference name of the secret to be used in service configs.
        """
        return pulumi.get(self, "reference_name")

    @reference_name.setter
    def reference_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'KeyVaultObjectType']]:
        """
        Type of key vault object: secret, key or certificate.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'KeyVaultObjectType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the secret in key vault.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class SecretsProfileArgsDict(TypedDict):
        """
        The cluster secret profile.
        """
        key_vault_resource_id: pulumi.Input[str]
        """
        Name of the user Key Vault where all the cluster specific user secrets are stored.
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgsDict']]]]
        """
        Properties of Key Vault secret.
        """
elif False:
    SecretsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretsProfileArgs:
    def __init__(__self__, *,
                 key_vault_resource_id: pulumi.Input[str],
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgs']]]] = None):
        """
        The cluster secret profile.
        :param pulumi.Input[str] key_vault_resource_id: Name of the user Key Vault where all the cluster specific user secrets are stored.
        :param pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgs']]] secrets: Properties of Key Vault secret.
        """
        pulumi.set(__self__, "key_vault_resource_id", key_vault_resource_id)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> pulumi.Input[str]:
        """
        Name of the user Key Vault where all the cluster specific user secrets are stored.
        """
        return pulumi.get(self, "key_vault_resource_id")

    @key_vault_resource_id.setter
    def key_vault_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_resource_id", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgs']]]]:
        """
        Properties of Key Vault secret.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgs']]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class SparkMetastoreSpecArgsDict(TypedDict):
        """
        The metastore specification for Spark cluster.
        """
        db_name: pulumi.Input[str]
        """
        The database name.
        """
        db_password_secret_name: pulumi.Input[str]
        """
        The secret name which contains the database user password.
        """
        db_server_host: pulumi.Input[str]
        """
        The database server host.
        """
        db_user_name: pulumi.Input[str]
        """
        The database user name.
        """
        key_vault_id: pulumi.Input[str]
        """
        The key vault resource id.
        """
        thrift_url: NotRequired[pulumi.Input[str]]
        """
        The thrift url.
        """
elif False:
    SparkMetastoreSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SparkMetastoreSpecArgs:
    def __init__(__self__, *,
                 db_name: pulumi.Input[str],
                 db_password_secret_name: pulumi.Input[str],
                 db_server_host: pulumi.Input[str],
                 db_user_name: pulumi.Input[str],
                 key_vault_id: pulumi.Input[str],
                 thrift_url: Optional[pulumi.Input[str]] = None):
        """
        The metastore specification for Spark cluster.
        :param pulumi.Input[str] db_name: The database name.
        :param pulumi.Input[str] db_password_secret_name: The secret name which contains the database user password.
        :param pulumi.Input[str] db_server_host: The database server host.
        :param pulumi.Input[str] db_user_name: The database user name.
        :param pulumi.Input[str] key_vault_id: The key vault resource id.
        :param pulumi.Input[str] thrift_url: The thrift url.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_password_secret_name", db_password_secret_name)
        pulumi.set(__self__, "db_server_host", db_server_host)
        pulumi.set(__self__, "db_user_name", db_user_name)
        pulumi.set(__self__, "key_vault_id", key_vault_id)
        if thrift_url is not None:
            pulumi.set(__self__, "thrift_url", thrift_url)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        The database name.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="dbPasswordSecretName")
    def db_password_secret_name(self) -> pulumi.Input[str]:
        """
        The secret name which contains the database user password.
        """
        return pulumi.get(self, "db_password_secret_name")

    @db_password_secret_name.setter
    def db_password_secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_password_secret_name", value)

    @property
    @pulumi.getter(name="dbServerHost")
    def db_server_host(self) -> pulumi.Input[str]:
        """
        The database server host.
        """
        return pulumi.get(self, "db_server_host")

    @db_server_host.setter
    def db_server_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_server_host", value)

    @property
    @pulumi.getter(name="dbUserName")
    def db_user_name(self) -> pulumi.Input[str]:
        """
        The database user name.
        """
        return pulumi.get(self, "db_user_name")

    @db_user_name.setter
    def db_user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_user_name", value)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> pulumi.Input[str]:
        """
        The key vault resource id.
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_id", value)

    @property
    @pulumi.getter(name="thriftUrl")
    def thrift_url(self) -> Optional[pulumi.Input[str]]:
        """
        The thrift url.
        """
        return pulumi.get(self, "thrift_url")

    @thrift_url.setter
    def thrift_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thrift_url", value)


if not MYPY:
    class SparkProfileArgsDict(TypedDict):
        """
        The spark cluster profile.
        """
        default_storage_url: NotRequired[pulumi.Input[str]]
        """
        The default storage URL.
        """
        metastore_spec: NotRequired[pulumi.Input['SparkMetastoreSpecArgsDict']]
        """
        The metastore specification for Spark cluster.
        """
        user_plugins_spec: NotRequired[pulumi.Input['SparkUserPluginsArgsDict']]
        """
        Spark user plugins spec
        """
elif False:
    SparkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SparkProfileArgs:
    def __init__(__self__, *,
                 default_storage_url: Optional[pulumi.Input[str]] = None,
                 metastore_spec: Optional[pulumi.Input['SparkMetastoreSpecArgs']] = None,
                 user_plugins_spec: Optional[pulumi.Input['SparkUserPluginsArgs']] = None):
        """
        The spark cluster profile.
        :param pulumi.Input[str] default_storage_url: The default storage URL.
        :param pulumi.Input['SparkMetastoreSpecArgs'] metastore_spec: The metastore specification for Spark cluster.
        :param pulumi.Input['SparkUserPluginsArgs'] user_plugins_spec: Spark user plugins spec
        """
        if default_storage_url is not None:
            pulumi.set(__self__, "default_storage_url", default_storage_url)
        if metastore_spec is not None:
            pulumi.set(__self__, "metastore_spec", metastore_spec)
        if user_plugins_spec is not None:
            pulumi.set(__self__, "user_plugins_spec", user_plugins_spec)

    @property
    @pulumi.getter(name="defaultStorageUrl")
    def default_storage_url(self) -> Optional[pulumi.Input[str]]:
        """
        The default storage URL.
        """
        return pulumi.get(self, "default_storage_url")

    @default_storage_url.setter
    def default_storage_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_storage_url", value)

    @property
    @pulumi.getter(name="metastoreSpec")
    def metastore_spec(self) -> Optional[pulumi.Input['SparkMetastoreSpecArgs']]:
        """
        The metastore specification for Spark cluster.
        """
        return pulumi.get(self, "metastore_spec")

    @metastore_spec.setter
    def metastore_spec(self, value: Optional[pulumi.Input['SparkMetastoreSpecArgs']]):
        pulumi.set(self, "metastore_spec", value)

    @property
    @pulumi.getter(name="userPluginsSpec")
    def user_plugins_spec(self) -> Optional[pulumi.Input['SparkUserPluginsArgs']]:
        """
        Spark user plugins spec
        """
        return pulumi.get(self, "user_plugins_spec")

    @user_plugins_spec.setter
    def user_plugins_spec(self, value: Optional[pulumi.Input['SparkUserPluginsArgs']]):
        pulumi.set(self, "user_plugins_spec", value)


if not MYPY:
    class SparkUserPluginsArgsDict(TypedDict):
        """
        Spark user plugins spec
        """
        plugins: NotRequired[pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgsDict']]]]
        """
        Spark user plugins.
        """
elif False:
    SparkUserPluginsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SparkUserPluginsArgs:
    def __init__(__self__, *,
                 plugins: Optional[pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgs']]]] = None):
        """
        Spark user plugins spec
        :param pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgs']]] plugins: Spark user plugins.
        """
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgs']]]]:
        """
        Spark user plugins.
        """
        return pulumi.get(self, "plugins")

    @plugins.setter
    def plugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgs']]]]):
        pulumi.set(self, "plugins", value)


if not MYPY:
    class SparkUserPluginArgsDict(TypedDict):
        """
        Spark user plugin.
        """
        path: pulumi.Input[str]
        """
        Fully qualified path to the folder containing the plugins.
        """
elif False:
    SparkUserPluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SparkUserPluginArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str]):
        """
        Spark user plugin.
        :param pulumi.Input[str] path: Fully qualified path to the folder containing the plugins.
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Fully qualified path to the folder containing the plugins.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class SshProfileArgsDict(TypedDict):
        """
        Ssh profile for the cluster.
        """
        count: pulumi.Input[int]
        """
        Number of ssh pods per cluster.
        """
elif False:
    SshProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshProfileArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int]):
        """
        Ssh profile for the cluster.
        :param pulumi.Input[int] count: Number of ssh pods per cluster.
        """
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        Number of ssh pods per cluster.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)


if not MYPY:
    class TrinoCoordinatorArgsDict(TypedDict):
        """
        Trino Coordinator.
        """
        enable: NotRequired[pulumi.Input[bool]]
        """
        The flag that if enable debug or not.
        """
        high_availability_enabled: NotRequired[pulumi.Input[bool]]
        """
        The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The debug port.
        """
        suspend: NotRequired[pulumi.Input[bool]]
        """
        The flag that if suspend debug or not.
        """
elif False:
    TrinoCoordinatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoCoordinatorArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 high_availability_enabled: Optional[pulumi.Input[bool]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 suspend: Optional[pulumi.Input[bool]] = None):
        """
        Trino Coordinator.
        :param pulumi.Input[bool] enable: The flag that if enable debug or not.
        :param pulumi.Input[bool] high_availability_enabled: The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.
        :param pulumi.Input[int] port: The debug port.
        :param pulumi.Input[bool] suspend: The flag that if suspend debug or not.
        """
        if enable is None:
            enable = False
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if high_availability_enabled is None:
            high_availability_enabled = True
        if high_availability_enabled is not None:
            pulumi.set(__self__, "high_availability_enabled", high_availability_enabled)
        if port is None:
            port = 8008
        if port is not None:
            pulumi.set(__self__, "port", port)
        if suspend is None:
            suspend = False
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if enable debug or not.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="highAvailabilityEnabled")
    def high_availability_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.
        """
        return pulumi.get(self, "high_availability_enabled")

    @high_availability_enabled.setter
    def high_availability_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "high_availability_enabled", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The debug port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if suspend debug or not.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suspend", value)


if not MYPY:
    class TrinoProfileArgsDict(TypedDict):
        """
        Trino Cluster profile.
        """
        catalog_options: NotRequired[pulumi.Input['CatalogOptionsArgsDict']]
        """
        Trino cluster catalog options.
        """
        coordinator: NotRequired[pulumi.Input['TrinoCoordinatorArgsDict']]
        """
        Trino Coordinator.
        """
        user_plugins_spec: NotRequired[pulumi.Input['TrinoUserPluginsArgsDict']]
        """
        Trino user plugins spec
        """
        user_telemetry_spec: NotRequired[pulumi.Input['TrinoUserTelemetryArgsDict']]
        """
        User telemetry
        """
        worker: NotRequired[pulumi.Input['TrinoWorkerArgsDict']]
        """
        Trino worker.
        """
elif False:
    TrinoProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoProfileArgs:
    def __init__(__self__, *,
                 catalog_options: Optional[pulumi.Input['CatalogOptionsArgs']] = None,
                 coordinator: Optional[pulumi.Input['TrinoCoordinatorArgs']] = None,
                 user_plugins_spec: Optional[pulumi.Input['TrinoUserPluginsArgs']] = None,
                 user_telemetry_spec: Optional[pulumi.Input['TrinoUserTelemetryArgs']] = None,
                 worker: Optional[pulumi.Input['TrinoWorkerArgs']] = None):
        """
        Trino Cluster profile.
        :param pulumi.Input['CatalogOptionsArgs'] catalog_options: Trino cluster catalog options.
        :param pulumi.Input['TrinoCoordinatorArgs'] coordinator: Trino Coordinator.
        :param pulumi.Input['TrinoUserPluginsArgs'] user_plugins_spec: Trino user plugins spec
        :param pulumi.Input['TrinoUserTelemetryArgs'] user_telemetry_spec: User telemetry
        :param pulumi.Input['TrinoWorkerArgs'] worker: Trino worker.
        """
        if catalog_options is not None:
            pulumi.set(__self__, "catalog_options", catalog_options)
        if coordinator is not None:
            pulumi.set(__self__, "coordinator", coordinator)
        if user_plugins_spec is not None:
            pulumi.set(__self__, "user_plugins_spec", user_plugins_spec)
        if user_telemetry_spec is not None:
            pulumi.set(__self__, "user_telemetry_spec", user_telemetry_spec)
        if worker is not None:
            pulumi.set(__self__, "worker", worker)

    @property
    @pulumi.getter(name="catalogOptions")
    def catalog_options(self) -> Optional[pulumi.Input['CatalogOptionsArgs']]:
        """
        Trino cluster catalog options.
        """
        return pulumi.get(self, "catalog_options")

    @catalog_options.setter
    def catalog_options(self, value: Optional[pulumi.Input['CatalogOptionsArgs']]):
        pulumi.set(self, "catalog_options", value)

    @property
    @pulumi.getter
    def coordinator(self) -> Optional[pulumi.Input['TrinoCoordinatorArgs']]:
        """
        Trino Coordinator.
        """
        return pulumi.get(self, "coordinator")

    @coordinator.setter
    def coordinator(self, value: Optional[pulumi.Input['TrinoCoordinatorArgs']]):
        pulumi.set(self, "coordinator", value)

    @property
    @pulumi.getter(name="userPluginsSpec")
    def user_plugins_spec(self) -> Optional[pulumi.Input['TrinoUserPluginsArgs']]:
        """
        Trino user plugins spec
        """
        return pulumi.get(self, "user_plugins_spec")

    @user_plugins_spec.setter
    def user_plugins_spec(self, value: Optional[pulumi.Input['TrinoUserPluginsArgs']]):
        pulumi.set(self, "user_plugins_spec", value)

    @property
    @pulumi.getter(name="userTelemetrySpec")
    def user_telemetry_spec(self) -> Optional[pulumi.Input['TrinoUserTelemetryArgs']]:
        """
        User telemetry
        """
        return pulumi.get(self, "user_telemetry_spec")

    @user_telemetry_spec.setter
    def user_telemetry_spec(self, value: Optional[pulumi.Input['TrinoUserTelemetryArgs']]):
        pulumi.set(self, "user_telemetry_spec", value)

    @property
    @pulumi.getter
    def worker(self) -> Optional[pulumi.Input['TrinoWorkerArgs']]:
        """
        Trino worker.
        """
        return pulumi.get(self, "worker")

    @worker.setter
    def worker(self, value: Optional[pulumi.Input['TrinoWorkerArgs']]):
        pulumi.set(self, "worker", value)


if not MYPY:
    class TrinoTelemetryConfigArgsDict(TypedDict):
        """
        Trino user telemetry definition.
        """
        hivecatalog_name: NotRequired[pulumi.Input[str]]
        """
        Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        """
        hivecatalog_schema: NotRequired[pulumi.Input[str]]
        """
        Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.
        """
        partition_retention_in_days: NotRequired[pulumi.Input[int]]
        """
        Retention period for query log table partitions, this doesn't have any affect on actual data.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Azure storage location of the blobs.
        """
elif False:
    TrinoTelemetryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoTelemetryConfigArgs:
    def __init__(__self__, *,
                 hivecatalog_name: Optional[pulumi.Input[str]] = None,
                 hivecatalog_schema: Optional[pulumi.Input[str]] = None,
                 partition_retention_in_days: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        Trino user telemetry definition.
        :param pulumi.Input[str] hivecatalog_name: Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        :param pulumi.Input[str] hivecatalog_schema: Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.
        :param pulumi.Input[int] partition_retention_in_days: Retention period for query log table partitions, this doesn't have any affect on actual data.
        :param pulumi.Input[str] path: Azure storage location of the blobs.
        """
        if hivecatalog_name is not None:
            pulumi.set(__self__, "hivecatalog_name", hivecatalog_name)
        if hivecatalog_schema is None:
            hivecatalog_schema = 'trinologs'
        if hivecatalog_schema is not None:
            pulumi.set(__self__, "hivecatalog_schema", hivecatalog_schema)
        if partition_retention_in_days is None:
            partition_retention_in_days = 365
        if partition_retention_in_days is not None:
            pulumi.set(__self__, "partition_retention_in_days", partition_retention_in_days)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="hivecatalogName")
    def hivecatalog_name(self) -> Optional[pulumi.Input[str]]:
        """
        Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        """
        return pulumi.get(self, "hivecatalog_name")

    @hivecatalog_name.setter
    def hivecatalog_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hivecatalog_name", value)

    @property
    @pulumi.getter(name="hivecatalogSchema")
    def hivecatalog_schema(self) -> Optional[pulumi.Input[str]]:
        """
        Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.
        """
        return pulumi.get(self, "hivecatalog_schema")

    @hivecatalog_schema.setter
    def hivecatalog_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hivecatalog_schema", value)

    @property
    @pulumi.getter(name="partitionRetentionInDays")
    def partition_retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Retention period for query log table partitions, this doesn't have any affect on actual data.
        """
        return pulumi.get(self, "partition_retention_in_days")

    @partition_retention_in_days.setter
    def partition_retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "partition_retention_in_days", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Azure storage location of the blobs.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class TrinoUserPluginsArgsDict(TypedDict):
        """
        Trino user plugins spec
        """
        plugins: NotRequired[pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgsDict']]]]
        """
        Trino user plugins.
        """
elif False:
    TrinoUserPluginsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoUserPluginsArgs:
    def __init__(__self__, *,
                 plugins: Optional[pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgs']]]] = None):
        """
        Trino user plugins spec
        :param pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgs']]] plugins: Trino user plugins.
        """
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgs']]]]:
        """
        Trino user plugins.
        """
        return pulumi.get(self, "plugins")

    @plugins.setter
    def plugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgs']]]]):
        pulumi.set(self, "plugins", value)


if not MYPY:
    class TrinoUserPluginArgsDict(TypedDict):
        """
        Trino user plugin.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Denotes whether the plugin is active or not.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        This field maps to the sub-directory in trino plugins location, that will contain all the plugins under path.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Fully qualified path to the folder containing the plugins.
        """
elif False:
    TrinoUserPluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoUserPluginArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        Trino user plugin.
        :param pulumi.Input[bool] enabled: Denotes whether the plugin is active or not.
        :param pulumi.Input[str] name: This field maps to the sub-directory in trino plugins location, that will contain all the plugins under path.
        :param pulumi.Input[str] path: Fully qualified path to the folder containing the plugins.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Denotes whether the plugin is active or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        This field maps to the sub-directory in trino plugins location, that will contain all the plugins under path.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified path to the folder containing the plugins.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class TrinoUserTelemetryArgsDict(TypedDict):
        """
        User telemetry
        """
        storage: NotRequired[pulumi.Input['TrinoTelemetryConfigArgsDict']]
        """
        Trino user telemetry definition.
        """
elif False:
    TrinoUserTelemetryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoUserTelemetryArgs:
    def __init__(__self__, *,
                 storage: Optional[pulumi.Input['TrinoTelemetryConfigArgs']] = None):
        """
        User telemetry
        :param pulumi.Input['TrinoTelemetryConfigArgs'] storage: Trino user telemetry definition.
        """
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input['TrinoTelemetryConfigArgs']]:
        """
        Trino user telemetry definition.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input['TrinoTelemetryConfigArgs']]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class TrinoWorkerArgsDict(TypedDict):
        """
        Trino worker.
        """
        enable: NotRequired[pulumi.Input[bool]]
        """
        The flag that if enable debug or not.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The debug port.
        """
        suspend: NotRequired[pulumi.Input[bool]]
        """
        The flag that if suspend debug or not.
        """
elif False:
    TrinoWorkerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoWorkerArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 suspend: Optional[pulumi.Input[bool]] = None):
        """
        Trino worker.
        :param pulumi.Input[bool] enable: The flag that if enable debug or not.
        :param pulumi.Input[int] port: The debug port.
        :param pulumi.Input[bool] suspend: The flag that if suspend debug or not.
        """
        if enable is None:
            enable = False
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if port is None:
            port = 8008
        if port is not None:
            pulumi.set(__self__, "port", port)
        if suspend is None:
            suspend = False
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if enable debug or not.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The debug port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if suspend debug or not.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suspend", value)


