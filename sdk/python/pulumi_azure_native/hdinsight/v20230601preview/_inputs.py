# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'AuthorizationProfileArgs',
    'AutoscaleProfileArgs',
    'CatalogOptionsArgs',
    'ClusterConfigFileArgs',
    'ClusterLogAnalyticsApplicationLogsArgs',
    'ClusterLogAnalyticsProfileArgs',
    'ClusterPoolResourcePropertiesClusterPoolProfileArgs',
    'ClusterPoolResourcePropertiesComputeProfileArgs',
    'ClusterPoolResourcePropertiesLogAnalyticsProfileArgs',
    'ClusterPoolResourcePropertiesNetworkProfileArgs',
    'ClusterProfileArgs',
    'ClusterPrometheusProfileArgs',
    'ClusterServiceConfigsProfileArgs',
    'ClusterServiceConfigArgs',
    'ComparisonRuleArgs',
    'ComputeProfileArgs',
    'ComputeResourceDefinitionArgs',
    'FlinkCatalogOptionsArgs',
    'FlinkHiveCatalogOptionArgs',
    'FlinkProfileArgs',
    'FlinkStorageProfileArgs',
    'HiveCatalogOptionArgs',
    'IdentityProfileArgs',
    'LoadBasedConfigArgs',
    'NodeProfileArgs',
    'ScalingRuleArgs',
    'ScheduleBasedConfigArgs',
    'ScheduleArgs',
    'ScriptActionProfileArgs',
    'SecretReferenceArgs',
    'SecretsProfileArgs',
    'SparkMetastoreSpecArgs',
    'SparkProfileArgs',
    'SparkUserPluginsArgs',
    'SparkUserPluginArgs',
    'SshProfileArgs',
    'TrinoCoordinatorArgs',
    'TrinoProfileArgs',
    'TrinoTelemetryConfigArgs',
    'TrinoUserPluginsArgs',
    'TrinoUserPluginArgs',
    'TrinoUserTelemetryArgs',
    'TrinoWorkerArgs',
]

@pulumi.input_type
class AuthorizationProfileArgs:
    def __init__(__self__, *,
                 group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_ids: AAD group Ids authorized for data plane access.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_ids: AAD user Ids authorized for data plane access.
        """
        if group_ids is not None:
            pulumi.set(__self__, "group_ids", group_ids)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        AAD group Ids authorized for data plane access.
        """
        return pulumi.get(self, "group_ids")

    @group_ids.setter
    def group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_ids", value)

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        AAD user Ids authorized for data plane access.
        """
        return pulumi.get(self, "user_ids")

    @user_ids.setter
    def user_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_ids", value)


@pulumi.input_type
class AutoscaleProfileArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 autoscale_type: Optional[pulumi.Input[Union[str, 'AutoscaleType']]] = None,
                 graceful_decommission_timeout: Optional[pulumi.Input[int]] = None,
                 load_based_config: Optional[pulumi.Input['LoadBasedConfigArgs']] = None,
                 schedule_based_config: Optional[pulumi.Input['ScheduleBasedConfigArgs']] = None):
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        :param pulumi.Input[bool] enabled: This indicates whether auto scale is enabled on HDInsight on AKS cluster.
        :param pulumi.Input[Union[str, 'AutoscaleType']] autoscale_type: User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        :param pulumi.Input[int] graceful_decommission_timeout: This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        :param pulumi.Input['LoadBasedConfigArgs'] load_based_config: Profiles of load based Autoscale.
        :param pulumi.Input['ScheduleBasedConfigArgs'] schedule_based_config: Profiles of schedule based Autoscale.
        """
        pulumi.set(__self__, "enabled", enabled)
        if autoscale_type is not None:
            pulumi.set(__self__, "autoscale_type", autoscale_type)
        if graceful_decommission_timeout is not None:
            pulumi.set(__self__, "graceful_decommission_timeout", graceful_decommission_timeout)
        if load_based_config is not None:
            pulumi.set(__self__, "load_based_config", load_based_config)
        if schedule_based_config is not None:
            pulumi.set(__self__, "schedule_based_config", schedule_based_config)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        This indicates whether auto scale is enabled on HDInsight on AKS cluster.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="autoscaleType")
    def autoscale_type(self) -> Optional[pulumi.Input[Union[str, 'AutoscaleType']]]:
        """
        User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        """
        return pulumi.get(self, "autoscale_type")

    @autoscale_type.setter
    def autoscale_type(self, value: Optional[pulumi.Input[Union[str, 'AutoscaleType']]]):
        pulumi.set(self, "autoscale_type", value)

    @property
    @pulumi.getter(name="gracefulDecommissionTimeout")
    def graceful_decommission_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        """
        return pulumi.get(self, "graceful_decommission_timeout")

    @graceful_decommission_timeout.setter
    def graceful_decommission_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "graceful_decommission_timeout", value)

    @property
    @pulumi.getter(name="loadBasedConfig")
    def load_based_config(self) -> Optional[pulumi.Input['LoadBasedConfigArgs']]:
        """
        Profiles of load based Autoscale.
        """
        return pulumi.get(self, "load_based_config")

    @load_based_config.setter
    def load_based_config(self, value: Optional[pulumi.Input['LoadBasedConfigArgs']]):
        pulumi.set(self, "load_based_config", value)

    @property
    @pulumi.getter(name="scheduleBasedConfig")
    def schedule_based_config(self) -> Optional[pulumi.Input['ScheduleBasedConfigArgs']]:
        """
        Profiles of schedule based Autoscale.
        """
        return pulumi.get(self, "schedule_based_config")

    @schedule_based_config.setter
    def schedule_based_config(self, value: Optional[pulumi.Input['ScheduleBasedConfigArgs']]):
        pulumi.set(self, "schedule_based_config", value)


@pulumi.input_type
class CatalogOptionsArgs:
    def __init__(__self__, *,
                 hive: Optional[pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgs']]]] = None):
        """
        Trino cluster catalog options.
        :param pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgs']]] hive: hive catalog options.
        """
        if hive is not None:
            pulumi.set(__self__, "hive", hive)

    @property
    @pulumi.getter
    def hive(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgs']]]]:
        """
        hive catalog options.
        """
        return pulumi.get(self, "hive")

    @hive.setter
    def hive(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgs']]]]):
        pulumi.set(self, "hive", value)


@pulumi.input_type
class ClusterConfigFileArgs:
    def __init__(__self__, *,
                 file_name: pulumi.Input[str],
                 content: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[Union[str, 'ContentEncoding']]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Cluster configuration files.
        :param pulumi.Input[str] file_name: Configuration file name.
        :param pulumi.Input[str] content: Free form content of the entire configuration file.
        :param pulumi.Input[Union[str, 'ContentEncoding']] encoding: This property indicates if the content is encoded and is case-insensitive. Please set the value to base64 if the content is base64 encoded. Set it to none or skip it if the content is plain text.
        :param pulumi.Input[str] path: Path of the config file if content is specified.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] values: List of key value pairs
               where key represents a valid service configuration name and value represents the value of the config.
        """
        pulumi.set(__self__, "file_name", file_name)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> pulumi.Input[str]:
        """
        Configuration file name.
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Free form content of the entire configuration file.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[Union[str, 'ContentEncoding']]]:
        """
        This property indicates if the content is encoded and is case-insensitive. Please set the value to base64 if the content is base64 encoded. Set it to none or skip it if the content is plain text.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[Union[str, 'ContentEncoding']]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path of the config file if content is specified.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        List of key value pairs
        where key represents a valid service configuration name and value represents the value of the config.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class ClusterLogAnalyticsApplicationLogsArgs:
    def __init__(__self__, *,
                 std_error_enabled: Optional[pulumi.Input[bool]] = None,
                 std_out_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Collection of logs to be enabled or disabled for log analytics.
        :param pulumi.Input[bool] std_error_enabled: True if stderror is enabled, otherwise false.
        :param pulumi.Input[bool] std_out_enabled: True if stdout is enabled, otherwise false.
        """
        if std_error_enabled is not None:
            pulumi.set(__self__, "std_error_enabled", std_error_enabled)
        if std_out_enabled is not None:
            pulumi.set(__self__, "std_out_enabled", std_out_enabled)

    @property
    @pulumi.getter(name="stdErrorEnabled")
    def std_error_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if stderror is enabled, otherwise false.
        """
        return pulumi.get(self, "std_error_enabled")

    @std_error_enabled.setter
    def std_error_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "std_error_enabled", value)

    @property
    @pulumi.getter(name="stdOutEnabled")
    def std_out_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if stdout is enabled, otherwise false.
        """
        return pulumi.get(self, "std_out_enabled")

    @std_out_enabled.setter
    def std_out_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "std_out_enabled", value)


@pulumi.input_type
class ClusterLogAnalyticsProfileArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 application_logs: Optional[pulumi.Input['ClusterLogAnalyticsApplicationLogsArgs']] = None,
                 metrics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        :param pulumi.Input[bool] enabled: True if log analytics is enabled for the cluster, otherwise false.
        :param pulumi.Input['ClusterLogAnalyticsApplicationLogsArgs'] application_logs: Collection of logs to be enabled or disabled for log analytics.
        :param pulumi.Input[bool] metrics_enabled: True if metrics are enabled, otherwise false.
        """
        pulumi.set(__self__, "enabled", enabled)
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if metrics_enabled is not None:
            pulumi.set(__self__, "metrics_enabled", metrics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        True if log analytics is enabled for the cluster, otherwise false.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional[pulumi.Input['ClusterLogAnalyticsApplicationLogsArgs']]:
        """
        Collection of logs to be enabled or disabled for log analytics.
        """
        return pulumi.get(self, "application_logs")

    @application_logs.setter
    def application_logs(self, value: Optional[pulumi.Input['ClusterLogAnalyticsApplicationLogsArgs']]):
        pulumi.set(self, "application_logs", value)

    @property
    @pulumi.getter(name="metricsEnabled")
    def metrics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if metrics are enabled, otherwise false.
        """
        return pulumi.get(self, "metrics_enabled")

    @metrics_enabled.setter
    def metrics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "metrics_enabled", value)


@pulumi.input_type
class ClusterPoolResourcePropertiesClusterPoolProfileArgs:
    def __init__(__self__, *,
                 cluster_pool_version: pulumi.Input[str]):
        """
        CLuster pool profile.
        :param pulumi.Input[str] cluster_pool_version: Cluster pool version is a 2-part version.
        """
        pulumi.set(__self__, "cluster_pool_version", cluster_pool_version)

    @property
    @pulumi.getter(name="clusterPoolVersion")
    def cluster_pool_version(self) -> pulumi.Input[str]:
        """
        Cluster pool version is a 2-part version.
        """
        return pulumi.get(self, "cluster_pool_version")

    @cluster_pool_version.setter
    def cluster_pool_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_pool_version", value)


@pulumi.input_type
class ClusterPoolResourcePropertiesComputeProfileArgs:
    def __init__(__self__, *,
                 vm_size: pulumi.Input[str]):
        """
        CLuster pool compute profile.
        :param pulumi.Input[str] vm_size: The virtual machine SKU.
        """
        pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> pulumi.Input[str]:
        """
        The virtual machine SKU.
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_size", value)


@pulumi.input_type
class ClusterPoolResourcePropertiesLogAnalyticsProfileArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 workspace_id: Optional[pulumi.Input[str]] = None):
        """
        Cluster pool log analytics profile to enable OMS agent for AKS cluster.
        :param pulumi.Input[bool] enabled: True if log analytics is enabled for cluster pool, otherwise false.
        :param pulumi.Input[str] workspace_id: Log analytics workspace to associate with the OMS agent.
        """
        pulumi.set(__self__, "enabled", enabled)
        if workspace_id is not None:
            pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        True if log analytics is enabled for cluster pool, otherwise false.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> Optional[pulumi.Input[str]]:
        """
        Log analytics workspace to associate with the OMS agent.
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workspace_id", value)


@pulumi.input_type
class ClusterPoolResourcePropertiesNetworkProfileArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str]):
        """
        Cluster pool network profile.
        :param pulumi.Input[str] subnet_id: Cluster pool subnet resource id.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        Cluster pool subnet resource id.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class ClusterProfileArgs:
    def __init__(__self__, *,
                 authorization_profile: pulumi.Input['AuthorizationProfileArgs'],
                 cluster_version: pulumi.Input[str],
                 identity_profile: pulumi.Input['IdentityProfileArgs'],
                 oss_version: pulumi.Input[str],
                 autoscale_profile: Optional[pulumi.Input['AutoscaleProfileArgs']] = None,
                 flink_profile: Optional[pulumi.Input['FlinkProfileArgs']] = None,
                 kafka_profile: Optional[Any] = None,
                 llap_profile: Optional[Any] = None,
                 log_analytics_profile: Optional[pulumi.Input['ClusterLogAnalyticsProfileArgs']] = None,
                 prometheus_profile: Optional[pulumi.Input['ClusterPrometheusProfileArgs']] = None,
                 script_action_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgs']]]] = None,
                 secrets_profile: Optional[pulumi.Input['SecretsProfileArgs']] = None,
                 service_configs_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgs']]]] = None,
                 spark_profile: Optional[pulumi.Input['SparkProfileArgs']] = None,
                 ssh_profile: Optional[pulumi.Input['SshProfileArgs']] = None,
                 stub_profile: Optional[Any] = None,
                 trino_profile: Optional[pulumi.Input['TrinoProfileArgs']] = None):
        """
        Cluster profile.
        :param pulumi.Input['AuthorizationProfileArgs'] authorization_profile: Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        :param pulumi.Input[str] cluster_version: Version with 3/4 part.
        :param pulumi.Input['IdentityProfileArgs'] identity_profile: Identity Profile with details of an MSI.
        :param pulumi.Input[str] oss_version: Version with three part.
        :param pulumi.Input['AutoscaleProfileArgs'] autoscale_profile: This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        :param pulumi.Input['FlinkProfileArgs'] flink_profile: The Flink cluster profile.
        :param Any kafka_profile: Kafka cluster profile.
        :param Any llap_profile: LLAP cluster profile.
        :param pulumi.Input['ClusterLogAnalyticsProfileArgs'] log_analytics_profile: Cluster log analytics profile to enable or disable OMS agent for cluster.
        :param pulumi.Input['ClusterPrometheusProfileArgs'] prometheus_profile: Cluster Prometheus profile.
        :param pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgs']]] script_action_profiles: The script action profile list.
        :param pulumi.Input['SecretsProfileArgs'] secrets_profile: The cluster secret profile.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgs']]] service_configs_profiles: The service configs profiles.
        :param pulumi.Input['SparkProfileArgs'] spark_profile: The spark cluster profile.
        :param pulumi.Input['SshProfileArgs'] ssh_profile: Ssh profile for the cluster.
        :param Any stub_profile: Stub cluster profile.
        :param pulumi.Input['TrinoProfileArgs'] trino_profile: Trino Cluster profile.
        """
        pulumi.set(__self__, "authorization_profile", authorization_profile)
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "identity_profile", identity_profile)
        pulumi.set(__self__, "oss_version", oss_version)
        if autoscale_profile is not None:
            pulumi.set(__self__, "autoscale_profile", autoscale_profile)
        if flink_profile is not None:
            pulumi.set(__self__, "flink_profile", flink_profile)
        if kafka_profile is not None:
            pulumi.set(__self__, "kafka_profile", kafka_profile)
        if llap_profile is not None:
            pulumi.set(__self__, "llap_profile", llap_profile)
        if log_analytics_profile is not None:
            pulumi.set(__self__, "log_analytics_profile", log_analytics_profile)
        if prometheus_profile is not None:
            pulumi.set(__self__, "prometheus_profile", prometheus_profile)
        if script_action_profiles is not None:
            pulumi.set(__self__, "script_action_profiles", script_action_profiles)
        if secrets_profile is not None:
            pulumi.set(__self__, "secrets_profile", secrets_profile)
        if service_configs_profiles is not None:
            pulumi.set(__self__, "service_configs_profiles", service_configs_profiles)
        if spark_profile is not None:
            pulumi.set(__self__, "spark_profile", spark_profile)
        if ssh_profile is not None:
            pulumi.set(__self__, "ssh_profile", ssh_profile)
        if stub_profile is not None:
            pulumi.set(__self__, "stub_profile", stub_profile)
        if trino_profile is not None:
            pulumi.set(__self__, "trino_profile", trino_profile)

    @property
    @pulumi.getter(name="authorizationProfile")
    def authorization_profile(self) -> pulumi.Input['AuthorizationProfileArgs']:
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        """
        return pulumi.get(self, "authorization_profile")

    @authorization_profile.setter
    def authorization_profile(self, value: pulumi.Input['AuthorizationProfileArgs']):
        pulumi.set(self, "authorization_profile", value)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> pulumi.Input[str]:
        """
        Version with 3/4 part.
        """
        return pulumi.get(self, "cluster_version")

    @cluster_version.setter
    def cluster_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_version", value)

    @property
    @pulumi.getter(name="identityProfile")
    def identity_profile(self) -> pulumi.Input['IdentityProfileArgs']:
        """
        Identity Profile with details of an MSI.
        """
        return pulumi.get(self, "identity_profile")

    @identity_profile.setter
    def identity_profile(self, value: pulumi.Input['IdentityProfileArgs']):
        pulumi.set(self, "identity_profile", value)

    @property
    @pulumi.getter(name="ossVersion")
    def oss_version(self) -> pulumi.Input[str]:
        """
        Version with three part.
        """
        return pulumi.get(self, "oss_version")

    @oss_version.setter
    def oss_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "oss_version", value)

    @property
    @pulumi.getter(name="autoscaleProfile")
    def autoscale_profile(self) -> Optional[pulumi.Input['AutoscaleProfileArgs']]:
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        """
        return pulumi.get(self, "autoscale_profile")

    @autoscale_profile.setter
    def autoscale_profile(self, value: Optional[pulumi.Input['AutoscaleProfileArgs']]):
        pulumi.set(self, "autoscale_profile", value)

    @property
    @pulumi.getter(name="flinkProfile")
    def flink_profile(self) -> Optional[pulumi.Input['FlinkProfileArgs']]:
        """
        The Flink cluster profile.
        """
        return pulumi.get(self, "flink_profile")

    @flink_profile.setter
    def flink_profile(self, value: Optional[pulumi.Input['FlinkProfileArgs']]):
        pulumi.set(self, "flink_profile", value)

    @property
    @pulumi.getter(name="kafkaProfile")
    def kafka_profile(self) -> Optional[Any]:
        """
        Kafka cluster profile.
        """
        return pulumi.get(self, "kafka_profile")

    @kafka_profile.setter
    def kafka_profile(self, value: Optional[Any]):
        pulumi.set(self, "kafka_profile", value)

    @property
    @pulumi.getter(name="llapProfile")
    def llap_profile(self) -> Optional[Any]:
        """
        LLAP cluster profile.
        """
        return pulumi.get(self, "llap_profile")

    @llap_profile.setter
    def llap_profile(self, value: Optional[Any]):
        pulumi.set(self, "llap_profile", value)

    @property
    @pulumi.getter(name="logAnalyticsProfile")
    def log_analytics_profile(self) -> Optional[pulumi.Input['ClusterLogAnalyticsProfileArgs']]:
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        """
        return pulumi.get(self, "log_analytics_profile")

    @log_analytics_profile.setter
    def log_analytics_profile(self, value: Optional[pulumi.Input['ClusterLogAnalyticsProfileArgs']]):
        pulumi.set(self, "log_analytics_profile", value)

    @property
    @pulumi.getter(name="prometheusProfile")
    def prometheus_profile(self) -> Optional[pulumi.Input['ClusterPrometheusProfileArgs']]:
        """
        Cluster Prometheus profile.
        """
        return pulumi.get(self, "prometheus_profile")

    @prometheus_profile.setter
    def prometheus_profile(self, value: Optional[pulumi.Input['ClusterPrometheusProfileArgs']]):
        pulumi.set(self, "prometheus_profile", value)

    @property
    @pulumi.getter(name="scriptActionProfiles")
    def script_action_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgs']]]]:
        """
        The script action profile list.
        """
        return pulumi.get(self, "script_action_profiles")

    @script_action_profiles.setter
    def script_action_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgs']]]]):
        pulumi.set(self, "script_action_profiles", value)

    @property
    @pulumi.getter(name="secretsProfile")
    def secrets_profile(self) -> Optional[pulumi.Input['SecretsProfileArgs']]:
        """
        The cluster secret profile.
        """
        return pulumi.get(self, "secrets_profile")

    @secrets_profile.setter
    def secrets_profile(self, value: Optional[pulumi.Input['SecretsProfileArgs']]):
        pulumi.set(self, "secrets_profile", value)

    @property
    @pulumi.getter(name="serviceConfigsProfiles")
    def service_configs_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgs']]]]:
        """
        The service configs profiles.
        """
        return pulumi.get(self, "service_configs_profiles")

    @service_configs_profiles.setter
    def service_configs_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgs']]]]):
        pulumi.set(self, "service_configs_profiles", value)

    @property
    @pulumi.getter(name="sparkProfile")
    def spark_profile(self) -> Optional[pulumi.Input['SparkProfileArgs']]:
        """
        The spark cluster profile.
        """
        return pulumi.get(self, "spark_profile")

    @spark_profile.setter
    def spark_profile(self, value: Optional[pulumi.Input['SparkProfileArgs']]):
        pulumi.set(self, "spark_profile", value)

    @property
    @pulumi.getter(name="sshProfile")
    def ssh_profile(self) -> Optional[pulumi.Input['SshProfileArgs']]:
        """
        Ssh profile for the cluster.
        """
        return pulumi.get(self, "ssh_profile")

    @ssh_profile.setter
    def ssh_profile(self, value: Optional[pulumi.Input['SshProfileArgs']]):
        pulumi.set(self, "ssh_profile", value)

    @property
    @pulumi.getter(name="stubProfile")
    def stub_profile(self) -> Optional[Any]:
        """
        Stub cluster profile.
        """
        return pulumi.get(self, "stub_profile")

    @stub_profile.setter
    def stub_profile(self, value: Optional[Any]):
        pulumi.set(self, "stub_profile", value)

    @property
    @pulumi.getter(name="trinoProfile")
    def trino_profile(self) -> Optional[pulumi.Input['TrinoProfileArgs']]:
        """
        Trino Cluster profile.
        """
        return pulumi.get(self, "trino_profile")

    @trino_profile.setter
    def trino_profile(self, value: Optional[pulumi.Input['TrinoProfileArgs']]):
        pulumi.set(self, "trino_profile", value)


@pulumi.input_type
class ClusterPrometheusProfileArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Cluster Prometheus profile.
        :param pulumi.Input[bool] enabled: Enable Prometheus for cluster or not.
        """
        if enabled is None:
            enabled = False
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Enable Prometheus for cluster or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ClusterServiceConfigsProfileArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgs']]],
                 service_name: pulumi.Input[str]):
        """
        Cluster service configs.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgs']]] configs: List of service configs.
        :param pulumi.Input[str] service_name: Name of the service the configurations should apply to.
        """
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgs']]]:
        """
        List of service configs.
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgs']]]):
        pulumi.set(self, "configs", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        """
        Name of the service the configurations should apply to.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)


@pulumi.input_type
class ClusterServiceConfigArgs:
    def __init__(__self__, *,
                 component: pulumi.Input[str],
                 files: pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgs']]]):
        """
        Cluster configs per component.
        :param pulumi.Input[str] component: Name of the component the config files should apply to.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgs']]] files: List of Config Files.
        """
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def component(self) -> pulumi.Input[str]:
        """
        Name of the component the config files should apply to.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: pulumi.Input[str]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def files(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgs']]]:
        """
        List of Config Files.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgs']]]):
        pulumi.set(self, "files", value)


@pulumi.input_type
class ComparisonRuleArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'ComparisonOperator']],
                 threshold: pulumi.Input[float]):
        """
        The comparison rule.
        :param pulumi.Input[Union[str, 'ComparisonOperator']] operator: The comparison operator.
        :param pulumi.Input[float] threshold: Threshold setting.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'ComparisonOperator']]:
        """
        The comparison operator.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'ComparisonOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        Threshold setting.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)


@pulumi.input_type
class ComputeProfileArgs:
    def __init__(__self__, *,
                 nodes: pulumi.Input[Sequence[pulumi.Input['NodeProfileArgs']]]):
        """
        The compute profile.
        :param pulumi.Input[Sequence[pulumi.Input['NodeProfileArgs']]] nodes: The nodes definitions.
        """
        pulumi.set(__self__, "nodes", nodes)

    @property
    @pulumi.getter
    def nodes(self) -> pulumi.Input[Sequence[pulumi.Input['NodeProfileArgs']]]:
        """
        The nodes definitions.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: pulumi.Input[Sequence[pulumi.Input['NodeProfileArgs']]]):
        pulumi.set(self, "nodes", value)


@pulumi.input_type
class ComputeResourceDefinitionArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[float],
                 memory: pulumi.Input[float]):
        """
        The cpu and memory requirement definition.
        :param pulumi.Input[float] cpu: The required CPU.
        :param pulumi.Input[float] memory: The required memory in MB, Container memory will be 110 percentile
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[float]:
        """
        The required CPU.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[float]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[float]:
        """
        The required memory in MB, Container memory will be 110 percentile
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[float]):
        pulumi.set(self, "memory", value)


@pulumi.input_type
class FlinkCatalogOptionsArgs:
    def __init__(__self__, *,
                 hive: Optional[pulumi.Input['FlinkHiveCatalogOptionArgs']] = None):
        """
        Flink cluster catalog options.
        :param pulumi.Input['FlinkHiveCatalogOptionArgs'] hive: Hive Catalog Option for Flink cluster.
        """
        if hive is not None:
            pulumi.set(__self__, "hive", hive)

    @property
    @pulumi.getter
    def hive(self) -> Optional[pulumi.Input['FlinkHiveCatalogOptionArgs']]:
        """
        Hive Catalog Option for Flink cluster.
        """
        return pulumi.get(self, "hive")

    @hive.setter
    def hive(self, value: Optional[pulumi.Input['FlinkHiveCatalogOptionArgs']]):
        pulumi.set(self, "hive", value)


@pulumi.input_type
class FlinkHiveCatalogOptionArgs:
    def __init__(__self__, *,
                 metastore_db_connection_password_secret: pulumi.Input[str],
                 metastore_db_connection_url: pulumi.Input[str],
                 metastore_db_connection_user_name: pulumi.Input[str]):
        """
        Hive Catalog Option for Flink cluster.
        :param pulumi.Input[str] metastore_db_connection_password_secret: Secret reference name from secretsProfile.secrets containing password for database connection.
        :param pulumi.Input[str] metastore_db_connection_url: Connection string for hive metastore database.
        :param pulumi.Input[str] metastore_db_connection_user_name: User name for database connection.
        """
        pulumi.set(__self__, "metastore_db_connection_password_secret", metastore_db_connection_password_secret)
        pulumi.set(__self__, "metastore_db_connection_url", metastore_db_connection_url)
        pulumi.set(__self__, "metastore_db_connection_user_name", metastore_db_connection_user_name)

    @property
    @pulumi.getter(name="metastoreDbConnectionPasswordSecret")
    def metastore_db_connection_password_secret(self) -> pulumi.Input[str]:
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_password_secret")

    @metastore_db_connection_password_secret.setter
    def metastore_db_connection_password_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_password_secret", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionURL")
    def metastore_db_connection_url(self) -> pulumi.Input[str]:
        """
        Connection string for hive metastore database.
        """
        return pulumi.get(self, "metastore_db_connection_url")

    @metastore_db_connection_url.setter
    def metastore_db_connection_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_url", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionUserName")
    def metastore_db_connection_user_name(self) -> pulumi.Input[str]:
        """
        User name for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_user_name")

    @metastore_db_connection_user_name.setter
    def metastore_db_connection_user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_user_name", value)


@pulumi.input_type
class FlinkProfileArgs:
    def __init__(__self__, *,
                 job_manager: pulumi.Input['ComputeResourceDefinitionArgs'],
                 storage: pulumi.Input['FlinkStorageProfileArgs'],
                 task_manager: pulumi.Input['ComputeResourceDefinitionArgs'],
                 catalog_options: Optional[pulumi.Input['FlinkCatalogOptionsArgs']] = None,
                 history_server: Optional[pulumi.Input['ComputeResourceDefinitionArgs']] = None,
                 num_replicas: Optional[pulumi.Input[int]] = None):
        """
        The Flink cluster profile.
        :param pulumi.Input['ComputeResourceDefinitionArgs'] job_manager: Job Manager container/ process CPU and memory requirements
        :param pulumi.Input['FlinkStorageProfileArgs'] storage: The storage profile
        :param pulumi.Input['ComputeResourceDefinitionArgs'] task_manager: Task Manager container/ process CPU and memory requirements
        :param pulumi.Input['FlinkCatalogOptionsArgs'] catalog_options: Flink cluster catalog options.
        :param pulumi.Input['ComputeResourceDefinitionArgs'] history_server: History Server container/ process CPU and memory requirements
        :param pulumi.Input[int] num_replicas: The number of task managers.
        """
        pulumi.set(__self__, "job_manager", job_manager)
        pulumi.set(__self__, "storage", storage)
        pulumi.set(__self__, "task_manager", task_manager)
        if catalog_options is not None:
            pulumi.set(__self__, "catalog_options", catalog_options)
        if history_server is not None:
            pulumi.set(__self__, "history_server", history_server)
        if num_replicas is not None:
            pulumi.set(__self__, "num_replicas", num_replicas)

    @property
    @pulumi.getter(name="jobManager")
    def job_manager(self) -> pulumi.Input['ComputeResourceDefinitionArgs']:
        """
        Job Manager container/ process CPU and memory requirements
        """
        return pulumi.get(self, "job_manager")

    @job_manager.setter
    def job_manager(self, value: pulumi.Input['ComputeResourceDefinitionArgs']):
        pulumi.set(self, "job_manager", value)

    @property
    @pulumi.getter
    def storage(self) -> pulumi.Input['FlinkStorageProfileArgs']:
        """
        The storage profile
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: pulumi.Input['FlinkStorageProfileArgs']):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter(name="taskManager")
    def task_manager(self) -> pulumi.Input['ComputeResourceDefinitionArgs']:
        """
        Task Manager container/ process CPU and memory requirements
        """
        return pulumi.get(self, "task_manager")

    @task_manager.setter
    def task_manager(self, value: pulumi.Input['ComputeResourceDefinitionArgs']):
        pulumi.set(self, "task_manager", value)

    @property
    @pulumi.getter(name="catalogOptions")
    def catalog_options(self) -> Optional[pulumi.Input['FlinkCatalogOptionsArgs']]:
        """
        Flink cluster catalog options.
        """
        return pulumi.get(self, "catalog_options")

    @catalog_options.setter
    def catalog_options(self, value: Optional[pulumi.Input['FlinkCatalogOptionsArgs']]):
        pulumi.set(self, "catalog_options", value)

    @property
    @pulumi.getter(name="historyServer")
    def history_server(self) -> Optional[pulumi.Input['ComputeResourceDefinitionArgs']]:
        """
        History Server container/ process CPU and memory requirements
        """
        return pulumi.get(self, "history_server")

    @history_server.setter
    def history_server(self, value: Optional[pulumi.Input['ComputeResourceDefinitionArgs']]):
        pulumi.set(self, "history_server", value)

    @property
    @pulumi.getter(name="numReplicas")
    def num_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of task managers.
        """
        return pulumi.get(self, "num_replicas")

    @num_replicas.setter
    def num_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_replicas", value)


@pulumi.input_type
class FlinkStorageProfileArgs:
    def __init__(__self__, *,
                 storage_uri: pulumi.Input[str],
                 storagekey: Optional[pulumi.Input[str]] = None):
        """
        The storage profile
        :param pulumi.Input[str] storage_uri: Storage account uri which is used for savepoint and checkpoint state.
        :param pulumi.Input[str] storagekey: Storage key is only required for wasb(s) storage.
        """
        pulumi.set(__self__, "storage_uri", storage_uri)
        if storagekey is not None:
            pulumi.set(__self__, "storagekey", storagekey)

    @property
    @pulumi.getter(name="storageUri")
    def storage_uri(self) -> pulumi.Input[str]:
        """
        Storage account uri which is used for savepoint and checkpoint state.
        """
        return pulumi.get(self, "storage_uri")

    @storage_uri.setter
    def storage_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_uri", value)

    @property
    @pulumi.getter
    def storagekey(self) -> Optional[pulumi.Input[str]]:
        """
        Storage key is only required for wasb(s) storage.
        """
        return pulumi.get(self, "storagekey")

    @storagekey.setter
    def storagekey(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storagekey", value)


@pulumi.input_type
class HiveCatalogOptionArgs:
    def __init__(__self__, *,
                 catalog_name: pulumi.Input[str],
                 metastore_db_connection_password_secret: pulumi.Input[str],
                 metastore_db_connection_url: pulumi.Input[str],
                 metastore_db_connection_user_name: pulumi.Input[str],
                 metastore_warehouse_dir: pulumi.Input[str]):
        """
        Hive Catalog Option
        :param pulumi.Input[str] catalog_name: Name of trino catalog which should use specified hive metastore.
        :param pulumi.Input[str] metastore_db_connection_password_secret: Secret reference name from secretsProfile.secrets containing password for database connection.
        :param pulumi.Input[str] metastore_db_connection_url: Connection string for hive metastore database.
        :param pulumi.Input[str] metastore_db_connection_user_name: User name for database connection.
        :param pulumi.Input[str] metastore_warehouse_dir: Metastore root directory URI, format: abfs[s]://<container>@<account_name>.dfs.core.windows.net/<path>. More details: https://docs.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-introduction-abfs-uri
        """
        pulumi.set(__self__, "catalog_name", catalog_name)
        pulumi.set(__self__, "metastore_db_connection_password_secret", metastore_db_connection_password_secret)
        pulumi.set(__self__, "metastore_db_connection_url", metastore_db_connection_url)
        pulumi.set(__self__, "metastore_db_connection_user_name", metastore_db_connection_user_name)
        pulumi.set(__self__, "metastore_warehouse_dir", metastore_warehouse_dir)

    @property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> pulumi.Input[str]:
        """
        Name of trino catalog which should use specified hive metastore.
        """
        return pulumi.get(self, "catalog_name")

    @catalog_name.setter
    def catalog_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "catalog_name", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionPasswordSecret")
    def metastore_db_connection_password_secret(self) -> pulumi.Input[str]:
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_password_secret")

    @metastore_db_connection_password_secret.setter
    def metastore_db_connection_password_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_password_secret", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionURL")
    def metastore_db_connection_url(self) -> pulumi.Input[str]:
        """
        Connection string for hive metastore database.
        """
        return pulumi.get(self, "metastore_db_connection_url")

    @metastore_db_connection_url.setter
    def metastore_db_connection_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_url", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionUserName")
    def metastore_db_connection_user_name(self) -> pulumi.Input[str]:
        """
        User name for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_user_name")

    @metastore_db_connection_user_name.setter
    def metastore_db_connection_user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_user_name", value)

    @property
    @pulumi.getter(name="metastoreWarehouseDir")
    def metastore_warehouse_dir(self) -> pulumi.Input[str]:
        """
        Metastore root directory URI, format: abfs[s]://<container>@<account_name>.dfs.core.windows.net/<path>. More details: https://docs.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-introduction-abfs-uri
        """
        return pulumi.get(self, "metastore_warehouse_dir")

    @metastore_warehouse_dir.setter
    def metastore_warehouse_dir(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_warehouse_dir", value)


@pulumi.input_type
class IdentityProfileArgs:
    def __init__(__self__, *,
                 msi_client_id: pulumi.Input[str],
                 msi_object_id: pulumi.Input[str],
                 msi_resource_id: pulumi.Input[str]):
        """
        Identity Profile with details of an MSI.
        :param pulumi.Input[str] msi_client_id: ClientId of the MSI.
        :param pulumi.Input[str] msi_object_id: ObjectId of the MSI.
        :param pulumi.Input[str] msi_resource_id: ResourceId of the MSI.
        """
        pulumi.set(__self__, "msi_client_id", msi_client_id)
        pulumi.set(__self__, "msi_object_id", msi_object_id)
        pulumi.set(__self__, "msi_resource_id", msi_resource_id)

    @property
    @pulumi.getter(name="msiClientId")
    def msi_client_id(self) -> pulumi.Input[str]:
        """
        ClientId of the MSI.
        """
        return pulumi.get(self, "msi_client_id")

    @msi_client_id.setter
    def msi_client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "msi_client_id", value)

    @property
    @pulumi.getter(name="msiObjectId")
    def msi_object_id(self) -> pulumi.Input[str]:
        """
        ObjectId of the MSI.
        """
        return pulumi.get(self, "msi_object_id")

    @msi_object_id.setter
    def msi_object_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "msi_object_id", value)

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> pulumi.Input[str]:
        """
        ResourceId of the MSI.
        """
        return pulumi.get(self, "msi_resource_id")

    @msi_resource_id.setter
    def msi_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "msi_resource_id", value)


@pulumi.input_type
class LoadBasedConfigArgs:
    def __init__(__self__, *,
                 max_nodes: pulumi.Input[int],
                 min_nodes: pulumi.Input[int],
                 scaling_rules: pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgs']]],
                 cooldown_period: Optional[pulumi.Input[int]] = None,
                 poll_interval: Optional[pulumi.Input[int]] = None):
        """
        Profile of load based Autoscale.
        :param pulumi.Input[int] max_nodes: User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        :param pulumi.Input[int] min_nodes: User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        :param pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgs']]] scaling_rules: The scaling rules.
        :param pulumi.Input[int] cooldown_period: This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.
        :param pulumi.Input[int] poll_interval: User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.
        """
        pulumi.set(__self__, "max_nodes", max_nodes)
        pulumi.set(__self__, "min_nodes", min_nodes)
        pulumi.set(__self__, "scaling_rules", scaling_rules)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if poll_interval is not None:
            pulumi.set(__self__, "poll_interval", poll_interval)

    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> pulumi.Input[int]:
        """
        User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        return pulumi.get(self, "max_nodes")

    @max_nodes.setter
    def max_nodes(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_nodes", value)

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> pulumi.Input[int]:
        """
        User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        return pulumi.get(self, "min_nodes")

    @min_nodes.setter
    def min_nodes(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_nodes", value)

    @property
    @pulumi.getter(name="scalingRules")
    def scaling_rules(self) -> pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgs']]]:
        """
        The scaling rules.
        """
        return pulumi.get(self, "scaling_rules")

    @scaling_rules.setter
    def scaling_rules(self, value: pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgs']]]):
        pulumi.set(self, "scaling_rules", value)

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[pulumi.Input[int]]:
        """
        This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.
        """
        return pulumi.get(self, "cooldown_period")

    @cooldown_period.setter
    def cooldown_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown_period", value)

    @property
    @pulumi.getter(name="pollInterval")
    def poll_interval(self) -> Optional[pulumi.Input[int]]:
        """
        User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.
        """
        return pulumi.get(self, "poll_interval")

    @poll_interval.setter
    def poll_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "poll_interval", value)


@pulumi.input_type
class NodeProfileArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 type: pulumi.Input[str],
                 vm_size: pulumi.Input[str]):
        """
        The node profile.
        :param pulumi.Input[int] count: The number of virtual machines.
        :param pulumi.Input[str] type: The node type.
        :param pulumi.Input[str] vm_size: The virtual machine SKU.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of virtual machines.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The node type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> pulumi.Input[str]:
        """
        The virtual machine SKU.
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_size", value)


@pulumi.input_type
class ScalingRuleArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[Union[str, 'ScaleActionType']],
                 comparison_rule: pulumi.Input['ComparisonRuleArgs'],
                 evaluation_count: pulumi.Input[int],
                 scaling_metric: pulumi.Input[str]):
        """
        The scaling rule.
        :param pulumi.Input[Union[str, 'ScaleActionType']] action_type: The action type.
        :param pulumi.Input['ComparisonRuleArgs'] comparison_rule: The comparison rule.
        :param pulumi.Input[int] evaluation_count: This is an evaluation count for a scaling condition, the number of times a trigger condition should be successful, before scaling activity is triggered.
        :param pulumi.Input[str] scaling_metric: Metrics name for individual workloads. For example: cpu
        """
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "comparison_rule", comparison_rule)
        pulumi.set(__self__, "evaluation_count", evaluation_count)
        pulumi.set(__self__, "scaling_metric", scaling_metric)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[Union[str, 'ScaleActionType']]:
        """
        The action type.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[Union[str, 'ScaleActionType']]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="comparisonRule")
    def comparison_rule(self) -> pulumi.Input['ComparisonRuleArgs']:
        """
        The comparison rule.
        """
        return pulumi.get(self, "comparison_rule")

    @comparison_rule.setter
    def comparison_rule(self, value: pulumi.Input['ComparisonRuleArgs']):
        pulumi.set(self, "comparison_rule", value)

    @property
    @pulumi.getter(name="evaluationCount")
    def evaluation_count(self) -> pulumi.Input[int]:
        """
        This is an evaluation count for a scaling condition, the number of times a trigger condition should be successful, before scaling activity is triggered.
        """
        return pulumi.get(self, "evaluation_count")

    @evaluation_count.setter
    def evaluation_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "evaluation_count", value)

    @property
    @pulumi.getter(name="scalingMetric")
    def scaling_metric(self) -> pulumi.Input[str]:
        """
        Metrics name for individual workloads. For example: cpu
        """
        return pulumi.get(self, "scaling_metric")

    @scaling_metric.setter
    def scaling_metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "scaling_metric", value)


@pulumi.input_type
class ScheduleBasedConfigArgs:
    def __init__(__self__, *,
                 default_count: pulumi.Input[int],
                 schedules: pulumi.Input[Sequence[pulumi.Input['ScheduleArgs']]],
                 time_zone: pulumi.Input[str]):
        """
        Profile of schedule based Autoscale.
        :param pulumi.Input[int] default_count: Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleArgs']]] schedules: This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).
        :param pulumi.Input[str] time_zone: User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        """
        pulumi.set(__self__, "default_count", default_count)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="defaultCount")
    def default_count(self) -> pulumi.Input[int]:
        """
        Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)
        """
        return pulumi.get(self, "default_count")

    @default_count.setter
    def default_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "default_count", value)

    @property
    @pulumi.getter
    def schedules(self) -> pulumi.Input[Sequence[pulumi.Input['ScheduleArgs']]]:
        """
        This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).
        """
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: pulumi.Input[Sequence[pulumi.Input['ScheduleArgs']]]):
        pulumi.set(self, "schedules", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[str]:
        """
        User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class ScheduleArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 days: pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]],
                 end_time: pulumi.Input[str],
                 start_time: pulumi.Input[str]):
        """
        Schedule definition.
        :param pulumi.Input[int] count: User has to set the node count anticipated at end of the scaling operation of the set current schedule configuration, format is integer.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]] days: User has to set the days where schedule has to be set for autoscale operation.
        :param pulumi.Input[str] end_time: User has to set the end time of current schedule configuration, format like 10:30 (HH:MM).
        :param pulumi.Input[str] start_time: User has to set the start time of current schedule configuration, format like 10:30 (HH:MM).
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        User has to set the node count anticipated at end of the scaling operation of the set current schedule configuration, format is integer.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def days(self) -> pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]]:
        """
        User has to set the days where schedule has to be set for autoscale operation.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[str]:
        """
        User has to set the end time of current schedule configuration, format like 10:30 (HH:MM).
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        User has to set the start time of current schedule configuration, format like 10:30 (HH:MM).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)


@pulumi.input_type
class ScriptActionProfileArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 services: pulumi.Input[Sequence[pulumi.Input[str]]],
                 type: pulumi.Input[str],
                 url: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[str]] = None,
                 should_persist: Optional[pulumi.Input[bool]] = None,
                 timeout_in_minutes: Optional[pulumi.Input[int]] = None):
        """
        The script action profile.
        :param pulumi.Input[str] name: Script name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of services to apply the script action.
        :param pulumi.Input[str] type: Type of the script action. Supported type is bash scripts.
        :param pulumi.Input[str] url: Url of the script file.
        :param pulumi.Input[str] parameters: Additional parameters for the script action. It should be space-separated list of arguments required for script execution.
        :param pulumi.Input[bool] should_persist: Specify if the script should persist on the cluster.
        :param pulumi.Input[int] timeout_in_minutes: Timeout duration for the script action in minutes.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if should_persist is None:
            should_persist = True
        if should_persist is not None:
            pulumi.set(__self__, "should_persist", should_persist)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Script name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def services(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of services to apply the script action.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the script action. Supported type is bash scripts.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Url of the script file.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional parameters for the script action. It should be space-separated list of arguments required for script execution.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="shouldPersist")
    def should_persist(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if the script should persist on the cluster.
        """
        return pulumi.get(self, "should_persist")

    @should_persist.setter
    def should_persist(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_persist", value)

    @property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout duration for the script action in minutes.
        """
        return pulumi.get(self, "timeout_in_minutes")

    @timeout_in_minutes.setter
    def timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_minutes", value)


@pulumi.input_type
class SecretReferenceArgs:
    def __init__(__self__, *,
                 key_vault_object_name: pulumi.Input[str],
                 reference_name: pulumi.Input[str],
                 type: pulumi.Input[Union[str, 'KeyVaultObjectType']],
                 version: Optional[pulumi.Input[str]] = None):
        """
        Secret reference and corresponding properties of a key vault secret.
        :param pulumi.Input[str] key_vault_object_name: Object identifier name of the secret in key vault.
        :param pulumi.Input[str] reference_name: Reference name of the secret to be used in service configs.
        :param pulumi.Input[Union[str, 'KeyVaultObjectType']] type: Type of key vault object: secret, key or certificate.
        :param pulumi.Input[str] version: Version of the secret in key vault.
        """
        pulumi.set(__self__, "key_vault_object_name", key_vault_object_name)
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="keyVaultObjectName")
    def key_vault_object_name(self) -> pulumi.Input[str]:
        """
        Object identifier name of the secret in key vault.
        """
        return pulumi.get(self, "key_vault_object_name")

    @key_vault_object_name.setter
    def key_vault_object_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_object_name", value)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> pulumi.Input[str]:
        """
        Reference name of the secret to be used in service configs.
        """
        return pulumi.get(self, "reference_name")

    @reference_name.setter
    def reference_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'KeyVaultObjectType']]:
        """
        Type of key vault object: secret, key or certificate.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'KeyVaultObjectType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the secret in key vault.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class SecretsProfileArgs:
    def __init__(__self__, *,
                 key_vault_resource_id: pulumi.Input[str],
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgs']]]] = None):
        """
        The cluster secret profile.
        :param pulumi.Input[str] key_vault_resource_id: Name of the user Key Vault where all the cluster specific user secrets are stored.
        :param pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgs']]] secrets: Properties of Key Vault secret.
        """
        pulumi.set(__self__, "key_vault_resource_id", key_vault_resource_id)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> pulumi.Input[str]:
        """
        Name of the user Key Vault where all the cluster specific user secrets are stored.
        """
        return pulumi.get(self, "key_vault_resource_id")

    @key_vault_resource_id.setter
    def key_vault_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_resource_id", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgs']]]]:
        """
        Properties of Key Vault secret.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgs']]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class SparkMetastoreSpecArgs:
    def __init__(__self__, *,
                 db_name: pulumi.Input[str],
                 db_password_secret_name: pulumi.Input[str],
                 db_server_host: pulumi.Input[str],
                 db_user_name: pulumi.Input[str],
                 key_vault_id: pulumi.Input[str],
                 thrift_url: Optional[pulumi.Input[str]] = None):
        """
        The metastore specification for Spark cluster.
        :param pulumi.Input[str] db_name: The database name.
        :param pulumi.Input[str] db_password_secret_name: The secret name which contains the database user password.
        :param pulumi.Input[str] db_server_host: The database server host.
        :param pulumi.Input[str] db_user_name: The database user name.
        :param pulumi.Input[str] key_vault_id: The key vault resource id.
        :param pulumi.Input[str] thrift_url: The thrift url.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_password_secret_name", db_password_secret_name)
        pulumi.set(__self__, "db_server_host", db_server_host)
        pulumi.set(__self__, "db_user_name", db_user_name)
        pulumi.set(__self__, "key_vault_id", key_vault_id)
        if thrift_url is not None:
            pulumi.set(__self__, "thrift_url", thrift_url)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        The database name.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="dbPasswordSecretName")
    def db_password_secret_name(self) -> pulumi.Input[str]:
        """
        The secret name which contains the database user password.
        """
        return pulumi.get(self, "db_password_secret_name")

    @db_password_secret_name.setter
    def db_password_secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_password_secret_name", value)

    @property
    @pulumi.getter(name="dbServerHost")
    def db_server_host(self) -> pulumi.Input[str]:
        """
        The database server host.
        """
        return pulumi.get(self, "db_server_host")

    @db_server_host.setter
    def db_server_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_server_host", value)

    @property
    @pulumi.getter(name="dbUserName")
    def db_user_name(self) -> pulumi.Input[str]:
        """
        The database user name.
        """
        return pulumi.get(self, "db_user_name")

    @db_user_name.setter
    def db_user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_user_name", value)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> pulumi.Input[str]:
        """
        The key vault resource id.
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_id", value)

    @property
    @pulumi.getter(name="thriftUrl")
    def thrift_url(self) -> Optional[pulumi.Input[str]]:
        """
        The thrift url.
        """
        return pulumi.get(self, "thrift_url")

    @thrift_url.setter
    def thrift_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thrift_url", value)


@pulumi.input_type
class SparkProfileArgs:
    def __init__(__self__, *,
                 default_storage_url: Optional[pulumi.Input[str]] = None,
                 metastore_spec: Optional[pulumi.Input['SparkMetastoreSpecArgs']] = None,
                 user_plugins_spec: Optional[pulumi.Input['SparkUserPluginsArgs']] = None):
        """
        The spark cluster profile.
        :param pulumi.Input[str] default_storage_url: The default storage URL.
        :param pulumi.Input['SparkMetastoreSpecArgs'] metastore_spec: The metastore specification for Spark cluster.
        :param pulumi.Input['SparkUserPluginsArgs'] user_plugins_spec: Spark user plugins spec
        """
        if default_storage_url is not None:
            pulumi.set(__self__, "default_storage_url", default_storage_url)
        if metastore_spec is not None:
            pulumi.set(__self__, "metastore_spec", metastore_spec)
        if user_plugins_spec is not None:
            pulumi.set(__self__, "user_plugins_spec", user_plugins_spec)

    @property
    @pulumi.getter(name="defaultStorageUrl")
    def default_storage_url(self) -> Optional[pulumi.Input[str]]:
        """
        The default storage URL.
        """
        return pulumi.get(self, "default_storage_url")

    @default_storage_url.setter
    def default_storage_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_storage_url", value)

    @property
    @pulumi.getter(name="metastoreSpec")
    def metastore_spec(self) -> Optional[pulumi.Input['SparkMetastoreSpecArgs']]:
        """
        The metastore specification for Spark cluster.
        """
        return pulumi.get(self, "metastore_spec")

    @metastore_spec.setter
    def metastore_spec(self, value: Optional[pulumi.Input['SparkMetastoreSpecArgs']]):
        pulumi.set(self, "metastore_spec", value)

    @property
    @pulumi.getter(name="userPluginsSpec")
    def user_plugins_spec(self) -> Optional[pulumi.Input['SparkUserPluginsArgs']]:
        """
        Spark user plugins spec
        """
        return pulumi.get(self, "user_plugins_spec")

    @user_plugins_spec.setter
    def user_plugins_spec(self, value: Optional[pulumi.Input['SparkUserPluginsArgs']]):
        pulumi.set(self, "user_plugins_spec", value)


@pulumi.input_type
class SparkUserPluginsArgs:
    def __init__(__self__, *,
                 plugins: Optional[pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgs']]]] = None):
        """
        Spark user plugins spec
        :param pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgs']]] plugins: Spark user plugins.
        """
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgs']]]]:
        """
        Spark user plugins.
        """
        return pulumi.get(self, "plugins")

    @plugins.setter
    def plugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgs']]]]):
        pulumi.set(self, "plugins", value)


@pulumi.input_type
class SparkUserPluginArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str]):
        """
        Spark user plugin.
        :param pulumi.Input[str] path: Fully qualified path to the folder containing the plugins.
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Fully qualified path to the folder containing the plugins.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class SshProfileArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int]):
        """
        Ssh profile for the cluster.
        :param pulumi.Input[int] count: Number of ssh pods per cluster.
        """
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        Number of ssh pods per cluster.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)


@pulumi.input_type
class TrinoCoordinatorArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 high_availability_enabled: Optional[pulumi.Input[bool]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 suspend: Optional[pulumi.Input[bool]] = None):
        """
        Trino Coordinator.
        :param pulumi.Input[bool] enable: The flag that if enable debug or not.
        :param pulumi.Input[bool] high_availability_enabled: The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.
        :param pulumi.Input[int] port: The debug port.
        :param pulumi.Input[bool] suspend: The flag that if suspend debug or not.
        """
        if enable is None:
            enable = False
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if high_availability_enabled is None:
            high_availability_enabled = True
        if high_availability_enabled is not None:
            pulumi.set(__self__, "high_availability_enabled", high_availability_enabled)
        if port is None:
            port = 8008
        if port is not None:
            pulumi.set(__self__, "port", port)
        if suspend is None:
            suspend = False
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if enable debug or not.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="highAvailabilityEnabled")
    def high_availability_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.
        """
        return pulumi.get(self, "high_availability_enabled")

    @high_availability_enabled.setter
    def high_availability_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "high_availability_enabled", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The debug port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if suspend debug or not.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suspend", value)


@pulumi.input_type
class TrinoProfileArgs:
    def __init__(__self__, *,
                 catalog_options: Optional[pulumi.Input['CatalogOptionsArgs']] = None,
                 coordinator: Optional[pulumi.Input['TrinoCoordinatorArgs']] = None,
                 user_plugins_spec: Optional[pulumi.Input['TrinoUserPluginsArgs']] = None,
                 user_telemetry_spec: Optional[pulumi.Input['TrinoUserTelemetryArgs']] = None,
                 worker: Optional[pulumi.Input['TrinoWorkerArgs']] = None):
        """
        Trino Cluster profile.
        :param pulumi.Input['CatalogOptionsArgs'] catalog_options: Trino cluster catalog options.
        :param pulumi.Input['TrinoCoordinatorArgs'] coordinator: Trino Coordinator.
        :param pulumi.Input['TrinoUserPluginsArgs'] user_plugins_spec: Trino user plugins spec
        :param pulumi.Input['TrinoUserTelemetryArgs'] user_telemetry_spec: User telemetry
        :param pulumi.Input['TrinoWorkerArgs'] worker: Trino worker.
        """
        if catalog_options is not None:
            pulumi.set(__self__, "catalog_options", catalog_options)
        if coordinator is not None:
            pulumi.set(__self__, "coordinator", coordinator)
        if user_plugins_spec is not None:
            pulumi.set(__self__, "user_plugins_spec", user_plugins_spec)
        if user_telemetry_spec is not None:
            pulumi.set(__self__, "user_telemetry_spec", user_telemetry_spec)
        if worker is not None:
            pulumi.set(__self__, "worker", worker)

    @property
    @pulumi.getter(name="catalogOptions")
    def catalog_options(self) -> Optional[pulumi.Input['CatalogOptionsArgs']]:
        """
        Trino cluster catalog options.
        """
        return pulumi.get(self, "catalog_options")

    @catalog_options.setter
    def catalog_options(self, value: Optional[pulumi.Input['CatalogOptionsArgs']]):
        pulumi.set(self, "catalog_options", value)

    @property
    @pulumi.getter
    def coordinator(self) -> Optional[pulumi.Input['TrinoCoordinatorArgs']]:
        """
        Trino Coordinator.
        """
        return pulumi.get(self, "coordinator")

    @coordinator.setter
    def coordinator(self, value: Optional[pulumi.Input['TrinoCoordinatorArgs']]):
        pulumi.set(self, "coordinator", value)

    @property
    @pulumi.getter(name="userPluginsSpec")
    def user_plugins_spec(self) -> Optional[pulumi.Input['TrinoUserPluginsArgs']]:
        """
        Trino user plugins spec
        """
        return pulumi.get(self, "user_plugins_spec")

    @user_plugins_spec.setter
    def user_plugins_spec(self, value: Optional[pulumi.Input['TrinoUserPluginsArgs']]):
        pulumi.set(self, "user_plugins_spec", value)

    @property
    @pulumi.getter(name="userTelemetrySpec")
    def user_telemetry_spec(self) -> Optional[pulumi.Input['TrinoUserTelemetryArgs']]:
        """
        User telemetry
        """
        return pulumi.get(self, "user_telemetry_spec")

    @user_telemetry_spec.setter
    def user_telemetry_spec(self, value: Optional[pulumi.Input['TrinoUserTelemetryArgs']]):
        pulumi.set(self, "user_telemetry_spec", value)

    @property
    @pulumi.getter
    def worker(self) -> Optional[pulumi.Input['TrinoWorkerArgs']]:
        """
        Trino worker.
        """
        return pulumi.get(self, "worker")

    @worker.setter
    def worker(self, value: Optional[pulumi.Input['TrinoWorkerArgs']]):
        pulumi.set(self, "worker", value)


@pulumi.input_type
class TrinoTelemetryConfigArgs:
    def __init__(__self__, *,
                 hivecatalog_name: Optional[pulumi.Input[str]] = None,
                 hivecatalog_schema: Optional[pulumi.Input[str]] = None,
                 partition_retention_in_days: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        Trino user telemetry definition.
        :param pulumi.Input[str] hivecatalog_name: Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        :param pulumi.Input[str] hivecatalog_schema: Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.
        :param pulumi.Input[int] partition_retention_in_days: Retention period for query log table partitions, this doesn't have any affect on actual data.
        :param pulumi.Input[str] path: Azure storage location of the blobs.
        """
        if hivecatalog_name is not None:
            pulumi.set(__self__, "hivecatalog_name", hivecatalog_name)
        if hivecatalog_schema is None:
            hivecatalog_schema = 'trinologs'
        if hivecatalog_schema is not None:
            pulumi.set(__self__, "hivecatalog_schema", hivecatalog_schema)
        if partition_retention_in_days is None:
            partition_retention_in_days = 365
        if partition_retention_in_days is not None:
            pulumi.set(__self__, "partition_retention_in_days", partition_retention_in_days)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="hivecatalogName")
    def hivecatalog_name(self) -> Optional[pulumi.Input[str]]:
        """
        Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        """
        return pulumi.get(self, "hivecatalog_name")

    @hivecatalog_name.setter
    def hivecatalog_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hivecatalog_name", value)

    @property
    @pulumi.getter(name="hivecatalogSchema")
    def hivecatalog_schema(self) -> Optional[pulumi.Input[str]]:
        """
        Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.
        """
        return pulumi.get(self, "hivecatalog_schema")

    @hivecatalog_schema.setter
    def hivecatalog_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hivecatalog_schema", value)

    @property
    @pulumi.getter(name="partitionRetentionInDays")
    def partition_retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Retention period for query log table partitions, this doesn't have any affect on actual data.
        """
        return pulumi.get(self, "partition_retention_in_days")

    @partition_retention_in_days.setter
    def partition_retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "partition_retention_in_days", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Azure storage location of the blobs.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class TrinoUserPluginsArgs:
    def __init__(__self__, *,
                 plugins: Optional[pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgs']]]] = None):
        """
        Trino user plugins spec
        :param pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgs']]] plugins: Trino user plugins.
        """
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgs']]]]:
        """
        Trino user plugins.
        """
        return pulumi.get(self, "plugins")

    @plugins.setter
    def plugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgs']]]]):
        pulumi.set(self, "plugins", value)


@pulumi.input_type
class TrinoUserPluginArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        Trino user plugin.
        :param pulumi.Input[bool] enabled: Denotes whether the plugin is active or not.
        :param pulumi.Input[str] name: This field maps to the sub-directory in trino plugins location, that will contain all the plugins under path.
        :param pulumi.Input[str] path: Fully qualified path to the folder containing the plugins.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Denotes whether the plugin is active or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        This field maps to the sub-directory in trino plugins location, that will contain all the plugins under path.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified path to the folder containing the plugins.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class TrinoUserTelemetryArgs:
    def __init__(__self__, *,
                 storage: Optional[pulumi.Input['TrinoTelemetryConfigArgs']] = None):
        """
        User telemetry
        :param pulumi.Input['TrinoTelemetryConfigArgs'] storage: Trino user telemetry definition.
        """
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input['TrinoTelemetryConfigArgs']]:
        """
        Trino user telemetry definition.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input['TrinoTelemetryConfigArgs']]):
        pulumi.set(self, "storage", value)


@pulumi.input_type
class TrinoWorkerArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 suspend: Optional[pulumi.Input[bool]] = None):
        """
        Trino worker.
        :param pulumi.Input[bool] enable: The flag that if enable debug or not.
        :param pulumi.Input[int] port: The debug port.
        :param pulumi.Input[bool] suspend: The flag that if suspend debug or not.
        """
        if enable is None:
            enable = False
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if port is None:
            port = 8008
        if port is not None:
            pulumi.set(__self__, "port", port)
        if suspend is None:
            suspend = False
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if enable debug or not.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The debug port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if suspend debug or not.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suspend", value)


