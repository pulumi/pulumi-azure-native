# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AksClusterProfileResponseAksClusterAgentPoolIdentityProfile',
    'ApplicationGetEndpointResponse',
    'ApplicationGetHttpsEndpointResponse',
    'ApplicationPropertiesResponse',
    'AuthorizationProfileResponse',
    'AutoscaleCapacityResponse',
    'AutoscaleProfileResponse',
    'AutoscaleRecurrenceResponse',
    'AutoscaleResponse',
    'AutoscaleScheduleResponse',
    'AutoscaleTimeAndCapacityResponse',
    'CatalogOptionsResponse',
    'ClientGroupInfoResponse',
    'ClusterAccessProfileResponse',
    'ClusterConfigFileResponse',
    'ClusterDefinitionResponse',
    'ClusterGetPropertiesResponse',
    'ClusterIdentityResponse',
    'ClusterLogAnalyticsApplicationLogsResponse',
    'ClusterLogAnalyticsProfileResponse',
    'ClusterPoolComputeProfileResponse',
    'ClusterPoolResourcePropertiesResponseAksClusterProfile',
    'ClusterPoolResourcePropertiesResponseClusterPoolProfile',
    'ClusterPoolResourcePropertiesResponseComputeProfile',
    'ClusterPoolResourcePropertiesResponseLogAnalyticsProfile',
    'ClusterPoolResourcePropertiesResponseNetworkProfile',
    'ClusterPoolSshProfileResponse',
    'ClusterProfileResponse',
    'ClusterProfileResponseComponents',
    'ClusterPrometheusProfileResponse',
    'ClusterRangerPluginProfileResponse',
    'ClusterServiceConfigResponse',
    'ClusterServiceConfigsProfileResponse',
    'ComparisonRuleResponse',
    'ComputeIsolationPropertiesResponse',
    'ComputeProfileResponse',
    'ComputeResourceDefinitionResponse',
    'ConnectivityEndpointResponse',
    'ConnectivityProfileResponse',
    'ConnectivityProfileResponseWeb',
    'DataDisksGroupsResponse',
    'DiskEncryptionPropertiesResponse',
    'DiskStorageProfileResponse',
    'EncryptionInTransitPropertiesResponse',
    'ErrorsResponse',
    'ExcludedServicesConfigResponse',
    'FlinkCatalogOptionsResponse',
    'FlinkHiveCatalogOptionResponse',
    'FlinkJobProfileResponse',
    'FlinkProfileResponse',
    'FlinkStorageProfileResponse',
    'HardwareProfileResponse',
    'HiveCatalogOptionResponse',
    'IPConfigurationResponse',
    'IdentityProfileResponse',
    'IpTagResponse',
    'KafkaConnectivityEndpointsResponse',
    'KafkaProfileResponse',
    'KafkaRestPropertiesResponse',
    'LinuxOperatingSystemProfileResponse',
    'LoadBasedConfigResponse',
    'ManagedIdentityProfileResponse',
    'ManagedIdentitySpecResponse',
    'NetworkPropertiesResponse',
    'NodeProfileResponse',
    'OsProfileResponse',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointResponse',
    'PrivateLinkConfigurationResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'QuotaInfoResponse',
    'RangerAdminSpecResponse',
    'RangerAdminSpecResponseDatabase',
    'RangerAuditSpecResponse',
    'RangerProfileResponse',
    'RangerUsersyncSpecResponse',
    'ResourceIdResponse',
    'RoleResponse',
    'RuntimeScriptActionResponse',
    'ScalingRuleResponse',
    'ScheduleBasedConfigResponse',
    'ScheduleResponse',
    'ScriptActionProfileResponse',
    'ScriptActionResponse',
    'SecretReferenceResponse',
    'SecretsProfileResponse',
    'SecurityProfileResponse',
    'SparkMetastoreSpecResponse',
    'SparkProfileResponse',
    'SparkUserPluginResponse',
    'SparkUserPluginsResponse',
    'SshConnectivityEndpointResponse',
    'SshProfileResponse',
    'SshPublicKeyResponse',
    'StorageAccountResponse',
    'StorageProfileResponse',
    'SystemDataResponse',
    'TrinoCoordinatorResponse',
    'TrinoProfileResponse',
    'TrinoTelemetryConfigResponse',
    'TrinoUserPluginResponse',
    'TrinoUserPluginsResponse',
    'TrinoUserTelemetryResponse',
    'TrinoWorkerResponse',
    'UserAssignedIdentityResponse',
    'VirtualNetworkProfileResponse',
]

@pulumi.output_type
class AksClusterProfileResponseAksClusterAgentPoolIdentityProfile(dict):
    """
    Identity properties of the AKS cluster agentpool MSI
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "msiClientId":
            suggest = "msi_client_id"
        elif key == "msiObjectId":
            suggest = "msi_object_id"
        elif key == "msiResourceId":
            suggest = "msi_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AksClusterProfileResponseAksClusterAgentPoolIdentityProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AksClusterProfileResponseAksClusterAgentPoolIdentityProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AksClusterProfileResponseAksClusterAgentPoolIdentityProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 msi_client_id: str,
                 msi_object_id: str,
                 msi_resource_id: str):
        """
        Identity properties of the AKS cluster agentpool MSI
        :param str msi_client_id: ClientId of the MSI.
        :param str msi_object_id: ObjectId of the MSI.
        :param str msi_resource_id: ResourceId of the MSI.
        """
        pulumi.set(__self__, "msi_client_id", msi_client_id)
        pulumi.set(__self__, "msi_object_id", msi_object_id)
        pulumi.set(__self__, "msi_resource_id", msi_resource_id)

    @property
    @pulumi.getter(name="msiClientId")
    def msi_client_id(self) -> str:
        """
        ClientId of the MSI.
        """
        return pulumi.get(self, "msi_client_id")

    @property
    @pulumi.getter(name="msiObjectId")
    def msi_object_id(self) -> str:
        """
        ObjectId of the MSI.
        """
        return pulumi.get(self, "msi_object_id")

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> str:
        """
        ResourceId of the MSI.
        """
        return pulumi.get(self, "msi_resource_id")


@pulumi.output_type
class ApplicationGetEndpointResponse(dict):
    """
    Gets the application SSH endpoint
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPort":
            suggest = "destination_port"
        elif key == "privateIPAddress":
            suggest = "private_ip_address"
        elif key == "publicPort":
            suggest = "public_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGetEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGetEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGetEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_port: Optional[int] = None,
                 location: Optional[str] = None,
                 private_ip_address: Optional[str] = None,
                 public_port: Optional[int] = None):
        """
        Gets the application SSH endpoint
        :param int destination_port: The destination port to connect to.
        :param str location: The location of the endpoint.
        :param str private_ip_address: The private ip address of the endpoint.
        :param int public_port: The public port to connect to.
        """
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if public_port is not None:
            pulumi.set(__self__, "public_port", public_port)

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[int]:
        """
        The destination port to connect to.
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The location of the endpoint.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private ip address of the endpoint.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="publicPort")
    def public_port(self) -> Optional[int]:
        """
        The public port to connect to.
        """
        return pulumi.get(self, "public_port")


@pulumi.output_type
class ApplicationGetHttpsEndpointResponse(dict):
    """
    Gets the application HTTP endpoints.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicPort":
            suggest = "public_port"
        elif key == "accessModes":
            suggest = "access_modes"
        elif key == "destinationPort":
            suggest = "destination_port"
        elif key == "disableGatewayAuth":
            suggest = "disable_gateway_auth"
        elif key == "privateIPAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGetHttpsEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGetHttpsEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGetHttpsEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 public_port: int,
                 access_modes: Optional[Sequence[str]] = None,
                 destination_port: Optional[int] = None,
                 disable_gateway_auth: Optional[bool] = None,
                 private_ip_address: Optional[str] = None):
        """
        Gets the application HTTP endpoints.
        :param str location: The location of the endpoint.
        :param int public_port: The public port to connect to.
        :param Sequence[str] access_modes: The list of access modes for the application.
        :param int destination_port: The destination port to connect to.
        :param bool disable_gateway_auth: The value indicates whether to disable GatewayAuth.
        :param str private_ip_address: The private ip address of the endpoint.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "public_port", public_port)
        if access_modes is not None:
            pulumi.set(__self__, "access_modes", access_modes)
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if disable_gateway_auth is not None:
            pulumi.set(__self__, "disable_gateway_auth", disable_gateway_auth)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The location of the endpoint.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="publicPort")
    def public_port(self) -> int:
        """
        The public port to connect to.
        """
        return pulumi.get(self, "public_port")

    @property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Optional[Sequence[str]]:
        """
        The list of access modes for the application.
        """
        return pulumi.get(self, "access_modes")

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[int]:
        """
        The destination port to connect to.
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter(name="disableGatewayAuth")
    def disable_gateway_auth(self) -> Optional[bool]:
        """
        The value indicates whether to disable GatewayAuth.
        """
        return pulumi.get(self, "disable_gateway_auth")

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private ip address of the endpoint.
        """
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class ApplicationPropertiesResponse(dict):
    """
    The HDInsight cluster application GET response.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationState":
            suggest = "application_state"
        elif key == "createdDate":
            suggest = "created_date"
        elif key == "marketplaceIdentifier":
            suggest = "marketplace_identifier"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "applicationType":
            suggest = "application_type"
        elif key == "computeProfile":
            suggest = "compute_profile"
        elif key == "httpsEndpoints":
            suggest = "https_endpoints"
        elif key == "installScriptActions":
            suggest = "install_script_actions"
        elif key == "privateLinkConfigurations":
            suggest = "private_link_configurations"
        elif key == "sshEndpoints":
            suggest = "ssh_endpoints"
        elif key == "uninstallScriptActions":
            suggest = "uninstall_script_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_state: str,
                 created_date: str,
                 marketplace_identifier: str,
                 provisioning_state: str,
                 application_type: Optional[str] = None,
                 compute_profile: Optional['outputs.ComputeProfileResponse'] = None,
                 errors: Optional[Sequence['outputs.ErrorsResponse']] = None,
                 https_endpoints: Optional[Sequence['outputs.ApplicationGetHttpsEndpointResponse']] = None,
                 install_script_actions: Optional[Sequence['outputs.RuntimeScriptActionResponse']] = None,
                 private_link_configurations: Optional[Sequence['outputs.PrivateLinkConfigurationResponse']] = None,
                 ssh_endpoints: Optional[Sequence['outputs.ApplicationGetEndpointResponse']] = None,
                 uninstall_script_actions: Optional[Sequence['outputs.RuntimeScriptActionResponse']] = None):
        """
        The HDInsight cluster application GET response.
        :param str application_state: The application state.
        :param str created_date: The application create date time.
        :param str marketplace_identifier: The marketplace identifier.
        :param str provisioning_state: The provisioning state of the application.
        :param str application_type: The application type.
        :param 'ComputeProfileResponse' compute_profile: The list of roles in the cluster.
        :param Sequence['ErrorsResponse'] errors: The list of errors.
        :param Sequence['ApplicationGetHttpsEndpointResponse'] https_endpoints: The list of application HTTPS endpoints.
        :param Sequence['RuntimeScriptActionResponse'] install_script_actions: The list of install script actions.
        :param Sequence['PrivateLinkConfigurationResponse'] private_link_configurations: The private link configurations.
        :param Sequence['ApplicationGetEndpointResponse'] ssh_endpoints: The list of application SSH endpoints.
        :param Sequence['RuntimeScriptActionResponse'] uninstall_script_actions: The list of uninstall script actions.
        """
        pulumi.set(__self__, "application_state", application_state)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "marketplace_identifier", marketplace_identifier)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if application_type is not None:
            pulumi.set(__self__, "application_type", application_type)
        if compute_profile is not None:
            pulumi.set(__self__, "compute_profile", compute_profile)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if https_endpoints is not None:
            pulumi.set(__self__, "https_endpoints", https_endpoints)
        if install_script_actions is not None:
            pulumi.set(__self__, "install_script_actions", install_script_actions)
        if private_link_configurations is not None:
            pulumi.set(__self__, "private_link_configurations", private_link_configurations)
        if ssh_endpoints is not None:
            pulumi.set(__self__, "ssh_endpoints", ssh_endpoints)
        if uninstall_script_actions is not None:
            pulumi.set(__self__, "uninstall_script_actions", uninstall_script_actions)

    @property
    @pulumi.getter(name="applicationState")
    def application_state(self) -> str:
        """
        The application state.
        """
        return pulumi.get(self, "application_state")

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> str:
        """
        The application create date time.
        """
        return pulumi.get(self, "created_date")

    @property
    @pulumi.getter(name="marketplaceIdentifier")
    def marketplace_identifier(self) -> str:
        """
        The marketplace identifier.
        """
        return pulumi.get(self, "marketplace_identifier")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the application.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="applicationType")
    def application_type(self) -> Optional[str]:
        """
        The application type.
        """
        return pulumi.get(self, "application_type")

    @property
    @pulumi.getter(name="computeProfile")
    def compute_profile(self) -> Optional['outputs.ComputeProfileResponse']:
        """
        The list of roles in the cluster.
        """
        return pulumi.get(self, "compute_profile")

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.ErrorsResponse']]:
        """
        The list of errors.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter(name="httpsEndpoints")
    def https_endpoints(self) -> Optional[Sequence['outputs.ApplicationGetHttpsEndpointResponse']]:
        """
        The list of application HTTPS endpoints.
        """
        return pulumi.get(self, "https_endpoints")

    @property
    @pulumi.getter(name="installScriptActions")
    def install_script_actions(self) -> Optional[Sequence['outputs.RuntimeScriptActionResponse']]:
        """
        The list of install script actions.
        """
        return pulumi.get(self, "install_script_actions")

    @property
    @pulumi.getter(name="privateLinkConfigurations")
    def private_link_configurations(self) -> Optional[Sequence['outputs.PrivateLinkConfigurationResponse']]:
        """
        The private link configurations.
        """
        return pulumi.get(self, "private_link_configurations")

    @property
    @pulumi.getter(name="sshEndpoints")
    def ssh_endpoints(self) -> Optional[Sequence['outputs.ApplicationGetEndpointResponse']]:
        """
        The list of application SSH endpoints.
        """
        return pulumi.get(self, "ssh_endpoints")

    @property
    @pulumi.getter(name="uninstallScriptActions")
    def uninstall_script_actions(self) -> Optional[Sequence['outputs.RuntimeScriptActionResponse']]:
        """
        The list of uninstall script actions.
        """
        return pulumi.get(self, "uninstall_script_actions")


@pulumi.output_type
class AuthorizationProfileResponse(dict):
    """
    Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "userIds":
            suggest = "user_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthorizationProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthorizationProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthorizationProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Optional[Sequence[str]] = None,
                 user_ids: Optional[Sequence[str]] = None):
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        :param Sequence[str] group_ids: AAD group Ids authorized for data plane access.
        :param Sequence[str] user_ids: AAD user Ids authorized for data plane access.
        """
        if group_ids is not None:
            pulumi.set(__self__, "group_ids", group_ids)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[Sequence[str]]:
        """
        AAD group Ids authorized for data plane access.
        """
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[Sequence[str]]:
        """
        AAD user Ids authorized for data plane access.
        """
        return pulumi.get(self, "user_ids")


@pulumi.output_type
class AutoscaleCapacityResponse(dict):
    """
    The load-based autoscale request parameters
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxInstanceCount":
            suggest = "max_instance_count"
        elif key == "minInstanceCount":
            suggest = "min_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscaleCapacityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscaleCapacityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscaleCapacityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_instance_count: Optional[int] = None,
                 min_instance_count: Optional[int] = None):
        """
        The load-based autoscale request parameters
        :param int max_instance_count: The maximum instance count of the cluster
        :param int min_instance_count: The minimum instance count of the cluster
        """
        if max_instance_count is not None:
            pulumi.set(__self__, "max_instance_count", max_instance_count)
        if min_instance_count is not None:
            pulumi.set(__self__, "min_instance_count", min_instance_count)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> Optional[int]:
        """
        The maximum instance count of the cluster
        """
        return pulumi.get(self, "max_instance_count")

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> Optional[int]:
        """
        The minimum instance count of the cluster
        """
        return pulumi.get(self, "min_instance_count")


@pulumi.output_type
class AutoscaleProfileResponse(dict):
    """
    This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscaleType":
            suggest = "autoscale_type"
        elif key == "gracefulDecommissionTimeout":
            suggest = "graceful_decommission_timeout"
        elif key == "loadBasedConfig":
            suggest = "load_based_config"
        elif key == "scheduleBasedConfig":
            suggest = "schedule_based_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscaleProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscaleProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscaleProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 autoscale_type: Optional[str] = None,
                 graceful_decommission_timeout: Optional[int] = None,
                 load_based_config: Optional['outputs.LoadBasedConfigResponse'] = None,
                 schedule_based_config: Optional['outputs.ScheduleBasedConfigResponse'] = None):
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        :param bool enabled: This indicates whether auto scale is enabled on HDInsight on AKS cluster.
        :param str autoscale_type: User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        :param int graceful_decommission_timeout: This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        :param 'LoadBasedConfigResponse' load_based_config: Profiles of load based Autoscale.
        :param 'ScheduleBasedConfigResponse' schedule_based_config: Profiles of schedule based Autoscale.
        """
        pulumi.set(__self__, "enabled", enabled)
        if autoscale_type is not None:
            pulumi.set(__self__, "autoscale_type", autoscale_type)
        if graceful_decommission_timeout is not None:
            pulumi.set(__self__, "graceful_decommission_timeout", graceful_decommission_timeout)
        if load_based_config is not None:
            pulumi.set(__self__, "load_based_config", load_based_config)
        if schedule_based_config is not None:
            pulumi.set(__self__, "schedule_based_config", schedule_based_config)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        This indicates whether auto scale is enabled on HDInsight on AKS cluster.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="autoscaleType")
    def autoscale_type(self) -> Optional[str]:
        """
        User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        """
        return pulumi.get(self, "autoscale_type")

    @property
    @pulumi.getter(name="gracefulDecommissionTimeout")
    def graceful_decommission_timeout(self) -> Optional[int]:
        """
        This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        """
        return pulumi.get(self, "graceful_decommission_timeout")

    @property
    @pulumi.getter(name="loadBasedConfig")
    def load_based_config(self) -> Optional['outputs.LoadBasedConfigResponse']:
        """
        Profiles of load based Autoscale.
        """
        return pulumi.get(self, "load_based_config")

    @property
    @pulumi.getter(name="scheduleBasedConfig")
    def schedule_based_config(self) -> Optional['outputs.ScheduleBasedConfigResponse']:
        """
        Profiles of schedule based Autoscale.
        """
        return pulumi.get(self, "schedule_based_config")


@pulumi.output_type
class AutoscaleRecurrenceResponse(dict):
    """
    Schedule-based autoscale request parameters
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscaleRecurrenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscaleRecurrenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscaleRecurrenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schedule: Optional[Sequence['outputs.AutoscaleScheduleResponse']] = None,
                 time_zone: Optional[str] = None):
        """
        Schedule-based autoscale request parameters
        :param Sequence['AutoscaleScheduleResponse'] schedule: Array of schedule-based autoscale rules
        :param str time_zone: The time zone for the autoscale schedule times
        """
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[Sequence['outputs.AutoscaleScheduleResponse']]:
        """
        Array of schedule-based autoscale rules
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        The time zone for the autoscale schedule times
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class AutoscaleResponse(dict):
    """
    The autoscale request parameters
    """
    def __init__(__self__, *,
                 capacity: Optional['outputs.AutoscaleCapacityResponse'] = None,
                 recurrence: Optional['outputs.AutoscaleRecurrenceResponse'] = None):
        """
        The autoscale request parameters
        :param 'AutoscaleCapacityResponse' capacity: Parameters for load-based autoscale
        :param 'AutoscaleRecurrenceResponse' recurrence: Parameters for schedule-based autoscale
        """
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)

    @property
    @pulumi.getter
    def capacity(self) -> Optional['outputs.AutoscaleCapacityResponse']:
        """
        Parameters for load-based autoscale
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def recurrence(self) -> Optional['outputs.AutoscaleRecurrenceResponse']:
        """
        Parameters for schedule-based autoscale
        """
        return pulumi.get(self, "recurrence")


@pulumi.output_type
class AutoscaleScheduleResponse(dict):
    """
    Parameters for a schedule-based autoscale rule, consisting of an array of days + a time and capacity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeAndCapacity":
            suggest = "time_and_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscaleScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscaleScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscaleScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Optional[Sequence[str]] = None,
                 time_and_capacity: Optional['outputs.AutoscaleTimeAndCapacityResponse'] = None):
        """
        Parameters for a schedule-based autoscale rule, consisting of an array of days + a time and capacity
        :param Sequence[str] days: Days of the week for a schedule-based autoscale rule
        :param 'AutoscaleTimeAndCapacityResponse' time_and_capacity: Time and capacity for a schedule-based autoscale rule
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if time_and_capacity is not None:
            pulumi.set(__self__, "time_and_capacity", time_and_capacity)

    @property
    @pulumi.getter
    def days(self) -> Optional[Sequence[str]]:
        """
        Days of the week for a schedule-based autoscale rule
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="timeAndCapacity")
    def time_and_capacity(self) -> Optional['outputs.AutoscaleTimeAndCapacityResponse']:
        """
        Time and capacity for a schedule-based autoscale rule
        """
        return pulumi.get(self, "time_and_capacity")


@pulumi.output_type
class AutoscaleTimeAndCapacityResponse(dict):
    """
    Time and capacity request parameters
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxInstanceCount":
            suggest = "max_instance_count"
        elif key == "minInstanceCount":
            suggest = "min_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoscaleTimeAndCapacityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoscaleTimeAndCapacityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoscaleTimeAndCapacityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_instance_count: Optional[int] = None,
                 min_instance_count: Optional[int] = None,
                 time: Optional[str] = None):
        """
        Time and capacity request parameters
        :param int max_instance_count: The maximum instance count of the cluster
        :param int min_instance_count: The minimum instance count of the cluster
        :param str time: 24-hour time in the form xx:xx
        """
        if max_instance_count is not None:
            pulumi.set(__self__, "max_instance_count", max_instance_count)
        if min_instance_count is not None:
            pulumi.set(__self__, "min_instance_count", min_instance_count)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> Optional[int]:
        """
        The maximum instance count of the cluster
        """
        return pulumi.get(self, "max_instance_count")

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> Optional[int]:
        """
        The minimum instance count of the cluster
        """
        return pulumi.get(self, "min_instance_count")

    @property
    @pulumi.getter
    def time(self) -> Optional[str]:
        """
        24-hour time in the form xx:xx
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class CatalogOptionsResponse(dict):
    """
    Trino cluster catalog options.
    """
    def __init__(__self__, *,
                 hive: Optional[Sequence['outputs.HiveCatalogOptionResponse']] = None):
        """
        Trino cluster catalog options.
        :param Sequence['HiveCatalogOptionResponse'] hive: hive catalog options.
        """
        if hive is not None:
            pulumi.set(__self__, "hive", hive)

    @property
    @pulumi.getter
    def hive(self) -> Optional[Sequence['outputs.HiveCatalogOptionResponse']]:
        """
        hive catalog options.
        """
        return pulumi.get(self, "hive")


@pulumi.output_type
class ClientGroupInfoResponse(dict):
    """
    The information of AAD security group.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "groupName":
            suggest = "group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientGroupInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientGroupInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientGroupInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: Optional[str] = None,
                 group_name: Optional[str] = None):
        """
        The information of AAD security group.
        :param str group_id: The AAD security group id.
        :param str group_name: The AAD security group name.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The AAD security group id.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        The AAD security group name.
        """
        return pulumi.get(self, "group_name")


@pulumi.output_type
class ClusterAccessProfileResponse(dict):
    """
    Cluster access profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableInternalIngress":
            suggest = "enable_internal_ingress"
        elif key == "privateLinkServiceId":
            suggest = "private_link_service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAccessProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAccessProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAccessProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_internal_ingress: bool,
                 private_link_service_id: str):
        """
        Cluster access profile.
        :param bool enable_internal_ingress: Whether to create cluster using private IP instead of public IP. This property must be set at create time.
        :param str private_link_service_id: Private link service resource ID. Only when enableInternalIngress is true, this property will be returned.
        """
        pulumi.set(__self__, "enable_internal_ingress", enable_internal_ingress)
        pulumi.set(__self__, "private_link_service_id", private_link_service_id)

    @property
    @pulumi.getter(name="enableInternalIngress")
    def enable_internal_ingress(self) -> bool:
        """
        Whether to create cluster using private IP instead of public IP. This property must be set at create time.
        """
        return pulumi.get(self, "enable_internal_ingress")

    @property
    @pulumi.getter(name="privateLinkServiceId")
    def private_link_service_id(self) -> str:
        """
        Private link service resource ID. Only when enableInternalIngress is true, this property will be returned.
        """
        return pulumi.get(self, "private_link_service_id")


@pulumi.output_type
class ClusterConfigFileResponse(dict):
    """
    Cluster configuration files.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileName":
            suggest = "file_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConfigFileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConfigFileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConfigFileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_name: str,
                 content: Optional[str] = None,
                 encoding: Optional[str] = None,
                 path: Optional[str] = None,
                 values: Optional[Mapping[str, str]] = None):
        """
        Cluster configuration files.
        :param str file_name: Configuration file name.
        :param str content: Free form content of the entire configuration file.
        :param str encoding: This property indicates if the content is encoded and is case-insensitive. Please set the value to base64 if the content is base64 encoded. Set it to none or skip it if the content is plain text.
        :param str path: Path of the config file if content is specified.
        :param Mapping[str, str] values: List of key value pairs
               where key represents a valid service configuration name and value represents the value of the config.
        """
        pulumi.set(__self__, "file_name", file_name)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> str:
        """
        Configuration file name.
        """
        return pulumi.get(self, "file_name")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        Free form content of the entire configuration file.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        This property indicates if the content is encoded and is case-insensitive. Please set the value to base64 if the content is base64 encoded. Set it to none or skip it if the content is plain text.
        """
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path of the config file if content is specified.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def values(self) -> Optional[Mapping[str, str]]:
        """
        List of key value pairs
        where key represents a valid service configuration name and value represents the value of the config.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterDefinitionResponse(dict):
    """
    The cluster definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentVersion":
            suggest = "component_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blueprint: Optional[str] = None,
                 component_version: Optional[Mapping[str, str]] = None,
                 configurations: Optional[Any] = None,
                 kind: Optional[str] = None):
        """
        The cluster definition.
        :param str blueprint: The link to the blueprint.
        :param Mapping[str, str] component_version: The versions of different services in the cluster.
        :param Any configurations: The cluster configurations.
        :param str kind: The type of cluster.
        """
        if blueprint is not None:
            pulumi.set(__self__, "blueprint", blueprint)
        if component_version is not None:
            pulumi.set(__self__, "component_version", component_version)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def blueprint(self) -> Optional[str]:
        """
        The link to the blueprint.
        """
        return pulumi.get(self, "blueprint")

    @property
    @pulumi.getter(name="componentVersion")
    def component_version(self) -> Optional[Mapping[str, str]]:
        """
        The versions of different services in the cluster.
        """
        return pulumi.get(self, "component_version")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Any]:
        """
        The cluster configurations.
        """
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        The type of cluster.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class ClusterGetPropertiesResponse(dict):
    """
    The properties of cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterDefinition":
            suggest = "cluster_definition"
        elif key == "privateEndpointConnections":
            suggest = "private_endpoint_connections"
        elif key == "clusterHdpVersion":
            suggest = "cluster_hdp_version"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "clusterState":
            suggest = "cluster_state"
        elif key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "computeIsolationProperties":
            suggest = "compute_isolation_properties"
        elif key == "computeProfile":
            suggest = "compute_profile"
        elif key == "connectivityEndpoints":
            suggest = "connectivity_endpoints"
        elif key == "createdDate":
            suggest = "created_date"
        elif key == "diskEncryptionProperties":
            suggest = "disk_encryption_properties"
        elif key == "encryptionInTransitProperties":
            suggest = "encryption_in_transit_properties"
        elif key == "excludedServicesConfig":
            suggest = "excluded_services_config"
        elif key == "kafkaRestProperties":
            suggest = "kafka_rest_properties"
        elif key == "minSupportedTlsVersion":
            suggest = "min_supported_tls_version"
        elif key == "networkProperties":
            suggest = "network_properties"
        elif key == "osType":
            suggest = "os_type"
        elif key == "privateLinkConfigurations":
            suggest = "private_link_configurations"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "quotaInfo":
            suggest = "quota_info"
        elif key == "securityProfile":
            suggest = "security_profile"
        elif key == "storageProfile":
            suggest = "storage_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterGetPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterGetPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterGetPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_definition: 'outputs.ClusterDefinitionResponse',
                 private_endpoint_connections: Sequence['outputs.PrivateEndpointConnectionResponse'],
                 cluster_hdp_version: Optional[str] = None,
                 cluster_id: Optional[str] = None,
                 cluster_state: Optional[str] = None,
                 cluster_version: Optional[str] = None,
                 compute_isolation_properties: Optional['outputs.ComputeIsolationPropertiesResponse'] = None,
                 compute_profile: Optional['outputs.ComputeProfileResponse'] = None,
                 connectivity_endpoints: Optional[Sequence['outputs.ConnectivityEndpointResponse']] = None,
                 created_date: Optional[str] = None,
                 disk_encryption_properties: Optional['outputs.DiskEncryptionPropertiesResponse'] = None,
                 encryption_in_transit_properties: Optional['outputs.EncryptionInTransitPropertiesResponse'] = None,
                 errors: Optional[Sequence['outputs.ErrorsResponse']] = None,
                 excluded_services_config: Optional['outputs.ExcludedServicesConfigResponse'] = None,
                 kafka_rest_properties: Optional['outputs.KafkaRestPropertiesResponse'] = None,
                 min_supported_tls_version: Optional[str] = None,
                 network_properties: Optional['outputs.NetworkPropertiesResponse'] = None,
                 os_type: Optional[str] = None,
                 private_link_configurations: Optional[Sequence['outputs.PrivateLinkConfigurationResponse']] = None,
                 provisioning_state: Optional[str] = None,
                 quota_info: Optional['outputs.QuotaInfoResponse'] = None,
                 security_profile: Optional['outputs.SecurityProfileResponse'] = None,
                 storage_profile: Optional['outputs.StorageProfileResponse'] = None,
                 tier: Optional[str] = None):
        """
        The properties of cluster.
        :param 'ClusterDefinitionResponse' cluster_definition: The cluster definition.
        :param Sequence['PrivateEndpointConnectionResponse'] private_endpoint_connections: The list of private endpoint connections.
        :param str cluster_hdp_version: The hdp version of the cluster.
        :param str cluster_id: The cluster id.
        :param str cluster_state: The state of the cluster.
        :param str cluster_version: The version of the cluster.
        :param 'ComputeIsolationPropertiesResponse' compute_isolation_properties: The compute isolation properties.
        :param 'ComputeProfileResponse' compute_profile: The compute profile.
        :param Sequence['ConnectivityEndpointResponse'] connectivity_endpoints: The list of connectivity endpoints.
        :param str created_date: The date on which the cluster was created.
        :param 'DiskEncryptionPropertiesResponse' disk_encryption_properties: The disk encryption properties.
        :param 'EncryptionInTransitPropertiesResponse' encryption_in_transit_properties: The encryption-in-transit properties.
        :param Sequence['ErrorsResponse'] errors: The list of errors.
        :param 'ExcludedServicesConfigResponse' excluded_services_config: The excluded services config.
        :param 'KafkaRestPropertiesResponse' kafka_rest_properties: The cluster kafka rest proxy configuration.
        :param str min_supported_tls_version: The minimal supported tls version.
        :param 'NetworkPropertiesResponse' network_properties: The network properties.
        :param str os_type: The type of operating system.
        :param Sequence['PrivateLinkConfigurationResponse'] private_link_configurations: The private link configurations.
        :param str provisioning_state: The provisioning state, which only appears in the response.
        :param 'QuotaInfoResponse' quota_info: The quota information.
        :param 'SecurityProfileResponse' security_profile: The security profile.
        :param 'StorageProfileResponse' storage_profile: The storage profile.
        :param str tier: The cluster tier.
        """
        pulumi.set(__self__, "cluster_definition", cluster_definition)
        pulumi.set(__self__, "private_endpoint_connections", private_endpoint_connections)
        if cluster_hdp_version is not None:
            pulumi.set(__self__, "cluster_hdp_version", cluster_hdp_version)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_state is not None:
            pulumi.set(__self__, "cluster_state", cluster_state)
        if cluster_version is not None:
            pulumi.set(__self__, "cluster_version", cluster_version)
        if compute_isolation_properties is not None:
            pulumi.set(__self__, "compute_isolation_properties", compute_isolation_properties)
        if compute_profile is not None:
            pulumi.set(__self__, "compute_profile", compute_profile)
        if connectivity_endpoints is not None:
            pulumi.set(__self__, "connectivity_endpoints", connectivity_endpoints)
        if created_date is not None:
            pulumi.set(__self__, "created_date", created_date)
        if disk_encryption_properties is not None:
            pulumi.set(__self__, "disk_encryption_properties", disk_encryption_properties)
        if encryption_in_transit_properties is not None:
            pulumi.set(__self__, "encryption_in_transit_properties", encryption_in_transit_properties)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if excluded_services_config is not None:
            pulumi.set(__self__, "excluded_services_config", excluded_services_config)
        if kafka_rest_properties is not None:
            pulumi.set(__self__, "kafka_rest_properties", kafka_rest_properties)
        if min_supported_tls_version is not None:
            pulumi.set(__self__, "min_supported_tls_version", min_supported_tls_version)
        if network_properties is not None:
            pulumi.set(__self__, "network_properties", network_properties)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if private_link_configurations is not None:
            pulumi.set(__self__, "private_link_configurations", private_link_configurations)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)
        if quota_info is not None:
            pulumi.set(__self__, "quota_info", quota_info)
        if security_profile is not None:
            pulumi.set(__self__, "security_profile", security_profile)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter(name="clusterDefinition")
    def cluster_definition(self) -> 'outputs.ClusterDefinitionResponse':
        """
        The cluster definition.
        """
        return pulumi.get(self, "cluster_definition")

    @property
    @pulumi.getter(name="privateEndpointConnections")
    def private_endpoint_connections(self) -> Sequence['outputs.PrivateEndpointConnectionResponse']:
        """
        The list of private endpoint connections.
        """
        return pulumi.get(self, "private_endpoint_connections")

    @property
    @pulumi.getter(name="clusterHdpVersion")
    def cluster_hdp_version(self) -> Optional[str]:
        """
        The hdp version of the cluster.
        """
        return pulumi.get(self, "cluster_hdp_version")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        """
        The cluster id.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterState")
    def cluster_state(self) -> Optional[str]:
        """
        The state of the cluster.
        """
        return pulumi.get(self, "cluster_state")

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> Optional[str]:
        """
        The version of the cluster.
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter(name="computeIsolationProperties")
    def compute_isolation_properties(self) -> Optional['outputs.ComputeIsolationPropertiesResponse']:
        """
        The compute isolation properties.
        """
        return pulumi.get(self, "compute_isolation_properties")

    @property
    @pulumi.getter(name="computeProfile")
    def compute_profile(self) -> Optional['outputs.ComputeProfileResponse']:
        """
        The compute profile.
        """
        return pulumi.get(self, "compute_profile")

    @property
    @pulumi.getter(name="connectivityEndpoints")
    def connectivity_endpoints(self) -> Optional[Sequence['outputs.ConnectivityEndpointResponse']]:
        """
        The list of connectivity endpoints.
        """
        return pulumi.get(self, "connectivity_endpoints")

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> Optional[str]:
        """
        The date on which the cluster was created.
        """
        return pulumi.get(self, "created_date")

    @property
    @pulumi.getter(name="diskEncryptionProperties")
    def disk_encryption_properties(self) -> Optional['outputs.DiskEncryptionPropertiesResponse']:
        """
        The disk encryption properties.
        """
        return pulumi.get(self, "disk_encryption_properties")

    @property
    @pulumi.getter(name="encryptionInTransitProperties")
    def encryption_in_transit_properties(self) -> Optional['outputs.EncryptionInTransitPropertiesResponse']:
        """
        The encryption-in-transit properties.
        """
        return pulumi.get(self, "encryption_in_transit_properties")

    @property
    @pulumi.getter
    def errors(self) -> Optional[Sequence['outputs.ErrorsResponse']]:
        """
        The list of errors.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter(name="excludedServicesConfig")
    def excluded_services_config(self) -> Optional['outputs.ExcludedServicesConfigResponse']:
        """
        The excluded services config.
        """
        return pulumi.get(self, "excluded_services_config")

    @property
    @pulumi.getter(name="kafkaRestProperties")
    def kafka_rest_properties(self) -> Optional['outputs.KafkaRestPropertiesResponse']:
        """
        The cluster kafka rest proxy configuration.
        """
        return pulumi.get(self, "kafka_rest_properties")

    @property
    @pulumi.getter(name="minSupportedTlsVersion")
    def min_supported_tls_version(self) -> Optional[str]:
        """
        The minimal supported tls version.
        """
        return pulumi.get(self, "min_supported_tls_version")

    @property
    @pulumi.getter(name="networkProperties")
    def network_properties(self) -> Optional['outputs.NetworkPropertiesResponse']:
        """
        The network properties.
        """
        return pulumi.get(self, "network_properties")

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[str]:
        """
        The type of operating system.
        """
        return pulumi.get(self, "os_type")

    @property
    @pulumi.getter(name="privateLinkConfigurations")
    def private_link_configurations(self) -> Optional[Sequence['outputs.PrivateLinkConfigurationResponse']]:
        """
        The private link configurations.
        """
        return pulumi.get(self, "private_link_configurations")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioning state, which only appears in the response.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="quotaInfo")
    def quota_info(self) -> Optional['outputs.QuotaInfoResponse']:
        """
        The quota information.
        """
        return pulumi.get(self, "quota_info")

    @property
    @pulumi.getter(name="securityProfile")
    def security_profile(self) -> Optional['outputs.SecurityProfileResponse']:
        """
        The security profile.
        """
        return pulumi.get(self, "security_profile")

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional['outputs.StorageProfileResponse']:
        """
        The storage profile.
        """
        return pulumi.get(self, "storage_profile")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        The cluster tier.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class ClusterIdentityResponse(dict):
    """
    Identity for the cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Identity for the cluster.
        :param str principal_id: The principal id of cluster identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant id associated with the cluster. This property will only be provided for a system assigned identity.
        :param str type: The type of identity used for the cluster. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities.
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The list of user identities associated with the cluster. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal id of cluster identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant id associated with the cluster. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of identity used for the cluster. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The list of user identities associated with the cluster. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class ClusterLogAnalyticsApplicationLogsResponse(dict):
    """
    Collection of logs to be enabled or disabled for log analytics.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stdErrorEnabled":
            suggest = "std_error_enabled"
        elif key == "stdOutEnabled":
            suggest = "std_out_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterLogAnalyticsApplicationLogsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterLogAnalyticsApplicationLogsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterLogAnalyticsApplicationLogsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 std_error_enabled: Optional[bool] = None,
                 std_out_enabled: Optional[bool] = None):
        """
        Collection of logs to be enabled or disabled for log analytics.
        :param bool std_error_enabled: True if stderror is enabled, otherwise false.
        :param bool std_out_enabled: True if stdout is enabled, otherwise false.
        """
        if std_error_enabled is not None:
            pulumi.set(__self__, "std_error_enabled", std_error_enabled)
        if std_out_enabled is not None:
            pulumi.set(__self__, "std_out_enabled", std_out_enabled)

    @property
    @pulumi.getter(name="stdErrorEnabled")
    def std_error_enabled(self) -> Optional[bool]:
        """
        True if stderror is enabled, otherwise false.
        """
        return pulumi.get(self, "std_error_enabled")

    @property
    @pulumi.getter(name="stdOutEnabled")
    def std_out_enabled(self) -> Optional[bool]:
        """
        True if stdout is enabled, otherwise false.
        """
        return pulumi.get(self, "std_out_enabled")


@pulumi.output_type
class ClusterLogAnalyticsProfileResponse(dict):
    """
    Cluster log analytics profile to enable or disable OMS agent for cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationLogs":
            suggest = "application_logs"
        elif key == "metricsEnabled":
            suggest = "metrics_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterLogAnalyticsProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterLogAnalyticsProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterLogAnalyticsProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 application_logs: Optional['outputs.ClusterLogAnalyticsApplicationLogsResponse'] = None,
                 metrics_enabled: Optional[bool] = None):
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        :param bool enabled: True if log analytics is enabled for the cluster, otherwise false.
        :param 'ClusterLogAnalyticsApplicationLogsResponse' application_logs: Collection of logs to be enabled or disabled for log analytics.
        :param bool metrics_enabled: True if metrics are enabled, otherwise false.
        """
        pulumi.set(__self__, "enabled", enabled)
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if metrics_enabled is not None:
            pulumi.set(__self__, "metrics_enabled", metrics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if log analytics is enabled for the cluster, otherwise false.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional['outputs.ClusterLogAnalyticsApplicationLogsResponse']:
        """
        Collection of logs to be enabled or disabled for log analytics.
        """
        return pulumi.get(self, "application_logs")

    @property
    @pulumi.getter(name="metricsEnabled")
    def metrics_enabled(self) -> Optional[bool]:
        """
        True if metrics are enabled, otherwise false.
        """
        return pulumi.get(self, "metrics_enabled")


@pulumi.output_type
class ClusterPoolComputeProfileResponse(dict):
    """
    The compute profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZones":
            suggest = "availability_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPoolComputeProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPoolComputeProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPoolComputeProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nodes: Sequence['outputs.NodeProfileResponse'],
                 availability_zones: Optional[Sequence[str]] = None):
        """
        The compute profile.
        :param Sequence['NodeProfileResponse'] nodes: The nodes definitions.
        :param Sequence[str] availability_zones: The list of Availability zones to use for AKS VMSS nodes.
        """
        pulumi.set(__self__, "nodes", nodes)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)

    @property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.NodeProfileResponse']:
        """
        The nodes definitions.
        """
        return pulumi.get(self, "nodes")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        """
        The list of Availability zones to use for AKS VMSS nodes.
        """
        return pulumi.get(self, "availability_zones")


@pulumi.output_type
class ClusterPoolResourcePropertiesResponseAksClusterProfile(dict):
    """
    Properties of underlying AKS cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aksVersion":
            suggest = "aks_version"
        elif key == "aksClusterAgentPoolIdentityProfile":
            suggest = "aks_cluster_agent_pool_identity_profile"
        elif key == "aksClusterResourceId":
            suggest = "aks_cluster_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPoolResourcePropertiesResponseAksClusterProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPoolResourcePropertiesResponseAksClusterProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPoolResourcePropertiesResponseAksClusterProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aks_version: str,
                 aks_cluster_agent_pool_identity_profile: Optional['outputs.AksClusterProfileResponseAksClusterAgentPoolIdentityProfile'] = None,
                 aks_cluster_resource_id: Optional[str] = None):
        """
        Properties of underlying AKS cluster.
        :param str aks_version: AKS control plane and default node pool version of this ClusterPool
        :param 'AksClusterProfileResponseAksClusterAgentPoolIdentityProfile' aks_cluster_agent_pool_identity_profile: Identity properties of the AKS cluster agentpool MSI
        :param str aks_cluster_resource_id: ARM Resource ID of the AKS cluster
        """
        pulumi.set(__self__, "aks_version", aks_version)
        if aks_cluster_agent_pool_identity_profile is not None:
            pulumi.set(__self__, "aks_cluster_agent_pool_identity_profile", aks_cluster_agent_pool_identity_profile)
        if aks_cluster_resource_id is not None:
            pulumi.set(__self__, "aks_cluster_resource_id", aks_cluster_resource_id)

    @property
    @pulumi.getter(name="aksVersion")
    def aks_version(self) -> str:
        """
        AKS control plane and default node pool version of this ClusterPool
        """
        return pulumi.get(self, "aks_version")

    @property
    @pulumi.getter(name="aksClusterAgentPoolIdentityProfile")
    def aks_cluster_agent_pool_identity_profile(self) -> Optional['outputs.AksClusterProfileResponseAksClusterAgentPoolIdentityProfile']:
        """
        Identity properties of the AKS cluster agentpool MSI
        """
        return pulumi.get(self, "aks_cluster_agent_pool_identity_profile")

    @property
    @pulumi.getter(name="aksClusterResourceId")
    def aks_cluster_resource_id(self) -> Optional[str]:
        """
        ARM Resource ID of the AKS cluster
        """
        return pulumi.get(self, "aks_cluster_resource_id")


@pulumi.output_type
class ClusterPoolResourcePropertiesResponseClusterPoolProfile(dict):
    """
    CLuster pool profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterPoolVersion":
            suggest = "cluster_pool_version"
        elif key == "publicIpTag":
            suggest = "public_ip_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPoolResourcePropertiesResponseClusterPoolProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPoolResourcePropertiesResponseClusterPoolProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPoolResourcePropertiesResponseClusterPoolProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_pool_version: str,
                 public_ip_tag: Optional['outputs.IpTagResponse'] = None):
        """
        CLuster pool profile.
        :param str cluster_pool_version: Cluster pool version is a 2-part version.
        :param 'IpTagResponse' public_ip_tag: Gets or sets the IP tag for the public IPs created along with the HDInsightOnAks ClusterPools and Clusters. 
        """
        pulumi.set(__self__, "cluster_pool_version", cluster_pool_version)
        if public_ip_tag is not None:
            pulumi.set(__self__, "public_ip_tag", public_ip_tag)

    @property
    @pulumi.getter(name="clusterPoolVersion")
    def cluster_pool_version(self) -> str:
        """
        Cluster pool version is a 2-part version.
        """
        return pulumi.get(self, "cluster_pool_version")

    @property
    @pulumi.getter(name="publicIpTag")
    def public_ip_tag(self) -> Optional['outputs.IpTagResponse']:
        """
        Gets or sets the IP tag for the public IPs created along with the HDInsightOnAks ClusterPools and Clusters. 
        """
        return pulumi.get(self, "public_ip_tag")


@pulumi.output_type
class ClusterPoolResourcePropertiesResponseComputeProfile(dict):
    """
    CLuster pool compute profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"
        elif key == "availabilityZones":
            suggest = "availability_zones"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPoolResourcePropertiesResponseComputeProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPoolResourcePropertiesResponseComputeProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPoolResourcePropertiesResponseComputeProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 vm_size: str,
                 availability_zones: Optional[Sequence[str]] = None):
        """
        CLuster pool compute profile.
        :param int count: The number of virtual machines.
        :param str vm_size: The virtual machine SKU.
        :param Sequence[str] availability_zones: The list of Availability zones to use for AKS VMSS nodes.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "vm_size", vm_size)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of virtual machines.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The virtual machine SKU.
        """
        return pulumi.get(self, "vm_size")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        """
        The list of Availability zones to use for AKS VMSS nodes.
        """
        return pulumi.get(self, "availability_zones")


@pulumi.output_type
class ClusterPoolResourcePropertiesResponseLogAnalyticsProfile(dict):
    """
    Cluster pool log analytics profile to enable OMS agent for AKS cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceId":
            suggest = "workspace_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPoolResourcePropertiesResponseLogAnalyticsProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPoolResourcePropertiesResponseLogAnalyticsProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPoolResourcePropertiesResponseLogAnalyticsProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 workspace_id: Optional[str] = None):
        """
        Cluster pool log analytics profile to enable OMS agent for AKS cluster.
        :param bool enabled: True if log analytics is enabled for cluster pool, otherwise false.
        :param str workspace_id: Log analytics workspace to associate with the OMS agent.
        """
        pulumi.set(__self__, "enabled", enabled)
        if workspace_id is not None:
            pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if log analytics is enabled for cluster pool, otherwise false.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> Optional[str]:
        """
        Log analytics workspace to associate with the OMS agent.
        """
        return pulumi.get(self, "workspace_id")


@pulumi.output_type
class ClusterPoolResourcePropertiesResponseNetworkProfile(dict):
    """
    Cluster pool network profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "apiServerAuthorizedIpRanges":
            suggest = "api_server_authorized_ip_ranges"
        elif key == "enablePrivateApiServer":
            suggest = "enable_private_api_server"
        elif key == "outboundType":
            suggest = "outbound_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPoolResourcePropertiesResponseNetworkProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPoolResourcePropertiesResponseNetworkProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPoolResourcePropertiesResponseNetworkProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: str,
                 api_server_authorized_ip_ranges: Optional[Sequence[str]] = None,
                 enable_private_api_server: Optional[bool] = None,
                 outbound_type: Optional[str] = None):
        """
        Cluster pool network profile.
        :param str subnet_id: Cluster pool subnet resource id.
        :param Sequence[str] api_server_authorized_ip_ranges: IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with private AKS clusters. So you cannot set enablePrivateApiServer to true and apiServerAuthorizedIpRanges at the same time. Currently, this property is not supported and please don't use it.
        :param bool enable_private_api_server: ClusterPool is based on AKS cluster. AKS cluster exposes the API server to public internet by default. If you set this property to true, a private AKS cluster will be created, and it will use private apiserver, which is not exposed to public internet.
        :param str outbound_type: This can only be set at cluster pool creation time and cannot be changed later. 
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if api_server_authorized_ip_ranges is not None:
            pulumi.set(__self__, "api_server_authorized_ip_ranges", api_server_authorized_ip_ranges)
        if enable_private_api_server is not None:
            pulumi.set(__self__, "enable_private_api_server", enable_private_api_server)
        if outbound_type is None:
            outbound_type = 'loadBalancer'
        if outbound_type is not None:
            pulumi.set(__self__, "outbound_type", outbound_type)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        """
        Cluster pool subnet resource id.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="apiServerAuthorizedIpRanges")
    def api_server_authorized_ip_ranges(self) -> Optional[Sequence[str]]:
        """
        IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with private AKS clusters. So you cannot set enablePrivateApiServer to true and apiServerAuthorizedIpRanges at the same time. Currently, this property is not supported and please don't use it.
        """
        return pulumi.get(self, "api_server_authorized_ip_ranges")

    @property
    @pulumi.getter(name="enablePrivateApiServer")
    def enable_private_api_server(self) -> Optional[bool]:
        """
        ClusterPool is based on AKS cluster. AKS cluster exposes the API server to public internet by default. If you set this property to true, a private AKS cluster will be created, and it will use private apiserver, which is not exposed to public internet.
        """
        return pulumi.get(self, "enable_private_api_server")

    @property
    @pulumi.getter(name="outboundType")
    def outbound_type(self) -> Optional[str]:
        """
        This can only be set at cluster pool creation time and cannot be changed later. 
        """
        return pulumi.get(self, "outbound_type")


@pulumi.output_type
class ClusterPoolSshProfileResponse(dict):
    """
    Ssh profile for the cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podPrefix":
            suggest = "pod_prefix"
        elif key == "vmSize":
            suggest = "vm_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPoolSshProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPoolSshProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPoolSshProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 pod_prefix: str,
                 vm_size: Optional[str] = None):
        """
        Ssh profile for the cluster.
        :param int count: Number of ssh pods per cluster.
        :param str pod_prefix: Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at <clusterFqdn>/<sshBasePath>/<prefix>-<number>
        :param str vm_size: The virtual machine SKU.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "pod_prefix", pod_prefix)
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        Number of ssh pods per cluster.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="podPrefix")
    def pod_prefix(self) -> str:
        """
        Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at <clusterFqdn>/<sshBasePath>/<prefix>-<number>
        """
        return pulumi.get(self, "pod_prefix")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[str]:
        """
        The virtual machine SKU.
        """
        return pulumi.get(self, "vm_size")


@pulumi.output_type
class ClusterProfileResponse(dict):
    """
    Cluster profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationProfile":
            suggest = "authorization_profile"
        elif key == "clusterVersion":
            suggest = "cluster_version"
        elif key == "connectivityProfile":
            suggest = "connectivity_profile"
        elif key == "ossVersion":
            suggest = "oss_version"
        elif key == "autoscaleProfile":
            suggest = "autoscale_profile"
        elif key == "clusterAccessProfile":
            suggest = "cluster_access_profile"
        elif key == "flinkProfile":
            suggest = "flink_profile"
        elif key == "identityProfile":
            suggest = "identity_profile"
        elif key == "kafkaProfile":
            suggest = "kafka_profile"
        elif key == "llapProfile":
            suggest = "llap_profile"
        elif key == "logAnalyticsProfile":
            suggest = "log_analytics_profile"
        elif key == "managedIdentityProfile":
            suggest = "managed_identity_profile"
        elif key == "prometheusProfile":
            suggest = "prometheus_profile"
        elif key == "rangerPluginProfile":
            suggest = "ranger_plugin_profile"
        elif key == "rangerProfile":
            suggest = "ranger_profile"
        elif key == "scriptActionProfiles":
            suggest = "script_action_profiles"
        elif key == "secretsProfile":
            suggest = "secrets_profile"
        elif key == "serviceConfigsProfiles":
            suggest = "service_configs_profiles"
        elif key == "sparkProfile":
            suggest = "spark_profile"
        elif key == "sshProfile":
            suggest = "ssh_profile"
        elif key == "stubProfile":
            suggest = "stub_profile"
        elif key == "trinoProfile":
            suggest = "trino_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_profile: 'outputs.AuthorizationProfileResponse',
                 cluster_version: str,
                 components: Sequence['outputs.ClusterProfileResponseComponents'],
                 connectivity_profile: 'outputs.ConnectivityProfileResponse',
                 oss_version: str,
                 autoscale_profile: Optional['outputs.AutoscaleProfileResponse'] = None,
                 cluster_access_profile: Optional['outputs.ClusterAccessProfileResponse'] = None,
                 flink_profile: Optional['outputs.FlinkProfileResponse'] = None,
                 identity_profile: Optional['outputs.IdentityProfileResponse'] = None,
                 kafka_profile: Optional['outputs.KafkaProfileResponse'] = None,
                 llap_profile: Optional[Any] = None,
                 log_analytics_profile: Optional['outputs.ClusterLogAnalyticsProfileResponse'] = None,
                 managed_identity_profile: Optional['outputs.ManagedIdentityProfileResponse'] = None,
                 prometheus_profile: Optional['outputs.ClusterPrometheusProfileResponse'] = None,
                 ranger_plugin_profile: Optional['outputs.ClusterRangerPluginProfileResponse'] = None,
                 ranger_profile: Optional['outputs.RangerProfileResponse'] = None,
                 script_action_profiles: Optional[Sequence['outputs.ScriptActionProfileResponse']] = None,
                 secrets_profile: Optional['outputs.SecretsProfileResponse'] = None,
                 service_configs_profiles: Optional[Sequence['outputs.ClusterServiceConfigsProfileResponse']] = None,
                 spark_profile: Optional['outputs.SparkProfileResponse'] = None,
                 ssh_profile: Optional['outputs.ClusterPoolSshProfileResponse'] = None,
                 stub_profile: Optional[Any] = None,
                 trino_profile: Optional['outputs.TrinoProfileResponse'] = None):
        """
        Cluster profile.
        :param 'AuthorizationProfileResponse' authorization_profile: Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        :param str cluster_version: Version with 3/4 part.
        :param Sequence['ClusterProfileResponseComponents'] components: Component list of this cluster type and version.
        :param 'ConnectivityProfileResponse' connectivity_profile: Cluster connectivity profile.
        :param str oss_version: Version with three part.
        :param 'AutoscaleProfileResponse' autoscale_profile: This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        :param 'ClusterAccessProfileResponse' cluster_access_profile: Cluster access profile.
        :param 'FlinkProfileResponse' flink_profile: The Flink cluster profile.
        :param 'IdentityProfileResponse' identity_profile: This is deprecated. Please use managed identity profile instead.
        :param 'KafkaProfileResponse' kafka_profile: The Kafka cluster profile.
        :param Any llap_profile: LLAP cluster profile.
        :param 'ClusterLogAnalyticsProfileResponse' log_analytics_profile: Cluster log analytics profile to enable or disable OMS agent for cluster.
        :param 'ManagedIdentityProfileResponse' managed_identity_profile: This property is required by Trino, Spark and Flink cluster but is optional for Kafka cluster.
        :param 'ClusterPrometheusProfileResponse' prometheus_profile: Cluster Prometheus profile.
        :param 'ClusterRangerPluginProfileResponse' ranger_plugin_profile: Cluster Ranger plugin profile.
        :param 'RangerProfileResponse' ranger_profile: The ranger cluster profile.
        :param Sequence['ScriptActionProfileResponse'] script_action_profiles: The script action profile list.
        :param 'SecretsProfileResponse' secrets_profile: The cluster secret profile.
        :param Sequence['ClusterServiceConfigsProfileResponse'] service_configs_profiles: The service configs profiles.
        :param 'SparkProfileResponse' spark_profile: The spark cluster profile.
        :param 'ClusterPoolSshProfileResponse' ssh_profile: Ssh profile for the cluster.
        :param Any stub_profile: Stub cluster profile.
        :param 'TrinoProfileResponse' trino_profile: Trino Cluster profile.
        """
        pulumi.set(__self__, "authorization_profile", authorization_profile)
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "components", components)
        pulumi.set(__self__, "connectivity_profile", connectivity_profile)
        pulumi.set(__self__, "oss_version", oss_version)
        if autoscale_profile is not None:
            pulumi.set(__self__, "autoscale_profile", autoscale_profile)
        if cluster_access_profile is not None:
            pulumi.set(__self__, "cluster_access_profile", cluster_access_profile)
        if flink_profile is not None:
            pulumi.set(__self__, "flink_profile", flink_profile)
        if identity_profile is not None:
            pulumi.set(__self__, "identity_profile", identity_profile)
        if kafka_profile is not None:
            pulumi.set(__self__, "kafka_profile", kafka_profile)
        if llap_profile is not None:
            pulumi.set(__self__, "llap_profile", llap_profile)
        if log_analytics_profile is not None:
            pulumi.set(__self__, "log_analytics_profile", log_analytics_profile)
        if managed_identity_profile is not None:
            pulumi.set(__self__, "managed_identity_profile", managed_identity_profile)
        if prometheus_profile is not None:
            pulumi.set(__self__, "prometheus_profile", prometheus_profile)
        if ranger_plugin_profile is not None:
            pulumi.set(__self__, "ranger_plugin_profile", ranger_plugin_profile)
        if ranger_profile is not None:
            pulumi.set(__self__, "ranger_profile", ranger_profile)
        if script_action_profiles is not None:
            pulumi.set(__self__, "script_action_profiles", script_action_profiles)
        if secrets_profile is not None:
            pulumi.set(__self__, "secrets_profile", secrets_profile)
        if service_configs_profiles is not None:
            pulumi.set(__self__, "service_configs_profiles", service_configs_profiles)
        if spark_profile is not None:
            pulumi.set(__self__, "spark_profile", spark_profile)
        if ssh_profile is not None:
            pulumi.set(__self__, "ssh_profile", ssh_profile)
        if stub_profile is not None:
            pulumi.set(__self__, "stub_profile", stub_profile)
        if trino_profile is not None:
            pulumi.set(__self__, "trino_profile", trino_profile)

    @property
    @pulumi.getter(name="authorizationProfile")
    def authorization_profile(self) -> 'outputs.AuthorizationProfileResponse':
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        """
        return pulumi.get(self, "authorization_profile")

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> str:
        """
        Version with 3/4 part.
        """
        return pulumi.get(self, "cluster_version")

    @property
    @pulumi.getter
    def components(self) -> Sequence['outputs.ClusterProfileResponseComponents']:
        """
        Component list of this cluster type and version.
        """
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="connectivityProfile")
    def connectivity_profile(self) -> 'outputs.ConnectivityProfileResponse':
        """
        Cluster connectivity profile.
        """
        return pulumi.get(self, "connectivity_profile")

    @property
    @pulumi.getter(name="ossVersion")
    def oss_version(self) -> str:
        """
        Version with three part.
        """
        return pulumi.get(self, "oss_version")

    @property
    @pulumi.getter(name="autoscaleProfile")
    def autoscale_profile(self) -> Optional['outputs.AutoscaleProfileResponse']:
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        """
        return pulumi.get(self, "autoscale_profile")

    @property
    @pulumi.getter(name="clusterAccessProfile")
    def cluster_access_profile(self) -> Optional['outputs.ClusterAccessProfileResponse']:
        """
        Cluster access profile.
        """
        return pulumi.get(self, "cluster_access_profile")

    @property
    @pulumi.getter(name="flinkProfile")
    def flink_profile(self) -> Optional['outputs.FlinkProfileResponse']:
        """
        The Flink cluster profile.
        """
        return pulumi.get(self, "flink_profile")

    @property
    @pulumi.getter(name="identityProfile")
    def identity_profile(self) -> Optional['outputs.IdentityProfileResponse']:
        """
        This is deprecated. Please use managed identity profile instead.
        """
        return pulumi.get(self, "identity_profile")

    @property
    @pulumi.getter(name="kafkaProfile")
    def kafka_profile(self) -> Optional['outputs.KafkaProfileResponse']:
        """
        The Kafka cluster profile.
        """
        return pulumi.get(self, "kafka_profile")

    @property
    @pulumi.getter(name="llapProfile")
    def llap_profile(self) -> Optional[Any]:
        """
        LLAP cluster profile.
        """
        return pulumi.get(self, "llap_profile")

    @property
    @pulumi.getter(name="logAnalyticsProfile")
    def log_analytics_profile(self) -> Optional['outputs.ClusterLogAnalyticsProfileResponse']:
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        """
        return pulumi.get(self, "log_analytics_profile")

    @property
    @pulumi.getter(name="managedIdentityProfile")
    def managed_identity_profile(self) -> Optional['outputs.ManagedIdentityProfileResponse']:
        """
        This property is required by Trino, Spark and Flink cluster but is optional for Kafka cluster.
        """
        return pulumi.get(self, "managed_identity_profile")

    @property
    @pulumi.getter(name="prometheusProfile")
    def prometheus_profile(self) -> Optional['outputs.ClusterPrometheusProfileResponse']:
        """
        Cluster Prometheus profile.
        """
        return pulumi.get(self, "prometheus_profile")

    @property
    @pulumi.getter(name="rangerPluginProfile")
    def ranger_plugin_profile(self) -> Optional['outputs.ClusterRangerPluginProfileResponse']:
        """
        Cluster Ranger plugin profile.
        """
        return pulumi.get(self, "ranger_plugin_profile")

    @property
    @pulumi.getter(name="rangerProfile")
    def ranger_profile(self) -> Optional['outputs.RangerProfileResponse']:
        """
        The ranger cluster profile.
        """
        return pulumi.get(self, "ranger_profile")

    @property
    @pulumi.getter(name="scriptActionProfiles")
    def script_action_profiles(self) -> Optional[Sequence['outputs.ScriptActionProfileResponse']]:
        """
        The script action profile list.
        """
        return pulumi.get(self, "script_action_profiles")

    @property
    @pulumi.getter(name="secretsProfile")
    def secrets_profile(self) -> Optional['outputs.SecretsProfileResponse']:
        """
        The cluster secret profile.
        """
        return pulumi.get(self, "secrets_profile")

    @property
    @pulumi.getter(name="serviceConfigsProfiles")
    def service_configs_profiles(self) -> Optional[Sequence['outputs.ClusterServiceConfigsProfileResponse']]:
        """
        The service configs profiles.
        """
        return pulumi.get(self, "service_configs_profiles")

    @property
    @pulumi.getter(name="sparkProfile")
    def spark_profile(self) -> Optional['outputs.SparkProfileResponse']:
        """
        The spark cluster profile.
        """
        return pulumi.get(self, "spark_profile")

    @property
    @pulumi.getter(name="sshProfile")
    def ssh_profile(self) -> Optional['outputs.ClusterPoolSshProfileResponse']:
        """
        Ssh profile for the cluster.
        """
        return pulumi.get(self, "ssh_profile")

    @property
    @pulumi.getter(name="stubProfile")
    def stub_profile(self) -> Optional[Any]:
        """
        Stub cluster profile.
        """
        return pulumi.get(self, "stub_profile")

    @property
    @pulumi.getter(name="trinoProfile")
    def trino_profile(self) -> Optional['outputs.TrinoProfileResponse']:
        """
        Trino Cluster profile.
        """
        return pulumi.get(self, "trino_profile")


@pulumi.output_type
class ClusterProfileResponseComponents(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterPrometheusProfileResponse(dict):
    """
    Cluster Prometheus profile.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Cluster Prometheus profile.
        :param bool enabled: Enable Prometheus for cluster or not.
        """
        if enabled is None:
            enabled = False
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable Prometheus for cluster or not.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterRangerPluginProfileResponse(dict):
    """
    Cluster Ranger plugin profile.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Cluster Ranger plugin profile.
        :param bool enabled: Enable Ranger for cluster or not.
        """
        if enabled is None:
            enabled = False
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable Ranger for cluster or not.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterServiceConfigResponse(dict):
    """
    Cluster configs per component.
    """
    def __init__(__self__, *,
                 component: str,
                 files: Sequence['outputs.ClusterConfigFileResponse']):
        """
        Cluster configs per component.
        :param str component: Name of the component the config files should apply to.
        :param Sequence['ClusterConfigFileResponse'] files: List of Config Files.
        """
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def component(self) -> str:
        """
        Name of the component the config files should apply to.
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def files(self) -> Sequence['outputs.ClusterConfigFileResponse']:
        """
        List of Config Files.
        """
        return pulumi.get(self, "files")


@pulumi.output_type
class ClusterServiceConfigsProfileResponse(dict):
    """
    Cluster service configs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterServiceConfigsProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterServiceConfigsProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterServiceConfigsProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configs: Sequence['outputs.ClusterServiceConfigResponse'],
                 service_name: str):
        """
        Cluster service configs.
        :param Sequence['ClusterServiceConfigResponse'] configs: List of service configs.
        :param str service_name: Name of the service the configurations should apply to.
        """
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.ClusterServiceConfigResponse']:
        """
        List of service configs.
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        Name of the service the configurations should apply to.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class ComparisonRuleResponse(dict):
    """
    The comparison rule.
    """
    def __init__(__self__, *,
                 operator: str,
                 threshold: float):
        """
        The comparison rule.
        :param str operator: The comparison operator.
        :param float threshold: Threshold setting.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The comparison operator.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold setting.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class ComputeIsolationPropertiesResponse(dict):
    """
    The compute isolation properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableComputeIsolation":
            suggest = "enable_compute_isolation"
        elif key == "hostSku":
            suggest = "host_sku"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeIsolationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeIsolationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeIsolationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_compute_isolation: Optional[bool] = None,
                 host_sku: Optional[str] = None):
        """
        The compute isolation properties.
        :param bool enable_compute_isolation: The flag indicates whether enable compute isolation or not.
        :param str host_sku: The host sku.
        """
        if enable_compute_isolation is None:
            enable_compute_isolation = False
        if enable_compute_isolation is not None:
            pulumi.set(__self__, "enable_compute_isolation", enable_compute_isolation)
        if host_sku is not None:
            pulumi.set(__self__, "host_sku", host_sku)

    @property
    @pulumi.getter(name="enableComputeIsolation")
    def enable_compute_isolation(self) -> Optional[bool]:
        """
        The flag indicates whether enable compute isolation or not.
        """
        return pulumi.get(self, "enable_compute_isolation")

    @property
    @pulumi.getter(name="hostSku")
    def host_sku(self) -> Optional[str]:
        """
        The host sku.
        """
        return pulumi.get(self, "host_sku")


@pulumi.output_type
class ComputeProfileResponse(dict):
    """
    Describes the compute profile.
    """
    def __init__(__self__, *,
                 roles: Optional[Sequence['outputs.RoleResponse']] = None):
        """
        Describes the compute profile.
        :param Sequence['RoleResponse'] roles: The list of roles in the cluster.
        """
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence['outputs.RoleResponse']]:
        """
        The list of roles in the cluster.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class ComputeResourceDefinitionResponse(dict):
    """
    The cpu and memory requirement definition.
    """
    def __init__(__self__, *,
                 cpu: float,
                 memory: float):
        """
        The cpu and memory requirement definition.
        :param float cpu: The required CPU.
        :param float memory: The required memory in MB, Container memory will be 110 percentile
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> float:
        """
        The required CPU.
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> float:
        """
        The required memory in MB, Container memory will be 110 percentile
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ConnectivityEndpointResponse(dict):
    """
    The connectivity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIPAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectivityEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectivityEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectivityEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 private_ip_address: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        The connectivity properties
        :param str location: The location of the endpoint.
        :param str name: The name of the endpoint.
        :param int port: The port to connect to.
        :param str private_ip_address: The private ip address of the endpoint.
        :param str protocol: The protocol of the endpoint.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The location of the endpoint.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the endpoint.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to connect to.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private ip address of the endpoint.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol of the endpoint.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class ConnectivityProfileResponse(dict):
    """
    Cluster connectivity profile.
    """
    def __init__(__self__, *,
                 web: 'outputs.ConnectivityProfileResponseWeb',
                 ssh: Optional[Sequence['outputs.SshConnectivityEndpointResponse']] = None):
        """
        Cluster connectivity profile.
        :param 'ConnectivityProfileResponseWeb' web: Web connectivity endpoint details.
        :param Sequence['SshConnectivityEndpointResponse'] ssh: List of SSH connectivity endpoints.
        """
        pulumi.set(__self__, "web", web)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def web(self) -> 'outputs.ConnectivityProfileResponseWeb':
        """
        Web connectivity endpoint details.
        """
        return pulumi.get(self, "web")

    @property
    @pulumi.getter
    def ssh(self) -> Optional[Sequence['outputs.SshConnectivityEndpointResponse']]:
        """
        List of SSH connectivity endpoints.
        """
        return pulumi.get(self, "ssh")


@pulumi.output_type
class ConnectivityProfileResponseWeb(dict):
    """
    Web connectivity endpoint details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateFqdn":
            suggest = "private_fqdn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectivityProfileResponseWeb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectivityProfileResponseWeb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectivityProfileResponseWeb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: str,
                 private_fqdn: Optional[str] = None):
        """
        Web connectivity endpoint details.
        :param str fqdn: Web connectivity endpoint.
        :param str private_fqdn: Private web connectivity endpoint. This property will only be returned when enableInternalIngress is true.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if private_fqdn is not None:
            pulumi.set(__self__, "private_fqdn", private_fqdn)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        """
        Web connectivity endpoint.
        """
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter(name="privateFqdn")
    def private_fqdn(self) -> Optional[str]:
        """
        Private web connectivity endpoint. This property will only be returned when enableInternalIngress is true.
        """
        return pulumi.get(self, "private_fqdn")


@pulumi.output_type
class DataDisksGroupsResponse(dict):
    """
    The data disks groups for the role.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeGB":
            suggest = "disk_size_gb"
        elif key == "storageAccountType":
            suggest = "storage_account_type"
        elif key == "disksPerNode":
            suggest = "disks_per_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataDisksGroupsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataDisksGroupsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataDisksGroupsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_gb: int,
                 storage_account_type: str,
                 disks_per_node: Optional[int] = None):
        """
        The data disks groups for the role.
        :param int disk_size_gb: ReadOnly. The DiskSize in GB. Do not set this value.
        :param str storage_account_type: ReadOnly. The storage account type. Do not set this value.
        :param int disks_per_node: The number of disks per node.
        """
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "storage_account_type", storage_account_type)
        if disks_per_node is not None:
            pulumi.set(__self__, "disks_per_node", disks_per_node)

    @property
    @pulumi.getter(name="diskSizeGB")
    def disk_size_gb(self) -> int:
        """
        ReadOnly. The DiskSize in GB. Do not set this value.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="storageAccountType")
    def storage_account_type(self) -> str:
        """
        ReadOnly. The storage account type. Do not set this value.
        """
        return pulumi.get(self, "storage_account_type")

    @property
    @pulumi.getter(name="disksPerNode")
    def disks_per_node(self) -> Optional[int]:
        """
        The number of disks per node.
        """
        return pulumi.get(self, "disks_per_node")


@pulumi.output_type
class DiskEncryptionPropertiesResponse(dict):
    """
    The disk encryption properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionAlgorithm":
            suggest = "encryption_algorithm"
        elif key == "encryptionAtHost":
            suggest = "encryption_at_host"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "keyVersion":
            suggest = "key_version"
        elif key == "msiResourceId":
            suggest = "msi_resource_id"
        elif key == "vaultUri":
            suggest = "vault_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskEncryptionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskEncryptionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskEncryptionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_algorithm: Optional[str] = None,
                 encryption_at_host: Optional[bool] = None,
                 key_name: Optional[str] = None,
                 key_version: Optional[str] = None,
                 msi_resource_id: Optional[str] = None,
                 vault_uri: Optional[str] = None):
        """
        The disk encryption properties
        :param str encryption_algorithm: Algorithm identifier for encryption, default RSA-OAEP.
        :param bool encryption_at_host: Indicates whether or not resource disk encryption is enabled.
        :param str key_name: Key name that is used for enabling disk encryption.
        :param str key_version: Specific key version that is used for enabling disk encryption.
        :param str msi_resource_id: Resource ID of Managed Identity that is used to access the key vault.
        :param str vault_uri: Base key vault URI where the customers key is located eg. https://myvault.vault.azure.net
        """
        if encryption_algorithm is not None:
            pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)
        if encryption_at_host is None:
            encryption_at_host = False
        if encryption_at_host is not None:
            pulumi.set(__self__, "encryption_at_host", encryption_at_host)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if key_version is not None:
            pulumi.set(__self__, "key_version", key_version)
        if msi_resource_id is not None:
            pulumi.set(__self__, "msi_resource_id", msi_resource_id)
        if vault_uri is not None:
            pulumi.set(__self__, "vault_uri", vault_uri)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[str]:
        """
        Algorithm identifier for encryption, default RSA-OAEP.
        """
        return pulumi.get(self, "encryption_algorithm")

    @property
    @pulumi.getter(name="encryptionAtHost")
    def encryption_at_host(self) -> Optional[bool]:
        """
        Indicates whether or not resource disk encryption is enabled.
        """
        return pulumi.get(self, "encryption_at_host")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[str]:
        """
        Key name that is used for enabling disk encryption.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> Optional[str]:
        """
        Specific key version that is used for enabling disk encryption.
        """
        return pulumi.get(self, "key_version")

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> Optional[str]:
        """
        Resource ID of Managed Identity that is used to access the key vault.
        """
        return pulumi.get(self, "msi_resource_id")

    @property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> Optional[str]:
        """
        Base key vault URI where the customers key is located eg. https://myvault.vault.azure.net
        """
        return pulumi.get(self, "vault_uri")


@pulumi.output_type
class DiskStorageProfileResponse(dict):
    """
    Kafka disk storage profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDiskSize":
            suggest = "data_disk_size"
        elif key == "dataDiskType":
            suggest = "data_disk_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskStorageProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskStorageProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskStorageProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_disk_size: int,
                 data_disk_type: str):
        """
        Kafka disk storage profile.
        :param int data_disk_size: Managed Disk size in GB. The maximum supported disk size for Standard and Premium HDD/SSD is 32TB, except for Premium SSD v2, which supports up to 64TB.
        :param str data_disk_type: Managed Disk Type.
        """
        pulumi.set(__self__, "data_disk_size", data_disk_size)
        pulumi.set(__self__, "data_disk_type", data_disk_type)

    @property
    @pulumi.getter(name="dataDiskSize")
    def data_disk_size(self) -> int:
        """
        Managed Disk size in GB. The maximum supported disk size for Standard and Premium HDD/SSD is 32TB, except for Premium SSD v2, which supports up to 64TB.
        """
        return pulumi.get(self, "data_disk_size")

    @property
    @pulumi.getter(name="dataDiskType")
    def data_disk_type(self) -> str:
        """
        Managed Disk Type.
        """
        return pulumi.get(self, "data_disk_type")


@pulumi.output_type
class EncryptionInTransitPropertiesResponse(dict):
    """
    The encryption-in-transit properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEncryptionInTransitEnabled":
            suggest = "is_encryption_in_transit_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionInTransitPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionInTransitPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionInTransitPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_encryption_in_transit_enabled: Optional[bool] = None):
        """
        The encryption-in-transit properties.
        :param bool is_encryption_in_transit_enabled: Indicates whether or not inter cluster node communication is encrypted in transit.
        """
        if is_encryption_in_transit_enabled is None:
            is_encryption_in_transit_enabled = False
        if is_encryption_in_transit_enabled is not None:
            pulumi.set(__self__, "is_encryption_in_transit_enabled", is_encryption_in_transit_enabled)

    @property
    @pulumi.getter(name="isEncryptionInTransitEnabled")
    def is_encryption_in_transit_enabled(self) -> Optional[bool]:
        """
        Indicates whether or not inter cluster node communication is encrypted in transit.
        """
        return pulumi.get(self, "is_encryption_in_transit_enabled")


@pulumi.output_type
class ErrorsResponse(dict):
    """
    The error message associated with the cluster creation.
    """
    def __init__(__self__, *,
                 code: Optional[str] = None,
                 message: Optional[str] = None):
        """
        The error message associated with the cluster creation.
        :param str code: The error code.
        :param str message: The error message.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        The error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The error message.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class ExcludedServicesConfigResponse(dict):
    """
    The configuration that services will be excluded when creating cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedServicesConfigId":
            suggest = "excluded_services_config_id"
        elif key == "excludedServicesList":
            suggest = "excluded_services_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExcludedServicesConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExcludedServicesConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExcludedServicesConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 excluded_services_config_id: Optional[str] = None,
                 excluded_services_list: Optional[str] = None):
        """
        The configuration that services will be excluded when creating cluster.
        :param str excluded_services_config_id: The config id of excluded services.
        :param str excluded_services_list: The list of excluded services.
        """
        if excluded_services_config_id is not None:
            pulumi.set(__self__, "excluded_services_config_id", excluded_services_config_id)
        if excluded_services_list is not None:
            pulumi.set(__self__, "excluded_services_list", excluded_services_list)

    @property
    @pulumi.getter(name="excludedServicesConfigId")
    def excluded_services_config_id(self) -> Optional[str]:
        """
        The config id of excluded services.
        """
        return pulumi.get(self, "excluded_services_config_id")

    @property
    @pulumi.getter(name="excludedServicesList")
    def excluded_services_list(self) -> Optional[str]:
        """
        The list of excluded services.
        """
        return pulumi.get(self, "excluded_services_list")


@pulumi.output_type
class FlinkCatalogOptionsResponse(dict):
    """
    Flink cluster catalog options.
    """
    def __init__(__self__, *,
                 hive: Optional['outputs.FlinkHiveCatalogOptionResponse'] = None):
        """
        Flink cluster catalog options.
        :param 'FlinkHiveCatalogOptionResponse' hive: Hive Catalog Option for Flink cluster.
        """
        if hive is not None:
            pulumi.set(__self__, "hive", hive)

    @property
    @pulumi.getter
    def hive(self) -> Optional['outputs.FlinkHiveCatalogOptionResponse']:
        """
        Hive Catalog Option for Flink cluster.
        """
        return pulumi.get(self, "hive")


@pulumi.output_type
class FlinkHiveCatalogOptionResponse(dict):
    """
    Hive Catalog Option for Flink cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metastoreDbConnectionURL":
            suggest = "metastore_db_connection_url"
        elif key == "metastoreDbConnectionAuthenticationMode":
            suggest = "metastore_db_connection_authentication_mode"
        elif key == "metastoreDbConnectionPasswordSecret":
            suggest = "metastore_db_connection_password_secret"
        elif key == "metastoreDbConnectionUserName":
            suggest = "metastore_db_connection_user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkHiveCatalogOptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkHiveCatalogOptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkHiveCatalogOptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metastore_db_connection_url: str,
                 metastore_db_connection_authentication_mode: Optional[str] = None,
                 metastore_db_connection_password_secret: Optional[str] = None,
                 metastore_db_connection_user_name: Optional[str] = None):
        """
        Hive Catalog Option for Flink cluster.
        :param str metastore_db_connection_url: Connection string for hive metastore database.
        :param str metastore_db_connection_authentication_mode: The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        :param str metastore_db_connection_password_secret: Secret reference name from secretsProfile.secrets containing password for database connection.
        :param str metastore_db_connection_user_name: User name for database connection.
        """
        pulumi.set(__self__, "metastore_db_connection_url", metastore_db_connection_url)
        if metastore_db_connection_authentication_mode is None:
            metastore_db_connection_authentication_mode = 'IdentityAuth'
        if metastore_db_connection_authentication_mode is not None:
            pulumi.set(__self__, "metastore_db_connection_authentication_mode", metastore_db_connection_authentication_mode)
        if metastore_db_connection_password_secret is not None:
            pulumi.set(__self__, "metastore_db_connection_password_secret", metastore_db_connection_password_secret)
        if metastore_db_connection_user_name is not None:
            pulumi.set(__self__, "metastore_db_connection_user_name", metastore_db_connection_user_name)

    @property
    @pulumi.getter(name="metastoreDbConnectionURL")
    def metastore_db_connection_url(self) -> str:
        """
        Connection string for hive metastore database.
        """
        return pulumi.get(self, "metastore_db_connection_url")

    @property
    @pulumi.getter(name="metastoreDbConnectionAuthenticationMode")
    def metastore_db_connection_authentication_mode(self) -> Optional[str]:
        """
        The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        """
        return pulumi.get(self, "metastore_db_connection_authentication_mode")

    @property
    @pulumi.getter(name="metastoreDbConnectionPasswordSecret")
    def metastore_db_connection_password_secret(self) -> Optional[str]:
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_password_secret")

    @property
    @pulumi.getter(name="metastoreDbConnectionUserName")
    def metastore_db_connection_user_name(self) -> Optional[str]:
        """
        User name for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_user_name")


@pulumi.output_type
class FlinkJobProfileResponse(dict):
    """
    Job specifications for flink clusters in application deployment mode. The specification is immutable even if job properties are changed by calling the RunJob API, please use the ListJob API to get the latest job information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jarName":
            suggest = "jar_name"
        elif key == "jobJarDirectory":
            suggest = "job_jar_directory"
        elif key == "upgradeMode":
            suggest = "upgrade_mode"
        elif key == "entryClass":
            suggest = "entry_class"
        elif key == "savePointName":
            suggest = "save_point_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkJobProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkJobProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkJobProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jar_name: str,
                 job_jar_directory: str,
                 upgrade_mode: str,
                 args: Optional[str] = None,
                 entry_class: Optional[str] = None,
                 save_point_name: Optional[str] = None):
        """
        Job specifications for flink clusters in application deployment mode. The specification is immutable even if job properties are changed by calling the RunJob API, please use the ListJob API to get the latest job information.
        :param str jar_name: A string property that represents the name of the job JAR.
        :param str job_jar_directory: A string property that specifies the directory where the job JAR is located.
        :param str upgrade_mode: A string property that indicates the upgrade mode to be performed on the Flink job. It can have one of the following enum values => STATELESS_UPDATE, UPDATE, LAST_STATE_UPDATE.
        :param str args: A string property representing additional JVM arguments for the Flink job. It should be space separated value.
        :param str entry_class: A string property that specifies the entry class for the Flink job. If not specified, the entry point is auto-detected from the flink job jar package.
        :param str save_point_name: A string property that represents the name of the savepoint for the Flink job
        """
        pulumi.set(__self__, "jar_name", jar_name)
        pulumi.set(__self__, "job_jar_directory", job_jar_directory)
        pulumi.set(__self__, "upgrade_mode", upgrade_mode)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if entry_class is not None:
            pulumi.set(__self__, "entry_class", entry_class)
        if save_point_name is not None:
            pulumi.set(__self__, "save_point_name", save_point_name)

    @property
    @pulumi.getter(name="jarName")
    def jar_name(self) -> str:
        """
        A string property that represents the name of the job JAR.
        """
        return pulumi.get(self, "jar_name")

    @property
    @pulumi.getter(name="jobJarDirectory")
    def job_jar_directory(self) -> str:
        """
        A string property that specifies the directory where the job JAR is located.
        """
        return pulumi.get(self, "job_jar_directory")

    @property
    @pulumi.getter(name="upgradeMode")
    def upgrade_mode(self) -> str:
        """
        A string property that indicates the upgrade mode to be performed on the Flink job. It can have one of the following enum values => STATELESS_UPDATE, UPDATE, LAST_STATE_UPDATE.
        """
        return pulumi.get(self, "upgrade_mode")

    @property
    @pulumi.getter
    def args(self) -> Optional[str]:
        """
        A string property representing additional JVM arguments for the Flink job. It should be space separated value.
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter(name="entryClass")
    def entry_class(self) -> Optional[str]:
        """
        A string property that specifies the entry class for the Flink job. If not specified, the entry point is auto-detected from the flink job jar package.
        """
        return pulumi.get(self, "entry_class")

    @property
    @pulumi.getter(name="savePointName")
    def save_point_name(self) -> Optional[str]:
        """
        A string property that represents the name of the savepoint for the Flink job
        """
        return pulumi.get(self, "save_point_name")


@pulumi.output_type
class FlinkProfileResponse(dict):
    """
    The Flink cluster profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobManager":
            suggest = "job_manager"
        elif key == "taskManager":
            suggest = "task_manager"
        elif key == "catalogOptions":
            suggest = "catalog_options"
        elif key == "deploymentMode":
            suggest = "deployment_mode"
        elif key == "historyServer":
            suggest = "history_server"
        elif key == "jobSpec":
            suggest = "job_spec"
        elif key == "numReplicas":
            suggest = "num_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_manager: 'outputs.ComputeResourceDefinitionResponse',
                 storage: 'outputs.FlinkStorageProfileResponse',
                 task_manager: 'outputs.ComputeResourceDefinitionResponse',
                 catalog_options: Optional['outputs.FlinkCatalogOptionsResponse'] = None,
                 deployment_mode: Optional[str] = None,
                 history_server: Optional['outputs.ComputeResourceDefinitionResponse'] = None,
                 job_spec: Optional['outputs.FlinkJobProfileResponse'] = None,
                 num_replicas: Optional[int] = None):
        """
        The Flink cluster profile.
        :param 'ComputeResourceDefinitionResponse' job_manager: Job Manager container/ process CPU and memory requirements
        :param 'FlinkStorageProfileResponse' storage: The storage profile
        :param 'ComputeResourceDefinitionResponse' task_manager: Task Manager container/ process CPU and memory requirements
        :param 'FlinkCatalogOptionsResponse' catalog_options: Flink cluster catalog options.
        :param str deployment_mode: A string property that indicates the deployment mode of Flink cluster. It can have one of the following enum values => Application, Session. Default value is Session
        :param 'ComputeResourceDefinitionResponse' history_server: History Server container/ process CPU and memory requirements
        :param 'FlinkJobProfileResponse' job_spec: Job specifications for flink clusters in application deployment mode. The specification is immutable even if job properties are changed by calling the RunJob API, please use the ListJob API to get the latest job information.
        :param int num_replicas: The number of task managers.
        """
        pulumi.set(__self__, "job_manager", job_manager)
        pulumi.set(__self__, "storage", storage)
        pulumi.set(__self__, "task_manager", task_manager)
        if catalog_options is not None:
            pulumi.set(__self__, "catalog_options", catalog_options)
        if deployment_mode is not None:
            pulumi.set(__self__, "deployment_mode", deployment_mode)
        if history_server is not None:
            pulumi.set(__self__, "history_server", history_server)
        if job_spec is not None:
            pulumi.set(__self__, "job_spec", job_spec)
        if num_replicas is not None:
            pulumi.set(__self__, "num_replicas", num_replicas)

    @property
    @pulumi.getter(name="jobManager")
    def job_manager(self) -> 'outputs.ComputeResourceDefinitionResponse':
        """
        Job Manager container/ process CPU and memory requirements
        """
        return pulumi.get(self, "job_manager")

    @property
    @pulumi.getter
    def storage(self) -> 'outputs.FlinkStorageProfileResponse':
        """
        The storage profile
        """
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter(name="taskManager")
    def task_manager(self) -> 'outputs.ComputeResourceDefinitionResponse':
        """
        Task Manager container/ process CPU and memory requirements
        """
        return pulumi.get(self, "task_manager")

    @property
    @pulumi.getter(name="catalogOptions")
    def catalog_options(self) -> Optional['outputs.FlinkCatalogOptionsResponse']:
        """
        Flink cluster catalog options.
        """
        return pulumi.get(self, "catalog_options")

    @property
    @pulumi.getter(name="deploymentMode")
    def deployment_mode(self) -> Optional[str]:
        """
        A string property that indicates the deployment mode of Flink cluster. It can have one of the following enum values => Application, Session. Default value is Session
        """
        return pulumi.get(self, "deployment_mode")

    @property
    @pulumi.getter(name="historyServer")
    def history_server(self) -> Optional['outputs.ComputeResourceDefinitionResponse']:
        """
        History Server container/ process CPU and memory requirements
        """
        return pulumi.get(self, "history_server")

    @property
    @pulumi.getter(name="jobSpec")
    def job_spec(self) -> Optional['outputs.FlinkJobProfileResponse']:
        """
        Job specifications for flink clusters in application deployment mode. The specification is immutable even if job properties are changed by calling the RunJob API, please use the ListJob API to get the latest job information.
        """
        return pulumi.get(self, "job_spec")

    @property
    @pulumi.getter(name="numReplicas")
    def num_replicas(self) -> Optional[int]:
        """
        The number of task managers.
        """
        return pulumi.get(self, "num_replicas")


@pulumi.output_type
class FlinkStorageProfileResponse(dict):
    """
    The storage profile
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageUri":
            suggest = "storage_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlinkStorageProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlinkStorageProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlinkStorageProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_uri: str,
                 storagekey: Optional[str] = None):
        """
        The storage profile
        :param str storage_uri: Storage account uri which is used for savepoint and checkpoint state.
        :param str storagekey: Storage key is only required for wasb(s) storage.
        """
        pulumi.set(__self__, "storage_uri", storage_uri)
        if storagekey is not None:
            pulumi.set(__self__, "storagekey", storagekey)

    @property
    @pulumi.getter(name="storageUri")
    def storage_uri(self) -> str:
        """
        Storage account uri which is used for savepoint and checkpoint state.
        """
        return pulumi.get(self, "storage_uri")

    @property
    @pulumi.getter
    def storagekey(self) -> Optional[str]:
        """
        Storage key is only required for wasb(s) storage.
        """
        return pulumi.get(self, "storagekey")


@pulumi.output_type
class HardwareProfileResponse(dict):
    """
    The hardware profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HardwareProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HardwareProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HardwareProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vm_size: Optional[str] = None):
        """
        The hardware profile.
        :param str vm_size: The size of the VM
        """
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[str]:
        """
        The size of the VM
        """
        return pulumi.get(self, "vm_size")


@pulumi.output_type
class HiveCatalogOptionResponse(dict):
    """
    Hive Catalog Option
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogName":
            suggest = "catalog_name"
        elif key == "metastoreDbConnectionURL":
            suggest = "metastore_db_connection_url"
        elif key == "metastoreWarehouseDir":
            suggest = "metastore_warehouse_dir"
        elif key == "metastoreDbConnectionAuthenticationMode":
            suggest = "metastore_db_connection_authentication_mode"
        elif key == "metastoreDbConnectionPasswordSecret":
            suggest = "metastore_db_connection_password_secret"
        elif key == "metastoreDbConnectionUserName":
            suggest = "metastore_db_connection_user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HiveCatalogOptionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HiveCatalogOptionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HiveCatalogOptionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_name: str,
                 metastore_db_connection_url: str,
                 metastore_warehouse_dir: str,
                 metastore_db_connection_authentication_mode: Optional[str] = None,
                 metastore_db_connection_password_secret: Optional[str] = None,
                 metastore_db_connection_user_name: Optional[str] = None):
        """
        Hive Catalog Option
        :param str catalog_name: Name of trino catalog which should use specified hive metastore.
        :param str metastore_db_connection_url: Connection string for hive metastore database.
        :param str metastore_warehouse_dir: Metastore root directory URI, format: abfs[s]://<container>@<account_name>.dfs.core.windows.net/<path>. More details: https://docs.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-introduction-abfs-uri
        :param str metastore_db_connection_authentication_mode: The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        :param str metastore_db_connection_password_secret: Secret reference name from secretsProfile.secrets containing password for database connection.
        :param str metastore_db_connection_user_name: User name for database connection.
        """
        pulumi.set(__self__, "catalog_name", catalog_name)
        pulumi.set(__self__, "metastore_db_connection_url", metastore_db_connection_url)
        pulumi.set(__self__, "metastore_warehouse_dir", metastore_warehouse_dir)
        if metastore_db_connection_authentication_mode is None:
            metastore_db_connection_authentication_mode = 'IdentityAuth'
        if metastore_db_connection_authentication_mode is not None:
            pulumi.set(__self__, "metastore_db_connection_authentication_mode", metastore_db_connection_authentication_mode)
        if metastore_db_connection_password_secret is not None:
            pulumi.set(__self__, "metastore_db_connection_password_secret", metastore_db_connection_password_secret)
        if metastore_db_connection_user_name is not None:
            pulumi.set(__self__, "metastore_db_connection_user_name", metastore_db_connection_user_name)

    @property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> str:
        """
        Name of trino catalog which should use specified hive metastore.
        """
        return pulumi.get(self, "catalog_name")

    @property
    @pulumi.getter(name="metastoreDbConnectionURL")
    def metastore_db_connection_url(self) -> str:
        """
        Connection string for hive metastore database.
        """
        return pulumi.get(self, "metastore_db_connection_url")

    @property
    @pulumi.getter(name="metastoreWarehouseDir")
    def metastore_warehouse_dir(self) -> str:
        """
        Metastore root directory URI, format: abfs[s]://<container>@<account_name>.dfs.core.windows.net/<path>. More details: https://docs.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-introduction-abfs-uri
        """
        return pulumi.get(self, "metastore_warehouse_dir")

    @property
    @pulumi.getter(name="metastoreDbConnectionAuthenticationMode")
    def metastore_db_connection_authentication_mode(self) -> Optional[str]:
        """
        The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        """
        return pulumi.get(self, "metastore_db_connection_authentication_mode")

    @property
    @pulumi.getter(name="metastoreDbConnectionPasswordSecret")
    def metastore_db_connection_password_secret(self) -> Optional[str]:
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_password_secret")

    @property
    @pulumi.getter(name="metastoreDbConnectionUserName")
    def metastore_db_connection_user_name(self) -> Optional[str]:
        """
        User name for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_user_name")


@pulumi.output_type
class IPConfigurationResponse(dict):
    """
    The ip configurations for the private link service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "privateIPAddress":
            suggest = "private_ip_address"
        elif key == "privateIPAllocationMethod":
            suggest = "private_ip_allocation_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IPConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IPConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IPConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 provisioning_state: str,
                 type: str,
                 primary: Optional[bool] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_allocation_method: Optional[str] = None,
                 subnet: Optional['outputs.ResourceIdResponse'] = None):
        """
        The ip configurations for the private link service.
        :param str id: The private link IP configuration id.
        :param str name: The name of private link IP configuration.
        :param str provisioning_state: The private link configuration provisioning state, which only appears in the response.
        :param str type: The type of the private link IP configuration.
        :param bool primary: Indicates whether this IP configuration is primary for the corresponding NIC.
        :param str private_ip_address: The IP address.
        :param str private_ip_allocation_method: The method that private IP address is allocated.
        :param 'ResourceIdResponse' subnet: The subnet resource id.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", type)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_allocation_method is not None:
            pulumi.set(__self__, "private_ip_allocation_method", private_ip_allocation_method)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The private link IP configuration id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of private link IP configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The private link configuration provisioning state, which only appears in the response.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the private link IP configuration.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Indicates whether this IP configuration is primary for the corresponding NIC.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The IP address.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIPAllocationMethod")
    def private_ip_allocation_method(self) -> Optional[str]:
        """
        The method that private IP address is allocated.
        """
        return pulumi.get(self, "private_ip_allocation_method")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.ResourceIdResponse']:
        """
        The subnet resource id.
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class IdentityProfileResponse(dict):
    """
    Identity Profile with details of an MSI.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "msiClientId":
            suggest = "msi_client_id"
        elif key == "msiObjectId":
            suggest = "msi_object_id"
        elif key == "msiResourceId":
            suggest = "msi_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 msi_client_id: str,
                 msi_object_id: str,
                 msi_resource_id: str):
        """
        Identity Profile with details of an MSI.
        :param str msi_client_id: ClientId of the MSI.
        :param str msi_object_id: ObjectId of the MSI.
        :param str msi_resource_id: ResourceId of the MSI.
        """
        pulumi.set(__self__, "msi_client_id", msi_client_id)
        pulumi.set(__self__, "msi_object_id", msi_object_id)
        pulumi.set(__self__, "msi_resource_id", msi_resource_id)

    @property
    @pulumi.getter(name="msiClientId")
    def msi_client_id(self) -> str:
        """
        ClientId of the MSI.
        """
        return pulumi.get(self, "msi_client_id")

    @property
    @pulumi.getter(name="msiObjectId")
    def msi_object_id(self) -> str:
        """
        ObjectId of the MSI.
        """
        return pulumi.get(self, "msi_object_id")

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> str:
        """
        ResourceId of the MSI.
        """
        return pulumi.get(self, "msi_resource_id")


@pulumi.output_type
class IpTagResponse(dict):
    """
    Contains the IpTag associated with the public IP address
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipTagType":
            suggest = "ip_tag_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpTagResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpTagResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpTagResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_tag_type: str,
                 tag: str):
        """
        Contains the IpTag associated with the public IP address
        :param str ip_tag_type: Gets or sets the ipTag type: Example FirstPartyUsage.
        :param str tag: Gets or sets value of the IpTag associated with the public IP. Example HDInsight, SQL, Storage etc
        """
        pulumi.set(__self__, "ip_tag_type", ip_tag_type)
        pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="ipTagType")
    def ip_tag_type(self) -> str:
        """
        Gets or sets the ipTag type: Example FirstPartyUsage.
        """
        return pulumi.get(self, "ip_tag_type")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Gets or sets value of the IpTag associated with the public IP. Example HDInsight, SQL, Storage etc
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class KafkaConnectivityEndpointsResponse(dict):
    """
    Kafka bootstrap server and broker related connectivity endpoints.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootstrapServerEndpoint":
            suggest = "bootstrap_server_endpoint"
        elif key == "brokerEndpoints":
            suggest = "broker_endpoints"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaConnectivityEndpointsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaConnectivityEndpointsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaConnectivityEndpointsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bootstrap_server_endpoint: Optional[str] = None,
                 broker_endpoints: Optional[Sequence[str]] = None):
        """
        Kafka bootstrap server and broker related connectivity endpoints.
        :param str bootstrap_server_endpoint: bootstrap server connectivity endpoint.
        :param Sequence[str] broker_endpoints: Kafka broker endpoint list.
        """
        if bootstrap_server_endpoint is not None:
            pulumi.set(__self__, "bootstrap_server_endpoint", bootstrap_server_endpoint)
        if broker_endpoints is not None:
            pulumi.set(__self__, "broker_endpoints", broker_endpoints)

    @property
    @pulumi.getter(name="bootstrapServerEndpoint")
    def bootstrap_server_endpoint(self) -> Optional[str]:
        """
        bootstrap server connectivity endpoint.
        """
        return pulumi.get(self, "bootstrap_server_endpoint")

    @property
    @pulumi.getter(name="brokerEndpoints")
    def broker_endpoints(self) -> Optional[Sequence[str]]:
        """
        Kafka broker endpoint list.
        """
        return pulumi.get(self, "broker_endpoints")


@pulumi.output_type
class KafkaProfileResponse(dict):
    """
    The Kafka cluster profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectivityEndpoints":
            suggest = "connectivity_endpoints"
        elif key == "diskStorage":
            suggest = "disk_storage"
        elif key == "enableKRaft":
            suggest = "enable_k_raft"
        elif key == "enablePublicEndpoints":
            suggest = "enable_public_endpoints"
        elif key == "remoteStorageUri":
            suggest = "remote_storage_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connectivity_endpoints: 'outputs.KafkaConnectivityEndpointsResponse',
                 disk_storage: 'outputs.DiskStorageProfileResponse',
                 enable_k_raft: Optional[bool] = None,
                 enable_public_endpoints: Optional[bool] = None,
                 remote_storage_uri: Optional[str] = None):
        """
        The Kafka cluster profile.
        :param 'KafkaConnectivityEndpointsResponse' connectivity_endpoints: Kafka bootstrap server and brokers related connectivity endpoints.
        :param 'DiskStorageProfileResponse' disk_storage: Kafka disk storage profile.
        :param bool enable_k_raft: Expose Kafka cluster in KRaft mode.
        :param bool enable_public_endpoints: Expose worker nodes as public endpoints.
        :param str remote_storage_uri: Fully qualified path of Azure Storage container used for Tiered Storage.
        """
        pulumi.set(__self__, "connectivity_endpoints", connectivity_endpoints)
        pulumi.set(__self__, "disk_storage", disk_storage)
        if enable_k_raft is None:
            enable_k_raft = True
        if enable_k_raft is not None:
            pulumi.set(__self__, "enable_k_raft", enable_k_raft)
        if enable_public_endpoints is None:
            enable_public_endpoints = False
        if enable_public_endpoints is not None:
            pulumi.set(__self__, "enable_public_endpoints", enable_public_endpoints)
        if remote_storage_uri is not None:
            pulumi.set(__self__, "remote_storage_uri", remote_storage_uri)

    @property
    @pulumi.getter(name="connectivityEndpoints")
    def connectivity_endpoints(self) -> 'outputs.KafkaConnectivityEndpointsResponse':
        """
        Kafka bootstrap server and brokers related connectivity endpoints.
        """
        return pulumi.get(self, "connectivity_endpoints")

    @property
    @pulumi.getter(name="diskStorage")
    def disk_storage(self) -> 'outputs.DiskStorageProfileResponse':
        """
        Kafka disk storage profile.
        """
        return pulumi.get(self, "disk_storage")

    @property
    @pulumi.getter(name="enableKRaft")
    def enable_k_raft(self) -> Optional[bool]:
        """
        Expose Kafka cluster in KRaft mode.
        """
        return pulumi.get(self, "enable_k_raft")

    @property
    @pulumi.getter(name="enablePublicEndpoints")
    def enable_public_endpoints(self) -> Optional[bool]:
        """
        Expose worker nodes as public endpoints.
        """
        return pulumi.get(self, "enable_public_endpoints")

    @property
    @pulumi.getter(name="remoteStorageUri")
    def remote_storage_uri(self) -> Optional[str]:
        """
        Fully qualified path of Azure Storage container used for Tiered Storage.
        """
        return pulumi.get(self, "remote_storage_uri")


@pulumi.output_type
class KafkaRestPropertiesResponse(dict):
    """
    The kafka rest proxy configuration which contains AAD security group information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientGroupInfo":
            suggest = "client_group_info"
        elif key == "configurationOverride":
            suggest = "configuration_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KafkaRestPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KafkaRestPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KafkaRestPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_group_info: Optional['outputs.ClientGroupInfoResponse'] = None,
                 configuration_override: Optional[Mapping[str, str]] = None):
        """
        The kafka rest proxy configuration which contains AAD security group information.
        :param 'ClientGroupInfoResponse' client_group_info: The information of AAD security group.
        :param Mapping[str, str] configuration_override: The configurations that need to be overriden.
        """
        if client_group_info is not None:
            pulumi.set(__self__, "client_group_info", client_group_info)
        if configuration_override is not None:
            pulumi.set(__self__, "configuration_override", configuration_override)

    @property
    @pulumi.getter(name="clientGroupInfo")
    def client_group_info(self) -> Optional['outputs.ClientGroupInfoResponse']:
        """
        The information of AAD security group.
        """
        return pulumi.get(self, "client_group_info")

    @property
    @pulumi.getter(name="configurationOverride")
    def configuration_override(self) -> Optional[Mapping[str, str]]:
        """
        The configurations that need to be overriden.
        """
        return pulumi.get(self, "configuration_override")


@pulumi.output_type
class LinuxOperatingSystemProfileResponse(dict):
    """
    The ssh username, password, and ssh public key.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshProfile":
            suggest = "ssh_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinuxOperatingSystemProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinuxOperatingSystemProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinuxOperatingSystemProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: Optional[str] = None,
                 ssh_profile: Optional['outputs.SshProfileResponse'] = None,
                 username: Optional[str] = None):
        """
        The ssh username, password, and ssh public key.
        :param str password: The password.
        :param 'SshProfileResponse' ssh_profile: The SSH profile.
        :param str username: The username.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ssh_profile is not None:
            pulumi.set(__self__, "ssh_profile", ssh_profile)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="sshProfile")
    def ssh_profile(self) -> Optional['outputs.SshProfileResponse']:
        """
        The SSH profile.
        """
        return pulumi.get(self, "ssh_profile")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class LoadBasedConfigResponse(dict):
    """
    Profile of load based Autoscale.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNodes":
            suggest = "max_nodes"
        elif key == "minNodes":
            suggest = "min_nodes"
        elif key == "scalingRules":
            suggest = "scaling_rules"
        elif key == "cooldownPeriod":
            suggest = "cooldown_period"
        elif key == "pollInterval":
            suggest = "poll_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBasedConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBasedConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBasedConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_nodes: int,
                 min_nodes: int,
                 scaling_rules: Sequence['outputs.ScalingRuleResponse'],
                 cooldown_period: Optional[int] = None,
                 poll_interval: Optional[int] = None):
        """
        Profile of load based Autoscale.
        :param int max_nodes: User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        :param int min_nodes: User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        :param Sequence['ScalingRuleResponse'] scaling_rules: The scaling rules.
        :param int cooldown_period: This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.
        :param int poll_interval: User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.
        """
        pulumi.set(__self__, "max_nodes", max_nodes)
        pulumi.set(__self__, "min_nodes", min_nodes)
        pulumi.set(__self__, "scaling_rules", scaling_rules)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if poll_interval is not None:
            pulumi.set(__self__, "poll_interval", poll_interval)

    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> int:
        """
        User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        return pulumi.get(self, "max_nodes")

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> int:
        """
        User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        return pulumi.get(self, "min_nodes")

    @property
    @pulumi.getter(name="scalingRules")
    def scaling_rules(self) -> Sequence['outputs.ScalingRuleResponse']:
        """
        The scaling rules.
        """
        return pulumi.get(self, "scaling_rules")

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[int]:
        """
        This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.
        """
        return pulumi.get(self, "cooldown_period")

    @property
    @pulumi.getter(name="pollInterval")
    def poll_interval(self) -> Optional[int]:
        """
        User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.
        """
        return pulumi.get(self, "poll_interval")


@pulumi.output_type
class ManagedIdentityProfileResponse(dict):
    """
    The details of managed identity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityList":
            suggest = "identity_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentityProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentityProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentityProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_list: Sequence['outputs.ManagedIdentitySpecResponse']):
        """
        The details of managed identity.
        :param Sequence['ManagedIdentitySpecResponse'] identity_list: The list of managed identity.
        """
        pulumi.set(__self__, "identity_list", identity_list)

    @property
    @pulumi.getter(name="identityList")
    def identity_list(self) -> Sequence['outputs.ManagedIdentitySpecResponse']:
        """
        The list of managed identity.
        """
        return pulumi.get(self, "identity_list")


@pulumi.output_type
class ManagedIdentitySpecResponse(dict):
    """
    The details of a managed identity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedIdentitySpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedIdentitySpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedIdentitySpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 object_id: str,
                 resource_id: str,
                 type: str):
        """
        The details of a managed identity.
        :param str client_id: ClientId of the managed identity.
        :param str object_id: ObjectId of the managed identity.
        :param str resource_id: ResourceId of the managed identity.
        :param str type: The type of managed identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        ClientId of the managed identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> str:
        """
        ObjectId of the managed identity.
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        ResourceId of the managed identity.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of managed identity.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkPropertiesResponse(dict):
    """
    The network properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outboundDependenciesManagedType":
            suggest = "outbound_dependencies_managed_type"
        elif key == "privateLink":
            suggest = "private_link"
        elif key == "publicIpTag":
            suggest = "public_ip_tag"
        elif key == "resourceProviderConnection":
            suggest = "resource_provider_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 outbound_dependencies_managed_type: Optional[str] = None,
                 private_link: Optional[str] = None,
                 public_ip_tag: Optional['outputs.IpTagResponse'] = None,
                 resource_provider_connection: Optional[str] = None):
        """
        The network properties.
        :param str outbound_dependencies_managed_type: A value to describe how the outbound dependencies of a HDInsight cluster are managed. 'Managed' means that the outbound dependencies are managed by the HDInsight service. 'External' means that the outbound dependencies are managed by a customer specific solution.
        :param str private_link: Indicates whether or not private link is enabled.
        :param 'IpTagResponse' public_ip_tag: Gets or sets the IP tag for the public IPs created along with the HDInsight Clusters. 
        :param str resource_provider_connection: The direction for the resource provider connection.
        """
        if outbound_dependencies_managed_type is not None:
            pulumi.set(__self__, "outbound_dependencies_managed_type", outbound_dependencies_managed_type)
        if private_link is not None:
            pulumi.set(__self__, "private_link", private_link)
        if public_ip_tag is not None:
            pulumi.set(__self__, "public_ip_tag", public_ip_tag)
        if resource_provider_connection is not None:
            pulumi.set(__self__, "resource_provider_connection", resource_provider_connection)

    @property
    @pulumi.getter(name="outboundDependenciesManagedType")
    def outbound_dependencies_managed_type(self) -> Optional[str]:
        """
        A value to describe how the outbound dependencies of a HDInsight cluster are managed. 'Managed' means that the outbound dependencies are managed by the HDInsight service. 'External' means that the outbound dependencies are managed by a customer specific solution.
        """
        return pulumi.get(self, "outbound_dependencies_managed_type")

    @property
    @pulumi.getter(name="privateLink")
    def private_link(self) -> Optional[str]:
        """
        Indicates whether or not private link is enabled.
        """
        return pulumi.get(self, "private_link")

    @property
    @pulumi.getter(name="publicIpTag")
    def public_ip_tag(self) -> Optional['outputs.IpTagResponse']:
        """
        Gets or sets the IP tag for the public IPs created along with the HDInsight Clusters. 
        """
        return pulumi.get(self, "public_ip_tag")

    @property
    @pulumi.getter(name="resourceProviderConnection")
    def resource_provider_connection(self) -> Optional[str]:
        """
        The direction for the resource provider connection.
        """
        return pulumi.get(self, "resource_provider_connection")


@pulumi.output_type
class NodeProfileResponse(dict):
    """
    The node profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmSize":
            suggest = "vm_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 type: str,
                 vm_size: str):
        """
        The node profile.
        :param int count: The number of virtual machines.
        :param str type: The node type.
        :param str vm_size: The virtual machine SKU.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        The number of virtual machines.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The node type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> str:
        """
        The virtual machine SKU.
        """
        return pulumi.get(self, "vm_size")


@pulumi.output_type
class OsProfileResponse(dict):
    """
    The Linux operation systems profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linuxOperatingSystemProfile":
            suggest = "linux_operating_system_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linux_operating_system_profile: Optional['outputs.LinuxOperatingSystemProfileResponse'] = None):
        """
        The Linux operation systems profile.
        :param 'LinuxOperatingSystemProfileResponse' linux_operating_system_profile: The Linux OS profile.
        """
        if linux_operating_system_profile is not None:
            pulumi.set(__self__, "linux_operating_system_profile", linux_operating_system_profile)

    @property
    @pulumi.getter(name="linuxOperatingSystemProfile")
    def linux_operating_system_profile(self) -> Optional['outputs.LinuxOperatingSystemProfileResponse']:
        """
        The Linux OS profile.
        """
        return pulumi.get(self, "linux_operating_system_profile")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    """
    The private endpoint connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkIdentifier":
            suggest = "link_identifier"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "systemData":
            suggest = "system_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 link_identifier: str,
                 name: str,
                 private_endpoint: 'outputs.PrivateEndpointResponse',
                 private_link_service_connection_state: 'outputs.PrivateLinkServiceConnectionStateResponse',
                 provisioning_state: str,
                 system_data: 'outputs.SystemDataResponse',
                 type: str):
        """
        The private endpoint connection.
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str link_identifier: The link identifier.
        :param str name: The name of the resource
        :param 'PrivateEndpointResponse' private_endpoint: The private endpoint of the private endpoint connection
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: The private link service connection state.
        :param str provisioning_state: The provisioning state, which only appears in the response.
        :param 'SystemDataResponse' system_data: Metadata pertaining to creation and last modification of the resource.
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "link_identifier", link_identifier)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_endpoint", private_endpoint)
        pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="linkIdentifier")
    def link_identifier(self) -> str:
        """
        The link identifier.
        """
        return pulumi.get(self, "link_identifier")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> 'outputs.PrivateEndpointResponse':
        """
        The private endpoint of the private endpoint connection
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> 'outputs.PrivateLinkServiceConnectionStateResponse':
        """
        The private link service connection state.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state, which only appears in the response.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Metadata pertaining to creation and last modification of the resource.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    The private endpoint.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        The private endpoint.
        :param str id: The private endpoint id.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The private endpoint id.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkConfigurationResponse(dict):
    """
    The private link configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "ipConfigurations":
            suggest = "ip_configurations"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: str,
                 id: str,
                 ip_configurations: Sequence['outputs.IPConfigurationResponse'],
                 name: str,
                 provisioning_state: str,
                 type: str):
        """
        The private link configuration.
        :param str group_id: The HDInsight private linkable sub-resource name to apply the private link configuration to. For example, 'headnode', 'gateway', 'edgenode'.
        :param str id: The private link configuration id.
        :param Sequence['IPConfigurationResponse'] ip_configurations: The IP configurations for the private link service.
        :param str name: The name of private link configuration.
        :param str provisioning_state: The private link configuration provisioning state, which only appears in the response.
        :param str type: The type of the private link configuration.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        The HDInsight private linkable sub-resource name to apply the private link configuration to. For example, 'headnode', 'gateway', 'edgenode'.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The private link configuration id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> Sequence['outputs.IPConfigurationResponse']:
        """
        The IP configurations for the private link service.
        """
        return pulumi.get(self, "ip_configurations")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of private link configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The private link configuration provisioning state, which only appears in the response.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the private link configuration.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    The private link service connection state.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: str,
                 actions_required: Optional[str] = None,
                 description: Optional[str] = None):
        """
        The private link service connection state.
        :param str status: The concrete private link service connection.
        :param str actions_required: Whether there is further actions.
        :param str description: The optional description of the status.
        """
        pulumi.set(__self__, "status", status)
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The concrete private link service connection.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[str]:
        """
        Whether there is further actions.
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The optional description of the status.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class QuotaInfoResponse(dict):
    """
    The quota properties for the cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coresUsed":
            suggest = "cores_used"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QuotaInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QuotaInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QuotaInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cores_used: Optional[int] = None):
        """
        The quota properties for the cluster.
        :param int cores_used: The cores used by the cluster.
        """
        if cores_used is not None:
            pulumi.set(__self__, "cores_used", cores_used)

    @property
    @pulumi.getter(name="coresUsed")
    def cores_used(self) -> Optional[int]:
        """
        The cores used by the cluster.
        """
        return pulumi.get(self, "cores_used")


@pulumi.output_type
class RangerAdminSpecResponse(dict):
    """
    Specification for the Ranger Admin service.
    """
    def __init__(__self__, *,
                 admins: Sequence[str],
                 database: 'outputs.RangerAdminSpecResponseDatabase'):
        """
        Specification for the Ranger Admin service.
        :param Sequence[str] admins: List of usernames that should be marked as ranger admins. These usernames should match the user principal name (UPN) of the respective AAD users.
        """
        pulumi.set(__self__, "admins", admins)
        pulumi.set(__self__, "database", database)

    @property
    @pulumi.getter
    def admins(self) -> Sequence[str]:
        """
        List of usernames that should be marked as ranger admins. These usernames should match the user principal name (UPN) of the respective AAD users.
        """
        return pulumi.get(self, "admins")

    @property
    @pulumi.getter
    def database(self) -> 'outputs.RangerAdminSpecResponseDatabase':
        return pulumi.get(self, "database")


@pulumi.output_type
class RangerAdminSpecResponseDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordSecretRef":
            suggest = "password_secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RangerAdminSpecResponseDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RangerAdminSpecResponseDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RangerAdminSpecResponseDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 name: str,
                 password_secret_ref: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str host: The database URL
        :param str name: The database name
        :param str password_secret_ref: Reference for the database password
        :param str username: The name of the database user
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "name", name)
        if password_secret_ref is not None:
            pulumi.set(__self__, "password_secret_ref", password_secret_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The database URL
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The database name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="passwordSecretRef")
    def password_secret_ref(self) -> Optional[str]:
        """
        Reference for the database password
        """
        return pulumi.get(self, "password_secret_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The name of the database user
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class RangerAuditSpecResponse(dict):
    """
    Properties required to describe audit log storage.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccount":
            suggest = "storage_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RangerAuditSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RangerAuditSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RangerAuditSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_account: Optional[str] = None):
        """
        Properties required to describe audit log storage.
        :param str storage_account: Azure storage location of the blobs. MSI should have read/write access to this Storage account.
        """
        if storage_account is not None:
            pulumi.set(__self__, "storage_account", storage_account)

    @property
    @pulumi.getter(name="storageAccount")
    def storage_account(self) -> Optional[str]:
        """
        Azure storage location of the blobs. MSI should have read/write access to this Storage account.
        """
        return pulumi.get(self, "storage_account")


@pulumi.output_type
class RangerProfileResponse(dict):
    """
    The ranger cluster profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangerAdmin":
            suggest = "ranger_admin"
        elif key == "rangerUsersync":
            suggest = "ranger_usersync"
        elif key == "rangerAudit":
            suggest = "ranger_audit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RangerProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RangerProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RangerProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ranger_admin: 'outputs.RangerAdminSpecResponse',
                 ranger_usersync: 'outputs.RangerUsersyncSpecResponse',
                 ranger_audit: Optional['outputs.RangerAuditSpecResponse'] = None):
        """
        The ranger cluster profile.
        :param 'RangerAdminSpecResponse' ranger_admin: Specification for the Ranger Admin service.
        :param 'RangerUsersyncSpecResponse' ranger_usersync: Specification for the Ranger Usersync service
        :param 'RangerAuditSpecResponse' ranger_audit: Properties required to describe audit log storage.
        """
        pulumi.set(__self__, "ranger_admin", ranger_admin)
        pulumi.set(__self__, "ranger_usersync", ranger_usersync)
        if ranger_audit is not None:
            pulumi.set(__self__, "ranger_audit", ranger_audit)

    @property
    @pulumi.getter(name="rangerAdmin")
    def ranger_admin(self) -> 'outputs.RangerAdminSpecResponse':
        """
        Specification for the Ranger Admin service.
        """
        return pulumi.get(self, "ranger_admin")

    @property
    @pulumi.getter(name="rangerUsersync")
    def ranger_usersync(self) -> 'outputs.RangerUsersyncSpecResponse':
        """
        Specification for the Ranger Usersync service
        """
        return pulumi.get(self, "ranger_usersync")

    @property
    @pulumi.getter(name="rangerAudit")
    def ranger_audit(self) -> Optional['outputs.RangerAuditSpecResponse']:
        """
        Properties required to describe audit log storage.
        """
        return pulumi.get(self, "ranger_audit")


@pulumi.output_type
class RangerUsersyncSpecResponse(dict):
    """
    Specification for the Ranger Usersync service
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userMappingLocation":
            suggest = "user_mapping_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RangerUsersyncSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RangerUsersyncSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RangerUsersyncSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 groups: Optional[Sequence[str]] = None,
                 mode: Optional[str] = None,
                 user_mapping_location: Optional[str] = None,
                 users: Optional[Sequence[str]] = None):
        """
        Specification for the Ranger Usersync service
        :param bool enabled: Denotes whether usersync service should be enabled
        :param Sequence[str] groups: List of groups that should be synced. These group names should match the object id of the respective AAD groups.
        :param str mode: User & groups can be synced automatically or via a static list that's refreshed.
        :param str user_mapping_location: Azure storage location of a mapping file that lists user & group associations.
        :param Sequence[str] users: List of user names that should be synced. These usernames should match the User principal name of the respective AAD users.
        """
        if enabled is None:
            enabled = True
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if mode is None:
            mode = 'automatic'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if user_mapping_location is not None:
            pulumi.set(__self__, "user_mapping_location", user_mapping_location)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Denotes whether usersync service should be enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        List of groups that should be synced. These group names should match the object id of the respective AAD groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        User & groups can be synced automatically or via a static list that's refreshed.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="userMappingLocation")
    def user_mapping_location(self) -> Optional[str]:
        """
        Azure storage location of a mapping file that lists user & group associations.
        """
        return pulumi.get(self, "user_mapping_location")

    @property
    @pulumi.getter
    def users(self) -> Optional[Sequence[str]]:
        """
        List of user names that should be synced. These usernames should match the User principal name of the respective AAD users.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class ResourceIdResponse(dict):
    """
    The azure resource id.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        The azure resource id.
        :param str id: The azure resource id.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The azure resource id.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class RoleResponse(dict):
    """
    Describes a role on the cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscaleConfiguration":
            suggest = "autoscale_configuration"
        elif key == "dataDisksGroups":
            suggest = "data_disks_groups"
        elif key == "encryptDataDisks":
            suggest = "encrypt_data_disks"
        elif key == "hardwareProfile":
            suggest = "hardware_profile"
        elif key == "minInstanceCount":
            suggest = "min_instance_count"
        elif key == "osProfile":
            suggest = "os_profile"
        elif key == "scriptActions":
            suggest = "script_actions"
        elif key == "targetInstanceCount":
            suggest = "target_instance_count"
        elif key == "vMGroupName":
            suggest = "v_m_group_name"
        elif key == "virtualNetworkProfile":
            suggest = "virtual_network_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale_configuration: Optional['outputs.AutoscaleResponse'] = None,
                 data_disks_groups: Optional[Sequence['outputs.DataDisksGroupsResponse']] = None,
                 encrypt_data_disks: Optional[bool] = None,
                 hardware_profile: Optional['outputs.HardwareProfileResponse'] = None,
                 min_instance_count: Optional[int] = None,
                 name: Optional[str] = None,
                 os_profile: Optional['outputs.OsProfileResponse'] = None,
                 script_actions: Optional[Sequence['outputs.ScriptActionResponse']] = None,
                 target_instance_count: Optional[int] = None,
                 v_m_group_name: Optional[str] = None,
                 virtual_network_profile: Optional['outputs.VirtualNetworkProfileResponse'] = None):
        """
        Describes a role on the cluster.
        :param 'AutoscaleResponse' autoscale_configuration: The autoscale configurations.
        :param Sequence['DataDisksGroupsResponse'] data_disks_groups: The data disks groups for the role.
        :param bool encrypt_data_disks: Indicates whether encrypt the data disks.
        :param 'HardwareProfileResponse' hardware_profile: The hardware profile.
        :param int min_instance_count: The minimum instance count of the cluster.
        :param str name: The name of the role.
        :param 'OsProfileResponse' os_profile: The operating system profile.
        :param Sequence['ScriptActionResponse'] script_actions: The list of script actions on the role.
        :param int target_instance_count: The instance count of the cluster.
        :param str v_m_group_name: The name of the virtual machine group.
        :param 'VirtualNetworkProfileResponse' virtual_network_profile: The virtual network profile.
        """
        if autoscale_configuration is not None:
            pulumi.set(__self__, "autoscale_configuration", autoscale_configuration)
        if data_disks_groups is not None:
            pulumi.set(__self__, "data_disks_groups", data_disks_groups)
        if encrypt_data_disks is None:
            encrypt_data_disks = False
        if encrypt_data_disks is not None:
            pulumi.set(__self__, "encrypt_data_disks", encrypt_data_disks)
        if hardware_profile is not None:
            pulumi.set(__self__, "hardware_profile", hardware_profile)
        if min_instance_count is not None:
            pulumi.set(__self__, "min_instance_count", min_instance_count)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if os_profile is not None:
            pulumi.set(__self__, "os_profile", os_profile)
        if script_actions is not None:
            pulumi.set(__self__, "script_actions", script_actions)
        if target_instance_count is not None:
            pulumi.set(__self__, "target_instance_count", target_instance_count)
        if v_m_group_name is not None:
            pulumi.set(__self__, "v_m_group_name", v_m_group_name)
        if virtual_network_profile is not None:
            pulumi.set(__self__, "virtual_network_profile", virtual_network_profile)

    @property
    @pulumi.getter(name="autoscaleConfiguration")
    def autoscale_configuration(self) -> Optional['outputs.AutoscaleResponse']:
        """
        The autoscale configurations.
        """
        return pulumi.get(self, "autoscale_configuration")

    @property
    @pulumi.getter(name="dataDisksGroups")
    def data_disks_groups(self) -> Optional[Sequence['outputs.DataDisksGroupsResponse']]:
        """
        The data disks groups for the role.
        """
        return pulumi.get(self, "data_disks_groups")

    @property
    @pulumi.getter(name="encryptDataDisks")
    def encrypt_data_disks(self) -> Optional[bool]:
        """
        Indicates whether encrypt the data disks.
        """
        return pulumi.get(self, "encrypt_data_disks")

    @property
    @pulumi.getter(name="hardwareProfile")
    def hardware_profile(self) -> Optional['outputs.HardwareProfileResponse']:
        """
        The hardware profile.
        """
        return pulumi.get(self, "hardware_profile")

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> Optional[int]:
        """
        The minimum instance count of the cluster.
        """
        return pulumi.get(self, "min_instance_count")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the role.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="osProfile")
    def os_profile(self) -> Optional['outputs.OsProfileResponse']:
        """
        The operating system profile.
        """
        return pulumi.get(self, "os_profile")

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[Sequence['outputs.ScriptActionResponse']]:
        """
        The list of script actions on the role.
        """
        return pulumi.get(self, "script_actions")

    @property
    @pulumi.getter(name="targetInstanceCount")
    def target_instance_count(self) -> Optional[int]:
        """
        The instance count of the cluster.
        """
        return pulumi.get(self, "target_instance_count")

    @property
    @pulumi.getter(name="vMGroupName")
    def v_m_group_name(self) -> Optional[str]:
        """
        The name of the virtual machine group.
        """
        return pulumi.get(self, "v_m_group_name")

    @property
    @pulumi.getter(name="virtualNetworkProfile")
    def virtual_network_profile(self) -> Optional['outputs.VirtualNetworkProfileResponse']:
        """
        The virtual network profile.
        """
        return pulumi.get(self, "virtual_network_profile")


@pulumi.output_type
class RuntimeScriptActionResponse(dict):
    """
    Describes a script action on a running cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationName":
            suggest = "application_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeScriptActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeScriptActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeScriptActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_name: str,
                 name: str,
                 roles: Sequence[str],
                 uri: str,
                 parameters: Optional[str] = None):
        """
        Describes a script action on a running cluster.
        :param str application_name: The application name of the script action, if any.
        :param str name: The name of the script action.
        :param Sequence[str] roles: The list of roles where script will be executed.
        :param str uri: The URI to the script.
        :param str parameters: The parameters for the script
        """
        pulumi.set(__self__, "application_name", application_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "uri", uri)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> str:
        """
        The application name of the script action, if any.
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        """
        The list of roles where script will be executed.
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        The parameters for the script
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class ScalingRuleResponse(dict):
    """
    The scaling rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "comparisonRule":
            suggest = "comparison_rule"
        elif key == "evaluationCount":
            suggest = "evaluation_count"
        elif key == "scalingMetric":
            suggest = "scaling_metric"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: str,
                 comparison_rule: 'outputs.ComparisonRuleResponse',
                 evaluation_count: int,
                 scaling_metric: str):
        """
        The scaling rule.
        :param str action_type: The action type.
        :param 'ComparisonRuleResponse' comparison_rule: The comparison rule.
        :param int evaluation_count: This is an evaluation count for a scaling condition, the number of times a trigger condition should be successful, before scaling activity is triggered.
        :param str scaling_metric: Metrics name for individual workloads. For example: cpu
        """
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "comparison_rule", comparison_rule)
        pulumi.set(__self__, "evaluation_count", evaluation_count)
        pulumi.set(__self__, "scaling_metric", scaling_metric)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> str:
        """
        The action type.
        """
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="comparisonRule")
    def comparison_rule(self) -> 'outputs.ComparisonRuleResponse':
        """
        The comparison rule.
        """
        return pulumi.get(self, "comparison_rule")

    @property
    @pulumi.getter(name="evaluationCount")
    def evaluation_count(self) -> int:
        """
        This is an evaluation count for a scaling condition, the number of times a trigger condition should be successful, before scaling activity is triggered.
        """
        return pulumi.get(self, "evaluation_count")

    @property
    @pulumi.getter(name="scalingMetric")
    def scaling_metric(self) -> str:
        """
        Metrics name for individual workloads. For example: cpu
        """
        return pulumi.get(self, "scaling_metric")


@pulumi.output_type
class ScheduleBasedConfigResponse(dict):
    """
    Profile of schedule based Autoscale.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultCount":
            suggest = "default_count"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleBasedConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleBasedConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleBasedConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_count: int,
                 schedules: Sequence['outputs.ScheduleResponse'],
                 time_zone: str):
        """
        Profile of schedule based Autoscale.
        :param int default_count: Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)
        :param Sequence['ScheduleResponse'] schedules: This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).
        :param str time_zone: User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        """
        pulumi.set(__self__, "default_count", default_count)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="defaultCount")
    def default_count(self) -> int:
        """
        Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)
        """
        return pulumi.get(self, "default_count")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.ScheduleResponse']:
        """
        This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).
        """
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class ScheduleResponse(dict):
    """
    Schedule definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: int,
                 days: Sequence[str],
                 end_time: str,
                 start_time: str):
        """
        Schedule definition.
        :param int count: User has to set the node count anticipated at end of the scaling operation of the set current schedule configuration, format is integer.
        :param Sequence[str] days: User has to set the days where schedule has to be set for autoscale operation.
        :param str end_time: User has to set the end time of current schedule configuration, format like 10:30 (HH:MM).
        :param str start_time: User has to set the start time of current schedule configuration, format like 10:30 (HH:MM).
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        User has to set the node count anticipated at end of the scaling operation of the set current schedule configuration, format is integer.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def days(self) -> Sequence[str]:
        """
        User has to set the days where schedule has to be set for autoscale operation.
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        User has to set the end time of current schedule configuration, format like 10:30 (HH:MM).
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        User has to set the start time of current schedule configuration, format like 10:30 (HH:MM).
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ScriptActionProfileResponse(dict):
    """
    The script action profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shouldPersist":
            suggest = "should_persist"
        elif key == "timeoutInMinutes":
            suggest = "timeout_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScriptActionProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScriptActionProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScriptActionProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 services: Sequence[str],
                 type: str,
                 url: str,
                 parameters: Optional[str] = None,
                 should_persist: Optional[bool] = None,
                 timeout_in_minutes: Optional[int] = None):
        """
        The script action profile.
        :param str name: Script name.
        :param Sequence[str] services: List of services to apply the script action.
        :param str type: Type of the script action. Supported type is bash scripts.
        :param str url: Url of the script file.
        :param str parameters: Additional parameters for the script action. It should be space-separated list of arguments required for script execution.
        :param bool should_persist: Specify if the script should persist on the cluster.
        :param int timeout_in_minutes: Timeout duration for the script action in minutes.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if should_persist is None:
            should_persist = True
        if should_persist is not None:
            pulumi.set(__self__, "should_persist", should_persist)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Script name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def services(self) -> Sequence[str]:
        """
        List of services to apply the script action.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the script action. Supported type is bash scripts.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Url of the script file.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[str]:
        """
        Additional parameters for the script action. It should be space-separated list of arguments required for script execution.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="shouldPersist")
    def should_persist(self) -> Optional[bool]:
        """
        Specify if the script should persist on the cluster.
        """
        return pulumi.get(self, "should_persist")

    @property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[int]:
        """
        Timeout duration for the script action in minutes.
        """
        return pulumi.get(self, "timeout_in_minutes")


@pulumi.output_type
class ScriptActionResponse(dict):
    """
    Describes a script action on role on the cluster.
    """
    def __init__(__self__, *,
                 name: str,
                 parameters: str,
                 uri: str):
        """
        Describes a script action on role on the cluster.
        :param str name: The name of the script action.
        :param str parameters: The parameters for the script provided.
        :param str uri: The URI to the script.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> str:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class SecretReferenceResponse(dict):
    """
    Secret reference and corresponding properties of a key vault secret.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultObjectName":
            suggest = "key_vault_object_name"
        elif key == "referenceName":
            suggest = "reference_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_object_name: str,
                 reference_name: str,
                 type: str,
                 version: Optional[str] = None):
        """
        Secret reference and corresponding properties of a key vault secret.
        :param str key_vault_object_name: Object identifier name of the secret in key vault.
        :param str reference_name: Reference name of the secret to be used in service configs.
        :param str type: Type of key vault object: secret, key or certificate.
        :param str version: Version of the secret in key vault.
        """
        pulumi.set(__self__, "key_vault_object_name", key_vault_object_name)
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="keyVaultObjectName")
    def key_vault_object_name(self) -> str:
        """
        Object identifier name of the secret in key vault.
        """
        return pulumi.get(self, "key_vault_object_name")

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> str:
        """
        Reference name of the secret to be used in service configs.
        """
        return pulumi.get(self, "reference_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of key vault object: secret, key or certificate.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the secret in key vault.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SecretsProfileResponse(dict):
    """
    The cluster secret profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultResourceId":
            suggest = "key_vault_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretsProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretsProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretsProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_resource_id: str,
                 secrets: Optional[Sequence['outputs.SecretReferenceResponse']] = None):
        """
        The cluster secret profile.
        :param str key_vault_resource_id: Name of the user Key Vault where all the cluster specific user secrets are stored.
        :param Sequence['SecretReferenceResponse'] secrets: Properties of Key Vault secret.
        """
        pulumi.set(__self__, "key_vault_resource_id", key_vault_resource_id)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> str:
        """
        Name of the user Key Vault where all the cluster specific user secrets are stored.
        """
        return pulumi.get(self, "key_vault_resource_id")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.SecretReferenceResponse']]:
        """
        Properties of Key Vault secret.
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class SecurityProfileResponse(dict):
    """
    The security profile which contains Ssh public key for the HDInsight cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aaddsResourceId":
            suggest = "aadds_resource_id"
        elif key == "clusterUsersGroupDNs":
            suggest = "cluster_users_group_dns"
        elif key == "directoryType":
            suggest = "directory_type"
        elif key == "domainUserPassword":
            suggest = "domain_user_password"
        elif key == "domainUsername":
            suggest = "domain_username"
        elif key == "ldapsUrls":
            suggest = "ldaps_urls"
        elif key == "msiResourceId":
            suggest = "msi_resource_id"
        elif key == "organizationalUnitDN":
            suggest = "organizational_unit_dn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aadds_resource_id: Optional[str] = None,
                 cluster_users_group_dns: Optional[Sequence[str]] = None,
                 directory_type: Optional[str] = None,
                 domain: Optional[str] = None,
                 domain_user_password: Optional[str] = None,
                 domain_username: Optional[str] = None,
                 ldaps_urls: Optional[Sequence[str]] = None,
                 msi_resource_id: Optional[str] = None,
                 organizational_unit_dn: Optional[str] = None):
        """
        The security profile which contains Ssh public key for the HDInsight cluster.
        :param str aadds_resource_id: The resource ID of the user's Azure Active Directory Domain Service.
        :param Sequence[str] cluster_users_group_dns: Optional. The Distinguished Names for cluster user groups
        :param str directory_type: The directory type.
        :param str domain: The organization's active directory domain.
        :param str domain_user_password: The domain admin password.
        :param str domain_username: The domain user account that will have admin privileges on the cluster.
        :param Sequence[str] ldaps_urls: The LDAPS protocol URLs to communicate with the Active Directory.
        :param str msi_resource_id: User assigned identity that has permissions to read and create cluster-related artifacts in the user's AADDS.
        :param str organizational_unit_dn: The organizational unit within the Active Directory to place the cluster and service accounts.
        """
        if aadds_resource_id is not None:
            pulumi.set(__self__, "aadds_resource_id", aadds_resource_id)
        if cluster_users_group_dns is not None:
            pulumi.set(__self__, "cluster_users_group_dns", cluster_users_group_dns)
        if directory_type is not None:
            pulumi.set(__self__, "directory_type", directory_type)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if domain_user_password is not None:
            pulumi.set(__self__, "domain_user_password", domain_user_password)
        if domain_username is not None:
            pulumi.set(__self__, "domain_username", domain_username)
        if ldaps_urls is not None:
            pulumi.set(__self__, "ldaps_urls", ldaps_urls)
        if msi_resource_id is not None:
            pulumi.set(__self__, "msi_resource_id", msi_resource_id)
        if organizational_unit_dn is not None:
            pulumi.set(__self__, "organizational_unit_dn", organizational_unit_dn)

    @property
    @pulumi.getter(name="aaddsResourceId")
    def aadds_resource_id(self) -> Optional[str]:
        """
        The resource ID of the user's Azure Active Directory Domain Service.
        """
        return pulumi.get(self, "aadds_resource_id")

    @property
    @pulumi.getter(name="clusterUsersGroupDNs")
    def cluster_users_group_dns(self) -> Optional[Sequence[str]]:
        """
        Optional. The Distinguished Names for cluster user groups
        """
        return pulumi.get(self, "cluster_users_group_dns")

    @property
    @pulumi.getter(name="directoryType")
    def directory_type(self) -> Optional[str]:
        """
        The directory type.
        """
        return pulumi.get(self, "directory_type")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The organization's active directory domain.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="domainUserPassword")
    def domain_user_password(self) -> Optional[str]:
        """
        The domain admin password.
        """
        return pulumi.get(self, "domain_user_password")

    @property
    @pulumi.getter(name="domainUsername")
    def domain_username(self) -> Optional[str]:
        """
        The domain user account that will have admin privileges on the cluster.
        """
        return pulumi.get(self, "domain_username")

    @property
    @pulumi.getter(name="ldapsUrls")
    def ldaps_urls(self) -> Optional[Sequence[str]]:
        """
        The LDAPS protocol URLs to communicate with the Active Directory.
        """
        return pulumi.get(self, "ldaps_urls")

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> Optional[str]:
        """
        User assigned identity that has permissions to read and create cluster-related artifacts in the user's AADDS.
        """
        return pulumi.get(self, "msi_resource_id")

    @property
    @pulumi.getter(name="organizationalUnitDN")
    def organizational_unit_dn(self) -> Optional[str]:
        """
        The organizational unit within the Active Directory to place the cluster and service accounts.
        """
        return pulumi.get(self, "organizational_unit_dn")


@pulumi.output_type
class SparkMetastoreSpecResponse(dict):
    """
    The metastore specification for Spark cluster.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "dbServerHost":
            suggest = "db_server_host"
        elif key == "dbConnectionAuthenticationMode":
            suggest = "db_connection_authentication_mode"
        elif key == "dbPasswordSecretName":
            suggest = "db_password_secret_name"
        elif key == "dbUserName":
            suggest = "db_user_name"
        elif key == "keyVaultId":
            suggest = "key_vault_id"
        elif key == "thriftUrl":
            suggest = "thrift_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkMetastoreSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkMetastoreSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkMetastoreSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: str,
                 db_server_host: str,
                 db_connection_authentication_mode: Optional[str] = None,
                 db_password_secret_name: Optional[str] = None,
                 db_user_name: Optional[str] = None,
                 key_vault_id: Optional[str] = None,
                 thrift_url: Optional[str] = None):
        """
        The metastore specification for Spark cluster.
        :param str db_name: The database name.
        :param str db_server_host: The database server host.
        :param str db_connection_authentication_mode: The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        :param str db_password_secret_name: The secret name which contains the database user password.
        :param str db_user_name: The database user name.
        :param str key_vault_id: The key vault resource id.
        :param str thrift_url: The thrift url.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_server_host", db_server_host)
        if db_connection_authentication_mode is None:
            db_connection_authentication_mode = 'IdentityAuth'
        if db_connection_authentication_mode is not None:
            pulumi.set(__self__, "db_connection_authentication_mode", db_connection_authentication_mode)
        if db_password_secret_name is not None:
            pulumi.set(__self__, "db_password_secret_name", db_password_secret_name)
        if db_user_name is not None:
            pulumi.set(__self__, "db_user_name", db_user_name)
        if key_vault_id is not None:
            pulumi.set(__self__, "key_vault_id", key_vault_id)
        if thrift_url is not None:
            pulumi.set(__self__, "thrift_url", thrift_url)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        """
        The database name.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="dbServerHost")
    def db_server_host(self) -> str:
        """
        The database server host.
        """
        return pulumi.get(self, "db_server_host")

    @property
    @pulumi.getter(name="dbConnectionAuthenticationMode")
    def db_connection_authentication_mode(self) -> Optional[str]:
        """
        The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        """
        return pulumi.get(self, "db_connection_authentication_mode")

    @property
    @pulumi.getter(name="dbPasswordSecretName")
    def db_password_secret_name(self) -> Optional[str]:
        """
        The secret name which contains the database user password.
        """
        return pulumi.get(self, "db_password_secret_name")

    @property
    @pulumi.getter(name="dbUserName")
    def db_user_name(self) -> Optional[str]:
        """
        The database user name.
        """
        return pulumi.get(self, "db_user_name")

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> Optional[str]:
        """
        The key vault resource id.
        """
        return pulumi.get(self, "key_vault_id")

    @property
    @pulumi.getter(name="thriftUrl")
    def thrift_url(self) -> Optional[str]:
        """
        The thrift url.
        """
        return pulumi.get(self, "thrift_url")


@pulumi.output_type
class SparkProfileResponse(dict):
    """
    The spark cluster profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultStorageUrl":
            suggest = "default_storage_url"
        elif key == "metastoreSpec":
            suggest = "metastore_spec"
        elif key == "userPluginsSpec":
            suggest = "user_plugins_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SparkProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SparkProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SparkProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_storage_url: Optional[str] = None,
                 metastore_spec: Optional['outputs.SparkMetastoreSpecResponse'] = None,
                 user_plugins_spec: Optional['outputs.SparkUserPluginsResponse'] = None):
        """
        The spark cluster profile.
        :param str default_storage_url: The default storage URL.
        :param 'SparkMetastoreSpecResponse' metastore_spec: The metastore specification for Spark cluster.
        :param 'SparkUserPluginsResponse' user_plugins_spec: Spark user plugins spec
        """
        if default_storage_url is not None:
            pulumi.set(__self__, "default_storage_url", default_storage_url)
        if metastore_spec is not None:
            pulumi.set(__self__, "metastore_spec", metastore_spec)
        if user_plugins_spec is not None:
            pulumi.set(__self__, "user_plugins_spec", user_plugins_spec)

    @property
    @pulumi.getter(name="defaultStorageUrl")
    def default_storage_url(self) -> Optional[str]:
        """
        The default storage URL.
        """
        return pulumi.get(self, "default_storage_url")

    @property
    @pulumi.getter(name="metastoreSpec")
    def metastore_spec(self) -> Optional['outputs.SparkMetastoreSpecResponse']:
        """
        The metastore specification for Spark cluster.
        """
        return pulumi.get(self, "metastore_spec")

    @property
    @pulumi.getter(name="userPluginsSpec")
    def user_plugins_spec(self) -> Optional['outputs.SparkUserPluginsResponse']:
        """
        Spark user plugins spec
        """
        return pulumi.get(self, "user_plugins_spec")


@pulumi.output_type
class SparkUserPluginResponse(dict):
    """
    Spark user plugin.
    """
    def __init__(__self__, *,
                 path: str):
        """
        Spark user plugin.
        :param str path: Fully qualified path to the folder containing the plugins.
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Fully qualified path to the folder containing the plugins.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class SparkUserPluginsResponse(dict):
    """
    Spark user plugins spec
    """
    def __init__(__self__, *,
                 plugins: Optional[Sequence['outputs.SparkUserPluginResponse']] = None):
        """
        Spark user plugins spec
        :param Sequence['SparkUserPluginResponse'] plugins: Spark user plugins.
        """
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[Sequence['outputs.SparkUserPluginResponse']]:
        """
        Spark user plugins.
        """
        return pulumi.get(self, "plugins")


@pulumi.output_type
class SshConnectivityEndpointResponse(dict):
    """
    SSH connectivity endpoint details.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateSshEndpoint":
            suggest = "private_ssh_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SshConnectivityEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SshConnectivityEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SshConnectivityEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 private_ssh_endpoint: Optional[str] = None):
        """
        SSH connectivity endpoint details.
        :param str endpoint: SSH connectivity endpoint.
        :param str private_ssh_endpoint: Private SSH connectivity endpoint. This property will only be returned when enableInternalIngress is true.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if private_ssh_endpoint is not None:
            pulumi.set(__self__, "private_ssh_endpoint", private_ssh_endpoint)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        SSH connectivity endpoint.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="privateSshEndpoint")
    def private_ssh_endpoint(self) -> Optional[str]:
        """
        Private SSH connectivity endpoint. This property will only be returned when enableInternalIngress is true.
        """
        return pulumi.get(self, "private_ssh_endpoint")


@pulumi.output_type
class SshProfileResponse(dict):
    """
    The list of SSH public keys.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicKeys":
            suggest = "public_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SshProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SshProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SshProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_keys: Optional[Sequence['outputs.SshPublicKeyResponse']] = None):
        """
        The list of SSH public keys.
        :param Sequence['SshPublicKeyResponse'] public_keys: The list of SSH public keys.
        """
        if public_keys is not None:
            pulumi.set(__self__, "public_keys", public_keys)

    @property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Optional[Sequence['outputs.SshPublicKeyResponse']]:
        """
        The list of SSH public keys.
        """
        return pulumi.get(self, "public_keys")


@pulumi.output_type
class SshPublicKeyResponse(dict):
    """
    The SSH public key for the cluster nodes.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateData":
            suggest = "certificate_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SshPublicKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SshPublicKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SshPublicKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_data: Optional[str] = None):
        """
        The SSH public key for the cluster nodes.
        :param str certificate_data: The certificate for SSH.
        """
        if certificate_data is not None:
            pulumi.set(__self__, "certificate_data", certificate_data)

    @property
    @pulumi.getter(name="certificateData")
    def certificate_data(self) -> Optional[str]:
        """
        The certificate for SSH.
        """
        return pulumi.get(self, "certificate_data")


@pulumi.output_type
class StorageAccountResponse(dict):
    """
    The storage Account.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableSecureChannel":
            suggest = "enable_secure_channel"
        elif key == "fileSystem":
            suggest = "file_system"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "msiResourceId":
            suggest = "msi_resource_id"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageAccountResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageAccountResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageAccountResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: Optional[str] = None,
                 enable_secure_channel: Optional[bool] = None,
                 file_system: Optional[str] = None,
                 fileshare: Optional[str] = None,
                 is_default: Optional[bool] = None,
                 key: Optional[str] = None,
                 msi_resource_id: Optional[str] = None,
                 name: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 saskey: Optional[str] = None):
        """
        The storage Account.
        :param str container: The container in the storage account, only to be specified for WASB storage accounts.
        :param bool enable_secure_channel: Enable secure channel or not, it's an optional field. Default value is false when cluster version < 5.1 and true when cluster version >= 5.1 , 
        :param str file_system: The filesystem, only to be specified for Azure Data Lake Storage Gen 2.
        :param str fileshare: The file share name.
        :param bool is_default: Whether or not the storage account is the default storage account.
        :param str key: The storage account access key.
        :param str msi_resource_id: The managed identity (MSI) that is allowed to access the storage account, only to be specified for Azure Data Lake Storage Gen 2.
        :param str name: The name of the storage account.
        :param str resource_id: The resource ID of storage account, only to be specified for Azure Data Lake Storage Gen 2.
        :param str saskey: The shared access signature key.
        """
        if container is not None:
            pulumi.set(__self__, "container", container)
        if enable_secure_channel is not None:
            pulumi.set(__self__, "enable_secure_channel", enable_secure_channel)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if fileshare is not None:
            pulumi.set(__self__, "fileshare", fileshare)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if msi_resource_id is not None:
            pulumi.set(__self__, "msi_resource_id", msi_resource_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if saskey is not None:
            pulumi.set(__self__, "saskey", saskey)

    @property
    @pulumi.getter
    def container(self) -> Optional[str]:
        """
        The container in the storage account, only to be specified for WASB storage accounts.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="enableSecureChannel")
    def enable_secure_channel(self) -> Optional[bool]:
        """
        Enable secure channel or not, it's an optional field. Default value is false when cluster version < 5.1 and true when cluster version >= 5.1 , 
        """
        return pulumi.get(self, "enable_secure_channel")

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[str]:
        """
        The filesystem, only to be specified for Azure Data Lake Storage Gen 2.
        """
        return pulumi.get(self, "file_system")

    @property
    @pulumi.getter
    def fileshare(self) -> Optional[str]:
        """
        The file share name.
        """
        return pulumi.get(self, "fileshare")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[bool]:
        """
        Whether or not the storage account is the default storage account.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The storage account access key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> Optional[str]:
        """
        The managed identity (MSI) that is allowed to access the storage account, only to be specified for Azure Data Lake Storage Gen 2.
        """
        return pulumi.get(self, "msi_resource_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the storage account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        The resource ID of storage account, only to be specified for Azure Data Lake Storage Gen 2.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def saskey(self) -> Optional[str]:
        """
        The shared access signature key.
        """
        return pulumi.get(self, "saskey")


@pulumi.output_type
class StorageProfileResponse(dict):
    """
    The storage profile.
    """
    def __init__(__self__, *,
                 storageaccounts: Optional[Sequence['outputs.StorageAccountResponse']] = None):
        """
        The storage profile.
        :param Sequence['StorageAccountResponse'] storageaccounts: The list of storage accounts in the cluster.
        """
        if storageaccounts is not None:
            pulumi.set(__self__, "storageaccounts", storageaccounts)

    @property
    @pulumi.getter
    def storageaccounts(self) -> Optional[Sequence['outputs.StorageAccountResponse']]:
        """
        The list of storage accounts in the cluster.
        """
        return pulumi.get(self, "storageaccounts")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TrinoCoordinatorResponse(dict):
    """
    Trino Coordinator.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highAvailabilityEnabled":
            suggest = "high_availability_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrinoCoordinatorResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrinoCoordinatorResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrinoCoordinatorResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 high_availability_enabled: Optional[bool] = None,
                 port: Optional[int] = None,
                 suspend: Optional[bool] = None):
        """
        Trino Coordinator.
        :param bool enable: The flag that if enable debug or not.
        :param bool high_availability_enabled: The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.
        :param int port: The debug port.
        :param bool suspend: The flag that if suspend debug or not.
        """
        if enable is None:
            enable = False
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if high_availability_enabled is None:
            high_availability_enabled = True
        if high_availability_enabled is not None:
            pulumi.set(__self__, "high_availability_enabled", high_availability_enabled)
        if port is None:
            port = 8008
        if port is not None:
            pulumi.set(__self__, "port", port)
        if suspend is None:
            suspend = False
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        The flag that if enable debug or not.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="highAvailabilityEnabled")
    def high_availability_enabled(self) -> Optional[bool]:
        """
        The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.
        """
        return pulumi.get(self, "high_availability_enabled")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The debug port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[bool]:
        """
        The flag that if suspend debug or not.
        """
        return pulumi.get(self, "suspend")


@pulumi.output_type
class TrinoProfileResponse(dict):
    """
    Trino Cluster profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogOptions":
            suggest = "catalog_options"
        elif key == "userPluginsSpec":
            suggest = "user_plugins_spec"
        elif key == "userTelemetrySpec":
            suggest = "user_telemetry_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrinoProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrinoProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrinoProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_options: Optional['outputs.CatalogOptionsResponse'] = None,
                 coordinator: Optional['outputs.TrinoCoordinatorResponse'] = None,
                 user_plugins_spec: Optional['outputs.TrinoUserPluginsResponse'] = None,
                 user_telemetry_spec: Optional['outputs.TrinoUserTelemetryResponse'] = None,
                 worker: Optional['outputs.TrinoWorkerResponse'] = None):
        """
        Trino Cluster profile.
        :param 'CatalogOptionsResponse' catalog_options: Trino cluster catalog options.
        :param 'TrinoCoordinatorResponse' coordinator: Trino Coordinator.
        :param 'TrinoUserPluginsResponse' user_plugins_spec: Trino user plugins spec
        :param 'TrinoUserTelemetryResponse' user_telemetry_spec: User telemetry
        :param 'TrinoWorkerResponse' worker: Trino worker.
        """
        if catalog_options is not None:
            pulumi.set(__self__, "catalog_options", catalog_options)
        if coordinator is not None:
            pulumi.set(__self__, "coordinator", coordinator)
        if user_plugins_spec is not None:
            pulumi.set(__self__, "user_plugins_spec", user_plugins_spec)
        if user_telemetry_spec is not None:
            pulumi.set(__self__, "user_telemetry_spec", user_telemetry_spec)
        if worker is not None:
            pulumi.set(__self__, "worker", worker)

    @property
    @pulumi.getter(name="catalogOptions")
    def catalog_options(self) -> Optional['outputs.CatalogOptionsResponse']:
        """
        Trino cluster catalog options.
        """
        return pulumi.get(self, "catalog_options")

    @property
    @pulumi.getter
    def coordinator(self) -> Optional['outputs.TrinoCoordinatorResponse']:
        """
        Trino Coordinator.
        """
        return pulumi.get(self, "coordinator")

    @property
    @pulumi.getter(name="userPluginsSpec")
    def user_plugins_spec(self) -> Optional['outputs.TrinoUserPluginsResponse']:
        """
        Trino user plugins spec
        """
        return pulumi.get(self, "user_plugins_spec")

    @property
    @pulumi.getter(name="userTelemetrySpec")
    def user_telemetry_spec(self) -> Optional['outputs.TrinoUserTelemetryResponse']:
        """
        User telemetry
        """
        return pulumi.get(self, "user_telemetry_spec")

    @property
    @pulumi.getter
    def worker(self) -> Optional['outputs.TrinoWorkerResponse']:
        """
        Trino worker.
        """
        return pulumi.get(self, "worker")


@pulumi.output_type
class TrinoTelemetryConfigResponse(dict):
    """
    Trino user telemetry definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hivecatalogName":
            suggest = "hivecatalog_name"
        elif key == "hivecatalogSchema":
            suggest = "hivecatalog_schema"
        elif key == "partitionRetentionInDays":
            suggest = "partition_retention_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrinoTelemetryConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrinoTelemetryConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrinoTelemetryConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hivecatalog_name: Optional[str] = None,
                 hivecatalog_schema: Optional[str] = None,
                 partition_retention_in_days: Optional[int] = None,
                 path: Optional[str] = None):
        """
        Trino user telemetry definition.
        :param str hivecatalog_name: Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        :param str hivecatalog_schema: Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.
        :param int partition_retention_in_days: Retention period for query log table partitions, this doesn't have any affect on actual data.
        :param str path: Azure storage location of the blobs.
        """
        if hivecatalog_name is not None:
            pulumi.set(__self__, "hivecatalog_name", hivecatalog_name)
        if hivecatalog_schema is None:
            hivecatalog_schema = 'trinologs'
        if hivecatalog_schema is not None:
            pulumi.set(__self__, "hivecatalog_schema", hivecatalog_schema)
        if partition_retention_in_days is None:
            partition_retention_in_days = 365
        if partition_retention_in_days is not None:
            pulumi.set(__self__, "partition_retention_in_days", partition_retention_in_days)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="hivecatalogName")
    def hivecatalog_name(self) -> Optional[str]:
        """
        Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        """
        return pulumi.get(self, "hivecatalog_name")

    @property
    @pulumi.getter(name="hivecatalogSchema")
    def hivecatalog_schema(self) -> Optional[str]:
        """
        Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.
        """
        return pulumi.get(self, "hivecatalog_schema")

    @property
    @pulumi.getter(name="partitionRetentionInDays")
    def partition_retention_in_days(self) -> Optional[int]:
        """
        Retention period for query log table partitions, this doesn't have any affect on actual data.
        """
        return pulumi.get(self, "partition_retention_in_days")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Azure storage location of the blobs.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class TrinoUserPluginResponse(dict):
    """
    Trino user plugin.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 path: Optional[str] = None):
        """
        Trino user plugin.
        :param bool enabled: Denotes whether the plugin is active or not.
        :param str name: This field maps to the sub-directory in trino plugins location, that will contain all the plugins under path.
        :param str path: Fully qualified path to the folder containing the plugins.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Denotes whether the plugin is active or not.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        This field maps to the sub-directory in trino plugins location, that will contain all the plugins under path.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Fully qualified path to the folder containing the plugins.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class TrinoUserPluginsResponse(dict):
    """
    Trino user plugins spec
    """
    def __init__(__self__, *,
                 plugins: Optional[Sequence['outputs.TrinoUserPluginResponse']] = None):
        """
        Trino user plugins spec
        :param Sequence['TrinoUserPluginResponse'] plugins: Trino user plugins.
        """
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[Sequence['outputs.TrinoUserPluginResponse']]:
        """
        Trino user plugins.
        """
        return pulumi.get(self, "plugins")


@pulumi.output_type
class TrinoUserTelemetryResponse(dict):
    """
    User telemetry
    """
    def __init__(__self__, *,
                 storage: Optional['outputs.TrinoTelemetryConfigResponse'] = None):
        """
        User telemetry
        :param 'TrinoTelemetryConfigResponse' storage: Trino user telemetry definition.
        """
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def storage(self) -> Optional['outputs.TrinoTelemetryConfigResponse']:
        """
        Trino user telemetry definition.
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class TrinoWorkerResponse(dict):
    """
    Trino worker.
    """
    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 port: Optional[int] = None,
                 suspend: Optional[bool] = None):
        """
        Trino worker.
        :param bool enable: The flag that if enable debug or not.
        :param int port: The debug port.
        :param bool suspend: The flag that if suspend debug or not.
        """
        if enable is None:
            enable = False
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if port is None:
            port = 8008
        if port is not None:
            pulumi.set(__self__, "port", port)
        if suspend is None:
            suspend = False
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        """
        The flag that if enable debug or not.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The debug port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[bool]:
        """
        The flag that if suspend debug or not.
        """
        return pulumi.get(self, "suspend")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    The User Assigned Identity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str,
                 tenant_id: Optional[str] = None):
        """
        The User Assigned Identity
        :param str client_id: The client id of user assigned identity.
        :param str principal_id: The principal id of user assigned identity.
        :param str tenant_id: The tenant id of user assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client id of user assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal id of user assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The tenant id of user assigned identity.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class VirtualNetworkProfileResponse(dict):
    """
    The virtual network properties.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 subnet: Optional[str] = None):
        """
        The virtual network properties.
        :param str id: The ID of the virtual network.
        :param str subnet: The name of the subnet.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the virtual network.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def subnet(self) -> Optional[str]:
        """
        The name of the subnet.
        """
        return pulumi.get(self, "subnet")


