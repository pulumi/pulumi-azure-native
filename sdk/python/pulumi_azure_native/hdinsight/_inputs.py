# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ApplicationGetEndpointArgs',
    'ApplicationGetEndpointArgsDict',
    'ApplicationGetHttpsEndpointArgs',
    'ApplicationGetHttpsEndpointArgsDict',
    'ApplicationPropertiesArgs',
    'ApplicationPropertiesArgsDict',
    'AuthorizationProfileArgs',
    'AuthorizationProfileArgsDict',
    'AutoscaleCapacityArgs',
    'AutoscaleCapacityArgsDict',
    'AutoscaleProfileArgs',
    'AutoscaleProfileArgsDict',
    'AutoscaleRecurrenceArgs',
    'AutoscaleRecurrenceArgsDict',
    'AutoscaleScheduleArgs',
    'AutoscaleScheduleArgsDict',
    'AutoscaleTimeAndCapacityArgs',
    'AutoscaleTimeAndCapacityArgsDict',
    'AutoscaleArgs',
    'AutoscaleArgsDict',
    'CatalogOptionsArgs',
    'CatalogOptionsArgsDict',
    'ClientGroupInfoArgs',
    'ClientGroupInfoArgsDict',
    'ClusterAccessProfileArgs',
    'ClusterAccessProfileArgsDict',
    'ClusterConfigFileArgs',
    'ClusterConfigFileArgsDict',
    'ClusterCreatePropertiesArgs',
    'ClusterCreatePropertiesArgsDict',
    'ClusterDefinitionArgs',
    'ClusterDefinitionArgsDict',
    'ClusterIdentityArgs',
    'ClusterIdentityArgsDict',
    'ClusterLogAnalyticsApplicationLogsArgs',
    'ClusterLogAnalyticsApplicationLogsArgsDict',
    'ClusterLogAnalyticsProfileArgs',
    'ClusterLogAnalyticsProfileArgsDict',
    'ClusterPoolComputeProfileArgs',
    'ClusterPoolComputeProfileArgsDict',
    'ClusterPoolResourcePropertiesClusterPoolProfileArgs',
    'ClusterPoolResourcePropertiesClusterPoolProfileArgsDict',
    'ClusterPoolResourcePropertiesComputeProfileArgs',
    'ClusterPoolResourcePropertiesComputeProfileArgsDict',
    'ClusterPoolResourcePropertiesLogAnalyticsProfileArgs',
    'ClusterPoolResourcePropertiesLogAnalyticsProfileArgsDict',
    'ClusterPoolResourcePropertiesNetworkProfileArgs',
    'ClusterPoolResourcePropertiesNetworkProfileArgsDict',
    'ClusterPoolSshProfileArgs',
    'ClusterPoolSshProfileArgsDict',
    'ClusterProfileArgs',
    'ClusterProfileArgsDict',
    'ClusterPrometheusProfileArgs',
    'ClusterPrometheusProfileArgsDict',
    'ClusterRangerPluginProfileArgs',
    'ClusterRangerPluginProfileArgsDict',
    'ClusterServiceConfigsProfileArgs',
    'ClusterServiceConfigsProfileArgsDict',
    'ClusterServiceConfigArgs',
    'ClusterServiceConfigArgsDict',
    'ComparisonRuleArgs',
    'ComparisonRuleArgsDict',
    'ComputeIsolationPropertiesArgs',
    'ComputeIsolationPropertiesArgsDict',
    'ComputeProfileArgs',
    'ComputeProfileArgsDict',
    'ComputeResourceDefinitionArgs',
    'ComputeResourceDefinitionArgsDict',
    'DataDisksGroupsArgs',
    'DataDisksGroupsArgsDict',
    'DiskEncryptionPropertiesArgs',
    'DiskEncryptionPropertiesArgsDict',
    'DiskStorageProfileArgs',
    'DiskStorageProfileArgsDict',
    'EncryptionInTransitPropertiesArgs',
    'EncryptionInTransitPropertiesArgsDict',
    'ErrorsArgs',
    'ErrorsArgsDict',
    'FlinkCatalogOptionsArgs',
    'FlinkCatalogOptionsArgsDict',
    'FlinkHiveCatalogOptionArgs',
    'FlinkHiveCatalogOptionArgsDict',
    'FlinkJobProfileArgs',
    'FlinkJobProfileArgsDict',
    'FlinkProfileArgs',
    'FlinkProfileArgsDict',
    'FlinkStorageProfileArgs',
    'FlinkStorageProfileArgsDict',
    'HardwareProfileArgs',
    'HardwareProfileArgsDict',
    'HiveCatalogOptionArgs',
    'HiveCatalogOptionArgsDict',
    'IPConfigurationArgs',
    'IPConfigurationArgsDict',
    'IdentityProfileArgs',
    'IdentityProfileArgsDict',
    'IpTagArgs',
    'IpTagArgsDict',
    'KafkaProfileArgs',
    'KafkaProfileArgsDict',
    'KafkaRestPropertiesArgs',
    'KafkaRestPropertiesArgsDict',
    'LinuxOperatingSystemProfileArgs',
    'LinuxOperatingSystemProfileArgsDict',
    'LoadBasedConfigArgs',
    'LoadBasedConfigArgsDict',
    'ManagedIdentityProfileArgs',
    'ManagedIdentityProfileArgsDict',
    'ManagedIdentitySpecArgs',
    'ManagedIdentitySpecArgsDict',
    'NetworkPropertiesArgs',
    'NetworkPropertiesArgsDict',
    'NodeProfileArgs',
    'NodeProfileArgsDict',
    'OsProfileArgs',
    'OsProfileArgsDict',
    'PrivateLinkConfigurationArgs',
    'PrivateLinkConfigurationArgsDict',
    'PrivateLinkServiceConnectionStateArgs',
    'PrivateLinkServiceConnectionStateArgsDict',
    'RangerAdminSpecDatabaseArgs',
    'RangerAdminSpecDatabaseArgsDict',
    'RangerAdminSpecArgs',
    'RangerAdminSpecArgsDict',
    'RangerAuditSpecArgs',
    'RangerAuditSpecArgsDict',
    'RangerProfileArgs',
    'RangerProfileArgsDict',
    'RangerUsersyncSpecArgs',
    'RangerUsersyncSpecArgsDict',
    'ResourceIdArgs',
    'ResourceIdArgsDict',
    'RoleArgs',
    'RoleArgsDict',
    'RuntimeScriptActionArgs',
    'RuntimeScriptActionArgsDict',
    'ScalingRuleArgs',
    'ScalingRuleArgsDict',
    'ScheduleBasedConfigArgs',
    'ScheduleBasedConfigArgsDict',
    'ScheduleArgs',
    'ScheduleArgsDict',
    'ScriptActionProfileArgs',
    'ScriptActionProfileArgsDict',
    'ScriptActionArgs',
    'ScriptActionArgsDict',
    'SecretReferenceArgs',
    'SecretReferenceArgsDict',
    'SecretsProfileArgs',
    'SecretsProfileArgsDict',
    'SecurityProfileArgs',
    'SecurityProfileArgsDict',
    'SparkMetastoreSpecArgs',
    'SparkMetastoreSpecArgsDict',
    'SparkProfileArgs',
    'SparkProfileArgsDict',
    'SparkUserPluginsArgs',
    'SparkUserPluginsArgsDict',
    'SparkUserPluginArgs',
    'SparkUserPluginArgsDict',
    'SshProfileArgs',
    'SshProfileArgsDict',
    'SshPublicKeyArgs',
    'SshPublicKeyArgsDict',
    'StorageAccountArgs',
    'StorageAccountArgsDict',
    'StorageProfileArgs',
    'StorageProfileArgsDict',
    'TrinoCoordinatorArgs',
    'TrinoCoordinatorArgsDict',
    'TrinoProfileArgs',
    'TrinoProfileArgsDict',
    'TrinoTelemetryConfigArgs',
    'TrinoTelemetryConfigArgsDict',
    'TrinoUserPluginsArgs',
    'TrinoUserPluginsArgsDict',
    'TrinoUserPluginArgs',
    'TrinoUserPluginArgsDict',
    'TrinoUserTelemetryArgs',
    'TrinoUserTelemetryArgsDict',
    'TrinoWorkerArgs',
    'TrinoWorkerArgsDict',
    'UserAssignedIdentityArgs',
    'UserAssignedIdentityArgsDict',
    'VirtualNetworkProfileArgs',
    'VirtualNetworkProfileArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationGetEndpointArgsDict(TypedDict):
        """
        Gets the application SSH endpoint
        """
        destination_port: NotRequired[pulumi.Input[int]]
        """
        The destination port to connect to.
        """
        location: NotRequired[pulumi.Input[str]]
        """
        The location of the endpoint.
        """
        private_ip_address: NotRequired[pulumi.Input[str]]
        """
        The private ip address of the endpoint.
        """
        public_port: NotRequired[pulumi.Input[int]]
        """
        The public port to connect to.
        """
elif False:
    ApplicationGetEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationGetEndpointArgs:
    def __init__(__self__, *,
                 destination_port: Optional[pulumi.Input[int]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 private_ip_address: Optional[pulumi.Input[str]] = None,
                 public_port: Optional[pulumi.Input[int]] = None):
        """
        Gets the application SSH endpoint
        :param pulumi.Input[int] destination_port: The destination port to connect to.
        :param pulumi.Input[str] location: The location of the endpoint.
        :param pulumi.Input[str] private_ip_address: The private ip address of the endpoint.
        :param pulumi.Input[int] public_port: The public port to connect to.
        """
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if public_port is not None:
            pulumi.set(__self__, "public_port", public_port)

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[pulumi.Input[int]]:
        """
        The destination port to connect to.
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "destination_port", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The location of the endpoint.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The private ip address of the endpoint.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter(name="publicPort")
    def public_port(self) -> Optional[pulumi.Input[int]]:
        """
        The public port to connect to.
        """
        return pulumi.get(self, "public_port")

    @public_port.setter
    def public_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "public_port", value)


if not MYPY:
    class ApplicationGetHttpsEndpointArgsDict(TypedDict):
        """
        Gets the application HTTP endpoints.
        """
        access_modes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of access modes for the application.
        """
        destination_port: NotRequired[pulumi.Input[int]]
        """
        The destination port to connect to.
        """
        disable_gateway_auth: NotRequired[pulumi.Input[bool]]
        """
        The value indicates whether to disable GatewayAuth.
        """
        private_ip_address: NotRequired[pulumi.Input[str]]
        """
        The private ip address of the endpoint.
        """
        sub_domain_suffix: NotRequired[pulumi.Input[str]]
        """
        The subdomain suffix of the application.
        """
elif False:
    ApplicationGetHttpsEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationGetHttpsEndpointArgs:
    def __init__(__self__, *,
                 access_modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 destination_port: Optional[pulumi.Input[int]] = None,
                 disable_gateway_auth: Optional[pulumi.Input[bool]] = None,
                 private_ip_address: Optional[pulumi.Input[str]] = None,
                 sub_domain_suffix: Optional[pulumi.Input[str]] = None):
        """
        Gets the application HTTP endpoints.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] access_modes: The list of access modes for the application.
        :param pulumi.Input[int] destination_port: The destination port to connect to.
        :param pulumi.Input[bool] disable_gateway_auth: The value indicates whether to disable GatewayAuth.
        :param pulumi.Input[str] private_ip_address: The private ip address of the endpoint.
        :param pulumi.Input[str] sub_domain_suffix: The subdomain suffix of the application.
        """
        if access_modes is not None:
            pulumi.set(__self__, "access_modes", access_modes)
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if disable_gateway_auth is not None:
            pulumi.set(__self__, "disable_gateway_auth", disable_gateway_auth)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if sub_domain_suffix is not None:
            pulumi.set(__self__, "sub_domain_suffix", sub_domain_suffix)

    @property
    @pulumi.getter(name="accessModes")
    def access_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of access modes for the application.
        """
        return pulumi.get(self, "access_modes")

    @access_modes.setter
    def access_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "access_modes", value)

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[pulumi.Input[int]]:
        """
        The destination port to connect to.
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "destination_port", value)

    @property
    @pulumi.getter(name="disableGatewayAuth")
    def disable_gateway_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        The value indicates whether to disable GatewayAuth.
        """
        return pulumi.get(self, "disable_gateway_auth")

    @disable_gateway_auth.setter
    def disable_gateway_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_gateway_auth", value)

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The private ip address of the endpoint.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter(name="subDomainSuffix")
    def sub_domain_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        The subdomain suffix of the application.
        """
        return pulumi.get(self, "sub_domain_suffix")

    @sub_domain_suffix.setter
    def sub_domain_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sub_domain_suffix", value)


if not MYPY:
    class ApplicationPropertiesArgsDict(TypedDict):
        """
        The HDInsight cluster application GET response.
        """
        application_type: NotRequired[pulumi.Input[str]]
        """
        The application type.
        """
        compute_profile: NotRequired[pulumi.Input['ComputeProfileArgsDict']]
        """
        The list of roles in the cluster.
        """
        errors: NotRequired[pulumi.Input[Sequence[pulumi.Input['ErrorsArgsDict']]]]
        """
        The list of errors.
        """
        https_endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationGetHttpsEndpointArgsDict']]]]
        """
        The list of application HTTPS endpoints.
        """
        install_script_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuntimeScriptActionArgsDict']]]]
        """
        The list of install script actions.
        """
        private_link_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['PrivateLinkConfigurationArgsDict']]]]
        """
        The private link configurations.
        """
        ssh_endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationGetEndpointArgsDict']]]]
        """
        The list of application SSH endpoints.
        """
        uninstall_script_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuntimeScriptActionArgsDict']]]]
        """
        The list of uninstall script actions.
        """
elif False:
    ApplicationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationPropertiesArgs:
    def __init__(__self__, *,
                 application_type: Optional[pulumi.Input[str]] = None,
                 compute_profile: Optional[pulumi.Input['ComputeProfileArgs']] = None,
                 errors: Optional[pulumi.Input[Sequence[pulumi.Input['ErrorsArgs']]]] = None,
                 https_endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationGetHttpsEndpointArgs']]]] = None,
                 install_script_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuntimeScriptActionArgs']]]] = None,
                 private_link_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['PrivateLinkConfigurationArgs']]]] = None,
                 ssh_endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationGetEndpointArgs']]]] = None,
                 uninstall_script_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuntimeScriptActionArgs']]]] = None):
        """
        The HDInsight cluster application GET response.
        :param pulumi.Input[str] application_type: The application type.
        :param pulumi.Input['ComputeProfileArgs'] compute_profile: The list of roles in the cluster.
        :param pulumi.Input[Sequence[pulumi.Input['ErrorsArgs']]] errors: The list of errors.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationGetHttpsEndpointArgs']]] https_endpoints: The list of application HTTPS endpoints.
        :param pulumi.Input[Sequence[pulumi.Input['RuntimeScriptActionArgs']]] install_script_actions: The list of install script actions.
        :param pulumi.Input[Sequence[pulumi.Input['PrivateLinkConfigurationArgs']]] private_link_configurations: The private link configurations.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationGetEndpointArgs']]] ssh_endpoints: The list of application SSH endpoints.
        :param pulumi.Input[Sequence[pulumi.Input['RuntimeScriptActionArgs']]] uninstall_script_actions: The list of uninstall script actions.
        """
        if application_type is not None:
            pulumi.set(__self__, "application_type", application_type)
        if compute_profile is not None:
            pulumi.set(__self__, "compute_profile", compute_profile)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if https_endpoints is not None:
            pulumi.set(__self__, "https_endpoints", https_endpoints)
        if install_script_actions is not None:
            pulumi.set(__self__, "install_script_actions", install_script_actions)
        if private_link_configurations is not None:
            pulumi.set(__self__, "private_link_configurations", private_link_configurations)
        if ssh_endpoints is not None:
            pulumi.set(__self__, "ssh_endpoints", ssh_endpoints)
        if uninstall_script_actions is not None:
            pulumi.set(__self__, "uninstall_script_actions", uninstall_script_actions)

    @property
    @pulumi.getter(name="applicationType")
    def application_type(self) -> Optional[pulumi.Input[str]]:
        """
        The application type.
        """
        return pulumi.get(self, "application_type")

    @application_type.setter
    def application_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_type", value)

    @property
    @pulumi.getter(name="computeProfile")
    def compute_profile(self) -> Optional[pulumi.Input['ComputeProfileArgs']]:
        """
        The list of roles in the cluster.
        """
        return pulumi.get(self, "compute_profile")

    @compute_profile.setter
    def compute_profile(self, value: Optional[pulumi.Input['ComputeProfileArgs']]):
        pulumi.set(self, "compute_profile", value)

    @property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ErrorsArgs']]]]:
        """
        The list of errors.
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ErrorsArgs']]]]):
        pulumi.set(self, "errors", value)

    @property
    @pulumi.getter(name="httpsEndpoints")
    def https_endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationGetHttpsEndpointArgs']]]]:
        """
        The list of application HTTPS endpoints.
        """
        return pulumi.get(self, "https_endpoints")

    @https_endpoints.setter
    def https_endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationGetHttpsEndpointArgs']]]]):
        pulumi.set(self, "https_endpoints", value)

    @property
    @pulumi.getter(name="installScriptActions")
    def install_script_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuntimeScriptActionArgs']]]]:
        """
        The list of install script actions.
        """
        return pulumi.get(self, "install_script_actions")

    @install_script_actions.setter
    def install_script_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuntimeScriptActionArgs']]]]):
        pulumi.set(self, "install_script_actions", value)

    @property
    @pulumi.getter(name="privateLinkConfigurations")
    def private_link_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PrivateLinkConfigurationArgs']]]]:
        """
        The private link configurations.
        """
        return pulumi.get(self, "private_link_configurations")

    @private_link_configurations.setter
    def private_link_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PrivateLinkConfigurationArgs']]]]):
        pulumi.set(self, "private_link_configurations", value)

    @property
    @pulumi.getter(name="sshEndpoints")
    def ssh_endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationGetEndpointArgs']]]]:
        """
        The list of application SSH endpoints.
        """
        return pulumi.get(self, "ssh_endpoints")

    @ssh_endpoints.setter
    def ssh_endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationGetEndpointArgs']]]]):
        pulumi.set(self, "ssh_endpoints", value)

    @property
    @pulumi.getter(name="uninstallScriptActions")
    def uninstall_script_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuntimeScriptActionArgs']]]]:
        """
        The list of uninstall script actions.
        """
        return pulumi.get(self, "uninstall_script_actions")

    @uninstall_script_actions.setter
    def uninstall_script_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuntimeScriptActionArgs']]]]):
        pulumi.set(self, "uninstall_script_actions", value)


if not MYPY:
    class AuthorizationProfileArgsDict(TypedDict):
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        """
        group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        AAD group Ids authorized for data plane access.
        """
        user_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        AAD user Ids authorized for data plane access.
        """
elif False:
    AuthorizationProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationProfileArgs:
    def __init__(__self__, *,
                 group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_ids: AAD group Ids authorized for data plane access.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_ids: AAD user Ids authorized for data plane access.
        """
        if group_ids is not None:
            pulumi.set(__self__, "group_ids", group_ids)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        AAD group Ids authorized for data plane access.
        """
        return pulumi.get(self, "group_ids")

    @group_ids.setter
    def group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_ids", value)

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        AAD user Ids authorized for data plane access.
        """
        return pulumi.get(self, "user_ids")

    @user_ids.setter
    def user_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_ids", value)


if not MYPY:
    class AutoscaleCapacityArgsDict(TypedDict):
        """
        The load-based autoscale request parameters
        """
        max_instance_count: NotRequired[pulumi.Input[int]]
        """
        The maximum instance count of the cluster
        """
        min_instance_count: NotRequired[pulumi.Input[int]]
        """
        The minimum instance count of the cluster
        """
elif False:
    AutoscaleCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleCapacityArgs:
    def __init__(__self__, *,
                 max_instance_count: Optional[pulumi.Input[int]] = None,
                 min_instance_count: Optional[pulumi.Input[int]] = None):
        """
        The load-based autoscale request parameters
        :param pulumi.Input[int] max_instance_count: The maximum instance count of the cluster
        :param pulumi.Input[int] min_instance_count: The minimum instance count of the cluster
        """
        if max_instance_count is not None:
            pulumi.set(__self__, "max_instance_count", max_instance_count)
        if min_instance_count is not None:
            pulumi.set(__self__, "min_instance_count", min_instance_count)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum instance count of the cluster
        """
        return pulumi.get(self, "max_instance_count")

    @max_instance_count.setter
    def max_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_instance_count", value)

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum instance count of the cluster
        """
        return pulumi.get(self, "min_instance_count")

    @min_instance_count.setter
    def min_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_instance_count", value)


if not MYPY:
    class AutoscaleProfileArgsDict(TypedDict):
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        """
        enabled: pulumi.Input[bool]
        """
        This indicates whether auto scale is enabled on HDInsight on AKS cluster.
        """
        autoscale_type: NotRequired[pulumi.Input[Union[str, 'AutoscaleType']]]
        """
        User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        """
        graceful_decommission_timeout: NotRequired[pulumi.Input[int]]
        """
        This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        """
        load_based_config: NotRequired[pulumi.Input['LoadBasedConfigArgsDict']]
        """
        Profiles of load based Autoscale.
        """
        schedule_based_config: NotRequired[pulumi.Input['ScheduleBasedConfigArgsDict']]
        """
        Profiles of schedule based Autoscale.
        """
elif False:
    AutoscaleProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleProfileArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 autoscale_type: Optional[pulumi.Input[Union[str, 'AutoscaleType']]] = None,
                 graceful_decommission_timeout: Optional[pulumi.Input[int]] = None,
                 load_based_config: Optional[pulumi.Input['LoadBasedConfigArgs']] = None,
                 schedule_based_config: Optional[pulumi.Input['ScheduleBasedConfigArgs']] = None):
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        :param pulumi.Input[bool] enabled: This indicates whether auto scale is enabled on HDInsight on AKS cluster.
        :param pulumi.Input[Union[str, 'AutoscaleType']] autoscale_type: User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        :param pulumi.Input[int] graceful_decommission_timeout: This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        :param pulumi.Input['LoadBasedConfigArgs'] load_based_config: Profiles of load based Autoscale.
        :param pulumi.Input['ScheduleBasedConfigArgs'] schedule_based_config: Profiles of schedule based Autoscale.
        """
        pulumi.set(__self__, "enabled", enabled)
        if autoscale_type is not None:
            pulumi.set(__self__, "autoscale_type", autoscale_type)
        if graceful_decommission_timeout is not None:
            pulumi.set(__self__, "graceful_decommission_timeout", graceful_decommission_timeout)
        if load_based_config is not None:
            pulumi.set(__self__, "load_based_config", load_based_config)
        if schedule_based_config is not None:
            pulumi.set(__self__, "schedule_based_config", schedule_based_config)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        This indicates whether auto scale is enabled on HDInsight on AKS cluster.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="autoscaleType")
    def autoscale_type(self) -> Optional[pulumi.Input[Union[str, 'AutoscaleType']]]:
        """
        User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        """
        return pulumi.get(self, "autoscale_type")

    @autoscale_type.setter
    def autoscale_type(self, value: Optional[pulumi.Input[Union[str, 'AutoscaleType']]]):
        pulumi.set(self, "autoscale_type", value)

    @property
    @pulumi.getter(name="gracefulDecommissionTimeout")
    def graceful_decommission_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        """
        return pulumi.get(self, "graceful_decommission_timeout")

    @graceful_decommission_timeout.setter
    def graceful_decommission_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "graceful_decommission_timeout", value)

    @property
    @pulumi.getter(name="loadBasedConfig")
    def load_based_config(self) -> Optional[pulumi.Input['LoadBasedConfigArgs']]:
        """
        Profiles of load based Autoscale.
        """
        return pulumi.get(self, "load_based_config")

    @load_based_config.setter
    def load_based_config(self, value: Optional[pulumi.Input['LoadBasedConfigArgs']]):
        pulumi.set(self, "load_based_config", value)

    @property
    @pulumi.getter(name="scheduleBasedConfig")
    def schedule_based_config(self) -> Optional[pulumi.Input['ScheduleBasedConfigArgs']]:
        """
        Profiles of schedule based Autoscale.
        """
        return pulumi.get(self, "schedule_based_config")

    @schedule_based_config.setter
    def schedule_based_config(self, value: Optional[pulumi.Input['ScheduleBasedConfigArgs']]):
        pulumi.set(self, "schedule_based_config", value)


if not MYPY:
    class AutoscaleRecurrenceArgsDict(TypedDict):
        """
        Schedule-based autoscale request parameters
        """
        schedule: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutoscaleScheduleArgsDict']]]]
        """
        Array of schedule-based autoscale rules
        """
        time_zone: NotRequired[pulumi.Input[str]]
        """
        The time zone for the autoscale schedule times
        """
elif False:
    AutoscaleRecurrenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleRecurrenceArgs:
    def __init__(__self__, *,
                 schedule: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscaleScheduleArgs']]]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        Schedule-based autoscale request parameters
        :param pulumi.Input[Sequence[pulumi.Input['AutoscaleScheduleArgs']]] schedule: Array of schedule-based autoscale rules
        :param pulumi.Input[str] time_zone: The time zone for the autoscale schedule times
        """
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoscaleScheduleArgs']]]]:
        """
        Array of schedule-based autoscale rules
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscaleScheduleArgs']]]]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The time zone for the autoscale schedule times
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class AutoscaleScheduleArgsDict(TypedDict):
        """
        Parameters for a schedule-based autoscale rule, consisting of an array of days + a time and capacity
        """
        days: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[str, 'DaysOfWeek']]]]]
        """
        Days of the week for a schedule-based autoscale rule
        """
        time_and_capacity: NotRequired[pulumi.Input['AutoscaleTimeAndCapacityArgsDict']]
        """
        Time and capacity for a schedule-based autoscale rule
        """
elif False:
    AutoscaleScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleScheduleArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'DaysOfWeek']]]]] = None,
                 time_and_capacity: Optional[pulumi.Input['AutoscaleTimeAndCapacityArgs']] = None):
        """
        Parameters for a schedule-based autoscale rule, consisting of an array of days + a time and capacity
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'DaysOfWeek']]]] days: Days of the week for a schedule-based autoscale rule
        :param pulumi.Input['AutoscaleTimeAndCapacityArgs'] time_and_capacity: Time and capacity for a schedule-based autoscale rule
        """
        if days is not None:
            pulumi.set(__self__, "days", days)
        if time_and_capacity is not None:
            pulumi.set(__self__, "time_and_capacity", time_and_capacity)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'DaysOfWeek']]]]]:
        """
        Days of the week for a schedule-based autoscale rule
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[str, 'DaysOfWeek']]]]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter(name="timeAndCapacity")
    def time_and_capacity(self) -> Optional[pulumi.Input['AutoscaleTimeAndCapacityArgs']]:
        """
        Time and capacity for a schedule-based autoscale rule
        """
        return pulumi.get(self, "time_and_capacity")

    @time_and_capacity.setter
    def time_and_capacity(self, value: Optional[pulumi.Input['AutoscaleTimeAndCapacityArgs']]):
        pulumi.set(self, "time_and_capacity", value)


if not MYPY:
    class AutoscaleTimeAndCapacityArgsDict(TypedDict):
        """
        Time and capacity request parameters
        """
        max_instance_count: NotRequired[pulumi.Input[int]]
        """
        The maximum instance count of the cluster
        """
        min_instance_count: NotRequired[pulumi.Input[int]]
        """
        The minimum instance count of the cluster
        """
        time: NotRequired[pulumi.Input[str]]
        """
        24-hour time in the form xx:xx
        """
elif False:
    AutoscaleTimeAndCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleTimeAndCapacityArgs:
    def __init__(__self__, *,
                 max_instance_count: Optional[pulumi.Input[int]] = None,
                 min_instance_count: Optional[pulumi.Input[int]] = None,
                 time: Optional[pulumi.Input[str]] = None):
        """
        Time and capacity request parameters
        :param pulumi.Input[int] max_instance_count: The maximum instance count of the cluster
        :param pulumi.Input[int] min_instance_count: The minimum instance count of the cluster
        :param pulumi.Input[str] time: 24-hour time in the form xx:xx
        """
        if max_instance_count is not None:
            pulumi.set(__self__, "max_instance_count", max_instance_count)
        if min_instance_count is not None:
            pulumi.set(__self__, "min_instance_count", min_instance_count)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum instance count of the cluster
        """
        return pulumi.get(self, "max_instance_count")

    @max_instance_count.setter
    def max_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_instance_count", value)

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum instance count of the cluster
        """
        return pulumi.get(self, "min_instance_count")

    @min_instance_count.setter
    def min_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_instance_count", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[str]]:
        """
        24-hour time in the form xx:xx
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time", value)


if not MYPY:
    class AutoscaleArgsDict(TypedDict):
        """
        The autoscale request parameters
        """
        capacity: NotRequired[pulumi.Input['AutoscaleCapacityArgsDict']]
        """
        Parameters for load-based autoscale
        """
        recurrence: NotRequired[pulumi.Input['AutoscaleRecurrenceArgsDict']]
        """
        Parameters for schedule-based autoscale
        """
elif False:
    AutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleArgs:
    def __init__(__self__, *,
                 capacity: Optional[pulumi.Input['AutoscaleCapacityArgs']] = None,
                 recurrence: Optional[pulumi.Input['AutoscaleRecurrenceArgs']] = None):
        """
        The autoscale request parameters
        :param pulumi.Input['AutoscaleCapacityArgs'] capacity: Parameters for load-based autoscale
        :param pulumi.Input['AutoscaleRecurrenceArgs'] recurrence: Parameters for schedule-based autoscale
        """
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input['AutoscaleCapacityArgs']]:
        """
        Parameters for load-based autoscale
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input['AutoscaleCapacityArgs']]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def recurrence(self) -> Optional[pulumi.Input['AutoscaleRecurrenceArgs']]:
        """
        Parameters for schedule-based autoscale
        """
        return pulumi.get(self, "recurrence")

    @recurrence.setter
    def recurrence(self, value: Optional[pulumi.Input['AutoscaleRecurrenceArgs']]):
        pulumi.set(self, "recurrence", value)


if not MYPY:
    class CatalogOptionsArgsDict(TypedDict):
        """
        Trino cluster catalog options.
        """
        hive: NotRequired[pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgsDict']]]]
        """
        hive catalog options.
        """
elif False:
    CatalogOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogOptionsArgs:
    def __init__(__self__, *,
                 hive: Optional[pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgs']]]] = None):
        """
        Trino cluster catalog options.
        :param pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgs']]] hive: hive catalog options.
        """
        if hive is not None:
            pulumi.set(__self__, "hive", hive)

    @property
    @pulumi.getter
    def hive(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgs']]]]:
        """
        hive catalog options.
        """
        return pulumi.get(self, "hive")

    @hive.setter
    def hive(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HiveCatalogOptionArgs']]]]):
        pulumi.set(self, "hive", value)


if not MYPY:
    class ClientGroupInfoArgsDict(TypedDict):
        """
        The information of AAD security group.
        """
        group_id: NotRequired[pulumi.Input[str]]
        """
        The AAD security group id.
        """
        group_name: NotRequired[pulumi.Input[str]]
        """
        The AAD security group name.
        """
elif False:
    ClientGroupInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientGroupInfoArgs:
    def __init__(__self__, *,
                 group_id: Optional[pulumi.Input[str]] = None,
                 group_name: Optional[pulumi.Input[str]] = None):
        """
        The information of AAD security group.
        :param pulumi.Input[str] group_id: The AAD security group id.
        :param pulumi.Input[str] group_name: The AAD security group name.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AAD security group id.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[str]]:
        """
        The AAD security group name.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_name", value)


if not MYPY:
    class ClusterAccessProfileArgsDict(TypedDict):
        """
        Cluster access profile.
        """
        enable_internal_ingress: pulumi.Input[bool]
        """
        Whether to create cluster using private IP instead of public IP. This property must be set at create time.
        """
elif False:
    ClusterAccessProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAccessProfileArgs:
    def __init__(__self__, *,
                 enable_internal_ingress: pulumi.Input[bool]):
        """
        Cluster access profile.
        :param pulumi.Input[bool] enable_internal_ingress: Whether to create cluster using private IP instead of public IP. This property must be set at create time.
        """
        pulumi.set(__self__, "enable_internal_ingress", enable_internal_ingress)

    @property
    @pulumi.getter(name="enableInternalIngress")
    def enable_internal_ingress(self) -> pulumi.Input[bool]:
        """
        Whether to create cluster using private IP instead of public IP. This property must be set at create time.
        """
        return pulumi.get(self, "enable_internal_ingress")

    @enable_internal_ingress.setter
    def enable_internal_ingress(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable_internal_ingress", value)


if not MYPY:
    class ClusterConfigFileArgsDict(TypedDict):
        """
        Cluster configuration files.
        """
        file_name: pulumi.Input[str]
        """
        Configuration file name.
        """
        content: NotRequired[pulumi.Input[str]]
        """
        Free form content of the entire configuration file.
        """
        encoding: NotRequired[pulumi.Input[Union[str, 'ContentEncoding']]]
        """
        This property indicates if the content is encoded and is case-insensitive. Please set the value to base64 if the content is base64 encoded. Set it to none or skip it if the content is plain text.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path of the config file if content is specified.
        """
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        List of key value pairs
        where key represents a valid service configuration name and value represents the value of the config.
        """
elif False:
    ClusterConfigFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterConfigFileArgs:
    def __init__(__self__, *,
                 file_name: pulumi.Input[str],
                 content: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[Union[str, 'ContentEncoding']]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Cluster configuration files.
        :param pulumi.Input[str] file_name: Configuration file name.
        :param pulumi.Input[str] content: Free form content of the entire configuration file.
        :param pulumi.Input[Union[str, 'ContentEncoding']] encoding: This property indicates if the content is encoded and is case-insensitive. Please set the value to base64 if the content is base64 encoded. Set it to none or skip it if the content is plain text.
        :param pulumi.Input[str] path: Path of the config file if content is specified.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] values: List of key value pairs
               where key represents a valid service configuration name and value represents the value of the config.
        """
        pulumi.set(__self__, "file_name", file_name)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> pulumi.Input[str]:
        """
        Configuration file name.
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Free form content of the entire configuration file.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[Union[str, 'ContentEncoding']]]:
        """
        This property indicates if the content is encoded and is case-insensitive. Please set the value to base64 if the content is base64 encoded. Set it to none or skip it if the content is plain text.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[Union[str, 'ContentEncoding']]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path of the config file if content is specified.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        List of key value pairs
        where key represents a valid service configuration name and value represents the value of the config.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ClusterCreatePropertiesArgsDict(TypedDict):
        """
        The cluster create parameters.
        """
        cluster_definition: NotRequired[pulumi.Input['ClusterDefinitionArgsDict']]
        """
        The cluster definition.
        """
        cluster_version: NotRequired[pulumi.Input[str]]
        """
        The version of the cluster.
        """
        compute_isolation_properties: NotRequired[pulumi.Input['ComputeIsolationPropertiesArgsDict']]
        """
        The compute isolation properties.
        """
        compute_profile: NotRequired[pulumi.Input['ComputeProfileArgsDict']]
        """
        The compute profile.
        """
        disk_encryption_properties: NotRequired[pulumi.Input['DiskEncryptionPropertiesArgsDict']]
        """
        The disk encryption properties.
        """
        encryption_in_transit_properties: NotRequired[pulumi.Input['EncryptionInTransitPropertiesArgsDict']]
        """
        The encryption-in-transit properties.
        """
        kafka_rest_properties: NotRequired[pulumi.Input['KafkaRestPropertiesArgsDict']]
        """
        The cluster kafka rest proxy configuration.
        """
        min_supported_tls_version: NotRequired[pulumi.Input[str]]
        """
        The minimal supported tls version.
        """
        network_properties: NotRequired[pulumi.Input['NetworkPropertiesArgsDict']]
        """
        The network properties.
        """
        os_type: NotRequired[pulumi.Input[Union[str, 'OSType']]]
        """
        The type of operating system.
        """
        private_link_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['PrivateLinkConfigurationArgsDict']]]]
        """
        The private link configurations.
        """
        security_profile: NotRequired[pulumi.Input['SecurityProfileArgsDict']]
        """
        The security profile.
        """
        storage_profile: NotRequired[pulumi.Input['StorageProfileArgsDict']]
        """
        The storage profile.
        """
        tier: NotRequired[pulumi.Input[Union[str, 'Tier']]]
        """
        The cluster tier.
        """
elif False:
    ClusterCreatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterCreatePropertiesArgs:
    def __init__(__self__, *,
                 cluster_definition: Optional[pulumi.Input['ClusterDefinitionArgs']] = None,
                 cluster_version: Optional[pulumi.Input[str]] = None,
                 compute_isolation_properties: Optional[pulumi.Input['ComputeIsolationPropertiesArgs']] = None,
                 compute_profile: Optional[pulumi.Input['ComputeProfileArgs']] = None,
                 disk_encryption_properties: Optional[pulumi.Input['DiskEncryptionPropertiesArgs']] = None,
                 encryption_in_transit_properties: Optional[pulumi.Input['EncryptionInTransitPropertiesArgs']] = None,
                 kafka_rest_properties: Optional[pulumi.Input['KafkaRestPropertiesArgs']] = None,
                 min_supported_tls_version: Optional[pulumi.Input[str]] = None,
                 network_properties: Optional[pulumi.Input['NetworkPropertiesArgs']] = None,
                 os_type: Optional[pulumi.Input[Union[str, 'OSType']]] = None,
                 private_link_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['PrivateLinkConfigurationArgs']]]] = None,
                 security_profile: Optional[pulumi.Input['SecurityProfileArgs']] = None,
                 storage_profile: Optional[pulumi.Input['StorageProfileArgs']] = None,
                 tier: Optional[pulumi.Input[Union[str, 'Tier']]] = None):
        """
        The cluster create parameters.
        :param pulumi.Input['ClusterDefinitionArgs'] cluster_definition: The cluster definition.
        :param pulumi.Input[str] cluster_version: The version of the cluster.
        :param pulumi.Input['ComputeIsolationPropertiesArgs'] compute_isolation_properties: The compute isolation properties.
        :param pulumi.Input['ComputeProfileArgs'] compute_profile: The compute profile.
        :param pulumi.Input['DiskEncryptionPropertiesArgs'] disk_encryption_properties: The disk encryption properties.
        :param pulumi.Input['EncryptionInTransitPropertiesArgs'] encryption_in_transit_properties: The encryption-in-transit properties.
        :param pulumi.Input['KafkaRestPropertiesArgs'] kafka_rest_properties: The cluster kafka rest proxy configuration.
        :param pulumi.Input[str] min_supported_tls_version: The minimal supported tls version.
        :param pulumi.Input['NetworkPropertiesArgs'] network_properties: The network properties.
        :param pulumi.Input[Union[str, 'OSType']] os_type: The type of operating system.
        :param pulumi.Input[Sequence[pulumi.Input['PrivateLinkConfigurationArgs']]] private_link_configurations: The private link configurations.
        :param pulumi.Input['SecurityProfileArgs'] security_profile: The security profile.
        :param pulumi.Input['StorageProfileArgs'] storage_profile: The storage profile.
        :param pulumi.Input[Union[str, 'Tier']] tier: The cluster tier.
        """
        if cluster_definition is not None:
            pulumi.set(__self__, "cluster_definition", cluster_definition)
        if cluster_version is not None:
            pulumi.set(__self__, "cluster_version", cluster_version)
        if compute_isolation_properties is not None:
            pulumi.set(__self__, "compute_isolation_properties", compute_isolation_properties)
        if compute_profile is not None:
            pulumi.set(__self__, "compute_profile", compute_profile)
        if disk_encryption_properties is not None:
            pulumi.set(__self__, "disk_encryption_properties", disk_encryption_properties)
        if encryption_in_transit_properties is not None:
            pulumi.set(__self__, "encryption_in_transit_properties", encryption_in_transit_properties)
        if kafka_rest_properties is not None:
            pulumi.set(__self__, "kafka_rest_properties", kafka_rest_properties)
        if min_supported_tls_version is not None:
            pulumi.set(__self__, "min_supported_tls_version", min_supported_tls_version)
        if network_properties is not None:
            pulumi.set(__self__, "network_properties", network_properties)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if private_link_configurations is not None:
            pulumi.set(__self__, "private_link_configurations", private_link_configurations)
        if security_profile is not None:
            pulumi.set(__self__, "security_profile", security_profile)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if tier is None:
            tier = 'Standard'
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter(name="clusterDefinition")
    def cluster_definition(self) -> Optional[pulumi.Input['ClusterDefinitionArgs']]:
        """
        The cluster definition.
        """
        return pulumi.get(self, "cluster_definition")

    @cluster_definition.setter
    def cluster_definition(self, value: Optional[pulumi.Input['ClusterDefinitionArgs']]):
        pulumi.set(self, "cluster_definition", value)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the cluster.
        """
        return pulumi.get(self, "cluster_version")

    @cluster_version.setter
    def cluster_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_version", value)

    @property
    @pulumi.getter(name="computeIsolationProperties")
    def compute_isolation_properties(self) -> Optional[pulumi.Input['ComputeIsolationPropertiesArgs']]:
        """
        The compute isolation properties.
        """
        return pulumi.get(self, "compute_isolation_properties")

    @compute_isolation_properties.setter
    def compute_isolation_properties(self, value: Optional[pulumi.Input['ComputeIsolationPropertiesArgs']]):
        pulumi.set(self, "compute_isolation_properties", value)

    @property
    @pulumi.getter(name="computeProfile")
    def compute_profile(self) -> Optional[pulumi.Input['ComputeProfileArgs']]:
        """
        The compute profile.
        """
        return pulumi.get(self, "compute_profile")

    @compute_profile.setter
    def compute_profile(self, value: Optional[pulumi.Input['ComputeProfileArgs']]):
        pulumi.set(self, "compute_profile", value)

    @property
    @pulumi.getter(name="diskEncryptionProperties")
    def disk_encryption_properties(self) -> Optional[pulumi.Input['DiskEncryptionPropertiesArgs']]:
        """
        The disk encryption properties.
        """
        return pulumi.get(self, "disk_encryption_properties")

    @disk_encryption_properties.setter
    def disk_encryption_properties(self, value: Optional[pulumi.Input['DiskEncryptionPropertiesArgs']]):
        pulumi.set(self, "disk_encryption_properties", value)

    @property
    @pulumi.getter(name="encryptionInTransitProperties")
    def encryption_in_transit_properties(self) -> Optional[pulumi.Input['EncryptionInTransitPropertiesArgs']]:
        """
        The encryption-in-transit properties.
        """
        return pulumi.get(self, "encryption_in_transit_properties")

    @encryption_in_transit_properties.setter
    def encryption_in_transit_properties(self, value: Optional[pulumi.Input['EncryptionInTransitPropertiesArgs']]):
        pulumi.set(self, "encryption_in_transit_properties", value)

    @property
    @pulumi.getter(name="kafkaRestProperties")
    def kafka_rest_properties(self) -> Optional[pulumi.Input['KafkaRestPropertiesArgs']]:
        """
        The cluster kafka rest proxy configuration.
        """
        return pulumi.get(self, "kafka_rest_properties")

    @kafka_rest_properties.setter
    def kafka_rest_properties(self, value: Optional[pulumi.Input['KafkaRestPropertiesArgs']]):
        pulumi.set(self, "kafka_rest_properties", value)

    @property
    @pulumi.getter(name="minSupportedTlsVersion")
    def min_supported_tls_version(self) -> Optional[pulumi.Input[str]]:
        """
        The minimal supported tls version.
        """
        return pulumi.get(self, "min_supported_tls_version")

    @min_supported_tls_version.setter
    def min_supported_tls_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_supported_tls_version", value)

    @property
    @pulumi.getter(name="networkProperties")
    def network_properties(self) -> Optional[pulumi.Input['NetworkPropertiesArgs']]:
        """
        The network properties.
        """
        return pulumi.get(self, "network_properties")

    @network_properties.setter
    def network_properties(self, value: Optional[pulumi.Input['NetworkPropertiesArgs']]):
        pulumi.set(self, "network_properties", value)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[Union[str, 'OSType']]]:
        """
        The type of operating system.
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[Union[str, 'OSType']]]):
        pulumi.set(self, "os_type", value)

    @property
    @pulumi.getter(name="privateLinkConfigurations")
    def private_link_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PrivateLinkConfigurationArgs']]]]:
        """
        The private link configurations.
        """
        return pulumi.get(self, "private_link_configurations")

    @private_link_configurations.setter
    def private_link_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PrivateLinkConfigurationArgs']]]]):
        pulumi.set(self, "private_link_configurations", value)

    @property
    @pulumi.getter(name="securityProfile")
    def security_profile(self) -> Optional[pulumi.Input['SecurityProfileArgs']]:
        """
        The security profile.
        """
        return pulumi.get(self, "security_profile")

    @security_profile.setter
    def security_profile(self, value: Optional[pulumi.Input['SecurityProfileArgs']]):
        pulumi.set(self, "security_profile", value)

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[pulumi.Input['StorageProfileArgs']]:
        """
        The storage profile.
        """
        return pulumi.get(self, "storage_profile")

    @storage_profile.setter
    def storage_profile(self, value: Optional[pulumi.Input['StorageProfileArgs']]):
        pulumi.set(self, "storage_profile", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[Union[str, 'Tier']]]:
        """
        The cluster tier.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[Union[str, 'Tier']]]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class ClusterDefinitionArgsDict(TypedDict):
        """
        The cluster definition.
        """
        blueprint: NotRequired[pulumi.Input[str]]
        """
        The link to the blueprint.
        """
        component_version: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The versions of different services in the cluster.
        """
        configurations: NotRequired[Any]
        """
        The cluster configurations.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        The type of cluster.
        """
elif False:
    ClusterDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterDefinitionArgs:
    def __init__(__self__, *,
                 blueprint: Optional[pulumi.Input[str]] = None,
                 component_version: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 configurations: Optional[Any] = None,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        The cluster definition.
        :param pulumi.Input[str] blueprint: The link to the blueprint.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] component_version: The versions of different services in the cluster.
        :param Any configurations: The cluster configurations.
        :param pulumi.Input[str] kind: The type of cluster.
        """
        if blueprint is not None:
            pulumi.set(__self__, "blueprint", blueprint)
        if component_version is not None:
            pulumi.set(__self__, "component_version", component_version)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def blueprint(self) -> Optional[pulumi.Input[str]]:
        """
        The link to the blueprint.
        """
        return pulumi.get(self, "blueprint")

    @blueprint.setter
    def blueprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "blueprint", value)

    @property
    @pulumi.getter(name="componentVersion")
    def component_version(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The versions of different services in the cluster.
        """
        return pulumi.get(self, "component_version")

    @component_version.setter
    def component_version(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "component_version", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Any]:
        """
        The cluster configurations.
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[Any]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        The type of cluster.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class ClusterIdentityArgsDict(TypedDict):
        """
        Identity for the cluster.
        """
        type: NotRequired[pulumi.Input[Union[str, 'ResourceIdentityType']]]
        """
        The type of identity used for the cluster. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['UserAssignedIdentityArgsDict']]]]
        """
        The list of user identities associated with the cluster. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
elif False:
    ClusterIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[str, 'ResourceIdentityType']]] = None,
                 user_assigned_identities: Optional[pulumi.Input[Mapping[str, pulumi.Input['UserAssignedIdentityArgs']]]] = None):
        """
        Identity for the cluster.
        :param pulumi.Input[Union[str, 'ResourceIdentityType']] type: The type of identity used for the cluster. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities.
        :param pulumi.Input[Mapping[str, pulumi.Input['UserAssignedIdentityArgs']]] user_assigned_identities: The list of user identities associated with the cluster. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'ResourceIdentityType']]]:
        """
        The type of identity used for the cluster. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'ResourceIdentityType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['UserAssignedIdentityArgs']]]]:
        """
        The list of user identities associated with the cluster. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['UserAssignedIdentityArgs']]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class ClusterLogAnalyticsApplicationLogsArgsDict(TypedDict):
        """
        Collection of logs to be enabled or disabled for log analytics.
        """
        std_error_enabled: NotRequired[pulumi.Input[bool]]
        """
        True if stderror is enabled, otherwise false.
        """
        std_out_enabled: NotRequired[pulumi.Input[bool]]
        """
        True if stdout is enabled, otherwise false.
        """
elif False:
    ClusterLogAnalyticsApplicationLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLogAnalyticsApplicationLogsArgs:
    def __init__(__self__, *,
                 std_error_enabled: Optional[pulumi.Input[bool]] = None,
                 std_out_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Collection of logs to be enabled or disabled for log analytics.
        :param pulumi.Input[bool] std_error_enabled: True if stderror is enabled, otherwise false.
        :param pulumi.Input[bool] std_out_enabled: True if stdout is enabled, otherwise false.
        """
        if std_error_enabled is not None:
            pulumi.set(__self__, "std_error_enabled", std_error_enabled)
        if std_out_enabled is not None:
            pulumi.set(__self__, "std_out_enabled", std_out_enabled)

    @property
    @pulumi.getter(name="stdErrorEnabled")
    def std_error_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if stderror is enabled, otherwise false.
        """
        return pulumi.get(self, "std_error_enabled")

    @std_error_enabled.setter
    def std_error_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "std_error_enabled", value)

    @property
    @pulumi.getter(name="stdOutEnabled")
    def std_out_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if stdout is enabled, otherwise false.
        """
        return pulumi.get(self, "std_out_enabled")

    @std_out_enabled.setter
    def std_out_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "std_out_enabled", value)


if not MYPY:
    class ClusterLogAnalyticsProfileArgsDict(TypedDict):
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        """
        enabled: pulumi.Input[bool]
        """
        True if log analytics is enabled for the cluster, otherwise false.
        """
        application_logs: NotRequired[pulumi.Input['ClusterLogAnalyticsApplicationLogsArgsDict']]
        """
        Collection of logs to be enabled or disabled for log analytics.
        """
        metrics_enabled: NotRequired[pulumi.Input[bool]]
        """
        True if metrics are enabled, otherwise false.
        """
elif False:
    ClusterLogAnalyticsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLogAnalyticsProfileArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 application_logs: Optional[pulumi.Input['ClusterLogAnalyticsApplicationLogsArgs']] = None,
                 metrics_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        :param pulumi.Input[bool] enabled: True if log analytics is enabled for the cluster, otherwise false.
        :param pulumi.Input['ClusterLogAnalyticsApplicationLogsArgs'] application_logs: Collection of logs to be enabled or disabled for log analytics.
        :param pulumi.Input[bool] metrics_enabled: True if metrics are enabled, otherwise false.
        """
        pulumi.set(__self__, "enabled", enabled)
        if application_logs is not None:
            pulumi.set(__self__, "application_logs", application_logs)
        if metrics_enabled is not None:
            pulumi.set(__self__, "metrics_enabled", metrics_enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        True if log analytics is enabled for the cluster, otherwise false.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="applicationLogs")
    def application_logs(self) -> Optional[pulumi.Input['ClusterLogAnalyticsApplicationLogsArgs']]:
        """
        Collection of logs to be enabled or disabled for log analytics.
        """
        return pulumi.get(self, "application_logs")

    @application_logs.setter
    def application_logs(self, value: Optional[pulumi.Input['ClusterLogAnalyticsApplicationLogsArgs']]):
        pulumi.set(self, "application_logs", value)

    @property
    @pulumi.getter(name="metricsEnabled")
    def metrics_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if metrics are enabled, otherwise false.
        """
        return pulumi.get(self, "metrics_enabled")

    @metrics_enabled.setter
    def metrics_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "metrics_enabled", value)


if not MYPY:
    class ClusterPoolComputeProfileArgsDict(TypedDict):
        """
        The compute profile.
        """
        nodes: pulumi.Input[Sequence[pulumi.Input['NodeProfileArgsDict']]]
        """
        The nodes definitions.
        """
        availability_zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Availability zones to use for AKS VMSS nodes.
        """
elif False:
    ClusterPoolComputeProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPoolComputeProfileArgs:
    def __init__(__self__, *,
                 nodes: pulumi.Input[Sequence[pulumi.Input['NodeProfileArgs']]],
                 availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The compute profile.
        :param pulumi.Input[Sequence[pulumi.Input['NodeProfileArgs']]] nodes: The nodes definitions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] availability_zones: The list of Availability zones to use for AKS VMSS nodes.
        """
        pulumi.set(__self__, "nodes", nodes)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)

    @property
    @pulumi.getter
    def nodes(self) -> pulumi.Input[Sequence[pulumi.Input['NodeProfileArgs']]]:
        """
        The nodes definitions.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: pulumi.Input[Sequence[pulumi.Input['NodeProfileArgs']]]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Availability zones to use for AKS VMSS nodes.
        """
        return pulumi.get(self, "availability_zones")

    @availability_zones.setter
    def availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "availability_zones", value)


if not MYPY:
    class ClusterPoolResourcePropertiesClusterPoolProfileArgsDict(TypedDict):
        """
        CLuster pool profile.
        """
        cluster_pool_version: pulumi.Input[str]
        """
        Cluster pool version is a 2-part version.
        """
        public_ip_tag: NotRequired[pulumi.Input['IpTagArgsDict']]
        """
        Gets or sets the IP tag for the public IPs created along with the HDInsightOnAks ClusterPools and Clusters. 
        """
elif False:
    ClusterPoolResourcePropertiesClusterPoolProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPoolResourcePropertiesClusterPoolProfileArgs:
    def __init__(__self__, *,
                 cluster_pool_version: pulumi.Input[str],
                 public_ip_tag: Optional[pulumi.Input['IpTagArgs']] = None):
        """
        CLuster pool profile.
        :param pulumi.Input[str] cluster_pool_version: Cluster pool version is a 2-part version.
        :param pulumi.Input['IpTagArgs'] public_ip_tag: Gets or sets the IP tag for the public IPs created along with the HDInsightOnAks ClusterPools and Clusters. 
        """
        pulumi.set(__self__, "cluster_pool_version", cluster_pool_version)
        if public_ip_tag is not None:
            pulumi.set(__self__, "public_ip_tag", public_ip_tag)

    @property
    @pulumi.getter(name="clusterPoolVersion")
    def cluster_pool_version(self) -> pulumi.Input[str]:
        """
        Cluster pool version is a 2-part version.
        """
        return pulumi.get(self, "cluster_pool_version")

    @cluster_pool_version.setter
    def cluster_pool_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_pool_version", value)

    @property
    @pulumi.getter(name="publicIpTag")
    def public_ip_tag(self) -> Optional[pulumi.Input['IpTagArgs']]:
        """
        Gets or sets the IP tag for the public IPs created along with the HDInsightOnAks ClusterPools and Clusters. 
        """
        return pulumi.get(self, "public_ip_tag")

    @public_ip_tag.setter
    def public_ip_tag(self, value: Optional[pulumi.Input['IpTagArgs']]):
        pulumi.set(self, "public_ip_tag", value)


if not MYPY:
    class ClusterPoolResourcePropertiesComputeProfileArgsDict(TypedDict):
        """
        CLuster pool compute profile.
        """
        vm_size: pulumi.Input[str]
        """
        The virtual machine SKU.
        """
        availability_zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of Availability zones to use for AKS VMSS nodes.
        """
elif False:
    ClusterPoolResourcePropertiesComputeProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPoolResourcePropertiesComputeProfileArgs:
    def __init__(__self__, *,
                 vm_size: pulumi.Input[str],
                 availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        CLuster pool compute profile.
        :param pulumi.Input[str] vm_size: The virtual machine SKU.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] availability_zones: The list of Availability zones to use for AKS VMSS nodes.
        """
        pulumi.set(__self__, "vm_size", vm_size)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> pulumi.Input[str]:
        """
        The virtual machine SKU.
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_size", value)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of Availability zones to use for AKS VMSS nodes.
        """
        return pulumi.get(self, "availability_zones")

    @availability_zones.setter
    def availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "availability_zones", value)


if not MYPY:
    class ClusterPoolResourcePropertiesLogAnalyticsProfileArgsDict(TypedDict):
        """
        Cluster pool log analytics profile to enable OMS agent for AKS cluster.
        """
        enabled: pulumi.Input[bool]
        """
        True if log analytics is enabled for cluster pool, otherwise false.
        """
        workspace_id: NotRequired[pulumi.Input[str]]
        """
        Log analytics workspace to associate with the OMS agent.
        """
elif False:
    ClusterPoolResourcePropertiesLogAnalyticsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPoolResourcePropertiesLogAnalyticsProfileArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 workspace_id: Optional[pulumi.Input[str]] = None):
        """
        Cluster pool log analytics profile to enable OMS agent for AKS cluster.
        :param pulumi.Input[bool] enabled: True if log analytics is enabled for cluster pool, otherwise false.
        :param pulumi.Input[str] workspace_id: Log analytics workspace to associate with the OMS agent.
        """
        pulumi.set(__self__, "enabled", enabled)
        if workspace_id is not None:
            pulumi.set(__self__, "workspace_id", workspace_id)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        True if log analytics is enabled for cluster pool, otherwise false.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> Optional[pulumi.Input[str]]:
        """
        Log analytics workspace to associate with the OMS agent.
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workspace_id", value)


if not MYPY:
    class ClusterPoolResourcePropertiesNetworkProfileArgsDict(TypedDict):
        """
        Cluster pool network profile.
        """
        subnet_id: pulumi.Input[str]
        """
        Cluster pool subnet resource id.
        """
        api_server_authorized_ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with private AKS clusters. So you cannot set enablePrivateApiServer to true and apiServerAuthorizedIpRanges at the same time. Currently, this property is not supported and please don't use it.
        """
        enable_private_api_server: NotRequired[pulumi.Input[bool]]
        """
        ClusterPool is based on AKS cluster. AKS cluster exposes the API server to public internet by default. If you set this property to true, a private AKS cluster will be created, and it will use private apiserver, which is not exposed to public internet.
        """
        outbound_type: NotRequired[pulumi.Input[Union[str, 'OutboundType']]]
        """
        This can only be set at cluster pool creation time and cannot be changed later. 
        """
elif False:
    ClusterPoolResourcePropertiesNetworkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPoolResourcePropertiesNetworkProfileArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 api_server_authorized_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enable_private_api_server: Optional[pulumi.Input[bool]] = None,
                 outbound_type: Optional[pulumi.Input[Union[str, 'OutboundType']]] = None):
        """
        Cluster pool network profile.
        :param pulumi.Input[str] subnet_id: Cluster pool subnet resource id.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] api_server_authorized_ip_ranges: IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with private AKS clusters. So you cannot set enablePrivateApiServer to true and apiServerAuthorizedIpRanges at the same time. Currently, this property is not supported and please don't use it.
        :param pulumi.Input[bool] enable_private_api_server: ClusterPool is based on AKS cluster. AKS cluster exposes the API server to public internet by default. If you set this property to true, a private AKS cluster will be created, and it will use private apiserver, which is not exposed to public internet.
        :param pulumi.Input[Union[str, 'OutboundType']] outbound_type: This can only be set at cluster pool creation time and cannot be changed later. 
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if api_server_authorized_ip_ranges is not None:
            pulumi.set(__self__, "api_server_authorized_ip_ranges", api_server_authorized_ip_ranges)
        if enable_private_api_server is not None:
            pulumi.set(__self__, "enable_private_api_server", enable_private_api_server)
        if outbound_type is None:
            outbound_type = 'loadBalancer'
        if outbound_type is not None:
            pulumi.set(__self__, "outbound_type", outbound_type)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        Cluster pool subnet resource id.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="apiServerAuthorizedIpRanges")
    def api_server_authorized_ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with private AKS clusters. So you cannot set enablePrivateApiServer to true and apiServerAuthorizedIpRanges at the same time. Currently, this property is not supported and please don't use it.
        """
        return pulumi.get(self, "api_server_authorized_ip_ranges")

    @api_server_authorized_ip_ranges.setter
    def api_server_authorized_ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "api_server_authorized_ip_ranges", value)

    @property
    @pulumi.getter(name="enablePrivateApiServer")
    def enable_private_api_server(self) -> Optional[pulumi.Input[bool]]:
        """
        ClusterPool is based on AKS cluster. AKS cluster exposes the API server to public internet by default. If you set this property to true, a private AKS cluster will be created, and it will use private apiserver, which is not exposed to public internet.
        """
        return pulumi.get(self, "enable_private_api_server")

    @enable_private_api_server.setter
    def enable_private_api_server(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_private_api_server", value)

    @property
    @pulumi.getter(name="outboundType")
    def outbound_type(self) -> Optional[pulumi.Input[Union[str, 'OutboundType']]]:
        """
        This can only be set at cluster pool creation time and cannot be changed later. 
        """
        return pulumi.get(self, "outbound_type")

    @outbound_type.setter
    def outbound_type(self, value: Optional[pulumi.Input[Union[str, 'OutboundType']]]):
        pulumi.set(self, "outbound_type", value)


if not MYPY:
    class ClusterPoolSshProfileArgsDict(TypedDict):
        """
        Ssh profile for the cluster.
        """
        count: pulumi.Input[int]
        """
        Number of ssh pods per cluster.
        """
        vm_size: NotRequired[pulumi.Input[str]]
        """
        The virtual machine SKU.
        """
elif False:
    ClusterPoolSshProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPoolSshProfileArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 vm_size: Optional[pulumi.Input[str]] = None):
        """
        Ssh profile for the cluster.
        :param pulumi.Input[int] count: Number of ssh pods per cluster.
        :param pulumi.Input[str] vm_size: The virtual machine SKU.
        """
        pulumi.set(__self__, "count", count)
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        Number of ssh pods per cluster.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[pulumi.Input[str]]:
        """
        The virtual machine SKU.
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_size", value)


if not MYPY:
    class ClusterProfileArgsDict(TypedDict):
        """
        Cluster profile.
        """
        authorization_profile: pulumi.Input['AuthorizationProfileArgsDict']
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        """
        cluster_version: pulumi.Input[str]
        """
        Version with 3/4 part.
        """
        oss_version: pulumi.Input[str]
        """
        Version with three part.
        """
        autoscale_profile: NotRequired[pulumi.Input['AutoscaleProfileArgsDict']]
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        """
        cluster_access_profile: NotRequired[pulumi.Input['ClusterAccessProfileArgsDict']]
        """
        Cluster access profile.
        """
        flink_profile: NotRequired[pulumi.Input['FlinkProfileArgsDict']]
        """
        The Flink cluster profile.
        """
        identity_profile: NotRequired[pulumi.Input['IdentityProfileArgsDict']]
        """
        This is deprecated. Please use managed identity profile instead.
        """
        kafka_profile: NotRequired[pulumi.Input['KafkaProfileArgsDict']]
        """
        The Kafka cluster profile.
        """
        llap_profile: NotRequired[Any]
        """
        LLAP cluster profile.
        """
        log_analytics_profile: NotRequired[pulumi.Input['ClusterLogAnalyticsProfileArgsDict']]
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        """
        managed_identity_profile: NotRequired[pulumi.Input['ManagedIdentityProfileArgsDict']]
        """
        This property is required by Trino, Spark and Flink cluster but is optional for Kafka cluster.
        """
        prometheus_profile: NotRequired[pulumi.Input['ClusterPrometheusProfileArgsDict']]
        """
        Cluster Prometheus profile.
        """
        ranger_plugin_profile: NotRequired[pulumi.Input['ClusterRangerPluginProfileArgsDict']]
        """
        Cluster Ranger plugin profile.
        """
        ranger_profile: NotRequired[pulumi.Input['RangerProfileArgsDict']]
        """
        The ranger cluster profile.
        """
        script_action_profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgsDict']]]]
        """
        The script action profile list.
        """
        secrets_profile: NotRequired[pulumi.Input['SecretsProfileArgsDict']]
        """
        The cluster secret profile.
        """
        service_configs_profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgsDict']]]]
        """
        The service configs profiles.
        """
        spark_profile: NotRequired[pulumi.Input['SparkProfileArgsDict']]
        """
        The spark cluster profile.
        """
        ssh_profile: NotRequired[pulumi.Input['ClusterPoolSshProfileArgsDict']]
        """
        Ssh profile for the cluster.
        """
        stub_profile: NotRequired[Any]
        """
        Stub cluster profile.
        """
        trino_profile: NotRequired[pulumi.Input['TrinoProfileArgsDict']]
        """
        Trino Cluster profile.
        """
elif False:
    ClusterProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterProfileArgs:
    def __init__(__self__, *,
                 authorization_profile: pulumi.Input['AuthorizationProfileArgs'],
                 cluster_version: pulumi.Input[str],
                 oss_version: pulumi.Input[str],
                 autoscale_profile: Optional[pulumi.Input['AutoscaleProfileArgs']] = None,
                 cluster_access_profile: Optional[pulumi.Input['ClusterAccessProfileArgs']] = None,
                 flink_profile: Optional[pulumi.Input['FlinkProfileArgs']] = None,
                 identity_profile: Optional[pulumi.Input['IdentityProfileArgs']] = None,
                 kafka_profile: Optional[pulumi.Input['KafkaProfileArgs']] = None,
                 llap_profile: Optional[Any] = None,
                 log_analytics_profile: Optional[pulumi.Input['ClusterLogAnalyticsProfileArgs']] = None,
                 managed_identity_profile: Optional[pulumi.Input['ManagedIdentityProfileArgs']] = None,
                 prometheus_profile: Optional[pulumi.Input['ClusterPrometheusProfileArgs']] = None,
                 ranger_plugin_profile: Optional[pulumi.Input['ClusterRangerPluginProfileArgs']] = None,
                 ranger_profile: Optional[pulumi.Input['RangerProfileArgs']] = None,
                 script_action_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgs']]]] = None,
                 secrets_profile: Optional[pulumi.Input['SecretsProfileArgs']] = None,
                 service_configs_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgs']]]] = None,
                 spark_profile: Optional[pulumi.Input['SparkProfileArgs']] = None,
                 ssh_profile: Optional[pulumi.Input['ClusterPoolSshProfileArgs']] = None,
                 stub_profile: Optional[Any] = None,
                 trino_profile: Optional[pulumi.Input['TrinoProfileArgs']] = None):
        """
        Cluster profile.
        :param pulumi.Input['AuthorizationProfileArgs'] authorization_profile: Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        :param pulumi.Input[str] cluster_version: Version with 3/4 part.
        :param pulumi.Input[str] oss_version: Version with three part.
        :param pulumi.Input['AutoscaleProfileArgs'] autoscale_profile: This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        :param pulumi.Input['ClusterAccessProfileArgs'] cluster_access_profile: Cluster access profile.
        :param pulumi.Input['FlinkProfileArgs'] flink_profile: The Flink cluster profile.
        :param pulumi.Input['IdentityProfileArgs'] identity_profile: This is deprecated. Please use managed identity profile instead.
        :param pulumi.Input['KafkaProfileArgs'] kafka_profile: The Kafka cluster profile.
        :param Any llap_profile: LLAP cluster profile.
        :param pulumi.Input['ClusterLogAnalyticsProfileArgs'] log_analytics_profile: Cluster log analytics profile to enable or disable OMS agent for cluster.
        :param pulumi.Input['ManagedIdentityProfileArgs'] managed_identity_profile: This property is required by Trino, Spark and Flink cluster but is optional for Kafka cluster.
        :param pulumi.Input['ClusterPrometheusProfileArgs'] prometheus_profile: Cluster Prometheus profile.
        :param pulumi.Input['ClusterRangerPluginProfileArgs'] ranger_plugin_profile: Cluster Ranger plugin profile.
        :param pulumi.Input['RangerProfileArgs'] ranger_profile: The ranger cluster profile.
        :param pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgs']]] script_action_profiles: The script action profile list.
        :param pulumi.Input['SecretsProfileArgs'] secrets_profile: The cluster secret profile.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgs']]] service_configs_profiles: The service configs profiles.
        :param pulumi.Input['SparkProfileArgs'] spark_profile: The spark cluster profile.
        :param pulumi.Input['ClusterPoolSshProfileArgs'] ssh_profile: Ssh profile for the cluster.
        :param Any stub_profile: Stub cluster profile.
        :param pulumi.Input['TrinoProfileArgs'] trino_profile: Trino Cluster profile.
        """
        pulumi.set(__self__, "authorization_profile", authorization_profile)
        pulumi.set(__self__, "cluster_version", cluster_version)
        pulumi.set(__self__, "oss_version", oss_version)
        if autoscale_profile is not None:
            pulumi.set(__self__, "autoscale_profile", autoscale_profile)
        if cluster_access_profile is not None:
            pulumi.set(__self__, "cluster_access_profile", cluster_access_profile)
        if flink_profile is not None:
            pulumi.set(__self__, "flink_profile", flink_profile)
        if identity_profile is not None:
            pulumi.set(__self__, "identity_profile", identity_profile)
        if kafka_profile is not None:
            pulumi.set(__self__, "kafka_profile", kafka_profile)
        if llap_profile is not None:
            pulumi.set(__self__, "llap_profile", llap_profile)
        if log_analytics_profile is not None:
            pulumi.set(__self__, "log_analytics_profile", log_analytics_profile)
        if managed_identity_profile is not None:
            pulumi.set(__self__, "managed_identity_profile", managed_identity_profile)
        if prometheus_profile is not None:
            pulumi.set(__self__, "prometheus_profile", prometheus_profile)
        if ranger_plugin_profile is not None:
            pulumi.set(__self__, "ranger_plugin_profile", ranger_plugin_profile)
        if ranger_profile is not None:
            pulumi.set(__self__, "ranger_profile", ranger_profile)
        if script_action_profiles is not None:
            pulumi.set(__self__, "script_action_profiles", script_action_profiles)
        if secrets_profile is not None:
            pulumi.set(__self__, "secrets_profile", secrets_profile)
        if service_configs_profiles is not None:
            pulumi.set(__self__, "service_configs_profiles", service_configs_profiles)
        if spark_profile is not None:
            pulumi.set(__self__, "spark_profile", spark_profile)
        if ssh_profile is not None:
            pulumi.set(__self__, "ssh_profile", ssh_profile)
        if stub_profile is not None:
            pulumi.set(__self__, "stub_profile", stub_profile)
        if trino_profile is not None:
            pulumi.set(__self__, "trino_profile", trino_profile)

    @property
    @pulumi.getter(name="authorizationProfile")
    def authorization_profile(self) -> pulumi.Input['AuthorizationProfileArgs']:
        """
        Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        """
        return pulumi.get(self, "authorization_profile")

    @authorization_profile.setter
    def authorization_profile(self, value: pulumi.Input['AuthorizationProfileArgs']):
        pulumi.set(self, "authorization_profile", value)

    @property
    @pulumi.getter(name="clusterVersion")
    def cluster_version(self) -> pulumi.Input[str]:
        """
        Version with 3/4 part.
        """
        return pulumi.get(self, "cluster_version")

    @cluster_version.setter
    def cluster_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_version", value)

    @property
    @pulumi.getter(name="ossVersion")
    def oss_version(self) -> pulumi.Input[str]:
        """
        Version with three part.
        """
        return pulumi.get(self, "oss_version")

    @oss_version.setter
    def oss_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "oss_version", value)

    @property
    @pulumi.getter(name="autoscaleProfile")
    def autoscale_profile(self) -> Optional[pulumi.Input['AutoscaleProfileArgs']]:
        """
        This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        """
        return pulumi.get(self, "autoscale_profile")

    @autoscale_profile.setter
    def autoscale_profile(self, value: Optional[pulumi.Input['AutoscaleProfileArgs']]):
        pulumi.set(self, "autoscale_profile", value)

    @property
    @pulumi.getter(name="clusterAccessProfile")
    def cluster_access_profile(self) -> Optional[pulumi.Input['ClusterAccessProfileArgs']]:
        """
        Cluster access profile.
        """
        return pulumi.get(self, "cluster_access_profile")

    @cluster_access_profile.setter
    def cluster_access_profile(self, value: Optional[pulumi.Input['ClusterAccessProfileArgs']]):
        pulumi.set(self, "cluster_access_profile", value)

    @property
    @pulumi.getter(name="flinkProfile")
    def flink_profile(self) -> Optional[pulumi.Input['FlinkProfileArgs']]:
        """
        The Flink cluster profile.
        """
        return pulumi.get(self, "flink_profile")

    @flink_profile.setter
    def flink_profile(self, value: Optional[pulumi.Input['FlinkProfileArgs']]):
        pulumi.set(self, "flink_profile", value)

    @property
    @pulumi.getter(name="identityProfile")
    def identity_profile(self) -> Optional[pulumi.Input['IdentityProfileArgs']]:
        """
        This is deprecated. Please use managed identity profile instead.
        """
        return pulumi.get(self, "identity_profile")

    @identity_profile.setter
    def identity_profile(self, value: Optional[pulumi.Input['IdentityProfileArgs']]):
        pulumi.set(self, "identity_profile", value)

    @property
    @pulumi.getter(name="kafkaProfile")
    def kafka_profile(self) -> Optional[pulumi.Input['KafkaProfileArgs']]:
        """
        The Kafka cluster profile.
        """
        return pulumi.get(self, "kafka_profile")

    @kafka_profile.setter
    def kafka_profile(self, value: Optional[pulumi.Input['KafkaProfileArgs']]):
        pulumi.set(self, "kafka_profile", value)

    @property
    @pulumi.getter(name="llapProfile")
    def llap_profile(self) -> Optional[Any]:
        """
        LLAP cluster profile.
        """
        return pulumi.get(self, "llap_profile")

    @llap_profile.setter
    def llap_profile(self, value: Optional[Any]):
        pulumi.set(self, "llap_profile", value)

    @property
    @pulumi.getter(name="logAnalyticsProfile")
    def log_analytics_profile(self) -> Optional[pulumi.Input['ClusterLogAnalyticsProfileArgs']]:
        """
        Cluster log analytics profile to enable or disable OMS agent for cluster.
        """
        return pulumi.get(self, "log_analytics_profile")

    @log_analytics_profile.setter
    def log_analytics_profile(self, value: Optional[pulumi.Input['ClusterLogAnalyticsProfileArgs']]):
        pulumi.set(self, "log_analytics_profile", value)

    @property
    @pulumi.getter(name="managedIdentityProfile")
    def managed_identity_profile(self) -> Optional[pulumi.Input['ManagedIdentityProfileArgs']]:
        """
        This property is required by Trino, Spark and Flink cluster but is optional for Kafka cluster.
        """
        return pulumi.get(self, "managed_identity_profile")

    @managed_identity_profile.setter
    def managed_identity_profile(self, value: Optional[pulumi.Input['ManagedIdentityProfileArgs']]):
        pulumi.set(self, "managed_identity_profile", value)

    @property
    @pulumi.getter(name="prometheusProfile")
    def prometheus_profile(self) -> Optional[pulumi.Input['ClusterPrometheusProfileArgs']]:
        """
        Cluster Prometheus profile.
        """
        return pulumi.get(self, "prometheus_profile")

    @prometheus_profile.setter
    def prometheus_profile(self, value: Optional[pulumi.Input['ClusterPrometheusProfileArgs']]):
        pulumi.set(self, "prometheus_profile", value)

    @property
    @pulumi.getter(name="rangerPluginProfile")
    def ranger_plugin_profile(self) -> Optional[pulumi.Input['ClusterRangerPluginProfileArgs']]:
        """
        Cluster Ranger plugin profile.
        """
        return pulumi.get(self, "ranger_plugin_profile")

    @ranger_plugin_profile.setter
    def ranger_plugin_profile(self, value: Optional[pulumi.Input['ClusterRangerPluginProfileArgs']]):
        pulumi.set(self, "ranger_plugin_profile", value)

    @property
    @pulumi.getter(name="rangerProfile")
    def ranger_profile(self) -> Optional[pulumi.Input['RangerProfileArgs']]:
        """
        The ranger cluster profile.
        """
        return pulumi.get(self, "ranger_profile")

    @ranger_profile.setter
    def ranger_profile(self, value: Optional[pulumi.Input['RangerProfileArgs']]):
        pulumi.set(self, "ranger_profile", value)

    @property
    @pulumi.getter(name="scriptActionProfiles")
    def script_action_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgs']]]]:
        """
        The script action profile list.
        """
        return pulumi.get(self, "script_action_profiles")

    @script_action_profiles.setter
    def script_action_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionProfileArgs']]]]):
        pulumi.set(self, "script_action_profiles", value)

    @property
    @pulumi.getter(name="secretsProfile")
    def secrets_profile(self) -> Optional[pulumi.Input['SecretsProfileArgs']]:
        """
        The cluster secret profile.
        """
        return pulumi.get(self, "secrets_profile")

    @secrets_profile.setter
    def secrets_profile(self, value: Optional[pulumi.Input['SecretsProfileArgs']]):
        pulumi.set(self, "secrets_profile", value)

    @property
    @pulumi.getter(name="serviceConfigsProfiles")
    def service_configs_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgs']]]]:
        """
        The service configs profiles.
        """
        return pulumi.get(self, "service_configs_profiles")

    @service_configs_profiles.setter
    def service_configs_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigsProfileArgs']]]]):
        pulumi.set(self, "service_configs_profiles", value)

    @property
    @pulumi.getter(name="sparkProfile")
    def spark_profile(self) -> Optional[pulumi.Input['SparkProfileArgs']]:
        """
        The spark cluster profile.
        """
        return pulumi.get(self, "spark_profile")

    @spark_profile.setter
    def spark_profile(self, value: Optional[pulumi.Input['SparkProfileArgs']]):
        pulumi.set(self, "spark_profile", value)

    @property
    @pulumi.getter(name="sshProfile")
    def ssh_profile(self) -> Optional[pulumi.Input['ClusterPoolSshProfileArgs']]:
        """
        Ssh profile for the cluster.
        """
        return pulumi.get(self, "ssh_profile")

    @ssh_profile.setter
    def ssh_profile(self, value: Optional[pulumi.Input['ClusterPoolSshProfileArgs']]):
        pulumi.set(self, "ssh_profile", value)

    @property
    @pulumi.getter(name="stubProfile")
    def stub_profile(self) -> Optional[Any]:
        """
        Stub cluster profile.
        """
        return pulumi.get(self, "stub_profile")

    @stub_profile.setter
    def stub_profile(self, value: Optional[Any]):
        pulumi.set(self, "stub_profile", value)

    @property
    @pulumi.getter(name="trinoProfile")
    def trino_profile(self) -> Optional[pulumi.Input['TrinoProfileArgs']]:
        """
        Trino Cluster profile.
        """
        return pulumi.get(self, "trino_profile")

    @trino_profile.setter
    def trino_profile(self, value: Optional[pulumi.Input['TrinoProfileArgs']]):
        pulumi.set(self, "trino_profile", value)


if not MYPY:
    class ClusterPrometheusProfileArgsDict(TypedDict):
        """
        Cluster Prometheus profile.
        """
        enabled: pulumi.Input[bool]
        """
        Enable Prometheus for cluster or not.
        """
elif False:
    ClusterPrometheusProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterPrometheusProfileArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Cluster Prometheus profile.
        :param pulumi.Input[bool] enabled: Enable Prometheus for cluster or not.
        """
        if enabled is None:
            enabled = False
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Enable Prometheus for cluster or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterRangerPluginProfileArgsDict(TypedDict):
        """
        Cluster Ranger plugin profile.
        """
        enabled: pulumi.Input[bool]
        """
        Enable Ranger for cluster or not.
        """
elif False:
    ClusterRangerPluginProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRangerPluginProfileArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Cluster Ranger plugin profile.
        :param pulumi.Input[bool] enabled: Enable Ranger for cluster or not.
        """
        if enabled is None:
            enabled = False
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Enable Ranger for cluster or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterServiceConfigsProfileArgsDict(TypedDict):
        """
        Cluster service configs.
        """
        configs: pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgsDict']]]
        """
        List of service configs.
        """
        service_name: pulumi.Input[str]
        """
        Name of the service the configurations should apply to.
        """
elif False:
    ClusterServiceConfigsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterServiceConfigsProfileArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgs']]],
                 service_name: pulumi.Input[str]):
        """
        Cluster service configs.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgs']]] configs: List of service configs.
        :param pulumi.Input[str] service_name: Name of the service the configurations should apply to.
        """
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgs']]]:
        """
        List of service configs.
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterServiceConfigArgs']]]):
        pulumi.set(self, "configs", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        """
        Name of the service the configurations should apply to.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class ClusterServiceConfigArgsDict(TypedDict):
        """
        Cluster configs per component.
        """
        component: pulumi.Input[str]
        """
        Name of the component the config files should apply to.
        """
        files: pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgsDict']]]
        """
        List of Config Files.
        """
elif False:
    ClusterServiceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterServiceConfigArgs:
    def __init__(__self__, *,
                 component: pulumi.Input[str],
                 files: pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgs']]]):
        """
        Cluster configs per component.
        :param pulumi.Input[str] component: Name of the component the config files should apply to.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgs']]] files: List of Config Files.
        """
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "files", files)

    @property
    @pulumi.getter
    def component(self) -> pulumi.Input[str]:
        """
        Name of the component the config files should apply to.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: pulumi.Input[str]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def files(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgs']]]:
        """
        List of Config Files.
        """
        return pulumi.get(self, "files")

    @files.setter
    def files(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterConfigFileArgs']]]):
        pulumi.set(self, "files", value)


if not MYPY:
    class ComparisonRuleArgsDict(TypedDict):
        """
        The comparison rule.
        """
        operator: pulumi.Input[Union[str, 'ComparisonOperator']]
        """
        The comparison operator.
        """
        threshold: pulumi.Input[float]
        """
        Threshold setting.
        """
elif False:
    ComparisonRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComparisonRuleArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[Union[str, 'ComparisonOperator']],
                 threshold: pulumi.Input[float]):
        """
        The comparison rule.
        :param pulumi.Input[Union[str, 'ComparisonOperator']] operator: The comparison operator.
        :param pulumi.Input[float] threshold: Threshold setting.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[Union[str, 'ComparisonOperator']]:
        """
        The comparison operator.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[Union[str, 'ComparisonOperator']]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        Threshold setting.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class ComputeIsolationPropertiesArgsDict(TypedDict):
        """
        The compute isolation properties.
        """
        enable_compute_isolation: NotRequired[pulumi.Input[bool]]
        """
        The flag indicates whether enable compute isolation or not.
        """
        host_sku: NotRequired[pulumi.Input[str]]
        """
        The host sku.
        """
elif False:
    ComputeIsolationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeIsolationPropertiesArgs:
    def __init__(__self__, *,
                 enable_compute_isolation: Optional[pulumi.Input[bool]] = None,
                 host_sku: Optional[pulumi.Input[str]] = None):
        """
        The compute isolation properties.
        :param pulumi.Input[bool] enable_compute_isolation: The flag indicates whether enable compute isolation or not.
        :param pulumi.Input[str] host_sku: The host sku.
        """
        if enable_compute_isolation is None:
            enable_compute_isolation = False
        if enable_compute_isolation is not None:
            pulumi.set(__self__, "enable_compute_isolation", enable_compute_isolation)
        if host_sku is not None:
            pulumi.set(__self__, "host_sku", host_sku)

    @property
    @pulumi.getter(name="enableComputeIsolation")
    def enable_compute_isolation(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag indicates whether enable compute isolation or not.
        """
        return pulumi.get(self, "enable_compute_isolation")

    @enable_compute_isolation.setter
    def enable_compute_isolation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_compute_isolation", value)

    @property
    @pulumi.getter(name="hostSku")
    def host_sku(self) -> Optional[pulumi.Input[str]]:
        """
        The host sku.
        """
        return pulumi.get(self, "host_sku")

    @host_sku.setter
    def host_sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_sku", value)


if not MYPY:
    class ComputeProfileArgsDict(TypedDict):
        """
        Describes the compute profile.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input['RoleArgsDict']]]]
        """
        The list of roles in the cluster.
        """
elif False:
    ComputeProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeProfileArgs:
    def __init__(__self__, *,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input['RoleArgs']]]] = None):
        """
        Describes the compute profile.
        :param pulumi.Input[Sequence[pulumi.Input['RoleArgs']]] roles: The list of roles in the cluster.
        """
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RoleArgs']]]]:
        """
        The list of roles in the cluster.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RoleArgs']]]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class ComputeResourceDefinitionArgsDict(TypedDict):
        """
        The cpu and memory requirement definition.
        """
        cpu: pulumi.Input[float]
        """
        The required CPU.
        """
        memory: pulumi.Input[float]
        """
        The required memory in MB, Container memory will be 110 percentile
        """
elif False:
    ComputeResourceDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeResourceDefinitionArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[float],
                 memory: pulumi.Input[float]):
        """
        The cpu and memory requirement definition.
        :param pulumi.Input[float] cpu: The required CPU.
        :param pulumi.Input[float] memory: The required memory in MB, Container memory will be 110 percentile
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[float]:
        """
        The required CPU.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[float]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[float]:
        """
        The required memory in MB, Container memory will be 110 percentile
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[float]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class DataDisksGroupsArgsDict(TypedDict):
        """
        The data disks groups for the role.
        """
        disks_per_node: NotRequired[pulumi.Input[int]]
        """
        The number of disks per node.
        """
elif False:
    DataDisksGroupsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataDisksGroupsArgs:
    def __init__(__self__, *,
                 disks_per_node: Optional[pulumi.Input[int]] = None):
        """
        The data disks groups for the role.
        :param pulumi.Input[int] disks_per_node: The number of disks per node.
        """
        if disks_per_node is not None:
            pulumi.set(__self__, "disks_per_node", disks_per_node)

    @property
    @pulumi.getter(name="disksPerNode")
    def disks_per_node(self) -> Optional[pulumi.Input[int]]:
        """
        The number of disks per node.
        """
        return pulumi.get(self, "disks_per_node")

    @disks_per_node.setter
    def disks_per_node(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disks_per_node", value)


if not MYPY:
    class DiskEncryptionPropertiesArgsDict(TypedDict):
        """
        The disk encryption properties
        """
        encryption_algorithm: NotRequired[pulumi.Input[Union[str, 'JsonWebKeyEncryptionAlgorithm']]]
        """
        Algorithm identifier for encryption, default RSA-OAEP.
        """
        encryption_at_host: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether or not resource disk encryption is enabled.
        """
        key_name: NotRequired[pulumi.Input[str]]
        """
        Key name that is used for enabling disk encryption.
        """
        key_version: NotRequired[pulumi.Input[str]]
        """
        Specific key version that is used for enabling disk encryption.
        """
        msi_resource_id: NotRequired[pulumi.Input[str]]
        """
        Resource ID of Managed Identity that is used to access the key vault.
        """
        vault_uri: NotRequired[pulumi.Input[str]]
        """
        Base key vault URI where the customers key is located eg. https://myvault.vault.azure.net
        """
elif False:
    DiskEncryptionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiskEncryptionPropertiesArgs:
    def __init__(__self__, *,
                 encryption_algorithm: Optional[pulumi.Input[Union[str, 'JsonWebKeyEncryptionAlgorithm']]] = None,
                 encryption_at_host: Optional[pulumi.Input[bool]] = None,
                 key_name: Optional[pulumi.Input[str]] = None,
                 key_version: Optional[pulumi.Input[str]] = None,
                 msi_resource_id: Optional[pulumi.Input[str]] = None,
                 vault_uri: Optional[pulumi.Input[str]] = None):
        """
        The disk encryption properties
        :param pulumi.Input[Union[str, 'JsonWebKeyEncryptionAlgorithm']] encryption_algorithm: Algorithm identifier for encryption, default RSA-OAEP.
        :param pulumi.Input[bool] encryption_at_host: Indicates whether or not resource disk encryption is enabled.
        :param pulumi.Input[str] key_name: Key name that is used for enabling disk encryption.
        :param pulumi.Input[str] key_version: Specific key version that is used for enabling disk encryption.
        :param pulumi.Input[str] msi_resource_id: Resource ID of Managed Identity that is used to access the key vault.
        :param pulumi.Input[str] vault_uri: Base key vault URI where the customers key is located eg. https://myvault.vault.azure.net
        """
        if encryption_algorithm is not None:
            pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)
        if encryption_at_host is None:
            encryption_at_host = False
        if encryption_at_host is not None:
            pulumi.set(__self__, "encryption_at_host", encryption_at_host)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if key_version is not None:
            pulumi.set(__self__, "key_version", key_version)
        if msi_resource_id is not None:
            pulumi.set(__self__, "msi_resource_id", msi_resource_id)
        if vault_uri is not None:
            pulumi.set(__self__, "vault_uri", vault_uri)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[pulumi.Input[Union[str, 'JsonWebKeyEncryptionAlgorithm']]]:
        """
        Algorithm identifier for encryption, default RSA-OAEP.
        """
        return pulumi.get(self, "encryption_algorithm")

    @encryption_algorithm.setter
    def encryption_algorithm(self, value: Optional[pulumi.Input[Union[str, 'JsonWebKeyEncryptionAlgorithm']]]):
        pulumi.set(self, "encryption_algorithm", value)

    @property
    @pulumi.getter(name="encryptionAtHost")
    def encryption_at_host(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether or not resource disk encryption is enabled.
        """
        return pulumi.get(self, "encryption_at_host")

    @encryption_at_host.setter
    def encryption_at_host(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encryption_at_host", value)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[str]]:
        """
        Key name that is used for enabling disk encryption.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_name", value)

    @property
    @pulumi.getter(name="keyVersion")
    def key_version(self) -> Optional[pulumi.Input[str]]:
        """
        Specific key version that is used for enabling disk encryption.
        """
        return pulumi.get(self, "key_version")

    @key_version.setter
    def key_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_version", value)

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID of Managed Identity that is used to access the key vault.
        """
        return pulumi.get(self, "msi_resource_id")

    @msi_resource_id.setter
    def msi_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "msi_resource_id", value)

    @property
    @pulumi.getter(name="vaultUri")
    def vault_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Base key vault URI where the customers key is located eg. https://myvault.vault.azure.net
        """
        return pulumi.get(self, "vault_uri")

    @vault_uri.setter
    def vault_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_uri", value)


if not MYPY:
    class DiskStorageProfileArgsDict(TypedDict):
        """
        Kafka disk storage profile.
        """
        data_disk_size: pulumi.Input[int]
        """
        Managed Disk size in GB. The maximum supported disk size for Standard and Premium HDD/SSD is 32TB, except for Premium SSD v2, which supports up to 64TB.
        """
        data_disk_type: pulumi.Input[Union[str, 'DataDiskType']]
        """
        Managed Disk Type.
        """
elif False:
    DiskStorageProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DiskStorageProfileArgs:
    def __init__(__self__, *,
                 data_disk_size: pulumi.Input[int],
                 data_disk_type: pulumi.Input[Union[str, 'DataDiskType']]):
        """
        Kafka disk storage profile.
        :param pulumi.Input[int] data_disk_size: Managed Disk size in GB. The maximum supported disk size for Standard and Premium HDD/SSD is 32TB, except for Premium SSD v2, which supports up to 64TB.
        :param pulumi.Input[Union[str, 'DataDiskType']] data_disk_type: Managed Disk Type.
        """
        pulumi.set(__self__, "data_disk_size", data_disk_size)
        pulumi.set(__self__, "data_disk_type", data_disk_type)

    @property
    @pulumi.getter(name="dataDiskSize")
    def data_disk_size(self) -> pulumi.Input[int]:
        """
        Managed Disk size in GB. The maximum supported disk size for Standard and Premium HDD/SSD is 32TB, except for Premium SSD v2, which supports up to 64TB.
        """
        return pulumi.get(self, "data_disk_size")

    @data_disk_size.setter
    def data_disk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "data_disk_size", value)

    @property
    @pulumi.getter(name="dataDiskType")
    def data_disk_type(self) -> pulumi.Input[Union[str, 'DataDiskType']]:
        """
        Managed Disk Type.
        """
        return pulumi.get(self, "data_disk_type")

    @data_disk_type.setter
    def data_disk_type(self, value: pulumi.Input[Union[str, 'DataDiskType']]):
        pulumi.set(self, "data_disk_type", value)


if not MYPY:
    class EncryptionInTransitPropertiesArgsDict(TypedDict):
        """
        The encryption-in-transit properties.
        """
        is_encryption_in_transit_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether or not inter cluster node communication is encrypted in transit.
        """
elif False:
    EncryptionInTransitPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionInTransitPropertiesArgs:
    def __init__(__self__, *,
                 is_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None):
        """
        The encryption-in-transit properties.
        :param pulumi.Input[bool] is_encryption_in_transit_enabled: Indicates whether or not inter cluster node communication is encrypted in transit.
        """
        if is_encryption_in_transit_enabled is None:
            is_encryption_in_transit_enabled = False
        if is_encryption_in_transit_enabled is not None:
            pulumi.set(__self__, "is_encryption_in_transit_enabled", is_encryption_in_transit_enabled)

    @property
    @pulumi.getter(name="isEncryptionInTransitEnabled")
    def is_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether or not inter cluster node communication is encrypted in transit.
        """
        return pulumi.get(self, "is_encryption_in_transit_enabled")

    @is_encryption_in_transit_enabled.setter
    def is_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_encryption_in_transit_enabled", value)


if not MYPY:
    class ErrorsArgsDict(TypedDict):
        """
        The error message associated with the cluster creation.
        """
        code: NotRequired[pulumi.Input[str]]
        """
        The error code.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        The error message.
        """
elif False:
    ErrorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ErrorsArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        """
        The error message associated with the cluster creation.
        :param pulumi.Input[str] code: The error code.
        :param pulumi.Input[str] message: The error message.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        """
        The error code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        The error message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class FlinkCatalogOptionsArgsDict(TypedDict):
        """
        Flink cluster catalog options.
        """
        hive: NotRequired[pulumi.Input['FlinkHiveCatalogOptionArgsDict']]
        """
        Hive Catalog Option for Flink cluster.
        """
elif False:
    FlinkCatalogOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlinkCatalogOptionsArgs:
    def __init__(__self__, *,
                 hive: Optional[pulumi.Input['FlinkHiveCatalogOptionArgs']] = None):
        """
        Flink cluster catalog options.
        :param pulumi.Input['FlinkHiveCatalogOptionArgs'] hive: Hive Catalog Option for Flink cluster.
        """
        if hive is not None:
            pulumi.set(__self__, "hive", hive)

    @property
    @pulumi.getter
    def hive(self) -> Optional[pulumi.Input['FlinkHiveCatalogOptionArgs']]:
        """
        Hive Catalog Option for Flink cluster.
        """
        return pulumi.get(self, "hive")

    @hive.setter
    def hive(self, value: Optional[pulumi.Input['FlinkHiveCatalogOptionArgs']]):
        pulumi.set(self, "hive", value)


if not MYPY:
    class FlinkHiveCatalogOptionArgsDict(TypedDict):
        """
        Hive Catalog Option for Flink cluster.
        """
        metastore_db_connection_url: pulumi.Input[str]
        """
        Connection string for hive metastore database.
        """
        metastore_db_connection_authentication_mode: NotRequired[pulumi.Input[Union[str, 'MetastoreDbConnectionAuthenticationMode']]]
        """
        The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        """
        metastore_db_connection_password_secret: NotRequired[pulumi.Input[str]]
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        metastore_db_connection_user_name: NotRequired[pulumi.Input[str]]
        """
        User name for database connection.
        """
elif False:
    FlinkHiveCatalogOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlinkHiveCatalogOptionArgs:
    def __init__(__self__, *,
                 metastore_db_connection_url: pulumi.Input[str],
                 metastore_db_connection_authentication_mode: Optional[pulumi.Input[Union[str, 'MetastoreDbConnectionAuthenticationMode']]] = None,
                 metastore_db_connection_password_secret: Optional[pulumi.Input[str]] = None,
                 metastore_db_connection_user_name: Optional[pulumi.Input[str]] = None):
        """
        Hive Catalog Option for Flink cluster.
        :param pulumi.Input[str] metastore_db_connection_url: Connection string for hive metastore database.
        :param pulumi.Input[Union[str, 'MetastoreDbConnectionAuthenticationMode']] metastore_db_connection_authentication_mode: The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        :param pulumi.Input[str] metastore_db_connection_password_secret: Secret reference name from secretsProfile.secrets containing password for database connection.
        :param pulumi.Input[str] metastore_db_connection_user_name: User name for database connection.
        """
        pulumi.set(__self__, "metastore_db_connection_url", metastore_db_connection_url)
        if metastore_db_connection_authentication_mode is None:
            metastore_db_connection_authentication_mode = 'IdentityAuth'
        if metastore_db_connection_authentication_mode is not None:
            pulumi.set(__self__, "metastore_db_connection_authentication_mode", metastore_db_connection_authentication_mode)
        if metastore_db_connection_password_secret is not None:
            pulumi.set(__self__, "metastore_db_connection_password_secret", metastore_db_connection_password_secret)
        if metastore_db_connection_user_name is not None:
            pulumi.set(__self__, "metastore_db_connection_user_name", metastore_db_connection_user_name)

    @property
    @pulumi.getter(name="metastoreDbConnectionURL")
    def metastore_db_connection_url(self) -> pulumi.Input[str]:
        """
        Connection string for hive metastore database.
        """
        return pulumi.get(self, "metastore_db_connection_url")

    @metastore_db_connection_url.setter
    def metastore_db_connection_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_url", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionAuthenticationMode")
    def metastore_db_connection_authentication_mode(self) -> Optional[pulumi.Input[Union[str, 'MetastoreDbConnectionAuthenticationMode']]]:
        """
        The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        """
        return pulumi.get(self, "metastore_db_connection_authentication_mode")

    @metastore_db_connection_authentication_mode.setter
    def metastore_db_connection_authentication_mode(self, value: Optional[pulumi.Input[Union[str, 'MetastoreDbConnectionAuthenticationMode']]]):
        pulumi.set(self, "metastore_db_connection_authentication_mode", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionPasswordSecret")
    def metastore_db_connection_password_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_password_secret")

    @metastore_db_connection_password_secret.setter
    def metastore_db_connection_password_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metastore_db_connection_password_secret", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionUserName")
    def metastore_db_connection_user_name(self) -> Optional[pulumi.Input[str]]:
        """
        User name for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_user_name")

    @metastore_db_connection_user_name.setter
    def metastore_db_connection_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metastore_db_connection_user_name", value)


if not MYPY:
    class FlinkJobProfileArgsDict(TypedDict):
        """
        Job specifications for flink clusters in application deployment mode. The specification is immutable even if job properties are changed by calling the RunJob API, please use the ListJob API to get the latest job information.
        """
        jar_name: pulumi.Input[str]
        """
        A string property that represents the name of the job JAR.
        """
        job_jar_directory: pulumi.Input[str]
        """
        A string property that specifies the directory where the job JAR is located.
        """
        upgrade_mode: pulumi.Input[Union[str, 'UpgradeMode']]
        """
        A string property that indicates the upgrade mode to be performed on the Flink job. It can have one of the following enum values => STATELESS_UPDATE, UPDATE, LAST_STATE_UPDATE.
        """
        args: NotRequired[pulumi.Input[str]]
        """
        A string property representing additional JVM arguments for the Flink job. It should be space separated value.
        """
        entry_class: NotRequired[pulumi.Input[str]]
        """
        A string property that specifies the entry class for the Flink job. If not specified, the entry point is auto-detected from the flink job jar package.
        """
        save_point_name: NotRequired[pulumi.Input[str]]
        """
        A string property that represents the name of the savepoint for the Flink job
        """
elif False:
    FlinkJobProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlinkJobProfileArgs:
    def __init__(__self__, *,
                 jar_name: pulumi.Input[str],
                 job_jar_directory: pulumi.Input[str],
                 upgrade_mode: pulumi.Input[Union[str, 'UpgradeMode']],
                 args: Optional[pulumi.Input[str]] = None,
                 entry_class: Optional[pulumi.Input[str]] = None,
                 save_point_name: Optional[pulumi.Input[str]] = None):
        """
        Job specifications for flink clusters in application deployment mode. The specification is immutable even if job properties are changed by calling the RunJob API, please use the ListJob API to get the latest job information.
        :param pulumi.Input[str] jar_name: A string property that represents the name of the job JAR.
        :param pulumi.Input[str] job_jar_directory: A string property that specifies the directory where the job JAR is located.
        :param pulumi.Input[Union[str, 'UpgradeMode']] upgrade_mode: A string property that indicates the upgrade mode to be performed on the Flink job. It can have one of the following enum values => STATELESS_UPDATE, UPDATE, LAST_STATE_UPDATE.
        :param pulumi.Input[str] args: A string property representing additional JVM arguments for the Flink job. It should be space separated value.
        :param pulumi.Input[str] entry_class: A string property that specifies the entry class for the Flink job. If not specified, the entry point is auto-detected from the flink job jar package.
        :param pulumi.Input[str] save_point_name: A string property that represents the name of the savepoint for the Flink job
        """
        pulumi.set(__self__, "jar_name", jar_name)
        pulumi.set(__self__, "job_jar_directory", job_jar_directory)
        pulumi.set(__self__, "upgrade_mode", upgrade_mode)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if entry_class is not None:
            pulumi.set(__self__, "entry_class", entry_class)
        if save_point_name is not None:
            pulumi.set(__self__, "save_point_name", save_point_name)

    @property
    @pulumi.getter(name="jarName")
    def jar_name(self) -> pulumi.Input[str]:
        """
        A string property that represents the name of the job JAR.
        """
        return pulumi.get(self, "jar_name")

    @jar_name.setter
    def jar_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "jar_name", value)

    @property
    @pulumi.getter(name="jobJarDirectory")
    def job_jar_directory(self) -> pulumi.Input[str]:
        """
        A string property that specifies the directory where the job JAR is located.
        """
        return pulumi.get(self, "job_jar_directory")

    @job_jar_directory.setter
    def job_jar_directory(self, value: pulumi.Input[str]):
        pulumi.set(self, "job_jar_directory", value)

    @property
    @pulumi.getter(name="upgradeMode")
    def upgrade_mode(self) -> pulumi.Input[Union[str, 'UpgradeMode']]:
        """
        A string property that indicates the upgrade mode to be performed on the Flink job. It can have one of the following enum values => STATELESS_UPDATE, UPDATE, LAST_STATE_UPDATE.
        """
        return pulumi.get(self, "upgrade_mode")

    @upgrade_mode.setter
    def upgrade_mode(self, value: pulumi.Input[Union[str, 'UpgradeMode']]):
        pulumi.set(self, "upgrade_mode", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[str]]:
        """
        A string property representing additional JVM arguments for the Flink job. It should be space separated value.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter(name="entryClass")
    def entry_class(self) -> Optional[pulumi.Input[str]]:
        """
        A string property that specifies the entry class for the Flink job. If not specified, the entry point is auto-detected from the flink job jar package.
        """
        return pulumi.get(self, "entry_class")

    @entry_class.setter
    def entry_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entry_class", value)

    @property
    @pulumi.getter(name="savePointName")
    def save_point_name(self) -> Optional[pulumi.Input[str]]:
        """
        A string property that represents the name of the savepoint for the Flink job
        """
        return pulumi.get(self, "save_point_name")

    @save_point_name.setter
    def save_point_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "save_point_name", value)


if not MYPY:
    class FlinkProfileArgsDict(TypedDict):
        """
        The Flink cluster profile.
        """
        job_manager: pulumi.Input['ComputeResourceDefinitionArgsDict']
        """
        Job Manager container/ process CPU and memory requirements
        """
        storage: pulumi.Input['FlinkStorageProfileArgsDict']
        """
        The storage profile
        """
        task_manager: pulumi.Input['ComputeResourceDefinitionArgsDict']
        """
        Task Manager container/ process CPU and memory requirements
        """
        catalog_options: NotRequired[pulumi.Input['FlinkCatalogOptionsArgsDict']]
        """
        Flink cluster catalog options.
        """
        deployment_mode: NotRequired[pulumi.Input[Union[str, 'DeploymentMode']]]
        """
        A string property that indicates the deployment mode of Flink cluster. It can have one of the following enum values => Application, Session. Default value is Session
        """
        history_server: NotRequired[pulumi.Input['ComputeResourceDefinitionArgsDict']]
        """
        History Server container/ process CPU and memory requirements
        """
        job_spec: NotRequired[pulumi.Input['FlinkJobProfileArgsDict']]
        """
        Job specifications for flink clusters in application deployment mode. The specification is immutable even if job properties are changed by calling the RunJob API, please use the ListJob API to get the latest job information.
        """
        num_replicas: NotRequired[pulumi.Input[int]]
        """
        The number of task managers.
        """
elif False:
    FlinkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlinkProfileArgs:
    def __init__(__self__, *,
                 job_manager: pulumi.Input['ComputeResourceDefinitionArgs'],
                 storage: pulumi.Input['FlinkStorageProfileArgs'],
                 task_manager: pulumi.Input['ComputeResourceDefinitionArgs'],
                 catalog_options: Optional[pulumi.Input['FlinkCatalogOptionsArgs']] = None,
                 deployment_mode: Optional[pulumi.Input[Union[str, 'DeploymentMode']]] = None,
                 history_server: Optional[pulumi.Input['ComputeResourceDefinitionArgs']] = None,
                 job_spec: Optional[pulumi.Input['FlinkJobProfileArgs']] = None,
                 num_replicas: Optional[pulumi.Input[int]] = None):
        """
        The Flink cluster profile.
        :param pulumi.Input['ComputeResourceDefinitionArgs'] job_manager: Job Manager container/ process CPU and memory requirements
        :param pulumi.Input['FlinkStorageProfileArgs'] storage: The storage profile
        :param pulumi.Input['ComputeResourceDefinitionArgs'] task_manager: Task Manager container/ process CPU and memory requirements
        :param pulumi.Input['FlinkCatalogOptionsArgs'] catalog_options: Flink cluster catalog options.
        :param pulumi.Input[Union[str, 'DeploymentMode']] deployment_mode: A string property that indicates the deployment mode of Flink cluster. It can have one of the following enum values => Application, Session. Default value is Session
        :param pulumi.Input['ComputeResourceDefinitionArgs'] history_server: History Server container/ process CPU and memory requirements
        :param pulumi.Input['FlinkJobProfileArgs'] job_spec: Job specifications for flink clusters in application deployment mode. The specification is immutable even if job properties are changed by calling the RunJob API, please use the ListJob API to get the latest job information.
        :param pulumi.Input[int] num_replicas: The number of task managers.
        """
        pulumi.set(__self__, "job_manager", job_manager)
        pulumi.set(__self__, "storage", storage)
        pulumi.set(__self__, "task_manager", task_manager)
        if catalog_options is not None:
            pulumi.set(__self__, "catalog_options", catalog_options)
        if deployment_mode is not None:
            pulumi.set(__self__, "deployment_mode", deployment_mode)
        if history_server is not None:
            pulumi.set(__self__, "history_server", history_server)
        if job_spec is not None:
            pulumi.set(__self__, "job_spec", job_spec)
        if num_replicas is not None:
            pulumi.set(__self__, "num_replicas", num_replicas)

    @property
    @pulumi.getter(name="jobManager")
    def job_manager(self) -> pulumi.Input['ComputeResourceDefinitionArgs']:
        """
        Job Manager container/ process CPU and memory requirements
        """
        return pulumi.get(self, "job_manager")

    @job_manager.setter
    def job_manager(self, value: pulumi.Input['ComputeResourceDefinitionArgs']):
        pulumi.set(self, "job_manager", value)

    @property
    @pulumi.getter
    def storage(self) -> pulumi.Input['FlinkStorageProfileArgs']:
        """
        The storage profile
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: pulumi.Input['FlinkStorageProfileArgs']):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter(name="taskManager")
    def task_manager(self) -> pulumi.Input['ComputeResourceDefinitionArgs']:
        """
        Task Manager container/ process CPU and memory requirements
        """
        return pulumi.get(self, "task_manager")

    @task_manager.setter
    def task_manager(self, value: pulumi.Input['ComputeResourceDefinitionArgs']):
        pulumi.set(self, "task_manager", value)

    @property
    @pulumi.getter(name="catalogOptions")
    def catalog_options(self) -> Optional[pulumi.Input['FlinkCatalogOptionsArgs']]:
        """
        Flink cluster catalog options.
        """
        return pulumi.get(self, "catalog_options")

    @catalog_options.setter
    def catalog_options(self, value: Optional[pulumi.Input['FlinkCatalogOptionsArgs']]):
        pulumi.set(self, "catalog_options", value)

    @property
    @pulumi.getter(name="deploymentMode")
    def deployment_mode(self) -> Optional[pulumi.Input[Union[str, 'DeploymentMode']]]:
        """
        A string property that indicates the deployment mode of Flink cluster. It can have one of the following enum values => Application, Session. Default value is Session
        """
        return pulumi.get(self, "deployment_mode")

    @deployment_mode.setter
    def deployment_mode(self, value: Optional[pulumi.Input[Union[str, 'DeploymentMode']]]):
        pulumi.set(self, "deployment_mode", value)

    @property
    @pulumi.getter(name="historyServer")
    def history_server(self) -> Optional[pulumi.Input['ComputeResourceDefinitionArgs']]:
        """
        History Server container/ process CPU and memory requirements
        """
        return pulumi.get(self, "history_server")

    @history_server.setter
    def history_server(self, value: Optional[pulumi.Input['ComputeResourceDefinitionArgs']]):
        pulumi.set(self, "history_server", value)

    @property
    @pulumi.getter(name="jobSpec")
    def job_spec(self) -> Optional[pulumi.Input['FlinkJobProfileArgs']]:
        """
        Job specifications for flink clusters in application deployment mode. The specification is immutable even if job properties are changed by calling the RunJob API, please use the ListJob API to get the latest job information.
        """
        return pulumi.get(self, "job_spec")

    @job_spec.setter
    def job_spec(self, value: Optional[pulumi.Input['FlinkJobProfileArgs']]):
        pulumi.set(self, "job_spec", value)

    @property
    @pulumi.getter(name="numReplicas")
    def num_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of task managers.
        """
        return pulumi.get(self, "num_replicas")

    @num_replicas.setter
    def num_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_replicas", value)


if not MYPY:
    class FlinkStorageProfileArgsDict(TypedDict):
        """
        The storage profile
        """
        storage_uri: pulumi.Input[str]
        """
        Storage account uri which is used for savepoint and checkpoint state.
        """
        storagekey: NotRequired[pulumi.Input[str]]
        """
        Storage key is only required for wasb(s) storage.
        """
elif False:
    FlinkStorageProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlinkStorageProfileArgs:
    def __init__(__self__, *,
                 storage_uri: pulumi.Input[str],
                 storagekey: Optional[pulumi.Input[str]] = None):
        """
        The storage profile
        :param pulumi.Input[str] storage_uri: Storage account uri which is used for savepoint and checkpoint state.
        :param pulumi.Input[str] storagekey: Storage key is only required for wasb(s) storage.
        """
        pulumi.set(__self__, "storage_uri", storage_uri)
        if storagekey is not None:
            pulumi.set(__self__, "storagekey", storagekey)

    @property
    @pulumi.getter(name="storageUri")
    def storage_uri(self) -> pulumi.Input[str]:
        """
        Storage account uri which is used for savepoint and checkpoint state.
        """
        return pulumi.get(self, "storage_uri")

    @storage_uri.setter
    def storage_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_uri", value)

    @property
    @pulumi.getter
    def storagekey(self) -> Optional[pulumi.Input[str]]:
        """
        Storage key is only required for wasb(s) storage.
        """
        return pulumi.get(self, "storagekey")

    @storagekey.setter
    def storagekey(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storagekey", value)


if not MYPY:
    class HardwareProfileArgsDict(TypedDict):
        """
        The hardware profile.
        """
        vm_size: NotRequired[pulumi.Input[str]]
        """
        The size of the VM
        """
elif False:
    HardwareProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HardwareProfileArgs:
    def __init__(__self__, *,
                 vm_size: Optional[pulumi.Input[str]] = None):
        """
        The hardware profile.
        :param pulumi.Input[str] vm_size: The size of the VM
        """
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the VM
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_size", value)


if not MYPY:
    class HiveCatalogOptionArgsDict(TypedDict):
        """
        Hive Catalog Option
        """
        catalog_name: pulumi.Input[str]
        """
        Name of trino catalog which should use specified hive metastore.
        """
        metastore_db_connection_url: pulumi.Input[str]
        """
        Connection string for hive metastore database.
        """
        metastore_warehouse_dir: pulumi.Input[str]
        """
        Metastore root directory URI, format: abfs[s]://<container>@<account_name>.dfs.core.windows.net/<path>. More details: https://docs.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-introduction-abfs-uri
        """
        metastore_db_connection_authentication_mode: NotRequired[pulumi.Input[Union[str, 'MetastoreDbConnectionAuthenticationMode']]]
        """
        The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        """
        metastore_db_connection_password_secret: NotRequired[pulumi.Input[str]]
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        metastore_db_connection_user_name: NotRequired[pulumi.Input[str]]
        """
        User name for database connection.
        """
elif False:
    HiveCatalogOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HiveCatalogOptionArgs:
    def __init__(__self__, *,
                 catalog_name: pulumi.Input[str],
                 metastore_db_connection_url: pulumi.Input[str],
                 metastore_warehouse_dir: pulumi.Input[str],
                 metastore_db_connection_authentication_mode: Optional[pulumi.Input[Union[str, 'MetastoreDbConnectionAuthenticationMode']]] = None,
                 metastore_db_connection_password_secret: Optional[pulumi.Input[str]] = None,
                 metastore_db_connection_user_name: Optional[pulumi.Input[str]] = None):
        """
        Hive Catalog Option
        :param pulumi.Input[str] catalog_name: Name of trino catalog which should use specified hive metastore.
        :param pulumi.Input[str] metastore_db_connection_url: Connection string for hive metastore database.
        :param pulumi.Input[str] metastore_warehouse_dir: Metastore root directory URI, format: abfs[s]://<container>@<account_name>.dfs.core.windows.net/<path>. More details: https://docs.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-introduction-abfs-uri
        :param pulumi.Input[Union[str, 'MetastoreDbConnectionAuthenticationMode']] metastore_db_connection_authentication_mode: The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        :param pulumi.Input[str] metastore_db_connection_password_secret: Secret reference name from secretsProfile.secrets containing password for database connection.
        :param pulumi.Input[str] metastore_db_connection_user_name: User name for database connection.
        """
        pulumi.set(__self__, "catalog_name", catalog_name)
        pulumi.set(__self__, "metastore_db_connection_url", metastore_db_connection_url)
        pulumi.set(__self__, "metastore_warehouse_dir", metastore_warehouse_dir)
        if metastore_db_connection_authentication_mode is None:
            metastore_db_connection_authentication_mode = 'IdentityAuth'
        if metastore_db_connection_authentication_mode is not None:
            pulumi.set(__self__, "metastore_db_connection_authentication_mode", metastore_db_connection_authentication_mode)
        if metastore_db_connection_password_secret is not None:
            pulumi.set(__self__, "metastore_db_connection_password_secret", metastore_db_connection_password_secret)
        if metastore_db_connection_user_name is not None:
            pulumi.set(__self__, "metastore_db_connection_user_name", metastore_db_connection_user_name)

    @property
    @pulumi.getter(name="catalogName")
    def catalog_name(self) -> pulumi.Input[str]:
        """
        Name of trino catalog which should use specified hive metastore.
        """
        return pulumi.get(self, "catalog_name")

    @catalog_name.setter
    def catalog_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "catalog_name", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionURL")
    def metastore_db_connection_url(self) -> pulumi.Input[str]:
        """
        Connection string for hive metastore database.
        """
        return pulumi.get(self, "metastore_db_connection_url")

    @metastore_db_connection_url.setter
    def metastore_db_connection_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_db_connection_url", value)

    @property
    @pulumi.getter(name="metastoreWarehouseDir")
    def metastore_warehouse_dir(self) -> pulumi.Input[str]:
        """
        Metastore root directory URI, format: abfs[s]://<container>@<account_name>.dfs.core.windows.net/<path>. More details: https://docs.microsoft.com/en-us/azure/storage/blobs/data-lake-storage-introduction-abfs-uri
        """
        return pulumi.get(self, "metastore_warehouse_dir")

    @metastore_warehouse_dir.setter
    def metastore_warehouse_dir(self, value: pulumi.Input[str]):
        pulumi.set(self, "metastore_warehouse_dir", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionAuthenticationMode")
    def metastore_db_connection_authentication_mode(self) -> Optional[pulumi.Input[Union[str, 'MetastoreDbConnectionAuthenticationMode']]]:
        """
        The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        """
        return pulumi.get(self, "metastore_db_connection_authentication_mode")

    @metastore_db_connection_authentication_mode.setter
    def metastore_db_connection_authentication_mode(self, value: Optional[pulumi.Input[Union[str, 'MetastoreDbConnectionAuthenticationMode']]]):
        pulumi.set(self, "metastore_db_connection_authentication_mode", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionPasswordSecret")
    def metastore_db_connection_password_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Secret reference name from secretsProfile.secrets containing password for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_password_secret")

    @metastore_db_connection_password_secret.setter
    def metastore_db_connection_password_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metastore_db_connection_password_secret", value)

    @property
    @pulumi.getter(name="metastoreDbConnectionUserName")
    def metastore_db_connection_user_name(self) -> Optional[pulumi.Input[str]]:
        """
        User name for database connection.
        """
        return pulumi.get(self, "metastore_db_connection_user_name")

    @metastore_db_connection_user_name.setter
    def metastore_db_connection_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metastore_db_connection_user_name", value)


if not MYPY:
    class IPConfigurationArgsDict(TypedDict):
        """
        The ip configurations for the private link service.
        """
        name: pulumi.Input[str]
        """
        The name of private link IP configuration.
        """
        primary: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether this IP configuration is primary for the corresponding NIC.
        """
        private_ip_address: NotRequired[pulumi.Input[str]]
        """
        The IP address.
        """
        private_ip_allocation_method: NotRequired[pulumi.Input[Union[str, 'PrivateIPAllocationMethod']]]
        """
        The method that private IP address is allocated.
        """
        subnet: NotRequired[pulumi.Input['ResourceIdArgsDict']]
        """
        The subnet resource id.
        """
elif False:
    IPConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IPConfigurationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 primary: Optional[pulumi.Input[bool]] = None,
                 private_ip_address: Optional[pulumi.Input[str]] = None,
                 private_ip_allocation_method: Optional[pulumi.Input[Union[str, 'PrivateIPAllocationMethod']]] = None,
                 subnet: Optional[pulumi.Input['ResourceIdArgs']] = None):
        """
        The ip configurations for the private link service.
        :param pulumi.Input[str] name: The name of private link IP configuration.
        :param pulumi.Input[bool] primary: Indicates whether this IP configuration is primary for the corresponding NIC.
        :param pulumi.Input[str] private_ip_address: The IP address.
        :param pulumi.Input[Union[str, 'PrivateIPAllocationMethod']] private_ip_allocation_method: The method that private IP address is allocated.
        :param pulumi.Input['ResourceIdArgs'] subnet: The subnet resource id.
        """
        pulumi.set(__self__, "name", name)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_allocation_method is not None:
            pulumi.set(__self__, "private_ip_allocation_method", private_ip_allocation_method)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of private link IP configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether this IP configuration is primary for the corresponding NIC.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter(name="privateIPAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter(name="privateIPAllocationMethod")
    def private_ip_allocation_method(self) -> Optional[pulumi.Input[Union[str, 'PrivateIPAllocationMethod']]]:
        """
        The method that private IP address is allocated.
        """
        return pulumi.get(self, "private_ip_allocation_method")

    @private_ip_allocation_method.setter
    def private_ip_allocation_method(self, value: Optional[pulumi.Input[Union[str, 'PrivateIPAllocationMethod']]]):
        pulumi.set(self, "private_ip_allocation_method", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input['ResourceIdArgs']]:
        """
        The subnet resource id.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input['ResourceIdArgs']]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class IdentityProfileArgsDict(TypedDict):
        """
        Identity Profile with details of an MSI.
        """
        msi_client_id: pulumi.Input[str]
        """
        ClientId of the MSI.
        """
        msi_object_id: pulumi.Input[str]
        """
        ObjectId of the MSI.
        """
        msi_resource_id: pulumi.Input[str]
        """
        ResourceId of the MSI.
        """
elif False:
    IdentityProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityProfileArgs:
    def __init__(__self__, *,
                 msi_client_id: pulumi.Input[str],
                 msi_object_id: pulumi.Input[str],
                 msi_resource_id: pulumi.Input[str]):
        """
        Identity Profile with details of an MSI.
        :param pulumi.Input[str] msi_client_id: ClientId of the MSI.
        :param pulumi.Input[str] msi_object_id: ObjectId of the MSI.
        :param pulumi.Input[str] msi_resource_id: ResourceId of the MSI.
        """
        pulumi.set(__self__, "msi_client_id", msi_client_id)
        pulumi.set(__self__, "msi_object_id", msi_object_id)
        pulumi.set(__self__, "msi_resource_id", msi_resource_id)

    @property
    @pulumi.getter(name="msiClientId")
    def msi_client_id(self) -> pulumi.Input[str]:
        """
        ClientId of the MSI.
        """
        return pulumi.get(self, "msi_client_id")

    @msi_client_id.setter
    def msi_client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "msi_client_id", value)

    @property
    @pulumi.getter(name="msiObjectId")
    def msi_object_id(self) -> pulumi.Input[str]:
        """
        ObjectId of the MSI.
        """
        return pulumi.get(self, "msi_object_id")

    @msi_object_id.setter
    def msi_object_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "msi_object_id", value)

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> pulumi.Input[str]:
        """
        ResourceId of the MSI.
        """
        return pulumi.get(self, "msi_resource_id")

    @msi_resource_id.setter
    def msi_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "msi_resource_id", value)


if not MYPY:
    class IpTagArgsDict(TypedDict):
        """
        Contains the IpTag associated with the public IP address
        """
        ip_tag_type: pulumi.Input[str]
        """
        Gets or sets the ipTag type: Example FirstPartyUsage.
        """
        tag: pulumi.Input[str]
        """
        Gets or sets value of the IpTag associated with the public IP. Example HDInsight, SQL, Storage etc
        """
elif False:
    IpTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpTagArgs:
    def __init__(__self__, *,
                 ip_tag_type: pulumi.Input[str],
                 tag: pulumi.Input[str]):
        """
        Contains the IpTag associated with the public IP address
        :param pulumi.Input[str] ip_tag_type: Gets or sets the ipTag type: Example FirstPartyUsage.
        :param pulumi.Input[str] tag: Gets or sets value of the IpTag associated with the public IP. Example HDInsight, SQL, Storage etc
        """
        pulumi.set(__self__, "ip_tag_type", ip_tag_type)
        pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="ipTagType")
    def ip_tag_type(self) -> pulumi.Input[str]:
        """
        Gets or sets the ipTag type: Example FirstPartyUsage.
        """
        return pulumi.get(self, "ip_tag_type")

    @ip_tag_type.setter
    def ip_tag_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_tag_type", value)

    @property
    @pulumi.getter
    def tag(self) -> pulumi.Input[str]:
        """
        Gets or sets value of the IpTag associated with the public IP. Example HDInsight, SQL, Storage etc
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class KafkaProfileArgsDict(TypedDict):
        """
        The Kafka cluster profile.
        """
        disk_storage: pulumi.Input['DiskStorageProfileArgsDict']
        """
        Kafka disk storage profile.
        """
        enable_k_raft: NotRequired[pulumi.Input[bool]]
        """
        Expose Kafka cluster in KRaft mode.
        """
        enable_public_endpoints: NotRequired[pulumi.Input[bool]]
        """
        Expose worker nodes as public endpoints.
        """
        remote_storage_uri: NotRequired[pulumi.Input[str]]
        """
        Fully qualified path of Azure Storage container used for Tiered Storage.
        """
elif False:
    KafkaProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaProfileArgs:
    def __init__(__self__, *,
                 disk_storage: pulumi.Input['DiskStorageProfileArgs'],
                 enable_k_raft: Optional[pulumi.Input[bool]] = None,
                 enable_public_endpoints: Optional[pulumi.Input[bool]] = None,
                 remote_storage_uri: Optional[pulumi.Input[str]] = None):
        """
        The Kafka cluster profile.
        :param pulumi.Input['DiskStorageProfileArgs'] disk_storage: Kafka disk storage profile.
        :param pulumi.Input[bool] enable_k_raft: Expose Kafka cluster in KRaft mode.
        :param pulumi.Input[bool] enable_public_endpoints: Expose worker nodes as public endpoints.
        :param pulumi.Input[str] remote_storage_uri: Fully qualified path of Azure Storage container used for Tiered Storage.
        """
        pulumi.set(__self__, "disk_storage", disk_storage)
        if enable_k_raft is None:
            enable_k_raft = True
        if enable_k_raft is not None:
            pulumi.set(__self__, "enable_k_raft", enable_k_raft)
        if enable_public_endpoints is None:
            enable_public_endpoints = False
        if enable_public_endpoints is not None:
            pulumi.set(__self__, "enable_public_endpoints", enable_public_endpoints)
        if remote_storage_uri is not None:
            pulumi.set(__self__, "remote_storage_uri", remote_storage_uri)

    @property
    @pulumi.getter(name="diskStorage")
    def disk_storage(self) -> pulumi.Input['DiskStorageProfileArgs']:
        """
        Kafka disk storage profile.
        """
        return pulumi.get(self, "disk_storage")

    @disk_storage.setter
    def disk_storage(self, value: pulumi.Input['DiskStorageProfileArgs']):
        pulumi.set(self, "disk_storage", value)

    @property
    @pulumi.getter(name="enableKRaft")
    def enable_k_raft(self) -> Optional[pulumi.Input[bool]]:
        """
        Expose Kafka cluster in KRaft mode.
        """
        return pulumi.get(self, "enable_k_raft")

    @enable_k_raft.setter
    def enable_k_raft(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_k_raft", value)

    @property
    @pulumi.getter(name="enablePublicEndpoints")
    def enable_public_endpoints(self) -> Optional[pulumi.Input[bool]]:
        """
        Expose worker nodes as public endpoints.
        """
        return pulumi.get(self, "enable_public_endpoints")

    @enable_public_endpoints.setter
    def enable_public_endpoints(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_public_endpoints", value)

    @property
    @pulumi.getter(name="remoteStorageUri")
    def remote_storage_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified path of Azure Storage container used for Tiered Storage.
        """
        return pulumi.get(self, "remote_storage_uri")

    @remote_storage_uri.setter
    def remote_storage_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_storage_uri", value)


if not MYPY:
    class KafkaRestPropertiesArgsDict(TypedDict):
        """
        The kafka rest proxy configuration which contains AAD security group information.
        """
        client_group_info: NotRequired[pulumi.Input['ClientGroupInfoArgsDict']]
        """
        The information of AAD security group.
        """
        configuration_override: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The configurations that need to be overriden.
        """
elif False:
    KafkaRestPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KafkaRestPropertiesArgs:
    def __init__(__self__, *,
                 client_group_info: Optional[pulumi.Input['ClientGroupInfoArgs']] = None,
                 configuration_override: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        The kafka rest proxy configuration which contains AAD security group information.
        :param pulumi.Input['ClientGroupInfoArgs'] client_group_info: The information of AAD security group.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] configuration_override: The configurations that need to be overriden.
        """
        if client_group_info is not None:
            pulumi.set(__self__, "client_group_info", client_group_info)
        if configuration_override is not None:
            pulumi.set(__self__, "configuration_override", configuration_override)

    @property
    @pulumi.getter(name="clientGroupInfo")
    def client_group_info(self) -> Optional[pulumi.Input['ClientGroupInfoArgs']]:
        """
        The information of AAD security group.
        """
        return pulumi.get(self, "client_group_info")

    @client_group_info.setter
    def client_group_info(self, value: Optional[pulumi.Input['ClientGroupInfoArgs']]):
        pulumi.set(self, "client_group_info", value)

    @property
    @pulumi.getter(name="configurationOverride")
    def configuration_override(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The configurations that need to be overriden.
        """
        return pulumi.get(self, "configuration_override")

    @configuration_override.setter
    def configuration_override(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "configuration_override", value)


if not MYPY:
    class LinuxOperatingSystemProfileArgsDict(TypedDict):
        """
        The ssh username, password, and ssh public key.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        The password.
        """
        ssh_profile: NotRequired[pulumi.Input['SshProfileArgsDict']]
        """
        The SSH profile.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The username.
        """
elif False:
    LinuxOperatingSystemProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LinuxOperatingSystemProfileArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 ssh_profile: Optional[pulumi.Input['SshProfileArgs']] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        The ssh username, password, and ssh public key.
        :param pulumi.Input[str] password: The password.
        :param pulumi.Input['SshProfileArgs'] ssh_profile: The SSH profile.
        :param pulumi.Input[str] username: The username.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ssh_profile is not None:
            pulumi.set(__self__, "ssh_profile", ssh_profile)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="sshProfile")
    def ssh_profile(self) -> Optional[pulumi.Input['SshProfileArgs']]:
        """
        The SSH profile.
        """
        return pulumi.get(self, "ssh_profile")

    @ssh_profile.setter
    def ssh_profile(self, value: Optional[pulumi.Input['SshProfileArgs']]):
        pulumi.set(self, "ssh_profile", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class LoadBasedConfigArgsDict(TypedDict):
        """
        Profile of load based Autoscale.
        """
        max_nodes: pulumi.Input[int]
        """
        User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        min_nodes: pulumi.Input[int]
        """
        User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        scaling_rules: pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgsDict']]]
        """
        The scaling rules.
        """
        cooldown_period: NotRequired[pulumi.Input[int]]
        """
        This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.
        """
        poll_interval: NotRequired[pulumi.Input[int]]
        """
        User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.
        """
elif False:
    LoadBasedConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBasedConfigArgs:
    def __init__(__self__, *,
                 max_nodes: pulumi.Input[int],
                 min_nodes: pulumi.Input[int],
                 scaling_rules: pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgs']]],
                 cooldown_period: Optional[pulumi.Input[int]] = None,
                 poll_interval: Optional[pulumi.Input[int]] = None):
        """
        Profile of load based Autoscale.
        :param pulumi.Input[int] max_nodes: User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        :param pulumi.Input[int] min_nodes: User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        :param pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgs']]] scaling_rules: The scaling rules.
        :param pulumi.Input[int] cooldown_period: This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.
        :param pulumi.Input[int] poll_interval: User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.
        """
        pulumi.set(__self__, "max_nodes", max_nodes)
        pulumi.set(__self__, "min_nodes", min_nodes)
        pulumi.set(__self__, "scaling_rules", scaling_rules)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if poll_interval is not None:
            pulumi.set(__self__, "poll_interval", poll_interval)

    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> pulumi.Input[int]:
        """
        User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        return pulumi.get(self, "max_nodes")

    @max_nodes.setter
    def max_nodes(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_nodes", value)

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> pulumi.Input[int]:
        """
        User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.
        """
        return pulumi.get(self, "min_nodes")

    @min_nodes.setter
    def min_nodes(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_nodes", value)

    @property
    @pulumi.getter(name="scalingRules")
    def scaling_rules(self) -> pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgs']]]:
        """
        The scaling rules.
        """
        return pulumi.get(self, "scaling_rules")

    @scaling_rules.setter
    def scaling_rules(self, value: pulumi.Input[Sequence[pulumi.Input['ScalingRuleArgs']]]):
        pulumi.set(self, "scaling_rules", value)

    @property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[pulumi.Input[int]]:
        """
        This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.
        """
        return pulumi.get(self, "cooldown_period")

    @cooldown_period.setter
    def cooldown_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown_period", value)

    @property
    @pulumi.getter(name="pollInterval")
    def poll_interval(self) -> Optional[pulumi.Input[int]]:
        """
        User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.
        """
        return pulumi.get(self, "poll_interval")

    @poll_interval.setter
    def poll_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "poll_interval", value)


if not MYPY:
    class ManagedIdentityProfileArgsDict(TypedDict):
        """
        The details of managed identity.
        """
        identity_list: pulumi.Input[Sequence[pulumi.Input['ManagedIdentitySpecArgsDict']]]
        """
        The list of managed identity.
        """
elif False:
    ManagedIdentityProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedIdentityProfileArgs:
    def __init__(__self__, *,
                 identity_list: pulumi.Input[Sequence[pulumi.Input['ManagedIdentitySpecArgs']]]):
        """
        The details of managed identity.
        :param pulumi.Input[Sequence[pulumi.Input['ManagedIdentitySpecArgs']]] identity_list: The list of managed identity.
        """
        pulumi.set(__self__, "identity_list", identity_list)

    @property
    @pulumi.getter(name="identityList")
    def identity_list(self) -> pulumi.Input[Sequence[pulumi.Input['ManagedIdentitySpecArgs']]]:
        """
        The list of managed identity.
        """
        return pulumi.get(self, "identity_list")

    @identity_list.setter
    def identity_list(self, value: pulumi.Input[Sequence[pulumi.Input['ManagedIdentitySpecArgs']]]):
        pulumi.set(self, "identity_list", value)


if not MYPY:
    class ManagedIdentitySpecArgsDict(TypedDict):
        """
        The details of a managed identity.
        """
        client_id: pulumi.Input[str]
        """
        ClientId of the managed identity.
        """
        object_id: pulumi.Input[str]
        """
        ObjectId of the managed identity.
        """
        resource_id: pulumi.Input[str]
        """
        ResourceId of the managed identity.
        """
        type: pulumi.Input[Union[str, 'ManagedIdentityType']]
        """
        The type of managed identity.
        """
elif False:
    ManagedIdentitySpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedIdentitySpecArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 object_id: pulumi.Input[str],
                 resource_id: pulumi.Input[str],
                 type: pulumi.Input[Union[str, 'ManagedIdentityType']]):
        """
        The details of a managed identity.
        :param pulumi.Input[str] client_id: ClientId of the managed identity.
        :param pulumi.Input[str] object_id: ObjectId of the managed identity.
        :param pulumi.Input[str] resource_id: ResourceId of the managed identity.
        :param pulumi.Input[Union[str, 'ManagedIdentityType']] type: The type of managed identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        ClientId of the managed identity.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> pulumi.Input[str]:
        """
        ObjectId of the managed identity.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[str]:
        """
        ResourceId of the managed identity.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedIdentityType']]:
        """
        The type of managed identity.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedIdentityType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworkPropertiesArgsDict(TypedDict):
        """
        The network properties.
        """
        outbound_dependencies_managed_type: NotRequired[pulumi.Input[Union[str, 'OutboundDependenciesManagedType']]]
        """
        A value to describe how the outbound dependencies of a HDInsight cluster are managed. 'Managed' means that the outbound dependencies are managed by the HDInsight service. 'External' means that the outbound dependencies are managed by a customer specific solution.
        """
        private_link: NotRequired[pulumi.Input[Union[str, 'PrivateLink']]]
        """
        Indicates whether or not private link is enabled.
        """
        public_ip_tag: NotRequired[pulumi.Input['IpTagArgsDict']]
        """
        Gets or sets the IP tag for the public IPs created along with the HDInsight Clusters. 
        """
        resource_provider_connection: NotRequired[pulumi.Input[Union[str, 'ResourceProviderConnection']]]
        """
        The direction for the resource provider connection.
        """
elif False:
    NetworkPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPropertiesArgs:
    def __init__(__self__, *,
                 outbound_dependencies_managed_type: Optional[pulumi.Input[Union[str, 'OutboundDependenciesManagedType']]] = None,
                 private_link: Optional[pulumi.Input[Union[str, 'PrivateLink']]] = None,
                 public_ip_tag: Optional[pulumi.Input['IpTagArgs']] = None,
                 resource_provider_connection: Optional[pulumi.Input[Union[str, 'ResourceProviderConnection']]] = None):
        """
        The network properties.
        :param pulumi.Input[Union[str, 'OutboundDependenciesManagedType']] outbound_dependencies_managed_type: A value to describe how the outbound dependencies of a HDInsight cluster are managed. 'Managed' means that the outbound dependencies are managed by the HDInsight service. 'External' means that the outbound dependencies are managed by a customer specific solution.
        :param pulumi.Input[Union[str, 'PrivateLink']] private_link: Indicates whether or not private link is enabled.
        :param pulumi.Input['IpTagArgs'] public_ip_tag: Gets or sets the IP tag for the public IPs created along with the HDInsight Clusters. 
        :param pulumi.Input[Union[str, 'ResourceProviderConnection']] resource_provider_connection: The direction for the resource provider connection.
        """
        if outbound_dependencies_managed_type is not None:
            pulumi.set(__self__, "outbound_dependencies_managed_type", outbound_dependencies_managed_type)
        if private_link is not None:
            pulumi.set(__self__, "private_link", private_link)
        if public_ip_tag is not None:
            pulumi.set(__self__, "public_ip_tag", public_ip_tag)
        if resource_provider_connection is not None:
            pulumi.set(__self__, "resource_provider_connection", resource_provider_connection)

    @property
    @pulumi.getter(name="outboundDependenciesManagedType")
    def outbound_dependencies_managed_type(self) -> Optional[pulumi.Input[Union[str, 'OutboundDependenciesManagedType']]]:
        """
        A value to describe how the outbound dependencies of a HDInsight cluster are managed. 'Managed' means that the outbound dependencies are managed by the HDInsight service. 'External' means that the outbound dependencies are managed by a customer specific solution.
        """
        return pulumi.get(self, "outbound_dependencies_managed_type")

    @outbound_dependencies_managed_type.setter
    def outbound_dependencies_managed_type(self, value: Optional[pulumi.Input[Union[str, 'OutboundDependenciesManagedType']]]):
        pulumi.set(self, "outbound_dependencies_managed_type", value)

    @property
    @pulumi.getter(name="privateLink")
    def private_link(self) -> Optional[pulumi.Input[Union[str, 'PrivateLink']]]:
        """
        Indicates whether or not private link is enabled.
        """
        return pulumi.get(self, "private_link")

    @private_link.setter
    def private_link(self, value: Optional[pulumi.Input[Union[str, 'PrivateLink']]]):
        pulumi.set(self, "private_link", value)

    @property
    @pulumi.getter(name="publicIpTag")
    def public_ip_tag(self) -> Optional[pulumi.Input['IpTagArgs']]:
        """
        Gets or sets the IP tag for the public IPs created along with the HDInsight Clusters. 
        """
        return pulumi.get(self, "public_ip_tag")

    @public_ip_tag.setter
    def public_ip_tag(self, value: Optional[pulumi.Input['IpTagArgs']]):
        pulumi.set(self, "public_ip_tag", value)

    @property
    @pulumi.getter(name="resourceProviderConnection")
    def resource_provider_connection(self) -> Optional[pulumi.Input[Union[str, 'ResourceProviderConnection']]]:
        """
        The direction for the resource provider connection.
        """
        return pulumi.get(self, "resource_provider_connection")

    @resource_provider_connection.setter
    def resource_provider_connection(self, value: Optional[pulumi.Input[Union[str, 'ResourceProviderConnection']]]):
        pulumi.set(self, "resource_provider_connection", value)


if not MYPY:
    class NodeProfileArgsDict(TypedDict):
        """
        The node profile.
        """
        count: pulumi.Input[int]
        """
        The number of virtual machines.
        """
        type: pulumi.Input[str]
        """
        The node type.
        """
        vm_size: pulumi.Input[str]
        """
        The virtual machine SKU.
        """
elif False:
    NodeProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeProfileArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 type: pulumi.Input[str],
                 vm_size: pulumi.Input[str]):
        """
        The node profile.
        :param pulumi.Input[int] count: The number of virtual machines.
        :param pulumi.Input[str] type: The node type.
        :param pulumi.Input[str] vm_size: The virtual machine SKU.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        The number of virtual machines.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The node type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> pulumi.Input[str]:
        """
        The virtual machine SKU.
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_size", value)


if not MYPY:
    class OsProfileArgsDict(TypedDict):
        """
        The Linux operation systems profile.
        """
        linux_operating_system_profile: NotRequired[pulumi.Input['LinuxOperatingSystemProfileArgsDict']]
        """
        The Linux OS profile.
        """
elif False:
    OsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OsProfileArgs:
    def __init__(__self__, *,
                 linux_operating_system_profile: Optional[pulumi.Input['LinuxOperatingSystemProfileArgs']] = None):
        """
        The Linux operation systems profile.
        :param pulumi.Input['LinuxOperatingSystemProfileArgs'] linux_operating_system_profile: The Linux OS profile.
        """
        if linux_operating_system_profile is not None:
            pulumi.set(__self__, "linux_operating_system_profile", linux_operating_system_profile)

    @property
    @pulumi.getter(name="linuxOperatingSystemProfile")
    def linux_operating_system_profile(self) -> Optional[pulumi.Input['LinuxOperatingSystemProfileArgs']]:
        """
        The Linux OS profile.
        """
        return pulumi.get(self, "linux_operating_system_profile")

    @linux_operating_system_profile.setter
    def linux_operating_system_profile(self, value: Optional[pulumi.Input['LinuxOperatingSystemProfileArgs']]):
        pulumi.set(self, "linux_operating_system_profile", value)


if not MYPY:
    class PrivateLinkConfigurationArgsDict(TypedDict):
        """
        The private link configuration.
        """
        group_id: pulumi.Input[str]
        """
        The HDInsight private linkable sub-resource name to apply the private link configuration to. For example, 'headnode', 'gateway', 'edgenode'.
        """
        ip_configurations: pulumi.Input[Sequence[pulumi.Input['IPConfigurationArgsDict']]]
        """
        The IP configurations for the private link service.
        """
        name: pulumi.Input[str]
        """
        The name of private link configuration.
        """
elif False:
    PrivateLinkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateLinkConfigurationArgs:
    def __init__(__self__, *,
                 group_id: pulumi.Input[str],
                 ip_configurations: pulumi.Input[Sequence[pulumi.Input['IPConfigurationArgs']]],
                 name: pulumi.Input[str]):
        """
        The private link configuration.
        :param pulumi.Input[str] group_id: The HDInsight private linkable sub-resource name to apply the private link configuration to. For example, 'headnode', 'gateway', 'edgenode'.
        :param pulumi.Input[Sequence[pulumi.Input['IPConfigurationArgs']]] ip_configurations: The IP configurations for the private link service.
        :param pulumi.Input[str] name: The name of private link configuration.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "ip_configurations", ip_configurations)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Input[str]:
        """
        The HDInsight private linkable sub-resource name to apply the private link configuration to. For example, 'headnode', 'gateway', 'edgenode'.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="ipConfigurations")
    def ip_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['IPConfigurationArgs']]]:
        """
        The IP configurations for the private link service.
        """
        return pulumi.get(self, "ip_configurations")

    @ip_configurations.setter
    def ip_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['IPConfigurationArgs']]]):
        pulumi.set(self, "ip_configurations", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of private link configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PrivateLinkServiceConnectionStateArgsDict(TypedDict):
        """
        The private link service connection state.
        """
        status: pulumi.Input[Union[str, 'PrivateLinkServiceConnectionStatus']]
        """
        The concrete private link service connection.
        """
        actions_required: NotRequired[pulumi.Input[str]]
        """
        Whether there is further actions.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The optional description of the status.
        """
elif False:
    PrivateLinkServiceConnectionStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateLinkServiceConnectionStateArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[Union[str, 'PrivateLinkServiceConnectionStatus']],
                 actions_required: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None):
        """
        The private link service connection state.
        :param pulumi.Input[Union[str, 'PrivateLinkServiceConnectionStatus']] status: The concrete private link service connection.
        :param pulumi.Input[str] actions_required: Whether there is further actions.
        :param pulumi.Input[str] description: The optional description of the status.
        """
        pulumi.set(__self__, "status", status)
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[Union[str, 'PrivateLinkServiceConnectionStatus']]:
        """
        The concrete private link service connection.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[Union[str, 'PrivateLinkServiceConnectionStatus']]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[pulumi.Input[str]]:
        """
        Whether there is further actions.
        """
        return pulumi.get(self, "actions_required")

    @actions_required.setter
    def actions_required(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "actions_required", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The optional description of the status.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class RangerAdminSpecDatabaseArgsDict(TypedDict):
        host: pulumi.Input[str]
        """
        The database URL
        """
        name: pulumi.Input[str]
        """
        The database name
        """
        password_secret_ref: NotRequired[pulumi.Input[str]]
        """
        Reference for the database password
        """
        username: NotRequired[pulumi.Input[str]]
        """
        The name of the database user
        """
elif False:
    RangerAdminSpecDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RangerAdminSpecDatabaseArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 name: pulumi.Input[str],
                 password_secret_ref: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The database URL
        :param pulumi.Input[str] name: The database name
        :param pulumi.Input[str] password_secret_ref: Reference for the database password
        :param pulumi.Input[str] username: The name of the database user
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "name", name)
        if password_secret_ref is not None:
            pulumi.set(__self__, "password_secret_ref", password_secret_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The database URL
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The database name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="passwordSecretRef")
    def password_secret_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Reference for the database password
        """
        return pulumi.get(self, "password_secret_ref")

    @password_secret_ref.setter
    def password_secret_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_secret_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the database user
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class RangerAdminSpecArgsDict(TypedDict):
        """
        Specification for the Ranger Admin service.
        """
        admins: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of usernames that should be marked as ranger admins. These usernames should match the user principal name (UPN) of the respective AAD users.
        """
        database: pulumi.Input['RangerAdminSpecDatabaseArgsDict']
elif False:
    RangerAdminSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RangerAdminSpecArgs:
    def __init__(__self__, *,
                 admins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 database: pulumi.Input['RangerAdminSpecDatabaseArgs']):
        """
        Specification for the Ranger Admin service.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] admins: List of usernames that should be marked as ranger admins. These usernames should match the user principal name (UPN) of the respective AAD users.
        """
        pulumi.set(__self__, "admins", admins)
        pulumi.set(__self__, "database", database)

    @property
    @pulumi.getter
    def admins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of usernames that should be marked as ranger admins. These usernames should match the user principal name (UPN) of the respective AAD users.
        """
        return pulumi.get(self, "admins")

    @admins.setter
    def admins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "admins", value)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input['RangerAdminSpecDatabaseArgs']:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input['RangerAdminSpecDatabaseArgs']):
        pulumi.set(self, "database", value)


if not MYPY:
    class RangerAuditSpecArgsDict(TypedDict):
        """
        Properties required to describe audit log storage.
        """
        storage_account: NotRequired[pulumi.Input[str]]
        """
        Azure storage location of the blobs. MSI should have read/write access to this Storage account.
        """
elif False:
    RangerAuditSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RangerAuditSpecArgs:
    def __init__(__self__, *,
                 storage_account: Optional[pulumi.Input[str]] = None):
        """
        Properties required to describe audit log storage.
        :param pulumi.Input[str] storage_account: Azure storage location of the blobs. MSI should have read/write access to this Storage account.
        """
        if storage_account is not None:
            pulumi.set(__self__, "storage_account", storage_account)

    @property
    @pulumi.getter(name="storageAccount")
    def storage_account(self) -> Optional[pulumi.Input[str]]:
        """
        Azure storage location of the blobs. MSI should have read/write access to this Storage account.
        """
        return pulumi.get(self, "storage_account")

    @storage_account.setter
    def storage_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_account", value)


if not MYPY:
    class RangerProfileArgsDict(TypedDict):
        """
        The ranger cluster profile.
        """
        ranger_admin: pulumi.Input['RangerAdminSpecArgsDict']
        """
        Specification for the Ranger Admin service.
        """
        ranger_usersync: pulumi.Input['RangerUsersyncSpecArgsDict']
        """
        Specification for the Ranger Usersync service
        """
        ranger_audit: NotRequired[pulumi.Input['RangerAuditSpecArgsDict']]
        """
        Properties required to describe audit log storage.
        """
elif False:
    RangerProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RangerProfileArgs:
    def __init__(__self__, *,
                 ranger_admin: pulumi.Input['RangerAdminSpecArgs'],
                 ranger_usersync: pulumi.Input['RangerUsersyncSpecArgs'],
                 ranger_audit: Optional[pulumi.Input['RangerAuditSpecArgs']] = None):
        """
        The ranger cluster profile.
        :param pulumi.Input['RangerAdminSpecArgs'] ranger_admin: Specification for the Ranger Admin service.
        :param pulumi.Input['RangerUsersyncSpecArgs'] ranger_usersync: Specification for the Ranger Usersync service
        :param pulumi.Input['RangerAuditSpecArgs'] ranger_audit: Properties required to describe audit log storage.
        """
        pulumi.set(__self__, "ranger_admin", ranger_admin)
        pulumi.set(__self__, "ranger_usersync", ranger_usersync)
        if ranger_audit is not None:
            pulumi.set(__self__, "ranger_audit", ranger_audit)

    @property
    @pulumi.getter(name="rangerAdmin")
    def ranger_admin(self) -> pulumi.Input['RangerAdminSpecArgs']:
        """
        Specification for the Ranger Admin service.
        """
        return pulumi.get(self, "ranger_admin")

    @ranger_admin.setter
    def ranger_admin(self, value: pulumi.Input['RangerAdminSpecArgs']):
        pulumi.set(self, "ranger_admin", value)

    @property
    @pulumi.getter(name="rangerUsersync")
    def ranger_usersync(self) -> pulumi.Input['RangerUsersyncSpecArgs']:
        """
        Specification for the Ranger Usersync service
        """
        return pulumi.get(self, "ranger_usersync")

    @ranger_usersync.setter
    def ranger_usersync(self, value: pulumi.Input['RangerUsersyncSpecArgs']):
        pulumi.set(self, "ranger_usersync", value)

    @property
    @pulumi.getter(name="rangerAudit")
    def ranger_audit(self) -> Optional[pulumi.Input['RangerAuditSpecArgs']]:
        """
        Properties required to describe audit log storage.
        """
        return pulumi.get(self, "ranger_audit")

    @ranger_audit.setter
    def ranger_audit(self, value: Optional[pulumi.Input['RangerAuditSpecArgs']]):
        pulumi.set(self, "ranger_audit", value)


if not MYPY:
    class RangerUsersyncSpecArgsDict(TypedDict):
        """
        Specification for the Ranger Usersync service
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Denotes whether usersync service should be enabled
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of groups that should be synced. These group names should match the object id of the respective AAD groups.
        """
        mode: NotRequired[pulumi.Input[Union[str, 'RangerUsersyncMode']]]
        """
        User & groups can be synced automatically or via a static list that's refreshed.
        """
        user_mapping_location: NotRequired[pulumi.Input[str]]
        """
        Azure storage location of a mapping file that lists user & group associations.
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of user names that should be synced. These usernames should match the User principal name of the respective AAD users.
        """
elif False:
    RangerUsersyncSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RangerUsersyncSpecArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mode: Optional[pulumi.Input[Union[str, 'RangerUsersyncMode']]] = None,
                 user_mapping_location: Optional[pulumi.Input[str]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Specification for the Ranger Usersync service
        :param pulumi.Input[bool] enabled: Denotes whether usersync service should be enabled
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: List of groups that should be synced. These group names should match the object id of the respective AAD groups.
        :param pulumi.Input[Union[str, 'RangerUsersyncMode']] mode: User & groups can be synced automatically or via a static list that's refreshed.
        :param pulumi.Input[str] user_mapping_location: Azure storage location of a mapping file that lists user & group associations.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] users: List of user names that should be synced. These usernames should match the User principal name of the respective AAD users.
        """
        if enabled is None:
            enabled = True
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if mode is None:
            mode = 'automatic'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if user_mapping_location is not None:
            pulumi.set(__self__, "user_mapping_location", user_mapping_location)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Denotes whether usersync service should be enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of groups that should be synced. These group names should match the object id of the respective AAD groups.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[str, 'RangerUsersyncMode']]]:
        """
        User & groups can be synced automatically or via a static list that's refreshed.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[str, 'RangerUsersyncMode']]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="userMappingLocation")
    def user_mapping_location(self) -> Optional[pulumi.Input[str]]:
        """
        Azure storage location of a mapping file that lists user & group associations.
        """
        return pulumi.get(self, "user_mapping_location")

    @user_mapping_location.setter
    def user_mapping_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_mapping_location", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of user names that should be synced. These usernames should match the User principal name of the respective AAD users.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class ResourceIdArgsDict(TypedDict):
        """
        The azure resource id.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The azure resource id.
        """
elif False:
    ResourceIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceIdArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        The azure resource id.
        :param pulumi.Input[str] id: The azure resource id.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The azure resource id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class RoleArgsDict(TypedDict):
        """
        Describes a role on the cluster.
        """
        autoscale_configuration: NotRequired[pulumi.Input['AutoscaleArgsDict']]
        """
        The autoscale configurations.
        """
        data_disks_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataDisksGroupsArgsDict']]]]
        """
        The data disks groups for the role.
        """
        encrypt_data_disks: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether encrypt the data disks.
        """
        hardware_profile: NotRequired[pulumi.Input['HardwareProfileArgsDict']]
        """
        The hardware profile.
        """
        min_instance_count: NotRequired[pulumi.Input[int]]
        """
        The minimum instance count of the cluster.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the role.
        """
        os_profile: NotRequired[pulumi.Input['OsProfileArgsDict']]
        """
        The operating system profile.
        """
        script_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScriptActionArgsDict']]]]
        """
        The list of script actions on the role.
        """
        target_instance_count: NotRequired[pulumi.Input[int]]
        """
        The instance count of the cluster.
        """
        v_m_group_name: NotRequired[pulumi.Input[str]]
        """
        The name of the virtual machine group.
        """
        virtual_network_profile: NotRequired[pulumi.Input['VirtualNetworkProfileArgsDict']]
        """
        The virtual network profile.
        """
elif False:
    RoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleArgs:
    def __init__(__self__, *,
                 autoscale_configuration: Optional[pulumi.Input['AutoscaleArgs']] = None,
                 data_disks_groups: Optional[pulumi.Input[Sequence[pulumi.Input['DataDisksGroupsArgs']]]] = None,
                 encrypt_data_disks: Optional[pulumi.Input[bool]] = None,
                 hardware_profile: Optional[pulumi.Input['HardwareProfileArgs']] = None,
                 min_instance_count: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 os_profile: Optional[pulumi.Input['OsProfileArgs']] = None,
                 script_actions: Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionArgs']]]] = None,
                 target_instance_count: Optional[pulumi.Input[int]] = None,
                 v_m_group_name: Optional[pulumi.Input[str]] = None,
                 virtual_network_profile: Optional[pulumi.Input['VirtualNetworkProfileArgs']] = None):
        """
        Describes a role on the cluster.
        :param pulumi.Input['AutoscaleArgs'] autoscale_configuration: The autoscale configurations.
        :param pulumi.Input[Sequence[pulumi.Input['DataDisksGroupsArgs']]] data_disks_groups: The data disks groups for the role.
        :param pulumi.Input[bool] encrypt_data_disks: Indicates whether encrypt the data disks.
        :param pulumi.Input['HardwareProfileArgs'] hardware_profile: The hardware profile.
        :param pulumi.Input[int] min_instance_count: The minimum instance count of the cluster.
        :param pulumi.Input[str] name: The name of the role.
        :param pulumi.Input['OsProfileArgs'] os_profile: The operating system profile.
        :param pulumi.Input[Sequence[pulumi.Input['ScriptActionArgs']]] script_actions: The list of script actions on the role.
        :param pulumi.Input[int] target_instance_count: The instance count of the cluster.
        :param pulumi.Input[str] v_m_group_name: The name of the virtual machine group.
        :param pulumi.Input['VirtualNetworkProfileArgs'] virtual_network_profile: The virtual network profile.
        """
        if autoscale_configuration is not None:
            pulumi.set(__self__, "autoscale_configuration", autoscale_configuration)
        if data_disks_groups is not None:
            pulumi.set(__self__, "data_disks_groups", data_disks_groups)
        if encrypt_data_disks is None:
            encrypt_data_disks = False
        if encrypt_data_disks is not None:
            pulumi.set(__self__, "encrypt_data_disks", encrypt_data_disks)
        if hardware_profile is not None:
            pulumi.set(__self__, "hardware_profile", hardware_profile)
        if min_instance_count is not None:
            pulumi.set(__self__, "min_instance_count", min_instance_count)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if os_profile is not None:
            pulumi.set(__self__, "os_profile", os_profile)
        if script_actions is not None:
            pulumi.set(__self__, "script_actions", script_actions)
        if target_instance_count is not None:
            pulumi.set(__self__, "target_instance_count", target_instance_count)
        if v_m_group_name is not None:
            pulumi.set(__self__, "v_m_group_name", v_m_group_name)
        if virtual_network_profile is not None:
            pulumi.set(__self__, "virtual_network_profile", virtual_network_profile)

    @property
    @pulumi.getter(name="autoscaleConfiguration")
    def autoscale_configuration(self) -> Optional[pulumi.Input['AutoscaleArgs']]:
        """
        The autoscale configurations.
        """
        return pulumi.get(self, "autoscale_configuration")

    @autoscale_configuration.setter
    def autoscale_configuration(self, value: Optional[pulumi.Input['AutoscaleArgs']]):
        pulumi.set(self, "autoscale_configuration", value)

    @property
    @pulumi.getter(name="dataDisksGroups")
    def data_disks_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataDisksGroupsArgs']]]]:
        """
        The data disks groups for the role.
        """
        return pulumi.get(self, "data_disks_groups")

    @data_disks_groups.setter
    def data_disks_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataDisksGroupsArgs']]]]):
        pulumi.set(self, "data_disks_groups", value)

    @property
    @pulumi.getter(name="encryptDataDisks")
    def encrypt_data_disks(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether encrypt the data disks.
        """
        return pulumi.get(self, "encrypt_data_disks")

    @encrypt_data_disks.setter
    def encrypt_data_disks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypt_data_disks", value)

    @property
    @pulumi.getter(name="hardwareProfile")
    def hardware_profile(self) -> Optional[pulumi.Input['HardwareProfileArgs']]:
        """
        The hardware profile.
        """
        return pulumi.get(self, "hardware_profile")

    @hardware_profile.setter
    def hardware_profile(self, value: Optional[pulumi.Input['HardwareProfileArgs']]):
        pulumi.set(self, "hardware_profile", value)

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum instance count of the cluster.
        """
        return pulumi.get(self, "min_instance_count")

    @min_instance_count.setter
    def min_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_instance_count", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the role.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="osProfile")
    def os_profile(self) -> Optional[pulumi.Input['OsProfileArgs']]:
        """
        The operating system profile.
        """
        return pulumi.get(self, "os_profile")

    @os_profile.setter
    def os_profile(self, value: Optional[pulumi.Input['OsProfileArgs']]):
        pulumi.set(self, "os_profile", value)

    @property
    @pulumi.getter(name="scriptActions")
    def script_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionArgs']]]]:
        """
        The list of script actions on the role.
        """
        return pulumi.get(self, "script_actions")

    @script_actions.setter
    def script_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScriptActionArgs']]]]):
        pulumi.set(self, "script_actions", value)

    @property
    @pulumi.getter(name="targetInstanceCount")
    def target_instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The instance count of the cluster.
        """
        return pulumi.get(self, "target_instance_count")

    @target_instance_count.setter
    def target_instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_instance_count", value)

    @property
    @pulumi.getter(name="vMGroupName")
    def v_m_group_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the virtual machine group.
        """
        return pulumi.get(self, "v_m_group_name")

    @v_m_group_name.setter
    def v_m_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "v_m_group_name", value)

    @property
    @pulumi.getter(name="virtualNetworkProfile")
    def virtual_network_profile(self) -> Optional[pulumi.Input['VirtualNetworkProfileArgs']]:
        """
        The virtual network profile.
        """
        return pulumi.get(self, "virtual_network_profile")

    @virtual_network_profile.setter
    def virtual_network_profile(self, value: Optional[pulumi.Input['VirtualNetworkProfileArgs']]):
        pulumi.set(self, "virtual_network_profile", value)


if not MYPY:
    class RuntimeScriptActionArgsDict(TypedDict):
        """
        Describes a script action on a running cluster.
        """
        name: pulumi.Input[str]
        """
        The name of the script action.
        """
        roles: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of roles where script will be executed.
        """
        uri: pulumi.Input[str]
        """
        The URI to the script.
        """
        parameters: NotRequired[pulumi.Input[str]]
        """
        The parameters for the script
        """
elif False:
    RuntimeScriptActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuntimeScriptActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 roles: pulumi.Input[Sequence[pulumi.Input[str]]],
                 uri: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[str]] = None):
        """
        Describes a script action on a running cluster.
        :param pulumi.Input[str] name: The name of the script action.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] roles: The list of roles where script will be executed.
        :param pulumi.Input[str] uri: The URI to the script.
        :param pulumi.Input[str] parameters: The parameters for the script
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "uri", uri)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def roles(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of roles where script will be executed.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "roles", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[str]]:
        """
        The parameters for the script
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class ScalingRuleArgsDict(TypedDict):
        """
        The scaling rule.
        """
        action_type: pulumi.Input[Union[str, 'ScaleActionType']]
        """
        The action type.
        """
        comparison_rule: pulumi.Input['ComparisonRuleArgsDict']
        """
        The comparison rule.
        """
        evaluation_count: pulumi.Input[int]
        """
        This is an evaluation count for a scaling condition, the number of times a trigger condition should be successful, before scaling activity is triggered.
        """
        scaling_metric: pulumi.Input[str]
        """
        Metrics name for individual workloads. For example: cpu
        """
elif False:
    ScalingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScalingRuleArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[Union[str, 'ScaleActionType']],
                 comparison_rule: pulumi.Input['ComparisonRuleArgs'],
                 evaluation_count: pulumi.Input[int],
                 scaling_metric: pulumi.Input[str]):
        """
        The scaling rule.
        :param pulumi.Input[Union[str, 'ScaleActionType']] action_type: The action type.
        :param pulumi.Input['ComparisonRuleArgs'] comparison_rule: The comparison rule.
        :param pulumi.Input[int] evaluation_count: This is an evaluation count for a scaling condition, the number of times a trigger condition should be successful, before scaling activity is triggered.
        :param pulumi.Input[str] scaling_metric: Metrics name for individual workloads. For example: cpu
        """
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "comparison_rule", comparison_rule)
        pulumi.set(__self__, "evaluation_count", evaluation_count)
        pulumi.set(__self__, "scaling_metric", scaling_metric)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[Union[str, 'ScaleActionType']]:
        """
        The action type.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[Union[str, 'ScaleActionType']]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="comparisonRule")
    def comparison_rule(self) -> pulumi.Input['ComparisonRuleArgs']:
        """
        The comparison rule.
        """
        return pulumi.get(self, "comparison_rule")

    @comparison_rule.setter
    def comparison_rule(self, value: pulumi.Input['ComparisonRuleArgs']):
        pulumi.set(self, "comparison_rule", value)

    @property
    @pulumi.getter(name="evaluationCount")
    def evaluation_count(self) -> pulumi.Input[int]:
        """
        This is an evaluation count for a scaling condition, the number of times a trigger condition should be successful, before scaling activity is triggered.
        """
        return pulumi.get(self, "evaluation_count")

    @evaluation_count.setter
    def evaluation_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "evaluation_count", value)

    @property
    @pulumi.getter(name="scalingMetric")
    def scaling_metric(self) -> pulumi.Input[str]:
        """
        Metrics name for individual workloads. For example: cpu
        """
        return pulumi.get(self, "scaling_metric")

    @scaling_metric.setter
    def scaling_metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "scaling_metric", value)


if not MYPY:
    class ScheduleBasedConfigArgsDict(TypedDict):
        """
        Profile of schedule based Autoscale.
        """
        default_count: pulumi.Input[int]
        """
        Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)
        """
        schedules: pulumi.Input[Sequence[pulumi.Input['ScheduleArgsDict']]]
        """
        This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).
        """
        time_zone: pulumi.Input[str]
        """
        User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        """
elif False:
    ScheduleBasedConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleBasedConfigArgs:
    def __init__(__self__, *,
                 default_count: pulumi.Input[int],
                 schedules: pulumi.Input[Sequence[pulumi.Input['ScheduleArgs']]],
                 time_zone: pulumi.Input[str]):
        """
        Profile of schedule based Autoscale.
        :param pulumi.Input[int] default_count: Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleArgs']]] schedules: This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).
        :param pulumi.Input[str] time_zone: User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        """
        pulumi.set(__self__, "default_count", default_count)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="defaultCount")
    def default_count(self) -> pulumi.Input[int]:
        """
        Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)
        """
        return pulumi.get(self, "default_count")

    @default_count.setter
    def default_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "default_count", value)

    @property
    @pulumi.getter
    def schedules(self) -> pulumi.Input[Sequence[pulumi.Input['ScheduleArgs']]]:
        """
        This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).
        """
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: pulumi.Input[Sequence[pulumi.Input['ScheduleArgs']]]):
        pulumi.set(self, "schedules", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[str]:
        """
        User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class ScheduleArgsDict(TypedDict):
        """
        Schedule definition.
        """
        count: pulumi.Input[int]
        """
        User has to set the node count anticipated at end of the scaling operation of the set current schedule configuration, format is integer.
        """
        days: pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]]
        """
        User has to set the days where schedule has to be set for autoscale operation.
        """
        end_time: pulumi.Input[str]
        """
        User has to set the end time of current schedule configuration, format like 10:30 (HH:MM).
        """
        start_time: pulumi.Input[str]
        """
        User has to set the start time of current schedule configuration, format like 10:30 (HH:MM).
        """
elif False:
    ScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 days: pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]],
                 end_time: pulumi.Input[str],
                 start_time: pulumi.Input[str]):
        """
        Schedule definition.
        :param pulumi.Input[int] count: User has to set the node count anticipated at end of the scaling operation of the set current schedule configuration, format is integer.
        :param pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]] days: User has to set the days where schedule has to be set for autoscale operation.
        :param pulumi.Input[str] end_time: User has to set the end time of current schedule configuration, format like 10:30 (HH:MM).
        :param pulumi.Input[str] start_time: User has to set the start time of current schedule configuration, format like 10:30 (HH:MM).
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        User has to set the node count anticipated at end of the scaling operation of the set current schedule configuration, format is integer.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def days(self) -> pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]]:
        """
        User has to set the days where schedule has to be set for autoscale operation.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[Sequence[pulumi.Input[Union[str, 'ScheduleDay']]]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[str]:
        """
        User has to set the end time of current schedule configuration, format like 10:30 (HH:MM).
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        User has to set the start time of current schedule configuration, format like 10:30 (HH:MM).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class ScriptActionProfileArgsDict(TypedDict):
        """
        The script action profile.
        """
        name: pulumi.Input[str]
        """
        Script name.
        """
        services: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of services to apply the script action.
        """
        type: pulumi.Input[str]
        """
        Type of the script action. Supported type is bash scripts.
        """
        url: pulumi.Input[str]
        """
        Url of the script file.
        """
        parameters: NotRequired[pulumi.Input[str]]
        """
        Additional parameters for the script action. It should be space-separated list of arguments required for script execution.
        """
        should_persist: NotRequired[pulumi.Input[bool]]
        """
        Specify if the script should persist on the cluster.
        """
        timeout_in_minutes: NotRequired[pulumi.Input[int]]
        """
        Timeout duration for the script action in minutes.
        """
elif False:
    ScriptActionProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScriptActionProfileArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 services: pulumi.Input[Sequence[pulumi.Input[str]]],
                 type: pulumi.Input[str],
                 url: pulumi.Input[str],
                 parameters: Optional[pulumi.Input[str]] = None,
                 should_persist: Optional[pulumi.Input[bool]] = None,
                 timeout_in_minutes: Optional[pulumi.Input[int]] = None):
        """
        The script action profile.
        :param pulumi.Input[str] name: Script name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of services to apply the script action.
        :param pulumi.Input[str] type: Type of the script action. Supported type is bash scripts.
        :param pulumi.Input[str] url: Url of the script file.
        :param pulumi.Input[str] parameters: Additional parameters for the script action. It should be space-separated list of arguments required for script execution.
        :param pulumi.Input[bool] should_persist: Specify if the script should persist on the cluster.
        :param pulumi.Input[int] timeout_in_minutes: Timeout duration for the script action in minutes.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if should_persist is None:
            should_persist = True
        if should_persist is not None:
            pulumi.set(__self__, "should_persist", should_persist)
        if timeout_in_minutes is not None:
            pulumi.set(__self__, "timeout_in_minutes", timeout_in_minutes)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Script name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def services(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of services to apply the script action.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the script action. Supported type is bash scripts.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Url of the script file.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[str]]:
        """
        Additional parameters for the script action. It should be space-separated list of arguments required for script execution.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="shouldPersist")
    def should_persist(self) -> Optional[pulumi.Input[bool]]:
        """
        Specify if the script should persist on the cluster.
        """
        return pulumi.get(self, "should_persist")

    @should_persist.setter
    def should_persist(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_persist", value)

    @property
    @pulumi.getter(name="timeoutInMinutes")
    def timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Timeout duration for the script action in minutes.
        """
        return pulumi.get(self, "timeout_in_minutes")

    @timeout_in_minutes.setter
    def timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_minutes", value)


if not MYPY:
    class ScriptActionArgsDict(TypedDict):
        """
        Describes a script action on role on the cluster.
        """
        name: pulumi.Input[str]
        """
        The name of the script action.
        """
        parameters: pulumi.Input[str]
        """
        The parameters for the script provided.
        """
        uri: pulumi.Input[str]
        """
        The URI to the script.
        """
elif False:
    ScriptActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScriptActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 parameters: pulumi.Input[str],
                 uri: pulumi.Input[str]):
        """
        Describes a script action on role on the cluster.
        :param pulumi.Input[str] name: The name of the script action.
        :param pulumi.Input[str] parameters: The parameters for the script provided.
        :param pulumi.Input[str] uri: The URI to the script.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parameters", parameters)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the script action.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input[str]:
        """
        The parameters for the script provided.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input[str]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The URI to the script.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class SecretReferenceArgsDict(TypedDict):
        """
        Secret reference and corresponding properties of a key vault secret.
        """
        key_vault_object_name: pulumi.Input[str]
        """
        Object identifier name of the secret in key vault.
        """
        reference_name: pulumi.Input[str]
        """
        Reference name of the secret to be used in service configs.
        """
        type: pulumi.Input[Union[str, 'KeyVaultObjectType']]
        """
        Type of key vault object: secret, key or certificate.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the secret in key vault.
        """
elif False:
    SecretReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretReferenceArgs:
    def __init__(__self__, *,
                 key_vault_object_name: pulumi.Input[str],
                 reference_name: pulumi.Input[str],
                 type: pulumi.Input[Union[str, 'KeyVaultObjectType']],
                 version: Optional[pulumi.Input[str]] = None):
        """
        Secret reference and corresponding properties of a key vault secret.
        :param pulumi.Input[str] key_vault_object_name: Object identifier name of the secret in key vault.
        :param pulumi.Input[str] reference_name: Reference name of the secret to be used in service configs.
        :param pulumi.Input[Union[str, 'KeyVaultObjectType']] type: Type of key vault object: secret, key or certificate.
        :param pulumi.Input[str] version: Version of the secret in key vault.
        """
        pulumi.set(__self__, "key_vault_object_name", key_vault_object_name)
        pulumi.set(__self__, "reference_name", reference_name)
        pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="keyVaultObjectName")
    def key_vault_object_name(self) -> pulumi.Input[str]:
        """
        Object identifier name of the secret in key vault.
        """
        return pulumi.get(self, "key_vault_object_name")

    @key_vault_object_name.setter
    def key_vault_object_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_object_name", value)

    @property
    @pulumi.getter(name="referenceName")
    def reference_name(self) -> pulumi.Input[str]:
        """
        Reference name of the secret to be used in service configs.
        """
        return pulumi.get(self, "reference_name")

    @reference_name.setter
    def reference_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "reference_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'KeyVaultObjectType']]:
        """
        Type of key vault object: secret, key or certificate.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'KeyVaultObjectType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the secret in key vault.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class SecretsProfileArgsDict(TypedDict):
        """
        The cluster secret profile.
        """
        key_vault_resource_id: pulumi.Input[str]
        """
        Name of the user Key Vault where all the cluster specific user secrets are stored.
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgsDict']]]]
        """
        Properties of Key Vault secret.
        """
elif False:
    SecretsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretsProfileArgs:
    def __init__(__self__, *,
                 key_vault_resource_id: pulumi.Input[str],
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgs']]]] = None):
        """
        The cluster secret profile.
        :param pulumi.Input[str] key_vault_resource_id: Name of the user Key Vault where all the cluster specific user secrets are stored.
        :param pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgs']]] secrets: Properties of Key Vault secret.
        """
        pulumi.set(__self__, "key_vault_resource_id", key_vault_resource_id)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter(name="keyVaultResourceId")
    def key_vault_resource_id(self) -> pulumi.Input[str]:
        """
        Name of the user Key Vault where all the cluster specific user secrets are stored.
        """
        return pulumi.get(self, "key_vault_resource_id")

    @key_vault_resource_id.setter
    def key_vault_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_vault_resource_id", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgs']]]]:
        """
        Properties of Key Vault secret.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecretReferenceArgs']]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class SecurityProfileArgsDict(TypedDict):
        """
        The security profile which contains Ssh public key for the HDInsight cluster.
        """
        aadds_resource_id: NotRequired[pulumi.Input[str]]
        """
        The resource ID of the user's Azure Active Directory Domain Service.
        """
        cluster_users_group_dns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional. The Distinguished Names for cluster user groups
        """
        directory_type: NotRequired[pulumi.Input[Union[str, 'DirectoryType']]]
        """
        The directory type.
        """
        domain: NotRequired[pulumi.Input[str]]
        """
        The organization's active directory domain.
        """
        domain_user_password: NotRequired[pulumi.Input[str]]
        """
        The domain admin password.
        """
        domain_username: NotRequired[pulumi.Input[str]]
        """
        The domain user account that will have admin privileges on the cluster.
        """
        ldaps_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The LDAPS protocol URLs to communicate with the Active Directory.
        """
        msi_resource_id: NotRequired[pulumi.Input[str]]
        """
        User assigned identity that has permissions to read and create cluster-related artifacts in the user's AADDS.
        """
        organizational_unit_dn: NotRequired[pulumi.Input[str]]
        """
        The organizational unit within the Active Directory to place the cluster and service accounts.
        """
elif False:
    SecurityProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileArgs:
    def __init__(__self__, *,
                 aadds_resource_id: Optional[pulumi.Input[str]] = None,
                 cluster_users_group_dns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 directory_type: Optional[pulumi.Input[Union[str, 'DirectoryType']]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 domain_user_password: Optional[pulumi.Input[str]] = None,
                 domain_username: Optional[pulumi.Input[str]] = None,
                 ldaps_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 msi_resource_id: Optional[pulumi.Input[str]] = None,
                 organizational_unit_dn: Optional[pulumi.Input[str]] = None):
        """
        The security profile which contains Ssh public key for the HDInsight cluster.
        :param pulumi.Input[str] aadds_resource_id: The resource ID of the user's Azure Active Directory Domain Service.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cluster_users_group_dns: Optional. The Distinguished Names for cluster user groups
        :param pulumi.Input[Union[str, 'DirectoryType']] directory_type: The directory type.
        :param pulumi.Input[str] domain: The organization's active directory domain.
        :param pulumi.Input[str] domain_user_password: The domain admin password.
        :param pulumi.Input[str] domain_username: The domain user account that will have admin privileges on the cluster.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ldaps_urls: The LDAPS protocol URLs to communicate with the Active Directory.
        :param pulumi.Input[str] msi_resource_id: User assigned identity that has permissions to read and create cluster-related artifacts in the user's AADDS.
        :param pulumi.Input[str] organizational_unit_dn: The organizational unit within the Active Directory to place the cluster and service accounts.
        """
        if aadds_resource_id is not None:
            pulumi.set(__self__, "aadds_resource_id", aadds_resource_id)
        if cluster_users_group_dns is not None:
            pulumi.set(__self__, "cluster_users_group_dns", cluster_users_group_dns)
        if directory_type is not None:
            pulumi.set(__self__, "directory_type", directory_type)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if domain_user_password is not None:
            pulumi.set(__self__, "domain_user_password", domain_user_password)
        if domain_username is not None:
            pulumi.set(__self__, "domain_username", domain_username)
        if ldaps_urls is not None:
            pulumi.set(__self__, "ldaps_urls", ldaps_urls)
        if msi_resource_id is not None:
            pulumi.set(__self__, "msi_resource_id", msi_resource_id)
        if organizational_unit_dn is not None:
            pulumi.set(__self__, "organizational_unit_dn", organizational_unit_dn)

    @property
    @pulumi.getter(name="aaddsResourceId")
    def aadds_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource ID of the user's Azure Active Directory Domain Service.
        """
        return pulumi.get(self, "aadds_resource_id")

    @aadds_resource_id.setter
    def aadds_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aadds_resource_id", value)

    @property
    @pulumi.getter(name="clusterUsersGroupDNs")
    def cluster_users_group_dns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. The Distinguished Names for cluster user groups
        """
        return pulumi.get(self, "cluster_users_group_dns")

    @cluster_users_group_dns.setter
    def cluster_users_group_dns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cluster_users_group_dns", value)

    @property
    @pulumi.getter(name="directoryType")
    def directory_type(self) -> Optional[pulumi.Input[Union[str, 'DirectoryType']]]:
        """
        The directory type.
        """
        return pulumi.get(self, "directory_type")

    @directory_type.setter
    def directory_type(self, value: Optional[pulumi.Input[Union[str, 'DirectoryType']]]):
        pulumi.set(self, "directory_type", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        The organization's active directory domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="domainUserPassword")
    def domain_user_password(self) -> Optional[pulumi.Input[str]]:
        """
        The domain admin password.
        """
        return pulumi.get(self, "domain_user_password")

    @domain_user_password.setter
    def domain_user_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_user_password", value)

    @property
    @pulumi.getter(name="domainUsername")
    def domain_username(self) -> Optional[pulumi.Input[str]]:
        """
        The domain user account that will have admin privileges on the cluster.
        """
        return pulumi.get(self, "domain_username")

    @domain_username.setter
    def domain_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_username", value)

    @property
    @pulumi.getter(name="ldapsUrls")
    def ldaps_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The LDAPS protocol URLs to communicate with the Active Directory.
        """
        return pulumi.get(self, "ldaps_urls")

    @ldaps_urls.setter
    def ldaps_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ldaps_urls", value)

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        User assigned identity that has permissions to read and create cluster-related artifacts in the user's AADDS.
        """
        return pulumi.get(self, "msi_resource_id")

    @msi_resource_id.setter
    def msi_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "msi_resource_id", value)

    @property
    @pulumi.getter(name="organizationalUnitDN")
    def organizational_unit_dn(self) -> Optional[pulumi.Input[str]]:
        """
        The organizational unit within the Active Directory to place the cluster and service accounts.
        """
        return pulumi.get(self, "organizational_unit_dn")

    @organizational_unit_dn.setter
    def organizational_unit_dn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organizational_unit_dn", value)


if not MYPY:
    class SparkMetastoreSpecArgsDict(TypedDict):
        """
        The metastore specification for Spark cluster.
        """
        db_name: pulumi.Input[str]
        """
        The database name.
        """
        db_server_host: pulumi.Input[str]
        """
        The database server host.
        """
        db_connection_authentication_mode: NotRequired[pulumi.Input[Union[str, 'DbConnectionAuthenticationMode']]]
        """
        The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        """
        db_password_secret_name: NotRequired[pulumi.Input[str]]
        """
        The secret name which contains the database user password.
        """
        db_user_name: NotRequired[pulumi.Input[str]]
        """
        The database user name.
        """
        key_vault_id: NotRequired[pulumi.Input[str]]
        """
        The key vault resource id.
        """
        thrift_url: NotRequired[pulumi.Input[str]]
        """
        The thrift url.
        """
elif False:
    SparkMetastoreSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SparkMetastoreSpecArgs:
    def __init__(__self__, *,
                 db_name: pulumi.Input[str],
                 db_server_host: pulumi.Input[str],
                 db_connection_authentication_mode: Optional[pulumi.Input[Union[str, 'DbConnectionAuthenticationMode']]] = None,
                 db_password_secret_name: Optional[pulumi.Input[str]] = None,
                 db_user_name: Optional[pulumi.Input[str]] = None,
                 key_vault_id: Optional[pulumi.Input[str]] = None,
                 thrift_url: Optional[pulumi.Input[str]] = None):
        """
        The metastore specification for Spark cluster.
        :param pulumi.Input[str] db_name: The database name.
        :param pulumi.Input[str] db_server_host: The database server host.
        :param pulumi.Input[Union[str, 'DbConnectionAuthenticationMode']] db_connection_authentication_mode: The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        :param pulumi.Input[str] db_password_secret_name: The secret name which contains the database user password.
        :param pulumi.Input[str] db_user_name: The database user name.
        :param pulumi.Input[str] key_vault_id: The key vault resource id.
        :param pulumi.Input[str] thrift_url: The thrift url.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_server_host", db_server_host)
        if db_connection_authentication_mode is None:
            db_connection_authentication_mode = 'IdentityAuth'
        if db_connection_authentication_mode is not None:
            pulumi.set(__self__, "db_connection_authentication_mode", db_connection_authentication_mode)
        if db_password_secret_name is not None:
            pulumi.set(__self__, "db_password_secret_name", db_password_secret_name)
        if db_user_name is not None:
            pulumi.set(__self__, "db_user_name", db_user_name)
        if key_vault_id is not None:
            pulumi.set(__self__, "key_vault_id", key_vault_id)
        if thrift_url is not None:
            pulumi.set(__self__, "thrift_url", thrift_url)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        The database name.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="dbServerHost")
    def db_server_host(self) -> pulumi.Input[str]:
        """
        The database server host.
        """
        return pulumi.get(self, "db_server_host")

    @db_server_host.setter
    def db_server_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_server_host", value)

    @property
    @pulumi.getter(name="dbConnectionAuthenticationMode")
    def db_connection_authentication_mode(self) -> Optional[pulumi.Input[Union[str, 'DbConnectionAuthenticationMode']]]:
        """
        The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        """
        return pulumi.get(self, "db_connection_authentication_mode")

    @db_connection_authentication_mode.setter
    def db_connection_authentication_mode(self, value: Optional[pulumi.Input[Union[str, 'DbConnectionAuthenticationMode']]]):
        pulumi.set(self, "db_connection_authentication_mode", value)

    @property
    @pulumi.getter(name="dbPasswordSecretName")
    def db_password_secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        The secret name which contains the database user password.
        """
        return pulumi.get(self, "db_password_secret_name")

    @db_password_secret_name.setter
    def db_password_secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_password_secret_name", value)

    @property
    @pulumi.getter(name="dbUserName")
    def db_user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The database user name.
        """
        return pulumi.get(self, "db_user_name")

    @db_user_name.setter
    def db_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_user_name", value)

    @property
    @pulumi.getter(name="keyVaultId")
    def key_vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        The key vault resource id.
        """
        return pulumi.get(self, "key_vault_id")

    @key_vault_id.setter
    def key_vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_id", value)

    @property
    @pulumi.getter(name="thriftUrl")
    def thrift_url(self) -> Optional[pulumi.Input[str]]:
        """
        The thrift url.
        """
        return pulumi.get(self, "thrift_url")

    @thrift_url.setter
    def thrift_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thrift_url", value)


if not MYPY:
    class SparkProfileArgsDict(TypedDict):
        """
        The spark cluster profile.
        """
        default_storage_url: NotRequired[pulumi.Input[str]]
        """
        The default storage URL.
        """
        metastore_spec: NotRequired[pulumi.Input['SparkMetastoreSpecArgsDict']]
        """
        The metastore specification for Spark cluster.
        """
        user_plugins_spec: NotRequired[pulumi.Input['SparkUserPluginsArgsDict']]
        """
        Spark user plugins spec
        """
elif False:
    SparkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SparkProfileArgs:
    def __init__(__self__, *,
                 default_storage_url: Optional[pulumi.Input[str]] = None,
                 metastore_spec: Optional[pulumi.Input['SparkMetastoreSpecArgs']] = None,
                 user_plugins_spec: Optional[pulumi.Input['SparkUserPluginsArgs']] = None):
        """
        The spark cluster profile.
        :param pulumi.Input[str] default_storage_url: The default storage URL.
        :param pulumi.Input['SparkMetastoreSpecArgs'] metastore_spec: The metastore specification for Spark cluster.
        :param pulumi.Input['SparkUserPluginsArgs'] user_plugins_spec: Spark user plugins spec
        """
        if default_storage_url is not None:
            pulumi.set(__self__, "default_storage_url", default_storage_url)
        if metastore_spec is not None:
            pulumi.set(__self__, "metastore_spec", metastore_spec)
        if user_plugins_spec is not None:
            pulumi.set(__self__, "user_plugins_spec", user_plugins_spec)

    @property
    @pulumi.getter(name="defaultStorageUrl")
    def default_storage_url(self) -> Optional[pulumi.Input[str]]:
        """
        The default storage URL.
        """
        return pulumi.get(self, "default_storage_url")

    @default_storage_url.setter
    def default_storage_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_storage_url", value)

    @property
    @pulumi.getter(name="metastoreSpec")
    def metastore_spec(self) -> Optional[pulumi.Input['SparkMetastoreSpecArgs']]:
        """
        The metastore specification for Spark cluster.
        """
        return pulumi.get(self, "metastore_spec")

    @metastore_spec.setter
    def metastore_spec(self, value: Optional[pulumi.Input['SparkMetastoreSpecArgs']]):
        pulumi.set(self, "metastore_spec", value)

    @property
    @pulumi.getter(name="userPluginsSpec")
    def user_plugins_spec(self) -> Optional[pulumi.Input['SparkUserPluginsArgs']]:
        """
        Spark user plugins spec
        """
        return pulumi.get(self, "user_plugins_spec")

    @user_plugins_spec.setter
    def user_plugins_spec(self, value: Optional[pulumi.Input['SparkUserPluginsArgs']]):
        pulumi.set(self, "user_plugins_spec", value)


if not MYPY:
    class SparkUserPluginsArgsDict(TypedDict):
        """
        Spark user plugins spec
        """
        plugins: NotRequired[pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgsDict']]]]
        """
        Spark user plugins.
        """
elif False:
    SparkUserPluginsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SparkUserPluginsArgs:
    def __init__(__self__, *,
                 plugins: Optional[pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgs']]]] = None):
        """
        Spark user plugins spec
        :param pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgs']]] plugins: Spark user plugins.
        """
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgs']]]]:
        """
        Spark user plugins.
        """
        return pulumi.get(self, "plugins")

    @plugins.setter
    def plugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SparkUserPluginArgs']]]]):
        pulumi.set(self, "plugins", value)


if not MYPY:
    class SparkUserPluginArgsDict(TypedDict):
        """
        Spark user plugin.
        """
        path: pulumi.Input[str]
        """
        Fully qualified path to the folder containing the plugins.
        """
elif False:
    SparkUserPluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SparkUserPluginArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str]):
        """
        Spark user plugin.
        :param pulumi.Input[str] path: Fully qualified path to the folder containing the plugins.
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Fully qualified path to the folder containing the plugins.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class SshProfileArgsDict(TypedDict):
        """
        The list of SSH public keys.
        """
        public_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgsDict']]]]
        """
        The list of SSH public keys.
        """
elif False:
    SshProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshProfileArgs:
    def __init__(__self__, *,
                 public_keys: Optional[pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgs']]]] = None):
        """
        The list of SSH public keys.
        :param pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgs']]] public_keys: The list of SSH public keys.
        """
        if public_keys is not None:
            pulumi.set(__self__, "public_keys", public_keys)

    @property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgs']]]]:
        """
        The list of SSH public keys.
        """
        return pulumi.get(self, "public_keys")

    @public_keys.setter
    def public_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SshPublicKeyArgs']]]]):
        pulumi.set(self, "public_keys", value)


if not MYPY:
    class SshPublicKeyArgsDict(TypedDict):
        """
        The SSH public key for the cluster nodes.
        """
        certificate_data: NotRequired[pulumi.Input[str]]
        """
        The certificate for SSH.
        """
elif False:
    SshPublicKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshPublicKeyArgs:
    def __init__(__self__, *,
                 certificate_data: Optional[pulumi.Input[str]] = None):
        """
        The SSH public key for the cluster nodes.
        :param pulumi.Input[str] certificate_data: The certificate for SSH.
        """
        if certificate_data is not None:
            pulumi.set(__self__, "certificate_data", certificate_data)

    @property
    @pulumi.getter(name="certificateData")
    def certificate_data(self) -> Optional[pulumi.Input[str]]:
        """
        The certificate for SSH.
        """
        return pulumi.get(self, "certificate_data")

    @certificate_data.setter
    def certificate_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_data", value)


if not MYPY:
    class StorageAccountArgsDict(TypedDict):
        """
        The storage Account.
        """
        container: NotRequired[pulumi.Input[str]]
        """
        The container in the storage account, only to be specified for WASB storage accounts.
        """
        enable_secure_channel: NotRequired[pulumi.Input[bool]]
        """
        Enable secure channel or not, it's an optional field. Default value is false when cluster version < 5.1 and true when cluster version >= 5.1 , 
        """
        file_system: NotRequired[pulumi.Input[str]]
        """
        The filesystem, only to be specified for Azure Data Lake Storage Gen 2.
        """
        fileshare: NotRequired[pulumi.Input[str]]
        """
        The file share name.
        """
        is_default: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the storage account is the default storage account.
        """
        key: NotRequired[pulumi.Input[str]]
        """
        The storage account access key.
        """
        msi_resource_id: NotRequired[pulumi.Input[str]]
        """
        The managed identity (MSI) that is allowed to access the storage account, only to be specified for Azure Data Lake Storage Gen 2.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the storage account.
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        The resource ID of storage account, only to be specified for Azure Data Lake Storage Gen 2.
        """
        saskey: NotRequired[pulumi.Input[str]]
        """
        The shared access signature key.
        """
elif False:
    StorageAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageAccountArgs:
    def __init__(__self__, *,
                 container: Optional[pulumi.Input[str]] = None,
                 enable_secure_channel: Optional[pulumi.Input[bool]] = None,
                 file_system: Optional[pulumi.Input[str]] = None,
                 fileshare: Optional[pulumi.Input[str]] = None,
                 is_default: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 msi_resource_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None,
                 saskey: Optional[pulumi.Input[str]] = None):
        """
        The storage Account.
        :param pulumi.Input[str] container: The container in the storage account, only to be specified for WASB storage accounts.
        :param pulumi.Input[bool] enable_secure_channel: Enable secure channel or not, it's an optional field. Default value is false when cluster version < 5.1 and true when cluster version >= 5.1 , 
        :param pulumi.Input[str] file_system: The filesystem, only to be specified for Azure Data Lake Storage Gen 2.
        :param pulumi.Input[str] fileshare: The file share name.
        :param pulumi.Input[bool] is_default: Whether or not the storage account is the default storage account.
        :param pulumi.Input[str] key: The storage account access key.
        :param pulumi.Input[str] msi_resource_id: The managed identity (MSI) that is allowed to access the storage account, only to be specified for Azure Data Lake Storage Gen 2.
        :param pulumi.Input[str] name: The name of the storage account.
        :param pulumi.Input[str] resource_id: The resource ID of storage account, only to be specified for Azure Data Lake Storage Gen 2.
        :param pulumi.Input[str] saskey: The shared access signature key.
        """
        if container is not None:
            pulumi.set(__self__, "container", container)
        if enable_secure_channel is not None:
            pulumi.set(__self__, "enable_secure_channel", enable_secure_channel)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if fileshare is not None:
            pulumi.set(__self__, "fileshare", fileshare)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if msi_resource_id is not None:
            pulumi.set(__self__, "msi_resource_id", msi_resource_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if saskey is not None:
            pulumi.set(__self__, "saskey", saskey)

    @property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input[str]]:
        """
        The container in the storage account, only to be specified for WASB storage accounts.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="enableSecureChannel")
    def enable_secure_channel(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable secure channel or not, it's an optional field. Default value is false when cluster version < 5.1 and true when cluster version >= 5.1 , 
        """
        return pulumi.get(self, "enable_secure_channel")

    @enable_secure_channel.setter
    def enable_secure_channel(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_secure_channel", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input[str]]:
        """
        The filesystem, only to be specified for Azure Data Lake Storage Gen 2.
        """
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_system", value)

    @property
    @pulumi.getter
    def fileshare(self) -> Optional[pulumi.Input[str]]:
        """
        The file share name.
        """
        return pulumi.get(self, "fileshare")

    @fileshare.setter
    def fileshare(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fileshare", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the storage account is the default storage account.
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_default", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The storage account access key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="msiResourceId")
    def msi_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The managed identity (MSI) that is allowed to access the storage account, only to be specified for Azure Data Lake Storage Gen 2.
        """
        return pulumi.get(self, "msi_resource_id")

    @msi_resource_id.setter
    def msi_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "msi_resource_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the storage account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource ID of storage account, only to be specified for Azure Data Lake Storage Gen 2.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter
    def saskey(self) -> Optional[pulumi.Input[str]]:
        """
        The shared access signature key.
        """
        return pulumi.get(self, "saskey")

    @saskey.setter
    def saskey(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "saskey", value)


if not MYPY:
    class StorageProfileArgsDict(TypedDict):
        """
        The storage profile.
        """
        storageaccounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageAccountArgsDict']]]]
        """
        The list of storage accounts in the cluster.
        """
elif False:
    StorageProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageProfileArgs:
    def __init__(__self__, *,
                 storageaccounts: Optional[pulumi.Input[Sequence[pulumi.Input['StorageAccountArgs']]]] = None):
        """
        The storage profile.
        :param pulumi.Input[Sequence[pulumi.Input['StorageAccountArgs']]] storageaccounts: The list of storage accounts in the cluster.
        """
        if storageaccounts is not None:
            pulumi.set(__self__, "storageaccounts", storageaccounts)

    @property
    @pulumi.getter
    def storageaccounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageAccountArgs']]]]:
        """
        The list of storage accounts in the cluster.
        """
        return pulumi.get(self, "storageaccounts")

    @storageaccounts.setter
    def storageaccounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageAccountArgs']]]]):
        pulumi.set(self, "storageaccounts", value)


if not MYPY:
    class TrinoCoordinatorArgsDict(TypedDict):
        """
        Trino Coordinator.
        """
        enable: NotRequired[pulumi.Input[bool]]
        """
        The flag that if enable debug or not.
        """
        high_availability_enabled: NotRequired[pulumi.Input[bool]]
        """
        The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The debug port.
        """
        suspend: NotRequired[pulumi.Input[bool]]
        """
        The flag that if suspend debug or not.
        """
elif False:
    TrinoCoordinatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoCoordinatorArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 high_availability_enabled: Optional[pulumi.Input[bool]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 suspend: Optional[pulumi.Input[bool]] = None):
        """
        Trino Coordinator.
        :param pulumi.Input[bool] enable: The flag that if enable debug or not.
        :param pulumi.Input[bool] high_availability_enabled: The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.
        :param pulumi.Input[int] port: The debug port.
        :param pulumi.Input[bool] suspend: The flag that if suspend debug or not.
        """
        if enable is None:
            enable = False
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if high_availability_enabled is None:
            high_availability_enabled = True
        if high_availability_enabled is not None:
            pulumi.set(__self__, "high_availability_enabled", high_availability_enabled)
        if port is None:
            port = 8008
        if port is not None:
            pulumi.set(__self__, "port", port)
        if suspend is None:
            suspend = False
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if enable debug or not.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="highAvailabilityEnabled")
    def high_availability_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.
        """
        return pulumi.get(self, "high_availability_enabled")

    @high_availability_enabled.setter
    def high_availability_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "high_availability_enabled", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The debug port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if suspend debug or not.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suspend", value)


if not MYPY:
    class TrinoProfileArgsDict(TypedDict):
        """
        Trino Cluster profile.
        """
        catalog_options: NotRequired[pulumi.Input['CatalogOptionsArgsDict']]
        """
        Trino cluster catalog options.
        """
        coordinator: NotRequired[pulumi.Input['TrinoCoordinatorArgsDict']]
        """
        Trino Coordinator.
        """
        user_plugins_spec: NotRequired[pulumi.Input['TrinoUserPluginsArgsDict']]
        """
        Trino user plugins spec
        """
        user_telemetry_spec: NotRequired[pulumi.Input['TrinoUserTelemetryArgsDict']]
        """
        User telemetry
        """
        worker: NotRequired[pulumi.Input['TrinoWorkerArgsDict']]
        """
        Trino worker.
        """
elif False:
    TrinoProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoProfileArgs:
    def __init__(__self__, *,
                 catalog_options: Optional[pulumi.Input['CatalogOptionsArgs']] = None,
                 coordinator: Optional[pulumi.Input['TrinoCoordinatorArgs']] = None,
                 user_plugins_spec: Optional[pulumi.Input['TrinoUserPluginsArgs']] = None,
                 user_telemetry_spec: Optional[pulumi.Input['TrinoUserTelemetryArgs']] = None,
                 worker: Optional[pulumi.Input['TrinoWorkerArgs']] = None):
        """
        Trino Cluster profile.
        :param pulumi.Input['CatalogOptionsArgs'] catalog_options: Trino cluster catalog options.
        :param pulumi.Input['TrinoCoordinatorArgs'] coordinator: Trino Coordinator.
        :param pulumi.Input['TrinoUserPluginsArgs'] user_plugins_spec: Trino user plugins spec
        :param pulumi.Input['TrinoUserTelemetryArgs'] user_telemetry_spec: User telemetry
        :param pulumi.Input['TrinoWorkerArgs'] worker: Trino worker.
        """
        if catalog_options is not None:
            pulumi.set(__self__, "catalog_options", catalog_options)
        if coordinator is not None:
            pulumi.set(__self__, "coordinator", coordinator)
        if user_plugins_spec is not None:
            pulumi.set(__self__, "user_plugins_spec", user_plugins_spec)
        if user_telemetry_spec is not None:
            pulumi.set(__self__, "user_telemetry_spec", user_telemetry_spec)
        if worker is not None:
            pulumi.set(__self__, "worker", worker)

    @property
    @pulumi.getter(name="catalogOptions")
    def catalog_options(self) -> Optional[pulumi.Input['CatalogOptionsArgs']]:
        """
        Trino cluster catalog options.
        """
        return pulumi.get(self, "catalog_options")

    @catalog_options.setter
    def catalog_options(self, value: Optional[pulumi.Input['CatalogOptionsArgs']]):
        pulumi.set(self, "catalog_options", value)

    @property
    @pulumi.getter
    def coordinator(self) -> Optional[pulumi.Input['TrinoCoordinatorArgs']]:
        """
        Trino Coordinator.
        """
        return pulumi.get(self, "coordinator")

    @coordinator.setter
    def coordinator(self, value: Optional[pulumi.Input['TrinoCoordinatorArgs']]):
        pulumi.set(self, "coordinator", value)

    @property
    @pulumi.getter(name="userPluginsSpec")
    def user_plugins_spec(self) -> Optional[pulumi.Input['TrinoUserPluginsArgs']]:
        """
        Trino user plugins spec
        """
        return pulumi.get(self, "user_plugins_spec")

    @user_plugins_spec.setter
    def user_plugins_spec(self, value: Optional[pulumi.Input['TrinoUserPluginsArgs']]):
        pulumi.set(self, "user_plugins_spec", value)

    @property
    @pulumi.getter(name="userTelemetrySpec")
    def user_telemetry_spec(self) -> Optional[pulumi.Input['TrinoUserTelemetryArgs']]:
        """
        User telemetry
        """
        return pulumi.get(self, "user_telemetry_spec")

    @user_telemetry_spec.setter
    def user_telemetry_spec(self, value: Optional[pulumi.Input['TrinoUserTelemetryArgs']]):
        pulumi.set(self, "user_telemetry_spec", value)

    @property
    @pulumi.getter
    def worker(self) -> Optional[pulumi.Input['TrinoWorkerArgs']]:
        """
        Trino worker.
        """
        return pulumi.get(self, "worker")

    @worker.setter
    def worker(self, value: Optional[pulumi.Input['TrinoWorkerArgs']]):
        pulumi.set(self, "worker", value)


if not MYPY:
    class TrinoTelemetryConfigArgsDict(TypedDict):
        """
        Trino user telemetry definition.
        """
        hivecatalog_name: NotRequired[pulumi.Input[str]]
        """
        Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        """
        hivecatalog_schema: NotRequired[pulumi.Input[str]]
        """
        Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.
        """
        partition_retention_in_days: NotRequired[pulumi.Input[int]]
        """
        Retention period for query log table partitions, this doesn't have any affect on actual data.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Azure storage location of the blobs.
        """
elif False:
    TrinoTelemetryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoTelemetryConfigArgs:
    def __init__(__self__, *,
                 hivecatalog_name: Optional[pulumi.Input[str]] = None,
                 hivecatalog_schema: Optional[pulumi.Input[str]] = None,
                 partition_retention_in_days: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        Trino user telemetry definition.
        :param pulumi.Input[str] hivecatalog_name: Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        :param pulumi.Input[str] hivecatalog_schema: Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.
        :param pulumi.Input[int] partition_retention_in_days: Retention period for query log table partitions, this doesn't have any affect on actual data.
        :param pulumi.Input[str] path: Azure storage location of the blobs.
        """
        if hivecatalog_name is not None:
            pulumi.set(__self__, "hivecatalog_name", hivecatalog_name)
        if hivecatalog_schema is None:
            hivecatalog_schema = 'trinologs'
        if hivecatalog_schema is not None:
            pulumi.set(__self__, "hivecatalog_schema", hivecatalog_schema)
        if partition_retention_in_days is None:
            partition_retention_in_days = 365
        if partition_retention_in_days is not None:
            pulumi.set(__self__, "partition_retention_in_days", partition_retention_in_days)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="hivecatalogName")
    def hivecatalog_name(self) -> Optional[pulumi.Input[str]]:
        """
        Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        """
        return pulumi.get(self, "hivecatalog_name")

    @hivecatalog_name.setter
    def hivecatalog_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hivecatalog_name", value)

    @property
    @pulumi.getter(name="hivecatalogSchema")
    def hivecatalog_schema(self) -> Optional[pulumi.Input[str]]:
        """
        Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.
        """
        return pulumi.get(self, "hivecatalog_schema")

    @hivecatalog_schema.setter
    def hivecatalog_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hivecatalog_schema", value)

    @property
    @pulumi.getter(name="partitionRetentionInDays")
    def partition_retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Retention period for query log table partitions, this doesn't have any affect on actual data.
        """
        return pulumi.get(self, "partition_retention_in_days")

    @partition_retention_in_days.setter
    def partition_retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "partition_retention_in_days", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Azure storage location of the blobs.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class TrinoUserPluginsArgsDict(TypedDict):
        """
        Trino user plugins spec
        """
        plugins: NotRequired[pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgsDict']]]]
        """
        Trino user plugins.
        """
elif False:
    TrinoUserPluginsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoUserPluginsArgs:
    def __init__(__self__, *,
                 plugins: Optional[pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgs']]]] = None):
        """
        Trino user plugins spec
        :param pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgs']]] plugins: Trino user plugins.
        """
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgs']]]]:
        """
        Trino user plugins.
        """
        return pulumi.get(self, "plugins")

    @plugins.setter
    def plugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TrinoUserPluginArgs']]]]):
        pulumi.set(self, "plugins", value)


if not MYPY:
    class TrinoUserPluginArgsDict(TypedDict):
        """
        Trino user plugin.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Denotes whether the plugin is active or not.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        This field maps to the sub-directory in trino plugins location, that will contain all the plugins under path.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Fully qualified path to the folder containing the plugins.
        """
elif False:
    TrinoUserPluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoUserPluginArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        Trino user plugin.
        :param pulumi.Input[bool] enabled: Denotes whether the plugin is active or not.
        :param pulumi.Input[str] name: This field maps to the sub-directory in trino plugins location, that will contain all the plugins under path.
        :param pulumi.Input[str] path: Fully qualified path to the folder containing the plugins.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Denotes whether the plugin is active or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        This field maps to the sub-directory in trino plugins location, that will contain all the plugins under path.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified path to the folder containing the plugins.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class TrinoUserTelemetryArgsDict(TypedDict):
        """
        User telemetry
        """
        storage: NotRequired[pulumi.Input['TrinoTelemetryConfigArgsDict']]
        """
        Trino user telemetry definition.
        """
elif False:
    TrinoUserTelemetryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoUserTelemetryArgs:
    def __init__(__self__, *,
                 storage: Optional[pulumi.Input['TrinoTelemetryConfigArgs']] = None):
        """
        User telemetry
        :param pulumi.Input['TrinoTelemetryConfigArgs'] storage: Trino user telemetry definition.
        """
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input['TrinoTelemetryConfigArgs']]:
        """
        Trino user telemetry definition.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input['TrinoTelemetryConfigArgs']]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class TrinoWorkerArgsDict(TypedDict):
        """
        Trino worker.
        """
        enable: NotRequired[pulumi.Input[bool]]
        """
        The flag that if enable debug or not.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The debug port.
        """
        suspend: NotRequired[pulumi.Input[bool]]
        """
        The flag that if suspend debug or not.
        """
elif False:
    TrinoWorkerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrinoWorkerArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 suspend: Optional[pulumi.Input[bool]] = None):
        """
        Trino worker.
        :param pulumi.Input[bool] enable: The flag that if enable debug or not.
        :param pulumi.Input[int] port: The debug port.
        :param pulumi.Input[bool] suspend: The flag that if suspend debug or not.
        """
        if enable is None:
            enable = False
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if port is None:
            port = 8008
        if port is not None:
            pulumi.set(__self__, "port", port)
        if suspend is None:
            suspend = False
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if enable debug or not.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The debug port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that if suspend debug or not.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suspend", value)


if not MYPY:
    class UserAssignedIdentityArgsDict(TypedDict):
        """
        The User Assigned Identity
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        The tenant id of user assigned identity.
        """
elif False:
    UserAssignedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserAssignedIdentityArgs:
    def __init__(__self__, *,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        The User Assigned Identity
        :param pulumi.Input[str] tenant_id: The tenant id of user assigned identity.
        """
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The tenant id of user assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class VirtualNetworkProfileArgsDict(TypedDict):
        """
        The virtual network properties.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the virtual network.
        """
        subnet: NotRequired[pulumi.Input[str]]
        """
        The name of the subnet.
        """
elif False:
    VirtualNetworkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkProfileArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 subnet: Optional[pulumi.Input[str]] = None):
        """
        The virtual network properties.
        :param pulumi.Input[str] id: The ID of the virtual network.
        :param pulumi.Input[str] subnet: The name of the subnet.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the virtual network.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the subnet.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet", value)


