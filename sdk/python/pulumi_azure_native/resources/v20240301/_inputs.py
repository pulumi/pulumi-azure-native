# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'ActionOnUnmanageArgs',
    'ActionOnUnmanageArgsDict',
    'DebugSettingArgs',
    'DebugSettingArgsDict',
    'DenySettingsArgs',
    'DenySettingsArgsDict',
    'DeploymentParameterArgs',
    'DeploymentParameterArgsDict',
    'DeploymentPropertiesArgs',
    'DeploymentPropertiesArgsDict',
    'DeploymentStacksDebugSettingArgs',
    'DeploymentStacksDebugSettingArgsDict',
    'DeploymentStacksParametersLinkArgs',
    'DeploymentStacksParametersLinkArgsDict',
    'DeploymentStacksTemplateLinkArgs',
    'DeploymentStacksTemplateLinkArgsDict',
    'ExpressionEvaluationOptionsArgs',
    'ExpressionEvaluationOptionsArgsDict',
    'ExtendedLocationArgs',
    'ExtendedLocationArgsDict',
    'IdentityArgs',
    'IdentityArgsDict',
    'KeyVaultParameterReferenceArgs',
    'KeyVaultParameterReferenceArgsDict',
    'KeyVaultReferenceArgs',
    'KeyVaultReferenceArgsDict',
    'OnErrorDeploymentArgs',
    'OnErrorDeploymentArgsDict',
    'ParametersLinkArgs',
    'ParametersLinkArgsDict',
    'PlanArgs',
    'PlanArgsDict',
    'SkuArgs',
    'SkuArgsDict',
    'TagsArgs',
    'TagsArgsDict',
    'TemplateLinkArgs',
    'TemplateLinkArgsDict',
]

MYPY = False

if not MYPY:
    class ActionOnUnmanageArgsDict(TypedDict):
        """
        Defines the behavior of resources that are no longer managed after the stack is updated or deleted.
        """
        resources: pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']]
        """
        Specifies an action for a newly unmanaged resource. Delete will attempt to delete the resource from Azure. Detach will leave the resource in it's current state.
        """
        management_groups: NotRequired[pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']]]
        """
        Specifies an action for a newly unmanaged resource. Delete will attempt to delete the resource from Azure. Detach will leave the resource in it's current state.
        """
        resource_groups: NotRequired[pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']]]
        """
        Specifies an action for a newly unmanaged resource. Delete will attempt to delete the resource from Azure. Detach will leave the resource in it's current state.
        """
elif False:
    ActionOnUnmanageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionOnUnmanageArgs:
    def __init__(__self__, *,
                 resources: pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']],
                 management_groups: Optional[pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']]] = None,
                 resource_groups: Optional[pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']]] = None):
        """
        Defines the behavior of resources that are no longer managed after the stack is updated or deleted.
        :param pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']] resources: Specifies an action for a newly unmanaged resource. Delete will attempt to delete the resource from Azure. Detach will leave the resource in it's current state.
        :param pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']] management_groups: Specifies an action for a newly unmanaged resource. Delete will attempt to delete the resource from Azure. Detach will leave the resource in it's current state.
        :param pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']] resource_groups: Specifies an action for a newly unmanaged resource. Delete will attempt to delete the resource from Azure. Detach will leave the resource in it's current state.
        """
        pulumi.set(__self__, "resources", resources)
        if management_groups is not None:
            pulumi.set(__self__, "management_groups", management_groups)
        if resource_groups is not None:
            pulumi.set(__self__, "resource_groups", resource_groups)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']]:
        """
        Specifies an action for a newly unmanaged resource. Delete will attempt to delete the resource from Azure. Detach will leave the resource in it's current state.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="managementGroups")
    def management_groups(self) -> Optional[pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']]]:
        """
        Specifies an action for a newly unmanaged resource. Delete will attempt to delete the resource from Azure. Detach will leave the resource in it's current state.
        """
        return pulumi.get(self, "management_groups")

    @management_groups.setter
    def management_groups(self, value: Optional[pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']]]):
        pulumi.set(self, "management_groups", value)

    @property
    @pulumi.getter(name="resourceGroups")
    def resource_groups(self) -> Optional[pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']]]:
        """
        Specifies an action for a newly unmanaged resource. Delete will attempt to delete the resource from Azure. Detach will leave the resource in it's current state.
        """
        return pulumi.get(self, "resource_groups")

    @resource_groups.setter
    def resource_groups(self, value: Optional[pulumi.Input[Union[str, 'DeploymentStacksDeleteDetachEnum']]]):
        pulumi.set(self, "resource_groups", value)


if not MYPY:
    class DebugSettingArgsDict(TypedDict):
        """
        The debug setting.
        """
        detail_level: NotRequired[pulumi.Input[str]]
        """
        Specifies the type of information to log for debugging. The permitted values are none, requestContent, responseContent, or both requestContent and responseContent separated by a comma. The default is none. When setting this value, carefully consider the type of information you are passing in during deployment. By logging information about the request or response, you could potentially expose sensitive data that is retrieved through the deployment operations.
        """
elif False:
    DebugSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DebugSettingArgs:
    def __init__(__self__, *,
                 detail_level: Optional[pulumi.Input[str]] = None):
        """
        The debug setting.
        :param pulumi.Input[str] detail_level: Specifies the type of information to log for debugging. The permitted values are none, requestContent, responseContent, or both requestContent and responseContent separated by a comma. The default is none. When setting this value, carefully consider the type of information you are passing in during deployment. By logging information about the request or response, you could potentially expose sensitive data that is retrieved through the deployment operations.
        """
        if detail_level is not None:
            pulumi.set(__self__, "detail_level", detail_level)

    @property
    @pulumi.getter(name="detailLevel")
    def detail_level(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of information to log for debugging. The permitted values are none, requestContent, responseContent, or both requestContent and responseContent separated by a comma. The default is none. When setting this value, carefully consider the type of information you are passing in during deployment. By logging information about the request or response, you could potentially expose sensitive data that is retrieved through the deployment operations.
        """
        return pulumi.get(self, "detail_level")

    @detail_level.setter
    def detail_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detail_level", value)


if not MYPY:
    class DenySettingsArgsDict(TypedDict):
        """
        Defines how resources deployed by the Deployment stack are locked.
        """
        mode: pulumi.Input[Union[str, 'DenySettingsMode']]
        """
        denySettings Mode that defines denied actions.
        """
        apply_to_child_scopes: NotRequired[pulumi.Input[bool]]
        """
        DenySettings will be applied to child resource scopes of every managed resource with a deny assignment.
        """
        excluded_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of role-based management operations that are excluded from the denySettings. Up to 200 actions are permitted. If the denySetting mode is set to 'denyWriteAndDelete', then the following actions are automatically appended to 'excludedActions': '*\\/read' and 'Microsoft.Authorization/locks/delete'. If the denySetting mode is set to 'denyDelete', then the following actions are automatically appended to 'excludedActions': 'Microsoft.Authorization/locks/delete'. Duplicate actions will be removed.
        """
        excluded_principals: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of AAD principal IDs excluded from the lock. Up to 5 principals are permitted.
        """
elif False:
    DenySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DenySettingsArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[Union[str, 'DenySettingsMode']],
                 apply_to_child_scopes: Optional[pulumi.Input[bool]] = None,
                 excluded_actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_principals: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Defines how resources deployed by the Deployment stack are locked.
        :param pulumi.Input[Union[str, 'DenySettingsMode']] mode: denySettings Mode that defines denied actions.
        :param pulumi.Input[bool] apply_to_child_scopes: DenySettings will be applied to child resource scopes of every managed resource with a deny assignment.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_actions: List of role-based management operations that are excluded from the denySettings. Up to 200 actions are permitted. If the denySetting mode is set to 'denyWriteAndDelete', then the following actions are automatically appended to 'excludedActions': '*\\/read' and 'Microsoft.Authorization/locks/delete'. If the denySetting mode is set to 'denyDelete', then the following actions are automatically appended to 'excludedActions': 'Microsoft.Authorization/locks/delete'. Duplicate actions will be removed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_principals: List of AAD principal IDs excluded from the lock. Up to 5 principals are permitted.
        """
        pulumi.set(__self__, "mode", mode)
        if apply_to_child_scopes is not None:
            pulumi.set(__self__, "apply_to_child_scopes", apply_to_child_scopes)
        if excluded_actions is not None:
            pulumi.set(__self__, "excluded_actions", excluded_actions)
        if excluded_principals is not None:
            pulumi.set(__self__, "excluded_principals", excluded_principals)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[Union[str, 'DenySettingsMode']]:
        """
        denySettings Mode that defines denied actions.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[Union[str, 'DenySettingsMode']]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="applyToChildScopes")
    def apply_to_child_scopes(self) -> Optional[pulumi.Input[bool]]:
        """
        DenySettings will be applied to child resource scopes of every managed resource with a deny assignment.
        """
        return pulumi.get(self, "apply_to_child_scopes")

    @apply_to_child_scopes.setter
    def apply_to_child_scopes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "apply_to_child_scopes", value)

    @property
    @pulumi.getter(name="excludedActions")
    def excluded_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of role-based management operations that are excluded from the denySettings. Up to 200 actions are permitted. If the denySetting mode is set to 'denyWriteAndDelete', then the following actions are automatically appended to 'excludedActions': '*\\/read' and 'Microsoft.Authorization/locks/delete'. If the denySetting mode is set to 'denyDelete', then the following actions are automatically appended to 'excludedActions': 'Microsoft.Authorization/locks/delete'. Duplicate actions will be removed.
        """
        return pulumi.get(self, "excluded_actions")

    @excluded_actions.setter
    def excluded_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_actions", value)

    @property
    @pulumi.getter(name="excludedPrincipals")
    def excluded_principals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of AAD principal IDs excluded from the lock. Up to 5 principals are permitted.
        """
        return pulumi.get(self, "excluded_principals")

    @excluded_principals.setter
    def excluded_principals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_principals", value)


if not MYPY:
    class DeploymentParameterArgsDict(TypedDict):
        """
        Deployment parameter for the template.
        """
        reference: NotRequired[pulumi.Input['KeyVaultParameterReferenceArgsDict']]
        """
        Azure Key Vault parameter reference.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the value.
        """
        value: NotRequired[Any]
        """
        Input value to the parameter.
        """
elif False:
    DeploymentParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentParameterArgs:
    def __init__(__self__, *,
                 reference: Optional[pulumi.Input['KeyVaultParameterReferenceArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[Any] = None):
        """
        Deployment parameter for the template.
        :param pulumi.Input['KeyVaultParameterReferenceArgs'] reference: Azure Key Vault parameter reference.
        :param pulumi.Input[str] type: Type of the value.
        :param Any value: Input value to the parameter.
        """
        if reference is not None:
            pulumi.set(__self__, "reference", reference)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def reference(self) -> Optional[pulumi.Input['KeyVaultParameterReferenceArgs']]:
        """
        Azure Key Vault parameter reference.
        """
        return pulumi.get(self, "reference")

    @reference.setter
    def reference(self, value: Optional[pulumi.Input['KeyVaultParameterReferenceArgs']]):
        pulumi.set(self, "reference", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the value.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[Any]:
        """
        Input value to the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[Any]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeploymentPropertiesArgsDict(TypedDict):
        """
        Deployment properties.
        """
        mode: pulumi.Input['DeploymentMode']
        """
        The mode that is used to deploy resources. This value can be either Incremental or Complete. In Incremental mode, resources are deployed without deleting existing resources that are not included in the template. In Complete mode, resources are deployed and existing resources in the resource group that are not included in the template are deleted. Be careful when using Complete mode as you may unintentionally delete resources.
        """
        debug_setting: NotRequired[pulumi.Input['DebugSettingArgsDict']]
        """
        The debug setting of the deployment.
        """
        expression_evaluation_options: NotRequired[pulumi.Input['ExpressionEvaluationOptionsArgsDict']]
        """
        Specifies whether template expressions are evaluated within the scope of the parent template or nested template. Only applicable to nested templates. If not specified, default value is outer.
        """
        on_error_deployment: NotRequired[pulumi.Input['OnErrorDeploymentArgsDict']]
        """
        The deployment on error behavior.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['DeploymentParameterArgsDict']]]]
        """
        Name and value pairs that define the deployment parameters for the template. You use this element when you want to provide the parameter values directly in the request rather than link to an existing parameter file. Use either the parametersLink property or the parameters property, but not both. It can be a JObject or a well formed JSON string.
        """
        parameters_link: NotRequired[pulumi.Input['ParametersLinkArgsDict']]
        """
        The URI of parameters file. You use this element to link to an existing parameters file. Use either the parametersLink property or the parameters property, but not both.
        """
        template: NotRequired[Any]
        """
        The template content. You use this element when you want to pass the template syntax directly in the request rather than link to an existing template. It can be a JObject or well-formed JSON string. Use either the templateLink property or the template property, but not both.
        """
        template_link: NotRequired[pulumi.Input['TemplateLinkArgsDict']]
        """
        The URI of the template. Use either the templateLink property or the template property, but not both.
        """
elif False:
    DeploymentPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentPropertiesArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input['DeploymentMode'],
                 debug_setting: Optional[pulumi.Input['DebugSettingArgs']] = None,
                 expression_evaluation_options: Optional[pulumi.Input['ExpressionEvaluationOptionsArgs']] = None,
                 on_error_deployment: Optional[pulumi.Input['OnErrorDeploymentArgs']] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeploymentParameterArgs']]]] = None,
                 parameters_link: Optional[pulumi.Input['ParametersLinkArgs']] = None,
                 template: Optional[Any] = None,
                 template_link: Optional[pulumi.Input['TemplateLinkArgs']] = None):
        """
        Deployment properties.
        :param pulumi.Input['DeploymentMode'] mode: The mode that is used to deploy resources. This value can be either Incremental or Complete. In Incremental mode, resources are deployed without deleting existing resources that are not included in the template. In Complete mode, resources are deployed and existing resources in the resource group that are not included in the template are deleted. Be careful when using Complete mode as you may unintentionally delete resources.
        :param pulumi.Input['DebugSettingArgs'] debug_setting: The debug setting of the deployment.
        :param pulumi.Input['ExpressionEvaluationOptionsArgs'] expression_evaluation_options: Specifies whether template expressions are evaluated within the scope of the parent template or nested template. Only applicable to nested templates. If not specified, default value is outer.
        :param pulumi.Input['OnErrorDeploymentArgs'] on_error_deployment: The deployment on error behavior.
        :param pulumi.Input[Mapping[str, pulumi.Input['DeploymentParameterArgs']]] parameters: Name and value pairs that define the deployment parameters for the template. You use this element when you want to provide the parameter values directly in the request rather than link to an existing parameter file. Use either the parametersLink property or the parameters property, but not both. It can be a JObject or a well formed JSON string.
        :param pulumi.Input['ParametersLinkArgs'] parameters_link: The URI of parameters file. You use this element to link to an existing parameters file. Use either the parametersLink property or the parameters property, but not both.
        :param Any template: The template content. You use this element when you want to pass the template syntax directly in the request rather than link to an existing template. It can be a JObject or well-formed JSON string. Use either the templateLink property or the template property, but not both.
        :param pulumi.Input['TemplateLinkArgs'] template_link: The URI of the template. Use either the templateLink property or the template property, but not both.
        """
        pulumi.set(__self__, "mode", mode)
        if debug_setting is not None:
            pulumi.set(__self__, "debug_setting", debug_setting)
        if expression_evaluation_options is not None:
            pulumi.set(__self__, "expression_evaluation_options", expression_evaluation_options)
        if on_error_deployment is not None:
            pulumi.set(__self__, "on_error_deployment", on_error_deployment)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if parameters_link is not None:
            pulumi.set(__self__, "parameters_link", parameters_link)
        if template is not None:
            pulumi.set(__self__, "template", template)
        if template_link is not None:
            pulumi.set(__self__, "template_link", template_link)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input['DeploymentMode']:
        """
        The mode that is used to deploy resources. This value can be either Incremental or Complete. In Incremental mode, resources are deployed without deleting existing resources that are not included in the template. In Complete mode, resources are deployed and existing resources in the resource group that are not included in the template are deleted. Be careful when using Complete mode as you may unintentionally delete resources.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input['DeploymentMode']):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="debugSetting")
    def debug_setting(self) -> Optional[pulumi.Input['DebugSettingArgs']]:
        """
        The debug setting of the deployment.
        """
        return pulumi.get(self, "debug_setting")

    @debug_setting.setter
    def debug_setting(self, value: Optional[pulumi.Input['DebugSettingArgs']]):
        pulumi.set(self, "debug_setting", value)

    @property
    @pulumi.getter(name="expressionEvaluationOptions")
    def expression_evaluation_options(self) -> Optional[pulumi.Input['ExpressionEvaluationOptionsArgs']]:
        """
        Specifies whether template expressions are evaluated within the scope of the parent template or nested template. Only applicable to nested templates. If not specified, default value is outer.
        """
        return pulumi.get(self, "expression_evaluation_options")

    @expression_evaluation_options.setter
    def expression_evaluation_options(self, value: Optional[pulumi.Input['ExpressionEvaluationOptionsArgs']]):
        pulumi.set(self, "expression_evaluation_options", value)

    @property
    @pulumi.getter(name="onErrorDeployment")
    def on_error_deployment(self) -> Optional[pulumi.Input['OnErrorDeploymentArgs']]:
        """
        The deployment on error behavior.
        """
        return pulumi.get(self, "on_error_deployment")

    @on_error_deployment.setter
    def on_error_deployment(self, value: Optional[pulumi.Input['OnErrorDeploymentArgs']]):
        pulumi.set(self, "on_error_deployment", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['DeploymentParameterArgs']]]]:
        """
        Name and value pairs that define the deployment parameters for the template. You use this element when you want to provide the parameter values directly in the request rather than link to an existing parameter file. Use either the parametersLink property or the parameters property, but not both. It can be a JObject or a well formed JSON string.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['DeploymentParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="parametersLink")
    def parameters_link(self) -> Optional[pulumi.Input['ParametersLinkArgs']]:
        """
        The URI of parameters file. You use this element to link to an existing parameters file. Use either the parametersLink property or the parameters property, but not both.
        """
        return pulumi.get(self, "parameters_link")

    @parameters_link.setter
    def parameters_link(self, value: Optional[pulumi.Input['ParametersLinkArgs']]):
        pulumi.set(self, "parameters_link", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[Any]:
        """
        The template content. You use this element when you want to pass the template syntax directly in the request rather than link to an existing template. It can be a JObject or well-formed JSON string. Use either the templateLink property or the template property, but not both.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[Any]):
        pulumi.set(self, "template", value)

    @property
    @pulumi.getter(name="templateLink")
    def template_link(self) -> Optional[pulumi.Input['TemplateLinkArgs']]:
        """
        The URI of the template. Use either the templateLink property or the template property, but not both.
        """
        return pulumi.get(self, "template_link")

    @template_link.setter
    def template_link(self, value: Optional[pulumi.Input['TemplateLinkArgs']]):
        pulumi.set(self, "template_link", value)


if not MYPY:
    class DeploymentStacksDebugSettingArgsDict(TypedDict):
        """
        The debug setting.
        """
        detail_level: NotRequired[pulumi.Input[str]]
        """
        Specifies the type of information to log for debugging. The permitted values are none, requestContent, responseContent, or both requestContent and responseContent separated by a comma. The default is none. When setting this value, carefully consider the type of information that is being passed in during deployment. By logging information about the request or response, sensitive data that is retrieved through the deployment operations could potentially be exposed.
        """
elif False:
    DeploymentStacksDebugSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentStacksDebugSettingArgs:
    def __init__(__self__, *,
                 detail_level: Optional[pulumi.Input[str]] = None):
        """
        The debug setting.
        :param pulumi.Input[str] detail_level: Specifies the type of information to log for debugging. The permitted values are none, requestContent, responseContent, or both requestContent and responseContent separated by a comma. The default is none. When setting this value, carefully consider the type of information that is being passed in during deployment. By logging information about the request or response, sensitive data that is retrieved through the deployment operations could potentially be exposed.
        """
        if detail_level is not None:
            pulumi.set(__self__, "detail_level", detail_level)

    @property
    @pulumi.getter(name="detailLevel")
    def detail_level(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the type of information to log for debugging. The permitted values are none, requestContent, responseContent, or both requestContent and responseContent separated by a comma. The default is none. When setting this value, carefully consider the type of information that is being passed in during deployment. By logging information about the request or response, sensitive data that is retrieved through the deployment operations could potentially be exposed.
        """
        return pulumi.get(self, "detail_level")

    @detail_level.setter
    def detail_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detail_level", value)


if not MYPY:
    class DeploymentStacksParametersLinkArgsDict(TypedDict):
        """
        Entity representing the reference to the deployment parameters.
        """
        uri: pulumi.Input[str]
        """
        The URI of the parameters file.
        """
        content_version: NotRequired[pulumi.Input[str]]
        """
        If included, must match the ContentVersion in the template.
        """
elif False:
    DeploymentStacksParametersLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentStacksParametersLinkArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 content_version: Optional[pulumi.Input[str]] = None):
        """
        Entity representing the reference to the deployment parameters.
        :param pulumi.Input[str] uri: The URI of the parameters file.
        :param pulumi.Input[str] content_version: If included, must match the ContentVersion in the template.
        """
        pulumi.set(__self__, "uri", uri)
        if content_version is not None:
            pulumi.set(__self__, "content_version", content_version)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The URI of the parameters file.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="contentVersion")
    def content_version(self) -> Optional[pulumi.Input[str]]:
        """
        If included, must match the ContentVersion in the template.
        """
        return pulumi.get(self, "content_version")

    @content_version.setter
    def content_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_version", value)


if not MYPY:
    class DeploymentStacksTemplateLinkArgsDict(TypedDict):
        """
        Entity representing the reference to the template.
        """
        content_version: NotRequired[pulumi.Input[str]]
        """
        If included, must match the ContentVersion in the template.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The resourceId of a Template Spec. Use either the id or uri property, but not both.
        """
        query_string: NotRequired[pulumi.Input[str]]
        """
        The query string (for example, a SAS token) to be used with the templateLink URI.
        """
        relative_path: NotRequired[pulumi.Input[str]]
        """
        The relativePath property can be used to deploy a linked template at a location relative to the parent. If the parent template was linked with a TemplateSpec, this will reference an artifact in the TemplateSpec.  If the parent was linked with a URI, the child deployment will be a combination of the parent and relativePath URIs.
        """
        uri: NotRequired[pulumi.Input[str]]
        """
        The URI of the template to deploy. Use either the uri or id property, but not both.
        """
elif False:
    DeploymentStacksTemplateLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentStacksTemplateLinkArgs:
    def __init__(__self__, *,
                 content_version: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 query_string: Optional[pulumi.Input[str]] = None,
                 relative_path: Optional[pulumi.Input[str]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        Entity representing the reference to the template.
        :param pulumi.Input[str] content_version: If included, must match the ContentVersion in the template.
        :param pulumi.Input[str] id: The resourceId of a Template Spec. Use either the id or uri property, but not both.
        :param pulumi.Input[str] query_string: The query string (for example, a SAS token) to be used with the templateLink URI.
        :param pulumi.Input[str] relative_path: The relativePath property can be used to deploy a linked template at a location relative to the parent. If the parent template was linked with a TemplateSpec, this will reference an artifact in the TemplateSpec.  If the parent was linked with a URI, the child deployment will be a combination of the parent and relativePath URIs.
        :param pulumi.Input[str] uri: The URI of the template to deploy. Use either the uri or id property, but not both.
        """
        if content_version is not None:
            pulumi.set(__self__, "content_version", content_version)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if relative_path is not None:
            pulumi.set(__self__, "relative_path", relative_path)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="contentVersion")
    def content_version(self) -> Optional[pulumi.Input[str]]:
        """
        If included, must match the ContentVersion in the template.
        """
        return pulumi.get(self, "content_version")

    @content_version.setter
    def content_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_version", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The resourceId of a Template Spec. Use either the id or uri property, but not both.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input[str]]:
        """
        The query string (for example, a SAS token) to be used with the templateLink URI.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[pulumi.Input[str]]:
        """
        The relativePath property can be used to deploy a linked template at a location relative to the parent. If the parent template was linked with a TemplateSpec, this will reference an artifact in the TemplateSpec.  If the parent was linked with a URI, the child deployment will be a combination of the parent and relativePath URIs.
        """
        return pulumi.get(self, "relative_path")

    @relative_path.setter
    def relative_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relative_path", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of the template to deploy. Use either the uri or id property, but not both.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class ExpressionEvaluationOptionsArgsDict(TypedDict):
        """
        Specifies whether template expressions are evaluated within the scope of the parent template or nested template.
        """
        scope: NotRequired[pulumi.Input[Union[str, 'ExpressionEvaluationOptionsScopeType']]]
        """
        The scope to be used for evaluation of parameters, variables and functions in a nested template.
        """
elif False:
    ExpressionEvaluationOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExpressionEvaluationOptionsArgs:
    def __init__(__self__, *,
                 scope: Optional[pulumi.Input[Union[str, 'ExpressionEvaluationOptionsScopeType']]] = None):
        """
        Specifies whether template expressions are evaluated within the scope of the parent template or nested template.
        :param pulumi.Input[Union[str, 'ExpressionEvaluationOptionsScopeType']] scope: The scope to be used for evaluation of parameters, variables and functions in a nested template.
        """
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[Union[str, 'ExpressionEvaluationOptionsScopeType']]]:
        """
        The scope to be used for evaluation of parameters, variables and functions in a nested template.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[Union[str, 'ExpressionEvaluationOptionsScopeType']]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class ExtendedLocationArgsDict(TypedDict):
        """
        Resource extended location.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The extended location name.
        """
        type: NotRequired[pulumi.Input[Union[str, 'ExtendedLocationType']]]
        """
        The extended location type.
        """
elif False:
    ExtendedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtendedLocationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[Union[str, 'ExtendedLocationType']]] = None):
        """
        Resource extended location.
        :param pulumi.Input[str] name: The extended location name.
        :param pulumi.Input[Union[str, 'ExtendedLocationType']] type: The extended location type.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The extended location name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'ExtendedLocationType']]]:
        """
        The extended location type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'ExtendedLocationType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IdentityArgsDict(TypedDict):
        """
        Identity for the resource.
        """
        type: NotRequired[pulumi.Input['ResourceIdentityType']]
        """
        The identity type.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
elif False:
    IdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ResourceIdentityType']] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Identity for the resource.
        :param pulumi.Input['ResourceIdentityType'] type: The identity type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ResourceIdentityType']]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ResourceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of user identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class KeyVaultParameterReferenceArgsDict(TypedDict):
        """
        Azure Key Vault parameter reference.
        """
        key_vault: pulumi.Input['KeyVaultReferenceArgsDict']
        """
        Azure Key Vault reference.
        """
        secret_name: pulumi.Input[str]
        """
        Azure Key Vault secret name.
        """
        secret_version: NotRequired[pulumi.Input[str]]
        """
        Azure Key Vault secret version.
        """
elif False:
    KeyVaultParameterReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyVaultParameterReferenceArgs:
    def __init__(__self__, *,
                 key_vault: pulumi.Input['KeyVaultReferenceArgs'],
                 secret_name: pulumi.Input[str],
                 secret_version: Optional[pulumi.Input[str]] = None):
        """
        Azure Key Vault parameter reference.
        :param pulumi.Input['KeyVaultReferenceArgs'] key_vault: Azure Key Vault reference.
        :param pulumi.Input[str] secret_name: Azure Key Vault secret name.
        :param pulumi.Input[str] secret_version: Azure Key Vault secret version.
        """
        pulumi.set(__self__, "key_vault", key_vault)
        pulumi.set(__self__, "secret_name", secret_name)
        if secret_version is not None:
            pulumi.set(__self__, "secret_version", secret_version)

    @property
    @pulumi.getter(name="keyVault")
    def key_vault(self) -> pulumi.Input['KeyVaultReferenceArgs']:
        """
        Azure Key Vault reference.
        """
        return pulumi.get(self, "key_vault")

    @key_vault.setter
    def key_vault(self, value: pulumi.Input['KeyVaultReferenceArgs']):
        pulumi.set(self, "key_vault", value)

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[str]:
        """
        Azure Key Vault secret name.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_name", value)

    @property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Key Vault secret version.
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_version", value)


if not MYPY:
    class KeyVaultReferenceArgsDict(TypedDict):
        """
        Azure Key Vault reference.
        """
        id: pulumi.Input[str]
        """
        Azure Key Vault resourceId.
        """
elif False:
    KeyVaultReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyVaultReferenceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        Azure Key Vault reference.
        :param pulumi.Input[str] id: Azure Key Vault resourceId.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Azure Key Vault resourceId.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class OnErrorDeploymentArgsDict(TypedDict):
        """
        Deployment on error behavior.
        """
        deployment_name: NotRequired[pulumi.Input[str]]
        """
        The deployment to be used on error case.
        """
        type: NotRequired[pulumi.Input['OnErrorDeploymentType']]
        """
        The deployment on error behavior type. Possible values are LastSuccessful and SpecificDeployment.
        """
elif False:
    OnErrorDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnErrorDeploymentArgs:
    def __init__(__self__, *,
                 deployment_name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input['OnErrorDeploymentType']] = None):
        """
        Deployment on error behavior.
        :param pulumi.Input[str] deployment_name: The deployment to be used on error case.
        :param pulumi.Input['OnErrorDeploymentType'] type: The deployment on error behavior type. Possible values are LastSuccessful and SpecificDeployment.
        """
        if deployment_name is not None:
            pulumi.set(__self__, "deployment_name", deployment_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="deploymentName")
    def deployment_name(self) -> Optional[pulumi.Input[str]]:
        """
        The deployment to be used on error case.
        """
        return pulumi.get(self, "deployment_name")

    @deployment_name.setter
    def deployment_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deployment_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['OnErrorDeploymentType']]:
        """
        The deployment on error behavior type. Possible values are LastSuccessful and SpecificDeployment.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['OnErrorDeploymentType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ParametersLinkArgsDict(TypedDict):
        """
        Entity representing the reference to the deployment parameters.
        """
        uri: pulumi.Input[str]
        """
        The URI of the parameters file.
        """
        content_version: NotRequired[pulumi.Input[str]]
        """
        If included, must match the ContentVersion in the template.
        """
elif False:
    ParametersLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ParametersLinkArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 content_version: Optional[pulumi.Input[str]] = None):
        """
        Entity representing the reference to the deployment parameters.
        :param pulumi.Input[str] uri: The URI of the parameters file.
        :param pulumi.Input[str] content_version: If included, must match the ContentVersion in the template.
        """
        pulumi.set(__self__, "uri", uri)
        if content_version is not None:
            pulumi.set(__self__, "content_version", content_version)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The URI of the parameters file.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="contentVersion")
    def content_version(self) -> Optional[pulumi.Input[str]]:
        """
        If included, must match the ContentVersion in the template.
        """
        return pulumi.get(self, "content_version")

    @content_version.setter
    def content_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_version", value)


if not MYPY:
    class PlanArgsDict(TypedDict):
        """
        Plan for the resource.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The plan ID.
        """
        product: NotRequired[pulumi.Input[str]]
        """
        The offer ID.
        """
        promotion_code: NotRequired[pulumi.Input[str]]
        """
        The promotion code.
        """
        publisher: NotRequired[pulumi.Input[str]]
        """
        The publisher ID.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        The plan's version.
        """
elif False:
    PlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlanArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 product: Optional[pulumi.Input[str]] = None,
                 promotion_code: Optional[pulumi.Input[str]] = None,
                 publisher: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        Plan for the resource.
        :param pulumi.Input[str] name: The plan ID.
        :param pulumi.Input[str] product: The offer ID.
        :param pulumi.Input[str] promotion_code: The promotion code.
        :param pulumi.Input[str] publisher: The publisher ID.
        :param pulumi.Input[str] version: The plan's version.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if product is not None:
            pulumi.set(__self__, "product", product)
        if promotion_code is not None:
            pulumi.set(__self__, "promotion_code", promotion_code)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The plan ID.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def product(self) -> Optional[pulumi.Input[str]]:
        """
        The offer ID.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[pulumi.Input[str]]:
        """
        The promotion code.
        """
        return pulumi.get(self, "promotion_code")

    @promotion_code.setter
    def promotion_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "promotion_code", value)

    @property
    @pulumi.getter
    def publisher(self) -> Optional[pulumi.Input[str]]:
        """
        The publisher ID.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The plan's version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class SkuArgsDict(TypedDict):
        """
        SKU for the resource.
        """
        capacity: NotRequired[pulumi.Input[int]]
        """
        The SKU capacity.
        """
        family: NotRequired[pulumi.Input[str]]
        """
        The SKU family.
        """
        model: NotRequired[pulumi.Input[str]]
        """
        The SKU model.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The SKU name.
        """
        size: NotRequired[pulumi.Input[str]]
        """
        The SKU size.
        """
        tier: NotRequired[pulumi.Input[str]]
        """
        The SKU tier.
        """
elif False:
    SkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuArgs:
    def __init__(__self__, *,
                 capacity: Optional[pulumi.Input[int]] = None,
                 family: Optional[pulumi.Input[str]] = None,
                 model: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 tier: Optional[pulumi.Input[str]] = None):
        """
        SKU for the resource.
        :param pulumi.Input[int] capacity: The SKU capacity.
        :param pulumi.Input[str] family: The SKU family.
        :param pulumi.Input[str] model: The SKU model.
        :param pulumi.Input[str] name: The SKU name.
        :param pulumi.Input[str] size: The SKU size.
        :param pulumi.Input[str] tier: The SKU tier.
        """
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[int]]:
        """
        The SKU capacity.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU family.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU model.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU size.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU tier.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class TagsArgsDict(TypedDict):
        """
        A dictionary of name and value pairs.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    TagsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TagsArgs:
    def __init__(__self__, *,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        A dictionary of name and value pairs.
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class TemplateLinkArgsDict(TypedDict):
        """
        Entity representing the reference to the template.
        """
        content_version: NotRequired[pulumi.Input[str]]
        """
        If included, must match the ContentVersion in the template.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The resource id of a Template Spec. Use either the id or uri property, but not both.
        """
        query_string: NotRequired[pulumi.Input[str]]
        """
        The query string (for example, a SAS token) to be used with the templateLink URI.
        """
        relative_path: NotRequired[pulumi.Input[str]]
        """
        The relativePath property can be used to deploy a linked template at a location relative to the parent. If the parent template was linked with a TemplateSpec, this will reference an artifact in the TemplateSpec.  If the parent was linked with a URI, the child deployment will be a combination of the parent and relativePath URIs
        """
        uri: NotRequired[pulumi.Input[str]]
        """
        The URI of the template to deploy. Use either the uri or id property, but not both.
        """
elif False:
    TemplateLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateLinkArgs:
    def __init__(__self__, *,
                 content_version: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 query_string: Optional[pulumi.Input[str]] = None,
                 relative_path: Optional[pulumi.Input[str]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        Entity representing the reference to the template.
        :param pulumi.Input[str] content_version: If included, must match the ContentVersion in the template.
        :param pulumi.Input[str] id: The resource id of a Template Spec. Use either the id or uri property, but not both.
        :param pulumi.Input[str] query_string: The query string (for example, a SAS token) to be used with the templateLink URI.
        :param pulumi.Input[str] relative_path: The relativePath property can be used to deploy a linked template at a location relative to the parent. If the parent template was linked with a TemplateSpec, this will reference an artifact in the TemplateSpec.  If the parent was linked with a URI, the child deployment will be a combination of the parent and relativePath URIs
        :param pulumi.Input[str] uri: The URI of the template to deploy. Use either the uri or id property, but not both.
        """
        if content_version is not None:
            pulumi.set(__self__, "content_version", content_version)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if relative_path is not None:
            pulumi.set(__self__, "relative_path", relative_path)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter(name="contentVersion")
    def content_version(self) -> Optional[pulumi.Input[str]]:
        """
        If included, must match the ContentVersion in the template.
        """
        return pulumi.get(self, "content_version")

    @content_version.setter
    def content_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_version", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource id of a Template Spec. Use either the id or uri property, but not both.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[pulumi.Input[str]]:
        """
        The query string (for example, a SAS token) to be used with the templateLink URI.
        """
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[pulumi.Input[str]]:
        """
        The relativePath property can be used to deploy a linked template at a location relative to the parent. If the parent template was linked with a TemplateSpec, this will reference an artifact in the TemplateSpec.  If the parent was linked with a URI, the child deployment will be a combination of the parent and relativePath URIs
        """
        return pulumi.get(self, "relative_path")

    @relative_path.setter
    def relative_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relative_path", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        The URI of the template to deploy. Use either the uri or id property, but not both.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


