# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'AgentUpdatePropertiesArgs',
    'AgentUpdatePropertiesArgsDict',
    'MaintenanceWindowPropertiesArgs',
    'MaintenanceWindowPropertiesArgsDict',
    'MigrationRequestPropertiesArgs',
    'MigrationRequestPropertiesArgsDict',
    'RegistrationInfoArgs',
    'RegistrationInfoArgsDict',
    'ResourceModelWithAllowedPropertySetIdentityArgs',
    'ResourceModelWithAllowedPropertySetIdentityArgsDict',
    'ResourceModelWithAllowedPropertySetPlanArgs',
    'ResourceModelWithAllowedPropertySetPlanArgsDict',
    'ResourceModelWithAllowedPropertySetSkuArgs',
    'ResourceModelWithAllowedPropertySetSkuArgsDict',
]

MYPY = False

if not MYPY:
    class AgentUpdatePropertiesArgsDict(TypedDict):
        """
        The session host configuration for updating agent, monitoring agent, and stack component.
        """
        maintenance_window_time_zone: NotRequired[pulumi.Input[str]]
        """
        Time zone for maintenance as defined in https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.findsystemtimezonebyid?view=net-5.0. Must be set if useLocalTime is true.
        """
        maintenance_windows: NotRequired[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowPropertiesArgsDict']]]]
        """
        List of maintenance windows. Maintenance windows are 2 hours long.
        """
        type: NotRequired[pulumi.Input[Union[str, 'SessionHostComponentUpdateType']]]
        """
        The type of maintenance for session host components.
        """
        use_session_host_local_time: NotRequired[pulumi.Input[bool]]
        """
        Whether to use localTime of the virtual machine.
        """
elif False:
    AgentUpdatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentUpdatePropertiesArgs:
    def __init__(__self__, *,
                 maintenance_window_time_zone: Optional[pulumi.Input[str]] = None,
                 maintenance_windows: Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowPropertiesArgs']]]] = None,
                 type: Optional[pulumi.Input[Union[str, 'SessionHostComponentUpdateType']]] = None,
                 use_session_host_local_time: Optional[pulumi.Input[bool]] = None):
        """
        The session host configuration for updating agent, monitoring agent, and stack component.
        :param pulumi.Input[str] maintenance_window_time_zone: Time zone for maintenance as defined in https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.findsystemtimezonebyid?view=net-5.0. Must be set if useLocalTime is true.
        :param pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowPropertiesArgs']]] maintenance_windows: List of maintenance windows. Maintenance windows are 2 hours long.
        :param pulumi.Input[Union[str, 'SessionHostComponentUpdateType']] type: The type of maintenance for session host components.
        :param pulumi.Input[bool] use_session_host_local_time: Whether to use localTime of the virtual machine.
        """
        if maintenance_window_time_zone is not None:
            pulumi.set(__self__, "maintenance_window_time_zone", maintenance_window_time_zone)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_session_host_local_time is not None:
            pulumi.set(__self__, "use_session_host_local_time", use_session_host_local_time)

    @property
    @pulumi.getter(name="maintenanceWindowTimeZone")
    def maintenance_window_time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Time zone for maintenance as defined in https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.findsystemtimezonebyid?view=net-5.0. Must be set if useLocalTime is true.
        """
        return pulumi.get(self, "maintenance_window_time_zone")

    @maintenance_window_time_zone.setter
    def maintenance_window_time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_window_time_zone", value)

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowPropertiesArgs']]]]:
        """
        List of maintenance windows. Maintenance windows are 2 hours long.
        """
        return pulumi.get(self, "maintenance_windows")

    @maintenance_windows.setter
    def maintenance_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MaintenanceWindowPropertiesArgs']]]]):
        pulumi.set(self, "maintenance_windows", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'SessionHostComponentUpdateType']]]:
        """
        The type of maintenance for session host components.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'SessionHostComponentUpdateType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useSessionHostLocalTime")
    def use_session_host_local_time(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use localTime of the virtual machine.
        """
        return pulumi.get(self, "use_session_host_local_time")

    @use_session_host_local_time.setter
    def use_session_host_local_time(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_session_host_local_time", value)


if not MYPY:
    class MaintenanceWindowPropertiesArgsDict(TypedDict):
        """
        Maintenance window starting hour and day of week.
        """
        day_of_week: NotRequired[pulumi.Input['DayOfWeek']]
        """
        Day of the week.
        """
        hour: NotRequired[pulumi.Input[int]]
        """
        The update start hour of the day. (0 - 23)
        """
elif False:
    MaintenanceWindowPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaintenanceWindowPropertiesArgs:
    def __init__(__self__, *,
                 day_of_week: Optional[pulumi.Input['DayOfWeek']] = None,
                 hour: Optional[pulumi.Input[int]] = None):
        """
        Maintenance window starting hour and day of week.
        :param pulumi.Input['DayOfWeek'] day_of_week: Day of the week.
        :param pulumi.Input[int] hour: The update start hour of the day. (0 - 23)
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input['DayOfWeek']]:
        """
        Day of the week.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input['DayOfWeek']]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        """
        The update start hour of the day. (0 - 23)
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)


if not MYPY:
    class MigrationRequestPropertiesArgsDict(TypedDict):
        """
        Properties for arm migration.
        """
        migration_path: NotRequired[pulumi.Input[str]]
        """
        The path to the legacy object to migrate.
        """
        operation: NotRequired[pulumi.Input[Union[str, 'Operation']]]
        """
        The type of operation for migration.
        """
elif False:
    MigrationRequestPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MigrationRequestPropertiesArgs:
    def __init__(__self__, *,
                 migration_path: Optional[pulumi.Input[str]] = None,
                 operation: Optional[pulumi.Input[Union[str, 'Operation']]] = None):
        """
        Properties for arm migration.
        :param pulumi.Input[str] migration_path: The path to the legacy object to migrate.
        :param pulumi.Input[Union[str, 'Operation']] operation: The type of operation for migration.
        """
        if migration_path is not None:
            pulumi.set(__self__, "migration_path", migration_path)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)

    @property
    @pulumi.getter(name="migrationPath")
    def migration_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the legacy object to migrate.
        """
        return pulumi.get(self, "migration_path")

    @migration_path.setter
    def migration_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "migration_path", value)

    @property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[Union[str, 'Operation']]]:
        """
        The type of operation for migration.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[Union[str, 'Operation']]]):
        pulumi.set(self, "operation", value)


if not MYPY:
    class RegistrationInfoArgsDict(TypedDict):
        """
        Represents a RegistrationInfo definition.
        """
        expiration_time: NotRequired[pulumi.Input[str]]
        """
        Expiration time of registration token.
        """
        registration_token_operation: NotRequired[pulumi.Input[Union[str, 'RegistrationTokenOperation']]]
        """
        The type of resetting the token.
        """
        token: NotRequired[pulumi.Input[str]]
        """
        The registration token base64 encoded string.
        """
elif False:
    RegistrationInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistrationInfoArgs:
    def __init__(__self__, *,
                 expiration_time: Optional[pulumi.Input[str]] = None,
                 registration_token_operation: Optional[pulumi.Input[Union[str, 'RegistrationTokenOperation']]] = None,
                 token: Optional[pulumi.Input[str]] = None):
        """
        Represents a RegistrationInfo definition.
        :param pulumi.Input[str] expiration_time: Expiration time of registration token.
        :param pulumi.Input[Union[str, 'RegistrationTokenOperation']] registration_token_operation: The type of resetting the token.
        :param pulumi.Input[str] token: The registration token base64 encoded string.
        """
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if registration_token_operation is not None:
            pulumi.set(__self__, "registration_token_operation", registration_token_operation)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        Expiration time of registration token.
        """
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration_time", value)

    @property
    @pulumi.getter(name="registrationTokenOperation")
    def registration_token_operation(self) -> Optional[pulumi.Input[Union[str, 'RegistrationTokenOperation']]]:
        """
        The type of resetting the token.
        """
        return pulumi.get(self, "registration_token_operation")

    @registration_token_operation.setter
    def registration_token_operation(self, value: Optional[pulumi.Input[Union[str, 'RegistrationTokenOperation']]]):
        pulumi.set(self, "registration_token_operation", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        The registration token base64 encoded string.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ResourceModelWithAllowedPropertySetIdentityArgsDict(TypedDict):
        type: NotRequired[pulumi.Input['ResourceIdentityType']]
        """
        The identity type.
        """
elif False:
    ResourceModelWithAllowedPropertySetIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceModelWithAllowedPropertySetIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ResourceIdentityType']] = None):
        """
        :param pulumi.Input['ResourceIdentityType'] type: The identity type.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ResourceIdentityType']]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ResourceIdentityType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResourceModelWithAllowedPropertySetPlanArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A user defined name of the 3rd Party Artifact that is being procured.
        """
        product: pulumi.Input[str]
        """
        The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        """
        publisher: pulumi.Input[str]
        """
        The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        """
        promotion_code: NotRequired[pulumi.Input[str]]
        """
        A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        The version of the desired product/artifact.
        """
elif False:
    ResourceModelWithAllowedPropertySetPlanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceModelWithAllowedPropertySetPlanArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 product: pulumi.Input[str],
                 publisher: pulumi.Input[str],
                 promotion_code: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: A user defined name of the 3rd Party Artifact that is being procured.
        :param pulumi.Input[str] product: The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        :param pulumi.Input[str] publisher: The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        :param pulumi.Input[str] promotion_code: A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        :param pulumi.Input[str] version: The version of the desired product/artifact.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)
        if promotion_code is not None:
            pulumi.set(__self__, "promotion_code", promotion_code)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A user defined name of the 3rd Party Artifact that is being procured.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[str]:
        """
        The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[str]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[str]:
        """
        The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[str]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[pulumi.Input[str]]:
        """
        A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        """
        return pulumi.get(self, "promotion_code")

    @promotion_code.setter
    def promotion_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "promotion_code", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the desired product/artifact.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ResourceModelWithAllowedPropertySetSkuArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the SKU. Ex - P3. It is typically a letter+number code
        """
        capacity: NotRequired[pulumi.Input[int]]
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        family: NotRequired[pulumi.Input[str]]
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        size: NotRequired[pulumi.Input[str]]
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        tier: NotRequired[pulumi.Input['SkuTier']]
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
elif False:
    ResourceModelWithAllowedPropertySetSkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceModelWithAllowedPropertySetSkuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 capacity: Optional[pulumi.Input[int]] = None,
                 family: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 tier: Optional[pulumi.Input['SkuTier']] = None):
        """
        :param pulumi.Input[str] name: The name of the SKU. Ex - P3. It is typically a letter+number code
        :param pulumi.Input[int] capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param pulumi.Input[str] family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
        :param pulumi.Input[str] size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param pulumi.Input['SkuTier'] tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the SKU. Ex - P3. It is typically a letter+number code
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[int]]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input[str]]:
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input['SkuTier']]:
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input['SkuTier']]):
        pulumi.set(self, "tier", value)


