# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AgentUpdatePropertiesResponse',
    'ApplicationGroupPropertiesResponse',
    'ApplicationPropertiesResponse',
    'HostPoolPropertiesResponse',
    'MSIXPackagePropertiesResponse',
    'MaintenanceWindowPropertiesResponse',
    'MigrationRequestPropertiesResponse',
    'MsixPackageApplicationsResponse',
    'MsixPackageDependenciesResponse',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'RegistrationInfoResponse',
    'ResourceModelWithAllowedPropertySetResponseIdentity',
    'ResourceModelWithAllowedPropertySetResponsePlan',
    'ResourceModelWithAllowedPropertySetResponseSku',
    'ScalingHostPoolReferenceResponse',
    'ScalingPlanPooledSchedulePropertiesResponse',
    'ScalingPlanPropertiesResponse',
    'ScalingScheduleResponse',
    'SystemDataResponse',
    'TimeResponse',
]

@pulumi.output_type
class AgentUpdatePropertiesResponse(dict):
    """
    The session host configuration for updating agent, monitoring agent, and stack component.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceWindowTimeZone":
            suggest = "maintenance_window_time_zone"
        elif key == "maintenanceWindows":
            suggest = "maintenance_windows"
        elif key == "useSessionHostLocalTime":
            suggest = "use_session_host_local_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentUpdatePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentUpdatePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentUpdatePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_window_time_zone: Optional[str] = None,
                 maintenance_windows: Optional[Sequence['outputs.MaintenanceWindowPropertiesResponse']] = None,
                 type: Optional[str] = None,
                 use_session_host_local_time: Optional[bool] = None):
        """
        The session host configuration for updating agent, monitoring agent, and stack component.
        :param str maintenance_window_time_zone: Time zone for maintenance as defined in https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.findsystemtimezonebyid?view=net-5.0. Must be set if useLocalTime is true.
        :param Sequence['MaintenanceWindowPropertiesResponse'] maintenance_windows: List of maintenance windows. Maintenance windows are 2 hours long.
        :param str type: The type of maintenance for session host components.
        :param bool use_session_host_local_time: Whether to use localTime of the virtual machine.
        """
        if maintenance_window_time_zone is not None:
            pulumi.set(__self__, "maintenance_window_time_zone", maintenance_window_time_zone)
        if maintenance_windows is not None:
            pulumi.set(__self__, "maintenance_windows", maintenance_windows)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_session_host_local_time is not None:
            pulumi.set(__self__, "use_session_host_local_time", use_session_host_local_time)

    @property
    @pulumi.getter(name="maintenanceWindowTimeZone")
    def maintenance_window_time_zone(self) -> Optional[str]:
        """
        Time zone for maintenance as defined in https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.findsystemtimezonebyid?view=net-5.0. Must be set if useLocalTime is true.
        """
        return pulumi.get(self, "maintenance_window_time_zone")

    @property
    @pulumi.getter(name="maintenanceWindows")
    def maintenance_windows(self) -> Optional[Sequence['outputs.MaintenanceWindowPropertiesResponse']]:
        """
        List of maintenance windows. Maintenance windows are 2 hours long.
        """
        return pulumi.get(self, "maintenance_windows")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of maintenance for session host components.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useSessionHostLocalTime")
    def use_session_host_local_time(self) -> Optional[bool]:
        """
        Whether to use localTime of the virtual machine.
        """
        return pulumi.get(self, "use_session_host_local_time")


@pulumi.output_type
class ApplicationGroupPropertiesResponse(dict):
    """
    Schema for ApplicationGroup properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationGroupType":
            suggest = "application_group_type"
        elif key == "cloudPcResource":
            suggest = "cloud_pc_resource"
        elif key == "hostPoolArmPath":
            suggest = "host_pool_arm_path"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "workspaceArmPath":
            suggest = "workspace_arm_path"
        elif key == "friendlyName":
            suggest = "friendly_name"
        elif key == "migrationRequest":
            suggest = "migration_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_group_type: str,
                 cloud_pc_resource: bool,
                 host_pool_arm_path: str,
                 object_id: str,
                 workspace_arm_path: str,
                 description: Optional[str] = None,
                 friendly_name: Optional[str] = None,
                 migration_request: Optional['outputs.MigrationRequestPropertiesResponse'] = None):
        """
        Schema for ApplicationGroup properties.
        :param str application_group_type: Resource Type of ApplicationGroup.
        :param bool cloud_pc_resource: Is cloud pc resource.
        :param str host_pool_arm_path: HostPool arm path of ApplicationGroup.
        :param str object_id: ObjectId of ApplicationGroup. (internal use)
        :param str workspace_arm_path: Workspace arm path of ApplicationGroup.
        :param str description: Description of ApplicationGroup.
        :param str friendly_name: Friendly name of ApplicationGroup.
        :param 'MigrationRequestPropertiesResponse' migration_request: The registration info of HostPool.
        """
        pulumi.set(__self__, "application_group_type", application_group_type)
        pulumi.set(__self__, "cloud_pc_resource", cloud_pc_resource)
        pulumi.set(__self__, "host_pool_arm_path", host_pool_arm_path)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "workspace_arm_path", workspace_arm_path)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if migration_request is not None:
            pulumi.set(__self__, "migration_request", migration_request)

    @property
    @pulumi.getter(name="applicationGroupType")
    def application_group_type(self) -> str:
        """
        Resource Type of ApplicationGroup.
        """
        return pulumi.get(self, "application_group_type")

    @property
    @pulumi.getter(name="cloudPcResource")
    def cloud_pc_resource(self) -> bool:
        """
        Is cloud pc resource.
        """
        return pulumi.get(self, "cloud_pc_resource")

    @property
    @pulumi.getter(name="hostPoolArmPath")
    def host_pool_arm_path(self) -> str:
        """
        HostPool arm path of ApplicationGroup.
        """
        return pulumi.get(self, "host_pool_arm_path")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> str:
        """
        ObjectId of ApplicationGroup. (internal use)
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="workspaceArmPath")
    def workspace_arm_path(self) -> str:
        """
        Workspace arm path of ApplicationGroup.
        """
        return pulumi.get(self, "workspace_arm_path")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of ApplicationGroup.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[str]:
        """
        Friendly name of ApplicationGroup.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter(name="migrationRequest")
    def migration_request(self) -> Optional['outputs.MigrationRequestPropertiesResponse']:
        """
        The registration info of HostPool.
        """
        return pulumi.get(self, "migration_request")


@pulumi.output_type
class ApplicationPropertiesResponse(dict):
    """
    Schema for Application properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandLineSetting":
            suggest = "command_line_setting"
        elif key == "iconContent":
            suggest = "icon_content"
        elif key == "iconHash":
            suggest = "icon_hash"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "applicationType":
            suggest = "application_type"
        elif key == "commandLineArguments":
            suggest = "command_line_arguments"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "friendlyName":
            suggest = "friendly_name"
        elif key == "iconIndex":
            suggest = "icon_index"
        elif key == "iconPath":
            suggest = "icon_path"
        elif key == "msixPackageApplicationId":
            suggest = "msix_package_application_id"
        elif key == "msixPackageFamilyName":
            suggest = "msix_package_family_name"
        elif key == "showInPortal":
            suggest = "show_in_portal"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_line_setting: str,
                 icon_content: str,
                 icon_hash: str,
                 object_id: str,
                 application_type: Optional[str] = None,
                 command_line_arguments: Optional[str] = None,
                 description: Optional[str] = None,
                 file_path: Optional[str] = None,
                 friendly_name: Optional[str] = None,
                 icon_index: Optional[int] = None,
                 icon_path: Optional[str] = None,
                 msix_package_application_id: Optional[str] = None,
                 msix_package_family_name: Optional[str] = None,
                 show_in_portal: Optional[bool] = None):
        """
        Schema for Application properties.
        :param str command_line_setting: Specifies whether this published application can be launched with command line arguments provided by the client, command line arguments specified at publish time, or no command line arguments at all.
        :param str icon_content: the icon a 64 bit string as a byte array.
        :param str icon_hash: Hash of the icon.
        :param str object_id: ObjectId of Application. (internal use)
        :param str application_type: Resource Type of Application.
        :param str command_line_arguments: Command Line Arguments for Application.
        :param str description: Description of Application.
        :param str file_path: Specifies a path for the executable file for the application.
        :param str friendly_name: Friendly name of Application.
        :param int icon_index: Index of the icon.
        :param str icon_path: Path to icon.
        :param str msix_package_application_id: Specifies the package application Id for MSIX applications
        :param str msix_package_family_name: Specifies the package family name for MSIX applications
        :param bool show_in_portal: Specifies whether to show the RemoteApp program in the RD Web Access server.
        """
        pulumi.set(__self__, "command_line_setting", command_line_setting)
        pulumi.set(__self__, "icon_content", icon_content)
        pulumi.set(__self__, "icon_hash", icon_hash)
        pulumi.set(__self__, "object_id", object_id)
        if application_type is not None:
            pulumi.set(__self__, "application_type", application_type)
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if icon_index is not None:
            pulumi.set(__self__, "icon_index", icon_index)
        if icon_path is not None:
            pulumi.set(__self__, "icon_path", icon_path)
        if msix_package_application_id is not None:
            pulumi.set(__self__, "msix_package_application_id", msix_package_application_id)
        if msix_package_family_name is not None:
            pulumi.set(__self__, "msix_package_family_name", msix_package_family_name)
        if show_in_portal is not None:
            pulumi.set(__self__, "show_in_portal", show_in_portal)

    @property
    @pulumi.getter(name="commandLineSetting")
    def command_line_setting(self) -> str:
        """
        Specifies whether this published application can be launched with command line arguments provided by the client, command line arguments specified at publish time, or no command line arguments at all.
        """
        return pulumi.get(self, "command_line_setting")

    @property
    @pulumi.getter(name="iconContent")
    def icon_content(self) -> str:
        """
        the icon a 64 bit string as a byte array.
        """
        return pulumi.get(self, "icon_content")

    @property
    @pulumi.getter(name="iconHash")
    def icon_hash(self) -> str:
        """
        Hash of the icon.
        """
        return pulumi.get(self, "icon_hash")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> str:
        """
        ObjectId of Application. (internal use)
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="applicationType")
    def application_type(self) -> Optional[str]:
        """
        Resource Type of Application.
        """
        return pulumi.get(self, "application_type")

    @property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[str]:
        """
        Command Line Arguments for Application.
        """
        return pulumi.get(self, "command_line_arguments")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of Application.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        Specifies a path for the executable file for the application.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[str]:
        """
        Friendly name of Application.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter(name="iconIndex")
    def icon_index(self) -> Optional[int]:
        """
        Index of the icon.
        """
        return pulumi.get(self, "icon_index")

    @property
    @pulumi.getter(name="iconPath")
    def icon_path(self) -> Optional[str]:
        """
        Path to icon.
        """
        return pulumi.get(self, "icon_path")

    @property
    @pulumi.getter(name="msixPackageApplicationId")
    def msix_package_application_id(self) -> Optional[str]:
        """
        Specifies the package application Id for MSIX applications
        """
        return pulumi.get(self, "msix_package_application_id")

    @property
    @pulumi.getter(name="msixPackageFamilyName")
    def msix_package_family_name(self) -> Optional[str]:
        """
        Specifies the package family name for MSIX applications
        """
        return pulumi.get(self, "msix_package_family_name")

    @property
    @pulumi.getter(name="showInPortal")
    def show_in_portal(self) -> Optional[bool]:
        """
        Specifies whether to show the RemoteApp program in the RD Web Access server.
        """
        return pulumi.get(self, "show_in_portal")


@pulumi.output_type
class HostPoolPropertiesResponse(dict):
    """
    Properties of HostPool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationGroupReferences":
            suggest = "application_group_references"
        elif key == "cloudPcResource":
            suggest = "cloud_pc_resource"
        elif key == "hostPoolType":
            suggest = "host_pool_type"
        elif key == "loadBalancerType":
            suggest = "load_balancer_type"
        elif key == "objectId":
            suggest = "object_id"
        elif key == "preferredAppGroupType":
            suggest = "preferred_app_group_type"
        elif key == "privateEndpointConnections":
            suggest = "private_endpoint_connections"
        elif key == "agentUpdate":
            suggest = "agent_update"
        elif key == "customRdpProperty":
            suggest = "custom_rdp_property"
        elif key == "friendlyName":
            suggest = "friendly_name"
        elif key == "maxSessionLimit":
            suggest = "max_session_limit"
        elif key == "migrationRequest":
            suggest = "migration_request"
        elif key == "personalDesktopAssignmentType":
            suggest = "personal_desktop_assignment_type"
        elif key == "publicNetworkAccess":
            suggest = "public_network_access"
        elif key == "registrationInfo":
            suggest = "registration_info"
        elif key == "ssoClientId":
            suggest = "sso_client_id"
        elif key == "ssoClientSecretKeyVaultPath":
            suggest = "sso_client_secret_key_vault_path"
        elif key == "ssoSecretType":
            suggest = "sso_secret_type"
        elif key == "ssoadfsAuthority":
            suggest = "ssoadfs_authority"
        elif key == "startVMOnConnect":
            suggest = "start_vm_on_connect"
        elif key == "validationEnvironment":
            suggest = "validation_environment"
        elif key == "vmTemplate":
            suggest = "vm_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostPoolPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostPoolPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostPoolPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_group_references: Sequence[str],
                 cloud_pc_resource: bool,
                 host_pool_type: str,
                 load_balancer_type: str,
                 object_id: str,
                 preferred_app_group_type: str,
                 private_endpoint_connections: Sequence['outputs.PrivateEndpointConnectionResponse'],
                 agent_update: Optional['outputs.AgentUpdatePropertiesResponse'] = None,
                 custom_rdp_property: Optional[str] = None,
                 description: Optional[str] = None,
                 friendly_name: Optional[str] = None,
                 max_session_limit: Optional[int] = None,
                 migration_request: Optional['outputs.MigrationRequestPropertiesResponse'] = None,
                 personal_desktop_assignment_type: Optional[str] = None,
                 public_network_access: Optional[str] = None,
                 registration_info: Optional['outputs.RegistrationInfoResponse'] = None,
                 ring: Optional[int] = None,
                 sso_client_id: Optional[str] = None,
                 sso_client_secret_key_vault_path: Optional[str] = None,
                 sso_secret_type: Optional[str] = None,
                 ssoadfs_authority: Optional[str] = None,
                 start_vm_on_connect: Optional[bool] = None,
                 validation_environment: Optional[bool] = None,
                 vm_template: Optional[str] = None):
        """
        Properties of HostPool.
        :param Sequence[str] application_group_references: List of applicationGroup links.
        :param bool cloud_pc_resource: Is cloud pc resource.
        :param str host_pool_type: HostPool type for desktop.
        :param str load_balancer_type: The type of the load balancer.
        :param str object_id: ObjectId of HostPool. (internal use)
        :param str preferred_app_group_type: The type of preferred application group type, default to Desktop Application Group
        :param Sequence['PrivateEndpointConnectionResponse'] private_endpoint_connections: List of private endpoint connection associated with the specified resource
        :param 'AgentUpdatePropertiesResponse' agent_update: The session host configuration for updating agent, monitoring agent, and stack component.
        :param str custom_rdp_property: Custom rdp property of HostPool.
        :param str description: Description of HostPool.
        :param str friendly_name: Friendly name of HostPool.
        :param int max_session_limit: The max session limit of HostPool.
        :param 'MigrationRequestPropertiesResponse' migration_request: The registration info of HostPool.
        :param str personal_desktop_assignment_type: PersonalDesktopAssignment type for HostPool.
        :param str public_network_access: Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only be accessed via private endpoints
        :param 'RegistrationInfoResponse' registration_info: The registration info of HostPool.
        :param int ring: The ring number of HostPool.
        :param str sso_client_id: ClientId for the registered Relying Party used to issue WVD SSO certificates.
        :param str sso_client_secret_key_vault_path: Path to Azure KeyVault storing the secret used for communication to ADFS.
        :param str sso_secret_type: The type of single sign on Secret Type.
        :param str ssoadfs_authority: URL to customer ADFS server for signing WVD SSO certificates.
        :param bool start_vm_on_connect: The flag to turn on/off StartVMOnConnect feature.
        :param bool validation_environment: Is validation environment.
        :param str vm_template: VM template for sessionhosts configuration within hostpool.
        """
        pulumi.set(__self__, "application_group_references", application_group_references)
        pulumi.set(__self__, "cloud_pc_resource", cloud_pc_resource)
        pulumi.set(__self__, "host_pool_type", host_pool_type)
        pulumi.set(__self__, "load_balancer_type", load_balancer_type)
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "preferred_app_group_type", preferred_app_group_type)
        pulumi.set(__self__, "private_endpoint_connections", private_endpoint_connections)
        if agent_update is not None:
            pulumi.set(__self__, "agent_update", agent_update)
        if custom_rdp_property is not None:
            pulumi.set(__self__, "custom_rdp_property", custom_rdp_property)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if max_session_limit is not None:
            pulumi.set(__self__, "max_session_limit", max_session_limit)
        if migration_request is not None:
            pulumi.set(__self__, "migration_request", migration_request)
        if personal_desktop_assignment_type is not None:
            pulumi.set(__self__, "personal_desktop_assignment_type", personal_desktop_assignment_type)
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)
        if registration_info is not None:
            pulumi.set(__self__, "registration_info", registration_info)
        if ring is not None:
            pulumi.set(__self__, "ring", ring)
        if sso_client_id is not None:
            pulumi.set(__self__, "sso_client_id", sso_client_id)
        if sso_client_secret_key_vault_path is not None:
            pulumi.set(__self__, "sso_client_secret_key_vault_path", sso_client_secret_key_vault_path)
        if sso_secret_type is not None:
            pulumi.set(__self__, "sso_secret_type", sso_secret_type)
        if ssoadfs_authority is not None:
            pulumi.set(__self__, "ssoadfs_authority", ssoadfs_authority)
        if start_vm_on_connect is not None:
            pulumi.set(__self__, "start_vm_on_connect", start_vm_on_connect)
        if validation_environment is not None:
            pulumi.set(__self__, "validation_environment", validation_environment)
        if vm_template is not None:
            pulumi.set(__self__, "vm_template", vm_template)

    @property
    @pulumi.getter(name="applicationGroupReferences")
    def application_group_references(self) -> Sequence[str]:
        """
        List of applicationGroup links.
        """
        return pulumi.get(self, "application_group_references")

    @property
    @pulumi.getter(name="cloudPcResource")
    def cloud_pc_resource(self) -> bool:
        """
        Is cloud pc resource.
        """
        return pulumi.get(self, "cloud_pc_resource")

    @property
    @pulumi.getter(name="hostPoolType")
    def host_pool_type(self) -> str:
        """
        HostPool type for desktop.
        """
        return pulumi.get(self, "host_pool_type")

    @property
    @pulumi.getter(name="loadBalancerType")
    def load_balancer_type(self) -> str:
        """
        The type of the load balancer.
        """
        return pulumi.get(self, "load_balancer_type")

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> str:
        """
        ObjectId of HostPool. (internal use)
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="preferredAppGroupType")
    def preferred_app_group_type(self) -> str:
        """
        The type of preferred application group type, default to Desktop Application Group
        """
        return pulumi.get(self, "preferred_app_group_type")

    @property
    @pulumi.getter(name="privateEndpointConnections")
    def private_endpoint_connections(self) -> Sequence['outputs.PrivateEndpointConnectionResponse']:
        """
        List of private endpoint connection associated with the specified resource
        """
        return pulumi.get(self, "private_endpoint_connections")

    @property
    @pulumi.getter(name="agentUpdate")
    def agent_update(self) -> Optional['outputs.AgentUpdatePropertiesResponse']:
        """
        The session host configuration for updating agent, monitoring agent, and stack component.
        """
        return pulumi.get(self, "agent_update")

    @property
    @pulumi.getter(name="customRdpProperty")
    def custom_rdp_property(self) -> Optional[str]:
        """
        Custom rdp property of HostPool.
        """
        return pulumi.get(self, "custom_rdp_property")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of HostPool.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[str]:
        """
        Friendly name of HostPool.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter(name="maxSessionLimit")
    def max_session_limit(self) -> Optional[int]:
        """
        The max session limit of HostPool.
        """
        return pulumi.get(self, "max_session_limit")

    @property
    @pulumi.getter(name="migrationRequest")
    def migration_request(self) -> Optional['outputs.MigrationRequestPropertiesResponse']:
        """
        The registration info of HostPool.
        """
        return pulumi.get(self, "migration_request")

    @property
    @pulumi.getter(name="personalDesktopAssignmentType")
    def personal_desktop_assignment_type(self) -> Optional[str]:
        """
        PersonalDesktopAssignment type for HostPool.
        """
        return pulumi.get(self, "personal_desktop_assignment_type")

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[str]:
        """
        Enabled allows this resource to be accessed from both public and private networks, Disabled allows this resource to only be accessed via private endpoints
        """
        return pulumi.get(self, "public_network_access")

    @property
    @pulumi.getter(name="registrationInfo")
    def registration_info(self) -> Optional['outputs.RegistrationInfoResponse']:
        """
        The registration info of HostPool.
        """
        return pulumi.get(self, "registration_info")

    @property
    @pulumi.getter
    def ring(self) -> Optional[int]:
        """
        The ring number of HostPool.
        """
        return pulumi.get(self, "ring")

    @property
    @pulumi.getter(name="ssoClientId")
    def sso_client_id(self) -> Optional[str]:
        """
        ClientId for the registered Relying Party used to issue WVD SSO certificates.
        """
        return pulumi.get(self, "sso_client_id")

    @property
    @pulumi.getter(name="ssoClientSecretKeyVaultPath")
    def sso_client_secret_key_vault_path(self) -> Optional[str]:
        """
        Path to Azure KeyVault storing the secret used for communication to ADFS.
        """
        return pulumi.get(self, "sso_client_secret_key_vault_path")

    @property
    @pulumi.getter(name="ssoSecretType")
    def sso_secret_type(self) -> Optional[str]:
        """
        The type of single sign on Secret Type.
        """
        return pulumi.get(self, "sso_secret_type")

    @property
    @pulumi.getter(name="ssoadfsAuthority")
    def ssoadfs_authority(self) -> Optional[str]:
        """
        URL to customer ADFS server for signing WVD SSO certificates.
        """
        return pulumi.get(self, "ssoadfs_authority")

    @property
    @pulumi.getter(name="startVMOnConnect")
    def start_vm_on_connect(self) -> Optional[bool]:
        """
        The flag to turn on/off StartVMOnConnect feature.
        """
        return pulumi.get(self, "start_vm_on_connect")

    @property
    @pulumi.getter(name="validationEnvironment")
    def validation_environment(self) -> Optional[bool]:
        """
        Is validation environment.
        """
        return pulumi.get(self, "validation_environment")

    @property
    @pulumi.getter(name="vmTemplate")
    def vm_template(self) -> Optional[str]:
        """
        VM template for sessionhosts configuration within hostpool.
        """
        return pulumi.get(self, "vm_template")


@pulumi.output_type
class MSIXPackagePropertiesResponse(dict):
    """
    Schema for MSIX Package properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "imagePath":
            suggest = "image_path"
        elif key == "isActive":
            suggest = "is_active"
        elif key == "isRegularRegistration":
            suggest = "is_regular_registration"
        elif key == "lastUpdated":
            suggest = "last_updated"
        elif key == "packageApplications":
            suggest = "package_applications"
        elif key == "packageDependencies":
            suggest = "package_dependencies"
        elif key == "packageFamilyName":
            suggest = "package_family_name"
        elif key == "packageName":
            suggest = "package_name"
        elif key == "packageRelativePath":
            suggest = "package_relative_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MSIXPackagePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MSIXPackagePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MSIXPackagePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 image_path: Optional[str] = None,
                 is_active: Optional[bool] = None,
                 is_regular_registration: Optional[bool] = None,
                 last_updated: Optional[str] = None,
                 package_applications: Optional[Sequence['outputs.MsixPackageApplicationsResponse']] = None,
                 package_dependencies: Optional[Sequence['outputs.MsixPackageDependenciesResponse']] = None,
                 package_family_name: Optional[str] = None,
                 package_name: Optional[str] = None,
                 package_relative_path: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Schema for MSIX Package properties.
        :param str display_name: User friendly Name to be displayed in the portal. 
        :param str image_path: VHD/CIM image path on Network Share.
        :param bool is_active: Make this version of the package the active one across the hostpool. 
        :param bool is_regular_registration: Specifies how to register Package in feed.
        :param str last_updated: Date Package was last updated, found in the appxmanifest.xml. 
        :param Sequence['MsixPackageApplicationsResponse'] package_applications: List of package applications. 
        :param Sequence['MsixPackageDependenciesResponse'] package_dependencies: List of package dependencies. 
        :param str package_family_name: Package Family Name from appxmanifest.xml. Contains Package Name and Publisher name. 
        :param str package_name: Package Name from appxmanifest.xml. 
        :param str package_relative_path: Relative Path to the package inside the image. 
        :param str version: Package Version found in the appxmanifest.xml. 
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if image_path is not None:
            pulumi.set(__self__, "image_path", image_path)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if is_regular_registration is not None:
            pulumi.set(__self__, "is_regular_registration", is_regular_registration)
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if package_applications is not None:
            pulumi.set(__self__, "package_applications", package_applications)
        if package_dependencies is not None:
            pulumi.set(__self__, "package_dependencies", package_dependencies)
        if package_family_name is not None:
            pulumi.set(__self__, "package_family_name", package_family_name)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if package_relative_path is not None:
            pulumi.set(__self__, "package_relative_path", package_relative_path)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        User friendly Name to be displayed in the portal. 
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="imagePath")
    def image_path(self) -> Optional[str]:
        """
        VHD/CIM image path on Network Share.
        """
        return pulumi.get(self, "image_path")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[bool]:
        """
        Make this version of the package the active one across the hostpool. 
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter(name="isRegularRegistration")
    def is_regular_registration(self) -> Optional[bool]:
        """
        Specifies how to register Package in feed.
        """
        return pulumi.get(self, "is_regular_registration")

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[str]:
        """
        Date Package was last updated, found in the appxmanifest.xml. 
        """
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter(name="packageApplications")
    def package_applications(self) -> Optional[Sequence['outputs.MsixPackageApplicationsResponse']]:
        """
        List of package applications. 
        """
        return pulumi.get(self, "package_applications")

    @property
    @pulumi.getter(name="packageDependencies")
    def package_dependencies(self) -> Optional[Sequence['outputs.MsixPackageDependenciesResponse']]:
        """
        List of package dependencies. 
        """
        return pulumi.get(self, "package_dependencies")

    @property
    @pulumi.getter(name="packageFamilyName")
    def package_family_name(self) -> Optional[str]:
        """
        Package Family Name from appxmanifest.xml. Contains Package Name and Publisher name. 
        """
        return pulumi.get(self, "package_family_name")

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[str]:
        """
        Package Name from appxmanifest.xml. 
        """
        return pulumi.get(self, "package_name")

    @property
    @pulumi.getter(name="packageRelativePath")
    def package_relative_path(self) -> Optional[str]:
        """
        Relative Path to the package inside the image. 
        """
        return pulumi.get(self, "package_relative_path")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Package Version found in the appxmanifest.xml. 
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MaintenanceWindowPropertiesResponse(dict):
    """
    Maintenance window starting hour and day of week.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: Optional[str] = None,
                 hour: Optional[int] = None):
        """
        Maintenance window starting hour and day of week.
        :param str day_of_week: Day of the week.
        :param int hour: The update start hour of the day. (0 - 23)
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[str]:
        """
        Day of the week.
        """
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter
    def hour(self) -> Optional[int]:
        """
        The update start hour of the day. (0 - 23)
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class MigrationRequestPropertiesResponse(dict):
    """
    Properties for arm migration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "migrationPath":
            suggest = "migration_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MigrationRequestPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MigrationRequestPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MigrationRequestPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 migration_path: Optional[str] = None,
                 operation: Optional[str] = None):
        """
        Properties for arm migration.
        :param str migration_path: The path to the legacy object to migrate.
        :param str operation: The type of operation for migration.
        """
        if migration_path is not None:
            pulumi.set(__self__, "migration_path", migration_path)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)

    @property
    @pulumi.getter(name="migrationPath")
    def migration_path(self) -> Optional[str]:
        """
        The path to the legacy object to migrate.
        """
        return pulumi.get(self, "migration_path")

    @property
    @pulumi.getter
    def operation(self) -> Optional[str]:
        """
        The type of operation for migration.
        """
        return pulumi.get(self, "operation")


@pulumi.output_type
class MsixPackageApplicationsResponse(dict):
    """
    Schema for MSIX Package Application properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appUserModelID":
            suggest = "app_user_model_id"
        elif key == "friendlyName":
            suggest = "friendly_name"
        elif key == "iconImageName":
            suggest = "icon_image_name"
        elif key == "rawIcon":
            suggest = "raw_icon"
        elif key == "rawPng":
            suggest = "raw_png"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MsixPackageApplicationsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MsixPackageApplicationsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MsixPackageApplicationsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[str] = None,
                 app_user_model_id: Optional[str] = None,
                 description: Optional[str] = None,
                 friendly_name: Optional[str] = None,
                 icon_image_name: Optional[str] = None,
                 raw_icon: Optional[str] = None,
                 raw_png: Optional[str] = None):
        """
        Schema for MSIX Package Application properties.
        :param str app_id: Package Application Id, found in appxmanifest.xml.
        :param str app_user_model_id: Used to activate Package Application. Consists of Package Name and ApplicationID. Found in appxmanifest.xml.
        :param str description: Description of Package Application.
        :param str friendly_name: User friendly name.
        :param str icon_image_name: User friendly name.
        :param str raw_icon: the icon a 64 bit string as a byte array.
        :param str raw_png: the icon a 64 bit string as a byte array.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_user_model_id is not None:
            pulumi.set(__self__, "app_user_model_id", app_user_model_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if icon_image_name is not None:
            pulumi.set(__self__, "icon_image_name", icon_image_name)
        if raw_icon is not None:
            pulumi.set(__self__, "raw_icon", raw_icon)
        if raw_png is not None:
            pulumi.set(__self__, "raw_png", raw_png)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[str]:
        """
        Package Application Id, found in appxmanifest.xml.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appUserModelID")
    def app_user_model_id(self) -> Optional[str]:
        """
        Used to activate Package Application. Consists of Package Name and ApplicationID. Found in appxmanifest.xml.
        """
        return pulumi.get(self, "app_user_model_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of Package Application.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[str]:
        """
        User friendly name.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter(name="iconImageName")
    def icon_image_name(self) -> Optional[str]:
        """
        User friendly name.
        """
        return pulumi.get(self, "icon_image_name")

    @property
    @pulumi.getter(name="rawIcon")
    def raw_icon(self) -> Optional[str]:
        """
        the icon a 64 bit string as a byte array.
        """
        return pulumi.get(self, "raw_icon")

    @property
    @pulumi.getter(name="rawPng")
    def raw_png(self) -> Optional[str]:
        """
        the icon a 64 bit string as a byte array.
        """
        return pulumi.get(self, "raw_png")


@pulumi.output_type
class MsixPackageDependenciesResponse(dict):
    """
    Schema for MSIX Package Dependencies properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dependencyName":
            suggest = "dependency_name"
        elif key == "minVersion":
            suggest = "min_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MsixPackageDependenciesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MsixPackageDependenciesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MsixPackageDependenciesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dependency_name: Optional[str] = None,
                 min_version: Optional[str] = None,
                 publisher: Optional[str] = None):
        """
        Schema for MSIX Package Dependencies properties.
        :param str dependency_name: Name of package dependency.
        :param str min_version: Dependency version required.
        :param str publisher: Name of dependency publisher.
        """
        if dependency_name is not None:
            pulumi.set(__self__, "dependency_name", dependency_name)
        if min_version is not None:
            pulumi.set(__self__, "min_version", min_version)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter(name="dependencyName")
    def dependency_name(self) -> Optional[str]:
        """
        Name of package dependency.
        """
        return pulumi.get(self, "dependency_name")

    @property
    @pulumi.getter(name="minVersion")
    def min_version(self) -> Optional[str]:
        """
        Dependency version required.
        """
        return pulumi.get(self, "min_version")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        Name of dependency publisher.
        """
        return pulumi.get(self, "publisher")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    """
    The Private Endpoint Connection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 private_link_service_connection_state: 'outputs.PrivateLinkServiceConnectionStateResponse',
                 provisioning_state: str,
                 type: str,
                 private_endpoint: Optional['outputs.PrivateEndpointResponse'] = None):
        """
        The Private Endpoint Connection resource.
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str name: The name of the resource
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: A collection of information about the state of the connection between service consumer and provider.
        :param str provisioning_state: The provisioning state of the private endpoint connection resource.
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'PrivateEndpointResponse' private_endpoint: The resource of private end point.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "type", type)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> 'outputs.PrivateLinkServiceConnectionStateResponse':
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state of the private endpoint connection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResponse']:
        """
        The resource of private end point.
        """
        return pulumi.get(self, "private_endpoint")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    The Private Endpoint resource.
    """
    def __init__(__self__, *,
                 id: str):
        """
        The Private Endpoint resource.
        :param str id: The ARM identifier for Private Endpoint
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ARM identifier for Private Endpoint
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    A collection of information about the state of the connection between service consumer and provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: Optional[str] = None,
                 description: Optional[str] = None,
                 status: Optional[str] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param str actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param str description: The reason for approval/rejection of the connection.
        :param str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[str]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class RegistrationInfoResponse(dict):
    """
    Represents a RegistrationInfo definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationTime":
            suggest = "expiration_time"
        elif key == "registrationTokenOperation":
            suggest = "registration_token_operation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistrationInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistrationInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistrationInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expiration_time: Optional[str] = None,
                 registration_token_operation: Optional[str] = None,
                 token: Optional[str] = None):
        """
        Represents a RegistrationInfo definition.
        :param str expiration_time: Expiration time of registration token.
        :param str registration_token_operation: The type of resetting the token.
        :param str token: The registration token base64 encoded string.
        """
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if registration_token_operation is not None:
            pulumi.set(__self__, "registration_token_operation", registration_token_operation)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[str]:
        """
        Expiration time of registration token.
        """
        return pulumi.get(self, "expiration_time")

    @property
    @pulumi.getter(name="registrationTokenOperation")
    def registration_token_operation(self) -> Optional[str]:
        """
        The type of resetting the token.
        """
        return pulumi.get(self, "registration_token_operation")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The registration token base64 encoded string.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ResourceModelWithAllowedPropertySetResponseIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceModelWithAllowedPropertySetResponseIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceModelWithAllowedPropertySetResponseIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceModelWithAllowedPropertySetResponseIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None):
        """
        :param str principal_id: The principal ID of resource identity.
        :param str tenant_id: The tenant ID of resource.
        :param str type: The identity type.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResourceModelWithAllowedPropertySetResponsePlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "promotionCode":
            suggest = "promotion_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceModelWithAllowedPropertySetResponsePlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceModelWithAllowedPropertySetResponsePlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceModelWithAllowedPropertySetResponsePlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 product: str,
                 publisher: str,
                 promotion_code: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str name: A user defined name of the 3rd Party Artifact that is being procured.
        :param str product: The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        :param str publisher: The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        :param str promotion_code: A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        :param str version: The version of the desired product/artifact.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "publisher", publisher)
        if promotion_code is not None:
            pulumi.set(__self__, "promotion_code", promotion_code)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A user defined name of the 3rd Party Artifact that is being procured.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def product(self) -> str:
        """
        The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding. 
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter(name="promotionCode")
    def promotion_code(self) -> Optional[str]:
        """
        A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
        """
        return pulumi.get(self, "promotion_code")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The version of the desired product/artifact.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ResourceModelWithAllowedPropertySetResponseSku(dict):
    def __init__(__self__, *,
                 name: str,
                 capacity: Optional[int] = None,
                 family: Optional[str] = None,
                 size: Optional[str] = None,
                 tier: Optional[str] = None):
        """
        :param str name: The name of the SKU. Ex - P3. It is typically a letter+number code
        :param int capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        :param str family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
        :param str size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        :param str tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        pulumi.set(__self__, "name", name)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the SKU. Ex - P3. It is typically a letter+number code
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def capacity(self) -> Optional[int]:
        """
        If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        """
        If the service has different generations of hardware, for the same SKU, then that can be captured here.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. 
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class ScalingHostPoolReferenceResponse(dict):
    """
    Scaling plan reference to hostpool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostPoolArmPath":
            suggest = "host_pool_arm_path"
        elif key == "scalingPlanEnabled":
            suggest = "scaling_plan_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingHostPoolReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingHostPoolReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingHostPoolReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_pool_arm_path: Optional[str] = None,
                 scaling_plan_enabled: Optional[bool] = None):
        """
        Scaling plan reference to hostpool.
        :param str host_pool_arm_path: Arm path of referenced hostpool.
        :param bool scaling_plan_enabled: Is the scaling plan enabled for this hostpool.
        """
        if host_pool_arm_path is not None:
            pulumi.set(__self__, "host_pool_arm_path", host_pool_arm_path)
        if scaling_plan_enabled is not None:
            pulumi.set(__self__, "scaling_plan_enabled", scaling_plan_enabled)

    @property
    @pulumi.getter(name="hostPoolArmPath")
    def host_pool_arm_path(self) -> Optional[str]:
        """
        Arm path of referenced hostpool.
        """
        return pulumi.get(self, "host_pool_arm_path")

    @property
    @pulumi.getter(name="scalingPlanEnabled")
    def scaling_plan_enabled(self) -> Optional[bool]:
        """
        Is the scaling plan enabled for this hostpool.
        """
        return pulumi.get(self, "scaling_plan_enabled")


@pulumi.output_type
class ScalingPlanPooledSchedulePropertiesResponse(dict):
    """
    A ScalingPlanPooledSchedule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeek":
            suggest = "days_of_week"
        elif key == "offPeakLoadBalancingAlgorithm":
            suggest = "off_peak_load_balancing_algorithm"
        elif key == "offPeakStartTime":
            suggest = "off_peak_start_time"
        elif key == "peakLoadBalancingAlgorithm":
            suggest = "peak_load_balancing_algorithm"
        elif key == "peakStartTime":
            suggest = "peak_start_time"
        elif key == "rampDownCapacityThresholdPct":
            suggest = "ramp_down_capacity_threshold_pct"
        elif key == "rampDownForceLogoffUsers":
            suggest = "ramp_down_force_logoff_users"
        elif key == "rampDownLoadBalancingAlgorithm":
            suggest = "ramp_down_load_balancing_algorithm"
        elif key == "rampDownMinimumHostsPct":
            suggest = "ramp_down_minimum_hosts_pct"
        elif key == "rampDownNotificationMessage":
            suggest = "ramp_down_notification_message"
        elif key == "rampDownStartTime":
            suggest = "ramp_down_start_time"
        elif key == "rampDownStopHostsWhen":
            suggest = "ramp_down_stop_hosts_when"
        elif key == "rampDownWaitTimeMinutes":
            suggest = "ramp_down_wait_time_minutes"
        elif key == "rampUpCapacityThresholdPct":
            suggest = "ramp_up_capacity_threshold_pct"
        elif key == "rampUpLoadBalancingAlgorithm":
            suggest = "ramp_up_load_balancing_algorithm"
        elif key == "rampUpMinimumHostsPct":
            suggest = "ramp_up_minimum_hosts_pct"
        elif key == "rampUpStartTime":
            suggest = "ramp_up_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPlanPooledSchedulePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPlanPooledSchedulePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPlanPooledSchedulePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_week: Optional[Sequence[str]] = None,
                 off_peak_load_balancing_algorithm: Optional[str] = None,
                 off_peak_start_time: Optional['outputs.TimeResponse'] = None,
                 peak_load_balancing_algorithm: Optional[str] = None,
                 peak_start_time: Optional['outputs.TimeResponse'] = None,
                 ramp_down_capacity_threshold_pct: Optional[int] = None,
                 ramp_down_force_logoff_users: Optional[bool] = None,
                 ramp_down_load_balancing_algorithm: Optional[str] = None,
                 ramp_down_minimum_hosts_pct: Optional[int] = None,
                 ramp_down_notification_message: Optional[str] = None,
                 ramp_down_start_time: Optional['outputs.TimeResponse'] = None,
                 ramp_down_stop_hosts_when: Optional[str] = None,
                 ramp_down_wait_time_minutes: Optional[int] = None,
                 ramp_up_capacity_threshold_pct: Optional[int] = None,
                 ramp_up_load_balancing_algorithm: Optional[str] = None,
                 ramp_up_minimum_hosts_pct: Optional[int] = None,
                 ramp_up_start_time: Optional['outputs.TimeResponse'] = None):
        """
        A ScalingPlanPooledSchedule.
        :param Sequence[str] days_of_week: Set of days of the week on which this schedule is active.
        :param str off_peak_load_balancing_algorithm: Load balancing algorithm for off-peak period.
        :param 'TimeResponse' off_peak_start_time: Starting time for off-peak period.
        :param str peak_load_balancing_algorithm: Load balancing algorithm for peak period.
        :param 'TimeResponse' peak_start_time: Starting time for peak period.
        :param int ramp_down_capacity_threshold_pct: Capacity threshold for ramp down period.
        :param bool ramp_down_force_logoff_users: Should users be logged off forcefully from hosts.
        :param str ramp_down_load_balancing_algorithm: Load balancing algorithm for ramp down period.
        :param int ramp_down_minimum_hosts_pct: Minimum host percentage for ramp down period.
        :param str ramp_down_notification_message: Notification message for users during ramp down period.
        :param 'TimeResponse' ramp_down_start_time: Starting time for ramp down period.
        :param str ramp_down_stop_hosts_when: Specifies when to stop hosts during ramp down period.
        :param int ramp_down_wait_time_minutes: Number of minutes to wait to stop hosts during ramp down period.
        :param int ramp_up_capacity_threshold_pct: Capacity threshold for ramp up period.
        :param str ramp_up_load_balancing_algorithm: Load balancing algorithm for ramp up period.
        :param int ramp_up_minimum_hosts_pct: Minimum host percentage for ramp up period.
        :param 'TimeResponse' ramp_up_start_time: Starting time for ramp up period.
        """
        if days_of_week is not None:
            pulumi.set(__self__, "days_of_week", days_of_week)
        if off_peak_load_balancing_algorithm is not None:
            pulumi.set(__self__, "off_peak_load_balancing_algorithm", off_peak_load_balancing_algorithm)
        if off_peak_start_time is not None:
            pulumi.set(__self__, "off_peak_start_time", off_peak_start_time)
        if peak_load_balancing_algorithm is not None:
            pulumi.set(__self__, "peak_load_balancing_algorithm", peak_load_balancing_algorithm)
        if peak_start_time is not None:
            pulumi.set(__self__, "peak_start_time", peak_start_time)
        if ramp_down_capacity_threshold_pct is not None:
            pulumi.set(__self__, "ramp_down_capacity_threshold_pct", ramp_down_capacity_threshold_pct)
        if ramp_down_force_logoff_users is not None:
            pulumi.set(__self__, "ramp_down_force_logoff_users", ramp_down_force_logoff_users)
        if ramp_down_load_balancing_algorithm is not None:
            pulumi.set(__self__, "ramp_down_load_balancing_algorithm", ramp_down_load_balancing_algorithm)
        if ramp_down_minimum_hosts_pct is not None:
            pulumi.set(__self__, "ramp_down_minimum_hosts_pct", ramp_down_minimum_hosts_pct)
        if ramp_down_notification_message is not None:
            pulumi.set(__self__, "ramp_down_notification_message", ramp_down_notification_message)
        if ramp_down_start_time is not None:
            pulumi.set(__self__, "ramp_down_start_time", ramp_down_start_time)
        if ramp_down_stop_hosts_when is not None:
            pulumi.set(__self__, "ramp_down_stop_hosts_when", ramp_down_stop_hosts_when)
        if ramp_down_wait_time_minutes is not None:
            pulumi.set(__self__, "ramp_down_wait_time_minutes", ramp_down_wait_time_minutes)
        if ramp_up_capacity_threshold_pct is not None:
            pulumi.set(__self__, "ramp_up_capacity_threshold_pct", ramp_up_capacity_threshold_pct)
        if ramp_up_load_balancing_algorithm is not None:
            pulumi.set(__self__, "ramp_up_load_balancing_algorithm", ramp_up_load_balancing_algorithm)
        if ramp_up_minimum_hosts_pct is not None:
            pulumi.set(__self__, "ramp_up_minimum_hosts_pct", ramp_up_minimum_hosts_pct)
        if ramp_up_start_time is not None:
            pulumi.set(__self__, "ramp_up_start_time", ramp_up_start_time)

    @property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> Optional[Sequence[str]]:
        """
        Set of days of the week on which this schedule is active.
        """
        return pulumi.get(self, "days_of_week")

    @property
    @pulumi.getter(name="offPeakLoadBalancingAlgorithm")
    def off_peak_load_balancing_algorithm(self) -> Optional[str]:
        """
        Load balancing algorithm for off-peak period.
        """
        return pulumi.get(self, "off_peak_load_balancing_algorithm")

    @property
    @pulumi.getter(name="offPeakStartTime")
    def off_peak_start_time(self) -> Optional['outputs.TimeResponse']:
        """
        Starting time for off-peak period.
        """
        return pulumi.get(self, "off_peak_start_time")

    @property
    @pulumi.getter(name="peakLoadBalancingAlgorithm")
    def peak_load_balancing_algorithm(self) -> Optional[str]:
        """
        Load balancing algorithm for peak period.
        """
        return pulumi.get(self, "peak_load_balancing_algorithm")

    @property
    @pulumi.getter(name="peakStartTime")
    def peak_start_time(self) -> Optional['outputs.TimeResponse']:
        """
        Starting time for peak period.
        """
        return pulumi.get(self, "peak_start_time")

    @property
    @pulumi.getter(name="rampDownCapacityThresholdPct")
    def ramp_down_capacity_threshold_pct(self) -> Optional[int]:
        """
        Capacity threshold for ramp down period.
        """
        return pulumi.get(self, "ramp_down_capacity_threshold_pct")

    @property
    @pulumi.getter(name="rampDownForceLogoffUsers")
    def ramp_down_force_logoff_users(self) -> Optional[bool]:
        """
        Should users be logged off forcefully from hosts.
        """
        return pulumi.get(self, "ramp_down_force_logoff_users")

    @property
    @pulumi.getter(name="rampDownLoadBalancingAlgorithm")
    def ramp_down_load_balancing_algorithm(self) -> Optional[str]:
        """
        Load balancing algorithm for ramp down period.
        """
        return pulumi.get(self, "ramp_down_load_balancing_algorithm")

    @property
    @pulumi.getter(name="rampDownMinimumHostsPct")
    def ramp_down_minimum_hosts_pct(self) -> Optional[int]:
        """
        Minimum host percentage for ramp down period.
        """
        return pulumi.get(self, "ramp_down_minimum_hosts_pct")

    @property
    @pulumi.getter(name="rampDownNotificationMessage")
    def ramp_down_notification_message(self) -> Optional[str]:
        """
        Notification message for users during ramp down period.
        """
        return pulumi.get(self, "ramp_down_notification_message")

    @property
    @pulumi.getter(name="rampDownStartTime")
    def ramp_down_start_time(self) -> Optional['outputs.TimeResponse']:
        """
        Starting time for ramp down period.
        """
        return pulumi.get(self, "ramp_down_start_time")

    @property
    @pulumi.getter(name="rampDownStopHostsWhen")
    def ramp_down_stop_hosts_when(self) -> Optional[str]:
        """
        Specifies when to stop hosts during ramp down period.
        """
        return pulumi.get(self, "ramp_down_stop_hosts_when")

    @property
    @pulumi.getter(name="rampDownWaitTimeMinutes")
    def ramp_down_wait_time_minutes(self) -> Optional[int]:
        """
        Number of minutes to wait to stop hosts during ramp down period.
        """
        return pulumi.get(self, "ramp_down_wait_time_minutes")

    @property
    @pulumi.getter(name="rampUpCapacityThresholdPct")
    def ramp_up_capacity_threshold_pct(self) -> Optional[int]:
        """
        Capacity threshold for ramp up period.
        """
        return pulumi.get(self, "ramp_up_capacity_threshold_pct")

    @property
    @pulumi.getter(name="rampUpLoadBalancingAlgorithm")
    def ramp_up_load_balancing_algorithm(self) -> Optional[str]:
        """
        Load balancing algorithm for ramp up period.
        """
        return pulumi.get(self, "ramp_up_load_balancing_algorithm")

    @property
    @pulumi.getter(name="rampUpMinimumHostsPct")
    def ramp_up_minimum_hosts_pct(self) -> Optional[int]:
        """
        Minimum host percentage for ramp up period.
        """
        return pulumi.get(self, "ramp_up_minimum_hosts_pct")

    @property
    @pulumi.getter(name="rampUpStartTime")
    def ramp_up_start_time(self) -> Optional['outputs.TimeResponse']:
        """
        Starting time for ramp up period.
        """
        return pulumi.get(self, "ramp_up_start_time")


@pulumi.output_type
class ScalingPlanPropertiesResponse(dict):
    """
    Scaling plan properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectId":
            suggest = "object_id"
        elif key == "timeZone":
            suggest = "time_zone"
        elif key == "exclusionTag":
            suggest = "exclusion_tag"
        elif key == "friendlyName":
            suggest = "friendly_name"
        elif key == "hostPoolReferences":
            suggest = "host_pool_references"
        elif key == "hostPoolType":
            suggest = "host_pool_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPlanPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPlanPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPlanPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_id: str,
                 time_zone: str,
                 description: Optional[str] = None,
                 exclusion_tag: Optional[str] = None,
                 friendly_name: Optional[str] = None,
                 host_pool_references: Optional[Sequence['outputs.ScalingHostPoolReferenceResponse']] = None,
                 host_pool_type: Optional[str] = None,
                 schedules: Optional[Sequence['outputs.ScalingScheduleResponse']] = None):
        """
        Scaling plan properties.
        :param str object_id: ObjectId of scaling plan. (internal use)
        :param str time_zone: Timezone of the scaling plan.
        :param str description: Description of scaling plan.
        :param str exclusion_tag: Exclusion tag for scaling plan.
        :param str friendly_name: User friendly name of scaling plan.
        :param Sequence['ScalingHostPoolReferenceResponse'] host_pool_references: List of ScalingHostPoolReference definitions.
        :param str host_pool_type: HostPool type for desktop.
        :param Sequence['ScalingScheduleResponse'] schedules: List of ScalingPlanPooledSchedule definitions.
        """
        pulumi.set(__self__, "object_id", object_id)
        pulumi.set(__self__, "time_zone", time_zone)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exclusion_tag is not None:
            pulumi.set(__self__, "exclusion_tag", exclusion_tag)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if host_pool_references is not None:
            pulumi.set(__self__, "host_pool_references", host_pool_references)
        if host_pool_type is None:
            host_pool_type = 'Pooled'
        if host_pool_type is not None:
            pulumi.set(__self__, "host_pool_type", host_pool_type)
        if schedules is not None:
            pulumi.set(__self__, "schedules", schedules)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> str:
        """
        ObjectId of scaling plan. (internal use)
        """
        return pulumi.get(self, "object_id")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        Timezone of the scaling plan.
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of scaling plan.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="exclusionTag")
    def exclusion_tag(self) -> Optional[str]:
        """
        Exclusion tag for scaling plan.
        """
        return pulumi.get(self, "exclusion_tag")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[str]:
        """
        User friendly name of scaling plan.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter(name="hostPoolReferences")
    def host_pool_references(self) -> Optional[Sequence['outputs.ScalingHostPoolReferenceResponse']]:
        """
        List of ScalingHostPoolReference definitions.
        """
        return pulumi.get(self, "host_pool_references")

    @property
    @pulumi.getter(name="hostPoolType")
    def host_pool_type(self) -> Optional[str]:
        """
        HostPool type for desktop.
        """
        return pulumi.get(self, "host_pool_type")

    @property
    @pulumi.getter
    def schedules(self) -> Optional[Sequence['outputs.ScalingScheduleResponse']]:
        """
        List of ScalingPlanPooledSchedule definitions.
        """
        return pulumi.get(self, "schedules")


@pulumi.output_type
class ScalingScheduleResponse(dict):
    """
    A ScalingPlanPooledSchedule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeek":
            suggest = "days_of_week"
        elif key == "offPeakLoadBalancingAlgorithm":
            suggest = "off_peak_load_balancing_algorithm"
        elif key == "offPeakStartTime":
            suggest = "off_peak_start_time"
        elif key == "peakLoadBalancingAlgorithm":
            suggest = "peak_load_balancing_algorithm"
        elif key == "peakStartTime":
            suggest = "peak_start_time"
        elif key == "rampDownCapacityThresholdPct":
            suggest = "ramp_down_capacity_threshold_pct"
        elif key == "rampDownForceLogoffUsers":
            suggest = "ramp_down_force_logoff_users"
        elif key == "rampDownLoadBalancingAlgorithm":
            suggest = "ramp_down_load_balancing_algorithm"
        elif key == "rampDownMinimumHostsPct":
            suggest = "ramp_down_minimum_hosts_pct"
        elif key == "rampDownNotificationMessage":
            suggest = "ramp_down_notification_message"
        elif key == "rampDownStartTime":
            suggest = "ramp_down_start_time"
        elif key == "rampDownStopHostsWhen":
            suggest = "ramp_down_stop_hosts_when"
        elif key == "rampDownWaitTimeMinutes":
            suggest = "ramp_down_wait_time_minutes"
        elif key == "rampUpCapacityThresholdPct":
            suggest = "ramp_up_capacity_threshold_pct"
        elif key == "rampUpLoadBalancingAlgorithm":
            suggest = "ramp_up_load_balancing_algorithm"
        elif key == "rampUpMinimumHostsPct":
            suggest = "ramp_up_minimum_hosts_pct"
        elif key == "rampUpStartTime":
            suggest = "ramp_up_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_week: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 off_peak_load_balancing_algorithm: Optional[str] = None,
                 off_peak_start_time: Optional['outputs.TimeResponse'] = None,
                 peak_load_balancing_algorithm: Optional[str] = None,
                 peak_start_time: Optional['outputs.TimeResponse'] = None,
                 ramp_down_capacity_threshold_pct: Optional[int] = None,
                 ramp_down_force_logoff_users: Optional[bool] = None,
                 ramp_down_load_balancing_algorithm: Optional[str] = None,
                 ramp_down_minimum_hosts_pct: Optional[int] = None,
                 ramp_down_notification_message: Optional[str] = None,
                 ramp_down_start_time: Optional['outputs.TimeResponse'] = None,
                 ramp_down_stop_hosts_when: Optional[str] = None,
                 ramp_down_wait_time_minutes: Optional[int] = None,
                 ramp_up_capacity_threshold_pct: Optional[int] = None,
                 ramp_up_load_balancing_algorithm: Optional[str] = None,
                 ramp_up_minimum_hosts_pct: Optional[int] = None,
                 ramp_up_start_time: Optional['outputs.TimeResponse'] = None):
        """
        A ScalingPlanPooledSchedule.
        :param Sequence[str] days_of_week: Set of days of the week on which this schedule is active.
        :param str name: Name of the ScalingPlanPooledSchedule.
        :param str off_peak_load_balancing_algorithm: Load balancing algorithm for off-peak period.
        :param 'TimeResponse' off_peak_start_time: Starting time for off-peak period.
        :param str peak_load_balancing_algorithm: Load balancing algorithm for peak period.
        :param 'TimeResponse' peak_start_time: Starting time for peak period.
        :param int ramp_down_capacity_threshold_pct: Capacity threshold for ramp down period.
        :param bool ramp_down_force_logoff_users: Should users be logged off forcefully from hosts.
        :param str ramp_down_load_balancing_algorithm: Load balancing algorithm for ramp down period.
        :param int ramp_down_minimum_hosts_pct: Minimum host percentage for ramp down period.
        :param str ramp_down_notification_message: Notification message for users during ramp down period.
        :param 'TimeResponse' ramp_down_start_time: Starting time for ramp down period.
        :param str ramp_down_stop_hosts_when: Specifies when to stop hosts during ramp down period.
        :param int ramp_down_wait_time_minutes: Number of minutes to wait to stop hosts during ramp down period.
        :param int ramp_up_capacity_threshold_pct: Capacity threshold for ramp up period.
        :param str ramp_up_load_balancing_algorithm: Load balancing algorithm for ramp up period.
        :param int ramp_up_minimum_hosts_pct: Minimum host percentage for ramp up period.
        :param 'TimeResponse' ramp_up_start_time: Starting time for ramp up period.
        """
        if days_of_week is not None:
            pulumi.set(__self__, "days_of_week", days_of_week)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if off_peak_load_balancing_algorithm is not None:
            pulumi.set(__self__, "off_peak_load_balancing_algorithm", off_peak_load_balancing_algorithm)
        if off_peak_start_time is not None:
            pulumi.set(__self__, "off_peak_start_time", off_peak_start_time)
        if peak_load_balancing_algorithm is not None:
            pulumi.set(__self__, "peak_load_balancing_algorithm", peak_load_balancing_algorithm)
        if peak_start_time is not None:
            pulumi.set(__self__, "peak_start_time", peak_start_time)
        if ramp_down_capacity_threshold_pct is not None:
            pulumi.set(__self__, "ramp_down_capacity_threshold_pct", ramp_down_capacity_threshold_pct)
        if ramp_down_force_logoff_users is not None:
            pulumi.set(__self__, "ramp_down_force_logoff_users", ramp_down_force_logoff_users)
        if ramp_down_load_balancing_algorithm is not None:
            pulumi.set(__self__, "ramp_down_load_balancing_algorithm", ramp_down_load_balancing_algorithm)
        if ramp_down_minimum_hosts_pct is not None:
            pulumi.set(__self__, "ramp_down_minimum_hosts_pct", ramp_down_minimum_hosts_pct)
        if ramp_down_notification_message is not None:
            pulumi.set(__self__, "ramp_down_notification_message", ramp_down_notification_message)
        if ramp_down_start_time is not None:
            pulumi.set(__self__, "ramp_down_start_time", ramp_down_start_time)
        if ramp_down_stop_hosts_when is not None:
            pulumi.set(__self__, "ramp_down_stop_hosts_when", ramp_down_stop_hosts_when)
        if ramp_down_wait_time_minutes is not None:
            pulumi.set(__self__, "ramp_down_wait_time_minutes", ramp_down_wait_time_minutes)
        if ramp_up_capacity_threshold_pct is not None:
            pulumi.set(__self__, "ramp_up_capacity_threshold_pct", ramp_up_capacity_threshold_pct)
        if ramp_up_load_balancing_algorithm is not None:
            pulumi.set(__self__, "ramp_up_load_balancing_algorithm", ramp_up_load_balancing_algorithm)
        if ramp_up_minimum_hosts_pct is not None:
            pulumi.set(__self__, "ramp_up_minimum_hosts_pct", ramp_up_minimum_hosts_pct)
        if ramp_up_start_time is not None:
            pulumi.set(__self__, "ramp_up_start_time", ramp_up_start_time)

    @property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> Optional[Sequence[str]]:
        """
        Set of days of the week on which this schedule is active.
        """
        return pulumi.get(self, "days_of_week")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the ScalingPlanPooledSchedule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="offPeakLoadBalancingAlgorithm")
    def off_peak_load_balancing_algorithm(self) -> Optional[str]:
        """
        Load balancing algorithm for off-peak period.
        """
        return pulumi.get(self, "off_peak_load_balancing_algorithm")

    @property
    @pulumi.getter(name="offPeakStartTime")
    def off_peak_start_time(self) -> Optional['outputs.TimeResponse']:
        """
        Starting time for off-peak period.
        """
        return pulumi.get(self, "off_peak_start_time")

    @property
    @pulumi.getter(name="peakLoadBalancingAlgorithm")
    def peak_load_balancing_algorithm(self) -> Optional[str]:
        """
        Load balancing algorithm for peak period.
        """
        return pulumi.get(self, "peak_load_balancing_algorithm")

    @property
    @pulumi.getter(name="peakStartTime")
    def peak_start_time(self) -> Optional['outputs.TimeResponse']:
        """
        Starting time for peak period.
        """
        return pulumi.get(self, "peak_start_time")

    @property
    @pulumi.getter(name="rampDownCapacityThresholdPct")
    def ramp_down_capacity_threshold_pct(self) -> Optional[int]:
        """
        Capacity threshold for ramp down period.
        """
        return pulumi.get(self, "ramp_down_capacity_threshold_pct")

    @property
    @pulumi.getter(name="rampDownForceLogoffUsers")
    def ramp_down_force_logoff_users(self) -> Optional[bool]:
        """
        Should users be logged off forcefully from hosts.
        """
        return pulumi.get(self, "ramp_down_force_logoff_users")

    @property
    @pulumi.getter(name="rampDownLoadBalancingAlgorithm")
    def ramp_down_load_balancing_algorithm(self) -> Optional[str]:
        """
        Load balancing algorithm for ramp down period.
        """
        return pulumi.get(self, "ramp_down_load_balancing_algorithm")

    @property
    @pulumi.getter(name="rampDownMinimumHostsPct")
    def ramp_down_minimum_hosts_pct(self) -> Optional[int]:
        """
        Minimum host percentage for ramp down period.
        """
        return pulumi.get(self, "ramp_down_minimum_hosts_pct")

    @property
    @pulumi.getter(name="rampDownNotificationMessage")
    def ramp_down_notification_message(self) -> Optional[str]:
        """
        Notification message for users during ramp down period.
        """
        return pulumi.get(self, "ramp_down_notification_message")

    @property
    @pulumi.getter(name="rampDownStartTime")
    def ramp_down_start_time(self) -> Optional['outputs.TimeResponse']:
        """
        Starting time for ramp down period.
        """
        return pulumi.get(self, "ramp_down_start_time")

    @property
    @pulumi.getter(name="rampDownStopHostsWhen")
    def ramp_down_stop_hosts_when(self) -> Optional[str]:
        """
        Specifies when to stop hosts during ramp down period.
        """
        return pulumi.get(self, "ramp_down_stop_hosts_when")

    @property
    @pulumi.getter(name="rampDownWaitTimeMinutes")
    def ramp_down_wait_time_minutes(self) -> Optional[int]:
        """
        Number of minutes to wait to stop hosts during ramp down period.
        """
        return pulumi.get(self, "ramp_down_wait_time_minutes")

    @property
    @pulumi.getter(name="rampUpCapacityThresholdPct")
    def ramp_up_capacity_threshold_pct(self) -> Optional[int]:
        """
        Capacity threshold for ramp up period.
        """
        return pulumi.get(self, "ramp_up_capacity_threshold_pct")

    @property
    @pulumi.getter(name="rampUpLoadBalancingAlgorithm")
    def ramp_up_load_balancing_algorithm(self) -> Optional[str]:
        """
        Load balancing algorithm for ramp up period.
        """
        return pulumi.get(self, "ramp_up_load_balancing_algorithm")

    @property
    @pulumi.getter(name="rampUpMinimumHostsPct")
    def ramp_up_minimum_hosts_pct(self) -> Optional[int]:
        """
        Minimum host percentage for ramp up period.
        """
        return pulumi.get(self, "ramp_up_minimum_hosts_pct")

    @property
    @pulumi.getter(name="rampUpStartTime")
    def ramp_up_start_time(self) -> Optional['outputs.TimeResponse']:
        """
        Starting time for ramp up period.
        """
        return pulumi.get(self, "ramp_up_start_time")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TimeResponse(dict):
    """
    The time for a scaling action to occur.
    """
    def __init__(__self__, *,
                 hour: int,
                 minute: int):
        """
        The time for a scaling action to occur.
        :param int hour: The hour.
        :param int minute: The minute.
        """
        pulumi.set(__self__, "hour", hour)
        pulumi.set(__self__, "minute", minute)

    @property
    @pulumi.getter
    def hour(self) -> int:
        """
        The hour.
        """
        return pulumi.get(self, "hour")

    @property
    @pulumi.getter
    def minute(self) -> int:
        """
        The minute.
        """
        return pulumi.get(self, "minute")


