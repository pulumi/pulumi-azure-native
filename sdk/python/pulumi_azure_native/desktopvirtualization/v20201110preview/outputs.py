# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ApplicationGroupPropertiesResponse',
    'ApplicationPropertiesResponse',
    'HostPoolPropertiesResponse',
    'MSIXPackagePropertiesResponse',
    'MsixPackageApplicationsResponse',
    'MsixPackageDependenciesResponse',
    'RegistrationInfoResponse',
    'ScalingHostPoolReferenceResponse',
    'ScalingScheduleResponse',
]

@pulumi.output_type
class ApplicationGroupPropertiesResponse(dict):
    """
    Schema for ApplicationGroup properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationGroupType":
            suggest = "application_group_type"
        elif key == "hostPoolArmPath":
            suggest = "host_pool_arm_path"
        elif key == "workspaceArmPath":
            suggest = "workspace_arm_path"
        elif key == "friendlyName":
            suggest = "friendly_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationGroupPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationGroupPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationGroupPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_group_type: str,
                 host_pool_arm_path: str,
                 workspace_arm_path: str,
                 description: Optional[str] = None,
                 friendly_name: Optional[str] = None):
        """
        Schema for ApplicationGroup properties.
        :param str application_group_type: Resource Type of ApplicationGroup.
        :param str host_pool_arm_path: HostPool arm path of ApplicationGroup.
        :param str workspace_arm_path: Workspace arm path of ApplicationGroup.
        :param str description: Description of ApplicationGroup.
        :param str friendly_name: Friendly name of ApplicationGroup.
        """
        pulumi.set(__self__, "application_group_type", application_group_type)
        pulumi.set(__self__, "host_pool_arm_path", host_pool_arm_path)
        pulumi.set(__self__, "workspace_arm_path", workspace_arm_path)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)

    @property
    @pulumi.getter(name="applicationGroupType")
    def application_group_type(self) -> str:
        """
        Resource Type of ApplicationGroup.
        """
        return pulumi.get(self, "application_group_type")

    @property
    @pulumi.getter(name="hostPoolArmPath")
    def host_pool_arm_path(self) -> str:
        """
        HostPool arm path of ApplicationGroup.
        """
        return pulumi.get(self, "host_pool_arm_path")

    @property
    @pulumi.getter(name="workspaceArmPath")
    def workspace_arm_path(self) -> str:
        """
        Workspace arm path of ApplicationGroup.
        """
        return pulumi.get(self, "workspace_arm_path")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of ApplicationGroup.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[str]:
        """
        Friendly name of ApplicationGroup.
        """
        return pulumi.get(self, "friendly_name")


@pulumi.output_type
class ApplicationPropertiesResponse(dict):
    """
    Schema for Application properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandLineSetting":
            suggest = "command_line_setting"
        elif key == "iconContent":
            suggest = "icon_content"
        elif key == "iconHash":
            suggest = "icon_hash"
        elif key == "applicationType":
            suggest = "application_type"
        elif key == "commandLineArguments":
            suggest = "command_line_arguments"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "friendlyName":
            suggest = "friendly_name"
        elif key == "iconIndex":
            suggest = "icon_index"
        elif key == "iconPath":
            suggest = "icon_path"
        elif key == "msixPackageApplicationId":
            suggest = "msix_package_application_id"
        elif key == "msixPackageFamilyName":
            suggest = "msix_package_family_name"
        elif key == "showInPortal":
            suggest = "show_in_portal"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_line_setting: str,
                 icon_content: str,
                 icon_hash: str,
                 application_type: Optional[str] = None,
                 command_line_arguments: Optional[str] = None,
                 description: Optional[str] = None,
                 file_path: Optional[str] = None,
                 friendly_name: Optional[str] = None,
                 icon_index: Optional[int] = None,
                 icon_path: Optional[str] = None,
                 msix_package_application_id: Optional[str] = None,
                 msix_package_family_name: Optional[str] = None,
                 show_in_portal: Optional[bool] = None):
        """
        Schema for Application properties.
        :param str command_line_setting: Specifies whether this published application can be launched with command line arguments provided by the client, command line arguments specified at publish time, or no command line arguments at all.
        :param str icon_content: the icon a 64 bit string as a byte array.
        :param str icon_hash: Hash of the icon.
        :param str application_type: Resource Type of Application.
        :param str command_line_arguments: Command Line Arguments for Application.
        :param str description: Description of Application.
        :param str file_path: Specifies a path for the executable file for the application.
        :param str friendly_name: Friendly name of Application.
        :param int icon_index: Index of the icon.
        :param str icon_path: Path to icon.
        :param str msix_package_application_id: Specifies the package application Id for MSIX applications
        :param str msix_package_family_name: Specifies the package family name for MSIX applications
        :param bool show_in_portal: Specifies whether to show the RemoteApp program in the RD Web Access server.
        """
        pulumi.set(__self__, "command_line_setting", command_line_setting)
        pulumi.set(__self__, "icon_content", icon_content)
        pulumi.set(__self__, "icon_hash", icon_hash)
        if application_type is not None:
            pulumi.set(__self__, "application_type", application_type)
        if command_line_arguments is not None:
            pulumi.set(__self__, "command_line_arguments", command_line_arguments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if icon_index is not None:
            pulumi.set(__self__, "icon_index", icon_index)
        if icon_path is not None:
            pulumi.set(__self__, "icon_path", icon_path)
        if msix_package_application_id is not None:
            pulumi.set(__self__, "msix_package_application_id", msix_package_application_id)
        if msix_package_family_name is not None:
            pulumi.set(__self__, "msix_package_family_name", msix_package_family_name)
        if show_in_portal is not None:
            pulumi.set(__self__, "show_in_portal", show_in_portal)

    @property
    @pulumi.getter(name="commandLineSetting")
    def command_line_setting(self) -> str:
        """
        Specifies whether this published application can be launched with command line arguments provided by the client, command line arguments specified at publish time, or no command line arguments at all.
        """
        return pulumi.get(self, "command_line_setting")

    @property
    @pulumi.getter(name="iconContent")
    def icon_content(self) -> str:
        """
        the icon a 64 bit string as a byte array.
        """
        return pulumi.get(self, "icon_content")

    @property
    @pulumi.getter(name="iconHash")
    def icon_hash(self) -> str:
        """
        Hash of the icon.
        """
        return pulumi.get(self, "icon_hash")

    @property
    @pulumi.getter(name="applicationType")
    def application_type(self) -> Optional[str]:
        """
        Resource Type of Application.
        """
        return pulumi.get(self, "application_type")

    @property
    @pulumi.getter(name="commandLineArguments")
    def command_line_arguments(self) -> Optional[str]:
        """
        Command Line Arguments for Application.
        """
        return pulumi.get(self, "command_line_arguments")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of Application.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        Specifies a path for the executable file for the application.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[str]:
        """
        Friendly name of Application.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter(name="iconIndex")
    def icon_index(self) -> Optional[int]:
        """
        Index of the icon.
        """
        return pulumi.get(self, "icon_index")

    @property
    @pulumi.getter(name="iconPath")
    def icon_path(self) -> Optional[str]:
        """
        Path to icon.
        """
        return pulumi.get(self, "icon_path")

    @property
    @pulumi.getter(name="msixPackageApplicationId")
    def msix_package_application_id(self) -> Optional[str]:
        """
        Specifies the package application Id for MSIX applications
        """
        return pulumi.get(self, "msix_package_application_id")

    @property
    @pulumi.getter(name="msixPackageFamilyName")
    def msix_package_family_name(self) -> Optional[str]:
        """
        Specifies the package family name for MSIX applications
        """
        return pulumi.get(self, "msix_package_family_name")

    @property
    @pulumi.getter(name="showInPortal")
    def show_in_portal(self) -> Optional[bool]:
        """
        Specifies whether to show the RemoteApp program in the RD Web Access server.
        """
        return pulumi.get(self, "show_in_portal")


@pulumi.output_type
class HostPoolPropertiesResponse(dict):
    """
    Properties of HostPool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationGroupReferences":
            suggest = "application_group_references"
        elif key == "hostPoolType":
            suggest = "host_pool_type"
        elif key == "loadBalancerType":
            suggest = "load_balancer_type"
        elif key == "preferredAppGroupType":
            suggest = "preferred_app_group_type"
        elif key == "customRdpProperty":
            suggest = "custom_rdp_property"
        elif key == "friendlyName":
            suggest = "friendly_name"
        elif key == "maxSessionLimit":
            suggest = "max_session_limit"
        elif key == "personalDesktopAssignmentType":
            suggest = "personal_desktop_assignment_type"
        elif key == "registrationInfo":
            suggest = "registration_info"
        elif key == "ssoClientId":
            suggest = "sso_client_id"
        elif key == "ssoClientSecretKeyVaultPath":
            suggest = "sso_client_secret_key_vault_path"
        elif key == "ssoSecretType":
            suggest = "sso_secret_type"
        elif key == "ssoadfsAuthority":
            suggest = "ssoadfs_authority"
        elif key == "startVMOnConnect":
            suggest = "start_vm_on_connect"
        elif key == "validationEnvironment":
            suggest = "validation_environment"
        elif key == "vmTemplate":
            suggest = "vm_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostPoolPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostPoolPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostPoolPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_group_references: Sequence[str],
                 host_pool_type: str,
                 load_balancer_type: str,
                 preferred_app_group_type: str,
                 custom_rdp_property: Optional[str] = None,
                 description: Optional[str] = None,
                 friendly_name: Optional[str] = None,
                 max_session_limit: Optional[int] = None,
                 personal_desktop_assignment_type: Optional[str] = None,
                 registration_info: Optional['outputs.RegistrationInfoResponse'] = None,
                 ring: Optional[int] = None,
                 sso_client_id: Optional[str] = None,
                 sso_client_secret_key_vault_path: Optional[str] = None,
                 sso_secret_type: Optional[str] = None,
                 ssoadfs_authority: Optional[str] = None,
                 start_vm_on_connect: Optional[bool] = None,
                 validation_environment: Optional[bool] = None,
                 vm_template: Optional[str] = None):
        """
        Properties of HostPool.
        :param Sequence[str] application_group_references: List of applicationGroup links.
        :param str host_pool_type: HostPool type for desktop.
        :param str load_balancer_type: The type of the load balancer.
        :param str preferred_app_group_type: The type of preferred application group type, default to Desktop Application Group
        :param str custom_rdp_property: Custom rdp property of HostPool.
        :param str description: Description of HostPool.
        :param str friendly_name: Friendly name of HostPool.
        :param int max_session_limit: The max session limit of HostPool.
        :param str personal_desktop_assignment_type: PersonalDesktopAssignment type for HostPool.
        :param 'RegistrationInfoResponse' registration_info: The registration info of HostPool.
        :param int ring: The ring number of HostPool.
        :param str sso_client_id: ClientId for the registered Relying Party used to issue WVD SSO certificates.
        :param str sso_client_secret_key_vault_path: Path to Azure KeyVault storing the secret used for communication to ADFS.
        :param str sso_secret_type: The type of single sign on Secret Type.
        :param str ssoadfs_authority: URL to customer ADFS server for signing WVD SSO certificates.
        :param bool start_vm_on_connect: The flag to turn on/off StartVMOnConnect feature.
        :param bool validation_environment: Is validation environment.
        :param str vm_template: VM template for sessionhosts configuration within hostpool.
        """
        pulumi.set(__self__, "application_group_references", application_group_references)
        pulumi.set(__self__, "host_pool_type", host_pool_type)
        pulumi.set(__self__, "load_balancer_type", load_balancer_type)
        pulumi.set(__self__, "preferred_app_group_type", preferred_app_group_type)
        if custom_rdp_property is not None:
            pulumi.set(__self__, "custom_rdp_property", custom_rdp_property)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if max_session_limit is not None:
            pulumi.set(__self__, "max_session_limit", max_session_limit)
        if personal_desktop_assignment_type is not None:
            pulumi.set(__self__, "personal_desktop_assignment_type", personal_desktop_assignment_type)
        if registration_info is not None:
            pulumi.set(__self__, "registration_info", registration_info)
        if ring is not None:
            pulumi.set(__self__, "ring", ring)
        if sso_client_id is not None:
            pulumi.set(__self__, "sso_client_id", sso_client_id)
        if sso_client_secret_key_vault_path is not None:
            pulumi.set(__self__, "sso_client_secret_key_vault_path", sso_client_secret_key_vault_path)
        if sso_secret_type is not None:
            pulumi.set(__self__, "sso_secret_type", sso_secret_type)
        if ssoadfs_authority is not None:
            pulumi.set(__self__, "ssoadfs_authority", ssoadfs_authority)
        if start_vm_on_connect is not None:
            pulumi.set(__self__, "start_vm_on_connect", start_vm_on_connect)
        if validation_environment is not None:
            pulumi.set(__self__, "validation_environment", validation_environment)
        if vm_template is not None:
            pulumi.set(__self__, "vm_template", vm_template)

    @property
    @pulumi.getter(name="applicationGroupReferences")
    def application_group_references(self) -> Sequence[str]:
        """
        List of applicationGroup links.
        """
        return pulumi.get(self, "application_group_references")

    @property
    @pulumi.getter(name="hostPoolType")
    def host_pool_type(self) -> str:
        """
        HostPool type for desktop.
        """
        return pulumi.get(self, "host_pool_type")

    @property
    @pulumi.getter(name="loadBalancerType")
    def load_balancer_type(self) -> str:
        """
        The type of the load balancer.
        """
        return pulumi.get(self, "load_balancer_type")

    @property
    @pulumi.getter(name="preferredAppGroupType")
    def preferred_app_group_type(self) -> str:
        """
        The type of preferred application group type, default to Desktop Application Group
        """
        return pulumi.get(self, "preferred_app_group_type")

    @property
    @pulumi.getter(name="customRdpProperty")
    def custom_rdp_property(self) -> Optional[str]:
        """
        Custom rdp property of HostPool.
        """
        return pulumi.get(self, "custom_rdp_property")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of HostPool.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[str]:
        """
        Friendly name of HostPool.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter(name="maxSessionLimit")
    def max_session_limit(self) -> Optional[int]:
        """
        The max session limit of HostPool.
        """
        return pulumi.get(self, "max_session_limit")

    @property
    @pulumi.getter(name="personalDesktopAssignmentType")
    def personal_desktop_assignment_type(self) -> Optional[str]:
        """
        PersonalDesktopAssignment type for HostPool.
        """
        return pulumi.get(self, "personal_desktop_assignment_type")

    @property
    @pulumi.getter(name="registrationInfo")
    def registration_info(self) -> Optional['outputs.RegistrationInfoResponse']:
        """
        The registration info of HostPool.
        """
        return pulumi.get(self, "registration_info")

    @property
    @pulumi.getter
    def ring(self) -> Optional[int]:
        """
        The ring number of HostPool.
        """
        return pulumi.get(self, "ring")

    @property
    @pulumi.getter(name="ssoClientId")
    def sso_client_id(self) -> Optional[str]:
        """
        ClientId for the registered Relying Party used to issue WVD SSO certificates.
        """
        return pulumi.get(self, "sso_client_id")

    @property
    @pulumi.getter(name="ssoClientSecretKeyVaultPath")
    def sso_client_secret_key_vault_path(self) -> Optional[str]:
        """
        Path to Azure KeyVault storing the secret used for communication to ADFS.
        """
        return pulumi.get(self, "sso_client_secret_key_vault_path")

    @property
    @pulumi.getter(name="ssoSecretType")
    def sso_secret_type(self) -> Optional[str]:
        """
        The type of single sign on Secret Type.
        """
        return pulumi.get(self, "sso_secret_type")

    @property
    @pulumi.getter(name="ssoadfsAuthority")
    def ssoadfs_authority(self) -> Optional[str]:
        """
        URL to customer ADFS server for signing WVD SSO certificates.
        """
        return pulumi.get(self, "ssoadfs_authority")

    @property
    @pulumi.getter(name="startVMOnConnect")
    def start_vm_on_connect(self) -> Optional[bool]:
        """
        The flag to turn on/off StartVMOnConnect feature.
        """
        return pulumi.get(self, "start_vm_on_connect")

    @property
    @pulumi.getter(name="validationEnvironment")
    def validation_environment(self) -> Optional[bool]:
        """
        Is validation environment.
        """
        return pulumi.get(self, "validation_environment")

    @property
    @pulumi.getter(name="vmTemplate")
    def vm_template(self) -> Optional[str]:
        """
        VM template for sessionhosts configuration within hostpool.
        """
        return pulumi.get(self, "vm_template")


@pulumi.output_type
class MSIXPackagePropertiesResponse(dict):
    """
    Schema for MSIX Package properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "imagePath":
            suggest = "image_path"
        elif key == "isActive":
            suggest = "is_active"
        elif key == "isRegularRegistration":
            suggest = "is_regular_registration"
        elif key == "lastUpdated":
            suggest = "last_updated"
        elif key == "packageApplications":
            suggest = "package_applications"
        elif key == "packageDependencies":
            suggest = "package_dependencies"
        elif key == "packageFamilyName":
            suggest = "package_family_name"
        elif key == "packageName":
            suggest = "package_name"
        elif key == "packageRelativePath":
            suggest = "package_relative_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MSIXPackagePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MSIXPackagePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MSIXPackagePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[str] = None,
                 image_path: Optional[str] = None,
                 is_active: Optional[bool] = None,
                 is_regular_registration: Optional[bool] = None,
                 last_updated: Optional[str] = None,
                 package_applications: Optional[Sequence['outputs.MsixPackageApplicationsResponse']] = None,
                 package_dependencies: Optional[Sequence['outputs.MsixPackageDependenciesResponse']] = None,
                 package_family_name: Optional[str] = None,
                 package_name: Optional[str] = None,
                 package_relative_path: Optional[str] = None,
                 version: Optional[str] = None):
        """
        Schema for MSIX Package properties.
        :param str display_name: User friendly Name to be displayed in the portal. 
        :param str image_path: VHD/CIM image path on Network Share.
        :param bool is_active: Make this version of the package the active one across the hostpool. 
        :param bool is_regular_registration: Specifies how to register Package in feed.
        :param str last_updated: Date Package was last updated, found in the appxmanifest.xml. 
        :param Sequence['MsixPackageApplicationsResponse'] package_applications: List of package applications. 
        :param Sequence['MsixPackageDependenciesResponse'] package_dependencies: List of package dependencies. 
        :param str package_family_name: Package Family Name from appxmanifest.xml. Contains Package Name and Publisher name. 
        :param str package_name: Package Name from appxmanifest.xml. 
        :param str package_relative_path: Relative Path to the package inside the image. 
        :param str version: Package Version found in the appxmanifest.xml. 
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if image_path is not None:
            pulumi.set(__self__, "image_path", image_path)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if is_regular_registration is not None:
            pulumi.set(__self__, "is_regular_registration", is_regular_registration)
        if last_updated is not None:
            pulumi.set(__self__, "last_updated", last_updated)
        if package_applications is not None:
            pulumi.set(__self__, "package_applications", package_applications)
        if package_dependencies is not None:
            pulumi.set(__self__, "package_dependencies", package_dependencies)
        if package_family_name is not None:
            pulumi.set(__self__, "package_family_name", package_family_name)
        if package_name is not None:
            pulumi.set(__self__, "package_name", package_name)
        if package_relative_path is not None:
            pulumi.set(__self__, "package_relative_path", package_relative_path)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        """
        User friendly Name to be displayed in the portal. 
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="imagePath")
    def image_path(self) -> Optional[str]:
        """
        VHD/CIM image path on Network Share.
        """
        return pulumi.get(self, "image_path")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[bool]:
        """
        Make this version of the package the active one across the hostpool. 
        """
        return pulumi.get(self, "is_active")

    @property
    @pulumi.getter(name="isRegularRegistration")
    def is_regular_registration(self) -> Optional[bool]:
        """
        Specifies how to register Package in feed.
        """
        return pulumi.get(self, "is_regular_registration")

    @property
    @pulumi.getter(name="lastUpdated")
    def last_updated(self) -> Optional[str]:
        """
        Date Package was last updated, found in the appxmanifest.xml. 
        """
        return pulumi.get(self, "last_updated")

    @property
    @pulumi.getter(name="packageApplications")
    def package_applications(self) -> Optional[Sequence['outputs.MsixPackageApplicationsResponse']]:
        """
        List of package applications. 
        """
        return pulumi.get(self, "package_applications")

    @property
    @pulumi.getter(name="packageDependencies")
    def package_dependencies(self) -> Optional[Sequence['outputs.MsixPackageDependenciesResponse']]:
        """
        List of package dependencies. 
        """
        return pulumi.get(self, "package_dependencies")

    @property
    @pulumi.getter(name="packageFamilyName")
    def package_family_name(self) -> Optional[str]:
        """
        Package Family Name from appxmanifest.xml. Contains Package Name and Publisher name. 
        """
        return pulumi.get(self, "package_family_name")

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> Optional[str]:
        """
        Package Name from appxmanifest.xml. 
        """
        return pulumi.get(self, "package_name")

    @property
    @pulumi.getter(name="packageRelativePath")
    def package_relative_path(self) -> Optional[str]:
        """
        Relative Path to the package inside the image. 
        """
        return pulumi.get(self, "package_relative_path")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Package Version found in the appxmanifest.xml. 
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MsixPackageApplicationsResponse(dict):
    """
    Schema for MSIX Package Application properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appUserModelID":
            suggest = "app_user_model_id"
        elif key == "friendlyName":
            suggest = "friendly_name"
        elif key == "iconImageName":
            suggest = "icon_image_name"
        elif key == "rawIcon":
            suggest = "raw_icon"
        elif key == "rawPng":
            suggest = "raw_png"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MsixPackageApplicationsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MsixPackageApplicationsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MsixPackageApplicationsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[str] = None,
                 app_user_model_id: Optional[str] = None,
                 description: Optional[str] = None,
                 friendly_name: Optional[str] = None,
                 icon_image_name: Optional[str] = None,
                 raw_icon: Optional[str] = None,
                 raw_png: Optional[str] = None):
        """
        Schema for MSIX Package Application properties.
        :param str app_id: Package Application Id, found in appxmanifest.xml.
        :param str app_user_model_id: Used to activate Package Application. Consists of Package Name and ApplicationID. Found in appxmanifest.xml.
        :param str description: Description of Package Application.
        :param str friendly_name: User friendly name.
        :param str icon_image_name: User friendly name.
        :param str raw_icon: the icon a 64 bit string as a byte array.
        :param str raw_png: the icon a 64 bit string as a byte array.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_user_model_id is not None:
            pulumi.set(__self__, "app_user_model_id", app_user_model_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if friendly_name is not None:
            pulumi.set(__self__, "friendly_name", friendly_name)
        if icon_image_name is not None:
            pulumi.set(__self__, "icon_image_name", icon_image_name)
        if raw_icon is not None:
            pulumi.set(__self__, "raw_icon", raw_icon)
        if raw_png is not None:
            pulumi.set(__self__, "raw_png", raw_png)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[str]:
        """
        Package Application Id, found in appxmanifest.xml.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appUserModelID")
    def app_user_model_id(self) -> Optional[str]:
        """
        Used to activate Package Application. Consists of Package Name and ApplicationID. Found in appxmanifest.xml.
        """
        return pulumi.get(self, "app_user_model_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of Package Application.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="friendlyName")
    def friendly_name(self) -> Optional[str]:
        """
        User friendly name.
        """
        return pulumi.get(self, "friendly_name")

    @property
    @pulumi.getter(name="iconImageName")
    def icon_image_name(self) -> Optional[str]:
        """
        User friendly name.
        """
        return pulumi.get(self, "icon_image_name")

    @property
    @pulumi.getter(name="rawIcon")
    def raw_icon(self) -> Optional[str]:
        """
        the icon a 64 bit string as a byte array.
        """
        return pulumi.get(self, "raw_icon")

    @property
    @pulumi.getter(name="rawPng")
    def raw_png(self) -> Optional[str]:
        """
        the icon a 64 bit string as a byte array.
        """
        return pulumi.get(self, "raw_png")


@pulumi.output_type
class MsixPackageDependenciesResponse(dict):
    """
    Schema for MSIX Package Dependencies properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dependencyName":
            suggest = "dependency_name"
        elif key == "minVersion":
            suggest = "min_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MsixPackageDependenciesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MsixPackageDependenciesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MsixPackageDependenciesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dependency_name: Optional[str] = None,
                 min_version: Optional[str] = None,
                 publisher: Optional[str] = None):
        """
        Schema for MSIX Package Dependencies properties.
        :param str dependency_name: Name of package dependency.
        :param str min_version: Dependency version required.
        :param str publisher: Name of dependency publisher.
        """
        if dependency_name is not None:
            pulumi.set(__self__, "dependency_name", dependency_name)
        if min_version is not None:
            pulumi.set(__self__, "min_version", min_version)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)

    @property
    @pulumi.getter(name="dependencyName")
    def dependency_name(self) -> Optional[str]:
        """
        Name of package dependency.
        """
        return pulumi.get(self, "dependency_name")

    @property
    @pulumi.getter(name="minVersion")
    def min_version(self) -> Optional[str]:
        """
        Dependency version required.
        """
        return pulumi.get(self, "min_version")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        Name of dependency publisher.
        """
        return pulumi.get(self, "publisher")


@pulumi.output_type
class RegistrationInfoResponse(dict):
    """
    Represents a RegistrationInfo definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationTime":
            suggest = "expiration_time"
        elif key == "registrationTokenOperation":
            suggest = "registration_token_operation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistrationInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistrationInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistrationInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expiration_time: Optional[str] = None,
                 registration_token_operation: Optional[str] = None,
                 token: Optional[str] = None):
        """
        Represents a RegistrationInfo definition.
        :param str expiration_time: Expiration time of registration token.
        :param str registration_token_operation: The type of resetting the token.
        :param str token: The registration token base64 encoded string.
        """
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if registration_token_operation is not None:
            pulumi.set(__self__, "registration_token_operation", registration_token_operation)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[str]:
        """
        Expiration time of registration token.
        """
        return pulumi.get(self, "expiration_time")

    @property
    @pulumi.getter(name="registrationTokenOperation")
    def registration_token_operation(self) -> Optional[str]:
        """
        The type of resetting the token.
        """
        return pulumi.get(self, "registration_token_operation")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The registration token base64 encoded string.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ScalingHostPoolReferenceResponse(dict):
    """
    Scaling plan reference to hostpool.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostPoolArmPath":
            suggest = "host_pool_arm_path"
        elif key == "scalingPlanEnabled":
            suggest = "scaling_plan_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingHostPoolReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingHostPoolReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingHostPoolReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_pool_arm_path: Optional[str] = None,
                 scaling_plan_enabled: Optional[bool] = None):
        """
        Scaling plan reference to hostpool.
        :param str host_pool_arm_path: Arm path of referenced hostpool.
        :param bool scaling_plan_enabled: Is the scaling plan enabled for this hostpool.
        """
        if host_pool_arm_path is not None:
            pulumi.set(__self__, "host_pool_arm_path", host_pool_arm_path)
        if scaling_plan_enabled is not None:
            pulumi.set(__self__, "scaling_plan_enabled", scaling_plan_enabled)

    @property
    @pulumi.getter(name="hostPoolArmPath")
    def host_pool_arm_path(self) -> Optional[str]:
        """
        Arm path of referenced hostpool.
        """
        return pulumi.get(self, "host_pool_arm_path")

    @property
    @pulumi.getter(name="scalingPlanEnabled")
    def scaling_plan_enabled(self) -> Optional[bool]:
        """
        Is the scaling plan enabled for this hostpool.
        """
        return pulumi.get(self, "scaling_plan_enabled")


@pulumi.output_type
class ScalingScheduleResponse(dict):
    """
    Scaling plan schedule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeek":
            suggest = "days_of_week"
        elif key == "offPeakLoadBalancingAlgorithm":
            suggest = "off_peak_load_balancing_algorithm"
        elif key == "offPeakStartTime":
            suggest = "off_peak_start_time"
        elif key == "peakLoadBalancingAlgorithm":
            suggest = "peak_load_balancing_algorithm"
        elif key == "peakStartTime":
            suggest = "peak_start_time"
        elif key == "rampDownCapacityThresholdPct":
            suggest = "ramp_down_capacity_threshold_pct"
        elif key == "rampDownForceLogoffUsers":
            suggest = "ramp_down_force_logoff_users"
        elif key == "rampDownLoadBalancingAlgorithm":
            suggest = "ramp_down_load_balancing_algorithm"
        elif key == "rampDownMinimumHostsPct":
            suggest = "ramp_down_minimum_hosts_pct"
        elif key == "rampDownNotificationMessage":
            suggest = "ramp_down_notification_message"
        elif key == "rampDownStartTime":
            suggest = "ramp_down_start_time"
        elif key == "rampDownStopHostsWhen":
            suggest = "ramp_down_stop_hosts_when"
        elif key == "rampDownWaitTimeMinutes":
            suggest = "ramp_down_wait_time_minutes"
        elif key == "rampUpCapacityThresholdPct":
            suggest = "ramp_up_capacity_threshold_pct"
        elif key == "rampUpLoadBalancingAlgorithm":
            suggest = "ramp_up_load_balancing_algorithm"
        elif key == "rampUpMinimumHostsPct":
            suggest = "ramp_up_minimum_hosts_pct"
        elif key == "rampUpStartTime":
            suggest = "ramp_up_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_week: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 off_peak_load_balancing_algorithm: Optional[str] = None,
                 off_peak_start_time: Optional[str] = None,
                 peak_load_balancing_algorithm: Optional[str] = None,
                 peak_start_time: Optional[str] = None,
                 ramp_down_capacity_threshold_pct: Optional[int] = None,
                 ramp_down_force_logoff_users: Optional[bool] = None,
                 ramp_down_load_balancing_algorithm: Optional[str] = None,
                 ramp_down_minimum_hosts_pct: Optional[int] = None,
                 ramp_down_notification_message: Optional[str] = None,
                 ramp_down_start_time: Optional[str] = None,
                 ramp_down_stop_hosts_when: Optional[str] = None,
                 ramp_down_wait_time_minutes: Optional[int] = None,
                 ramp_up_capacity_threshold_pct: Optional[int] = None,
                 ramp_up_load_balancing_algorithm: Optional[str] = None,
                 ramp_up_minimum_hosts_pct: Optional[int] = None,
                 ramp_up_start_time: Optional[str] = None):
        """
        Scaling plan schedule.
        :param Sequence[str] days_of_week: Set of days of the week on which this schedule is active.
        :param str name: Name of the scaling schedule.
        :param str off_peak_load_balancing_algorithm: Load balancing algorithm for off-peak period.
        :param str off_peak_start_time: Starting time for off-peak period.
        :param str peak_load_balancing_algorithm: Load balancing algorithm for peak period.
        :param str peak_start_time: Starting time for peak period.
        :param int ramp_down_capacity_threshold_pct: Capacity threshold for ramp down period.
        :param bool ramp_down_force_logoff_users: Should users be logged off forcefully from hosts.
        :param str ramp_down_load_balancing_algorithm: Load balancing algorithm for ramp down period.
        :param int ramp_down_minimum_hosts_pct: Minimum host percentage for ramp down period.
        :param str ramp_down_notification_message: Notification message for users during ramp down period.
        :param str ramp_down_start_time: Starting time for ramp down period.
        :param str ramp_down_stop_hosts_when: Specifies when to stop hosts during ramp down period.
        :param int ramp_down_wait_time_minutes: Number of minutes to wait to stop hosts during ramp down period.
        :param int ramp_up_capacity_threshold_pct: Capacity threshold for ramp up period.
        :param str ramp_up_load_balancing_algorithm: Load balancing algorithm for ramp up period.
        :param int ramp_up_minimum_hosts_pct: Minimum host percentage for ramp up period.
        :param str ramp_up_start_time: Starting time for ramp up period.
        """
        if days_of_week is not None:
            pulumi.set(__self__, "days_of_week", days_of_week)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if off_peak_load_balancing_algorithm is not None:
            pulumi.set(__self__, "off_peak_load_balancing_algorithm", off_peak_load_balancing_algorithm)
        if off_peak_start_time is not None:
            pulumi.set(__self__, "off_peak_start_time", off_peak_start_time)
        if peak_load_balancing_algorithm is not None:
            pulumi.set(__self__, "peak_load_balancing_algorithm", peak_load_balancing_algorithm)
        if peak_start_time is not None:
            pulumi.set(__self__, "peak_start_time", peak_start_time)
        if ramp_down_capacity_threshold_pct is not None:
            pulumi.set(__self__, "ramp_down_capacity_threshold_pct", ramp_down_capacity_threshold_pct)
        if ramp_down_force_logoff_users is not None:
            pulumi.set(__self__, "ramp_down_force_logoff_users", ramp_down_force_logoff_users)
        if ramp_down_load_balancing_algorithm is not None:
            pulumi.set(__self__, "ramp_down_load_balancing_algorithm", ramp_down_load_balancing_algorithm)
        if ramp_down_minimum_hosts_pct is not None:
            pulumi.set(__self__, "ramp_down_minimum_hosts_pct", ramp_down_minimum_hosts_pct)
        if ramp_down_notification_message is not None:
            pulumi.set(__self__, "ramp_down_notification_message", ramp_down_notification_message)
        if ramp_down_start_time is not None:
            pulumi.set(__self__, "ramp_down_start_time", ramp_down_start_time)
        if ramp_down_stop_hosts_when is not None:
            pulumi.set(__self__, "ramp_down_stop_hosts_when", ramp_down_stop_hosts_when)
        if ramp_down_wait_time_minutes is not None:
            pulumi.set(__self__, "ramp_down_wait_time_minutes", ramp_down_wait_time_minutes)
        if ramp_up_capacity_threshold_pct is not None:
            pulumi.set(__self__, "ramp_up_capacity_threshold_pct", ramp_up_capacity_threshold_pct)
        if ramp_up_load_balancing_algorithm is not None:
            pulumi.set(__self__, "ramp_up_load_balancing_algorithm", ramp_up_load_balancing_algorithm)
        if ramp_up_minimum_hosts_pct is not None:
            pulumi.set(__self__, "ramp_up_minimum_hosts_pct", ramp_up_minimum_hosts_pct)
        if ramp_up_start_time is not None:
            pulumi.set(__self__, "ramp_up_start_time", ramp_up_start_time)

    @property
    @pulumi.getter(name="daysOfWeek")
    def days_of_week(self) -> Optional[Sequence[str]]:
        """
        Set of days of the week on which this schedule is active.
        """
        return pulumi.get(self, "days_of_week")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the scaling schedule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="offPeakLoadBalancingAlgorithm")
    def off_peak_load_balancing_algorithm(self) -> Optional[str]:
        """
        Load balancing algorithm for off-peak period.
        """
        return pulumi.get(self, "off_peak_load_balancing_algorithm")

    @property
    @pulumi.getter(name="offPeakStartTime")
    def off_peak_start_time(self) -> Optional[str]:
        """
        Starting time for off-peak period.
        """
        return pulumi.get(self, "off_peak_start_time")

    @property
    @pulumi.getter(name="peakLoadBalancingAlgorithm")
    def peak_load_balancing_algorithm(self) -> Optional[str]:
        """
        Load balancing algorithm for peak period.
        """
        return pulumi.get(self, "peak_load_balancing_algorithm")

    @property
    @pulumi.getter(name="peakStartTime")
    def peak_start_time(self) -> Optional[str]:
        """
        Starting time for peak period.
        """
        return pulumi.get(self, "peak_start_time")

    @property
    @pulumi.getter(name="rampDownCapacityThresholdPct")
    def ramp_down_capacity_threshold_pct(self) -> Optional[int]:
        """
        Capacity threshold for ramp down period.
        """
        return pulumi.get(self, "ramp_down_capacity_threshold_pct")

    @property
    @pulumi.getter(name="rampDownForceLogoffUsers")
    def ramp_down_force_logoff_users(self) -> Optional[bool]:
        """
        Should users be logged off forcefully from hosts.
        """
        return pulumi.get(self, "ramp_down_force_logoff_users")

    @property
    @pulumi.getter(name="rampDownLoadBalancingAlgorithm")
    def ramp_down_load_balancing_algorithm(self) -> Optional[str]:
        """
        Load balancing algorithm for ramp down period.
        """
        return pulumi.get(self, "ramp_down_load_balancing_algorithm")

    @property
    @pulumi.getter(name="rampDownMinimumHostsPct")
    def ramp_down_minimum_hosts_pct(self) -> Optional[int]:
        """
        Minimum host percentage for ramp down period.
        """
        return pulumi.get(self, "ramp_down_minimum_hosts_pct")

    @property
    @pulumi.getter(name="rampDownNotificationMessage")
    def ramp_down_notification_message(self) -> Optional[str]:
        """
        Notification message for users during ramp down period.
        """
        return pulumi.get(self, "ramp_down_notification_message")

    @property
    @pulumi.getter(name="rampDownStartTime")
    def ramp_down_start_time(self) -> Optional[str]:
        """
        Starting time for ramp down period.
        """
        return pulumi.get(self, "ramp_down_start_time")

    @property
    @pulumi.getter(name="rampDownStopHostsWhen")
    def ramp_down_stop_hosts_when(self) -> Optional[str]:
        """
        Specifies when to stop hosts during ramp down period.
        """
        return pulumi.get(self, "ramp_down_stop_hosts_when")

    @property
    @pulumi.getter(name="rampDownWaitTimeMinutes")
    def ramp_down_wait_time_minutes(self) -> Optional[int]:
        """
        Number of minutes to wait to stop hosts during ramp down period.
        """
        return pulumi.get(self, "ramp_down_wait_time_minutes")

    @property
    @pulumi.getter(name="rampUpCapacityThresholdPct")
    def ramp_up_capacity_threshold_pct(self) -> Optional[int]:
        """
        Capacity threshold for ramp up period.
        """
        return pulumi.get(self, "ramp_up_capacity_threshold_pct")

    @property
    @pulumi.getter(name="rampUpLoadBalancingAlgorithm")
    def ramp_up_load_balancing_algorithm(self) -> Optional[str]:
        """
        Load balancing algorithm for ramp up period.
        """
        return pulumi.get(self, "ramp_up_load_balancing_algorithm")

    @property
    @pulumi.getter(name="rampUpMinimumHostsPct")
    def ramp_up_minimum_hosts_pct(self) -> Optional[int]:
        """
        Minimum host percentage for ramp up period.
        """
        return pulumi.get(self, "ramp_up_minimum_hosts_pct")

    @property
    @pulumi.getter(name="rampUpStartTime")
    def ramp_up_start_time(self) -> Optional[str]:
        """
        Starting time for ramp up period.
        """
        return pulumi.get(self, "ramp_up_start_time")


