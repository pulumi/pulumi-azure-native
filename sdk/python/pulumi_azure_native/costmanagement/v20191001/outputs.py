# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ExportDeliveryDestinationResponse',
    'ExportDeliveryInfoResponse',
    'ExportRecurrencePeriodResponse',
    'ExportScheduleResponse',
    'QueryAggregationResponse',
    'QueryComparisonExpressionResponse',
    'QueryDatasetConfigurationResponse',
    'QueryDatasetResponse',
    'QueryDefinitionResponse',
    'QueryFilterResponse',
    'QueryGroupingResponse',
    'QuerySortingConfigurationResponse',
    'QueryTimePeriodResponse',
]

@pulumi.output_type
class ExportDeliveryDestinationResponse(dict):
    """
    The destination information for the delivery of the export.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"
        elif key == "rootFolderPath":
            suggest = "root_folder_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportDeliveryDestinationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportDeliveryDestinationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportDeliveryDestinationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: str,
                 resource_id: str,
                 root_folder_path: Optional[str] = None):
        """
        The destination information for the delivery of the export.
        :param str container: The name of the container where exports will be uploaded.
        :param str resource_id: The resource id of the storage account where exports will be delivered.
        :param str root_folder_path: The name of the directory where exports will be uploaded.
        """
        ExportDeliveryDestinationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container=container,
            resource_id=resource_id,
            root_folder_path=root_folder_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container: str,
             resource_id: str,
             root_folder_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("container", container)
        _setter("resource_id", resource_id)
        if root_folder_path is not None:
            _setter("root_folder_path", root_folder_path)

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        The name of the container where exports will be uploaded.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The resource id of the storage account where exports will be delivered.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="rootFolderPath")
    def root_folder_path(self) -> Optional[str]:
        """
        The name of the directory where exports will be uploaded.
        """
        return pulumi.get(self, "root_folder_path")


@pulumi.output_type
class ExportDeliveryInfoResponse(dict):
    """
    The delivery information associated with a export.
    """
    def __init__(__self__, *,
                 destination: 'outputs.ExportDeliveryDestinationResponse'):
        """
        The delivery information associated with a export.
        :param 'ExportDeliveryDestinationResponse' destination: Has destination for the export being delivered.
        """
        ExportDeliveryInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: 'outputs.ExportDeliveryDestinationResponse',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("destination", destination)

    @property
    @pulumi.getter
    def destination(self) -> 'outputs.ExportDeliveryDestinationResponse':
        """
        Has destination for the export being delivered.
        """
        return pulumi.get(self, "destination")


@pulumi.output_type
class ExportRecurrencePeriodResponse(dict):
    """
    The start and end date for recurrence schedule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportRecurrencePeriodResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportRecurrencePeriodResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportRecurrencePeriodResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: str,
                 to: Optional[str] = None):
        """
        The start and end date for recurrence schedule.
        :param str from_: The start date of recurrence.
        :param str to: The end date of recurrence.
        """
        ExportRecurrencePeriodResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: str,
             to: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("from_", from_)
        if to is not None:
            _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> str:
        """
        The start date of recurrence.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[str]:
        """
        The end date of recurrence.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class ExportScheduleResponse(dict):
    """
    The schedule associated with a export.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrencePeriod":
            suggest = "recurrence_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExportScheduleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExportScheduleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExportScheduleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recurrence: str,
                 recurrence_period: Optional['outputs.ExportRecurrencePeriodResponse'] = None,
                 status: Optional[str] = None):
        """
        The schedule associated with a export.
        :param str recurrence: The schedule recurrence.
        :param 'ExportRecurrencePeriodResponse' recurrence_period: Has start and end date of the recurrence. The start date must be in future. If present, the end date must be greater than start date.
        :param str status: The status of the schedule. Whether active or not. If inactive, the export's scheduled execution is paused.
        """
        ExportScheduleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            recurrence=recurrence,
            recurrence_period=recurrence_period,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             recurrence: str,
             recurrence_period: Optional['outputs.ExportRecurrencePeriodResponse'] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("recurrence", recurrence)
        if recurrence_period is not None:
            _setter("recurrence_period", recurrence_period)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def recurrence(self) -> str:
        """
        The schedule recurrence.
        """
        return pulumi.get(self, "recurrence")

    @property
    @pulumi.getter(name="recurrencePeriod")
    def recurrence_period(self) -> Optional['outputs.ExportRecurrencePeriodResponse']:
        """
        Has start and end date of the recurrence. The start date must be in future. If present, the end date must be greater than start date.
        """
        return pulumi.get(self, "recurrence_period")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the schedule. Whether active or not. If inactive, the export's scheduled execution is paused.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class QueryAggregationResponse(dict):
    """
    The aggregation expression to be used in the query.
    """
    def __init__(__self__, *,
                 function: str,
                 name: str):
        """
        The aggregation expression to be used in the query.
        :param str function: The name of the aggregation function to use.
        :param str name: The name of the column to aggregate.
        """
        QueryAggregationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            function=function,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             function: str,
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("function", function)
        _setter("name", name)

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        The name of the aggregation function to use.
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column to aggregate.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class QueryComparisonExpressionResponse(dict):
    """
    The comparison expression to be used in the query.
    """
    def __init__(__self__, *,
                 name: str,
                 operator: str,
                 values: Sequence[str]):
        """
        The comparison expression to be used in the query.
        :param str name: The name of the column to use in comparison.
        :param str operator: The operator to use for comparison.
        :param Sequence[str] values: Array of values to use for comparison
        """
        QueryComparisonExpressionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            operator=operator,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             operator: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("operator", operator)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column to use in comparison.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to use for comparison.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Array of values to use for comparison
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class QueryDatasetConfigurationResponse(dict):
    """
    The configuration of dataset in the query.
    """
    def __init__(__self__, *,
                 columns: Optional[Sequence[str]] = None):
        """
        The configuration of dataset in the query.
        :param Sequence[str] columns: Array of column names to be included in the query. Any valid query column name is allowed. If not provided, then query includes all columns.
        """
        QueryDatasetConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if columns is not None:
            _setter("columns", columns)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence[str]]:
        """
        Array of column names to be included in the query. Any valid query column name is allowed. If not provided, then query includes all columns.
        """
        return pulumi.get(self, "columns")


@pulumi.output_type
class QueryDatasetResponse(dict):
    """
    The definition of data present in the query.
    """
    def __init__(__self__, *,
                 aggregation: Optional[Mapping[str, 'outputs.QueryAggregationResponse']] = None,
                 configuration: Optional['outputs.QueryDatasetConfigurationResponse'] = None,
                 filter: Optional['outputs.QueryFilterResponse'] = None,
                 granularity: Optional[str] = None,
                 grouping: Optional[Sequence['outputs.QueryGroupingResponse']] = None,
                 sorting: Optional[Sequence['outputs.QuerySortingConfigurationResponse']] = None):
        """
        The definition of data present in the query.
        :param Mapping[str, 'QueryAggregationResponse'] aggregation: Dictionary of aggregation expression to use in the query. The key of each item in the dictionary is the alias for the aggregated column. Query can have up to 2 aggregation clauses.
        :param 'QueryDatasetConfigurationResponse' configuration: Has configuration information for the data in the export. The configuration will be ignored if aggregation and grouping are provided.
        :param 'QueryFilterResponse' filter: The filter expression to use in the query. Please reference our Query API REST documentation for how to properly format the filter.
        :param str granularity: The granularity of rows in the query.
        :param Sequence['QueryGroupingResponse'] grouping: Array of group by expression to use in the query. Query can have up to 2 group by clauses.
        :param Sequence['QuerySortingConfigurationResponse'] sorting: Array of sorting by columns in query.
        """
        QueryDatasetResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            configuration=configuration,
            filter=filter,
            granularity=granularity,
            grouping=grouping,
            sorting=sorting,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: Optional[Mapping[str, 'outputs.QueryAggregationResponse']] = None,
             configuration: Optional['outputs.QueryDatasetConfigurationResponse'] = None,
             filter: Optional['outputs.QueryFilterResponse'] = None,
             granularity: Optional[str] = None,
             grouping: Optional[Sequence['outputs.QueryGroupingResponse']] = None,
             sorting: Optional[Sequence['outputs.QuerySortingConfigurationResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregation is not None:
            _setter("aggregation", aggregation)
        if configuration is not None:
            _setter("configuration", configuration)
        if filter is not None:
            _setter("filter", filter)
        if granularity is not None:
            _setter("granularity", granularity)
        if grouping is not None:
            _setter("grouping", grouping)
        if sorting is not None:
            _setter("sorting", sorting)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[Mapping[str, 'outputs.QueryAggregationResponse']]:
        """
        Dictionary of aggregation expression to use in the query. The key of each item in the dictionary is the alias for the aggregated column. Query can have up to 2 aggregation clauses.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.QueryDatasetConfigurationResponse']:
        """
        Has configuration information for the data in the export. The configuration will be ignored if aggregation and grouping are provided.
        """
        return pulumi.get(self, "configuration")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.QueryFilterResponse']:
        """
        The filter expression to use in the query. Please reference our Query API REST documentation for how to properly format the filter.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def granularity(self) -> Optional[str]:
        """
        The granularity of rows in the query.
        """
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter
    def grouping(self) -> Optional[Sequence['outputs.QueryGroupingResponse']]:
        """
        Array of group by expression to use in the query. Query can have up to 2 group by clauses.
        """
        return pulumi.get(self, "grouping")

    @property
    @pulumi.getter
    def sorting(self) -> Optional[Sequence['outputs.QuerySortingConfigurationResponse']]:
        """
        Array of sorting by columns in query.
        """
        return pulumi.get(self, "sorting")


@pulumi.output_type
class QueryDefinitionResponse(dict):
    """
    The definition of a query.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timePeriod":
            suggest = "time_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 timeframe: str,
                 type: str,
                 dataset: Optional['outputs.QueryDatasetResponse'] = None,
                 time_period: Optional['outputs.QueryTimePeriodResponse'] = None):
        """
        The definition of a query.
        :param str timeframe: The time frame for pulling data for the query. If custom, then a specific time period must be provided.
        :param str type: The type of the query.
        :param 'QueryDatasetResponse' dataset: Has definition for data in this query.
        :param 'QueryTimePeriodResponse' time_period: Has time period for pulling data for the query.
        """
        QueryDefinitionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            timeframe=timeframe,
            type=type,
            dataset=dataset,
            time_period=time_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             timeframe: str,
             type: str,
             dataset: Optional['outputs.QueryDatasetResponse'] = None,
             time_period: Optional['outputs.QueryTimePeriodResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("timeframe", timeframe)
        _setter("type", type)
        if dataset is not None:
            _setter("dataset", dataset)
        if time_period is not None:
            _setter("time_period", time_period)

    @property
    @pulumi.getter
    def timeframe(self) -> str:
        """
        The time frame for pulling data for the query. If custom, then a specific time period must be provided.
        """
        return pulumi.get(self, "timeframe")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the query.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def dataset(self) -> Optional['outputs.QueryDatasetResponse']:
        """
        Has definition for data in this query.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter(name="timePeriod")
    def time_period(self) -> Optional['outputs.QueryTimePeriodResponse']:
        """
        Has time period for pulling data for the query.
        """
        return pulumi.get(self, "time_period")


@pulumi.output_type
class QueryFilterResponse(dict):
    """
    The filter expression to be used in the export.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "and":
            suggest = "and_"
        elif key == "not":
            suggest = "not_"
        elif key == "or":
            suggest = "or_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryFilterResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryFilterResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryFilterResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_: Optional[Sequence['outputs.QueryFilterResponse']] = None,
                 dimension: Optional['outputs.QueryComparisonExpressionResponse'] = None,
                 not_: Optional['outputs.QueryFilterResponse'] = None,
                 or_: Optional[Sequence['outputs.QueryFilterResponse']] = None,
                 tag: Optional['outputs.QueryComparisonExpressionResponse'] = None):
        """
        The filter expression to be used in the export.
        :param Sequence['QueryFilterResponse'] and_: The logical "AND" expression. Must have at least 2 items.
        :param 'QueryComparisonExpressionResponse' dimension: Has comparison expression for a dimension
        :param 'QueryFilterResponse' not_: The logical "NOT" expression.
        :param Sequence['QueryFilterResponse'] or_: The logical "OR" expression. Must have at least 2 items.
        :param 'QueryComparisonExpressionResponse' tag: Has comparison expression for a tag
        """
        QueryFilterResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            and_=and_,
            dimension=dimension,
            not_=not_,
            or_=or_,
            tag=tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             and_: Optional[Sequence['outputs.QueryFilterResponse']] = None,
             dimension: Optional['outputs.QueryComparisonExpressionResponse'] = None,
             not_: Optional['outputs.QueryFilterResponse'] = None,
             or_: Optional[Sequence['outputs.QueryFilterResponse']] = None,
             tag: Optional['outputs.QueryComparisonExpressionResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if and_ is not None:
            _setter("and_", and_)
        if dimension is not None:
            _setter("dimension", dimension)
        if not_ is not None:
            _setter("not_", not_)
        if or_ is not None:
            _setter("or_", or_)
        if tag is not None:
            _setter("tag", tag)

    @property
    @pulumi.getter(name="and")
    def and_(self) -> Optional[Sequence['outputs.QueryFilterResponse']]:
        """
        The logical "AND" expression. Must have at least 2 items.
        """
        return pulumi.get(self, "and_")

    @property
    @pulumi.getter
    def dimension(self) -> Optional['outputs.QueryComparisonExpressionResponse']:
        """
        Has comparison expression for a dimension
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="not")
    def not_(self) -> Optional['outputs.QueryFilterResponse']:
        """
        The logical "NOT" expression.
        """
        return pulumi.get(self, "not_")

    @property
    @pulumi.getter(name="or")
    def or_(self) -> Optional[Sequence['outputs.QueryFilterResponse']]:
        """
        The logical "OR" expression. Must have at least 2 items.
        """
        return pulumi.get(self, "or_")

    @property
    @pulumi.getter
    def tag(self) -> Optional['outputs.QueryComparisonExpressionResponse']:
        """
        Has comparison expression for a tag
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class QueryGroupingResponse(dict):
    """
    The group by expression to be used in the query.
    """
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        The group by expression to be used in the query.
        :param str name: The name of the column to group.
        :param str type: Has type of the column to group.
        """
        QueryGroupingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column to group.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Has type of the column to group.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class QuerySortingConfigurationResponse(dict):
    """
    The configuration for sorting in the query.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "querySortingDirection":
            suggest = "query_sorting_direction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QuerySortingConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QuerySortingConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QuerySortingConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 query_sorting_direction: Optional[str] = None):
        """
        The configuration for sorting in the query.
        :param str name: The name of the column to use in sorting.
        :param str query_sorting_direction: The sorting direction
        """
        QuerySortingConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query_sorting_direction=query_sorting_direction,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             query_sorting_direction: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if query_sorting_direction is not None:
            _setter("query_sorting_direction", query_sorting_direction)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the column to use in sorting.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="querySortingDirection")
    def query_sorting_direction(self) -> Optional[str]:
        """
        The sorting direction
        """
        return pulumi.get(self, "query_sorting_direction")


@pulumi.output_type
class QueryTimePeriodResponse(dict):
    """
    The start and end date for pulling data for the query.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueryTimePeriodResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueryTimePeriodResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueryTimePeriodResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: str,
                 to: str):
        """
        The start and end date for pulling data for the query.
        :param str from_: The start date to pull data from.
        :param str to: The end date to pull data to.
        """
        QueryTimePeriodResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             from_: str,
             to: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> str:
        """
        The start date to pull data from.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> str:
        """
        The end date to pull data to.
        """
        return pulumi.get(self, "to")


