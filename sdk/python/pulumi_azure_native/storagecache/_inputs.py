# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AmlFilesystemEncryptionSettingsArgs',
    'AmlFilesystemEncryptionSettingsArgsDict',
    'AmlFilesystemHsmSettingsArgs',
    'AmlFilesystemHsmSettingsArgsDict',
    'AmlFilesystemHsmArgs',
    'AmlFilesystemHsmArgsDict',
    'AmlFilesystemIdentityArgs',
    'AmlFilesystemIdentityArgsDict',
    'AmlFilesystemMaintenanceWindowArgs',
    'AmlFilesystemMaintenanceWindowArgsDict',
    'AmlFilesystemRootSquashSettingsArgs',
    'AmlFilesystemRootSquashSettingsArgsDict',
    'BlobNfsTargetArgs',
    'BlobNfsTargetArgsDict',
    'CacheActiveDirectorySettingsCredentialsArgs',
    'CacheActiveDirectorySettingsCredentialsArgsDict',
    'CacheActiveDirectorySettingsArgs',
    'CacheActiveDirectorySettingsArgsDict',
    'CacheDirectorySettingsArgs',
    'CacheDirectorySettingsArgsDict',
    'CacheEncryptionSettingsArgs',
    'CacheEncryptionSettingsArgsDict',
    'CacheIdentityArgs',
    'CacheIdentityArgsDict',
    'CacheNetworkSettingsArgs',
    'CacheNetworkSettingsArgsDict',
    'CacheSecuritySettingsArgs',
    'CacheSecuritySettingsArgsDict',
    'CacheSkuArgs',
    'CacheSkuArgsDict',
    'CacheUpgradeSettingsArgs',
    'CacheUpgradeSettingsArgsDict',
    'CacheUsernameDownloadSettingsCredentialsArgs',
    'CacheUsernameDownloadSettingsCredentialsArgsDict',
    'CacheUsernameDownloadSettingsArgs',
    'CacheUsernameDownloadSettingsArgsDict',
    'ClfsTargetArgs',
    'ClfsTargetArgsDict',
    'KeyVaultKeyReferenceSourceVaultArgs',
    'KeyVaultKeyReferenceSourceVaultArgsDict',
    'KeyVaultKeyReferenceArgs',
    'KeyVaultKeyReferenceArgsDict',
    'NamespaceJunctionArgs',
    'NamespaceJunctionArgsDict',
    'Nfs3TargetArgs',
    'Nfs3TargetArgsDict',
    'NfsAccessPolicyArgs',
    'NfsAccessPolicyArgsDict',
    'NfsAccessRuleArgs',
    'NfsAccessRuleArgsDict',
    'SkuName',
    'SkuNameDict',
    'SkuNameArgs',
    'SkuNameArgsDict',
    'UnknownTargetArgs',
    'UnknownTargetArgsDict',
]

MYPY = False

if not MYPY:
    class AmlFilesystemEncryptionSettingsArgsDict(TypedDict):
        """
        AML file system encryption settings.
        """
        key_encryption_key: NotRequired[pulumi.Input['KeyVaultKeyReferenceArgsDict']]
        """
        Specifies the location of the encryption key in Key Vault.
        """
elif False:
    AmlFilesystemEncryptionSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AmlFilesystemEncryptionSettingsArgs:
    def __init__(__self__, *,
                 key_encryption_key: Optional[pulumi.Input['KeyVaultKeyReferenceArgs']] = None):
        """
        AML file system encryption settings.
        :param pulumi.Input['KeyVaultKeyReferenceArgs'] key_encryption_key: Specifies the location of the encryption key in Key Vault.
        """
        if key_encryption_key is not None:
            pulumi.set(__self__, "key_encryption_key", key_encryption_key)

    @property
    @pulumi.getter(name="keyEncryptionKey")
    def key_encryption_key(self) -> Optional[pulumi.Input['KeyVaultKeyReferenceArgs']]:
        """
        Specifies the location of the encryption key in Key Vault.
        """
        return pulumi.get(self, "key_encryption_key")

    @key_encryption_key.setter
    def key_encryption_key(self, value: Optional[pulumi.Input['KeyVaultKeyReferenceArgs']]):
        pulumi.set(self, "key_encryption_key", value)


if not MYPY:
    class AmlFilesystemHsmSettingsArgsDict(TypedDict):
        """
        AML file system HSM settings.
        """
        container: pulumi.Input[builtins.str]
        """
        Resource ID of storage container used for hydrating the namespace and archiving from the namespace. The resource provider must have permission to create SAS tokens on the storage account.
        """
        logging_container: pulumi.Input[builtins.str]
        """
        Resource ID of storage container used for logging events and errors.  Must be a separate container in the same storage account as the hydration and archive container. The resource provider must have permission to create SAS tokens on the storage account.
        """
        import_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        Only blobs in the non-logging container that start with this path/prefix get imported into the cluster namespace. This is only used during initial creation of the AML file system. It automatically creates an import job resource that can be deleted.
        """
        import_prefixes_initial: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Only blobs in the non-logging container that start with one of the paths/prefixes in this array get imported into the cluster namespace. This is only used during initial creation of the AML file system and has '/' as the default value. It automatically creates an import job resource that can be deleted.
        """
elif False:
    AmlFilesystemHsmSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AmlFilesystemHsmSettingsArgs:
    def __init__(__self__, *,
                 container: pulumi.Input[builtins.str],
                 logging_container: pulumi.Input[builtins.str],
                 import_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 import_prefixes_initial: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        AML file system HSM settings.
        :param pulumi.Input[builtins.str] container: Resource ID of storage container used for hydrating the namespace and archiving from the namespace. The resource provider must have permission to create SAS tokens on the storage account.
        :param pulumi.Input[builtins.str] logging_container: Resource ID of storage container used for logging events and errors.  Must be a separate container in the same storage account as the hydration and archive container. The resource provider must have permission to create SAS tokens on the storage account.
        :param pulumi.Input[builtins.str] import_prefix: Only blobs in the non-logging container that start with this path/prefix get imported into the cluster namespace. This is only used during initial creation of the AML file system. It automatically creates an import job resource that can be deleted.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] import_prefixes_initial: Only blobs in the non-logging container that start with one of the paths/prefixes in this array get imported into the cluster namespace. This is only used during initial creation of the AML file system and has '/' as the default value. It automatically creates an import job resource that can be deleted.
        """
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "logging_container", logging_container)
        if import_prefix is None:
            import_prefix = '/'
        if import_prefix is not None:
            pulumi.set(__self__, "import_prefix", import_prefix)
        if import_prefixes_initial is not None:
            pulumi.set(__self__, "import_prefixes_initial", import_prefixes_initial)

    @property
    @pulumi.getter
    def container(self) -> pulumi.Input[builtins.str]:
        """
        Resource ID of storage container used for hydrating the namespace and archiving from the namespace. The resource provider must have permission to create SAS tokens on the storage account.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="loggingContainer")
    def logging_container(self) -> pulumi.Input[builtins.str]:
        """
        Resource ID of storage container used for logging events and errors.  Must be a separate container in the same storage account as the hydration and archive container. The resource provider must have permission to create SAS tokens on the storage account.
        """
        return pulumi.get(self, "logging_container")

    @logging_container.setter
    def logging_container(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "logging_container", value)

    @property
    @pulumi.getter(name="importPrefix")
    def import_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Only blobs in the non-logging container that start with this path/prefix get imported into the cluster namespace. This is only used during initial creation of the AML file system. It automatically creates an import job resource that can be deleted.
        """
        return pulumi.get(self, "import_prefix")

    @import_prefix.setter
    def import_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "import_prefix", value)

    @property
    @pulumi.getter(name="importPrefixesInitial")
    def import_prefixes_initial(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Only blobs in the non-logging container that start with one of the paths/prefixes in this array get imported into the cluster namespace. This is only used during initial creation of the AML file system and has '/' as the default value. It automatically creates an import job resource that can be deleted.
        """
        return pulumi.get(self, "import_prefixes_initial")

    @import_prefixes_initial.setter
    def import_prefixes_initial(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "import_prefixes_initial", value)


if not MYPY:
    class AmlFilesystemHsmArgsDict(TypedDict):
        """
        Hydration and archive settings and status
        """
        settings: NotRequired[pulumi.Input['AmlFilesystemHsmSettingsArgsDict']]
        """
        Specifies HSM settings of the AML file system.
        """
elif False:
    AmlFilesystemHsmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AmlFilesystemHsmArgs:
    def __init__(__self__, *,
                 settings: Optional[pulumi.Input['AmlFilesystemHsmSettingsArgs']] = None):
        """
        Hydration and archive settings and status
        :param pulumi.Input['AmlFilesystemHsmSettingsArgs'] settings: Specifies HSM settings of the AML file system.
        """
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['AmlFilesystemHsmSettingsArgs']]:
        """
        Specifies HSM settings of the AML file system.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['AmlFilesystemHsmSettingsArgs']]):
        pulumi.set(self, "settings", value)


if not MYPY:
    class AmlFilesystemIdentityArgsDict(TypedDict):
        """
        Managed Identity properties.
        """
        type: NotRequired[pulumi.Input['AmlFilesystemIdentityType']]
        """
        The type of identity used for the resource.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A dictionary where each key is a user assigned identity resource ID, and each key's value is an empty dictionary.
        """
elif False:
    AmlFilesystemIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AmlFilesystemIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['AmlFilesystemIdentityType']] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Managed Identity properties.
        :param pulumi.Input['AmlFilesystemIdentityType'] type: The type of identity used for the resource.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_assigned_identities: A dictionary where each key is a user assigned identity resource ID, and each key's value is an empty dictionary.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['AmlFilesystemIdentityType']]:
        """
        The type of identity used for the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['AmlFilesystemIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A dictionary where each key is a user assigned identity resource ID, and each key's value is an empty dictionary.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class AmlFilesystemMaintenanceWindowArgsDict(TypedDict):
        """
        Start time of a 30-minute weekly maintenance window.
        """
        day_of_week: NotRequired[pulumi.Input['MaintenanceDayOfWeekType']]
        """
        Day of the week on which the maintenance window will occur.
        """
        time_of_day_utc: NotRequired[pulumi.Input[builtins.str]]
        """
        The time of day (in UTC) to start the maintenance window.
        """
elif False:
    AmlFilesystemMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AmlFilesystemMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day_of_week: Optional[pulumi.Input['MaintenanceDayOfWeekType']] = None,
                 time_of_day_utc: Optional[pulumi.Input[builtins.str]] = None):
        """
        Start time of a 30-minute weekly maintenance window.
        :param pulumi.Input['MaintenanceDayOfWeekType'] day_of_week: Day of the week on which the maintenance window will occur.
        :param pulumi.Input[builtins.str] time_of_day_utc: The time of day (in UTC) to start the maintenance window.
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if time_of_day_utc is not None:
            pulumi.set(__self__, "time_of_day_utc", time_of_day_utc)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input['MaintenanceDayOfWeekType']]:
        """
        Day of the week on which the maintenance window will occur.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input['MaintenanceDayOfWeekType']]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="timeOfDayUTC")
    def time_of_day_utc(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The time of day (in UTC) to start the maintenance window.
        """
        return pulumi.get(self, "time_of_day_utc")

    @time_of_day_utc.setter
    def time_of_day_utc(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_of_day_utc", value)


if not MYPY:
    class AmlFilesystemRootSquashSettingsArgsDict(TypedDict):
        """
        AML file system squash settings.
        """
        mode: NotRequired[pulumi.Input[Union[builtins.str, 'AmlFilesystemSquashMode']]]
        """
        Squash mode of the AML file system. 'All': User and Group IDs on files will be squashed to the provided values for all users on non-trusted systems. 'RootOnly': User and Group IDs on files will be squashed to provided values for solely the root user on non-trusted systems. 'None': No squashing of User and Group IDs is performed for any users on any systems.
        """
        no_squash_nid_lists: NotRequired[pulumi.Input[builtins.str]]
        """
        Semicolon separated NID IP Address list(s) to be added to the TrustedSystems.
        """
        squash_gid: NotRequired[pulumi.Input[builtins.float]]
        """
        Group ID to squash to.
        """
        squash_uid: NotRequired[pulumi.Input[builtins.float]]
        """
        User ID to squash to.
        """
elif False:
    AmlFilesystemRootSquashSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AmlFilesystemRootSquashSettingsArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[Union[builtins.str, 'AmlFilesystemSquashMode']]] = None,
                 no_squash_nid_lists: Optional[pulumi.Input[builtins.str]] = None,
                 squash_gid: Optional[pulumi.Input[builtins.float]] = None,
                 squash_uid: Optional[pulumi.Input[builtins.float]] = None):
        """
        AML file system squash settings.
        :param pulumi.Input[Union[builtins.str, 'AmlFilesystemSquashMode']] mode: Squash mode of the AML file system. 'All': User and Group IDs on files will be squashed to the provided values for all users on non-trusted systems. 'RootOnly': User and Group IDs on files will be squashed to provided values for solely the root user on non-trusted systems. 'None': No squashing of User and Group IDs is performed for any users on any systems.
        :param pulumi.Input[builtins.str] no_squash_nid_lists: Semicolon separated NID IP Address list(s) to be added to the TrustedSystems.
        :param pulumi.Input[builtins.float] squash_gid: Group ID to squash to.
        :param pulumi.Input[builtins.float] squash_uid: User ID to squash to.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if no_squash_nid_lists is not None:
            pulumi.set(__self__, "no_squash_nid_lists", no_squash_nid_lists)
        if squash_gid is not None:
            pulumi.set(__self__, "squash_gid", squash_gid)
        if squash_uid is not None:
            pulumi.set(__self__, "squash_uid", squash_uid)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'AmlFilesystemSquashMode']]]:
        """
        Squash mode of the AML file system. 'All': User and Group IDs on files will be squashed to the provided values for all users on non-trusted systems. 'RootOnly': User and Group IDs on files will be squashed to provided values for solely the root user on non-trusted systems. 'None': No squashing of User and Group IDs is performed for any users on any systems.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'AmlFilesystemSquashMode']]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="noSquashNidLists")
    def no_squash_nid_lists(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Semicolon separated NID IP Address list(s) to be added to the TrustedSystems.
        """
        return pulumi.get(self, "no_squash_nid_lists")

    @no_squash_nid_lists.setter
    def no_squash_nid_lists(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "no_squash_nid_lists", value)

    @property
    @pulumi.getter(name="squashGID")
    def squash_gid(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Group ID to squash to.
        """
        return pulumi.get(self, "squash_gid")

    @squash_gid.setter
    def squash_gid(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "squash_gid", value)

    @property
    @pulumi.getter(name="squashUID")
    def squash_uid(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        User ID to squash to.
        """
        return pulumi.get(self, "squash_uid")

    @squash_uid.setter
    def squash_uid(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "squash_uid", value)


if not MYPY:
    class BlobNfsTargetArgsDict(TypedDict):
        """
        Properties pertaining to the BlobNfsTarget.
        """
        target: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ID of the storage container.
        """
        usage_model: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifies the StorageCache usage model to be used for this storage target.
        """
        verification_timer: NotRequired[pulumi.Input[builtins.int]]
        """
        Amount of time (in seconds) the cache waits before it checks the back-end storage for file updates.
        """
        write_back_timer: NotRequired[pulumi.Input[builtins.int]]
        """
        Amount of time (in seconds) the cache waits after the last file change before it copies the changed file to back-end storage.
        """
elif False:
    BlobNfsTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BlobNfsTargetArgs:
    def __init__(__self__, *,
                 target: Optional[pulumi.Input[builtins.str]] = None,
                 usage_model: Optional[pulumi.Input[builtins.str]] = None,
                 verification_timer: Optional[pulumi.Input[builtins.int]] = None,
                 write_back_timer: Optional[pulumi.Input[builtins.int]] = None):
        """
        Properties pertaining to the BlobNfsTarget.
        :param pulumi.Input[builtins.str] target: Resource ID of the storage container.
        :param pulumi.Input[builtins.str] usage_model: Identifies the StorageCache usage model to be used for this storage target.
        :param pulumi.Input[builtins.int] verification_timer: Amount of time (in seconds) the cache waits before it checks the back-end storage for file updates.
        :param pulumi.Input[builtins.int] write_back_timer: Amount of time (in seconds) the cache waits after the last file change before it copies the changed file to back-end storage.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if usage_model is not None:
            pulumi.set(__self__, "usage_model", usage_model)
        if verification_timer is not None:
            pulumi.set(__self__, "verification_timer", verification_timer)
        if write_back_timer is not None:
            pulumi.set(__self__, "write_back_timer", write_back_timer)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ID of the storage container.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="usageModel")
    def usage_model(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifies the StorageCache usage model to be used for this storage target.
        """
        return pulumi.get(self, "usage_model")

    @usage_model.setter
    def usage_model(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "usage_model", value)

    @property
    @pulumi.getter(name="verificationTimer")
    def verification_timer(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Amount of time (in seconds) the cache waits before it checks the back-end storage for file updates.
        """
        return pulumi.get(self, "verification_timer")

    @verification_timer.setter
    def verification_timer(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "verification_timer", value)

    @property
    @pulumi.getter(name="writeBackTimer")
    def write_back_timer(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Amount of time (in seconds) the cache waits after the last file change before it copies the changed file to back-end storage.
        """
        return pulumi.get(self, "write_back_timer")

    @write_back_timer.setter
    def write_back_timer(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "write_back_timer", value)


if not MYPY:
    class CacheActiveDirectorySettingsCredentialsArgsDict(TypedDict):
        """
        Active Directory admin credentials used to join the HPC Cache to a domain.
        """
        username: pulumi.Input[builtins.str]
        """
        Username of the Active Directory domain administrator. This value is stored encrypted and not returned on response.
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Plain text password of the Active Directory domain administrator. This value is stored encrypted and not returned on response.
        """
elif False:
    CacheActiveDirectorySettingsCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheActiveDirectorySettingsCredentialsArgs:
    def __init__(__self__, *,
                 username: pulumi.Input[builtins.str],
                 password: Optional[pulumi.Input[builtins.str]] = None):
        """
        Active Directory admin credentials used to join the HPC Cache to a domain.
        :param pulumi.Input[builtins.str] username: Username of the Active Directory domain administrator. This value is stored encrypted and not returned on response.
        :param pulumi.Input[builtins.str] password: Plain text password of the Active Directory domain administrator. This value is stored encrypted and not returned on response.
        """
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        """
        Username of the Active Directory domain administrator. This value is stored encrypted and not returned on response.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Plain text password of the Active Directory domain administrator. This value is stored encrypted and not returned on response.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class CacheActiveDirectorySettingsArgsDict(TypedDict):
        """
        Active Directory settings used to join a cache to a domain.
        """
        cache_net_bios_name: pulumi.Input[builtins.str]
        """
        The NetBIOS name to assign to the HPC Cache when it joins the Active Directory domain as a server. Length must 1-15 characters from the class [-0-9a-zA-Z].
        """
        domain_name: pulumi.Input[builtins.str]
        """
        The fully qualified domain name of the Active Directory domain controller.
        """
        domain_net_bios_name: pulumi.Input[builtins.str]
        """
        The Active Directory domain's NetBIOS name.
        """
        primary_dns_ip_address: pulumi.Input[builtins.str]
        """
        Primary DNS IP address used to resolve the Active Directory domain controller's fully qualified domain name.
        """
        credentials: NotRequired[pulumi.Input['CacheActiveDirectorySettingsCredentialsArgsDict']]
        """
        Active Directory admin credentials used to join the HPC Cache to a domain.
        """
        secondary_dns_ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        Secondary DNS IP address used to resolve the Active Directory domain controller's fully qualified domain name.
        """
elif False:
    CacheActiveDirectorySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheActiveDirectorySettingsArgs:
    def __init__(__self__, *,
                 cache_net_bios_name: pulumi.Input[builtins.str],
                 domain_name: pulumi.Input[builtins.str],
                 domain_net_bios_name: pulumi.Input[builtins.str],
                 primary_dns_ip_address: pulumi.Input[builtins.str],
                 credentials: Optional[pulumi.Input['CacheActiveDirectorySettingsCredentialsArgs']] = None,
                 secondary_dns_ip_address: Optional[pulumi.Input[builtins.str]] = None):
        """
        Active Directory settings used to join a cache to a domain.
        :param pulumi.Input[builtins.str] cache_net_bios_name: The NetBIOS name to assign to the HPC Cache when it joins the Active Directory domain as a server. Length must 1-15 characters from the class [-0-9a-zA-Z].
        :param pulumi.Input[builtins.str] domain_name: The fully qualified domain name of the Active Directory domain controller.
        :param pulumi.Input[builtins.str] domain_net_bios_name: The Active Directory domain's NetBIOS name.
        :param pulumi.Input[builtins.str] primary_dns_ip_address: Primary DNS IP address used to resolve the Active Directory domain controller's fully qualified domain name.
        :param pulumi.Input['CacheActiveDirectorySettingsCredentialsArgs'] credentials: Active Directory admin credentials used to join the HPC Cache to a domain.
        :param pulumi.Input[builtins.str] secondary_dns_ip_address: Secondary DNS IP address used to resolve the Active Directory domain controller's fully qualified domain name.
        """
        pulumi.set(__self__, "cache_net_bios_name", cache_net_bios_name)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "domain_net_bios_name", domain_net_bios_name)
        pulumi.set(__self__, "primary_dns_ip_address", primary_dns_ip_address)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if secondary_dns_ip_address is not None:
            pulumi.set(__self__, "secondary_dns_ip_address", secondary_dns_ip_address)

    @property
    @pulumi.getter(name="cacheNetBiosName")
    def cache_net_bios_name(self) -> pulumi.Input[builtins.str]:
        """
        The NetBIOS name to assign to the HPC Cache when it joins the Active Directory domain as a server. Length must 1-15 characters from the class [-0-9a-zA-Z].
        """
        return pulumi.get(self, "cache_net_bios_name")

    @cache_net_bios_name.setter
    def cache_net_bios_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cache_net_bios_name", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[builtins.str]:
        """
        The fully qualified domain name of the Active Directory domain controller.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="domainNetBiosName")
    def domain_net_bios_name(self) -> pulumi.Input[builtins.str]:
        """
        The Active Directory domain's NetBIOS name.
        """
        return pulumi.get(self, "domain_net_bios_name")

    @domain_net_bios_name.setter
    def domain_net_bios_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "domain_net_bios_name", value)

    @property
    @pulumi.getter(name="primaryDnsIpAddress")
    def primary_dns_ip_address(self) -> pulumi.Input[builtins.str]:
        """
        Primary DNS IP address used to resolve the Active Directory domain controller's fully qualified domain name.
        """
        return pulumi.get(self, "primary_dns_ip_address")

    @primary_dns_ip_address.setter
    def primary_dns_ip_address(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "primary_dns_ip_address", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['CacheActiveDirectorySettingsCredentialsArgs']]:
        """
        Active Directory admin credentials used to join the HPC Cache to a domain.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['CacheActiveDirectorySettingsCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="secondaryDnsIpAddress")
    def secondary_dns_ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Secondary DNS IP address used to resolve the Active Directory domain controller's fully qualified domain name.
        """
        return pulumi.get(self, "secondary_dns_ip_address")

    @secondary_dns_ip_address.setter
    def secondary_dns_ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secondary_dns_ip_address", value)


if not MYPY:
    class CacheDirectorySettingsArgsDict(TypedDict):
        """
        Cache Directory Services settings.
        """
        active_directory: NotRequired[pulumi.Input['CacheActiveDirectorySettingsArgsDict']]
        """
        Specifies settings for joining the HPC Cache to an Active Directory domain.
        """
        username_download: NotRequired[pulumi.Input['CacheUsernameDownloadSettingsArgsDict']]
        """
        Specifies settings for Extended Groups. Extended Groups allows users to be members of more than 16 groups.
        """
elif False:
    CacheDirectorySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheDirectorySettingsArgs:
    def __init__(__self__, *,
                 active_directory: Optional[pulumi.Input['CacheActiveDirectorySettingsArgs']] = None,
                 username_download: Optional[pulumi.Input['CacheUsernameDownloadSettingsArgs']] = None):
        """
        Cache Directory Services settings.
        :param pulumi.Input['CacheActiveDirectorySettingsArgs'] active_directory: Specifies settings for joining the HPC Cache to an Active Directory domain.
        :param pulumi.Input['CacheUsernameDownloadSettingsArgs'] username_download: Specifies settings for Extended Groups. Extended Groups allows users to be members of more than 16 groups.
        """
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if username_download is not None:
            pulumi.set(__self__, "username_download", username_download)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional[pulumi.Input['CacheActiveDirectorySettingsArgs']]:
        """
        Specifies settings for joining the HPC Cache to an Active Directory domain.
        """
        return pulumi.get(self, "active_directory")

    @active_directory.setter
    def active_directory(self, value: Optional[pulumi.Input['CacheActiveDirectorySettingsArgs']]):
        pulumi.set(self, "active_directory", value)

    @property
    @pulumi.getter(name="usernameDownload")
    def username_download(self) -> Optional[pulumi.Input['CacheUsernameDownloadSettingsArgs']]:
        """
        Specifies settings for Extended Groups. Extended Groups allows users to be members of more than 16 groups.
        """
        return pulumi.get(self, "username_download")

    @username_download.setter
    def username_download(self, value: Optional[pulumi.Input['CacheUsernameDownloadSettingsArgs']]):
        pulumi.set(self, "username_download", value)


if not MYPY:
    class CacheEncryptionSettingsArgsDict(TypedDict):
        """
        Cache encryption settings.
        """
        key_encryption_key: NotRequired[pulumi.Input['KeyVaultKeyReferenceArgsDict']]
        """
        Specifies the location of the key encryption key in key vault.
        """
        rotation_to_latest_key_version_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether the service will automatically rotate to the newest version of the key in the key vault.
        """
elif False:
    CacheEncryptionSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheEncryptionSettingsArgs:
    def __init__(__self__, *,
                 key_encryption_key: Optional[pulumi.Input['KeyVaultKeyReferenceArgs']] = None,
                 rotation_to_latest_key_version_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Cache encryption settings.
        :param pulumi.Input['KeyVaultKeyReferenceArgs'] key_encryption_key: Specifies the location of the key encryption key in key vault.
        :param pulumi.Input[builtins.bool] rotation_to_latest_key_version_enabled: Specifies whether the service will automatically rotate to the newest version of the key in the key vault.
        """
        if key_encryption_key is not None:
            pulumi.set(__self__, "key_encryption_key", key_encryption_key)
        if rotation_to_latest_key_version_enabled is not None:
            pulumi.set(__self__, "rotation_to_latest_key_version_enabled", rotation_to_latest_key_version_enabled)

    @property
    @pulumi.getter(name="keyEncryptionKey")
    def key_encryption_key(self) -> Optional[pulumi.Input['KeyVaultKeyReferenceArgs']]:
        """
        Specifies the location of the key encryption key in key vault.
        """
        return pulumi.get(self, "key_encryption_key")

    @key_encryption_key.setter
    def key_encryption_key(self, value: Optional[pulumi.Input['KeyVaultKeyReferenceArgs']]):
        pulumi.set(self, "key_encryption_key", value)

    @property
    @pulumi.getter(name="rotationToLatestKeyVersionEnabled")
    def rotation_to_latest_key_version_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether the service will automatically rotate to the newest version of the key in the key vault.
        """
        return pulumi.get(self, "rotation_to_latest_key_version_enabled")

    @rotation_to_latest_key_version_enabled.setter
    def rotation_to_latest_key_version_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "rotation_to_latest_key_version_enabled", value)


if not MYPY:
    class CacheIdentityArgsDict(TypedDict):
        """
        Cache identity properties.
        """
        type: NotRequired[pulumi.Input['CacheIdentityType']]
        """
        The type of identity used for the cache
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A dictionary where each key is a user assigned identity resource ID, and each key's value is an empty dictionary.
        """
elif False:
    CacheIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['CacheIdentityType']] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Cache identity properties.
        :param pulumi.Input['CacheIdentityType'] type: The type of identity used for the cache
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_assigned_identities: A dictionary where each key is a user assigned identity resource ID, and each key's value is an empty dictionary.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['CacheIdentityType']]:
        """
        The type of identity used for the cache
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['CacheIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A dictionary where each key is a user assigned identity resource ID, and each key's value is an empty dictionary.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class CacheNetworkSettingsArgsDict(TypedDict):
        """
        Cache network settings.
        """
        dns_search_domain: NotRequired[pulumi.Input[builtins.str]]
        """
        DNS search domain
        """
        dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        DNS servers for the cache to use.  It will be set from the network configuration if no value is provided.
        """
        mtu: NotRequired[pulumi.Input[builtins.int]]
        """
        The IPv4 maximum transmission unit configured for the subnet.
        """
        ntp_server: NotRequired[pulumi.Input[builtins.str]]
        """
        NTP server IP Address or FQDN for the cache to use. The default is time.windows.com.
        """
elif False:
    CacheNetworkSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheNetworkSettingsArgs:
    def __init__(__self__, *,
                 dns_search_domain: Optional[pulumi.Input[builtins.str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 mtu: Optional[pulumi.Input[builtins.int]] = None,
                 ntp_server: Optional[pulumi.Input[builtins.str]] = None):
        """
        Cache network settings.
        :param pulumi.Input[builtins.str] dns_search_domain: DNS search domain
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] dns_servers: DNS servers for the cache to use.  It will be set from the network configuration if no value is provided.
        :param pulumi.Input[builtins.int] mtu: The IPv4 maximum transmission unit configured for the subnet.
        :param pulumi.Input[builtins.str] ntp_server: NTP server IP Address or FQDN for the cache to use. The default is time.windows.com.
        """
        if dns_search_domain is not None:
            pulumi.set(__self__, "dns_search_domain", dns_search_domain)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if mtu is None:
            mtu = 1500
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if ntp_server is None:
            ntp_server = 'time.windows.com'
        if ntp_server is not None:
            pulumi.set(__self__, "ntp_server", ntp_server)

    @property
    @pulumi.getter(name="dnsSearchDomain")
    def dns_search_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        DNS search domain
        """
        return pulumi.get(self, "dns_search_domain")

    @dns_search_domain.setter
    def dns_search_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dns_search_domain", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        DNS servers for the cache to use.  It will be set from the network configuration if no value is provided.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The IPv4 maximum transmission unit configured for the subnet.
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter(name="ntpServer")
    def ntp_server(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        NTP server IP Address or FQDN for the cache to use. The default is time.windows.com.
        """
        return pulumi.get(self, "ntp_server")

    @ntp_server.setter
    def ntp_server(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ntp_server", value)


if not MYPY:
    class CacheSecuritySettingsArgsDict(TypedDict):
        """
        Cache security settings.
        """
        access_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['NfsAccessPolicyArgsDict']]]]
        """
        NFS access policies defined for this cache.
        """
elif False:
    CacheSecuritySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheSecuritySettingsArgs:
    def __init__(__self__, *,
                 access_policies: Optional[pulumi.Input[Sequence[pulumi.Input['NfsAccessPolicyArgs']]]] = None):
        """
        Cache security settings.
        :param pulumi.Input[Sequence[pulumi.Input['NfsAccessPolicyArgs']]] access_policies: NFS access policies defined for this cache.
        """
        if access_policies is not None:
            pulumi.set(__self__, "access_policies", access_policies)

    @property
    @pulumi.getter(name="accessPolicies")
    def access_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NfsAccessPolicyArgs']]]]:
        """
        NFS access policies defined for this cache.
        """
        return pulumi.get(self, "access_policies")

    @access_policies.setter
    def access_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NfsAccessPolicyArgs']]]]):
        pulumi.set(self, "access_policies", value)


if not MYPY:
    class CacheSkuArgsDict(TypedDict):
        """
        SKU for the cache.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        SKU name for this cache.
        """
elif False:
    CacheSkuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheSkuArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        SKU for the cache.
        :param pulumi.Input[builtins.str] name: SKU name for this cache.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SKU name for this cache.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CacheUpgradeSettingsArgsDict(TypedDict):
        """
        Cache Upgrade Settings.
        """
        scheduled_time: NotRequired[pulumi.Input[builtins.str]]
        """
        When upgradeScheduleEnabled is true, this field holds the user-chosen upgrade time. At the user-chosen time, the firmware update will automatically be installed on the cache.
        """
        upgrade_schedule_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        True if the user chooses to select an installation time between now and firmwareUpdateDeadline. Else the firmware will automatically be installed after firmwareUpdateDeadline if not triggered earlier via the upgrade operation.
        """
elif False:
    CacheUpgradeSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheUpgradeSettingsArgs:
    def __init__(__self__, *,
                 scheduled_time: Optional[pulumi.Input[builtins.str]] = None,
                 upgrade_schedule_enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Cache Upgrade Settings.
        :param pulumi.Input[builtins.str] scheduled_time: When upgradeScheduleEnabled is true, this field holds the user-chosen upgrade time. At the user-chosen time, the firmware update will automatically be installed on the cache.
        :param pulumi.Input[builtins.bool] upgrade_schedule_enabled: True if the user chooses to select an installation time between now and firmwareUpdateDeadline. Else the firmware will automatically be installed after firmwareUpdateDeadline if not triggered earlier via the upgrade operation.
        """
        if scheduled_time is not None:
            pulumi.set(__self__, "scheduled_time", scheduled_time)
        if upgrade_schedule_enabled is not None:
            pulumi.set(__self__, "upgrade_schedule_enabled", upgrade_schedule_enabled)

    @property
    @pulumi.getter(name="scheduledTime")
    def scheduled_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        When upgradeScheduleEnabled is true, this field holds the user-chosen upgrade time. At the user-chosen time, the firmware update will automatically be installed on the cache.
        """
        return pulumi.get(self, "scheduled_time")

    @scheduled_time.setter
    def scheduled_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scheduled_time", value)

    @property
    @pulumi.getter(name="upgradeScheduleEnabled")
    def upgrade_schedule_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        True if the user chooses to select an installation time between now and firmwareUpdateDeadline. Else the firmware will automatically be installed after firmwareUpdateDeadline if not triggered earlier via the upgrade operation.
        """
        return pulumi.get(self, "upgrade_schedule_enabled")

    @upgrade_schedule_enabled.setter
    def upgrade_schedule_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "upgrade_schedule_enabled", value)


if not MYPY:
    class CacheUsernameDownloadSettingsCredentialsArgsDict(TypedDict):
        """
        When present, these are the credentials for the secure LDAP connection.
        """
        bind_dn: NotRequired[pulumi.Input[builtins.str]]
        """
        The Bind Distinguished Name identity to be used in the secure LDAP connection. This value is stored encrypted and not returned on response.
        """
        bind_password: NotRequired[pulumi.Input[builtins.str]]
        """
        The Bind password to be used in the secure LDAP connection. This value is stored encrypted and not returned on response.
        """
elif False:
    CacheUsernameDownloadSettingsCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheUsernameDownloadSettingsCredentialsArgs:
    def __init__(__self__, *,
                 bind_dn: Optional[pulumi.Input[builtins.str]] = None,
                 bind_password: Optional[pulumi.Input[builtins.str]] = None):
        """
        When present, these are the credentials for the secure LDAP connection.
        :param pulumi.Input[builtins.str] bind_dn: The Bind Distinguished Name identity to be used in the secure LDAP connection. This value is stored encrypted and not returned on response.
        :param pulumi.Input[builtins.str] bind_password: The Bind password to be used in the secure LDAP connection. This value is stored encrypted and not returned on response.
        """
        if bind_dn is not None:
            pulumi.set(__self__, "bind_dn", bind_dn)
        if bind_password is not None:
            pulumi.set(__self__, "bind_password", bind_password)

    @property
    @pulumi.getter(name="bindDn")
    def bind_dn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Bind Distinguished Name identity to be used in the secure LDAP connection. This value is stored encrypted and not returned on response.
        """
        return pulumi.get(self, "bind_dn")

    @bind_dn.setter
    def bind_dn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bind_dn", value)

    @property
    @pulumi.getter(name="bindPassword")
    def bind_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Bind password to be used in the secure LDAP connection. This value is stored encrypted and not returned on response.
        """
        return pulumi.get(self, "bind_password")

    @bind_password.setter
    def bind_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bind_password", value)


if not MYPY:
    class CacheUsernameDownloadSettingsArgsDict(TypedDict):
        """
        Settings for Extended Groups username and group download.
        """
        auto_download_certificate: NotRequired[pulumi.Input[builtins.bool]]
        """
        Determines if the certificate should be automatically downloaded. This applies to 'caCertificateURI' only if 'requireValidCertificate' is true.
        """
        ca_certificate_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        The URI of the CA certificate to validate the LDAP secure connection. This field must be populated when 'requireValidCertificate' is set to true.
        """
        credentials: NotRequired[pulumi.Input['CacheUsernameDownloadSettingsCredentialsArgsDict']]
        """
        When present, these are the credentials for the secure LDAP connection.
        """
        encrypt_ldap_connection: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether or not the LDAP connection should be encrypted.
        """
        extended_groups: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether or not Extended Groups is enabled.
        """
        group_file_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        The URI of the file containing group information (in /etc/group file format). This field must be populated when 'usernameSource' is set to 'File'.
        """
        ldap_base_dn: NotRequired[pulumi.Input[builtins.str]]
        """
        The base distinguished name for the LDAP domain.
        """
        ldap_server: NotRequired[pulumi.Input[builtins.str]]
        """
        The fully qualified domain name or IP address of the LDAP server to use.
        """
        require_valid_certificate: NotRequired[pulumi.Input[builtins.bool]]
        """
        Determines if the certificates must be validated by a certificate authority. When true, caCertificateURI must be provided.
        """
        user_file_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        The URI of the file containing user information (in /etc/passwd file format). This field must be populated when 'usernameSource' is set to 'File'.
        """
        username_source: NotRequired[pulumi.Input[Union[builtins.str, 'UsernameSource']]]
        """
        This setting determines how the cache gets username and group names for clients.
        """
elif False:
    CacheUsernameDownloadSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CacheUsernameDownloadSettingsArgs:
    def __init__(__self__, *,
                 auto_download_certificate: Optional[pulumi.Input[builtins.bool]] = None,
                 ca_certificate_uri: Optional[pulumi.Input[builtins.str]] = None,
                 credentials: Optional[pulumi.Input['CacheUsernameDownloadSettingsCredentialsArgs']] = None,
                 encrypt_ldap_connection: Optional[pulumi.Input[builtins.bool]] = None,
                 extended_groups: Optional[pulumi.Input[builtins.bool]] = None,
                 group_file_uri: Optional[pulumi.Input[builtins.str]] = None,
                 ldap_base_dn: Optional[pulumi.Input[builtins.str]] = None,
                 ldap_server: Optional[pulumi.Input[builtins.str]] = None,
                 require_valid_certificate: Optional[pulumi.Input[builtins.bool]] = None,
                 user_file_uri: Optional[pulumi.Input[builtins.str]] = None,
                 username_source: Optional[pulumi.Input[Union[builtins.str, 'UsernameSource']]] = None):
        """
        Settings for Extended Groups username and group download.
        :param pulumi.Input[builtins.bool] auto_download_certificate: Determines if the certificate should be automatically downloaded. This applies to 'caCertificateURI' only if 'requireValidCertificate' is true.
        :param pulumi.Input[builtins.str] ca_certificate_uri: The URI of the CA certificate to validate the LDAP secure connection. This field must be populated when 'requireValidCertificate' is set to true.
        :param pulumi.Input['CacheUsernameDownloadSettingsCredentialsArgs'] credentials: When present, these are the credentials for the secure LDAP connection.
        :param pulumi.Input[builtins.bool] encrypt_ldap_connection: Whether or not the LDAP connection should be encrypted.
        :param pulumi.Input[builtins.bool] extended_groups: Whether or not Extended Groups is enabled.
        :param pulumi.Input[builtins.str] group_file_uri: The URI of the file containing group information (in /etc/group file format). This field must be populated when 'usernameSource' is set to 'File'.
        :param pulumi.Input[builtins.str] ldap_base_dn: The base distinguished name for the LDAP domain.
        :param pulumi.Input[builtins.str] ldap_server: The fully qualified domain name or IP address of the LDAP server to use.
        :param pulumi.Input[builtins.bool] require_valid_certificate: Determines if the certificates must be validated by a certificate authority. When true, caCertificateURI must be provided.
        :param pulumi.Input[builtins.str] user_file_uri: The URI of the file containing user information (in /etc/passwd file format). This field must be populated when 'usernameSource' is set to 'File'.
        :param pulumi.Input[Union[builtins.str, 'UsernameSource']] username_source: This setting determines how the cache gets username and group names for clients.
        """
        if auto_download_certificate is None:
            auto_download_certificate = False
        if auto_download_certificate is not None:
            pulumi.set(__self__, "auto_download_certificate", auto_download_certificate)
        if ca_certificate_uri is not None:
            pulumi.set(__self__, "ca_certificate_uri", ca_certificate_uri)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if encrypt_ldap_connection is None:
            encrypt_ldap_connection = False
        if encrypt_ldap_connection is not None:
            pulumi.set(__self__, "encrypt_ldap_connection", encrypt_ldap_connection)
        if extended_groups is not None:
            pulumi.set(__self__, "extended_groups", extended_groups)
        if group_file_uri is not None:
            pulumi.set(__self__, "group_file_uri", group_file_uri)
        if ldap_base_dn is not None:
            pulumi.set(__self__, "ldap_base_dn", ldap_base_dn)
        if ldap_server is not None:
            pulumi.set(__self__, "ldap_server", ldap_server)
        if require_valid_certificate is None:
            require_valid_certificate = False
        if require_valid_certificate is not None:
            pulumi.set(__self__, "require_valid_certificate", require_valid_certificate)
        if user_file_uri is not None:
            pulumi.set(__self__, "user_file_uri", user_file_uri)
        if username_source is None:
            username_source = 'None'
        if username_source is not None:
            pulumi.set(__self__, "username_source", username_source)

    @property
    @pulumi.getter(name="autoDownloadCertificate")
    def auto_download_certificate(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Determines if the certificate should be automatically downloaded. This applies to 'caCertificateURI' only if 'requireValidCertificate' is true.
        """
        return pulumi.get(self, "auto_download_certificate")

    @auto_download_certificate.setter
    def auto_download_certificate(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "auto_download_certificate", value)

    @property
    @pulumi.getter(name="caCertificateURI")
    def ca_certificate_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URI of the CA certificate to validate the LDAP secure connection. This field must be populated when 'requireValidCertificate' is set to true.
        """
        return pulumi.get(self, "ca_certificate_uri")

    @ca_certificate_uri.setter
    def ca_certificate_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ca_certificate_uri", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['CacheUsernameDownloadSettingsCredentialsArgs']]:
        """
        When present, these are the credentials for the secure LDAP connection.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['CacheUsernameDownloadSettingsCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="encryptLdapConnection")
    def encrypt_ldap_connection(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether or not the LDAP connection should be encrypted.
        """
        return pulumi.get(self, "encrypt_ldap_connection")

    @encrypt_ldap_connection.setter
    def encrypt_ldap_connection(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "encrypt_ldap_connection", value)

    @property
    @pulumi.getter(name="extendedGroups")
    def extended_groups(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether or not Extended Groups is enabled.
        """
        return pulumi.get(self, "extended_groups")

    @extended_groups.setter
    def extended_groups(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "extended_groups", value)

    @property
    @pulumi.getter(name="groupFileURI")
    def group_file_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URI of the file containing group information (in /etc/group file format). This field must be populated when 'usernameSource' is set to 'File'.
        """
        return pulumi.get(self, "group_file_uri")

    @group_file_uri.setter
    def group_file_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group_file_uri", value)

    @property
    @pulumi.getter(name="ldapBaseDN")
    def ldap_base_dn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The base distinguished name for the LDAP domain.
        """
        return pulumi.get(self, "ldap_base_dn")

    @ldap_base_dn.setter
    def ldap_base_dn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ldap_base_dn", value)

    @property
    @pulumi.getter(name="ldapServer")
    def ldap_server(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The fully qualified domain name or IP address of the LDAP server to use.
        """
        return pulumi.get(self, "ldap_server")

    @ldap_server.setter
    def ldap_server(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ldap_server", value)

    @property
    @pulumi.getter(name="requireValidCertificate")
    def require_valid_certificate(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Determines if the certificates must be validated by a certificate authority. When true, caCertificateURI must be provided.
        """
        return pulumi.get(self, "require_valid_certificate")

    @require_valid_certificate.setter
    def require_valid_certificate(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_valid_certificate", value)

    @property
    @pulumi.getter(name="userFileURI")
    def user_file_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URI of the file containing user information (in /etc/passwd file format). This field must be populated when 'usernameSource' is set to 'File'.
        """
        return pulumi.get(self, "user_file_uri")

    @user_file_uri.setter
    def user_file_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_file_uri", value)

    @property
    @pulumi.getter(name="usernameSource")
    def username_source(self) -> Optional[pulumi.Input[Union[builtins.str, 'UsernameSource']]]:
        """
        This setting determines how the cache gets username and group names for clients.
        """
        return pulumi.get(self, "username_source")

    @username_source.setter
    def username_source(self, value: Optional[pulumi.Input[Union[builtins.str, 'UsernameSource']]]):
        pulumi.set(self, "username_source", value)


if not MYPY:
    class ClfsTargetArgsDict(TypedDict):
        """
        Properties pertaining to the ClfsTarget
        """
        target: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ID of storage container.
        """
elif False:
    ClfsTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClfsTargetArgs:
    def __init__(__self__, *,
                 target: Optional[pulumi.Input[builtins.str]] = None):
        """
        Properties pertaining to the ClfsTarget
        :param pulumi.Input[builtins.str] target: Resource ID of storage container.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ID of storage container.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class KeyVaultKeyReferenceSourceVaultArgsDict(TypedDict):
        """
        Describes a resource Id to source key vault.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource Id.
        """
elif False:
    KeyVaultKeyReferenceSourceVaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyVaultKeyReferenceSourceVaultArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Describes a resource Id to source key vault.
        :param pulumi.Input[builtins.str] id: Resource Id.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class KeyVaultKeyReferenceArgsDict(TypedDict):
        """
        Describes a reference to key vault key.
        """
        key_url: pulumi.Input[builtins.str]
        """
        The URL referencing a key encryption key in key vault.
        """
        source_vault: pulumi.Input['KeyVaultKeyReferenceSourceVaultArgsDict']
        """
        Describes a resource Id to source key vault.
        """
elif False:
    KeyVaultKeyReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyVaultKeyReferenceArgs:
    def __init__(__self__, *,
                 key_url: pulumi.Input[builtins.str],
                 source_vault: pulumi.Input['KeyVaultKeyReferenceSourceVaultArgs']):
        """
        Describes a reference to key vault key.
        :param pulumi.Input[builtins.str] key_url: The URL referencing a key encryption key in key vault.
        :param pulumi.Input['KeyVaultKeyReferenceSourceVaultArgs'] source_vault: Describes a resource Id to source key vault.
        """
        pulumi.set(__self__, "key_url", key_url)
        pulumi.set(__self__, "source_vault", source_vault)

    @property
    @pulumi.getter(name="keyUrl")
    def key_url(self) -> pulumi.Input[builtins.str]:
        """
        The URL referencing a key encryption key in key vault.
        """
        return pulumi.get(self, "key_url")

    @key_url.setter
    def key_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key_url", value)

    @property
    @pulumi.getter(name="sourceVault")
    def source_vault(self) -> pulumi.Input['KeyVaultKeyReferenceSourceVaultArgs']:
        """
        Describes a resource Id to source key vault.
        """
        return pulumi.get(self, "source_vault")

    @source_vault.setter
    def source_vault(self, value: pulumi.Input['KeyVaultKeyReferenceSourceVaultArgs']):
        pulumi.set(self, "source_vault", value)


if not MYPY:
    class NamespaceJunctionArgsDict(TypedDict):
        """
        A namespace junction.
        """
        namespace_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Namespace path on a cache for a Storage Target.
        """
        nfs_access_policy: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the access policy applied to this junction.
        """
        nfs_export: NotRequired[pulumi.Input[builtins.str]]
        """
        NFS export where targetPath exists.
        """
        target_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path in Storage Target to which namespacePath points.
        """
elif False:
    NamespaceJunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceJunctionArgs:
    def __init__(__self__, *,
                 namespace_path: Optional[pulumi.Input[builtins.str]] = None,
                 nfs_access_policy: Optional[pulumi.Input[builtins.str]] = None,
                 nfs_export: Optional[pulumi.Input[builtins.str]] = None,
                 target_path: Optional[pulumi.Input[builtins.str]] = None):
        """
        A namespace junction.
        :param pulumi.Input[builtins.str] namespace_path: Namespace path on a cache for a Storage Target.
        :param pulumi.Input[builtins.str] nfs_access_policy: Name of the access policy applied to this junction.
        :param pulumi.Input[builtins.str] nfs_export: NFS export where targetPath exists.
        :param pulumi.Input[builtins.str] target_path: Path in Storage Target to which namespacePath points.
        """
        if namespace_path is not None:
            pulumi.set(__self__, "namespace_path", namespace_path)
        if nfs_access_policy is None:
            nfs_access_policy = 'default'
        if nfs_access_policy is not None:
            pulumi.set(__self__, "nfs_access_policy", nfs_access_policy)
        if nfs_export is not None:
            pulumi.set(__self__, "nfs_export", nfs_export)
        if target_path is not None:
            pulumi.set(__self__, "target_path", target_path)

    @property
    @pulumi.getter(name="namespacePath")
    def namespace_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Namespace path on a cache for a Storage Target.
        """
        return pulumi.get(self, "namespace_path")

    @namespace_path.setter
    def namespace_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace_path", value)

    @property
    @pulumi.getter(name="nfsAccessPolicy")
    def nfs_access_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the access policy applied to this junction.
        """
        return pulumi.get(self, "nfs_access_policy")

    @nfs_access_policy.setter
    def nfs_access_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nfs_access_policy", value)

    @property
    @pulumi.getter(name="nfsExport")
    def nfs_export(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        NFS export where targetPath exists.
        """
        return pulumi.get(self, "nfs_export")

    @nfs_export.setter
    def nfs_export(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nfs_export", value)

    @property
    @pulumi.getter(name="targetPath")
    def target_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path in Storage Target to which namespacePath points.
        """
        return pulumi.get(self, "target_path")

    @target_path.setter
    def target_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target_path", value)


if not MYPY:
    class Nfs3TargetArgsDict(TypedDict):
        """
        Properties pertaining to the Nfs3Target
        """
        target: NotRequired[pulumi.Input[builtins.str]]
        """
        IP address or host name of an NFSv3 host (e.g., 10.0.44.44).
        """
        usage_model: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifies the StorageCache usage model to be used for this storage target.
        """
        verification_timer: NotRequired[pulumi.Input[builtins.int]]
        """
        Amount of time (in seconds) the cache waits before it checks the back-end storage for file updates.
        """
        write_back_timer: NotRequired[pulumi.Input[builtins.int]]
        """
        Amount of time (in seconds) the cache waits after the last file change before it copies the changed file to back-end storage.
        """
elif False:
    Nfs3TargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Nfs3TargetArgs:
    def __init__(__self__, *,
                 target: Optional[pulumi.Input[builtins.str]] = None,
                 usage_model: Optional[pulumi.Input[builtins.str]] = None,
                 verification_timer: Optional[pulumi.Input[builtins.int]] = None,
                 write_back_timer: Optional[pulumi.Input[builtins.int]] = None):
        """
        Properties pertaining to the Nfs3Target
        :param pulumi.Input[builtins.str] target: IP address or host name of an NFSv3 host (e.g., 10.0.44.44).
        :param pulumi.Input[builtins.str] usage_model: Identifies the StorageCache usage model to be used for this storage target.
        :param pulumi.Input[builtins.int] verification_timer: Amount of time (in seconds) the cache waits before it checks the back-end storage for file updates.
        :param pulumi.Input[builtins.int] write_back_timer: Amount of time (in seconds) the cache waits after the last file change before it copies the changed file to back-end storage.
        """
        if target is not None:
            pulumi.set(__self__, "target", target)
        if usage_model is not None:
            pulumi.set(__self__, "usage_model", usage_model)
        if verification_timer is not None:
            pulumi.set(__self__, "verification_timer", verification_timer)
        if write_back_timer is not None:
            pulumi.set(__self__, "write_back_timer", write_back_timer)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IP address or host name of an NFSv3 host (e.g., 10.0.44.44).
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="usageModel")
    def usage_model(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifies the StorageCache usage model to be used for this storage target.
        """
        return pulumi.get(self, "usage_model")

    @usage_model.setter
    def usage_model(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "usage_model", value)

    @property
    @pulumi.getter(name="verificationTimer")
    def verification_timer(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Amount of time (in seconds) the cache waits before it checks the back-end storage for file updates.
        """
        return pulumi.get(self, "verification_timer")

    @verification_timer.setter
    def verification_timer(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "verification_timer", value)

    @property
    @pulumi.getter(name="writeBackTimer")
    def write_back_timer(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Amount of time (in seconds) the cache waits after the last file change before it copies the changed file to back-end storage.
        """
        return pulumi.get(self, "write_back_timer")

    @write_back_timer.setter
    def write_back_timer(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "write_back_timer", value)


if not MYPY:
    class NfsAccessPolicyArgsDict(TypedDict):
        """
        A set of rules describing access policies applied to NFSv3 clients of the cache.
        """
        access_rules: pulumi.Input[Sequence[pulumi.Input['NfsAccessRuleArgsDict']]]
        """
        The set of rules describing client accesses allowed under this policy.
        """
        name: pulumi.Input[builtins.str]
        """
        Name identifying this policy. Access Policy names are not case sensitive.
        """
elif False:
    NfsAccessPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NfsAccessPolicyArgs:
    def __init__(__self__, *,
                 access_rules: pulumi.Input[Sequence[pulumi.Input['NfsAccessRuleArgs']]],
                 name: pulumi.Input[builtins.str]):
        """
        A set of rules describing access policies applied to NFSv3 clients of the cache.
        :param pulumi.Input[Sequence[pulumi.Input['NfsAccessRuleArgs']]] access_rules: The set of rules describing client accesses allowed under this policy.
        :param pulumi.Input[builtins.str] name: Name identifying this policy. Access Policy names are not case sensitive.
        """
        pulumi.set(__self__, "access_rules", access_rules)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="accessRules")
    def access_rules(self) -> pulumi.Input[Sequence[pulumi.Input['NfsAccessRuleArgs']]]:
        """
        The set of rules describing client accesses allowed under this policy.
        """
        return pulumi.get(self, "access_rules")

    @access_rules.setter
    def access_rules(self, value: pulumi.Input[Sequence[pulumi.Input['NfsAccessRuleArgs']]]):
        pulumi.set(self, "access_rules", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name identifying this policy. Access Policy names are not case sensitive.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class NfsAccessRuleArgsDict(TypedDict):
        """
        Rule to place restrictions on portions of the cache namespace being presented to clients.
        """
        access: pulumi.Input[Union[builtins.str, 'NfsAccessRuleAccess']]
        """
        Access allowed by this rule.
        """
        scope: pulumi.Input[Union[builtins.str, 'NfsAccessRuleScope']]
        """
        Scope for this rule. The scope and filter determine which clients match the rule.
        """
        anonymous_gid: NotRequired[pulumi.Input[builtins.str]]
        """
        GID value that replaces 0 when rootSquash is true. This will use the value of anonymousUID if not provided.
        """
        anonymous_uid: NotRequired[pulumi.Input[builtins.str]]
        """
        UID value that replaces 0 when rootSquash is true. 65534 will be used if not provided.
        """
        filter: NotRequired[pulumi.Input[builtins.str]]
        """
        Filter applied to the scope for this rule. The filter's format depends on its scope. 'default' scope matches all clients and has no filter value. 'network' scope takes a filter in CIDR format (for example, 10.99.1.0/24). 'host' takes an IP address or fully qualified domain name as filter. If a client does not match any filter rule and there is no default rule, access is denied.
        """
        root_squash: NotRequired[pulumi.Input[builtins.bool]]
        """
        Map root accesses to anonymousUID and anonymousGID.
        """
        submount_access: NotRequired[pulumi.Input[builtins.bool]]
        """
        For the default policy, allow access to subdirectories under the root export. If this is set to no, clients can only mount the path '/'. If set to yes, clients can mount a deeper path, like '/a/b'.
        """
        suid: NotRequired[pulumi.Input[builtins.bool]]
        """
        Allow SUID semantics.
        """
elif False:
    NfsAccessRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NfsAccessRuleArgs:
    def __init__(__self__, *,
                 access: pulumi.Input[Union[builtins.str, 'NfsAccessRuleAccess']],
                 scope: pulumi.Input[Union[builtins.str, 'NfsAccessRuleScope']],
                 anonymous_gid: Optional[pulumi.Input[builtins.str]] = None,
                 anonymous_uid: Optional[pulumi.Input[builtins.str]] = None,
                 filter: Optional[pulumi.Input[builtins.str]] = None,
                 root_squash: Optional[pulumi.Input[builtins.bool]] = None,
                 submount_access: Optional[pulumi.Input[builtins.bool]] = None,
                 suid: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Rule to place restrictions on portions of the cache namespace being presented to clients.
        :param pulumi.Input[Union[builtins.str, 'NfsAccessRuleAccess']] access: Access allowed by this rule.
        :param pulumi.Input[Union[builtins.str, 'NfsAccessRuleScope']] scope: Scope for this rule. The scope and filter determine which clients match the rule.
        :param pulumi.Input[builtins.str] anonymous_gid: GID value that replaces 0 when rootSquash is true. This will use the value of anonymousUID if not provided.
        :param pulumi.Input[builtins.str] anonymous_uid: UID value that replaces 0 when rootSquash is true. 65534 will be used if not provided.
        :param pulumi.Input[builtins.str] filter: Filter applied to the scope for this rule. The filter's format depends on its scope. 'default' scope matches all clients and has no filter value. 'network' scope takes a filter in CIDR format (for example, 10.99.1.0/24). 'host' takes an IP address or fully qualified domain name as filter. If a client does not match any filter rule and there is no default rule, access is denied.
        :param pulumi.Input[builtins.bool] root_squash: Map root accesses to anonymousUID and anonymousGID.
        :param pulumi.Input[builtins.bool] submount_access: For the default policy, allow access to subdirectories under the root export. If this is set to no, clients can only mount the path '/'. If set to yes, clients can mount a deeper path, like '/a/b'.
        :param pulumi.Input[builtins.bool] suid: Allow SUID semantics.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "scope", scope)
        if anonymous_gid is not None:
            pulumi.set(__self__, "anonymous_gid", anonymous_gid)
        if anonymous_uid is not None:
            pulumi.set(__self__, "anonymous_uid", anonymous_uid)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if root_squash is not None:
            pulumi.set(__self__, "root_squash", root_squash)
        if submount_access is not None:
            pulumi.set(__self__, "submount_access", submount_access)
        if suid is not None:
            pulumi.set(__self__, "suid", suid)

    @property
    @pulumi.getter
    def access(self) -> pulumi.Input[Union[builtins.str, 'NfsAccessRuleAccess']]:
        """
        Access allowed by this rule.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: pulumi.Input[Union[builtins.str, 'NfsAccessRuleAccess']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[Union[builtins.str, 'NfsAccessRuleScope']]:
        """
        Scope for this rule. The scope and filter determine which clients match the rule.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[Union[builtins.str, 'NfsAccessRuleScope']]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="anonymousGID")
    def anonymous_gid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        GID value that replaces 0 when rootSquash is true. This will use the value of anonymousUID if not provided.
        """
        return pulumi.get(self, "anonymous_gid")

    @anonymous_gid.setter
    def anonymous_gid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "anonymous_gid", value)

    @property
    @pulumi.getter(name="anonymousUID")
    def anonymous_uid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        UID value that replaces 0 when rootSquash is true. 65534 will be used if not provided.
        """
        return pulumi.get(self, "anonymous_uid")

    @anonymous_uid.setter
    def anonymous_uid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "anonymous_uid", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Filter applied to the scope for this rule. The filter's format depends on its scope. 'default' scope matches all clients and has no filter value. 'network' scope takes a filter in CIDR format (for example, 10.99.1.0/24). 'host' takes an IP address or fully qualified domain name as filter. If a client does not match any filter rule and there is no default rule, access is denied.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="rootSquash")
    def root_squash(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Map root accesses to anonymousUID and anonymousGID.
        """
        return pulumi.get(self, "root_squash")

    @root_squash.setter
    def root_squash(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "root_squash", value)

    @property
    @pulumi.getter(name="submountAccess")
    def submount_access(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        For the default policy, allow access to subdirectories under the root export. If this is set to no, clients can only mount the path '/'. If set to yes, clients can mount a deeper path, like '/a/b'.
        """
        return pulumi.get(self, "submount_access")

    @submount_access.setter
    def submount_access(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "submount_access", value)

    @property
    @pulumi.getter
    def suid(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Allow SUID semantics.
        """
        return pulumi.get(self, "suid")

    @suid.setter
    def suid(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "suid", value)


if not MYPY:
    class SkuNameDict(TypedDict):
        """
        SKU for the resource.
        """
        name: NotRequired[builtins.str]
        """
        SKU name for this resource.
        """
elif False:
    SkuNameDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuName:
    def __init__(__self__, *,
                 name: Optional[builtins.str] = None):
        """
        SKU for the resource.
        :param builtins.str name: SKU name for this resource.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        SKU name for this resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SkuNameArgsDict(TypedDict):
        """
        SKU for the resource.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        SKU name for this resource.
        """
elif False:
    SkuNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SkuNameArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        SKU for the resource.
        :param pulumi.Input[builtins.str] name: SKU name for this resource.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SKU name for this resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class UnknownTargetArgsDict(TypedDict):
        """
        Properties pertaining to the UnknownTarget
        """
        attributes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Dictionary of string->string pairs containing information about the Storage Target.
        """
elif False:
    UnknownTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UnknownTargetArgs:
    def __init__(__self__, *,
                 attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        Properties pertaining to the UnknownTarget
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] attributes: Dictionary of string->string pairs containing information about the Storage Target.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Dictionary of string->string pairs containing information about the Storage Target.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "attributes", value)


