# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = ['ImportJobArgs', 'ImportJob']

@pulumi.input_type
class ImportJobArgs:
    def __init__(__self__, *,
                 aml_filesystem_name: pulumi.Input[str],
                 resource_group_name: pulumi.Input[str],
                 conflict_resolution_mode: Optional[pulumi.Input[Union[str, 'ConflictResolutionMode']]] = None,
                 import_job_name: Optional[pulumi.Input[str]] = None,
                 import_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 maximum_errors: Optional[pulumi.Input[int]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        The set of arguments for constructing a ImportJob resource.
        :param pulumi.Input[str] aml_filesystem_name: Name for the AML file system. Allows alphanumerics, underscores, and hyphens. Start and end with alphanumeric.
        :param pulumi.Input[str] resource_group_name: The name of the resource group. The name is case insensitive.
        :param pulumi.Input[Union[str, 'ConflictResolutionMode']] conflict_resolution_mode: How the import job will handle conflicts. For example, if the import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution modes.
        :param pulumi.Input[str] import_job_name: Name for the import job. Allows alphanumerics, underscores, and hyphens. Start and end with alphanumeric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] import_prefixes: An array of blob paths/prefixes that get imported into the cluster namespace. It has '/' as the default value.
        :param pulumi.Input[str] location: The geo-location where the resource lives
        :param pulumi.Input[int] maximum_errors: Total non-conflict oriented errors the import job will tolerate before exiting with failure. -1 means infinite. 0 means exit immediately and is the default.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Resource tags.
        """
        pulumi.set(__self__, "aml_filesystem_name", aml_filesystem_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        if conflict_resolution_mode is None:
            conflict_resolution_mode = 'Fail'
        if conflict_resolution_mode is not None:
            pulumi.set(__self__, "conflict_resolution_mode", conflict_resolution_mode)
        if import_job_name is not None:
            pulumi.set(__self__, "import_job_name", import_job_name)
        if import_prefixes is not None:
            pulumi.set(__self__, "import_prefixes", import_prefixes)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maximum_errors is None:
            maximum_errors = 0
        if maximum_errors is not None:
            pulumi.set(__self__, "maximum_errors", maximum_errors)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="amlFilesystemName")
    def aml_filesystem_name(self) -> pulumi.Input[str]:
        """
        Name for the AML file system. Allows alphanumerics, underscores, and hyphens. Start and end with alphanumeric.
        """
        return pulumi.get(self, "aml_filesystem_name")

    @aml_filesystem_name.setter
    def aml_filesystem_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "aml_filesystem_name", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[str]:
        """
        The name of the resource group. The name is case insensitive.
        """
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter(name="conflictResolutionMode")
    def conflict_resolution_mode(self) -> Optional[pulumi.Input[Union[str, 'ConflictResolutionMode']]]:
        """
        How the import job will handle conflicts. For example, if the import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution modes.
        """
        return pulumi.get(self, "conflict_resolution_mode")

    @conflict_resolution_mode.setter
    def conflict_resolution_mode(self, value: Optional[pulumi.Input[Union[str, 'ConflictResolutionMode']]]):
        pulumi.set(self, "conflict_resolution_mode", value)

    @property
    @pulumi.getter(name="importJobName")
    def import_job_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for the import job. Allows alphanumerics, underscores, and hyphens. Start and end with alphanumeric.
        """
        return pulumi.get(self, "import_job_name")

    @import_job_name.setter
    def import_job_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "import_job_name", value)

    @property
    @pulumi.getter(name="importPrefixes")
    def import_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of blob paths/prefixes that get imported into the cluster namespace. It has '/' as the default value.
        """
        return pulumi.get(self, "import_prefixes")

    @import_prefixes.setter
    def import_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "import_prefixes", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="maximumErrors")
    def maximum_errors(self) -> Optional[pulumi.Input[int]]:
        """
        Total non-conflict oriented errors the import job will tolerate before exiting with failure. -1 means infinite. 0 means exit immediately and is the default.
        """
        return pulumi.get(self, "maximum_errors")

    @maximum_errors.setter
    def maximum_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_errors", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


class ImportJob(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 aml_filesystem_name: Optional[pulumi.Input[str]] = None,
                 conflict_resolution_mode: Optional[pulumi.Input[Union[str, 'ConflictResolutionMode']]] = None,
                 import_job_name: Optional[pulumi.Input[str]] = None,
                 import_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 maximum_errors: Optional[pulumi.Input[int]] = None,
                 resource_group_name: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 __props__=None):
        """
        An import job instance. Follows Azure Resource Manager standards: https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] aml_filesystem_name: Name for the AML file system. Allows alphanumerics, underscores, and hyphens. Start and end with alphanumeric.
        :param pulumi.Input[Union[str, 'ConflictResolutionMode']] conflict_resolution_mode: How the import job will handle conflicts. For example, if the import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution modes.
        :param pulumi.Input[str] import_job_name: Name for the import job. Allows alphanumerics, underscores, and hyphens. Start and end with alphanumeric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] import_prefixes: An array of blob paths/prefixes that get imported into the cluster namespace. It has '/' as the default value.
        :param pulumi.Input[str] location: The geo-location where the resource lives
        :param pulumi.Input[int] maximum_errors: Total non-conflict oriented errors the import job will tolerate before exiting with failure. -1 means infinite. 0 means exit immediately and is the default.
        :param pulumi.Input[str] resource_group_name: The name of the resource group. The name is case insensitive.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Resource tags.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ImportJobArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        An import job instance. Follows Azure Resource Manager standards: https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md

        :param str resource_name: The name of the resource.
        :param ImportJobArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ImportJobArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 aml_filesystem_name: Optional[pulumi.Input[str]] = None,
                 conflict_resolution_mode: Optional[pulumi.Input[Union[str, 'ConflictResolutionMode']]] = None,
                 import_job_name: Optional[pulumi.Input[str]] = None,
                 import_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 maximum_errors: Optional[pulumi.Input[int]] = None,
                 resource_group_name: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ImportJobArgs.__new__(ImportJobArgs)

            if aml_filesystem_name is None and not opts.urn:
                raise TypeError("Missing required property 'aml_filesystem_name'")
            __props__.__dict__["aml_filesystem_name"] = aml_filesystem_name
            if conflict_resolution_mode is None:
                conflict_resolution_mode = 'Fail'
            __props__.__dict__["conflict_resolution_mode"] = conflict_resolution_mode
            __props__.__dict__["import_job_name"] = import_job_name
            __props__.__dict__["import_prefixes"] = import_prefixes
            __props__.__dict__["location"] = location
            if maximum_errors is None:
                maximum_errors = 0
            __props__.__dict__["maximum_errors"] = maximum_errors
            if resource_group_name is None and not opts.urn:
                raise TypeError("Missing required property 'resource_group_name'")
            __props__.__dict__["resource_group_name"] = resource_group_name
            __props__.__dict__["tags"] = tags
            __props__.__dict__["blobs_imported_per_second"] = None
            __props__.__dict__["blobs_walked_per_second"] = None
            __props__.__dict__["last_completion_time"] = None
            __props__.__dict__["last_started_time"] = None
            __props__.__dict__["name"] = None
            __props__.__dict__["provisioning_state"] = None
            __props__.__dict__["state"] = None
            __props__.__dict__["status_message"] = None
            __props__.__dict__["system_data"] = None
            __props__.__dict__["total_blobs_imported"] = None
            __props__.__dict__["total_blobs_walked"] = None
            __props__.__dict__["total_conflicts"] = None
            __props__.__dict__["total_errors"] = None
            __props__.__dict__["type"] = None
        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="azure-native:storagecache/v20240301:importJob"), pulumi.Alias(type_="azure-native:storagecache:ImportJob"), pulumi.Alias(type_="azure-native:storagecache:importJob")])
        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
        super(ImportJob, __self__).__init__(
            'azure-native:storagecache/v20240301:ImportJob',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None) -> 'ImportJob':
        """
        Get an existing ImportJob resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = ImportJobArgs.__new__(ImportJobArgs)

        __props__.__dict__["blobs_imported_per_second"] = None
        __props__.__dict__["blobs_walked_per_second"] = None
        __props__.__dict__["conflict_resolution_mode"] = None
        __props__.__dict__["import_prefixes"] = None
        __props__.__dict__["last_completion_time"] = None
        __props__.__dict__["last_started_time"] = None
        __props__.__dict__["location"] = None
        __props__.__dict__["maximum_errors"] = None
        __props__.__dict__["name"] = None
        __props__.__dict__["provisioning_state"] = None
        __props__.__dict__["state"] = None
        __props__.__dict__["status_message"] = None
        __props__.__dict__["system_data"] = None
        __props__.__dict__["tags"] = None
        __props__.__dict__["total_blobs_imported"] = None
        __props__.__dict__["total_blobs_walked"] = None
        __props__.__dict__["total_conflicts"] = None
        __props__.__dict__["total_errors"] = None
        __props__.__dict__["type"] = None
        return ImportJob(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="blobsImportedPerSecond")
    def blobs_imported_per_second(self) -> pulumi.Output[float]:
        """
        A recent and frequently updated rate of total files, directories, and symlinks imported per second.
        """
        return pulumi.get(self, "blobs_imported_per_second")

    @property
    @pulumi.getter(name="blobsWalkedPerSecond")
    def blobs_walked_per_second(self) -> pulumi.Output[float]:
        """
        A recent and frequently updated rate of blobs walked per second.
        """
        return pulumi.get(self, "blobs_walked_per_second")

    @property
    @pulumi.getter(name="conflictResolutionMode")
    def conflict_resolution_mode(self) -> pulumi.Output[Optional[str]]:
        """
        How the import job will handle conflicts. For example, if the import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or was not previously imported. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/ for a thorough explanation of these resolution modes.
        """
        return pulumi.get(self, "conflict_resolution_mode")

    @property
    @pulumi.getter(name="importPrefixes")
    def import_prefixes(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        An array of blob paths/prefixes that get imported into the cluster namespace. It has '/' as the default value.
        """
        return pulumi.get(self, "import_prefixes")

    @property
    @pulumi.getter(name="lastCompletionTime")
    def last_completion_time(self) -> pulumi.Output[str]:
        """
        The time of the last completed archive operation
        """
        return pulumi.get(self, "last_completion_time")

    @property
    @pulumi.getter(name="lastStartedTime")
    def last_started_time(self) -> pulumi.Output[str]:
        """
        The time the latest archive operation started
        """
        return pulumi.get(self, "last_started_time")

    @property
    @pulumi.getter
    def location(self) -> pulumi.Output[str]:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="maximumErrors")
    def maximum_errors(self) -> pulumi.Output[Optional[int]]:
        """
        Total non-conflict oriented errors the import job will tolerate before exiting with failure. -1 means infinite. 0 means exit immediately and is the default.
        """
        return pulumi.get(self, "maximum_errors")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> pulumi.Output[str]:
        """
        ARM provisioning state.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def state(self) -> pulumi.Output[str]:
        """
        The state of the import job. InProgress indicates the import is still running. Canceled indicates it has been canceled by the user. Completed indicates import finished, successfully importing all discovered blobs into the Lustre namespace. CompletedPartial indicates the import finished but some blobs either were found to be conflicting and could not be imported or other errors were encountered. Failed means the import was unable to complete due to a fatal error.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="statusMessage")
    def status_message(self) -> pulumi.Output[str]:
        """
        The status message of the import job.
        """
        return pulumi.get(self, "status_message")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> pulumi.Output['outputs.SystemDataResponse']:
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def tags(self) -> pulumi.Output[Optional[Mapping[str, str]]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="totalBlobsImported")
    def total_blobs_imported(self) -> pulumi.Output[float]:
        """
        The total blobs that have been imported since import began.
        """
        return pulumi.get(self, "total_blobs_imported")

    @property
    @pulumi.getter(name="totalBlobsWalked")
    def total_blobs_walked(self) -> pulumi.Output[float]:
        """
        The total blob objects walked.
        """
        return pulumi.get(self, "total_blobs_walked")

    @property
    @pulumi.getter(name="totalConflicts")
    def total_conflicts(self) -> pulumi.Output[int]:
        """
        Number of conflicts in the import job.
        """
        return pulumi.get(self, "total_conflicts")

    @property
    @pulumi.getter(name="totalErrors")
    def total_errors(self) -> pulumi.Output[int]:
        """
        Number of errors in the import job.
        """
        return pulumi.get(self, "total_errors")

    @property
    @pulumi.getter
    def type(self) -> pulumi.Output[str]:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

