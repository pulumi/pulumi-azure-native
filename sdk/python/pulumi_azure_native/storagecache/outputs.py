# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AmlFilesystemArchiveResponse',
    'AmlFilesystemArchiveResponseStatus',
    'AmlFilesystemClientInfoResponse',
    'AmlFilesystemContainerStorageInterfaceResponse',
    'AmlFilesystemEncryptionSettingsResponse',
    'AmlFilesystemHealthResponse',
    'AmlFilesystemHsmSettingsResponse',
    'AmlFilesystemIdentityResponse',
    'AmlFilesystemResponseHsm',
    'AmlFilesystemResponseMaintenanceWindow',
    'BlobNfsTargetResponse',
    'CacheActiveDirectorySettingsResponse',
    'CacheActiveDirectorySettingsResponseCredentials',
    'CacheDirectorySettingsResponse',
    'CacheEncryptionSettingsResponse',
    'CacheHealthResponse',
    'CacheIdentityResponse',
    'CacheIdentityResponseUserAssignedIdentities',
    'CacheNetworkSettingsResponse',
    'CacheResponseSku',
    'CacheSecuritySettingsResponse',
    'CacheUpgradeSettingsResponse',
    'CacheUpgradeStatusResponse',
    'CacheUsernameDownloadSettingsResponse',
    'CacheUsernameDownloadSettingsResponseCredentials',
    'ClfsTargetResponse',
    'ConditionResponse',
    'KeyVaultKeyReferenceResponse',
    'KeyVaultKeyReferenceResponseSourceVault',
    'NamespaceJunctionResponse',
    'Nfs3TargetResponse',
    'NfsAccessPolicyResponse',
    'NfsAccessRuleResponse',
    'PrimingJobResponse',
    'SkuNameResponse',
    'StorageTargetSpaceAllocationResponse',
    'SystemDataResponse',
    'UnknownTargetResponse',
    'UserAssignedIdentitiesResponseUserAssignedIdentities',
]

@pulumi.output_type
class AmlFilesystemArchiveResponse(dict):
    """
    Information about the AML file system archive
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filesystemPath":
            suggest = "filesystem_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlFilesystemArchiveResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlFilesystemArchiveResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlFilesystemArchiveResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filesystem_path: str,
                 status: 'outputs.AmlFilesystemArchiveResponseStatus'):
        """
        Information about the AML file system archive
        :param str filesystem_path: Lustre file system path to archive relative to the file system root.  Specify '/' to archive all modified data.
        :param 'AmlFilesystemArchiveResponseStatus' status: The status of the archive
        """
        AmlFilesystemArchiveResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filesystem_path=filesystem_path,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filesystem_path: Optional[str] = None,
             status: Optional['outputs.AmlFilesystemArchiveResponseStatus'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if filesystem_path is None and 'filesystemPath' in kwargs:
            filesystem_path = kwargs['filesystemPath']
        if filesystem_path is None:
            raise TypeError("Missing 'filesystem_path' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")

        _setter("filesystem_path", filesystem_path)
        _setter("status", status)

    @property
    @pulumi.getter(name="filesystemPath")
    def filesystem_path(self) -> str:
        """
        Lustre file system path to archive relative to the file system root.  Specify '/' to archive all modified data.
        """
        return pulumi.get(self, "filesystem_path")

    @property
    @pulumi.getter
    def status(self) -> 'outputs.AmlFilesystemArchiveResponseStatus':
        """
        The status of the archive
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class AmlFilesystemArchiveResponseStatus(dict):
    """
    The status of the archive
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorCode":
            suggest = "error_code"
        elif key == "errorMessage":
            suggest = "error_message"
        elif key == "lastCompletionTime":
            suggest = "last_completion_time"
        elif key == "lastStartedTime":
            suggest = "last_started_time"
        elif key == "percentComplete":
            suggest = "percent_complete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlFilesystemArchiveResponseStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlFilesystemArchiveResponseStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlFilesystemArchiveResponseStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_code: str,
                 error_message: str,
                 last_completion_time: str,
                 last_started_time: str,
                 percent_complete: int,
                 state: str):
        """
        The status of the archive
        :param str error_code: Server-defined error code for the archive operation
        :param str error_message: Server-defined error message for the archive operation
        :param str last_completion_time: The time of the last completed archive operation
        :param str last_started_time: The time the latest archive operation started
        :param int percent_complete: The completion percentage of the archive operation
        :param str state: The state of the archive operation
        """
        AmlFilesystemArchiveResponseStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error_code=error_code,
            error_message=error_message,
            last_completion_time=last_completion_time,
            last_started_time=last_started_time,
            percent_complete=percent_complete,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error_code: Optional[str] = None,
             error_message: Optional[str] = None,
             last_completion_time: Optional[str] = None,
             last_started_time: Optional[str] = None,
             percent_complete: Optional[int] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if error_code is None and 'errorCode' in kwargs:
            error_code = kwargs['errorCode']
        if error_code is None:
            raise TypeError("Missing 'error_code' argument")
        if error_message is None and 'errorMessage' in kwargs:
            error_message = kwargs['errorMessage']
        if error_message is None:
            raise TypeError("Missing 'error_message' argument")
        if last_completion_time is None and 'lastCompletionTime' in kwargs:
            last_completion_time = kwargs['lastCompletionTime']
        if last_completion_time is None:
            raise TypeError("Missing 'last_completion_time' argument")
        if last_started_time is None and 'lastStartedTime' in kwargs:
            last_started_time = kwargs['lastStartedTime']
        if last_started_time is None:
            raise TypeError("Missing 'last_started_time' argument")
        if percent_complete is None and 'percentComplete' in kwargs:
            percent_complete = kwargs['percentComplete']
        if percent_complete is None:
            raise TypeError("Missing 'percent_complete' argument")
        if state is None:
            raise TypeError("Missing 'state' argument")

        _setter("error_code", error_code)
        _setter("error_message", error_message)
        _setter("last_completion_time", last_completion_time)
        _setter("last_started_time", last_started_time)
        _setter("percent_complete", percent_complete)
        _setter("state", state)

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> str:
        """
        Server-defined error code for the archive operation
        """
        return pulumi.get(self, "error_code")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        Server-defined error message for the archive operation
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="lastCompletionTime")
    def last_completion_time(self) -> str:
        """
        The time of the last completed archive operation
        """
        return pulumi.get(self, "last_completion_time")

    @property
    @pulumi.getter(name="lastStartedTime")
    def last_started_time(self) -> str:
        """
        The time the latest archive operation started
        """
        return pulumi.get(self, "last_started_time")

    @property
    @pulumi.getter(name="percentComplete")
    def percent_complete(self) -> int:
        """
        The completion percentage of the archive operation
        """
        return pulumi.get(self, "percent_complete")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the archive operation
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class AmlFilesystemClientInfoResponse(dict):
    """
    AML file system client information
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerStorageInterface":
            suggest = "container_storage_interface"
        elif key == "lustreVersion":
            suggest = "lustre_version"
        elif key == "mgsAddress":
            suggest = "mgs_address"
        elif key == "mountCommand":
            suggest = "mount_command"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlFilesystemClientInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlFilesystemClientInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlFilesystemClientInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_storage_interface: 'outputs.AmlFilesystemContainerStorageInterfaceResponse',
                 lustre_version: str,
                 mgs_address: str,
                 mount_command: str):
        """
        AML file system client information
        :param 'AmlFilesystemContainerStorageInterfaceResponse' container_storage_interface: Container Storage Interface information for the AML file system.
        :param str lustre_version: The version of Lustre running in the AML file system
        :param str mgs_address: The IPv4 address used by clients to mount the AML file system's Lustre Management Service (MGS).
        :param str mount_command: Recommended command to mount the AML file system
        """
        AmlFilesystemClientInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container_storage_interface=container_storage_interface,
            lustre_version=lustre_version,
            mgs_address=mgs_address,
            mount_command=mount_command,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container_storage_interface: Optional['outputs.AmlFilesystemContainerStorageInterfaceResponse'] = None,
             lustre_version: Optional[str] = None,
             mgs_address: Optional[str] = None,
             mount_command: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if container_storage_interface is None and 'containerStorageInterface' in kwargs:
            container_storage_interface = kwargs['containerStorageInterface']
        if container_storage_interface is None:
            raise TypeError("Missing 'container_storage_interface' argument")
        if lustre_version is None and 'lustreVersion' in kwargs:
            lustre_version = kwargs['lustreVersion']
        if lustre_version is None:
            raise TypeError("Missing 'lustre_version' argument")
        if mgs_address is None and 'mgsAddress' in kwargs:
            mgs_address = kwargs['mgsAddress']
        if mgs_address is None:
            raise TypeError("Missing 'mgs_address' argument")
        if mount_command is None and 'mountCommand' in kwargs:
            mount_command = kwargs['mountCommand']
        if mount_command is None:
            raise TypeError("Missing 'mount_command' argument")

        _setter("container_storage_interface", container_storage_interface)
        _setter("lustre_version", lustre_version)
        _setter("mgs_address", mgs_address)
        _setter("mount_command", mount_command)

    @property
    @pulumi.getter(name="containerStorageInterface")
    def container_storage_interface(self) -> 'outputs.AmlFilesystemContainerStorageInterfaceResponse':
        """
        Container Storage Interface information for the AML file system.
        """
        return pulumi.get(self, "container_storage_interface")

    @property
    @pulumi.getter(name="lustreVersion")
    def lustre_version(self) -> str:
        """
        The version of Lustre running in the AML file system
        """
        return pulumi.get(self, "lustre_version")

    @property
    @pulumi.getter(name="mgsAddress")
    def mgs_address(self) -> str:
        """
        The IPv4 address used by clients to mount the AML file system's Lustre Management Service (MGS).
        """
        return pulumi.get(self, "mgs_address")

    @property
    @pulumi.getter(name="mountCommand")
    def mount_command(self) -> str:
        """
        Recommended command to mount the AML file system
        """
        return pulumi.get(self, "mount_command")


@pulumi.output_type
class AmlFilesystemContainerStorageInterfaceResponse(dict):
    """
    AML file system container storage interface information
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "persistentVolume":
            suggest = "persistent_volume"
        elif key == "persistentVolumeClaim":
            suggest = "persistent_volume_claim"
        elif key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlFilesystemContainerStorageInterfaceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlFilesystemContainerStorageInterfaceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlFilesystemContainerStorageInterfaceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 persistent_volume: str,
                 persistent_volume_claim: str,
                 storage_class: str):
        """
        AML file system container storage interface information
        :param str persistent_volume: Recommended AKS Persistent Volume for the CSI driver, in Base64 encoded YAML
        :param str persistent_volume_claim: Recommended AKS Persistent Volume Claim for the CSI driver, in Base64 encoded YAML
        :param str storage_class: Recommended AKS Storage Class for the CSI driver, in Base64 encoded YAML
        """
        AmlFilesystemContainerStorageInterfaceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            persistent_volume=persistent_volume,
            persistent_volume_claim=persistent_volume_claim,
            storage_class=storage_class,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             persistent_volume: Optional[str] = None,
             persistent_volume_claim: Optional[str] = None,
             storage_class: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if persistent_volume is None and 'persistentVolume' in kwargs:
            persistent_volume = kwargs['persistentVolume']
        if persistent_volume is None:
            raise TypeError("Missing 'persistent_volume' argument")
        if persistent_volume_claim is None and 'persistentVolumeClaim' in kwargs:
            persistent_volume_claim = kwargs['persistentVolumeClaim']
        if persistent_volume_claim is None:
            raise TypeError("Missing 'persistent_volume_claim' argument")
        if storage_class is None and 'storageClass' in kwargs:
            storage_class = kwargs['storageClass']
        if storage_class is None:
            raise TypeError("Missing 'storage_class' argument")

        _setter("persistent_volume", persistent_volume)
        _setter("persistent_volume_claim", persistent_volume_claim)
        _setter("storage_class", storage_class)

    @property
    @pulumi.getter(name="persistentVolume")
    def persistent_volume(self) -> str:
        """
        Recommended AKS Persistent Volume for the CSI driver, in Base64 encoded YAML
        """
        return pulumi.get(self, "persistent_volume")

    @property
    @pulumi.getter(name="persistentVolumeClaim")
    def persistent_volume_claim(self) -> str:
        """
        Recommended AKS Persistent Volume Claim for the CSI driver, in Base64 encoded YAML
        """
        return pulumi.get(self, "persistent_volume_claim")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        """
        Recommended AKS Storage Class for the CSI driver, in Base64 encoded YAML
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class AmlFilesystemEncryptionSettingsResponse(dict):
    """
    AML file system encryption settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyEncryptionKey":
            suggest = "key_encryption_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlFilesystemEncryptionSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlFilesystemEncryptionSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlFilesystemEncryptionSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_encryption_key: Optional['outputs.KeyVaultKeyReferenceResponse'] = None):
        """
        AML file system encryption settings.
        :param 'KeyVaultKeyReferenceResponse' key_encryption_key: Specifies the location of the encryption key in Key Vault.
        """
        AmlFilesystemEncryptionSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_encryption_key=key_encryption_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_encryption_key: Optional['outputs.KeyVaultKeyReferenceResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_encryption_key is None and 'keyEncryptionKey' in kwargs:
            key_encryption_key = kwargs['keyEncryptionKey']

        if key_encryption_key is not None:
            _setter("key_encryption_key", key_encryption_key)

    @property
    @pulumi.getter(name="keyEncryptionKey")
    def key_encryption_key(self) -> Optional['outputs.KeyVaultKeyReferenceResponse']:
        """
        Specifies the location of the encryption key in Key Vault.
        """
        return pulumi.get(self, "key_encryption_key")


@pulumi.output_type
class AmlFilesystemHealthResponse(dict):
    """
    An indication of AML file system health. Gives more information about health than just that related to provisioning.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"
        elif key == "statusDescription":
            suggest = "status_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlFilesystemHealthResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlFilesystemHealthResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlFilesystemHealthResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: Optional[str] = None,
                 status_code: Optional[str] = None,
                 status_description: Optional[str] = None):
        """
        An indication of AML file system health. Gives more information about health than just that related to provisioning.
        :param str state: List of AML file system health states.
        :param str status_code: Server-defined error code for the AML file system health
        :param str status_description: Describes the health state.
        """
        AmlFilesystemHealthResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            state=state,
            status_code=status_code,
            status_description=status_description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             state: Optional[str] = None,
             status_code: Optional[str] = None,
             status_description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if status_code is None and 'statusCode' in kwargs:
            status_code = kwargs['statusCode']
        if status_description is None and 'statusDescription' in kwargs:
            status_description = kwargs['statusDescription']

        if state is not None:
            _setter("state", state)
        if status_code is not None:
            _setter("status_code", status_code)
        if status_description is not None:
            _setter("status_description", status_description)

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        List of AML file system health states.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[str]:
        """
        Server-defined error code for the AML file system health
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter(name="statusDescription")
    def status_description(self) -> Optional[str]:
        """
        Describes the health state.
        """
        return pulumi.get(self, "status_description")


@pulumi.output_type
class AmlFilesystemHsmSettingsResponse(dict):
    """
    AML file system HSM settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loggingContainer":
            suggest = "logging_container"
        elif key == "importPrefix":
            suggest = "import_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlFilesystemHsmSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlFilesystemHsmSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlFilesystemHsmSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: str,
                 logging_container: str,
                 import_prefix: Optional[str] = None):
        """
        AML file system HSM settings.
        :param str container: Resource ID of storage container used for hydrating the namespace and archiving from the namespace. The resource provider must have permission to create SAS tokens on the storage account.
        :param str logging_container: Resource ID of storage container used for logging events and errors.  Must be a separate container in the same storage account as the hydration and archive container. The resource provider must have permission to create SAS tokens on the storage account.
        :param str import_prefix: Only blobs in the non-logging container that start with this path/prefix get hydrated into the cluster namespace.
        """
        AmlFilesystemHsmSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container=container,
            logging_container=logging_container,
            import_prefix=import_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container: Optional[str] = None,
             logging_container: Optional[str] = None,
             import_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if container is None:
            raise TypeError("Missing 'container' argument")
        if logging_container is None and 'loggingContainer' in kwargs:
            logging_container = kwargs['loggingContainer']
        if logging_container is None:
            raise TypeError("Missing 'logging_container' argument")
        if import_prefix is None and 'importPrefix' in kwargs:
            import_prefix = kwargs['importPrefix']

        _setter("container", container)
        _setter("logging_container", logging_container)
        if import_prefix is None:
            import_prefix = '/'
        if import_prefix is not None:
            _setter("import_prefix", import_prefix)

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        Resource ID of storage container used for hydrating the namespace and archiving from the namespace. The resource provider must have permission to create SAS tokens on the storage account.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="loggingContainer")
    def logging_container(self) -> str:
        """
        Resource ID of storage container used for logging events and errors.  Must be a separate container in the same storage account as the hydration and archive container. The resource provider must have permission to create SAS tokens on the storage account.
        """
        return pulumi.get(self, "logging_container")

    @property
    @pulumi.getter(name="importPrefix")
    def import_prefix(self) -> Optional[str]:
        """
        Only blobs in the non-logging container that start with this path/prefix get hydrated into the cluster namespace.
        """
        return pulumi.get(self, "import_prefix")


@pulumi.output_type
class AmlFilesystemIdentityResponse(dict):
    """
    Managed Identity properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlFilesystemIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlFilesystemIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlFilesystemIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentitiesResponseUserAssignedIdentities']] = None):
        """
        Managed Identity properties.
        :param str principal_id: The principal ID for the user-assigned identity of the resource.
        :param str tenant_id: The tenant ID associated with the resource.
        :param str type: The type of identity used for the resource.
        :param Mapping[str, 'UserAssignedIdentitiesResponseUserAssignedIdentities'] user_assigned_identities: A dictionary where each key is a user assigned identity resource ID, and each key's value is an empty dictionary.
        """
        AmlFilesystemIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             type: Optional[str] = None,
             user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentitiesResponseUserAssignedIdentities']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if user_assigned_identities is None and 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        _setter("principal_id", principal_id)
        _setter("tenant_id", tenant_id)
        if type is not None:
            _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID for the user-assigned identity of the resource.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID associated with the resource.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of identity used for the resource.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentitiesResponseUserAssignedIdentities']]:
        """
        A dictionary where each key is a user assigned identity resource ID, and each key's value is an empty dictionary.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class AmlFilesystemResponseHsm(dict):
    """
    Hydration and archive settings and status
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archiveStatus":
            suggest = "archive_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlFilesystemResponseHsm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlFilesystemResponseHsm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlFilesystemResponseHsm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive_status: Sequence['outputs.AmlFilesystemArchiveResponse'],
                 settings: Optional['outputs.AmlFilesystemHsmSettingsResponse'] = None):
        """
        Hydration and archive settings and status
        :param Sequence['AmlFilesystemArchiveResponse'] archive_status: Archive status
        :param 'AmlFilesystemHsmSettingsResponse' settings: Specifies HSM settings of the AML file system.
        """
        AmlFilesystemResponseHsm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archive_status=archive_status,
            settings=settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archive_status: Optional[Sequence['outputs.AmlFilesystemArchiveResponse']] = None,
             settings: Optional['outputs.AmlFilesystemHsmSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if archive_status is None and 'archiveStatus' in kwargs:
            archive_status = kwargs['archiveStatus']
        if archive_status is None:
            raise TypeError("Missing 'archive_status' argument")

        _setter("archive_status", archive_status)
        if settings is not None:
            _setter("settings", settings)

    @property
    @pulumi.getter(name="archiveStatus")
    def archive_status(self) -> Sequence['outputs.AmlFilesystemArchiveResponse']:
        """
        Archive status
        """
        return pulumi.get(self, "archive_status")

    @property
    @pulumi.getter
    def settings(self) -> Optional['outputs.AmlFilesystemHsmSettingsResponse']:
        """
        Specifies HSM settings of the AML file system.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class AmlFilesystemResponseMaintenanceWindow(dict):
    """
    Start time of a 30-minute weekly maintenance window.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "timeOfDayUTC":
            suggest = "time_of_day_utc"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AmlFilesystemResponseMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AmlFilesystemResponseMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AmlFilesystemResponseMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: Optional[str] = None,
                 time_of_day_utc: Optional[str] = None):
        """
        Start time of a 30-minute weekly maintenance window.
        :param str day_of_week: Day of the week on which the maintenance window will occur.
        :param str time_of_day_utc: The time of day (in UTC) to start the maintenance window.
        """
        AmlFilesystemResponseMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day_of_week=day_of_week,
            time_of_day_utc=time_of_day_utc,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day_of_week: Optional[str] = None,
             time_of_day_utc: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if day_of_week is None and 'dayOfWeek' in kwargs:
            day_of_week = kwargs['dayOfWeek']
        if time_of_day_utc is None and 'timeOfDayUTC' in kwargs:
            time_of_day_utc = kwargs['timeOfDayUTC']

        if day_of_week is not None:
            _setter("day_of_week", day_of_week)
        if time_of_day_utc is not None:
            _setter("time_of_day_utc", time_of_day_utc)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[str]:
        """
        Day of the week on which the maintenance window will occur.
        """
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter(name="timeOfDayUTC")
    def time_of_day_utc(self) -> Optional[str]:
        """
        The time of day (in UTC) to start the maintenance window.
        """
        return pulumi.get(self, "time_of_day_utc")


@pulumi.output_type
class BlobNfsTargetResponse(dict):
    """
    Properties pertaining to the BlobNfsTarget.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usageModel":
            suggest = "usage_model"
        elif key == "verificationTimer":
            suggest = "verification_timer"
        elif key == "writeBackTimer":
            suggest = "write_back_timer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BlobNfsTargetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BlobNfsTargetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BlobNfsTargetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: Optional[str] = None,
                 usage_model: Optional[str] = None,
                 verification_timer: Optional[int] = None,
                 write_back_timer: Optional[int] = None):
        """
        Properties pertaining to the BlobNfsTarget.
        :param str target: Resource ID of the storage container.
        :param str usage_model: Identifies the StorageCache usage model to be used for this storage target.
        :param int verification_timer: Amount of time (in seconds) the cache waits before it checks the back-end storage for file updates.
        :param int write_back_timer: Amount of time (in seconds) the cache waits after the last file change before it copies the changed file to back-end storage.
        """
        BlobNfsTargetResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            usage_model=usage_model,
            verification_timer=verification_timer,
            write_back_timer=write_back_timer,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: Optional[str] = None,
             usage_model: Optional[str] = None,
             verification_timer: Optional[int] = None,
             write_back_timer: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if usage_model is None and 'usageModel' in kwargs:
            usage_model = kwargs['usageModel']
        if verification_timer is None and 'verificationTimer' in kwargs:
            verification_timer = kwargs['verificationTimer']
        if write_back_timer is None and 'writeBackTimer' in kwargs:
            write_back_timer = kwargs['writeBackTimer']

        if target is not None:
            _setter("target", target)
        if usage_model is not None:
            _setter("usage_model", usage_model)
        if verification_timer is not None:
            _setter("verification_timer", verification_timer)
        if write_back_timer is not None:
            _setter("write_back_timer", write_back_timer)

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Resource ID of the storage container.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="usageModel")
    def usage_model(self) -> Optional[str]:
        """
        Identifies the StorageCache usage model to be used for this storage target.
        """
        return pulumi.get(self, "usage_model")

    @property
    @pulumi.getter(name="verificationTimer")
    def verification_timer(self) -> Optional[int]:
        """
        Amount of time (in seconds) the cache waits before it checks the back-end storage for file updates.
        """
        return pulumi.get(self, "verification_timer")

    @property
    @pulumi.getter(name="writeBackTimer")
    def write_back_timer(self) -> Optional[int]:
        """
        Amount of time (in seconds) the cache waits after the last file change before it copies the changed file to back-end storage.
        """
        return pulumi.get(self, "write_back_timer")


@pulumi.output_type
class CacheActiveDirectorySettingsResponse(dict):
    """
    Active Directory settings used to join a cache to a domain.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheNetBiosName":
            suggest = "cache_net_bios_name"
        elif key == "domainJoined":
            suggest = "domain_joined"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "domainNetBiosName":
            suggest = "domain_net_bios_name"
        elif key == "primaryDnsIpAddress":
            suggest = "primary_dns_ip_address"
        elif key == "secondaryDnsIpAddress":
            suggest = "secondary_dns_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheActiveDirectorySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheActiveDirectorySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheActiveDirectorySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_net_bios_name: str,
                 domain_joined: str,
                 domain_name: str,
                 domain_net_bios_name: str,
                 primary_dns_ip_address: str,
                 credentials: Optional['outputs.CacheActiveDirectorySettingsResponseCredentials'] = None,
                 secondary_dns_ip_address: Optional[str] = None):
        """
        Active Directory settings used to join a cache to a domain.
        :param str cache_net_bios_name: The NetBIOS name to assign to the HPC Cache when it joins the Active Directory domain as a server. Length must 1-15 characters from the class [-0-9a-zA-Z].
        :param str domain_joined: True if the HPC Cache is joined to the Active Directory domain.
        :param str domain_name: The fully qualified domain name of the Active Directory domain controller.
        :param str domain_net_bios_name: The Active Directory domain's NetBIOS name.
        :param str primary_dns_ip_address: Primary DNS IP address used to resolve the Active Directory domain controller's fully qualified domain name.
        :param 'CacheActiveDirectorySettingsResponseCredentials' credentials: Active Directory admin credentials used to join the HPC Cache to a domain.
        :param str secondary_dns_ip_address: Secondary DNS IP address used to resolve the Active Directory domain controller's fully qualified domain name.
        """
        CacheActiveDirectorySettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cache_net_bios_name=cache_net_bios_name,
            domain_joined=domain_joined,
            domain_name=domain_name,
            domain_net_bios_name=domain_net_bios_name,
            primary_dns_ip_address=primary_dns_ip_address,
            credentials=credentials,
            secondary_dns_ip_address=secondary_dns_ip_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cache_net_bios_name: Optional[str] = None,
             domain_joined: Optional[str] = None,
             domain_name: Optional[str] = None,
             domain_net_bios_name: Optional[str] = None,
             primary_dns_ip_address: Optional[str] = None,
             credentials: Optional['outputs.CacheActiveDirectorySettingsResponseCredentials'] = None,
             secondary_dns_ip_address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if cache_net_bios_name is None and 'cacheNetBiosName' in kwargs:
            cache_net_bios_name = kwargs['cacheNetBiosName']
        if cache_net_bios_name is None:
            raise TypeError("Missing 'cache_net_bios_name' argument")
        if domain_joined is None and 'domainJoined' in kwargs:
            domain_joined = kwargs['domainJoined']
        if domain_joined is None:
            raise TypeError("Missing 'domain_joined' argument")
        if domain_name is None and 'domainName' in kwargs:
            domain_name = kwargs['domainName']
        if domain_name is None:
            raise TypeError("Missing 'domain_name' argument")
        if domain_net_bios_name is None and 'domainNetBiosName' in kwargs:
            domain_net_bios_name = kwargs['domainNetBiosName']
        if domain_net_bios_name is None:
            raise TypeError("Missing 'domain_net_bios_name' argument")
        if primary_dns_ip_address is None and 'primaryDnsIpAddress' in kwargs:
            primary_dns_ip_address = kwargs['primaryDnsIpAddress']
        if primary_dns_ip_address is None:
            raise TypeError("Missing 'primary_dns_ip_address' argument")
        if secondary_dns_ip_address is None and 'secondaryDnsIpAddress' in kwargs:
            secondary_dns_ip_address = kwargs['secondaryDnsIpAddress']

        _setter("cache_net_bios_name", cache_net_bios_name)
        _setter("domain_joined", domain_joined)
        _setter("domain_name", domain_name)
        _setter("domain_net_bios_name", domain_net_bios_name)
        _setter("primary_dns_ip_address", primary_dns_ip_address)
        if credentials is not None:
            _setter("credentials", credentials)
        if secondary_dns_ip_address is not None:
            _setter("secondary_dns_ip_address", secondary_dns_ip_address)

    @property
    @pulumi.getter(name="cacheNetBiosName")
    def cache_net_bios_name(self) -> str:
        """
        The NetBIOS name to assign to the HPC Cache when it joins the Active Directory domain as a server. Length must 1-15 characters from the class [-0-9a-zA-Z].
        """
        return pulumi.get(self, "cache_net_bios_name")

    @property
    @pulumi.getter(name="domainJoined")
    def domain_joined(self) -> str:
        """
        True if the HPC Cache is joined to the Active Directory domain.
        """
        return pulumi.get(self, "domain_joined")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The fully qualified domain name of the Active Directory domain controller.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="domainNetBiosName")
    def domain_net_bios_name(self) -> str:
        """
        The Active Directory domain's NetBIOS name.
        """
        return pulumi.get(self, "domain_net_bios_name")

    @property
    @pulumi.getter(name="primaryDnsIpAddress")
    def primary_dns_ip_address(self) -> str:
        """
        Primary DNS IP address used to resolve the Active Directory domain controller's fully qualified domain name.
        """
        return pulumi.get(self, "primary_dns_ip_address")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.CacheActiveDirectorySettingsResponseCredentials']:
        """
        Active Directory admin credentials used to join the HPC Cache to a domain.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="secondaryDnsIpAddress")
    def secondary_dns_ip_address(self) -> Optional[str]:
        """
        Secondary DNS IP address used to resolve the Active Directory domain controller's fully qualified domain name.
        """
        return pulumi.get(self, "secondary_dns_ip_address")


@pulumi.output_type
class CacheActiveDirectorySettingsResponseCredentials(dict):
    """
    Active Directory admin credentials used to join the HPC Cache to a domain.
    """
    def __init__(__self__, *,
                 username: str,
                 password: Optional[str] = None):
        """
        Active Directory admin credentials used to join the HPC Cache to a domain.
        :param str username: Username of the Active Directory domain administrator. This value is stored encrypted and not returned on response.
        :param str password: Plain text password of the Active Directory domain administrator. This value is stored encrypted and not returned on response.
        """
        CacheActiveDirectorySettingsResponseCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
            password=password,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: Optional[str] = None,
             password: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if username is None:
            raise TypeError("Missing 'username' argument")

        _setter("username", username)
        if password is not None:
            _setter("password", password)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username of the Active Directory domain administrator. This value is stored encrypted and not returned on response.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Plain text password of the Active Directory domain administrator. This value is stored encrypted and not returned on response.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class CacheDirectorySettingsResponse(dict):
    """
    Cache Directory Services settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "usernameDownload":
            suggest = "username_download"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheDirectorySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheDirectorySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheDirectorySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_directory: Optional['outputs.CacheActiveDirectorySettingsResponse'] = None,
                 username_download: Optional['outputs.CacheUsernameDownloadSettingsResponse'] = None):
        """
        Cache Directory Services settings.
        :param 'CacheActiveDirectorySettingsResponse' active_directory: Specifies settings for joining the HPC Cache to an Active Directory domain.
        :param 'CacheUsernameDownloadSettingsResponse' username_download: Specifies settings for Extended Groups. Extended Groups allows users to be members of more than 16 groups.
        """
        CacheDirectorySettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            active_directory=active_directory,
            username_download=username_download,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             active_directory: Optional['outputs.CacheActiveDirectorySettingsResponse'] = None,
             username_download: Optional['outputs.CacheUsernameDownloadSettingsResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if active_directory is None and 'activeDirectory' in kwargs:
            active_directory = kwargs['activeDirectory']
        if username_download is None and 'usernameDownload' in kwargs:
            username_download = kwargs['usernameDownload']

        if active_directory is not None:
            _setter("active_directory", active_directory)
        if username_download is not None:
            _setter("username_download", username_download)

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.CacheActiveDirectorySettingsResponse']:
        """
        Specifies settings for joining the HPC Cache to an Active Directory domain.
        """
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="usernameDownload")
    def username_download(self) -> Optional['outputs.CacheUsernameDownloadSettingsResponse']:
        """
        Specifies settings for Extended Groups. Extended Groups allows users to be members of more than 16 groups.
        """
        return pulumi.get(self, "username_download")


@pulumi.output_type
class CacheEncryptionSettingsResponse(dict):
    """
    Cache encryption settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyEncryptionKey":
            suggest = "key_encryption_key"
        elif key == "rotationToLatestKeyVersionEnabled":
            suggest = "rotation_to_latest_key_version_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheEncryptionSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheEncryptionSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheEncryptionSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_encryption_key: Optional['outputs.KeyVaultKeyReferenceResponse'] = None,
                 rotation_to_latest_key_version_enabled: Optional[bool] = None):
        """
        Cache encryption settings.
        :param 'KeyVaultKeyReferenceResponse' key_encryption_key: Specifies the location of the key encryption key in key vault.
        :param bool rotation_to_latest_key_version_enabled: Specifies whether the service will automatically rotate to the newest version of the key in the key vault.
        """
        CacheEncryptionSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_encryption_key=key_encryption_key,
            rotation_to_latest_key_version_enabled=rotation_to_latest_key_version_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_encryption_key: Optional['outputs.KeyVaultKeyReferenceResponse'] = None,
             rotation_to_latest_key_version_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_encryption_key is None and 'keyEncryptionKey' in kwargs:
            key_encryption_key = kwargs['keyEncryptionKey']
        if rotation_to_latest_key_version_enabled is None and 'rotationToLatestKeyVersionEnabled' in kwargs:
            rotation_to_latest_key_version_enabled = kwargs['rotationToLatestKeyVersionEnabled']

        if key_encryption_key is not None:
            _setter("key_encryption_key", key_encryption_key)
        if rotation_to_latest_key_version_enabled is not None:
            _setter("rotation_to_latest_key_version_enabled", rotation_to_latest_key_version_enabled)

    @property
    @pulumi.getter(name="keyEncryptionKey")
    def key_encryption_key(self) -> Optional['outputs.KeyVaultKeyReferenceResponse']:
        """
        Specifies the location of the key encryption key in key vault.
        """
        return pulumi.get(self, "key_encryption_key")

    @property
    @pulumi.getter(name="rotationToLatestKeyVersionEnabled")
    def rotation_to_latest_key_version_enabled(self) -> Optional[bool]:
        """
        Specifies whether the service will automatically rotate to the newest version of the key in the key vault.
        """
        return pulumi.get(self, "rotation_to_latest_key_version_enabled")


@pulumi.output_type
class CacheHealthResponse(dict):
    """
    An indication of cache health. Gives more information about health than just that related to provisioning.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusDescription":
            suggest = "status_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheHealthResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheHealthResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheHealthResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Sequence['outputs.ConditionResponse'],
                 state: Optional[str] = None,
                 status_description: Optional[str] = None):
        """
        An indication of cache health. Gives more information about health than just that related to provisioning.
        :param Sequence['ConditionResponse'] conditions: Outstanding conditions that need to be investigated and resolved.
        :param str state: List of cache health states. Down is when the cluster is not responding.  Degraded is when its functioning but has some alerts. Transitioning when it is creating or deleting. Unknown will be returned in old api versions when a new value is added in future versions. WaitingForKey is when the create is waiting for the system assigned identity to be given access to the encryption key in the encryption settings.
        :param str status_description: Describes explanation of state.
        """
        CacheHealthResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditions=conditions,
            state=state,
            status_description=status_description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditions: Optional[Sequence['outputs.ConditionResponse']] = None,
             state: Optional[str] = None,
             status_description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if conditions is None:
            raise TypeError("Missing 'conditions' argument")
        if status_description is None and 'statusDescription' in kwargs:
            status_description = kwargs['statusDescription']

        _setter("conditions", conditions)
        if state is not None:
            _setter("state", state)
        if status_description is not None:
            _setter("status_description", status_description)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.ConditionResponse']:
        """
        Outstanding conditions that need to be investigated and resolved.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        List of cache health states. Down is when the cluster is not responding.  Degraded is when its functioning but has some alerts. Transitioning when it is creating or deleting. Unknown will be returned in old api versions when a new value is added in future versions. WaitingForKey is when the create is waiting for the system assigned identity to be given access to the encryption key in the encryption settings.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="statusDescription")
    def status_description(self) -> Optional[str]:
        """
        Describes explanation of state.
        """
        return pulumi.get(self, "status_description")


@pulumi.output_type
class CacheIdentityResponse(dict):
    """
    Cache identity properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.CacheIdentityResponseUserAssignedIdentities']] = None):
        """
        Cache identity properties.
        :param str principal_id: The principal ID for the system-assigned identity of the cache.
        :param str tenant_id: The tenant ID associated with the cache.
        :param str type: The type of identity used for the cache
        :param Mapping[str, 'CacheIdentityResponseUserAssignedIdentities'] user_assigned_identities: A dictionary where each key is a user assigned identity resource ID, and each key's value is an empty dictionary.
        """
        CacheIdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             type: Optional[str] = None,
             user_assigned_identities: Optional[Mapping[str, 'outputs.CacheIdentityResponseUserAssignedIdentities']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")
        if user_assigned_identities is None and 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        _setter("principal_id", principal_id)
        _setter("tenant_id", tenant_id)
        if type is not None:
            _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID for the system-assigned identity of the cache.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID associated with the cache.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of identity used for the cache
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.CacheIdentityResponseUserAssignedIdentities']]:
        """
        A dictionary where each key is a user assigned identity resource ID, and each key's value is an empty dictionary.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class CacheIdentityResponseUserAssignedIdentities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheIdentityResponseUserAssignedIdentities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheIdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheIdentityResponseUserAssignedIdentities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        :param str client_id: The client ID of the user-assigned identity.
        :param str principal_id: The principal ID of the user-assigned identity.
        """
        CacheIdentityResponseUserAssignedIdentities._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            principal_id=principal_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             principal_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")

        _setter("client_id", client_id)
        _setter("principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the user-assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the user-assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class CacheNetworkSettingsResponse(dict):
    """
    Cache network settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "utilityAddresses":
            suggest = "utility_addresses"
        elif key == "dnsSearchDomain":
            suggest = "dns_search_domain"
        elif key == "dnsServers":
            suggest = "dns_servers"
        elif key == "ntpServer":
            suggest = "ntp_server"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheNetworkSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheNetworkSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheNetworkSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 utility_addresses: Sequence[str],
                 dns_search_domain: Optional[str] = None,
                 dns_servers: Optional[Sequence[str]] = None,
                 mtu: Optional[int] = None,
                 ntp_server: Optional[str] = None):
        """
        Cache network settings.
        :param Sequence[str] utility_addresses: Array of additional IP addresses used by this cache.
        :param str dns_search_domain: DNS search domain
        :param Sequence[str] dns_servers: DNS servers for the cache to use.  It will be set from the network configuration if no value is provided.
        :param int mtu: The IPv4 maximum transmission unit configured for the subnet.
        :param str ntp_server: NTP server IP Address or FQDN for the cache to use. The default is time.windows.com.
        """
        CacheNetworkSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            utility_addresses=utility_addresses,
            dns_search_domain=dns_search_domain,
            dns_servers=dns_servers,
            mtu=mtu,
            ntp_server=ntp_server,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             utility_addresses: Optional[Sequence[str]] = None,
             dns_search_domain: Optional[str] = None,
             dns_servers: Optional[Sequence[str]] = None,
             mtu: Optional[int] = None,
             ntp_server: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if utility_addresses is None and 'utilityAddresses' in kwargs:
            utility_addresses = kwargs['utilityAddresses']
        if utility_addresses is None:
            raise TypeError("Missing 'utility_addresses' argument")
        if dns_search_domain is None and 'dnsSearchDomain' in kwargs:
            dns_search_domain = kwargs['dnsSearchDomain']
        if dns_servers is None and 'dnsServers' in kwargs:
            dns_servers = kwargs['dnsServers']
        if ntp_server is None and 'ntpServer' in kwargs:
            ntp_server = kwargs['ntpServer']

        _setter("utility_addresses", utility_addresses)
        if dns_search_domain is not None:
            _setter("dns_search_domain", dns_search_domain)
        if dns_servers is not None:
            _setter("dns_servers", dns_servers)
        if mtu is None:
            mtu = 1500
        if mtu is not None:
            _setter("mtu", mtu)
        if ntp_server is None:
            ntp_server = 'time.windows.com'
        if ntp_server is not None:
            _setter("ntp_server", ntp_server)

    @property
    @pulumi.getter(name="utilityAddresses")
    def utility_addresses(self) -> Sequence[str]:
        """
        Array of additional IP addresses used by this cache.
        """
        return pulumi.get(self, "utility_addresses")

    @property
    @pulumi.getter(name="dnsSearchDomain")
    def dns_search_domain(self) -> Optional[str]:
        """
        DNS search domain
        """
        return pulumi.get(self, "dns_search_domain")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        """
        DNS servers for the cache to use.  It will be set from the network configuration if no value is provided.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter
    def mtu(self) -> Optional[int]:
        """
        The IPv4 maximum transmission unit configured for the subnet.
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter(name="ntpServer")
    def ntp_server(self) -> Optional[str]:
        """
        NTP server IP Address or FQDN for the cache to use. The default is time.windows.com.
        """
        return pulumi.get(self, "ntp_server")


@pulumi.output_type
class CacheResponseSku(dict):
    """
    SKU for the cache.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        SKU for the cache.
        :param str name: SKU name for this cache.
        """
        CacheResponseSku._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        SKU name for this cache.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CacheSecuritySettingsResponse(dict):
    """
    Cache security settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessPolicies":
            suggest = "access_policies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheSecuritySettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheSecuritySettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheSecuritySettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_policies: Optional[Sequence['outputs.NfsAccessPolicyResponse']] = None):
        """
        Cache security settings.
        :param Sequence['NfsAccessPolicyResponse'] access_policies: NFS access policies defined for this cache.
        """
        CacheSecuritySettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_policies=access_policies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_policies: Optional[Sequence['outputs.NfsAccessPolicyResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_policies is None and 'accessPolicies' in kwargs:
            access_policies = kwargs['accessPolicies']

        if access_policies is not None:
            _setter("access_policies", access_policies)

    @property
    @pulumi.getter(name="accessPolicies")
    def access_policies(self) -> Optional[Sequence['outputs.NfsAccessPolicyResponse']]:
        """
        NFS access policies defined for this cache.
        """
        return pulumi.get(self, "access_policies")


@pulumi.output_type
class CacheUpgradeSettingsResponse(dict):
    """
    Cache Upgrade Settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scheduledTime":
            suggest = "scheduled_time"
        elif key == "upgradeScheduleEnabled":
            suggest = "upgrade_schedule_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheUpgradeSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheUpgradeSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheUpgradeSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scheduled_time: Optional[str] = None,
                 upgrade_schedule_enabled: Optional[bool] = None):
        """
        Cache Upgrade Settings.
        :param str scheduled_time: When upgradeScheduleEnabled is true, this field holds the user-chosen upgrade time. At the user-chosen time, the firmware update will automatically be installed on the cache.
        :param bool upgrade_schedule_enabled: True if the user chooses to select an installation time between now and firmwareUpdateDeadline. Else the firmware will automatically be installed after firmwareUpdateDeadline if not triggered earlier via the upgrade operation.
        """
        CacheUpgradeSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scheduled_time=scheduled_time,
            upgrade_schedule_enabled=upgrade_schedule_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scheduled_time: Optional[str] = None,
             upgrade_schedule_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if scheduled_time is None and 'scheduledTime' in kwargs:
            scheduled_time = kwargs['scheduledTime']
        if upgrade_schedule_enabled is None and 'upgradeScheduleEnabled' in kwargs:
            upgrade_schedule_enabled = kwargs['upgradeScheduleEnabled']

        if scheduled_time is not None:
            _setter("scheduled_time", scheduled_time)
        if upgrade_schedule_enabled is not None:
            _setter("upgrade_schedule_enabled", upgrade_schedule_enabled)

    @property
    @pulumi.getter(name="scheduledTime")
    def scheduled_time(self) -> Optional[str]:
        """
        When upgradeScheduleEnabled is true, this field holds the user-chosen upgrade time. At the user-chosen time, the firmware update will automatically be installed on the cache.
        """
        return pulumi.get(self, "scheduled_time")

    @property
    @pulumi.getter(name="upgradeScheduleEnabled")
    def upgrade_schedule_enabled(self) -> Optional[bool]:
        """
        True if the user chooses to select an installation time between now and firmwareUpdateDeadline. Else the firmware will automatically be installed after firmwareUpdateDeadline if not triggered earlier via the upgrade operation.
        """
        return pulumi.get(self, "upgrade_schedule_enabled")


@pulumi.output_type
class CacheUpgradeStatusResponse(dict):
    """
    Properties describing the software upgrade state of the cache.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentFirmwareVersion":
            suggest = "current_firmware_version"
        elif key == "firmwareUpdateDeadline":
            suggest = "firmware_update_deadline"
        elif key == "firmwareUpdateStatus":
            suggest = "firmware_update_status"
        elif key == "lastFirmwareUpdate":
            suggest = "last_firmware_update"
        elif key == "pendingFirmwareVersion":
            suggest = "pending_firmware_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheUpgradeStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheUpgradeStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheUpgradeStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_firmware_version: str,
                 firmware_update_deadline: str,
                 firmware_update_status: str,
                 last_firmware_update: str,
                 pending_firmware_version: str):
        """
        Properties describing the software upgrade state of the cache.
        :param str current_firmware_version: Version string of the firmware currently installed on this cache.
        :param str firmware_update_deadline: Time at which the pending firmware update will automatically be installed on the cache.
        :param str firmware_update_status: True if there is a firmware update ready to install on this cache. The firmware will automatically be installed after firmwareUpdateDeadline if not triggered earlier via the upgrade operation.
        :param str last_firmware_update: Time of the last successful firmware update.
        :param str pending_firmware_version: When firmwareUpdateAvailable is true, this field holds the version string for the update.
        """
        CacheUpgradeStatusResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            current_firmware_version=current_firmware_version,
            firmware_update_deadline=firmware_update_deadline,
            firmware_update_status=firmware_update_status,
            last_firmware_update=last_firmware_update,
            pending_firmware_version=pending_firmware_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             current_firmware_version: Optional[str] = None,
             firmware_update_deadline: Optional[str] = None,
             firmware_update_status: Optional[str] = None,
             last_firmware_update: Optional[str] = None,
             pending_firmware_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if current_firmware_version is None and 'currentFirmwareVersion' in kwargs:
            current_firmware_version = kwargs['currentFirmwareVersion']
        if current_firmware_version is None:
            raise TypeError("Missing 'current_firmware_version' argument")
        if firmware_update_deadline is None and 'firmwareUpdateDeadline' in kwargs:
            firmware_update_deadline = kwargs['firmwareUpdateDeadline']
        if firmware_update_deadline is None:
            raise TypeError("Missing 'firmware_update_deadline' argument")
        if firmware_update_status is None and 'firmwareUpdateStatus' in kwargs:
            firmware_update_status = kwargs['firmwareUpdateStatus']
        if firmware_update_status is None:
            raise TypeError("Missing 'firmware_update_status' argument")
        if last_firmware_update is None and 'lastFirmwareUpdate' in kwargs:
            last_firmware_update = kwargs['lastFirmwareUpdate']
        if last_firmware_update is None:
            raise TypeError("Missing 'last_firmware_update' argument")
        if pending_firmware_version is None and 'pendingFirmwareVersion' in kwargs:
            pending_firmware_version = kwargs['pendingFirmwareVersion']
        if pending_firmware_version is None:
            raise TypeError("Missing 'pending_firmware_version' argument")

        _setter("current_firmware_version", current_firmware_version)
        _setter("firmware_update_deadline", firmware_update_deadline)
        _setter("firmware_update_status", firmware_update_status)
        _setter("last_firmware_update", last_firmware_update)
        _setter("pending_firmware_version", pending_firmware_version)

    @property
    @pulumi.getter(name="currentFirmwareVersion")
    def current_firmware_version(self) -> str:
        """
        Version string of the firmware currently installed on this cache.
        """
        return pulumi.get(self, "current_firmware_version")

    @property
    @pulumi.getter(name="firmwareUpdateDeadline")
    def firmware_update_deadline(self) -> str:
        """
        Time at which the pending firmware update will automatically be installed on the cache.
        """
        return pulumi.get(self, "firmware_update_deadline")

    @property
    @pulumi.getter(name="firmwareUpdateStatus")
    def firmware_update_status(self) -> str:
        """
        True if there is a firmware update ready to install on this cache. The firmware will automatically be installed after firmwareUpdateDeadline if not triggered earlier via the upgrade operation.
        """
        return pulumi.get(self, "firmware_update_status")

    @property
    @pulumi.getter(name="lastFirmwareUpdate")
    def last_firmware_update(self) -> str:
        """
        Time of the last successful firmware update.
        """
        return pulumi.get(self, "last_firmware_update")

    @property
    @pulumi.getter(name="pendingFirmwareVersion")
    def pending_firmware_version(self) -> str:
        """
        When firmwareUpdateAvailable is true, this field holds the version string for the update.
        """
        return pulumi.get(self, "pending_firmware_version")


@pulumi.output_type
class CacheUsernameDownloadSettingsResponse(dict):
    """
    Settings for Extended Groups username and group download.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usernameDownloaded":
            suggest = "username_downloaded"
        elif key == "autoDownloadCertificate":
            suggest = "auto_download_certificate"
        elif key == "caCertificateURI":
            suggest = "ca_certificate_uri"
        elif key == "encryptLdapConnection":
            suggest = "encrypt_ldap_connection"
        elif key == "extendedGroups":
            suggest = "extended_groups"
        elif key == "groupFileURI":
            suggest = "group_file_uri"
        elif key == "ldapBaseDN":
            suggest = "ldap_base_dn"
        elif key == "ldapServer":
            suggest = "ldap_server"
        elif key == "requireValidCertificate":
            suggest = "require_valid_certificate"
        elif key == "userFileURI":
            suggest = "user_file_uri"
        elif key == "usernameSource":
            suggest = "username_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheUsernameDownloadSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheUsernameDownloadSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheUsernameDownloadSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 username_downloaded: str,
                 auto_download_certificate: Optional[bool] = None,
                 ca_certificate_uri: Optional[str] = None,
                 credentials: Optional['outputs.CacheUsernameDownloadSettingsResponseCredentials'] = None,
                 encrypt_ldap_connection: Optional[bool] = None,
                 extended_groups: Optional[bool] = None,
                 group_file_uri: Optional[str] = None,
                 ldap_base_dn: Optional[str] = None,
                 ldap_server: Optional[str] = None,
                 require_valid_certificate: Optional[bool] = None,
                 user_file_uri: Optional[str] = None,
                 username_source: Optional[str] = None):
        """
        Settings for Extended Groups username and group download.
        :param str username_downloaded: Indicates whether or not the HPC Cache has performed the username download successfully.
        :param bool auto_download_certificate: Determines if the certificate should be automatically downloaded. This applies to 'caCertificateURI' only if 'requireValidCertificate' is true.
        :param str ca_certificate_uri: The URI of the CA certificate to validate the LDAP secure connection. This field must be populated when 'requireValidCertificate' is set to true.
        :param 'CacheUsernameDownloadSettingsResponseCredentials' credentials: When present, these are the credentials for the secure LDAP connection.
        :param bool encrypt_ldap_connection: Whether or not the LDAP connection should be encrypted.
        :param bool extended_groups: Whether or not Extended Groups is enabled.
        :param str group_file_uri: The URI of the file containing group information (in /etc/group file format). This field must be populated when 'usernameSource' is set to 'File'.
        :param str ldap_base_dn: The base distinguished name for the LDAP domain.
        :param str ldap_server: The fully qualified domain name or IP address of the LDAP server to use.
        :param bool require_valid_certificate: Determines if the certificates must be validated by a certificate authority. When true, caCertificateURI must be provided.
        :param str user_file_uri: The URI of the file containing user information (in /etc/passwd file format). This field must be populated when 'usernameSource' is set to 'File'.
        :param str username_source: This setting determines how the cache gets username and group names for clients.
        """
        CacheUsernameDownloadSettingsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username_downloaded=username_downloaded,
            auto_download_certificate=auto_download_certificate,
            ca_certificate_uri=ca_certificate_uri,
            credentials=credentials,
            encrypt_ldap_connection=encrypt_ldap_connection,
            extended_groups=extended_groups,
            group_file_uri=group_file_uri,
            ldap_base_dn=ldap_base_dn,
            ldap_server=ldap_server,
            require_valid_certificate=require_valid_certificate,
            user_file_uri=user_file_uri,
            username_source=username_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username_downloaded: Optional[str] = None,
             auto_download_certificate: Optional[bool] = None,
             ca_certificate_uri: Optional[str] = None,
             credentials: Optional['outputs.CacheUsernameDownloadSettingsResponseCredentials'] = None,
             encrypt_ldap_connection: Optional[bool] = None,
             extended_groups: Optional[bool] = None,
             group_file_uri: Optional[str] = None,
             ldap_base_dn: Optional[str] = None,
             ldap_server: Optional[str] = None,
             require_valid_certificate: Optional[bool] = None,
             user_file_uri: Optional[str] = None,
             username_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if username_downloaded is None and 'usernameDownloaded' in kwargs:
            username_downloaded = kwargs['usernameDownloaded']
        if username_downloaded is None:
            raise TypeError("Missing 'username_downloaded' argument")
        if auto_download_certificate is None and 'autoDownloadCertificate' in kwargs:
            auto_download_certificate = kwargs['autoDownloadCertificate']
        if ca_certificate_uri is None and 'caCertificateURI' in kwargs:
            ca_certificate_uri = kwargs['caCertificateURI']
        if encrypt_ldap_connection is None and 'encryptLdapConnection' in kwargs:
            encrypt_ldap_connection = kwargs['encryptLdapConnection']
        if extended_groups is None and 'extendedGroups' in kwargs:
            extended_groups = kwargs['extendedGroups']
        if group_file_uri is None and 'groupFileURI' in kwargs:
            group_file_uri = kwargs['groupFileURI']
        if ldap_base_dn is None and 'ldapBaseDN' in kwargs:
            ldap_base_dn = kwargs['ldapBaseDN']
        if ldap_server is None and 'ldapServer' in kwargs:
            ldap_server = kwargs['ldapServer']
        if require_valid_certificate is None and 'requireValidCertificate' in kwargs:
            require_valid_certificate = kwargs['requireValidCertificate']
        if user_file_uri is None and 'userFileURI' in kwargs:
            user_file_uri = kwargs['userFileURI']
        if username_source is None and 'usernameSource' in kwargs:
            username_source = kwargs['usernameSource']

        _setter("username_downloaded", username_downloaded)
        if auto_download_certificate is None:
            auto_download_certificate = False
        if auto_download_certificate is not None:
            _setter("auto_download_certificate", auto_download_certificate)
        if ca_certificate_uri is not None:
            _setter("ca_certificate_uri", ca_certificate_uri)
        if credentials is not None:
            _setter("credentials", credentials)
        if encrypt_ldap_connection is None:
            encrypt_ldap_connection = False
        if encrypt_ldap_connection is not None:
            _setter("encrypt_ldap_connection", encrypt_ldap_connection)
        if extended_groups is not None:
            _setter("extended_groups", extended_groups)
        if group_file_uri is not None:
            _setter("group_file_uri", group_file_uri)
        if ldap_base_dn is not None:
            _setter("ldap_base_dn", ldap_base_dn)
        if ldap_server is not None:
            _setter("ldap_server", ldap_server)
        if require_valid_certificate is None:
            require_valid_certificate = False
        if require_valid_certificate is not None:
            _setter("require_valid_certificate", require_valid_certificate)
        if user_file_uri is not None:
            _setter("user_file_uri", user_file_uri)
        if username_source is None:
            username_source = 'None'
        if username_source is not None:
            _setter("username_source", username_source)

    @property
    @pulumi.getter(name="usernameDownloaded")
    def username_downloaded(self) -> str:
        """
        Indicates whether or not the HPC Cache has performed the username download successfully.
        """
        return pulumi.get(self, "username_downloaded")

    @property
    @pulumi.getter(name="autoDownloadCertificate")
    def auto_download_certificate(self) -> Optional[bool]:
        """
        Determines if the certificate should be automatically downloaded. This applies to 'caCertificateURI' only if 'requireValidCertificate' is true.
        """
        return pulumi.get(self, "auto_download_certificate")

    @property
    @pulumi.getter(name="caCertificateURI")
    def ca_certificate_uri(self) -> Optional[str]:
        """
        The URI of the CA certificate to validate the LDAP secure connection. This field must be populated when 'requireValidCertificate' is set to true.
        """
        return pulumi.get(self, "ca_certificate_uri")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.CacheUsernameDownloadSettingsResponseCredentials']:
        """
        When present, these are the credentials for the secure LDAP connection.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="encryptLdapConnection")
    def encrypt_ldap_connection(self) -> Optional[bool]:
        """
        Whether or not the LDAP connection should be encrypted.
        """
        return pulumi.get(self, "encrypt_ldap_connection")

    @property
    @pulumi.getter(name="extendedGroups")
    def extended_groups(self) -> Optional[bool]:
        """
        Whether or not Extended Groups is enabled.
        """
        return pulumi.get(self, "extended_groups")

    @property
    @pulumi.getter(name="groupFileURI")
    def group_file_uri(self) -> Optional[str]:
        """
        The URI of the file containing group information (in /etc/group file format). This field must be populated when 'usernameSource' is set to 'File'.
        """
        return pulumi.get(self, "group_file_uri")

    @property
    @pulumi.getter(name="ldapBaseDN")
    def ldap_base_dn(self) -> Optional[str]:
        """
        The base distinguished name for the LDAP domain.
        """
        return pulumi.get(self, "ldap_base_dn")

    @property
    @pulumi.getter(name="ldapServer")
    def ldap_server(self) -> Optional[str]:
        """
        The fully qualified domain name or IP address of the LDAP server to use.
        """
        return pulumi.get(self, "ldap_server")

    @property
    @pulumi.getter(name="requireValidCertificate")
    def require_valid_certificate(self) -> Optional[bool]:
        """
        Determines if the certificates must be validated by a certificate authority. When true, caCertificateURI must be provided.
        """
        return pulumi.get(self, "require_valid_certificate")

    @property
    @pulumi.getter(name="userFileURI")
    def user_file_uri(self) -> Optional[str]:
        """
        The URI of the file containing user information (in /etc/passwd file format). This field must be populated when 'usernameSource' is set to 'File'.
        """
        return pulumi.get(self, "user_file_uri")

    @property
    @pulumi.getter(name="usernameSource")
    def username_source(self) -> Optional[str]:
        """
        This setting determines how the cache gets username and group names for clients.
        """
        return pulumi.get(self, "username_source")


@pulumi.output_type
class CacheUsernameDownloadSettingsResponseCredentials(dict):
    """
    When present, these are the credentials for the secure LDAP connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindDn":
            suggest = "bind_dn"
        elif key == "bindPassword":
            suggest = "bind_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheUsernameDownloadSettingsResponseCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheUsernameDownloadSettingsResponseCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheUsernameDownloadSettingsResponseCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_dn: Optional[str] = None,
                 bind_password: Optional[str] = None):
        """
        When present, these are the credentials for the secure LDAP connection.
        :param str bind_dn: The Bind Distinguished Name identity to be used in the secure LDAP connection. This value is stored encrypted and not returned on response.
        :param str bind_password: The Bind password to be used in the secure LDAP connection. This value is stored encrypted and not returned on response.
        """
        CacheUsernameDownloadSettingsResponseCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bind_dn=bind_dn,
            bind_password=bind_password,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bind_dn: Optional[str] = None,
             bind_password: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bind_dn is None and 'bindDn' in kwargs:
            bind_dn = kwargs['bindDn']
        if bind_password is None and 'bindPassword' in kwargs:
            bind_password = kwargs['bindPassword']

        if bind_dn is not None:
            _setter("bind_dn", bind_dn)
        if bind_password is not None:
            _setter("bind_password", bind_password)

    @property
    @pulumi.getter(name="bindDn")
    def bind_dn(self) -> Optional[str]:
        """
        The Bind Distinguished Name identity to be used in the secure LDAP connection. This value is stored encrypted and not returned on response.
        """
        return pulumi.get(self, "bind_dn")

    @property
    @pulumi.getter(name="bindPassword")
    def bind_password(self) -> Optional[str]:
        """
        The Bind password to be used in the secure LDAP connection. This value is stored encrypted and not returned on response.
        """
        return pulumi.get(self, "bind_password")


@pulumi.output_type
class ClfsTargetResponse(dict):
    """
    Properties pertaining to the ClfsTarget
    """
    def __init__(__self__, *,
                 target: Optional[str] = None):
        """
        Properties pertaining to the ClfsTarget
        :param str target: Resource ID of storage container.
        """
        ClfsTargetResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if target is not None:
            _setter("target", target)

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Resource ID of storage container.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ConditionResponse(dict):
    """
    Outstanding conditions that will need to be resolved.
    """
    def __init__(__self__, *,
                 message: str,
                 timestamp: str):
        """
        Outstanding conditions that will need to be resolved.
        :param str message: The issue requiring attention.
        :param str timestamp: The time when the condition was raised.
        """
        ConditionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            message=message,
            timestamp=timestamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             message: Optional[str] = None,
             timestamp: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if message is None:
            raise TypeError("Missing 'message' argument")
        if timestamp is None:
            raise TypeError("Missing 'timestamp' argument")

        _setter("message", message)
        _setter("timestamp", timestamp)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The issue requiring attention.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def timestamp(self) -> str:
        """
        The time when the condition was raised.
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class KeyVaultKeyReferenceResponse(dict):
    """
    Describes a reference to key vault key.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyUrl":
            suggest = "key_url"
        elif key == "sourceVault":
            suggest = "source_vault"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KeyVaultKeyReferenceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KeyVaultKeyReferenceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KeyVaultKeyReferenceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_url: str,
                 source_vault: 'outputs.KeyVaultKeyReferenceResponseSourceVault'):
        """
        Describes a reference to key vault key.
        :param str key_url: The URL referencing a key encryption key in key vault.
        :param 'KeyVaultKeyReferenceResponseSourceVault' source_vault: Describes a resource Id to source key vault.
        """
        KeyVaultKeyReferenceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key_url=key_url,
            source_vault=source_vault,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key_url: Optional[str] = None,
             source_vault: Optional['outputs.KeyVaultKeyReferenceResponseSourceVault'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key_url is None and 'keyUrl' in kwargs:
            key_url = kwargs['keyUrl']
        if key_url is None:
            raise TypeError("Missing 'key_url' argument")
        if source_vault is None and 'sourceVault' in kwargs:
            source_vault = kwargs['sourceVault']
        if source_vault is None:
            raise TypeError("Missing 'source_vault' argument")

        _setter("key_url", key_url)
        _setter("source_vault", source_vault)

    @property
    @pulumi.getter(name="keyUrl")
    def key_url(self) -> str:
        """
        The URL referencing a key encryption key in key vault.
        """
        return pulumi.get(self, "key_url")

    @property
    @pulumi.getter(name="sourceVault")
    def source_vault(self) -> 'outputs.KeyVaultKeyReferenceResponseSourceVault':
        """
        Describes a resource Id to source key vault.
        """
        return pulumi.get(self, "source_vault")


@pulumi.output_type
class KeyVaultKeyReferenceResponseSourceVault(dict):
    """
    Describes a resource Id to source key vault.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Describes a resource Id to source key vault.
        :param str id: Resource Id.
        """
        KeyVaultKeyReferenceResponseSourceVault._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource Id.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NamespaceJunctionResponse(dict):
    """
    A namespace junction.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespacePath":
            suggest = "namespace_path"
        elif key == "nfsAccessPolicy":
            suggest = "nfs_access_policy"
        elif key == "nfsExport":
            suggest = "nfs_export"
        elif key == "targetPath":
            suggest = "target_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceJunctionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceJunctionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceJunctionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace_path: Optional[str] = None,
                 nfs_access_policy: Optional[str] = None,
                 nfs_export: Optional[str] = None,
                 target_path: Optional[str] = None):
        """
        A namespace junction.
        :param str namespace_path: Namespace path on a cache for a Storage Target.
        :param str nfs_access_policy: Name of the access policy applied to this junction.
        :param str nfs_export: NFS export where targetPath exists.
        :param str target_path: Path in Storage Target to which namespacePath points.
        """
        NamespaceJunctionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            namespace_path=namespace_path,
            nfs_access_policy=nfs_access_policy,
            nfs_export=nfs_export,
            target_path=target_path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             namespace_path: Optional[str] = None,
             nfs_access_policy: Optional[str] = None,
             nfs_export: Optional[str] = None,
             target_path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if namespace_path is None and 'namespacePath' in kwargs:
            namespace_path = kwargs['namespacePath']
        if nfs_access_policy is None and 'nfsAccessPolicy' in kwargs:
            nfs_access_policy = kwargs['nfsAccessPolicy']
        if nfs_export is None and 'nfsExport' in kwargs:
            nfs_export = kwargs['nfsExport']
        if target_path is None and 'targetPath' in kwargs:
            target_path = kwargs['targetPath']

        if namespace_path is not None:
            _setter("namespace_path", namespace_path)
        if nfs_access_policy is None:
            nfs_access_policy = 'default'
        if nfs_access_policy is not None:
            _setter("nfs_access_policy", nfs_access_policy)
        if nfs_export is not None:
            _setter("nfs_export", nfs_export)
        if target_path is not None:
            _setter("target_path", target_path)

    @property
    @pulumi.getter(name="namespacePath")
    def namespace_path(self) -> Optional[str]:
        """
        Namespace path on a cache for a Storage Target.
        """
        return pulumi.get(self, "namespace_path")

    @property
    @pulumi.getter(name="nfsAccessPolicy")
    def nfs_access_policy(self) -> Optional[str]:
        """
        Name of the access policy applied to this junction.
        """
        return pulumi.get(self, "nfs_access_policy")

    @property
    @pulumi.getter(name="nfsExport")
    def nfs_export(self) -> Optional[str]:
        """
        NFS export where targetPath exists.
        """
        return pulumi.get(self, "nfs_export")

    @property
    @pulumi.getter(name="targetPath")
    def target_path(self) -> Optional[str]:
        """
        Path in Storage Target to which namespacePath points.
        """
        return pulumi.get(self, "target_path")


@pulumi.output_type
class Nfs3TargetResponse(dict):
    """
    Properties pertaining to the Nfs3Target
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usageModel":
            suggest = "usage_model"
        elif key == "verificationTimer":
            suggest = "verification_timer"
        elif key == "writeBackTimer":
            suggest = "write_back_timer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Nfs3TargetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Nfs3TargetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Nfs3TargetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: Optional[str] = None,
                 usage_model: Optional[str] = None,
                 verification_timer: Optional[int] = None,
                 write_back_timer: Optional[int] = None):
        """
        Properties pertaining to the Nfs3Target
        :param str target: IP address or host name of an NFSv3 host (e.g., 10.0.44.44).
        :param str usage_model: Identifies the StorageCache usage model to be used for this storage target.
        :param int verification_timer: Amount of time (in seconds) the cache waits before it checks the back-end storage for file updates.
        :param int write_back_timer: Amount of time (in seconds) the cache waits after the last file change before it copies the changed file to back-end storage.
        """
        Nfs3TargetResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            usage_model=usage_model,
            verification_timer=verification_timer,
            write_back_timer=write_back_timer,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: Optional[str] = None,
             usage_model: Optional[str] = None,
             verification_timer: Optional[int] = None,
             write_back_timer: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if usage_model is None and 'usageModel' in kwargs:
            usage_model = kwargs['usageModel']
        if verification_timer is None and 'verificationTimer' in kwargs:
            verification_timer = kwargs['verificationTimer']
        if write_back_timer is None and 'writeBackTimer' in kwargs:
            write_back_timer = kwargs['writeBackTimer']

        if target is not None:
            _setter("target", target)
        if usage_model is not None:
            _setter("usage_model", usage_model)
        if verification_timer is not None:
            _setter("verification_timer", verification_timer)
        if write_back_timer is not None:
            _setter("write_back_timer", write_back_timer)

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        IP address or host name of an NFSv3 host (e.g., 10.0.44.44).
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="usageModel")
    def usage_model(self) -> Optional[str]:
        """
        Identifies the StorageCache usage model to be used for this storage target.
        """
        return pulumi.get(self, "usage_model")

    @property
    @pulumi.getter(name="verificationTimer")
    def verification_timer(self) -> Optional[int]:
        """
        Amount of time (in seconds) the cache waits before it checks the back-end storage for file updates.
        """
        return pulumi.get(self, "verification_timer")

    @property
    @pulumi.getter(name="writeBackTimer")
    def write_back_timer(self) -> Optional[int]:
        """
        Amount of time (in seconds) the cache waits after the last file change before it copies the changed file to back-end storage.
        """
        return pulumi.get(self, "write_back_timer")


@pulumi.output_type
class NfsAccessPolicyResponse(dict):
    """
    A set of rules describing access policies applied to NFSv3 clients of the cache.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessRules":
            suggest = "access_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NfsAccessPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NfsAccessPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NfsAccessPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_rules: Sequence['outputs.NfsAccessRuleResponse'],
                 name: str):
        """
        A set of rules describing access policies applied to NFSv3 clients of the cache.
        :param Sequence['NfsAccessRuleResponse'] access_rules: The set of rules describing client accesses allowed under this policy.
        :param str name: Name identifying this policy. Access Policy names are not case sensitive.
        """
        NfsAccessPolicyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_rules=access_rules,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_rules: Optional[Sequence['outputs.NfsAccessRuleResponse']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access_rules is None and 'accessRules' in kwargs:
            access_rules = kwargs['accessRules']
        if access_rules is None:
            raise TypeError("Missing 'access_rules' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")

        _setter("access_rules", access_rules)
        _setter("name", name)

    @property
    @pulumi.getter(name="accessRules")
    def access_rules(self) -> Sequence['outputs.NfsAccessRuleResponse']:
        """
        The set of rules describing client accesses allowed under this policy.
        """
        return pulumi.get(self, "access_rules")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name identifying this policy. Access Policy names are not case sensitive.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NfsAccessRuleResponse(dict):
    """
    Rule to place restrictions on portions of the cache namespace being presented to clients.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anonymousGID":
            suggest = "anonymous_gid"
        elif key == "anonymousUID":
            suggest = "anonymous_uid"
        elif key == "rootSquash":
            suggest = "root_squash"
        elif key == "submountAccess":
            suggest = "submount_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NfsAccessRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NfsAccessRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NfsAccessRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access: str,
                 scope: str,
                 anonymous_gid: Optional[str] = None,
                 anonymous_uid: Optional[str] = None,
                 filter: Optional[str] = None,
                 root_squash: Optional[bool] = None,
                 submount_access: Optional[bool] = None,
                 suid: Optional[bool] = None):
        """
        Rule to place restrictions on portions of the cache namespace being presented to clients.
        :param str access: Access allowed by this rule.
        :param str scope: Scope for this rule. The scope and filter determine which clients match the rule.
        :param str anonymous_gid: GID value that replaces 0 when rootSquash is true. This will use the value of anonymousUID if not provided.
        :param str anonymous_uid: UID value that replaces 0 when rootSquash is true. 65534 will be used if not provided.
        :param str filter: Filter applied to the scope for this rule. The filter's format depends on its scope. 'default' scope matches all clients and has no filter value. 'network' scope takes a filter in CIDR format (for example, 10.99.1.0/24). 'host' takes an IP address or fully qualified domain name as filter. If a client does not match any filter rule and there is no default rule, access is denied.
        :param bool root_squash: Map root accesses to anonymousUID and anonymousGID.
        :param bool submount_access: For the default policy, allow access to subdirectories under the root export. If this is set to no, clients can only mount the path '/'. If set to yes, clients can mount a deeper path, like '/a/b'.
        :param bool suid: Allow SUID semantics.
        """
        NfsAccessRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access=access,
            scope=scope,
            anonymous_gid=anonymous_gid,
            anonymous_uid=anonymous_uid,
            filter=filter,
            root_squash=root_squash,
            submount_access=submount_access,
            suid=suid,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access: Optional[str] = None,
             scope: Optional[str] = None,
             anonymous_gid: Optional[str] = None,
             anonymous_uid: Optional[str] = None,
             filter: Optional[str] = None,
             root_squash: Optional[bool] = None,
             submount_access: Optional[bool] = None,
             suid: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if access is None:
            raise TypeError("Missing 'access' argument")
        if scope is None:
            raise TypeError("Missing 'scope' argument")
        if anonymous_gid is None and 'anonymousGID' in kwargs:
            anonymous_gid = kwargs['anonymousGID']
        if anonymous_uid is None and 'anonymousUID' in kwargs:
            anonymous_uid = kwargs['anonymousUID']
        if root_squash is None and 'rootSquash' in kwargs:
            root_squash = kwargs['rootSquash']
        if submount_access is None and 'submountAccess' in kwargs:
            submount_access = kwargs['submountAccess']

        _setter("access", access)
        _setter("scope", scope)
        if anonymous_gid is not None:
            _setter("anonymous_gid", anonymous_gid)
        if anonymous_uid is not None:
            _setter("anonymous_uid", anonymous_uid)
        if filter is not None:
            _setter("filter", filter)
        if root_squash is not None:
            _setter("root_squash", root_squash)
        if submount_access is not None:
            _setter("submount_access", submount_access)
        if suid is not None:
            _setter("suid", suid)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        Access allowed by this rule.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        Scope for this rule. The scope and filter determine which clients match the rule.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="anonymousGID")
    def anonymous_gid(self) -> Optional[str]:
        """
        GID value that replaces 0 when rootSquash is true. This will use the value of anonymousUID if not provided.
        """
        return pulumi.get(self, "anonymous_gid")

    @property
    @pulumi.getter(name="anonymousUID")
    def anonymous_uid(self) -> Optional[str]:
        """
        UID value that replaces 0 when rootSquash is true. 65534 will be used if not provided.
        """
        return pulumi.get(self, "anonymous_uid")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        Filter applied to the scope for this rule. The filter's format depends on its scope. 'default' scope matches all clients and has no filter value. 'network' scope takes a filter in CIDR format (for example, 10.99.1.0/24). 'host' takes an IP address or fully qualified domain name as filter. If a client does not match any filter rule and there is no default rule, access is denied.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="rootSquash")
    def root_squash(self) -> Optional[bool]:
        """
        Map root accesses to anonymousUID and anonymousGID.
        """
        return pulumi.get(self, "root_squash")

    @property
    @pulumi.getter(name="submountAccess")
    def submount_access(self) -> Optional[bool]:
        """
        For the default policy, allow access to subdirectories under the root export. If this is set to no, clients can only mount the path '/'. If set to yes, clients can mount a deeper path, like '/a/b'.
        """
        return pulumi.get(self, "submount_access")

    @property
    @pulumi.getter
    def suid(self) -> Optional[bool]:
        """
        Allow SUID semantics.
        """
        return pulumi.get(self, "suid")


@pulumi.output_type
class PrimingJobResponse(dict):
    """
    A priming job instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primingJobDetails":
            suggest = "priming_job_details"
        elif key == "primingJobId":
            suggest = "priming_job_id"
        elif key == "primingJobName":
            suggest = "priming_job_name"
        elif key == "primingJobPercentComplete":
            suggest = "priming_job_percent_complete"
        elif key == "primingJobState":
            suggest = "priming_job_state"
        elif key == "primingJobStatus":
            suggest = "priming_job_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrimingJobResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrimingJobResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrimingJobResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 priming_job_details: str,
                 priming_job_id: str,
                 priming_job_name: str,
                 priming_job_percent_complete: float,
                 priming_job_state: str,
                 priming_job_status: str):
        """
        A priming job instance.
        :param str priming_job_details: The job details or error information if any.
        :param str priming_job_id: The unique identifier of the priming job.
        :param str priming_job_name: The priming job name.
        :param float priming_job_percent_complete: The current progress of the priming job, as a percentage.
        :param str priming_job_state: The state of the priming operation.
        :param str priming_job_status: The status code of the priming job.
        """
        PrimingJobResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priming_job_details=priming_job_details,
            priming_job_id=priming_job_id,
            priming_job_name=priming_job_name,
            priming_job_percent_complete=priming_job_percent_complete,
            priming_job_state=priming_job_state,
            priming_job_status=priming_job_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priming_job_details: Optional[str] = None,
             priming_job_id: Optional[str] = None,
             priming_job_name: Optional[str] = None,
             priming_job_percent_complete: Optional[float] = None,
             priming_job_state: Optional[str] = None,
             priming_job_status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if priming_job_details is None and 'primingJobDetails' in kwargs:
            priming_job_details = kwargs['primingJobDetails']
        if priming_job_details is None:
            raise TypeError("Missing 'priming_job_details' argument")
        if priming_job_id is None and 'primingJobId' in kwargs:
            priming_job_id = kwargs['primingJobId']
        if priming_job_id is None:
            raise TypeError("Missing 'priming_job_id' argument")
        if priming_job_name is None and 'primingJobName' in kwargs:
            priming_job_name = kwargs['primingJobName']
        if priming_job_name is None:
            raise TypeError("Missing 'priming_job_name' argument")
        if priming_job_percent_complete is None and 'primingJobPercentComplete' in kwargs:
            priming_job_percent_complete = kwargs['primingJobPercentComplete']
        if priming_job_percent_complete is None:
            raise TypeError("Missing 'priming_job_percent_complete' argument")
        if priming_job_state is None and 'primingJobState' in kwargs:
            priming_job_state = kwargs['primingJobState']
        if priming_job_state is None:
            raise TypeError("Missing 'priming_job_state' argument")
        if priming_job_status is None and 'primingJobStatus' in kwargs:
            priming_job_status = kwargs['primingJobStatus']
        if priming_job_status is None:
            raise TypeError("Missing 'priming_job_status' argument")

        _setter("priming_job_details", priming_job_details)
        _setter("priming_job_id", priming_job_id)
        _setter("priming_job_name", priming_job_name)
        _setter("priming_job_percent_complete", priming_job_percent_complete)
        _setter("priming_job_state", priming_job_state)
        _setter("priming_job_status", priming_job_status)

    @property
    @pulumi.getter(name="primingJobDetails")
    def priming_job_details(self) -> str:
        """
        The job details or error information if any.
        """
        return pulumi.get(self, "priming_job_details")

    @property
    @pulumi.getter(name="primingJobId")
    def priming_job_id(self) -> str:
        """
        The unique identifier of the priming job.
        """
        return pulumi.get(self, "priming_job_id")

    @property
    @pulumi.getter(name="primingJobName")
    def priming_job_name(self) -> str:
        """
        The priming job name.
        """
        return pulumi.get(self, "priming_job_name")

    @property
    @pulumi.getter(name="primingJobPercentComplete")
    def priming_job_percent_complete(self) -> float:
        """
        The current progress of the priming job, as a percentage.
        """
        return pulumi.get(self, "priming_job_percent_complete")

    @property
    @pulumi.getter(name="primingJobState")
    def priming_job_state(self) -> str:
        """
        The state of the priming operation.
        """
        return pulumi.get(self, "priming_job_state")

    @property
    @pulumi.getter(name="primingJobStatus")
    def priming_job_status(self) -> str:
        """
        The status code of the priming job.
        """
        return pulumi.get(self, "priming_job_status")


@pulumi.output_type
class SkuNameResponse(dict):
    """
    SKU for the resource.
    """
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        SKU for the resource.
        :param str name: SKU name for this resource.
        """
        SkuNameResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        SKU name for this resource.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class StorageTargetSpaceAllocationResponse(dict):
    """
    Storage Target space allocation properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationPercentage":
            suggest = "allocation_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageTargetSpaceAllocationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageTargetSpaceAllocationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageTargetSpaceAllocationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_percentage: Optional[int] = None,
                 name: Optional[str] = None):
        """
        Storage Target space allocation properties.
        :param int allocation_percentage: The percentage of cache space allocated for this storage target
        :param str name: Name of the storage target.
        """
        StorageTargetSpaceAllocationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allocation_percentage=allocation_percentage,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allocation_percentage: Optional[int] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allocation_percentage is None and 'allocationPercentage' in kwargs:
            allocation_percentage = kwargs['allocationPercentage']

        if allocation_percentage is not None:
            _setter("allocation_percentage", allocation_percentage)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="allocationPercentage")
    def allocation_percentage(self) -> Optional[int]:
        """
        The percentage of cache space allocated for this storage target
        """
        return pulumi.get(self, "allocation_percentage")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the storage target.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UnknownTargetResponse(dict):
    """
    Properties pertaining to the UnknownTarget
    """
    def __init__(__self__, *,
                 attributes: Optional[Mapping[str, str]] = None):
        """
        Properties pertaining to the UnknownTarget
        :param Mapping[str, str] attributes: Dictionary of string->string pairs containing information about the Storage Target.
        """
        UnknownTargetResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attributes=attributes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attributes: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if attributes is not None:
            _setter("attributes", attributes)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, str]]:
        """
        Dictionary of string->string pairs containing information about the Storage Target.
        """
        return pulumi.get(self, "attributes")


@pulumi.output_type
class UserAssignedIdentitiesResponseUserAssignedIdentities(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentitiesResponseUserAssignedIdentities. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentitiesResponseUserAssignedIdentities.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentitiesResponseUserAssignedIdentities.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        :param str client_id: The client ID of the user-assigned identity.
        :param str principal_id: The principal ID of the user-assigned identity.
        """
        UserAssignedIdentitiesResponseUserAssignedIdentities._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            principal_id=principal_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[str] = None,
             principal_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if client_id is None and 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if client_id is None:
            raise TypeError("Missing 'client_id' argument")
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")

        _setter("client_id", client_id)
        _setter("principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the user-assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the user-assigned identity.
        """
        return pulumi.get(self, "principal_id")


