# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AgentUpgradeArgs',
    'AgentUpgradeArgsDict',
    'HybridComputePrivateLinkScopePropertiesArgs',
    'HybridComputePrivateLinkScopePropertiesArgsDict',
    'IdentityArgs',
    'IdentityArgsDict',
    'LicenseDetailsArgs',
    'LicenseDetailsArgsDict',
    'LicenseProfileMachineInstanceViewEsuPropertiesArgs',
    'LicenseProfileMachineInstanceViewEsuPropertiesArgsDict',
    'LicenseProfileMachineInstanceViewArgs',
    'LicenseProfileMachineInstanceViewArgsDict',
    'LicenseArgs',
    'LicenseArgsDict',
    'LocationDataArgs',
    'LocationDataArgsDict',
    'MachineExtensionInstanceViewStatusArgs',
    'MachineExtensionInstanceViewStatusArgsDict',
    'MachineExtensionInstanceViewArgs',
    'MachineExtensionInstanceViewArgsDict',
    'MachineExtensionPropertiesArgs',
    'MachineExtensionPropertiesArgsDict',
    'MachineRunCommandScriptSourceArgs',
    'MachineRunCommandScriptSourceArgsDict',
    'OSProfileLinuxConfigurationArgs',
    'OSProfileLinuxConfigurationArgsDict',
    'OSProfileWindowsConfigurationArgs',
    'OSProfileWindowsConfigurationArgsDict',
    'OSProfileArgs',
    'OSProfileArgsDict',
    'PrivateEndpointConnectionPropertiesArgs',
    'PrivateEndpointConnectionPropertiesArgsDict',
    'PrivateEndpointPropertyArgs',
    'PrivateEndpointPropertyArgsDict',
    'PrivateLinkServiceConnectionStatePropertyArgs',
    'PrivateLinkServiceConnectionStatePropertyArgsDict',
    'ProductFeatureArgs',
    'ProductFeatureArgsDict',
    'RunCommandInputParameterArgs',
    'RunCommandInputParameterArgsDict',
    'RunCommandManagedIdentityArgs',
    'RunCommandManagedIdentityArgsDict',
    'ServiceStatusesArgs',
    'ServiceStatusesArgsDict',
    'ServiceStatusArgs',
    'ServiceStatusArgsDict',
    'VolumeLicenseDetailsArgs',
    'VolumeLicenseDetailsArgsDict',
]

MYPY = False

if not MYPY:
    class AgentUpgradeArgsDict(TypedDict):
        """
        The info w.r.t Agent Upgrade.
        """
        correlation_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The correlation ID passed in from RSM per upgrade.
        """
        desired_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the version info w.r.t AgentUpgrade for the machine.
        """
        enable_automatic_upgrade: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies if RSM should try to upgrade this machine
        """
elif False:
    AgentUpgradeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentUpgradeArgs:
    def __init__(__self__, *,
                 correlation_id: Optional[pulumi.Input[builtins.str]] = None,
                 desired_version: Optional[pulumi.Input[builtins.str]] = None,
                 enable_automatic_upgrade: Optional[pulumi.Input[builtins.bool]] = None):
        """
        The info w.r.t Agent Upgrade.
        :param pulumi.Input[builtins.str] correlation_id: The correlation ID passed in from RSM per upgrade.
        :param pulumi.Input[builtins.str] desired_version: Specifies the version info w.r.t AgentUpgrade for the machine.
        :param pulumi.Input[builtins.bool] enable_automatic_upgrade: Specifies if RSM should try to upgrade this machine
        """
        if correlation_id is not None:
            pulumi.set(__self__, "correlation_id", correlation_id)
        if desired_version is not None:
            pulumi.set(__self__, "desired_version", desired_version)
        if enable_automatic_upgrade is not None:
            pulumi.set(__self__, "enable_automatic_upgrade", enable_automatic_upgrade)

    @property
    @pulumi.getter(name="correlationId")
    def correlation_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The correlation ID passed in from RSM per upgrade.
        """
        return pulumi.get(self, "correlation_id")

    @correlation_id.setter
    def correlation_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "correlation_id", value)

    @property
    @pulumi.getter(name="desiredVersion")
    def desired_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the version info w.r.t AgentUpgrade for the machine.
        """
        return pulumi.get(self, "desired_version")

    @desired_version.setter
    def desired_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "desired_version", value)

    @property
    @pulumi.getter(name="enableAutomaticUpgrade")
    def enable_automatic_upgrade(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies if RSM should try to upgrade this machine
        """
        return pulumi.get(self, "enable_automatic_upgrade")

    @enable_automatic_upgrade.setter
    def enable_automatic_upgrade(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_automatic_upgrade", value)


if not MYPY:
    class HybridComputePrivateLinkScopePropertiesArgsDict(TypedDict):
        """
        Properties that define a Azure Arc PrivateLinkScope resource.
        """
        public_network_access: NotRequired[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessType']]]
        """
        Indicates whether machines associated with the private link scope can also use public Azure Arc service endpoints.
        """
elif False:
    HybridComputePrivateLinkScopePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HybridComputePrivateLinkScopePropertiesArgs:
    def __init__(__self__, *,
                 public_network_access: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessType']]] = None):
        """
        Properties that define a Azure Arc PrivateLinkScope resource.
        :param pulumi.Input[Union[builtins.str, 'PublicNetworkAccessType']] public_network_access: Indicates whether machines associated with the private link scope can also use public Azure Arc service endpoints.
        """
        if public_network_access is not None:
            pulumi.set(__self__, "public_network_access", public_network_access)

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessType']]]:
        """
        Indicates whether machines associated with the private link scope can also use public Azure Arc service endpoints.
        """
        return pulumi.get(self, "public_network_access")

    @public_network_access.setter
    def public_network_access(self, value: Optional[pulumi.Input[Union[builtins.str, 'PublicNetworkAccessType']]]):
        pulumi.set(self, "public_network_access", value)


if not MYPY:
    class IdentityArgsDict(TypedDict):
        """
        Identity for the resource.
        """
        type: NotRequired[pulumi.Input['ResourceIdentityType']]
        """
        The identity type.
        """
elif False:
    IdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ResourceIdentityType']] = None):
        """
        Identity for the resource.
        :param pulumi.Input['ResourceIdentityType'] type: The identity type.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ResourceIdentityType']]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ResourceIdentityType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LicenseDetailsArgsDict(TypedDict):
        """
        Describes the properties of a License.
        """
        edition: NotRequired[pulumi.Input[Union[builtins.str, 'LicenseEdition']]]
        """
        Describes the edition of the license. The values are either Standard or Datacenter.
        """
        processors: NotRequired[pulumi.Input[builtins.int]]
        """
        Describes the number of processors.
        """
        state: NotRequired[pulumi.Input[Union[builtins.str, 'LicenseState']]]
        """
        Describes the state of the license.
        """
        target: NotRequired[pulumi.Input[Union[builtins.str, 'LicenseTarget']]]
        """
        Describes the license target server.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'LicenseCoreType']]]
        """
        Describes the license core type (pCore or vCore).
        """
        volume_license_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeLicenseDetailsArgsDict']]]]
        """
        A list of volume license details.
        """
elif False:
    LicenseDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicenseDetailsArgs:
    def __init__(__self__, *,
                 edition: Optional[pulumi.Input[Union[builtins.str, 'LicenseEdition']]] = None,
                 processors: Optional[pulumi.Input[builtins.int]] = None,
                 state: Optional[pulumi.Input[Union[builtins.str, 'LicenseState']]] = None,
                 target: Optional[pulumi.Input[Union[builtins.str, 'LicenseTarget']]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'LicenseCoreType']]] = None,
                 volume_license_details: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeLicenseDetailsArgs']]]] = None):
        """
        Describes the properties of a License.
        :param pulumi.Input[Union[builtins.str, 'LicenseEdition']] edition: Describes the edition of the license. The values are either Standard or Datacenter.
        :param pulumi.Input[builtins.int] processors: Describes the number of processors.
        :param pulumi.Input[Union[builtins.str, 'LicenseState']] state: Describes the state of the license.
        :param pulumi.Input[Union[builtins.str, 'LicenseTarget']] target: Describes the license target server.
        :param pulumi.Input[Union[builtins.str, 'LicenseCoreType']] type: Describes the license core type (pCore or vCore).
        :param pulumi.Input[Sequence[pulumi.Input['VolumeLicenseDetailsArgs']]] volume_license_details: A list of volume license details.
        """
        if edition is not None:
            pulumi.set(__self__, "edition", edition)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if volume_license_details is not None:
            pulumi.set(__self__, "volume_license_details", volume_license_details)

    @property
    @pulumi.getter
    def edition(self) -> Optional[pulumi.Input[Union[builtins.str, 'LicenseEdition']]]:
        """
        Describes the edition of the license. The values are either Standard or Datacenter.
        """
        return pulumi.get(self, "edition")

    @edition.setter
    def edition(self, value: Optional[pulumi.Input[Union[builtins.str, 'LicenseEdition']]]):
        pulumi.set(self, "edition", value)

    @property
    @pulumi.getter
    def processors(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Describes the number of processors.
        """
        return pulumi.get(self, "processors")

    @processors.setter
    def processors(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "processors", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[Union[builtins.str, 'LicenseState']]]:
        """
        Describes the state of the license.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[Union[builtins.str, 'LicenseState']]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[Union[builtins.str, 'LicenseTarget']]]:
        """
        Describes the license target server.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[Union[builtins.str, 'LicenseTarget']]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'LicenseCoreType']]]:
        """
        Describes the license core type (pCore or vCore).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'LicenseCoreType']]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="volumeLicenseDetails")
    def volume_license_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeLicenseDetailsArgs']]]]:
        """
        A list of volume license details.
        """
        return pulumi.get(self, "volume_license_details")

    @volume_license_details.setter
    def volume_license_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeLicenseDetailsArgs']]]]):
        pulumi.set(self, "volume_license_details", value)


if not MYPY:
    class LicenseProfileMachineInstanceViewEsuPropertiesArgsDict(TypedDict):
        """
        Properties for the Machine ESU profile.
        """
        assigned_license: NotRequired[pulumi.Input['LicenseArgsDict']]
        """
        The assigned license resource.
        """
        license_assignment_state: NotRequired[pulumi.Input[Union[builtins.str, 'LicenseAssignmentState']]]
        """
        Describes the license assignment state (Assigned or NotAssigned).
        """
elif False:
    LicenseProfileMachineInstanceViewEsuPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicenseProfileMachineInstanceViewEsuPropertiesArgs:
    def __init__(__self__, *,
                 assigned_license: Optional[pulumi.Input['LicenseArgs']] = None,
                 license_assignment_state: Optional[pulumi.Input[Union[builtins.str, 'LicenseAssignmentState']]] = None):
        """
        Properties for the Machine ESU profile.
        :param pulumi.Input['LicenseArgs'] assigned_license: The assigned license resource.
        :param pulumi.Input[Union[builtins.str, 'LicenseAssignmentState']] license_assignment_state: Describes the license assignment state (Assigned or NotAssigned).
        """
        if assigned_license is not None:
            pulumi.set(__self__, "assigned_license", assigned_license)
        if license_assignment_state is not None:
            pulumi.set(__self__, "license_assignment_state", license_assignment_state)

    @property
    @pulumi.getter(name="assignedLicense")
    def assigned_license(self) -> Optional[pulumi.Input['LicenseArgs']]:
        """
        The assigned license resource.
        """
        return pulumi.get(self, "assigned_license")

    @assigned_license.setter
    def assigned_license(self, value: Optional[pulumi.Input['LicenseArgs']]):
        pulumi.set(self, "assigned_license", value)

    @property
    @pulumi.getter(name="licenseAssignmentState")
    def license_assignment_state(self) -> Optional[pulumi.Input[Union[builtins.str, 'LicenseAssignmentState']]]:
        """
        Describes the license assignment state (Assigned or NotAssigned).
        """
        return pulumi.get(self, "license_assignment_state")

    @license_assignment_state.setter
    def license_assignment_state(self, value: Optional[pulumi.Input[Union[builtins.str, 'LicenseAssignmentState']]]):
        pulumi.set(self, "license_assignment_state", value)


if not MYPY:
    class LicenseProfileMachineInstanceViewArgsDict(TypedDict):
        """
        License Profile Instance View in Machine Properties.
        """
        esu_profile: NotRequired[pulumi.Input['LicenseProfileMachineInstanceViewEsuPropertiesArgsDict']]
        """
        Properties for the Machine ESU profile.
        """
        product_features: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProductFeatureArgsDict']]]]
        """
        The list of product features.
        """
        product_type: NotRequired[pulumi.Input[Union[builtins.str, 'LicenseProfileProductType']]]
        """
        Indicates the product type of the license.
        """
        software_assurance_customer: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies if this machine is licensed as part of a Software Assurance agreement.
        """
        subscription_status: NotRequired[pulumi.Input[Union[builtins.str, 'LicenseProfileSubscriptionStatus']]]
        """
        Indicates the subscription status of the product.
        """
elif False:
    LicenseProfileMachineInstanceViewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicenseProfileMachineInstanceViewArgs:
    def __init__(__self__, *,
                 esu_profile: Optional[pulumi.Input['LicenseProfileMachineInstanceViewEsuPropertiesArgs']] = None,
                 product_features: Optional[pulumi.Input[Sequence[pulumi.Input['ProductFeatureArgs']]]] = None,
                 product_type: Optional[pulumi.Input[Union[builtins.str, 'LicenseProfileProductType']]] = None,
                 software_assurance_customer: Optional[pulumi.Input[builtins.bool]] = None,
                 subscription_status: Optional[pulumi.Input[Union[builtins.str, 'LicenseProfileSubscriptionStatus']]] = None):
        """
        License Profile Instance View in Machine Properties.
        :param pulumi.Input['LicenseProfileMachineInstanceViewEsuPropertiesArgs'] esu_profile: Properties for the Machine ESU profile.
        :param pulumi.Input[Sequence[pulumi.Input['ProductFeatureArgs']]] product_features: The list of product features.
        :param pulumi.Input[Union[builtins.str, 'LicenseProfileProductType']] product_type: Indicates the product type of the license.
        :param pulumi.Input[builtins.bool] software_assurance_customer: Specifies if this machine is licensed as part of a Software Assurance agreement.
        :param pulumi.Input[Union[builtins.str, 'LicenseProfileSubscriptionStatus']] subscription_status: Indicates the subscription status of the product.
        """
        if esu_profile is not None:
            pulumi.set(__self__, "esu_profile", esu_profile)
        if product_features is not None:
            pulumi.set(__self__, "product_features", product_features)
        if product_type is not None:
            pulumi.set(__self__, "product_type", product_type)
        if software_assurance_customer is not None:
            pulumi.set(__self__, "software_assurance_customer", software_assurance_customer)
        if subscription_status is not None:
            pulumi.set(__self__, "subscription_status", subscription_status)

    @property
    @pulumi.getter(name="esuProfile")
    def esu_profile(self) -> Optional[pulumi.Input['LicenseProfileMachineInstanceViewEsuPropertiesArgs']]:
        """
        Properties for the Machine ESU profile.
        """
        return pulumi.get(self, "esu_profile")

    @esu_profile.setter
    def esu_profile(self, value: Optional[pulumi.Input['LicenseProfileMachineInstanceViewEsuPropertiesArgs']]):
        pulumi.set(self, "esu_profile", value)

    @property
    @pulumi.getter(name="productFeatures")
    def product_features(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProductFeatureArgs']]]]:
        """
        The list of product features.
        """
        return pulumi.get(self, "product_features")

    @product_features.setter
    def product_features(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProductFeatureArgs']]]]):
        pulumi.set(self, "product_features", value)

    @property
    @pulumi.getter(name="productType")
    def product_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'LicenseProfileProductType']]]:
        """
        Indicates the product type of the license.
        """
        return pulumi.get(self, "product_type")

    @product_type.setter
    def product_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'LicenseProfileProductType']]]):
        pulumi.set(self, "product_type", value)

    @property
    @pulumi.getter(name="softwareAssuranceCustomer")
    def software_assurance_customer(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies if this machine is licensed as part of a Software Assurance agreement.
        """
        return pulumi.get(self, "software_assurance_customer")

    @software_assurance_customer.setter
    def software_assurance_customer(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "software_assurance_customer", value)

    @property
    @pulumi.getter(name="subscriptionStatus")
    def subscription_status(self) -> Optional[pulumi.Input[Union[builtins.str, 'LicenseProfileSubscriptionStatus']]]:
        """
        Indicates the subscription status of the product.
        """
        return pulumi.get(self, "subscription_status")

    @subscription_status.setter
    def subscription_status(self, value: Optional[pulumi.Input[Union[builtins.str, 'LicenseProfileSubscriptionStatus']]]):
        pulumi.set(self, "subscription_status", value)


if not MYPY:
    class LicenseArgsDict(TypedDict):
        """
        Describes a license in a hybrid machine.
        """
        location: pulumi.Input[builtins.str]
        """
        The geo-location where the resource lives
        """
        license_details: NotRequired[pulumi.Input['LicenseDetailsArgsDict']]
        """
        Describes the properties of a License.
        """
        license_type: NotRequired[pulumi.Input[Union[builtins.str, 'LicenseType']]]
        """
        The type of the license resource.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Resource tags.
        """
        tenant_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Describes the tenant id.
        """
elif False:
    LicenseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicenseArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[builtins.str],
                 license_details: Optional[pulumi.Input['LicenseDetailsArgs']] = None,
                 license_type: Optional[pulumi.Input[Union[builtins.str, 'LicenseType']]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 tenant_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Describes a license in a hybrid machine.
        :param pulumi.Input[builtins.str] location: The geo-location where the resource lives
        :param pulumi.Input['LicenseDetailsArgs'] license_details: Describes the properties of a License.
        :param pulumi.Input[Union[builtins.str, 'LicenseType']] license_type: The type of the license resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] tags: Resource tags.
        :param pulumi.Input[builtins.str] tenant_id: Describes the tenant id.
        """
        pulumi.set(__self__, "location", location)
        if license_details is not None:
            pulumi.set(__self__, "license_details", license_details)
        if license_type is not None:
            pulumi.set(__self__, "license_type", license_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[builtins.str]:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="licenseDetails")
    def license_details(self) -> Optional[pulumi.Input['LicenseDetailsArgs']]:
        """
        Describes the properties of a License.
        """
        return pulumi.get(self, "license_details")

    @license_details.setter
    def license_details(self, value: Optional[pulumi.Input['LicenseDetailsArgs']]):
        pulumi.set(self, "license_details", value)

    @property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'LicenseType']]]:
        """
        The type of the license resource.
        """
        return pulumi.get(self, "license_type")

    @license_type.setter
    def license_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'LicenseType']]]):
        pulumi.set(self, "license_type", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Describes the tenant id.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class LocationDataArgsDict(TypedDict):
        """
        Metadata pertaining to the geographic location of the resource.
        """
        name: pulumi.Input[builtins.str]
        """
        A canonical name for the geographic or physical location.
        """
        city: NotRequired[pulumi.Input[builtins.str]]
        """
        The city or locality where the resource is located.
        """
        country_or_region: NotRequired[pulumi.Input[builtins.str]]
        """
        The country or region where the resource is located
        """
        district: NotRequired[pulumi.Input[builtins.str]]
        """
        The district, state, or province where the resource is located.
        """
elif False:
    LocationDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocationDataArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 city: Optional[pulumi.Input[builtins.str]] = None,
                 country_or_region: Optional[pulumi.Input[builtins.str]] = None,
                 district: Optional[pulumi.Input[builtins.str]] = None):
        """
        Metadata pertaining to the geographic location of the resource.
        :param pulumi.Input[builtins.str] name: A canonical name for the geographic or physical location.
        :param pulumi.Input[builtins.str] city: The city or locality where the resource is located.
        :param pulumi.Input[builtins.str] country_or_region: The country or region where the resource is located
        :param pulumi.Input[builtins.str] district: The district, state, or province where the resource is located.
        """
        pulumi.set(__self__, "name", name)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country_or_region is not None:
            pulumi.set(__self__, "country_or_region", country_or_region)
        if district is not None:
            pulumi.set(__self__, "district", district)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        A canonical name for the geographic or physical location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The city or locality where the resource is located.
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "city", value)

    @property
    @pulumi.getter(name="countryOrRegion")
    def country_or_region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The country or region where the resource is located
        """
        return pulumi.get(self, "country_or_region")

    @country_or_region.setter
    def country_or_region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "country_or_region", value)

    @property
    @pulumi.getter
    def district(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The district, state, or province where the resource is located.
        """
        return pulumi.get(self, "district")

    @district.setter
    def district(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "district", value)


if not MYPY:
    class MachineExtensionInstanceViewStatusArgsDict(TypedDict):
        """
        Instance view status.
        """
        code: NotRequired[pulumi.Input[builtins.str]]
        """
        The status code.
        """
        display_status: NotRequired[pulumi.Input[builtins.str]]
        """
        The short localizable label for the status.
        """
        level: NotRequired[pulumi.Input[Union[builtins.str, 'StatusLevelTypes']]]
        """
        The level code.
        """
        message: NotRequired[pulumi.Input[builtins.str]]
        """
        The detailed status message, including for alerts and error messages.
        """
        time: NotRequired[pulumi.Input[builtins.str]]
        """
        The time of the status.
        """
elif False:
    MachineExtensionInstanceViewStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineExtensionInstanceViewStatusArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[builtins.str]] = None,
                 display_status: Optional[pulumi.Input[builtins.str]] = None,
                 level: Optional[pulumi.Input[Union[builtins.str, 'StatusLevelTypes']]] = None,
                 message: Optional[pulumi.Input[builtins.str]] = None,
                 time: Optional[pulumi.Input[builtins.str]] = None):
        """
        Instance view status.
        :param pulumi.Input[builtins.str] code: The status code.
        :param pulumi.Input[builtins.str] display_status: The short localizable label for the status.
        :param pulumi.Input[Union[builtins.str, 'StatusLevelTypes']] level: The level code.
        :param pulumi.Input[builtins.str] message: The detailed status message, including for alerts and error messages.
        :param pulumi.Input[builtins.str] time: The time of the status.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if display_status is not None:
            pulumi.set(__self__, "display_status", display_status)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The status code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter(name="displayStatus")
    def display_status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The short localizable label for the status.
        """
        return pulumi.get(self, "display_status")

    @display_status.setter
    def display_status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_status", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[Union[builtins.str, 'StatusLevelTypes']]]:
        """
        The level code.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[Union[builtins.str, 'StatusLevelTypes']]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The detailed status message, including for alerts and error messages.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The time of the status.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time", value)


if not MYPY:
    class MachineExtensionInstanceViewArgsDict(TypedDict):
        """
        Describes the Machine Extension Instance View.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The machine extension name.
        """
        status: NotRequired[pulumi.Input['MachineExtensionInstanceViewStatusArgsDict']]
        """
        Instance view status.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the type of the extension; an example is "CustomScriptExtension".
        """
        type_handler_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the version of the script handler.
        """
elif False:
    MachineExtensionInstanceViewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineExtensionInstanceViewArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input['MachineExtensionInstanceViewStatusArgs']] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 type_handler_version: Optional[pulumi.Input[builtins.str]] = None):
        """
        Describes the Machine Extension Instance View.
        :param pulumi.Input[builtins.str] name: The machine extension name.
        :param pulumi.Input['MachineExtensionInstanceViewStatusArgs'] status: Instance view status.
        :param pulumi.Input[builtins.str] type: Specifies the type of the extension; an example is "CustomScriptExtension".
        :param pulumi.Input[builtins.str] type_handler_version: Specifies the version of the script handler.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type_handler_version is not None:
            pulumi.set(__self__, "type_handler_version", type_handler_version)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The machine extension name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['MachineExtensionInstanceViewStatusArgs']]:
        """
        Instance view status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['MachineExtensionInstanceViewStatusArgs']]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the type of the extension; an example is "CustomScriptExtension".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the version of the script handler.
        """
        return pulumi.get(self, "type_handler_version")

    @type_handler_version.setter
    def type_handler_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_handler_version", value)


if not MYPY:
    class MachineExtensionPropertiesArgsDict(TypedDict):
        """
        Describes the properties of a Machine Extension.
        """
        auto_upgrade_minor_version: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
        """
        enable_automatic_upgrade: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether the extension should be automatically upgraded by the platform if there is a newer version available.
        """
        force_update_tag: NotRequired[pulumi.Input[builtins.str]]
        """
        How the extension handler should be forced to update even if the extension configuration has not changed.
        """
        instance_view: NotRequired[pulumi.Input['MachineExtensionInstanceViewArgsDict']]
        """
        The machine extension instance view.
        """
        protected_settings: NotRequired[Any]
        """
        The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
        """
        publisher: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the extension handler publisher.
        """
        settings: NotRequired[Any]
        """
        Json formatted public settings for the extension.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the type of the extension; an example is "CustomScriptExtension".
        """
        type_handler_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the version of the script handler.
        """
elif False:
    MachineExtensionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineExtensionPropertiesArgs:
    def __init__(__self__, *,
                 auto_upgrade_minor_version: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_automatic_upgrade: Optional[pulumi.Input[builtins.bool]] = None,
                 force_update_tag: Optional[pulumi.Input[builtins.str]] = None,
                 instance_view: Optional[pulumi.Input['MachineExtensionInstanceViewArgs']] = None,
                 protected_settings: Optional[Any] = None,
                 publisher: Optional[pulumi.Input[builtins.str]] = None,
                 settings: Optional[Any] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 type_handler_version: Optional[pulumi.Input[builtins.str]] = None):
        """
        Describes the properties of a Machine Extension.
        :param pulumi.Input[builtins.bool] auto_upgrade_minor_version: Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
        :param pulumi.Input[builtins.bool] enable_automatic_upgrade: Indicates whether the extension should be automatically upgraded by the platform if there is a newer version available.
        :param pulumi.Input[builtins.str] force_update_tag: How the extension handler should be forced to update even if the extension configuration has not changed.
        :param pulumi.Input['MachineExtensionInstanceViewArgs'] instance_view: The machine extension instance view.
        :param Any protected_settings: The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
        :param pulumi.Input[builtins.str] publisher: The name of the extension handler publisher.
        :param Any settings: Json formatted public settings for the extension.
        :param pulumi.Input[builtins.str] type: Specifies the type of the extension; an example is "CustomScriptExtension".
        :param pulumi.Input[builtins.str] type_handler_version: Specifies the version of the script handler.
        """
        if auto_upgrade_minor_version is not None:
            pulumi.set(__self__, "auto_upgrade_minor_version", auto_upgrade_minor_version)
        if enable_automatic_upgrade is not None:
            pulumi.set(__self__, "enable_automatic_upgrade", enable_automatic_upgrade)
        if force_update_tag is not None:
            pulumi.set(__self__, "force_update_tag", force_update_tag)
        if instance_view is not None:
            pulumi.set(__self__, "instance_view", instance_view)
        if protected_settings is not None:
            pulumi.set(__self__, "protected_settings", protected_settings)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if type_handler_version is not None:
            pulumi.set(__self__, "type_handler_version", type_handler_version)

    @property
    @pulumi.getter(name="autoUpgradeMinorVersion")
    def auto_upgrade_minor_version(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
        """
        return pulumi.get(self, "auto_upgrade_minor_version")

    @auto_upgrade_minor_version.setter
    def auto_upgrade_minor_version(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "auto_upgrade_minor_version", value)

    @property
    @pulumi.getter(name="enableAutomaticUpgrade")
    def enable_automatic_upgrade(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether the extension should be automatically upgraded by the platform if there is a newer version available.
        """
        return pulumi.get(self, "enable_automatic_upgrade")

    @enable_automatic_upgrade.setter
    def enable_automatic_upgrade(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_automatic_upgrade", value)

    @property
    @pulumi.getter(name="forceUpdateTag")
    def force_update_tag(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        How the extension handler should be forced to update even if the extension configuration has not changed.
        """
        return pulumi.get(self, "force_update_tag")

    @force_update_tag.setter
    def force_update_tag(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "force_update_tag", value)

    @property
    @pulumi.getter(name="instanceView")
    def instance_view(self) -> Optional[pulumi.Input['MachineExtensionInstanceViewArgs']]:
        """
        The machine extension instance view.
        """
        return pulumi.get(self, "instance_view")

    @instance_view.setter
    def instance_view(self, value: Optional[pulumi.Input['MachineExtensionInstanceViewArgs']]):
        pulumi.set(self, "instance_view", value)

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[Any]:
        """
        The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
        """
        return pulumi.get(self, "protected_settings")

    @protected_settings.setter
    def protected_settings(self, value: Optional[Any]):
        pulumi.set(self, "protected_settings", value)

    @property
    @pulumi.getter
    def publisher(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the extension handler publisher.
        """
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "publisher", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[Any]:
        """
        Json formatted public settings for the extension.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[Any]):
        pulumi.set(self, "settings", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the type of the extension; an example is "CustomScriptExtension".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the version of the script handler.
        """
        return pulumi.get(self, "type_handler_version")

    @type_handler_version.setter
    def type_handler_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_handler_version", value)


if not MYPY:
    class MachineRunCommandScriptSourceArgsDict(TypedDict):
        """
        Describes the script sources for run command. Use only one of script, scriptUri, commandId.
        """
        command_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the commandId of predefined built-in script.
        """
        script: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the script content to be executed on the machine.
        """
        script_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the script download location. It can be either SAS URI of an Azure storage blob with read access or public URI.
        """
        script_uri_managed_identity: NotRequired[pulumi.Input['RunCommandManagedIdentityArgsDict']]
        """
        User-assigned managed identity that has access to scriptUri in case of Azure storage blob. Use an empty object in case of system-assigned identity. Make sure the Azure storage blob exists, and managed identity has been given access to blob's container with 'Storage Blob Data Reader' role assignment. In case of user-assigned identity, make sure you add it under VM's identity. For more info on managed identity and Run Command, refer https://aka.ms/ManagedIdentity and https://aka.ms/RunCommandManaged.
        """
elif False:
    MachineRunCommandScriptSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineRunCommandScriptSourceArgs:
    def __init__(__self__, *,
                 command_id: Optional[pulumi.Input[builtins.str]] = None,
                 script: Optional[pulumi.Input[builtins.str]] = None,
                 script_uri: Optional[pulumi.Input[builtins.str]] = None,
                 script_uri_managed_identity: Optional[pulumi.Input['RunCommandManagedIdentityArgs']] = None):
        """
        Describes the script sources for run command. Use only one of script, scriptUri, commandId.
        :param pulumi.Input[builtins.str] command_id: Specifies the commandId of predefined built-in script.
        :param pulumi.Input[builtins.str] script: Specifies the script content to be executed on the machine.
        :param pulumi.Input[builtins.str] script_uri: Specifies the script download location. It can be either SAS URI of an Azure storage blob with read access or public URI.
        :param pulumi.Input['RunCommandManagedIdentityArgs'] script_uri_managed_identity: User-assigned managed identity that has access to scriptUri in case of Azure storage blob. Use an empty object in case of system-assigned identity. Make sure the Azure storage blob exists, and managed identity has been given access to blob's container with 'Storage Blob Data Reader' role assignment. In case of user-assigned identity, make sure you add it under VM's identity. For more info on managed identity and Run Command, refer https://aka.ms/ManagedIdentity and https://aka.ms/RunCommandManaged.
        """
        if command_id is not None:
            pulumi.set(__self__, "command_id", command_id)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if script_uri is not None:
            pulumi.set(__self__, "script_uri", script_uri)
        if script_uri_managed_identity is not None:
            pulumi.set(__self__, "script_uri_managed_identity", script_uri_managed_identity)

    @property
    @pulumi.getter(name="commandId")
    def command_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the commandId of predefined built-in script.
        """
        return pulumi.get(self, "command_id")

    @command_id.setter
    def command_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "command_id", value)

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the script content to be executed on the machine.
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "script", value)

    @property
    @pulumi.getter(name="scriptUri")
    def script_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the script download location. It can be either SAS URI of an Azure storage blob with read access or public URI.
        """
        return pulumi.get(self, "script_uri")

    @script_uri.setter
    def script_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "script_uri", value)

    @property
    @pulumi.getter(name="scriptUriManagedIdentity")
    def script_uri_managed_identity(self) -> Optional[pulumi.Input['RunCommandManagedIdentityArgs']]:
        """
        User-assigned managed identity that has access to scriptUri in case of Azure storage blob. Use an empty object in case of system-assigned identity. Make sure the Azure storage blob exists, and managed identity has been given access to blob's container with 'Storage Blob Data Reader' role assignment. In case of user-assigned identity, make sure you add it under VM's identity. For more info on managed identity and Run Command, refer https://aka.ms/ManagedIdentity and https://aka.ms/RunCommandManaged.
        """
        return pulumi.get(self, "script_uri_managed_identity")

    @script_uri_managed_identity.setter
    def script_uri_managed_identity(self, value: Optional[pulumi.Input['RunCommandManagedIdentityArgs']]):
        pulumi.set(self, "script_uri_managed_identity", value)


if not MYPY:
    class OSProfileLinuxConfigurationArgsDict(TypedDict):
        """
        Specifies the linux configuration for update management.
        """
        assessment_mode: NotRequired[pulumi.Input[Union[builtins.str, 'AssessmentModeTypes']]]
        """
        Specifies the assessment mode.
        """
        enable_hotpatching: NotRequired[pulumi.Input[builtins.bool]]
        """
        Captures the hotpatch capability enrollment intent of the customers, which enables customers to patch their Windows machines without requiring a reboot.
        """
        patch_mode: NotRequired[pulumi.Input[Union[builtins.str, 'PatchModeTypes']]]
        """
        Specifies the patch mode.
        """
elif False:
    OSProfileLinuxConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OSProfileLinuxConfigurationArgs:
    def __init__(__self__, *,
                 assessment_mode: Optional[pulumi.Input[Union[builtins.str, 'AssessmentModeTypes']]] = None,
                 enable_hotpatching: Optional[pulumi.Input[builtins.bool]] = None,
                 patch_mode: Optional[pulumi.Input[Union[builtins.str, 'PatchModeTypes']]] = None):
        """
        Specifies the linux configuration for update management.
        :param pulumi.Input[Union[builtins.str, 'AssessmentModeTypes']] assessment_mode: Specifies the assessment mode.
        :param pulumi.Input[builtins.bool] enable_hotpatching: Captures the hotpatch capability enrollment intent of the customers, which enables customers to patch their Windows machines without requiring a reboot.
        :param pulumi.Input[Union[builtins.str, 'PatchModeTypes']] patch_mode: Specifies the patch mode.
        """
        if assessment_mode is not None:
            pulumi.set(__self__, "assessment_mode", assessment_mode)
        if enable_hotpatching is not None:
            pulumi.set(__self__, "enable_hotpatching", enable_hotpatching)
        if patch_mode is not None:
            pulumi.set(__self__, "patch_mode", patch_mode)

    @property
    @pulumi.getter(name="assessmentMode")
    def assessment_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'AssessmentModeTypes']]]:
        """
        Specifies the assessment mode.
        """
        return pulumi.get(self, "assessment_mode")

    @assessment_mode.setter
    def assessment_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'AssessmentModeTypes']]]):
        pulumi.set(self, "assessment_mode", value)

    @property
    @pulumi.getter(name="enableHotpatching")
    def enable_hotpatching(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Captures the hotpatch capability enrollment intent of the customers, which enables customers to patch their Windows machines without requiring a reboot.
        """
        return pulumi.get(self, "enable_hotpatching")

    @enable_hotpatching.setter
    def enable_hotpatching(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_hotpatching", value)

    @property
    @pulumi.getter(name="patchMode")
    def patch_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'PatchModeTypes']]]:
        """
        Specifies the patch mode.
        """
        return pulumi.get(self, "patch_mode")

    @patch_mode.setter
    def patch_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'PatchModeTypes']]]):
        pulumi.set(self, "patch_mode", value)


if not MYPY:
    class OSProfileWindowsConfigurationArgsDict(TypedDict):
        """
        Specifies the windows configuration for update management.
        """
        assessment_mode: NotRequired[pulumi.Input[Union[builtins.str, 'AssessmentModeTypes']]]
        """
        Specifies the assessment mode.
        """
        enable_hotpatching: NotRequired[pulumi.Input[builtins.bool]]
        """
        Captures the hotpatch capability enrollment intent of the customers, which enables customers to patch their Windows machines without requiring a reboot.
        """
        patch_mode: NotRequired[pulumi.Input[Union[builtins.str, 'PatchModeTypes']]]
        """
        Specifies the patch mode.
        """
elif False:
    OSProfileWindowsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OSProfileWindowsConfigurationArgs:
    def __init__(__self__, *,
                 assessment_mode: Optional[pulumi.Input[Union[builtins.str, 'AssessmentModeTypes']]] = None,
                 enable_hotpatching: Optional[pulumi.Input[builtins.bool]] = None,
                 patch_mode: Optional[pulumi.Input[Union[builtins.str, 'PatchModeTypes']]] = None):
        """
        Specifies the windows configuration for update management.
        :param pulumi.Input[Union[builtins.str, 'AssessmentModeTypes']] assessment_mode: Specifies the assessment mode.
        :param pulumi.Input[builtins.bool] enable_hotpatching: Captures the hotpatch capability enrollment intent of the customers, which enables customers to patch their Windows machines without requiring a reboot.
        :param pulumi.Input[Union[builtins.str, 'PatchModeTypes']] patch_mode: Specifies the patch mode.
        """
        if assessment_mode is not None:
            pulumi.set(__self__, "assessment_mode", assessment_mode)
        if enable_hotpatching is not None:
            pulumi.set(__self__, "enable_hotpatching", enable_hotpatching)
        if patch_mode is not None:
            pulumi.set(__self__, "patch_mode", patch_mode)

    @property
    @pulumi.getter(name="assessmentMode")
    def assessment_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'AssessmentModeTypes']]]:
        """
        Specifies the assessment mode.
        """
        return pulumi.get(self, "assessment_mode")

    @assessment_mode.setter
    def assessment_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'AssessmentModeTypes']]]):
        pulumi.set(self, "assessment_mode", value)

    @property
    @pulumi.getter(name="enableHotpatching")
    def enable_hotpatching(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Captures the hotpatch capability enrollment intent of the customers, which enables customers to patch their Windows machines without requiring a reboot.
        """
        return pulumi.get(self, "enable_hotpatching")

    @enable_hotpatching.setter
    def enable_hotpatching(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_hotpatching", value)

    @property
    @pulumi.getter(name="patchMode")
    def patch_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'PatchModeTypes']]]:
        """
        Specifies the patch mode.
        """
        return pulumi.get(self, "patch_mode")

    @patch_mode.setter
    def patch_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'PatchModeTypes']]]):
        pulumi.set(self, "patch_mode", value)


if not MYPY:
    class OSProfileArgsDict(TypedDict):
        """
        Specifies the operating system settings for the hybrid machine.
        """
        linux_configuration: NotRequired[pulumi.Input['OSProfileLinuxConfigurationArgsDict']]
        """
        Specifies the linux configuration for update management.
        """
        windows_configuration: NotRequired[pulumi.Input['OSProfileWindowsConfigurationArgsDict']]
        """
        Specifies the windows configuration for update management.
        """
elif False:
    OSProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OSProfileArgs:
    def __init__(__self__, *,
                 linux_configuration: Optional[pulumi.Input['OSProfileLinuxConfigurationArgs']] = None,
                 windows_configuration: Optional[pulumi.Input['OSProfileWindowsConfigurationArgs']] = None):
        """
        Specifies the operating system settings for the hybrid machine.
        :param pulumi.Input['OSProfileLinuxConfigurationArgs'] linux_configuration: Specifies the linux configuration for update management.
        :param pulumi.Input['OSProfileWindowsConfigurationArgs'] windows_configuration: Specifies the windows configuration for update management.
        """
        if linux_configuration is not None:
            pulumi.set(__self__, "linux_configuration", linux_configuration)
        if windows_configuration is not None:
            pulumi.set(__self__, "windows_configuration", windows_configuration)

    @property
    @pulumi.getter(name="linuxConfiguration")
    def linux_configuration(self) -> Optional[pulumi.Input['OSProfileLinuxConfigurationArgs']]:
        """
        Specifies the linux configuration for update management.
        """
        return pulumi.get(self, "linux_configuration")

    @linux_configuration.setter
    def linux_configuration(self, value: Optional[pulumi.Input['OSProfileLinuxConfigurationArgs']]):
        pulumi.set(self, "linux_configuration", value)

    @property
    @pulumi.getter(name="windowsConfiguration")
    def windows_configuration(self) -> Optional[pulumi.Input['OSProfileWindowsConfigurationArgs']]:
        """
        Specifies the windows configuration for update management.
        """
        return pulumi.get(self, "windows_configuration")

    @windows_configuration.setter
    def windows_configuration(self, value: Optional[pulumi.Input['OSProfileWindowsConfigurationArgs']]):
        pulumi.set(self, "windows_configuration", value)


if not MYPY:
    class PrivateEndpointConnectionPropertiesArgsDict(TypedDict):
        """
        Properties of a private endpoint connection.
        """
        private_endpoint: NotRequired[pulumi.Input['PrivateEndpointPropertyArgsDict']]
        """
        Private endpoint which the connection belongs to.
        """
        private_link_service_connection_state: NotRequired[pulumi.Input['PrivateLinkServiceConnectionStatePropertyArgsDict']]
        """
        Connection state of the private endpoint connection.
        """
elif False:
    PrivateEndpointConnectionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateEndpointConnectionPropertiesArgs:
    def __init__(__self__, *,
                 private_endpoint: Optional[pulumi.Input['PrivateEndpointPropertyArgs']] = None,
                 private_link_service_connection_state: Optional[pulumi.Input['PrivateLinkServiceConnectionStatePropertyArgs']] = None):
        """
        Properties of a private endpoint connection.
        :param pulumi.Input['PrivateEndpointPropertyArgs'] private_endpoint: Private endpoint which the connection belongs to.
        :param pulumi.Input['PrivateLinkServiceConnectionStatePropertyArgs'] private_link_service_connection_state: Connection state of the private endpoint connection.
        """
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if private_link_service_connection_state is not None:
            pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional[pulumi.Input['PrivateEndpointPropertyArgs']]:
        """
        Private endpoint which the connection belongs to.
        """
        return pulumi.get(self, "private_endpoint")

    @private_endpoint.setter
    def private_endpoint(self, value: Optional[pulumi.Input['PrivateEndpointPropertyArgs']]):
        pulumi.set(self, "private_endpoint", value)

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> Optional[pulumi.Input['PrivateLinkServiceConnectionStatePropertyArgs']]:
        """
        Connection state of the private endpoint connection.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @private_link_service_connection_state.setter
    def private_link_service_connection_state(self, value: Optional[pulumi.Input['PrivateLinkServiceConnectionStatePropertyArgs']]):
        pulumi.set(self, "private_link_service_connection_state", value)


if not MYPY:
    class PrivateEndpointPropertyArgsDict(TypedDict):
        """
        Private endpoint which the connection belongs to.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource id of the private endpoint.
        """
elif False:
    PrivateEndpointPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateEndpointPropertyArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Private endpoint which the connection belongs to.
        :param pulumi.Input[builtins.str] id: Resource id of the private endpoint.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource id of the private endpoint.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PrivateLinkServiceConnectionStatePropertyArgsDict(TypedDict):
        """
        State of the private endpoint connection.
        """
        description: pulumi.Input[builtins.str]
        """
        The private link service connection description.
        """
        status: pulumi.Input[builtins.str]
        """
        The private link service connection status.
        """
elif False:
    PrivateLinkServiceConnectionStatePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateLinkServiceConnectionStatePropertyArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[builtins.str],
                 status: pulumi.Input[builtins.str]):
        """
        State of the private endpoint connection.
        :param pulumi.Input[builtins.str] description: The private link service connection description.
        :param pulumi.Input[builtins.str] status: The private link service connection status.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def description(self) -> pulumi.Input[builtins.str]:
        """
        The private link service connection description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[builtins.str]:
        """
        The private link service connection status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ProductFeatureArgsDict(TypedDict):
        """
        Product Feature
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Product feature name.
        """
        subscription_status: NotRequired[pulumi.Input[Union[builtins.str, 'LicenseProfileSubscriptionStatus']]]
        """
        Indicates the current status of the product features.
        """
elif False:
    ProductFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProductFeatureArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 subscription_status: Optional[pulumi.Input[Union[builtins.str, 'LicenseProfileSubscriptionStatus']]] = None):
        """
        Product Feature
        :param pulumi.Input[builtins.str] name: Product feature name.
        :param pulumi.Input[Union[builtins.str, 'LicenseProfileSubscriptionStatus']] subscription_status: Indicates the current status of the product features.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subscription_status is not None:
            pulumi.set(__self__, "subscription_status", subscription_status)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Product feature name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="subscriptionStatus")
    def subscription_status(self) -> Optional[pulumi.Input[Union[builtins.str, 'LicenseProfileSubscriptionStatus']]]:
        """
        Indicates the current status of the product features.
        """
        return pulumi.get(self, "subscription_status")

    @subscription_status.setter
    def subscription_status(self, value: Optional[pulumi.Input[Union[builtins.str, 'LicenseProfileSubscriptionStatus']]]):
        pulumi.set(self, "subscription_status", value)


if not MYPY:
    class RunCommandInputParameterArgsDict(TypedDict):
        """
        Describes the properties of a run command parameter.
        """
        name: pulumi.Input[builtins.str]
        """
        The run command parameter name.
        """
        value: pulumi.Input[builtins.str]
        """
        The run command parameter value.
        """
elif False:
    RunCommandInputParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunCommandInputParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        Describes the properties of a run command parameter.
        :param pulumi.Input[builtins.str] name: The run command parameter name.
        :param pulumi.Input[builtins.str] value: The run command parameter value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The run command parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The run command parameter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RunCommandManagedIdentityArgsDict(TypedDict):
        """
         Contains clientId or objectId (use only one, not both) of a user-assigned managed identity that has access to storage blob used in Run Command. Use an empty RunCommandManagedIdentity object in case of system-assigned identity. Make sure the Azure storage blob exists in case of scriptUri, and managed identity has been given access to blob's container with 'Storage Blob Data Reader' role assignment with scriptUri blob and 'Storage Blob Data Contributor' for Append blobs(outputBlobUri, errorBlobUri). In case of user assigned identity, make sure you add it under VM's identity. For more info on managed identity and Run Command, refer https://aka.ms/ManagedIdentity and https://aka.ms/RunCommandManaged.
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Client Id (GUID value) of the user-assigned managed identity. ObjectId should not be used if this is provided.
        """
        object_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Object Id (GUID value) of the user-assigned managed identity. ClientId should not be used if this is provided.
        """
elif False:
    RunCommandManagedIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RunCommandManagedIdentityArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 object_id: Optional[pulumi.Input[builtins.str]] = None):
        """
         Contains clientId or objectId (use only one, not both) of a user-assigned managed identity that has access to storage blob used in Run Command. Use an empty RunCommandManagedIdentity object in case of system-assigned identity. Make sure the Azure storage blob exists in case of scriptUri, and managed identity has been given access to blob's container with 'Storage Blob Data Reader' role assignment with scriptUri blob and 'Storage Blob Data Contributor' for Append blobs(outputBlobUri, errorBlobUri). In case of user assigned identity, make sure you add it under VM's identity. For more info on managed identity and Run Command, refer https://aka.ms/ManagedIdentity and https://aka.ms/RunCommandManaged.
        :param pulumi.Input[builtins.str] client_id: Client Id (GUID value) of the user-assigned managed identity. ObjectId should not be used if this is provided.
        :param pulumi.Input[builtins.str] object_id: Object Id (GUID value) of the user-assigned managed identity. ClientId should not be used if this is provided.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Client Id (GUID value) of the user-assigned managed identity. ObjectId should not be used if this is provided.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Object Id (GUID value) of the user-assigned managed identity. ClientId should not be used if this is provided.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "object_id", value)


if not MYPY:
    class ServiceStatusesArgsDict(TypedDict):
        """
        Reports the state and behavior of dependent services.
        """
        extension_service: NotRequired[pulumi.Input['ServiceStatusArgsDict']]
        """
        The state of the extension service on the Arc-enabled machine.
        """
        guest_configuration_service: NotRequired[pulumi.Input['ServiceStatusArgsDict']]
        """
        The state of the guest configuration service on the Arc-enabled machine.
        """
elif False:
    ServiceStatusesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceStatusesArgs:
    def __init__(__self__, *,
                 extension_service: Optional[pulumi.Input['ServiceStatusArgs']] = None,
                 guest_configuration_service: Optional[pulumi.Input['ServiceStatusArgs']] = None):
        """
        Reports the state and behavior of dependent services.
        :param pulumi.Input['ServiceStatusArgs'] extension_service: The state of the extension service on the Arc-enabled machine.
        :param pulumi.Input['ServiceStatusArgs'] guest_configuration_service: The state of the guest configuration service on the Arc-enabled machine.
        """
        if extension_service is not None:
            pulumi.set(__self__, "extension_service", extension_service)
        if guest_configuration_service is not None:
            pulumi.set(__self__, "guest_configuration_service", guest_configuration_service)

    @property
    @pulumi.getter(name="extensionService")
    def extension_service(self) -> Optional[pulumi.Input['ServiceStatusArgs']]:
        """
        The state of the extension service on the Arc-enabled machine.
        """
        return pulumi.get(self, "extension_service")

    @extension_service.setter
    def extension_service(self, value: Optional[pulumi.Input['ServiceStatusArgs']]):
        pulumi.set(self, "extension_service", value)

    @property
    @pulumi.getter(name="guestConfigurationService")
    def guest_configuration_service(self) -> Optional[pulumi.Input['ServiceStatusArgs']]:
        """
        The state of the guest configuration service on the Arc-enabled machine.
        """
        return pulumi.get(self, "guest_configuration_service")

    @guest_configuration_service.setter
    def guest_configuration_service(self, value: Optional[pulumi.Input['ServiceStatusArgs']]):
        pulumi.set(self, "guest_configuration_service", value)


if not MYPY:
    class ServiceStatusArgsDict(TypedDict):
        """
        Describes the status and behavior of a service.
        """
        startup_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The behavior of the service when the Arc-enabled machine starts up.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        The current status of the service.
        """
elif False:
    ServiceStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceStatusArgs:
    def __init__(__self__, *,
                 startup_type: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None):
        """
        Describes the status and behavior of a service.
        :param pulumi.Input[builtins.str] startup_type: The behavior of the service when the Arc-enabled machine starts up.
        :param pulumi.Input[builtins.str] status: The current status of the service.
        """
        if startup_type is not None:
            pulumi.set(__self__, "startup_type", startup_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="startupType")
    def startup_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The behavior of the service when the Arc-enabled machine starts up.
        """
        return pulumi.get(self, "startup_type")

    @startup_type.setter
    def startup_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "startup_type", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The current status of the service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class VolumeLicenseDetailsArgsDict(TypedDict):
        invoice_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The invoice id for the volume license.
        """
        program_year: NotRequired[pulumi.Input[Union[builtins.str, 'ProgramYear']]]
        """
        Describes the program year the volume license is for.
        """
elif False:
    VolumeLicenseDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeLicenseDetailsArgs:
    def __init__(__self__, *,
                 invoice_id: Optional[pulumi.Input[builtins.str]] = None,
                 program_year: Optional[pulumi.Input[Union[builtins.str, 'ProgramYear']]] = None):
        """
        :param pulumi.Input[builtins.str] invoice_id: The invoice id for the volume license.
        :param pulumi.Input[Union[builtins.str, 'ProgramYear']] program_year: Describes the program year the volume license is for.
        """
        if invoice_id is not None:
            pulumi.set(__self__, "invoice_id", invoice_id)
        if program_year is not None:
            pulumi.set(__self__, "program_year", program_year)

    @property
    @pulumi.getter(name="invoiceId")
    def invoice_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The invoice id for the volume license.
        """
        return pulumi.get(self, "invoice_id")

    @invoice_id.setter
    def invoice_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "invoice_id", value)

    @property
    @pulumi.getter(name="programYear")
    def program_year(self) -> Optional[pulumi.Input[Union[builtins.str, 'ProgramYear']]]:
        """
        Describes the program year the volume license is for.
        """
        return pulumi.get(self, "program_year")

    @program_year.setter
    def program_year(self, value: Optional[pulumi.Input[Union[builtins.str, 'ProgramYear']]]):
        pulumi.set(self, "program_year", value)


