# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AgentConfigurationResponse',
    'AgentUpgradeResponse',
    'CloudMetadataResponse',
    'ConfigurationExtensionResponse',
    'ErrorAdditionalInfoResponse',
    'ErrorDetailResponse',
    'EsuKeyResponse',
    'HybridComputePrivateLinkScopePropertiesResponse',
    'IdentityResponse',
    'IpAddressResponse',
    'LicenseDetailsResponse',
    'LicenseProfileMachineInstanceViewEsuPropertiesResponse',
    'LicenseProfileMachineInstanceViewResponse',
    'LicenseResponse',
    'LocationDataResponse',
    'MachineExtensionInstanceViewResponse',
    'MachineExtensionInstanceViewResponseStatus',
    'MachineExtensionPropertiesResponse',
    'MachineExtensionResponse',
    'NetworkInterfaceResponse',
    'NetworkProfileResponse',
    'OSProfileResponse',
    'OSProfileResponseLinuxConfiguration',
    'OSProfileResponseWindowsConfiguration',
    'PrivateEndpointConnectionDataModelResponse',
    'PrivateEndpointConnectionPropertiesResponse',
    'PrivateEndpointPropertyResponse',
    'PrivateLinkServiceConnectionStatePropertyResponse',
    'ServiceStatusResponse',
    'ServiceStatusesResponse',
    'SubnetResponse',
    'SystemDataResponse',
]

@pulumi.output_type
class AgentConfigurationResponse(dict):
    """
    Configurable properties that the user can set locally via the azcmagent config command, or remotely via ARM.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMode":
            suggest = "config_mode"
        elif key == "extensionsAllowList":
            suggest = "extensions_allow_list"
        elif key == "extensionsBlockList":
            suggest = "extensions_block_list"
        elif key == "extensionsEnabled":
            suggest = "extensions_enabled"
        elif key == "guestConfigurationEnabled":
            suggest = "guest_configuration_enabled"
        elif key == "incomingConnectionsPorts":
            suggest = "incoming_connections_ports"
        elif key == "proxyBypass":
            suggest = "proxy_bypass"
        elif key == "proxyUrl":
            suggest = "proxy_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_mode: str,
                 extensions_allow_list: Sequence['outputs.ConfigurationExtensionResponse'],
                 extensions_block_list: Sequence['outputs.ConfigurationExtensionResponse'],
                 extensions_enabled: str,
                 guest_configuration_enabled: str,
                 incoming_connections_ports: Sequence[str],
                 proxy_bypass: Sequence[str],
                 proxy_url: str):
        """
        Configurable properties that the user can set locally via the azcmagent config command, or remotely via ARM.
        :param str config_mode: Name of configuration mode to use. Modes are pre-defined configurations of security controls, extension allowlists and guest configuration, maintained by Microsoft.
        :param Sequence['ConfigurationExtensionResponse'] extensions_allow_list: Array of extensions that are allowed to be installed or updated.
        :param Sequence['ConfigurationExtensionResponse'] extensions_block_list: Array of extensions that are blocked (cannot be installed or updated)
        :param str extensions_enabled: Specifies whether the extension service is enabled or disabled.
        :param str guest_configuration_enabled: Specified whether the guest configuration service is enabled or disabled.
        :param Sequence[str] incoming_connections_ports: Specifies the list of ports that the agent will be able to listen on.
        :param Sequence[str] proxy_bypass: List of service names which should not use the specified proxy server.
        :param str proxy_url: Specifies the URL of the proxy to be used.
        """
        AgentConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_mode=config_mode,
            extensions_allow_list=extensions_allow_list,
            extensions_block_list=extensions_block_list,
            extensions_enabled=extensions_enabled,
            guest_configuration_enabled=guest_configuration_enabled,
            incoming_connections_ports=incoming_connections_ports,
            proxy_bypass=proxy_bypass,
            proxy_url=proxy_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_mode: Optional[str] = None,
             extensions_allow_list: Optional[Sequence['outputs.ConfigurationExtensionResponse']] = None,
             extensions_block_list: Optional[Sequence['outputs.ConfigurationExtensionResponse']] = None,
             extensions_enabled: Optional[str] = None,
             guest_configuration_enabled: Optional[str] = None,
             incoming_connections_ports: Optional[Sequence[str]] = None,
             proxy_bypass: Optional[Sequence[str]] = None,
             proxy_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if config_mode is None and 'configMode' in kwargs:
            config_mode = kwargs['configMode']
        if config_mode is None:
            raise TypeError("Missing 'config_mode' argument")
        if extensions_allow_list is None and 'extensionsAllowList' in kwargs:
            extensions_allow_list = kwargs['extensionsAllowList']
        if extensions_allow_list is None:
            raise TypeError("Missing 'extensions_allow_list' argument")
        if extensions_block_list is None and 'extensionsBlockList' in kwargs:
            extensions_block_list = kwargs['extensionsBlockList']
        if extensions_block_list is None:
            raise TypeError("Missing 'extensions_block_list' argument")
        if extensions_enabled is None and 'extensionsEnabled' in kwargs:
            extensions_enabled = kwargs['extensionsEnabled']
        if extensions_enabled is None:
            raise TypeError("Missing 'extensions_enabled' argument")
        if guest_configuration_enabled is None and 'guestConfigurationEnabled' in kwargs:
            guest_configuration_enabled = kwargs['guestConfigurationEnabled']
        if guest_configuration_enabled is None:
            raise TypeError("Missing 'guest_configuration_enabled' argument")
        if incoming_connections_ports is None and 'incomingConnectionsPorts' in kwargs:
            incoming_connections_ports = kwargs['incomingConnectionsPorts']
        if incoming_connections_ports is None:
            raise TypeError("Missing 'incoming_connections_ports' argument")
        if proxy_bypass is None and 'proxyBypass' in kwargs:
            proxy_bypass = kwargs['proxyBypass']
        if proxy_bypass is None:
            raise TypeError("Missing 'proxy_bypass' argument")
        if proxy_url is None and 'proxyUrl' in kwargs:
            proxy_url = kwargs['proxyUrl']
        if proxy_url is None:
            raise TypeError("Missing 'proxy_url' argument")

        _setter("config_mode", config_mode)
        _setter("extensions_allow_list", extensions_allow_list)
        _setter("extensions_block_list", extensions_block_list)
        _setter("extensions_enabled", extensions_enabled)
        _setter("guest_configuration_enabled", guest_configuration_enabled)
        _setter("incoming_connections_ports", incoming_connections_ports)
        _setter("proxy_bypass", proxy_bypass)
        _setter("proxy_url", proxy_url)

    @property
    @pulumi.getter(name="configMode")
    def config_mode(self) -> str:
        """
        Name of configuration mode to use. Modes are pre-defined configurations of security controls, extension allowlists and guest configuration, maintained by Microsoft.
        """
        return pulumi.get(self, "config_mode")

    @property
    @pulumi.getter(name="extensionsAllowList")
    def extensions_allow_list(self) -> Sequence['outputs.ConfigurationExtensionResponse']:
        """
        Array of extensions that are allowed to be installed or updated.
        """
        return pulumi.get(self, "extensions_allow_list")

    @property
    @pulumi.getter(name="extensionsBlockList")
    def extensions_block_list(self) -> Sequence['outputs.ConfigurationExtensionResponse']:
        """
        Array of extensions that are blocked (cannot be installed or updated)
        """
        return pulumi.get(self, "extensions_block_list")

    @property
    @pulumi.getter(name="extensionsEnabled")
    def extensions_enabled(self) -> str:
        """
        Specifies whether the extension service is enabled or disabled.
        """
        return pulumi.get(self, "extensions_enabled")

    @property
    @pulumi.getter(name="guestConfigurationEnabled")
    def guest_configuration_enabled(self) -> str:
        """
        Specified whether the guest configuration service is enabled or disabled.
        """
        return pulumi.get(self, "guest_configuration_enabled")

    @property
    @pulumi.getter(name="incomingConnectionsPorts")
    def incoming_connections_ports(self) -> Sequence[str]:
        """
        Specifies the list of ports that the agent will be able to listen on.
        """
        return pulumi.get(self, "incoming_connections_ports")

    @property
    @pulumi.getter(name="proxyBypass")
    def proxy_bypass(self) -> Sequence[str]:
        """
        List of service names which should not use the specified proxy server.
        """
        return pulumi.get(self, "proxy_bypass")

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> str:
        """
        Specifies the URL of the proxy to be used.
        """
        return pulumi.get(self, "proxy_url")


@pulumi.output_type
class AgentUpgradeResponse(dict):
    """
    The info w.r.t Agent Upgrade.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastAttemptDesiredVersion":
            suggest = "last_attempt_desired_version"
        elif key == "lastAttemptMessage":
            suggest = "last_attempt_message"
        elif key == "lastAttemptStatus":
            suggest = "last_attempt_status"
        elif key == "lastAttemptTimestamp":
            suggest = "last_attempt_timestamp"
        elif key == "correlationId":
            suggest = "correlation_id"
        elif key == "desiredVersion":
            suggest = "desired_version"
        elif key == "enableAutomaticUpgrade":
            suggest = "enable_automatic_upgrade"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentUpgradeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentUpgradeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentUpgradeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_attempt_desired_version: str,
                 last_attempt_message: str,
                 last_attempt_status: str,
                 last_attempt_timestamp: str,
                 correlation_id: Optional[str] = None,
                 desired_version: Optional[str] = None,
                 enable_automatic_upgrade: Optional[bool] = None):
        """
        The info w.r.t Agent Upgrade.
        :param str last_attempt_desired_version: Specifies the version of the last attempt
        :param str last_attempt_message: Failure message of last upgrade attempt if any.
        :param str last_attempt_status: Specifies the status of Agent Upgrade.
        :param str last_attempt_timestamp: Timestamp of last upgrade attempt
        :param str correlation_id: The correlation ID passed in from RSM per upgrade.
        :param str desired_version: Specifies the version info w.r.t AgentUpgrade for the machine.
        :param bool enable_automatic_upgrade: Specifies if RSM should try to upgrade this machine
        """
        AgentUpgradeResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            last_attempt_desired_version=last_attempt_desired_version,
            last_attempt_message=last_attempt_message,
            last_attempt_status=last_attempt_status,
            last_attempt_timestamp=last_attempt_timestamp,
            correlation_id=correlation_id,
            desired_version=desired_version,
            enable_automatic_upgrade=enable_automatic_upgrade,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             last_attempt_desired_version: Optional[str] = None,
             last_attempt_message: Optional[str] = None,
             last_attempt_status: Optional[str] = None,
             last_attempt_timestamp: Optional[str] = None,
             correlation_id: Optional[str] = None,
             desired_version: Optional[str] = None,
             enable_automatic_upgrade: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if last_attempt_desired_version is None and 'lastAttemptDesiredVersion' in kwargs:
            last_attempt_desired_version = kwargs['lastAttemptDesiredVersion']
        if last_attempt_desired_version is None:
            raise TypeError("Missing 'last_attempt_desired_version' argument")
        if last_attempt_message is None and 'lastAttemptMessage' in kwargs:
            last_attempt_message = kwargs['lastAttemptMessage']
        if last_attempt_message is None:
            raise TypeError("Missing 'last_attempt_message' argument")
        if last_attempt_status is None and 'lastAttemptStatus' in kwargs:
            last_attempt_status = kwargs['lastAttemptStatus']
        if last_attempt_status is None:
            raise TypeError("Missing 'last_attempt_status' argument")
        if last_attempt_timestamp is None and 'lastAttemptTimestamp' in kwargs:
            last_attempt_timestamp = kwargs['lastAttemptTimestamp']
        if last_attempt_timestamp is None:
            raise TypeError("Missing 'last_attempt_timestamp' argument")
        if correlation_id is None and 'correlationId' in kwargs:
            correlation_id = kwargs['correlationId']
        if desired_version is None and 'desiredVersion' in kwargs:
            desired_version = kwargs['desiredVersion']
        if enable_automatic_upgrade is None and 'enableAutomaticUpgrade' in kwargs:
            enable_automatic_upgrade = kwargs['enableAutomaticUpgrade']

        _setter("last_attempt_desired_version", last_attempt_desired_version)
        _setter("last_attempt_message", last_attempt_message)
        _setter("last_attempt_status", last_attempt_status)
        _setter("last_attempt_timestamp", last_attempt_timestamp)
        if correlation_id is not None:
            _setter("correlation_id", correlation_id)
        if desired_version is not None:
            _setter("desired_version", desired_version)
        if enable_automatic_upgrade is not None:
            _setter("enable_automatic_upgrade", enable_automatic_upgrade)

    @property
    @pulumi.getter(name="lastAttemptDesiredVersion")
    def last_attempt_desired_version(self) -> str:
        """
        Specifies the version of the last attempt
        """
        return pulumi.get(self, "last_attempt_desired_version")

    @property
    @pulumi.getter(name="lastAttemptMessage")
    def last_attempt_message(self) -> str:
        """
        Failure message of last upgrade attempt if any.
        """
        return pulumi.get(self, "last_attempt_message")

    @property
    @pulumi.getter(name="lastAttemptStatus")
    def last_attempt_status(self) -> str:
        """
        Specifies the status of Agent Upgrade.
        """
        return pulumi.get(self, "last_attempt_status")

    @property
    @pulumi.getter(name="lastAttemptTimestamp")
    def last_attempt_timestamp(self) -> str:
        """
        Timestamp of last upgrade attempt
        """
        return pulumi.get(self, "last_attempt_timestamp")

    @property
    @pulumi.getter(name="correlationId")
    def correlation_id(self) -> Optional[str]:
        """
        The correlation ID passed in from RSM per upgrade.
        """
        return pulumi.get(self, "correlation_id")

    @property
    @pulumi.getter(name="desiredVersion")
    def desired_version(self) -> Optional[str]:
        """
        Specifies the version info w.r.t AgentUpgrade for the machine.
        """
        return pulumi.get(self, "desired_version")

    @property
    @pulumi.getter(name="enableAutomaticUpgrade")
    def enable_automatic_upgrade(self) -> Optional[bool]:
        """
        Specifies if RSM should try to upgrade this machine
        """
        return pulumi.get(self, "enable_automatic_upgrade")


@pulumi.output_type
class CloudMetadataResponse(dict):
    """
    The metadata of the cloud environment (Azure/GCP/AWS/OCI...).
    """
    def __init__(__self__, *,
                 provider: str):
        """
        The metadata of the cloud environment (Azure/GCP/AWS/OCI...).
        :param str provider: Specifies the cloud provider (Azure/AWS/GCP...).
        """
        CloudMetadataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provider=provider,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provider: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if provider is None:
            raise TypeError("Missing 'provider' argument")

        _setter("provider", provider)

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        Specifies the cloud provider (Azure/AWS/GCP...).
        """
        return pulumi.get(self, "provider")


@pulumi.output_type
class ConfigurationExtensionResponse(dict):
    """
    Describes properties that can identify extensions.
    """
    def __init__(__self__, *,
                 publisher: str,
                 type: str):
        """
        Describes properties that can identify extensions.
        :param str publisher: Publisher of the extension.
        :param str type: Type of the extension.
        """
        ConfigurationExtensionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            publisher=publisher,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             publisher: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if publisher is None:
            raise TypeError("Missing 'publisher' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("publisher", publisher)
        _setter("type", type)

    @property
    @pulumi.getter
    def publisher(self) -> str:
        """
        Publisher of the extension.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the extension.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ErrorAdditionalInfoResponse(dict):
    """
    The resource management error additional info.
    """
    def __init__(__self__, *,
                 info: Any,
                 type: str):
        """
        The resource management error additional info.
        :param Any info: The additional info.
        :param str type: The additional info type.
        """
        ErrorAdditionalInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info=info,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info: Optional[Any] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if info is None:
            raise TypeError("Missing 'info' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("info", info)
        _setter("type", type)

    @property
    @pulumi.getter
    def info(self) -> Any:
        """
        The additional info.
        """
        return pulumi.get(self, "info")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The additional info type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ErrorDetailResponse(dict):
    """
    The error detail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalInfo":
            suggest = "additional_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ErrorDetailResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ErrorDetailResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ErrorDetailResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_info: Sequence['outputs.ErrorAdditionalInfoResponse'],
                 code: str,
                 details: Sequence['outputs.ErrorDetailResponse'],
                 message: str,
                 target: str):
        """
        The error detail.
        :param Sequence['ErrorAdditionalInfoResponse'] additional_info: The error additional info.
        :param str code: The error code.
        :param Sequence['ErrorDetailResponse'] details: The error details.
        :param str message: The error message.
        :param str target: The error target.
        """
        ErrorDetailResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_info=additional_info,
            code=code,
            details=details,
            message=message,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_info: Optional[Sequence['outputs.ErrorAdditionalInfoResponse']] = None,
             code: Optional[str] = None,
             details: Optional[Sequence['outputs.ErrorDetailResponse']] = None,
             message: Optional[str] = None,
             target: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if additional_info is None and 'additionalInfo' in kwargs:
            additional_info = kwargs['additionalInfo']
        if additional_info is None:
            raise TypeError("Missing 'additional_info' argument")
        if code is None:
            raise TypeError("Missing 'code' argument")
        if details is None:
            raise TypeError("Missing 'details' argument")
        if message is None:
            raise TypeError("Missing 'message' argument")
        if target is None:
            raise TypeError("Missing 'target' argument")

        _setter("additional_info", additional_info)
        _setter("code", code)
        _setter("details", details)
        _setter("message", message)
        _setter("target", target)

    @property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Sequence['outputs.ErrorAdditionalInfoResponse']:
        """
        The error additional info.
        """
        return pulumi.get(self, "additional_info")

    @property
    @pulumi.getter
    def code(self) -> str:
        """
        The error code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Sequence['outputs.ErrorDetailResponse']:
        """
        The error details.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        The error message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The error target.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class EsuKeyResponse(dict):
    """
    ESU key
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "licenseStatus":
            suggest = "license_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EsuKeyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EsuKeyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EsuKeyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license_status: Optional[str] = None,
                 sku: Optional[str] = None):
        """
        ESU key
        :param str license_status: The current status of the license profile key.
        :param str sku: SKU number.
        """
        EsuKeyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            license_status=license_status,
            sku=sku,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             license_status: Optional[str] = None,
             sku: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if license_status is None and 'licenseStatus' in kwargs:
            license_status = kwargs['licenseStatus']

        if license_status is not None:
            _setter("license_status", license_status)
        if sku is not None:
            _setter("sku", sku)

    @property
    @pulumi.getter(name="licenseStatus")
    def license_status(self) -> Optional[str]:
        """
        The current status of the license profile key.
        """
        return pulumi.get(self, "license_status")

    @property
    @pulumi.getter
    def sku(self) -> Optional[str]:
        """
        SKU number.
        """
        return pulumi.get(self, "sku")


@pulumi.output_type
class HybridComputePrivateLinkScopePropertiesResponse(dict):
    """
    Properties that define a Azure Arc PrivateLinkScope resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateEndpointConnections":
            suggest = "private_endpoint_connections"
        elif key == "privateLinkScopeId":
            suggest = "private_link_scope_id"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "publicNetworkAccess":
            suggest = "public_network_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HybridComputePrivateLinkScopePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HybridComputePrivateLinkScopePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HybridComputePrivateLinkScopePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_endpoint_connections: Sequence['outputs.PrivateEndpointConnectionDataModelResponse'],
                 private_link_scope_id: str,
                 provisioning_state: str,
                 public_network_access: Optional[str] = None):
        """
        Properties that define a Azure Arc PrivateLinkScope resource.
        :param Sequence['PrivateEndpointConnectionDataModelResponse'] private_endpoint_connections: The collection of associated Private Endpoint Connections.
        :param str private_link_scope_id: The Guid id of the private link scope.
        :param str provisioning_state: Current state of this PrivateLinkScope: whether or not is has been provisioned within the resource group it is defined. Users cannot change this value but are able to read from it. Values will include Provisioning ,Succeeded, Canceled and Failed.
        :param str public_network_access: Indicates whether machines associated with the private link scope can also use public Azure Arc service endpoints.
        """
        HybridComputePrivateLinkScopePropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_endpoint_connections=private_endpoint_connections,
            private_link_scope_id=private_link_scope_id,
            provisioning_state=provisioning_state,
            public_network_access=public_network_access,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_endpoint_connections: Optional[Sequence['outputs.PrivateEndpointConnectionDataModelResponse']] = None,
             private_link_scope_id: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             public_network_access: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if private_endpoint_connections is None and 'privateEndpointConnections' in kwargs:
            private_endpoint_connections = kwargs['privateEndpointConnections']
        if private_endpoint_connections is None:
            raise TypeError("Missing 'private_endpoint_connections' argument")
        if private_link_scope_id is None and 'privateLinkScopeId' in kwargs:
            private_link_scope_id = kwargs['privateLinkScopeId']
        if private_link_scope_id is None:
            raise TypeError("Missing 'private_link_scope_id' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if public_network_access is None and 'publicNetworkAccess' in kwargs:
            public_network_access = kwargs['publicNetworkAccess']

        _setter("private_endpoint_connections", private_endpoint_connections)
        _setter("private_link_scope_id", private_link_scope_id)
        _setter("provisioning_state", provisioning_state)
        if public_network_access is not None:
            _setter("public_network_access", public_network_access)

    @property
    @pulumi.getter(name="privateEndpointConnections")
    def private_endpoint_connections(self) -> Sequence['outputs.PrivateEndpointConnectionDataModelResponse']:
        """
        The collection of associated Private Endpoint Connections.
        """
        return pulumi.get(self, "private_endpoint_connections")

    @property
    @pulumi.getter(name="privateLinkScopeId")
    def private_link_scope_id(self) -> str:
        """
        The Guid id of the private link scope.
        """
        return pulumi.get(self, "private_link_scope_id")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Current state of this PrivateLinkScope: whether or not is has been provisioned within the resource group it is defined. Users cannot change this value but are able to read from it. Values will include Provisioning ,Succeeded, Canceled and Failed.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="publicNetworkAccess")
    def public_network_access(self) -> Optional[str]:
        """
        Indicates whether machines associated with the private link scope can also use public Azure Arc service endpoints.
        """
        return pulumi.get(self, "public_network_access")


@pulumi.output_type
class IdentityResponse(dict):
    """
    Identity for the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: Optional[str] = None):
        """
        Identity for the resource.
        :param str principal_id: The principal ID of resource identity.
        :param str tenant_id: The tenant ID of resource.
        :param str type: The identity type.
        """
        IdentityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            tenant_id=tenant_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if principal_id is None and 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if principal_id is None:
            raise TypeError("Missing 'principal_id' argument")
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']
        if tenant_id is None:
            raise TypeError("Missing 'tenant_id' argument")

        _setter("principal_id", principal_id)
        _setter("tenant_id", tenant_id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of resource identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of resource.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The identity type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IpAddressResponse(dict):
    """
    Describes properties of the IP address.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressVersion":
            suggest = "ip_address_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpAddressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpAddressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpAddressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet: 'outputs.SubnetResponse',
                 address: Optional[str] = None,
                 ip_address_version: Optional[str] = None):
        """
        Describes properties of the IP address.
        :param 'SubnetResponse' subnet: The subnet to which this IP address belongs.
        :param str address: Represents the IP Address.
        :param str ip_address_version: Represents the Ip Address Version.
        """
        IpAddressResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnet=subnet,
            address=address,
            ip_address_version=ip_address_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnet: Optional['outputs.SubnetResponse'] = None,
             address: Optional[str] = None,
             ip_address_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subnet is None:
            raise TypeError("Missing 'subnet' argument")
        if ip_address_version is None and 'ipAddressVersion' in kwargs:
            ip_address_version = kwargs['ipAddressVersion']

        _setter("subnet", subnet)
        if address is not None:
            _setter("address", address)
        if ip_address_version is not None:
            _setter("ip_address_version", ip_address_version)

    @property
    @pulumi.getter
    def subnet(self) -> 'outputs.SubnetResponse':
        """
        The subnet to which this IP address belongs.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Represents the IP Address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="ipAddressVersion")
    def ip_address_version(self) -> Optional[str]:
        """
        Represents the Ip Address Version.
        """
        return pulumi.get(self, "ip_address_version")


@pulumi.output_type
class LicenseDetailsResponse(dict):
    """
    Describes the properties of a License.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignedLicenses":
            suggest = "assigned_licenses"
        elif key == "immutableId":
            suggest = "immutable_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LicenseDetailsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LicenseDetailsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LicenseDetailsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assigned_licenses: int,
                 immutable_id: str,
                 edition: Optional[str] = None,
                 processors: Optional[int] = None,
                 state: Optional[str] = None,
                 target: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Describes the properties of a License.
        :param int assigned_licenses: Describes the number of assigned licenses.
        :param str immutable_id: Describes the immutable id.
        :param str edition: Describes the edition of the license. The values are either Standard or Datacenter.
        :param int processors: Describes the number of processors.
        :param str state: Describes the state of the license.
        :param str target: Describes the license target server.
        :param str type: Describes the license core type (pCore or vCore).
        """
        LicenseDetailsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assigned_licenses=assigned_licenses,
            immutable_id=immutable_id,
            edition=edition,
            processors=processors,
            state=state,
            target=target,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assigned_licenses: Optional[int] = None,
             immutable_id: Optional[str] = None,
             edition: Optional[str] = None,
             processors: Optional[int] = None,
             state: Optional[str] = None,
             target: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if assigned_licenses is None and 'assignedLicenses' in kwargs:
            assigned_licenses = kwargs['assignedLicenses']
        if assigned_licenses is None:
            raise TypeError("Missing 'assigned_licenses' argument")
        if immutable_id is None and 'immutableId' in kwargs:
            immutable_id = kwargs['immutableId']
        if immutable_id is None:
            raise TypeError("Missing 'immutable_id' argument")

        _setter("assigned_licenses", assigned_licenses)
        _setter("immutable_id", immutable_id)
        if edition is not None:
            _setter("edition", edition)
        if processors is not None:
            _setter("processors", processors)
        if state is not None:
            _setter("state", state)
        if target is not None:
            _setter("target", target)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="assignedLicenses")
    def assigned_licenses(self) -> int:
        """
        Describes the number of assigned licenses.
        """
        return pulumi.get(self, "assigned_licenses")

    @property
    @pulumi.getter(name="immutableId")
    def immutable_id(self) -> str:
        """
        Describes the immutable id.
        """
        return pulumi.get(self, "immutable_id")

    @property
    @pulumi.getter
    def edition(self) -> Optional[str]:
        """
        Describes the edition of the license. The values are either Standard or Datacenter.
        """
        return pulumi.get(self, "edition")

    @property
    @pulumi.getter
    def processors(self) -> Optional[int]:
        """
        Describes the number of processors.
        """
        return pulumi.get(self, "processors")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        Describes the state of the license.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Describes the license target server.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Describes the license core type (pCore or vCore).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LicenseProfileMachineInstanceViewEsuPropertiesResponse(dict):
    """
    Properties for the Machine ESU profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignedLicenseImmutableId":
            suggest = "assigned_license_immutable_id"
        elif key == "esuEligibility":
            suggest = "esu_eligibility"
        elif key == "esuKeyState":
            suggest = "esu_key_state"
        elif key == "esuKeys":
            suggest = "esu_keys"
        elif key == "serverType":
            suggest = "server_type"
        elif key == "assignedLicense":
            suggest = "assigned_license"
        elif key == "licenseAssignmentState":
            suggest = "license_assignment_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LicenseProfileMachineInstanceViewEsuPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LicenseProfileMachineInstanceViewEsuPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LicenseProfileMachineInstanceViewEsuPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assigned_license_immutable_id: str,
                 esu_eligibility: str,
                 esu_key_state: str,
                 esu_keys: Sequence['outputs.EsuKeyResponse'],
                 server_type: str,
                 assigned_license: Optional['outputs.LicenseResponse'] = None,
                 license_assignment_state: Optional[str] = None):
        """
        Properties for the Machine ESU profile.
        :param str assigned_license_immutable_id: The guid id of the license.
        :param str esu_eligibility: Indicates the eligibility state of Esu.
        :param str esu_key_state: Indicates whether there is an ESU Key currently active for the machine.
        :param Sequence['EsuKeyResponse'] esu_keys: The list of ESU keys.
        :param str server_type: The type of the Esu servers.
        :param 'LicenseResponse' assigned_license: The assigned license resource.
        :param str license_assignment_state: Describes the license assignment state (Assigned or NotAssigned).
        """
        LicenseProfileMachineInstanceViewEsuPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assigned_license_immutable_id=assigned_license_immutable_id,
            esu_eligibility=esu_eligibility,
            esu_key_state=esu_key_state,
            esu_keys=esu_keys,
            server_type=server_type,
            assigned_license=assigned_license,
            license_assignment_state=license_assignment_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assigned_license_immutable_id: Optional[str] = None,
             esu_eligibility: Optional[str] = None,
             esu_key_state: Optional[str] = None,
             esu_keys: Optional[Sequence['outputs.EsuKeyResponse']] = None,
             server_type: Optional[str] = None,
             assigned_license: Optional['outputs.LicenseResponse'] = None,
             license_assignment_state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if assigned_license_immutable_id is None and 'assignedLicenseImmutableId' in kwargs:
            assigned_license_immutable_id = kwargs['assignedLicenseImmutableId']
        if assigned_license_immutable_id is None:
            raise TypeError("Missing 'assigned_license_immutable_id' argument")
        if esu_eligibility is None and 'esuEligibility' in kwargs:
            esu_eligibility = kwargs['esuEligibility']
        if esu_eligibility is None:
            raise TypeError("Missing 'esu_eligibility' argument")
        if esu_key_state is None and 'esuKeyState' in kwargs:
            esu_key_state = kwargs['esuKeyState']
        if esu_key_state is None:
            raise TypeError("Missing 'esu_key_state' argument")
        if esu_keys is None and 'esuKeys' in kwargs:
            esu_keys = kwargs['esuKeys']
        if esu_keys is None:
            raise TypeError("Missing 'esu_keys' argument")
        if server_type is None and 'serverType' in kwargs:
            server_type = kwargs['serverType']
        if server_type is None:
            raise TypeError("Missing 'server_type' argument")
        if assigned_license is None and 'assignedLicense' in kwargs:
            assigned_license = kwargs['assignedLicense']
        if license_assignment_state is None and 'licenseAssignmentState' in kwargs:
            license_assignment_state = kwargs['licenseAssignmentState']

        _setter("assigned_license_immutable_id", assigned_license_immutable_id)
        _setter("esu_eligibility", esu_eligibility)
        _setter("esu_key_state", esu_key_state)
        _setter("esu_keys", esu_keys)
        _setter("server_type", server_type)
        if assigned_license is not None:
            _setter("assigned_license", assigned_license)
        if license_assignment_state is not None:
            _setter("license_assignment_state", license_assignment_state)

    @property
    @pulumi.getter(name="assignedLicenseImmutableId")
    def assigned_license_immutable_id(self) -> str:
        """
        The guid id of the license.
        """
        return pulumi.get(self, "assigned_license_immutable_id")

    @property
    @pulumi.getter(name="esuEligibility")
    def esu_eligibility(self) -> str:
        """
        Indicates the eligibility state of Esu.
        """
        return pulumi.get(self, "esu_eligibility")

    @property
    @pulumi.getter(name="esuKeyState")
    def esu_key_state(self) -> str:
        """
        Indicates whether there is an ESU Key currently active for the machine.
        """
        return pulumi.get(self, "esu_key_state")

    @property
    @pulumi.getter(name="esuKeys")
    def esu_keys(self) -> Sequence['outputs.EsuKeyResponse']:
        """
        The list of ESU keys.
        """
        return pulumi.get(self, "esu_keys")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> str:
        """
        The type of the Esu servers.
        """
        return pulumi.get(self, "server_type")

    @property
    @pulumi.getter(name="assignedLicense")
    def assigned_license(self) -> Optional['outputs.LicenseResponse']:
        """
        The assigned license resource.
        """
        return pulumi.get(self, "assigned_license")

    @property
    @pulumi.getter(name="licenseAssignmentState")
    def license_assignment_state(self) -> Optional[str]:
        """
        Describes the license assignment state (Assigned or NotAssigned).
        """
        return pulumi.get(self, "license_assignment_state")


@pulumi.output_type
class LicenseProfileMachineInstanceViewResponse(dict):
    """
    License Profile Instance View in Machine Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "esuProfile":
            suggest = "esu_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LicenseProfileMachineInstanceViewResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LicenseProfileMachineInstanceViewResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LicenseProfileMachineInstanceViewResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 esu_profile: Optional['outputs.LicenseProfileMachineInstanceViewEsuPropertiesResponse'] = None):
        """
        License Profile Instance View in Machine Properties.
        :param 'LicenseProfileMachineInstanceViewEsuPropertiesResponse' esu_profile: Properties for the Machine ESU profile.
        """
        LicenseProfileMachineInstanceViewResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            esu_profile=esu_profile,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             esu_profile: Optional['outputs.LicenseProfileMachineInstanceViewEsuPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if esu_profile is None and 'esuProfile' in kwargs:
            esu_profile = kwargs['esuProfile']

        if esu_profile is not None:
            _setter("esu_profile", esu_profile)

    @property
    @pulumi.getter(name="esuProfile")
    def esu_profile(self) -> Optional['outputs.LicenseProfileMachineInstanceViewEsuPropertiesResponse']:
        """
        Properties for the Machine ESU profile.
        """
        return pulumi.get(self, "esu_profile")


@pulumi.output_type
class LicenseResponse(dict):
    """
    Describes a license in a hybrid machine.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "systemData":
            suggest = "system_data"
        elif key == "licenseDetails":
            suggest = "license_details"
        elif key == "licenseType":
            suggest = "license_type"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LicenseResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LicenseResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LicenseResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 location: str,
                 name: str,
                 provisioning_state: str,
                 system_data: 'outputs.SystemDataResponse',
                 type: str,
                 license_details: Optional['outputs.LicenseDetailsResponse'] = None,
                 license_type: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 tenant_id: Optional[str] = None):
        """
        Describes a license in a hybrid machine.
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str location: The geo-location where the resource lives
        :param str name: The name of the resource
        :param str provisioning_state: The provisioning state, which only appears in the response.
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'LicenseDetailsResponse' license_details: Describes the properties of a License.
        :param str license_type: The type of the license resource.
        :param Mapping[str, str] tags: Resource tags.
        :param str tenant_id: Describes the tenant id.
        """
        LicenseResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            location=location,
            name=name,
            provisioning_state=provisioning_state,
            system_data=system_data,
            type=type,
            license_details=license_details,
            license_type=license_type,
            tags=tags,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             location: Optional[str] = None,
             name: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             system_data: Optional['outputs.SystemDataResponse'] = None,
             type: Optional[str] = None,
             license_details: Optional['outputs.LicenseDetailsResponse'] = None,
             license_type: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             tenant_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if location is None:
            raise TypeError("Missing 'location' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if system_data is None and 'systemData' in kwargs:
            system_data = kwargs['systemData']
        if system_data is None:
            raise TypeError("Missing 'system_data' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if license_details is None and 'licenseDetails' in kwargs:
            license_details = kwargs['licenseDetails']
        if license_type is None and 'licenseType' in kwargs:
            license_type = kwargs['licenseType']
        if tenant_id is None and 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']

        _setter("id", id)
        _setter("location", location)
        _setter("name", name)
        _setter("provisioning_state", provisioning_state)
        _setter("system_data", system_data)
        _setter("type", type)
        if license_details is not None:
            _setter("license_details", license_details)
        if license_type is not None:
            _setter("license_type", license_type)
        if tags is not None:
            _setter("tags", tags)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state, which only appears in the response.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="licenseDetails")
    def license_details(self) -> Optional['outputs.LicenseDetailsResponse']:
        """
        Describes the properties of a License.
        """
        return pulumi.get(self, "license_details")

    @property
    @pulumi.getter(name="licenseType")
    def license_type(self) -> Optional[str]:
        """
        The type of the license resource.
        """
        return pulumi.get(self, "license_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        Describes the tenant id.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class LocationDataResponse(dict):
    """
    Metadata pertaining to the geographic location of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "countryOrRegion":
            suggest = "country_or_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocationDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocationDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocationDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 city: Optional[str] = None,
                 country_or_region: Optional[str] = None,
                 district: Optional[str] = None):
        """
        Metadata pertaining to the geographic location of the resource.
        :param str name: A canonical name for the geographic or physical location.
        :param str city: The city or locality where the resource is located.
        :param str country_or_region: The country or region where the resource is located
        :param str district: The district, state, or province where the resource is located.
        """
        LocationDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            city=city,
            country_or_region=country_or_region,
            district=district,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             city: Optional[str] = None,
             country_or_region: Optional[str] = None,
             district: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if country_or_region is None and 'countryOrRegion' in kwargs:
            country_or_region = kwargs['countryOrRegion']

        _setter("name", name)
        if city is not None:
            _setter("city", city)
        if country_or_region is not None:
            _setter("country_or_region", country_or_region)
        if district is not None:
            _setter("district", district)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A canonical name for the geographic or physical location.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        """
        The city or locality where the resource is located.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter(name="countryOrRegion")
    def country_or_region(self) -> Optional[str]:
        """
        The country or region where the resource is located
        """
        return pulumi.get(self, "country_or_region")

    @property
    @pulumi.getter
    def district(self) -> Optional[str]:
        """
        The district, state, or province where the resource is located.
        """
        return pulumi.get(self, "district")


@pulumi.output_type
class MachineExtensionInstanceViewResponse(dict):
    """
    Describes the Machine Extension Instance View.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeHandlerVersion":
            suggest = "type_handler_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineExtensionInstanceViewResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineExtensionInstanceViewResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineExtensionInstanceViewResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 status: Optional['outputs.MachineExtensionInstanceViewResponseStatus'] = None,
                 type: Optional[str] = None,
                 type_handler_version: Optional[str] = None):
        """
        Describes the Machine Extension Instance View.
        :param str name: The machine extension name.
        :param 'MachineExtensionInstanceViewResponseStatus' status: Instance view status.
        :param str type: Specifies the type of the extension; an example is "CustomScriptExtension".
        :param str type_handler_version: Specifies the version of the script handler.
        """
        MachineExtensionInstanceViewResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            status=status,
            type=type,
            type_handler_version=type_handler_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             status: Optional['outputs.MachineExtensionInstanceViewResponseStatus'] = None,
             type: Optional[str] = None,
             type_handler_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if type_handler_version is None and 'typeHandlerVersion' in kwargs:
            type_handler_version = kwargs['typeHandlerVersion']

        if name is not None:
            _setter("name", name)
        if status is not None:
            _setter("status", status)
        if type is not None:
            _setter("type", type)
        if type_handler_version is not None:
            _setter("type_handler_version", type_handler_version)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The machine extension name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.MachineExtensionInstanceViewResponseStatus']:
        """
        Instance view status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Specifies the type of the extension; an example is "CustomScriptExtension".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> Optional[str]:
        """
        Specifies the version of the script handler.
        """
        return pulumi.get(self, "type_handler_version")


@pulumi.output_type
class MachineExtensionInstanceViewResponseStatus(dict):
    """
    Instance view status.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayStatus":
            suggest = "display_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineExtensionInstanceViewResponseStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineExtensionInstanceViewResponseStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineExtensionInstanceViewResponseStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code: Optional[str] = None,
                 display_status: Optional[str] = None,
                 level: Optional[str] = None,
                 message: Optional[str] = None,
                 time: Optional[str] = None):
        """
        Instance view status.
        :param str code: The status code.
        :param str display_status: The short localizable label for the status.
        :param str level: The level code.
        :param str message: The detailed status message, including for alerts and error messages.
        :param str time: The time of the status.
        """
        MachineExtensionInstanceViewResponseStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            display_status=display_status,
            level=level,
            message=message,
            time=time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[str] = None,
             display_status: Optional[str] = None,
             level: Optional[str] = None,
             message: Optional[str] = None,
             time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if display_status is None and 'displayStatus' in kwargs:
            display_status = kwargs['displayStatus']

        if code is not None:
            _setter("code", code)
        if display_status is not None:
            _setter("display_status", display_status)
        if level is not None:
            _setter("level", level)
        if message is not None:
            _setter("message", message)
        if time is not None:
            _setter("time", time)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        The status code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="displayStatus")
    def display_status(self) -> Optional[str]:
        """
        The short localizable label for the status.
        """
        return pulumi.get(self, "display_status")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        The level code.
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The detailed status message, including for alerts and error messages.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def time(self) -> Optional[str]:
        """
        The time of the status.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class MachineExtensionPropertiesResponse(dict):
    """
    Describes the properties of a Machine Extension.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "autoUpgradeMinorVersion":
            suggest = "auto_upgrade_minor_version"
        elif key == "enableAutomaticUpgrade":
            suggest = "enable_automatic_upgrade"
        elif key == "forceUpdateTag":
            suggest = "force_update_tag"
        elif key == "instanceView":
            suggest = "instance_view"
        elif key == "protectedSettings":
            suggest = "protected_settings"
        elif key == "typeHandlerVersion":
            suggest = "type_handler_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineExtensionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineExtensionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineExtensionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: str,
                 auto_upgrade_minor_version: Optional[bool] = None,
                 enable_automatic_upgrade: Optional[bool] = None,
                 force_update_tag: Optional[str] = None,
                 instance_view: Optional['outputs.MachineExtensionInstanceViewResponse'] = None,
                 protected_settings: Optional[Any] = None,
                 publisher: Optional[str] = None,
                 settings: Optional[Any] = None,
                 type: Optional[str] = None,
                 type_handler_version: Optional[str] = None):
        """
        Describes the properties of a Machine Extension.
        :param str provisioning_state: The provisioning state, which only appears in the response.
        :param bool auto_upgrade_minor_version: Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
        :param bool enable_automatic_upgrade: Indicates whether the extension should be automatically upgraded by the platform if there is a newer version available.
        :param str force_update_tag: How the extension handler should be forced to update even if the extension configuration has not changed.
        :param 'MachineExtensionInstanceViewResponse' instance_view: The machine extension instance view.
        :param Any protected_settings: The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
        :param str publisher: The name of the extension handler publisher.
        :param Any settings: Json formatted public settings for the extension.
        :param str type: Specifies the type of the extension; an example is "CustomScriptExtension".
        :param str type_handler_version: Specifies the version of the script handler.
        """
        MachineExtensionPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provisioning_state=provisioning_state,
            auto_upgrade_minor_version=auto_upgrade_minor_version,
            enable_automatic_upgrade=enable_automatic_upgrade,
            force_update_tag=force_update_tag,
            instance_view=instance_view,
            protected_settings=protected_settings,
            publisher=publisher,
            settings=settings,
            type=type,
            type_handler_version=type_handler_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provisioning_state: Optional[str] = None,
             auto_upgrade_minor_version: Optional[bool] = None,
             enable_automatic_upgrade: Optional[bool] = None,
             force_update_tag: Optional[str] = None,
             instance_view: Optional['outputs.MachineExtensionInstanceViewResponse'] = None,
             protected_settings: Optional[Any] = None,
             publisher: Optional[str] = None,
             settings: Optional[Any] = None,
             type: Optional[str] = None,
             type_handler_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if auto_upgrade_minor_version is None and 'autoUpgradeMinorVersion' in kwargs:
            auto_upgrade_minor_version = kwargs['autoUpgradeMinorVersion']
        if enable_automatic_upgrade is None and 'enableAutomaticUpgrade' in kwargs:
            enable_automatic_upgrade = kwargs['enableAutomaticUpgrade']
        if force_update_tag is None and 'forceUpdateTag' in kwargs:
            force_update_tag = kwargs['forceUpdateTag']
        if instance_view is None and 'instanceView' in kwargs:
            instance_view = kwargs['instanceView']
        if protected_settings is None and 'protectedSettings' in kwargs:
            protected_settings = kwargs['protectedSettings']
        if type_handler_version is None and 'typeHandlerVersion' in kwargs:
            type_handler_version = kwargs['typeHandlerVersion']

        _setter("provisioning_state", provisioning_state)
        if auto_upgrade_minor_version is not None:
            _setter("auto_upgrade_minor_version", auto_upgrade_minor_version)
        if enable_automatic_upgrade is not None:
            _setter("enable_automatic_upgrade", enable_automatic_upgrade)
        if force_update_tag is not None:
            _setter("force_update_tag", force_update_tag)
        if instance_view is not None:
            _setter("instance_view", instance_view)
        if protected_settings is not None:
            _setter("protected_settings", protected_settings)
        if publisher is not None:
            _setter("publisher", publisher)
        if settings is not None:
            _setter("settings", settings)
        if type is not None:
            _setter("type", type)
        if type_handler_version is not None:
            _setter("type_handler_version", type_handler_version)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        The provisioning state, which only appears in the response.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="autoUpgradeMinorVersion")
    def auto_upgrade_minor_version(self) -> Optional[bool]:
        """
        Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
        """
        return pulumi.get(self, "auto_upgrade_minor_version")

    @property
    @pulumi.getter(name="enableAutomaticUpgrade")
    def enable_automatic_upgrade(self) -> Optional[bool]:
        """
        Indicates whether the extension should be automatically upgraded by the platform if there is a newer version available.
        """
        return pulumi.get(self, "enable_automatic_upgrade")

    @property
    @pulumi.getter(name="forceUpdateTag")
    def force_update_tag(self) -> Optional[str]:
        """
        How the extension handler should be forced to update even if the extension configuration has not changed.
        """
        return pulumi.get(self, "force_update_tag")

    @property
    @pulumi.getter(name="instanceView")
    def instance_view(self) -> Optional['outputs.MachineExtensionInstanceViewResponse']:
        """
        The machine extension instance view.
        """
        return pulumi.get(self, "instance_view")

    @property
    @pulumi.getter(name="protectedSettings")
    def protected_settings(self) -> Optional[Any]:
        """
        The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
        """
        return pulumi.get(self, "protected_settings")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[str]:
        """
        The name of the extension handler publisher.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter
    def settings(self) -> Optional[Any]:
        """
        Json formatted public settings for the extension.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Specifies the type of the extension; an example is "CustomScriptExtension".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="typeHandlerVersion")
    def type_handler_version(self) -> Optional[str]:
        """
        Specifies the version of the script handler.
        """
        return pulumi.get(self, "type_handler_version")


@pulumi.output_type
class MachineExtensionResponse(dict):
    """
    Describes a Machine Extension.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemData":
            suggest = "system_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineExtensionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineExtensionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineExtensionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 location: str,
                 name: str,
                 system_data: 'outputs.SystemDataResponse',
                 type: str,
                 properties: Optional['outputs.MachineExtensionPropertiesResponse'] = None,
                 tags: Optional[Mapping[str, str]] = None):
        """
        Describes a Machine Extension.
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str location: The geo-location where the resource lives
        :param str name: The name of the resource
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'MachineExtensionPropertiesResponse' properties: Describes Machine Extension Properties.
        :param Mapping[str, str] tags: Resource tags.
        """
        MachineExtensionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            location=location,
            name=name,
            system_data=system_data,
            type=type,
            properties=properties,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             location: Optional[str] = None,
             name: Optional[str] = None,
             system_data: Optional['outputs.SystemDataResponse'] = None,
             type: Optional[str] = None,
             properties: Optional['outputs.MachineExtensionPropertiesResponse'] = None,
             tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if location is None:
            raise TypeError("Missing 'location' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if system_data is None and 'systemData' in kwargs:
            system_data = kwargs['systemData']
        if system_data is None:
            raise TypeError("Missing 'system_data' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("id", id)
        _setter("location", location)
        _setter("name", name)
        _setter("system_data", system_data)
        _setter("type", type)
        if properties is not None:
            _setter("properties", properties)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The geo-location where the resource lives
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.MachineExtensionPropertiesResponse']:
        """
        Describes Machine Extension Properties.
        """
        return pulumi.get(self, "properties")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Resource tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class NetworkInterfaceResponse(dict):
    """
    Describes a network interface.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_addresses: Optional[Sequence['outputs.IpAddressResponse']] = None):
        """
        Describes a network interface.
        :param Sequence['IpAddressResponse'] ip_addresses: The list of IP addresses in this interface.
        """
        NetworkInterfaceResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_addresses=ip_addresses,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_addresses: Optional[Sequence['outputs.IpAddressResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if ip_addresses is None and 'ipAddresses' in kwargs:
            ip_addresses = kwargs['ipAddresses']

        if ip_addresses is not None:
            _setter("ip_addresses", ip_addresses)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence['outputs.IpAddressResponse']]:
        """
        The list of IP addresses in this interface.
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class NetworkProfileResponse(dict):
    """
    Describes the network information on this machine.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaces":
            suggest = "network_interfaces"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interfaces: Optional[Sequence['outputs.NetworkInterfaceResponse']] = None):
        """
        Describes the network information on this machine.
        :param Sequence['NetworkInterfaceResponse'] network_interfaces: The list of network interfaces.
        """
        NetworkProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_interfaces=network_interfaces,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_interfaces: Optional[Sequence['outputs.NetworkInterfaceResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if network_interfaces is None and 'networkInterfaces' in kwargs:
            network_interfaces = kwargs['networkInterfaces']

        if network_interfaces is not None:
            _setter("network_interfaces", network_interfaces)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.NetworkInterfaceResponse']]:
        """
        The list of network interfaces.
        """
        return pulumi.get(self, "network_interfaces")


@pulumi.output_type
class OSProfileResponse(dict):
    """
    Specifies the operating system settings for the hybrid machine.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computerName":
            suggest = "computer_name"
        elif key == "linuxConfiguration":
            suggest = "linux_configuration"
        elif key == "windowsConfiguration":
            suggest = "windows_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OSProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OSProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OSProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computer_name: str,
                 linux_configuration: Optional['outputs.OSProfileResponseLinuxConfiguration'] = None,
                 windows_configuration: Optional['outputs.OSProfileResponseWindowsConfiguration'] = None):
        """
        Specifies the operating system settings for the hybrid machine.
        :param str computer_name: Specifies the host OS name of the hybrid machine.
        :param 'OSProfileResponseLinuxConfiguration' linux_configuration: Specifies the linux configuration for update management.
        :param 'OSProfileResponseWindowsConfiguration' windows_configuration: Specifies the windows configuration for update management.
        """
        OSProfileResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computer_name=computer_name,
            linux_configuration=linux_configuration,
            windows_configuration=windows_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computer_name: Optional[str] = None,
             linux_configuration: Optional['outputs.OSProfileResponseLinuxConfiguration'] = None,
             windows_configuration: Optional['outputs.OSProfileResponseWindowsConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if computer_name is None and 'computerName' in kwargs:
            computer_name = kwargs['computerName']
        if computer_name is None:
            raise TypeError("Missing 'computer_name' argument")
        if linux_configuration is None and 'linuxConfiguration' in kwargs:
            linux_configuration = kwargs['linuxConfiguration']
        if windows_configuration is None and 'windowsConfiguration' in kwargs:
            windows_configuration = kwargs['windowsConfiguration']

        _setter("computer_name", computer_name)
        if linux_configuration is not None:
            _setter("linux_configuration", linux_configuration)
        if windows_configuration is not None:
            _setter("windows_configuration", windows_configuration)

    @property
    @pulumi.getter(name="computerName")
    def computer_name(self) -> str:
        """
        Specifies the host OS name of the hybrid machine.
        """
        return pulumi.get(self, "computer_name")

    @property
    @pulumi.getter(name="linuxConfiguration")
    def linux_configuration(self) -> Optional['outputs.OSProfileResponseLinuxConfiguration']:
        """
        Specifies the linux configuration for update management.
        """
        return pulumi.get(self, "linux_configuration")

    @property
    @pulumi.getter(name="windowsConfiguration")
    def windows_configuration(self) -> Optional['outputs.OSProfileResponseWindowsConfiguration']:
        """
        Specifies the windows configuration for update management.
        """
        return pulumi.get(self, "windows_configuration")


@pulumi.output_type
class OSProfileResponseLinuxConfiguration(dict):
    """
    Specifies the linux configuration for update management.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assessmentMode":
            suggest = "assessment_mode"
        elif key == "patchMode":
            suggest = "patch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OSProfileResponseLinuxConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OSProfileResponseLinuxConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OSProfileResponseLinuxConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assessment_mode: Optional[str] = None,
                 patch_mode: Optional[str] = None):
        """
        Specifies the linux configuration for update management.
        :param str assessment_mode: Specifies the assessment mode.
        :param str patch_mode: Specifies the patch mode.
        """
        OSProfileResponseLinuxConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assessment_mode=assessment_mode,
            patch_mode=patch_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assessment_mode: Optional[str] = None,
             patch_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if assessment_mode is None and 'assessmentMode' in kwargs:
            assessment_mode = kwargs['assessmentMode']
        if patch_mode is None and 'patchMode' in kwargs:
            patch_mode = kwargs['patchMode']

        if assessment_mode is not None:
            _setter("assessment_mode", assessment_mode)
        if patch_mode is not None:
            _setter("patch_mode", patch_mode)

    @property
    @pulumi.getter(name="assessmentMode")
    def assessment_mode(self) -> Optional[str]:
        """
        Specifies the assessment mode.
        """
        return pulumi.get(self, "assessment_mode")

    @property
    @pulumi.getter(name="patchMode")
    def patch_mode(self) -> Optional[str]:
        """
        Specifies the patch mode.
        """
        return pulumi.get(self, "patch_mode")


@pulumi.output_type
class OSProfileResponseWindowsConfiguration(dict):
    """
    Specifies the windows configuration for update management.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assessmentMode":
            suggest = "assessment_mode"
        elif key == "patchMode":
            suggest = "patch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OSProfileResponseWindowsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OSProfileResponseWindowsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OSProfileResponseWindowsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assessment_mode: Optional[str] = None,
                 patch_mode: Optional[str] = None):
        """
        Specifies the windows configuration for update management.
        :param str assessment_mode: Specifies the assessment mode.
        :param str patch_mode: Specifies the patch mode.
        """
        OSProfileResponseWindowsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            assessment_mode=assessment_mode,
            patch_mode=patch_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             assessment_mode: Optional[str] = None,
             patch_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if assessment_mode is None and 'assessmentMode' in kwargs:
            assessment_mode = kwargs['assessmentMode']
        if patch_mode is None and 'patchMode' in kwargs:
            patch_mode = kwargs['patchMode']

        if assessment_mode is not None:
            _setter("assessment_mode", assessment_mode)
        if patch_mode is not None:
            _setter("patch_mode", patch_mode)

    @property
    @pulumi.getter(name="assessmentMode")
    def assessment_mode(self) -> Optional[str]:
        """
        Specifies the assessment mode.
        """
        return pulumi.get(self, "assessment_mode")

    @property
    @pulumi.getter(name="patchMode")
    def patch_mode(self) -> Optional[str]:
        """
        Specifies the patch mode.
        """
        return pulumi.get(self, "patch_mode")


@pulumi.output_type
class PrivateEndpointConnectionDataModelResponse(dict):
    """
    The Data Model for a Private Endpoint Connection associated with a Private Link Scope
    """
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str,
                 properties: Optional['outputs.PrivateEndpointConnectionPropertiesResponse'] = None):
        """
        The Data Model for a Private Endpoint Connection associated with a Private Link Scope
        :param str id: The ARM Resource Id of the Private Endpoint.
        :param str name: The Name of the Private Endpoint.
        :param str type: Azure resource type
        :param 'PrivateEndpointConnectionPropertiesResponse' properties: The Private Endpoint Connection properties.
        """
        PrivateEndpointConnectionDataModelResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            type=type,
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             type: Optional[str] = None,
             properties: Optional['outputs.PrivateEndpointConnectionPropertiesResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if id is None:
            raise TypeError("Missing 'id' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("id", id)
        _setter("name", name)
        _setter("type", type)
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ARM Resource Id of the Private Endpoint.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The Name of the Private Endpoint.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Azure resource type
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.PrivateEndpointConnectionPropertiesResponse']:
        """
        The Private Endpoint Connection properties.
        """
        return pulumi.get(self, "properties")


@pulumi.output_type
class PrivateEndpointConnectionPropertiesResponse(dict):
    """
    Properties of a private endpoint connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Sequence[str],
                 provisioning_state: str,
                 private_endpoint: Optional['outputs.PrivateEndpointPropertyResponse'] = None,
                 private_link_service_connection_state: Optional['outputs.PrivateLinkServiceConnectionStatePropertyResponse'] = None):
        """
        Properties of a private endpoint connection.
        :param Sequence[str] group_ids: List of group IDs.
        :param str provisioning_state: State of the private endpoint connection.
        :param 'PrivateEndpointPropertyResponse' private_endpoint: Private endpoint which the connection belongs to.
        :param 'PrivateLinkServiceConnectionStatePropertyResponse' private_link_service_connection_state: Connection state of the private endpoint connection.
        """
        PrivateEndpointConnectionPropertiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_ids=group_ids,
            provisioning_state=provisioning_state,
            private_endpoint=private_endpoint,
            private_link_service_connection_state=private_link_service_connection_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_ids: Optional[Sequence[str]] = None,
             provisioning_state: Optional[str] = None,
             private_endpoint: Optional['outputs.PrivateEndpointPropertyResponse'] = None,
             private_link_service_connection_state: Optional['outputs.PrivateLinkServiceConnectionStatePropertyResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if group_ids is None and 'groupIds' in kwargs:
            group_ids = kwargs['groupIds']
        if group_ids is None:
            raise TypeError("Missing 'group_ids' argument")
        if provisioning_state is None and 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if provisioning_state is None:
            raise TypeError("Missing 'provisioning_state' argument")
        if private_endpoint is None and 'privateEndpoint' in kwargs:
            private_endpoint = kwargs['privateEndpoint']
        if private_link_service_connection_state is None and 'privateLinkServiceConnectionState' in kwargs:
            private_link_service_connection_state = kwargs['privateLinkServiceConnectionState']

        _setter("group_ids", group_ids)
        _setter("provisioning_state", provisioning_state)
        if private_endpoint is not None:
            _setter("private_endpoint", private_endpoint)
        if private_link_service_connection_state is not None:
            _setter("private_link_service_connection_state", private_link_service_connection_state)

    @property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Sequence[str]:
        """
        List of group IDs.
        """
        return pulumi.get(self, "group_ids")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        State of the private endpoint connection.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointPropertyResponse']:
        """
        Private endpoint which the connection belongs to.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> Optional['outputs.PrivateLinkServiceConnectionStatePropertyResponse']:
        """
        Connection state of the private endpoint connection.
        """
        return pulumi.get(self, "private_link_service_connection_state")


@pulumi.output_type
class PrivateEndpointPropertyResponse(dict):
    """
    Private endpoint which the connection belongs to.
    """
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        Private endpoint which the connection belongs to.
        :param str id: Resource id of the private endpoint.
        """
        PrivateEndpointPropertyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Resource id of the private endpoint.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkServiceConnectionStatePropertyResponse(dict):
    """
    State of the private endpoint connection.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStatePropertyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStatePropertyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStatePropertyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: str,
                 description: str,
                 status: str):
        """
        State of the private endpoint connection.
        :param str actions_required: The actions required for private link service connection.
        :param str description: The private link service connection description.
        :param str status: The private link service connection status.
        """
        PrivateLinkServiceConnectionStatePropertyResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions_required=actions_required,
            description=description,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions_required: Optional[str] = None,
             description: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if actions_required is None and 'actionsRequired' in kwargs:
            actions_required = kwargs['actionsRequired']
        if actions_required is None:
            raise TypeError("Missing 'actions_required' argument")
        if description is None:
            raise TypeError("Missing 'description' argument")
        if status is None:
            raise TypeError("Missing 'status' argument")

        _setter("actions_required", actions_required)
        _setter("description", description)
        _setter("status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> str:
        """
        The actions required for private link service connection.
        """
        return pulumi.get(self, "actions_required")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The private link service connection description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The private link service connection status.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ServiceStatusResponse(dict):
    """
    Describes the status and behavior of a service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startupType":
            suggest = "startup_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceStatusResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceStatusResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceStatusResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 startup_type: Optional[str] = None,
                 status: Optional[str] = None):
        """
        Describes the status and behavior of a service.
        :param str startup_type: The behavior of the service when the Arc-enabled machine starts up.
        :param str status: The current status of the service.
        """
        ServiceStatusResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            startup_type=startup_type,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             startup_type: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if startup_type is None and 'startupType' in kwargs:
            startup_type = kwargs['startupType']

        if startup_type is not None:
            _setter("startup_type", startup_type)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="startupType")
    def startup_type(self) -> Optional[str]:
        """
        The behavior of the service when the Arc-enabled machine starts up.
        """
        return pulumi.get(self, "startup_type")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The current status of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ServiceStatusesResponse(dict):
    """
    Reports the state and behavior of dependent services.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extensionService":
            suggest = "extension_service"
        elif key == "guestConfigurationService":
            suggest = "guest_configuration_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceStatusesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceStatusesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceStatusesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extension_service: Optional['outputs.ServiceStatusResponse'] = None,
                 guest_configuration_service: Optional['outputs.ServiceStatusResponse'] = None):
        """
        Reports the state and behavior of dependent services.
        :param 'ServiceStatusResponse' extension_service: The state of the extension service on the Arc-enabled machine.
        :param 'ServiceStatusResponse' guest_configuration_service: The state of the guest configuration service on the Arc-enabled machine.
        """
        ServiceStatusesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            extension_service=extension_service,
            guest_configuration_service=guest_configuration_service,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             extension_service: Optional['outputs.ServiceStatusResponse'] = None,
             guest_configuration_service: Optional['outputs.ServiceStatusResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if extension_service is None and 'extensionService' in kwargs:
            extension_service = kwargs['extensionService']
        if guest_configuration_service is None and 'guestConfigurationService' in kwargs:
            guest_configuration_service = kwargs['guestConfigurationService']

        if extension_service is not None:
            _setter("extension_service", extension_service)
        if guest_configuration_service is not None:
            _setter("guest_configuration_service", guest_configuration_service)

    @property
    @pulumi.getter(name="extensionService")
    def extension_service(self) -> Optional['outputs.ServiceStatusResponse']:
        """
        The state of the extension service on the Arc-enabled machine.
        """
        return pulumi.get(self, "extension_service")

    @property
    @pulumi.getter(name="guestConfigurationService")
    def guest_configuration_service(self) -> Optional['outputs.ServiceStatusResponse']:
        """
        The state of the guest configuration service on the Arc-enabled machine.
        """
        return pulumi.get(self, "guest_configuration_service")


@pulumi.output_type
class SubnetResponse(dict):
    """
    Describes the subnet.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPrefix":
            suggest = "address_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubnetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubnetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubnetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_prefix: Optional[str] = None):
        """
        Describes the subnet.
        :param str address_prefix: Represents address prefix.
        """
        SubnetResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_prefix=address_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if address_prefix is None and 'addressPrefix' in kwargs:
            address_prefix = kwargs['addressPrefix']

        if address_prefix is not None:
            _setter("address_prefix", address_prefix)

    @property
    @pulumi.getter(name="addressPrefix")
    def address_prefix(self) -> Optional[str]:
        """
        Represents address prefix.
        """
        return pulumi.get(self, "address_prefix")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


