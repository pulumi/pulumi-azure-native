# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'InputLinuxParametersArgs',
    'InputPatchConfigurationArgs',
    'InputWindowsParametersArgs',
    'MaintenanceOverridePropertiesArgs',
    'TaskPropertiesArgs',
]

@pulumi.input_type
class InputLinuxParametersArgs:
    def __init__(__self__, *,
                 classifications_to_include: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 package_name_masks_to_exclude: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 package_name_masks_to_include: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Input properties for patching a Linux machine.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] classifications_to_include: Classification category of patches to be patched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] package_name_masks_to_exclude: Package names to be excluded for patching.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] package_name_masks_to_include: Package names to be included for patching.
        """
        InputLinuxParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            classifications_to_include=classifications_to_include,
            package_name_masks_to_exclude=package_name_masks_to_exclude,
            package_name_masks_to_include=package_name_masks_to_include,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             classifications_to_include: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             package_name_masks_to_exclude: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             package_name_masks_to_include: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if classifications_to_include is None and 'classificationsToInclude' in kwargs:
            classifications_to_include = kwargs['classificationsToInclude']
        if package_name_masks_to_exclude is None and 'packageNameMasksToExclude' in kwargs:
            package_name_masks_to_exclude = kwargs['packageNameMasksToExclude']
        if package_name_masks_to_include is None and 'packageNameMasksToInclude' in kwargs:
            package_name_masks_to_include = kwargs['packageNameMasksToInclude']

        if classifications_to_include is not None:
            _setter("classifications_to_include", classifications_to_include)
        if package_name_masks_to_exclude is not None:
            _setter("package_name_masks_to_exclude", package_name_masks_to_exclude)
        if package_name_masks_to_include is not None:
            _setter("package_name_masks_to_include", package_name_masks_to_include)

    @property
    @pulumi.getter(name="classificationsToInclude")
    def classifications_to_include(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Classification category of patches to be patched
        """
        return pulumi.get(self, "classifications_to_include")

    @classifications_to_include.setter
    def classifications_to_include(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "classifications_to_include", value)

    @property
    @pulumi.getter(name="packageNameMasksToExclude")
    def package_name_masks_to_exclude(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Package names to be excluded for patching.
        """
        return pulumi.get(self, "package_name_masks_to_exclude")

    @package_name_masks_to_exclude.setter
    def package_name_masks_to_exclude(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "package_name_masks_to_exclude", value)

    @property
    @pulumi.getter(name="packageNameMasksToInclude")
    def package_name_masks_to_include(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Package names to be included for patching.
        """
        return pulumi.get(self, "package_name_masks_to_include")

    @package_name_masks_to_include.setter
    def package_name_masks_to_include(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "package_name_masks_to_include", value)


@pulumi.input_type
class InputPatchConfigurationArgs:
    def __init__(__self__, *,
                 linux_parameters: Optional[pulumi.Input['InputLinuxParametersArgs']] = None,
                 post_tasks: Optional[pulumi.Input[Sequence[pulumi.Input['TaskPropertiesArgs']]]] = None,
                 pre_tasks: Optional[pulumi.Input[Sequence[pulumi.Input['TaskPropertiesArgs']]]] = None,
                 reboot_setting: Optional[pulumi.Input[Union[str, 'RebootOptions']]] = None,
                 windows_parameters: Optional[pulumi.Input['InputWindowsParametersArgs']] = None):
        """
        Input configuration for a patch run
        :param pulumi.Input['InputLinuxParametersArgs'] linux_parameters: Input parameters specific to patching Linux machine. For Windows machines, do not pass this property.
        :param pulumi.Input[Sequence[pulumi.Input['TaskPropertiesArgs']]] post_tasks: List of post tasks. e.g. [{'source' :'runbook', 'taskScope': 'Resource', 'parameters': { 'arg1': 'value1'}}]
        :param pulumi.Input[Sequence[pulumi.Input['TaskPropertiesArgs']]] pre_tasks: List of pre tasks. e.g. [{'source' :'runbook', 'taskScope': 'Global', 'parameters': { 'arg1': 'value1'}}]
        :param pulumi.Input[Union[str, 'RebootOptions']] reboot_setting: Possible reboot preference as defined by the user based on which it would be decided to reboot the machine or not after the patch operation is completed.
        :param pulumi.Input['InputWindowsParametersArgs'] windows_parameters: Input parameters specific to patching a Windows machine. For Linux machines, do not pass this property.
        """
        InputPatchConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            linux_parameters=linux_parameters,
            post_tasks=post_tasks,
            pre_tasks=pre_tasks,
            reboot_setting=reboot_setting,
            windows_parameters=windows_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             linux_parameters: Optional[pulumi.Input['InputLinuxParametersArgs']] = None,
             post_tasks: Optional[pulumi.Input[Sequence[pulumi.Input['TaskPropertiesArgs']]]] = None,
             pre_tasks: Optional[pulumi.Input[Sequence[pulumi.Input['TaskPropertiesArgs']]]] = None,
             reboot_setting: Optional[pulumi.Input[Union[str, 'RebootOptions']]] = None,
             windows_parameters: Optional[pulumi.Input['InputWindowsParametersArgs']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if linux_parameters is None and 'linuxParameters' in kwargs:
            linux_parameters = kwargs['linuxParameters']
        if post_tasks is None and 'postTasks' in kwargs:
            post_tasks = kwargs['postTasks']
        if pre_tasks is None and 'preTasks' in kwargs:
            pre_tasks = kwargs['preTasks']
        if reboot_setting is None and 'rebootSetting' in kwargs:
            reboot_setting = kwargs['rebootSetting']
        if windows_parameters is None and 'windowsParameters' in kwargs:
            windows_parameters = kwargs['windowsParameters']

        if linux_parameters is not None:
            _setter("linux_parameters", linux_parameters)
        if post_tasks is not None:
            _setter("post_tasks", post_tasks)
        if pre_tasks is not None:
            _setter("pre_tasks", pre_tasks)
        if reboot_setting is None:
            reboot_setting = 'IfRequired'
        if reboot_setting is not None:
            _setter("reboot_setting", reboot_setting)
        if windows_parameters is not None:
            _setter("windows_parameters", windows_parameters)

    @property
    @pulumi.getter(name="linuxParameters")
    def linux_parameters(self) -> Optional[pulumi.Input['InputLinuxParametersArgs']]:
        """
        Input parameters specific to patching Linux machine. For Windows machines, do not pass this property.
        """
        return pulumi.get(self, "linux_parameters")

    @linux_parameters.setter
    def linux_parameters(self, value: Optional[pulumi.Input['InputLinuxParametersArgs']]):
        pulumi.set(self, "linux_parameters", value)

    @property
    @pulumi.getter(name="postTasks")
    def post_tasks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskPropertiesArgs']]]]:
        """
        List of post tasks. e.g. [{'source' :'runbook', 'taskScope': 'Resource', 'parameters': { 'arg1': 'value1'}}]
        """
        return pulumi.get(self, "post_tasks")

    @post_tasks.setter
    def post_tasks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskPropertiesArgs']]]]):
        pulumi.set(self, "post_tasks", value)

    @property
    @pulumi.getter(name="preTasks")
    def pre_tasks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaskPropertiesArgs']]]]:
        """
        List of pre tasks. e.g. [{'source' :'runbook', 'taskScope': 'Global', 'parameters': { 'arg1': 'value1'}}]
        """
        return pulumi.get(self, "pre_tasks")

    @pre_tasks.setter
    def pre_tasks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaskPropertiesArgs']]]]):
        pulumi.set(self, "pre_tasks", value)

    @property
    @pulumi.getter(name="rebootSetting")
    def reboot_setting(self) -> Optional[pulumi.Input[Union[str, 'RebootOptions']]]:
        """
        Possible reboot preference as defined by the user based on which it would be decided to reboot the machine or not after the patch operation is completed.
        """
        return pulumi.get(self, "reboot_setting")

    @reboot_setting.setter
    def reboot_setting(self, value: Optional[pulumi.Input[Union[str, 'RebootOptions']]]):
        pulumi.set(self, "reboot_setting", value)

    @property
    @pulumi.getter(name="windowsParameters")
    def windows_parameters(self) -> Optional[pulumi.Input['InputWindowsParametersArgs']]:
        """
        Input parameters specific to patching a Windows machine. For Linux machines, do not pass this property.
        """
        return pulumi.get(self, "windows_parameters")

    @windows_parameters.setter
    def windows_parameters(self, value: Optional[pulumi.Input['InputWindowsParametersArgs']]):
        pulumi.set(self, "windows_parameters", value)


@pulumi.input_type
class InputWindowsParametersArgs:
    def __init__(__self__, *,
                 classifications_to_include: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exclude_kbs_requiring_reboot: Optional[pulumi.Input[bool]] = None,
                 kb_numbers_to_exclude: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kb_numbers_to_include: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Input properties for patching a Windows machine.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] classifications_to_include: Classification category of patches to be patched
        :param pulumi.Input[bool] exclude_kbs_requiring_reboot: Exclude patches which need reboot
        :param pulumi.Input[Sequence[pulumi.Input[str]]] kb_numbers_to_exclude: Windows KBID to be excluded for patching.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] kb_numbers_to_include: Windows KBID to be included for patching.
        """
        InputWindowsParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            classifications_to_include=classifications_to_include,
            exclude_kbs_requiring_reboot=exclude_kbs_requiring_reboot,
            kb_numbers_to_exclude=kb_numbers_to_exclude,
            kb_numbers_to_include=kb_numbers_to_include,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             classifications_to_include: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             exclude_kbs_requiring_reboot: Optional[pulumi.Input[bool]] = None,
             kb_numbers_to_exclude: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             kb_numbers_to_include: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if classifications_to_include is None and 'classificationsToInclude' in kwargs:
            classifications_to_include = kwargs['classificationsToInclude']
        if exclude_kbs_requiring_reboot is None and 'excludeKbsRequiringReboot' in kwargs:
            exclude_kbs_requiring_reboot = kwargs['excludeKbsRequiringReboot']
        if kb_numbers_to_exclude is None and 'kbNumbersToExclude' in kwargs:
            kb_numbers_to_exclude = kwargs['kbNumbersToExclude']
        if kb_numbers_to_include is None and 'kbNumbersToInclude' in kwargs:
            kb_numbers_to_include = kwargs['kbNumbersToInclude']

        if classifications_to_include is not None:
            _setter("classifications_to_include", classifications_to_include)
        if exclude_kbs_requiring_reboot is not None:
            _setter("exclude_kbs_requiring_reboot", exclude_kbs_requiring_reboot)
        if kb_numbers_to_exclude is not None:
            _setter("kb_numbers_to_exclude", kb_numbers_to_exclude)
        if kb_numbers_to_include is not None:
            _setter("kb_numbers_to_include", kb_numbers_to_include)

    @property
    @pulumi.getter(name="classificationsToInclude")
    def classifications_to_include(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Classification category of patches to be patched
        """
        return pulumi.get(self, "classifications_to_include")

    @classifications_to_include.setter
    def classifications_to_include(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "classifications_to_include", value)

    @property
    @pulumi.getter(name="excludeKbsRequiringReboot")
    def exclude_kbs_requiring_reboot(self) -> Optional[pulumi.Input[bool]]:
        """
        Exclude patches which need reboot
        """
        return pulumi.get(self, "exclude_kbs_requiring_reboot")

    @exclude_kbs_requiring_reboot.setter
    def exclude_kbs_requiring_reboot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_kbs_requiring_reboot", value)

    @property
    @pulumi.getter(name="kbNumbersToExclude")
    def kb_numbers_to_exclude(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Windows KBID to be excluded for patching.
        """
        return pulumi.get(self, "kb_numbers_to_exclude")

    @kb_numbers_to_exclude.setter
    def kb_numbers_to_exclude(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "kb_numbers_to_exclude", value)

    @property
    @pulumi.getter(name="kbNumbersToInclude")
    def kb_numbers_to_include(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Windows KBID to be included for patching.
        """
        return pulumi.get(self, "kb_numbers_to_include")

    @kb_numbers_to_include.setter
    def kb_numbers_to_include(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "kb_numbers_to_include", value)


@pulumi.input_type
class MaintenanceOverridePropertiesArgs:
    def __init__(__self__, *,
                 end_date_time: Optional[pulumi.Input[str]] = None,
                 override_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 start_date_time: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        Definition of a MaintenanceOverrideProperties
        :param pulumi.Input[str] end_date_time: Effective end date of the maintenance override window in YYYY-MM-DD hh:mm format. The window will be created in the time zone provided and adjusted to daylight savings according to that time zone. Expiration date must be set to a future date. If not provided, it will be set to the maximum datetime 9999-12-31 23:59:59.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] override_properties: Gets or sets overrideProperties of the maintenanceConfiguration
        :param pulumi.Input[str] start_date_time: Effective start date of the maintenance override window in YYYY-MM-DD hh:mm format. The start date can be set to either the current date or future date. The window will be created in the time zone provided and adjusted to daylight savings according to that time zone.
        :param pulumi.Input[str] time_zone: Name of the timezone. List of timezones can be obtained by executing [System.TimeZoneInfo]::GetSystemTimeZones() in PowerShell. Example: Pacific Standard Time, UTC, W. Europe Standard Time, Korea Standard Time, Cen. Australia Standard Time.
        """
        MaintenanceOverridePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_date_time=end_date_time,
            override_properties=override_properties,
            start_date_time=start_date_time,
            time_zone=time_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_date_time: Optional[pulumi.Input[str]] = None,
             override_properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             start_date_time: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end_date_time is None and 'endDateTime' in kwargs:
            end_date_time = kwargs['endDateTime']
        if override_properties is None and 'overrideProperties' in kwargs:
            override_properties = kwargs['overrideProperties']
        if start_date_time is None and 'startDateTime' in kwargs:
            start_date_time = kwargs['startDateTime']
        if time_zone is None and 'timeZone' in kwargs:
            time_zone = kwargs['timeZone']

        if end_date_time is not None:
            _setter("end_date_time", end_date_time)
        if override_properties is not None:
            _setter("override_properties", override_properties)
        if start_date_time is not None:
            _setter("start_date_time", start_date_time)
        if time_zone is not None:
            _setter("time_zone", time_zone)

    @property
    @pulumi.getter(name="endDateTime")
    def end_date_time(self) -> Optional[pulumi.Input[str]]:
        """
        Effective end date of the maintenance override window in YYYY-MM-DD hh:mm format. The window will be created in the time zone provided and adjusted to daylight savings according to that time zone. Expiration date must be set to a future date. If not provided, it will be set to the maximum datetime 9999-12-31 23:59:59.
        """
        return pulumi.get(self, "end_date_time")

    @end_date_time.setter
    def end_date_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date_time", value)

    @property
    @pulumi.getter(name="overrideProperties")
    def override_properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Gets or sets overrideProperties of the maintenanceConfiguration
        """
        return pulumi.get(self, "override_properties")

    @override_properties.setter
    def override_properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "override_properties", value)

    @property
    @pulumi.getter(name="startDateTime")
    def start_date_time(self) -> Optional[pulumi.Input[str]]:
        """
        Effective start date of the maintenance override window in YYYY-MM-DD hh:mm format. The start date can be set to either the current date or future date. The window will be created in the time zone provided and adjusted to daylight savings according to that time zone.
        """
        return pulumi.get(self, "start_date_time")

    @start_date_time.setter
    def start_date_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the timezone. List of timezones can be obtained by executing [System.TimeZoneInfo]::GetSystemTimeZones() in PowerShell. Example: Pacific Standard Time, UTC, W. Europe Standard Time, Korea Standard Time, Cen. Australia Standard Time.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class TaskPropertiesArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 task_scope: Optional[pulumi.Input[Union[str, 'TaskScope']]] = None):
        """
        Task properties of the software update configuration.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: Gets or sets the parameters of the task.
        :param pulumi.Input[str] source: Gets or sets the name of the runbook.
        :param pulumi.Input[Union[str, 'TaskScope']] task_scope: Global Task execute once when schedule trigger. Resource task execute for each VM.
        """
        TaskPropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            parameters=parameters,
            source=source,
            task_scope=task_scope,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             source: Optional[pulumi.Input[str]] = None,
             task_scope: Optional[pulumi.Input[Union[str, 'TaskScope']]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if task_scope is None and 'taskScope' in kwargs:
            task_scope = kwargs['taskScope']

        if parameters is not None:
            _setter("parameters", parameters)
        if source is not None:
            _setter("source", source)
        if task_scope is None:
            task_scope = 'Global'
        if task_scope is not None:
            _setter("task_scope", task_scope)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Gets or sets the parameters of the task.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Gets or sets the name of the runbook.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="taskScope")
    def task_scope(self) -> Optional[pulumi.Input[Union[str, 'TaskScope']]]:
        """
        Global Task execute once when schedule trigger. Resource task execute for each VM.
        """
        return pulumi.get(self, "task_scope")

    @task_scope.setter
    def task_scope(self, value: Optional[pulumi.Input[Union[str, 'TaskScope']]]):
        pulumi.set(self, "task_scope", value)


