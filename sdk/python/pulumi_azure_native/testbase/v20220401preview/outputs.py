# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'BillingHubExecutionUsageDetailResponse',
    'BillingHubFreeHourIncrementEntryResponse',
    'BillingHubGetUsageRequestResponse',
    'BillingHubPackageUsageResponse',
    'BillingHubUsageGroupResponse',
    'BillingHubUsageGroupedByUpdateTypeResponse',
    'CommandResponse',
    'DistributionGroupListReceiverValueResponse',
    'NotificationEventReceiverResponse',
    'NotificationReceiverValueResponse',
    'PackageValidationResultResponse',
    'SubscriptionReceiverValueResponse',
    'SystemDataResponse',
    'TargetOSInfoResponse',
    'TestBaseAccountSKUCapabilityResponse',
    'TestBaseAccountSKUResponse',
    'TestResponse',
    'UserObjectReceiverValueResponse',
]

@pulumi.output_type
class BillingHubExecutionUsageDetailResponse(dict):
    def __init__(__self__, *,
                 application_name: Optional[str] = None,
                 application_version: Optional[str] = None,
                 billed_charges: Optional[float] = None,
                 end_time_stamp: Optional[str] = None,
                 execution_request_id: Optional[str] = None,
                 meter_id: Optional[str] = None,
                 os_build: Optional[str] = None,
                 release: Optional[str] = None,
                 sku: Optional[str] = None,
                 start_time_stamp: Optional[str] = None,
                 test_type: Optional[str] = None,
                 update_type: Optional[str] = None,
                 used_billable_hours: Optional[float] = None,
                 used_free_hours: Optional[float] = None):
        BillingHubExecutionUsageDetailResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_name=application_name,
            application_version=application_version,
            billed_charges=billed_charges,
            end_time_stamp=end_time_stamp,
            execution_request_id=execution_request_id,
            meter_id=meter_id,
            os_build=os_build,
            release=release,
            sku=sku,
            start_time_stamp=start_time_stamp,
            test_type=test_type,
            update_type=update_type,
            used_billable_hours=used_billable_hours,
            used_free_hours=used_free_hours,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_name: Optional[str] = None,
             application_version: Optional[str] = None,
             billed_charges: Optional[float] = None,
             end_time_stamp: Optional[str] = None,
             execution_request_id: Optional[str] = None,
             meter_id: Optional[str] = None,
             os_build: Optional[str] = None,
             release: Optional[str] = None,
             sku: Optional[str] = None,
             start_time_stamp: Optional[str] = None,
             test_type: Optional[str] = None,
             update_type: Optional[str] = None,
             used_billable_hours: Optional[float] = None,
             used_free_hours: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if application_name is None and 'applicationName' in kwargs:
            application_name = kwargs['applicationName']
        if application_version is None and 'applicationVersion' in kwargs:
            application_version = kwargs['applicationVersion']
        if billed_charges is None and 'billedCharges' in kwargs:
            billed_charges = kwargs['billedCharges']
        if end_time_stamp is None and 'endTimeStamp' in kwargs:
            end_time_stamp = kwargs['endTimeStamp']
        if execution_request_id is None and 'executionRequestId' in kwargs:
            execution_request_id = kwargs['executionRequestId']
        if meter_id is None and 'meterId' in kwargs:
            meter_id = kwargs['meterId']
        if os_build is None and 'osBuild' in kwargs:
            os_build = kwargs['osBuild']
        if start_time_stamp is None and 'startTimeStamp' in kwargs:
            start_time_stamp = kwargs['startTimeStamp']
        if test_type is None and 'testType' in kwargs:
            test_type = kwargs['testType']
        if update_type is None and 'updateType' in kwargs:
            update_type = kwargs['updateType']
        if used_billable_hours is None and 'usedBillableHours' in kwargs:
            used_billable_hours = kwargs['usedBillableHours']
        if used_free_hours is None and 'usedFreeHours' in kwargs:
            used_free_hours = kwargs['usedFreeHours']

        if application_name is not None:
            _setter("application_name", application_name)
        if application_version is not None:
            _setter("application_version", application_version)
        if billed_charges is not None:
            _setter("billed_charges", billed_charges)
        if end_time_stamp is not None:
            _setter("end_time_stamp", end_time_stamp)
        if execution_request_id is not None:
            _setter("execution_request_id", execution_request_id)
        if meter_id is not None:
            _setter("meter_id", meter_id)
        if os_build is not None:
            _setter("os_build", os_build)
        if release is not None:
            _setter("release", release)
        if sku is not None:
            _setter("sku", sku)
        if start_time_stamp is not None:
            _setter("start_time_stamp", start_time_stamp)
        if test_type is not None:
            _setter("test_type", test_type)
        if update_type is not None:
            _setter("update_type", update_type)
        if used_billable_hours is not None:
            _setter("used_billable_hours", used_billable_hours)
        if used_free_hours is not None:
            _setter("used_free_hours", used_free_hours)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> Optional[str]:
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="applicationVersion")
    def application_version(self) -> Optional[str]:
        return pulumi.get(self, "application_version")

    @property
    @pulumi.getter(name="billedCharges")
    def billed_charges(self) -> Optional[float]:
        return pulumi.get(self, "billed_charges")

    @property
    @pulumi.getter(name="endTimeStamp")
    def end_time_stamp(self) -> Optional[str]:
        return pulumi.get(self, "end_time_stamp")

    @property
    @pulumi.getter(name="executionRequestId")
    def execution_request_id(self) -> Optional[str]:
        return pulumi.get(self, "execution_request_id")

    @property
    @pulumi.getter(name="meterId")
    def meter_id(self) -> Optional[str]:
        return pulumi.get(self, "meter_id")

    @property
    @pulumi.getter(name="osBuild")
    def os_build(self) -> Optional[str]:
        return pulumi.get(self, "os_build")

    @property
    @pulumi.getter
    def release(self) -> Optional[str]:
        return pulumi.get(self, "release")

    @property
    @pulumi.getter
    def sku(self) -> Optional[str]:
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter(name="startTimeStamp")
    def start_time_stamp(self) -> Optional[str]:
        return pulumi.get(self, "start_time_stamp")

    @property
    @pulumi.getter(name="testType")
    def test_type(self) -> Optional[str]:
        return pulumi.get(self, "test_type")

    @property
    @pulumi.getter(name="updateType")
    def update_type(self) -> Optional[str]:
        return pulumi.get(self, "update_type")

    @property
    @pulumi.getter(name="usedBillableHours")
    def used_billable_hours(self) -> Optional[float]:
        return pulumi.get(self, "used_billable_hours")

    @property
    @pulumi.getter(name="usedFreeHours")
    def used_free_hours(self) -> Optional[float]:
        return pulumi.get(self, "used_free_hours")


@pulumi.output_type
class BillingHubFreeHourIncrementEntryResponse(dict):
    def __init__(__self__, *,
                 create_time_stamp: Optional[str] = None,
                 expiration_time_stamp: Optional[str] = None,
                 incremental_free_hours: Optional[float] = None,
                 remaining_free_hours: Optional[float] = None):
        BillingHubFreeHourIncrementEntryResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_time_stamp=create_time_stamp,
            expiration_time_stamp=expiration_time_stamp,
            incremental_free_hours=incremental_free_hours,
            remaining_free_hours=remaining_free_hours,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_time_stamp: Optional[str] = None,
             expiration_time_stamp: Optional[str] = None,
             incremental_free_hours: Optional[float] = None,
             remaining_free_hours: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if create_time_stamp is None and 'createTimeStamp' in kwargs:
            create_time_stamp = kwargs['createTimeStamp']
        if expiration_time_stamp is None and 'expirationTimeStamp' in kwargs:
            expiration_time_stamp = kwargs['expirationTimeStamp']
        if incremental_free_hours is None and 'incrementalFreeHours' in kwargs:
            incremental_free_hours = kwargs['incrementalFreeHours']
        if remaining_free_hours is None and 'remainingFreeHours' in kwargs:
            remaining_free_hours = kwargs['remainingFreeHours']

        if create_time_stamp is not None:
            _setter("create_time_stamp", create_time_stamp)
        if expiration_time_stamp is not None:
            _setter("expiration_time_stamp", expiration_time_stamp)
        if incremental_free_hours is not None:
            _setter("incremental_free_hours", incremental_free_hours)
        if remaining_free_hours is not None:
            _setter("remaining_free_hours", remaining_free_hours)

    @property
    @pulumi.getter(name="createTimeStamp")
    def create_time_stamp(self) -> Optional[str]:
        return pulumi.get(self, "create_time_stamp")

    @property
    @pulumi.getter(name="expirationTimeStamp")
    def expiration_time_stamp(self) -> Optional[str]:
        return pulumi.get(self, "expiration_time_stamp")

    @property
    @pulumi.getter(name="incrementalFreeHours")
    def incremental_free_hours(self) -> Optional[float]:
        return pulumi.get(self, "incremental_free_hours")

    @property
    @pulumi.getter(name="remainingFreeHours")
    def remaining_free_hours(self) -> Optional[float]:
        return pulumi.get(self, "remaining_free_hours")


@pulumi.output_type
class BillingHubGetUsageRequestResponse(dict):
    def __init__(__self__, *,
                 end_time_stamp: str,
                 start_time_stamp: str,
                 page_index: Optional[int] = None,
                 page_size: Optional[int] = None):
        BillingHubGetUsageRequestResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_time_stamp=end_time_stamp,
            start_time_stamp=start_time_stamp,
            page_index=page_index,
            page_size=page_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_time_stamp: Optional[str] = None,
             start_time_stamp: Optional[str] = None,
             page_index: Optional[int] = None,
             page_size: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if end_time_stamp is None and 'endTimeStamp' in kwargs:
            end_time_stamp = kwargs['endTimeStamp']
        if end_time_stamp is None:
            raise TypeError("Missing 'end_time_stamp' argument")
        if start_time_stamp is None and 'startTimeStamp' in kwargs:
            start_time_stamp = kwargs['startTimeStamp']
        if start_time_stamp is None:
            raise TypeError("Missing 'start_time_stamp' argument")
        if page_index is None and 'pageIndex' in kwargs:
            page_index = kwargs['pageIndex']
        if page_size is None and 'pageSize' in kwargs:
            page_size = kwargs['pageSize']

        _setter("end_time_stamp", end_time_stamp)
        _setter("start_time_stamp", start_time_stamp)
        if page_index is not None:
            _setter("page_index", page_index)
        if page_size is not None:
            _setter("page_size", page_size)

    @property
    @pulumi.getter(name="endTimeStamp")
    def end_time_stamp(self) -> str:
        return pulumi.get(self, "end_time_stamp")

    @property
    @pulumi.getter(name="startTimeStamp")
    def start_time_stamp(self) -> str:
        return pulumi.get(self, "start_time_stamp")

    @property
    @pulumi.getter(name="pageIndex")
    def page_index(self) -> Optional[int]:
        return pulumi.get(self, "page_index")

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[int]:
        return pulumi.get(self, "page_size")


@pulumi.output_type
class BillingHubPackageUsageResponse(dict):
    def __init__(__self__, *,
                 application_name: Optional[str] = None,
                 application_version: Optional[str] = None,
                 azure_resource_uri: Optional[str] = None,
                 total_charges: Optional[float] = None,
                 total_used_billable_hours: Optional[float] = None,
                 total_used_free_hours: Optional[float] = None,
                 usage_entries_grouped_by_update_type: Optional[Sequence['outputs.BillingHubUsageGroupedByUpdateTypeResponse']] = None):
        BillingHubPackageUsageResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_name=application_name,
            application_version=application_version,
            azure_resource_uri=azure_resource_uri,
            total_charges=total_charges,
            total_used_billable_hours=total_used_billable_hours,
            total_used_free_hours=total_used_free_hours,
            usage_entries_grouped_by_update_type=usage_entries_grouped_by_update_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_name: Optional[str] = None,
             application_version: Optional[str] = None,
             azure_resource_uri: Optional[str] = None,
             total_charges: Optional[float] = None,
             total_used_billable_hours: Optional[float] = None,
             total_used_free_hours: Optional[float] = None,
             usage_entries_grouped_by_update_type: Optional[Sequence['outputs.BillingHubUsageGroupedByUpdateTypeResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if application_name is None and 'applicationName' in kwargs:
            application_name = kwargs['applicationName']
        if application_version is None and 'applicationVersion' in kwargs:
            application_version = kwargs['applicationVersion']
        if azure_resource_uri is None and 'azureResourceUri' in kwargs:
            azure_resource_uri = kwargs['azureResourceUri']
        if total_charges is None and 'totalCharges' in kwargs:
            total_charges = kwargs['totalCharges']
        if total_used_billable_hours is None and 'totalUsedBillableHours' in kwargs:
            total_used_billable_hours = kwargs['totalUsedBillableHours']
        if total_used_free_hours is None and 'totalUsedFreeHours' in kwargs:
            total_used_free_hours = kwargs['totalUsedFreeHours']
        if usage_entries_grouped_by_update_type is None and 'usageEntriesGroupedByUpdateType' in kwargs:
            usage_entries_grouped_by_update_type = kwargs['usageEntriesGroupedByUpdateType']

        if application_name is not None:
            _setter("application_name", application_name)
        if application_version is not None:
            _setter("application_version", application_version)
        if azure_resource_uri is not None:
            _setter("azure_resource_uri", azure_resource_uri)
        if total_charges is not None:
            _setter("total_charges", total_charges)
        if total_used_billable_hours is not None:
            _setter("total_used_billable_hours", total_used_billable_hours)
        if total_used_free_hours is not None:
            _setter("total_used_free_hours", total_used_free_hours)
        if usage_entries_grouped_by_update_type is not None:
            _setter("usage_entries_grouped_by_update_type", usage_entries_grouped_by_update_type)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> Optional[str]:
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="applicationVersion")
    def application_version(self) -> Optional[str]:
        return pulumi.get(self, "application_version")

    @property
    @pulumi.getter(name="azureResourceUri")
    def azure_resource_uri(self) -> Optional[str]:
        return pulumi.get(self, "azure_resource_uri")

    @property
    @pulumi.getter(name="totalCharges")
    def total_charges(self) -> Optional[float]:
        return pulumi.get(self, "total_charges")

    @property
    @pulumi.getter(name="totalUsedBillableHours")
    def total_used_billable_hours(self) -> Optional[float]:
        return pulumi.get(self, "total_used_billable_hours")

    @property
    @pulumi.getter(name="totalUsedFreeHours")
    def total_used_free_hours(self) -> Optional[float]:
        return pulumi.get(self, "total_used_free_hours")

    @property
    @pulumi.getter(name="usageEntriesGroupedByUpdateType")
    def usage_entries_grouped_by_update_type(self) -> Optional[Sequence['outputs.BillingHubUsageGroupedByUpdateTypeResponse']]:
        return pulumi.get(self, "usage_entries_grouped_by_update_type")


@pulumi.output_type
class BillingHubUsageGroupResponse(dict):
    def __init__(__self__, *,
                 execution_usage_details: Optional[Sequence['outputs.BillingHubExecutionUsageDetailResponse']] = None,
                 os_build: Optional[str] = None,
                 product_family: Optional[str] = None,
                 release: Optional[str] = None,
                 release_build_date: Optional[str] = None,
                 release_build_number: Optional[float] = None,
                 release_build_revision: Optional[float] = None,
                 test_type: Optional[str] = None,
                 total_charges: Optional[float] = None,
                 total_used_billable_hours: Optional[float] = None,
                 total_used_free_hours: Optional[float] = None):
        BillingHubUsageGroupResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            execution_usage_details=execution_usage_details,
            os_build=os_build,
            product_family=product_family,
            release=release,
            release_build_date=release_build_date,
            release_build_number=release_build_number,
            release_build_revision=release_build_revision,
            test_type=test_type,
            total_charges=total_charges,
            total_used_billable_hours=total_used_billable_hours,
            total_used_free_hours=total_used_free_hours,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             execution_usage_details: Optional[Sequence['outputs.BillingHubExecutionUsageDetailResponse']] = None,
             os_build: Optional[str] = None,
             product_family: Optional[str] = None,
             release: Optional[str] = None,
             release_build_date: Optional[str] = None,
             release_build_number: Optional[float] = None,
             release_build_revision: Optional[float] = None,
             test_type: Optional[str] = None,
             total_charges: Optional[float] = None,
             total_used_billable_hours: Optional[float] = None,
             total_used_free_hours: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if execution_usage_details is None and 'executionUsageDetails' in kwargs:
            execution_usage_details = kwargs['executionUsageDetails']
        if os_build is None and 'osBuild' in kwargs:
            os_build = kwargs['osBuild']
        if product_family is None and 'productFamily' in kwargs:
            product_family = kwargs['productFamily']
        if release_build_date is None and 'releaseBuildDate' in kwargs:
            release_build_date = kwargs['releaseBuildDate']
        if release_build_number is None and 'releaseBuildNumber' in kwargs:
            release_build_number = kwargs['releaseBuildNumber']
        if release_build_revision is None and 'releaseBuildRevision' in kwargs:
            release_build_revision = kwargs['releaseBuildRevision']
        if test_type is None and 'testType' in kwargs:
            test_type = kwargs['testType']
        if total_charges is None and 'totalCharges' in kwargs:
            total_charges = kwargs['totalCharges']
        if total_used_billable_hours is None and 'totalUsedBillableHours' in kwargs:
            total_used_billable_hours = kwargs['totalUsedBillableHours']
        if total_used_free_hours is None and 'totalUsedFreeHours' in kwargs:
            total_used_free_hours = kwargs['totalUsedFreeHours']

        if execution_usage_details is not None:
            _setter("execution_usage_details", execution_usage_details)
        if os_build is not None:
            _setter("os_build", os_build)
        if product_family is not None:
            _setter("product_family", product_family)
        if release is not None:
            _setter("release", release)
        if release_build_date is not None:
            _setter("release_build_date", release_build_date)
        if release_build_number is not None:
            _setter("release_build_number", release_build_number)
        if release_build_revision is not None:
            _setter("release_build_revision", release_build_revision)
        if test_type is not None:
            _setter("test_type", test_type)
        if total_charges is not None:
            _setter("total_charges", total_charges)
        if total_used_billable_hours is not None:
            _setter("total_used_billable_hours", total_used_billable_hours)
        if total_used_free_hours is not None:
            _setter("total_used_free_hours", total_used_free_hours)

    @property
    @pulumi.getter(name="executionUsageDetails")
    def execution_usage_details(self) -> Optional[Sequence['outputs.BillingHubExecutionUsageDetailResponse']]:
        return pulumi.get(self, "execution_usage_details")

    @property
    @pulumi.getter(name="osBuild")
    def os_build(self) -> Optional[str]:
        return pulumi.get(self, "os_build")

    @property
    @pulumi.getter(name="productFamily")
    def product_family(self) -> Optional[str]:
        return pulumi.get(self, "product_family")

    @property
    @pulumi.getter
    def release(self) -> Optional[str]:
        return pulumi.get(self, "release")

    @property
    @pulumi.getter(name="releaseBuildDate")
    def release_build_date(self) -> Optional[str]:
        return pulumi.get(self, "release_build_date")

    @property
    @pulumi.getter(name="releaseBuildNumber")
    def release_build_number(self) -> Optional[float]:
        return pulumi.get(self, "release_build_number")

    @property
    @pulumi.getter(name="releaseBuildRevision")
    def release_build_revision(self) -> Optional[float]:
        return pulumi.get(self, "release_build_revision")

    @property
    @pulumi.getter(name="testType")
    def test_type(self) -> Optional[str]:
        return pulumi.get(self, "test_type")

    @property
    @pulumi.getter(name="totalCharges")
    def total_charges(self) -> Optional[float]:
        return pulumi.get(self, "total_charges")

    @property
    @pulumi.getter(name="totalUsedBillableHours")
    def total_used_billable_hours(self) -> Optional[float]:
        return pulumi.get(self, "total_used_billable_hours")

    @property
    @pulumi.getter(name="totalUsedFreeHours")
    def total_used_free_hours(self) -> Optional[float]:
        return pulumi.get(self, "total_used_free_hours")


@pulumi.output_type
class BillingHubUsageGroupedByUpdateTypeResponse(dict):
    def __init__(__self__, *,
                 total_charges: Optional[float] = None,
                 total_used_billable_hours: Optional[float] = None,
                 total_used_free_hours: Optional[float] = None,
                 update_type: Optional[str] = None,
                 usage_groups: Optional[Sequence['outputs.BillingHubUsageGroupResponse']] = None):
        BillingHubUsageGroupedByUpdateTypeResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            total_charges=total_charges,
            total_used_billable_hours=total_used_billable_hours,
            total_used_free_hours=total_used_free_hours,
            update_type=update_type,
            usage_groups=usage_groups,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             total_charges: Optional[float] = None,
             total_used_billable_hours: Optional[float] = None,
             total_used_free_hours: Optional[float] = None,
             update_type: Optional[str] = None,
             usage_groups: Optional[Sequence['outputs.BillingHubUsageGroupResponse']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if total_charges is None and 'totalCharges' in kwargs:
            total_charges = kwargs['totalCharges']
        if total_used_billable_hours is None and 'totalUsedBillableHours' in kwargs:
            total_used_billable_hours = kwargs['totalUsedBillableHours']
        if total_used_free_hours is None and 'totalUsedFreeHours' in kwargs:
            total_used_free_hours = kwargs['totalUsedFreeHours']
        if update_type is None and 'updateType' in kwargs:
            update_type = kwargs['updateType']
        if usage_groups is None and 'usageGroups' in kwargs:
            usage_groups = kwargs['usageGroups']

        if total_charges is not None:
            _setter("total_charges", total_charges)
        if total_used_billable_hours is not None:
            _setter("total_used_billable_hours", total_used_billable_hours)
        if total_used_free_hours is not None:
            _setter("total_used_free_hours", total_used_free_hours)
        if update_type is not None:
            _setter("update_type", update_type)
        if usage_groups is not None:
            _setter("usage_groups", usage_groups)

    @property
    @pulumi.getter(name="totalCharges")
    def total_charges(self) -> Optional[float]:
        return pulumi.get(self, "total_charges")

    @property
    @pulumi.getter(name="totalUsedBillableHours")
    def total_used_billable_hours(self) -> Optional[float]:
        return pulumi.get(self, "total_used_billable_hours")

    @property
    @pulumi.getter(name="totalUsedFreeHours")
    def total_used_free_hours(self) -> Optional[float]:
        return pulumi.get(self, "total_used_free_hours")

    @property
    @pulumi.getter(name="updateType")
    def update_type(self) -> Optional[str]:
        return pulumi.get(self, "update_type")

    @property
    @pulumi.getter(name="usageGroups")
    def usage_groups(self) -> Optional[Sequence['outputs.BillingHubUsageGroupResponse']]:
        return pulumi.get(self, "usage_groups")


@pulumi.output_type
class CommandResponse(dict):
    """
    The command used in the test
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "alwaysRun":
            suggest = "always_run"
        elif key == "applyUpdateBefore":
            suggest = "apply_update_before"
        elif key == "maxRunTime":
            suggest = "max_run_time"
        elif key == "restartAfter":
            suggest = "restart_after"
        elif key == "runAsInteractive":
            suggest = "run_as_interactive"
        elif key == "runElevated":
            suggest = "run_elevated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CommandResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CommandResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CommandResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 content: str,
                 content_type: str,
                 name: str,
                 always_run: Optional[bool] = None,
                 apply_update_before: Optional[bool] = None,
                 max_run_time: Optional[int] = None,
                 restart_after: Optional[bool] = None,
                 run_as_interactive: Optional[bool] = None,
                 run_elevated: Optional[bool] = None):
        """
        The command used in the test
        :param str action: The action of the command.
        :param str content: The content of the command. The content depends on source type.
        :param str content_type: The type of command content.
        :param str name: The name of the command.
        :param bool always_run: Specifies whether to run the command even if a previous command is failed.
        :param bool apply_update_before: Specifies whether to apply update before the command.
        :param int max_run_time: Specifies the max run time of the command.
        :param bool restart_after: Specifies whether to restart the VM after the command executed.
        :param bool run_as_interactive: Specifies whether to run the command in interactive mode.
        :param bool run_elevated: Specifies whether to run the command as administrator.
        """
        CommandResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            content=content,
            content_type=content_type,
            name=name,
            always_run=always_run,
            apply_update_before=apply_update_before,
            max_run_time=max_run_time,
            restart_after=restart_after,
            run_as_interactive=run_as_interactive,
            run_elevated=run_elevated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             content: Optional[str] = None,
             content_type: Optional[str] = None,
             name: Optional[str] = None,
             always_run: Optional[bool] = None,
             apply_update_before: Optional[bool] = None,
             max_run_time: Optional[int] = None,
             restart_after: Optional[bool] = None,
             run_as_interactive: Optional[bool] = None,
             run_elevated: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if action is None:
            raise TypeError("Missing 'action' argument")
        if content is None:
            raise TypeError("Missing 'content' argument")
        if content_type is None and 'contentType' in kwargs:
            content_type = kwargs['contentType']
        if content_type is None:
            raise TypeError("Missing 'content_type' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if always_run is None and 'alwaysRun' in kwargs:
            always_run = kwargs['alwaysRun']
        if apply_update_before is None and 'applyUpdateBefore' in kwargs:
            apply_update_before = kwargs['applyUpdateBefore']
        if max_run_time is None and 'maxRunTime' in kwargs:
            max_run_time = kwargs['maxRunTime']
        if restart_after is None and 'restartAfter' in kwargs:
            restart_after = kwargs['restartAfter']
        if run_as_interactive is None and 'runAsInteractive' in kwargs:
            run_as_interactive = kwargs['runAsInteractive']
        if run_elevated is None and 'runElevated' in kwargs:
            run_elevated = kwargs['runElevated']

        _setter("action", action)
        _setter("content", content)
        _setter("content_type", content_type)
        _setter("name", name)
        if always_run is not None:
            _setter("always_run", always_run)
        if apply_update_before is not None:
            _setter("apply_update_before", apply_update_before)
        if max_run_time is not None:
            _setter("max_run_time", max_run_time)
        if restart_after is not None:
            _setter("restart_after", restart_after)
        if run_as_interactive is not None:
            _setter("run_as_interactive", run_as_interactive)
        if run_elevated is not None:
            _setter("run_elevated", run_elevated)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action of the command.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The content of the command. The content depends on source type.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        The type of command content.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the command.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="alwaysRun")
    def always_run(self) -> Optional[bool]:
        """
        Specifies whether to run the command even if a previous command is failed.
        """
        return pulumi.get(self, "always_run")

    @property
    @pulumi.getter(name="applyUpdateBefore")
    def apply_update_before(self) -> Optional[bool]:
        """
        Specifies whether to apply update before the command.
        """
        return pulumi.get(self, "apply_update_before")

    @property
    @pulumi.getter(name="maxRunTime")
    def max_run_time(self) -> Optional[int]:
        """
        Specifies the max run time of the command.
        """
        return pulumi.get(self, "max_run_time")

    @property
    @pulumi.getter(name="restartAfter")
    def restart_after(self) -> Optional[bool]:
        """
        Specifies whether to restart the VM after the command executed.
        """
        return pulumi.get(self, "restart_after")

    @property
    @pulumi.getter(name="runAsInteractive")
    def run_as_interactive(self) -> Optional[bool]:
        """
        Specifies whether to run the command in interactive mode.
        """
        return pulumi.get(self, "run_as_interactive")

    @property
    @pulumi.getter(name="runElevated")
    def run_elevated(self) -> Optional[bool]:
        """
        Specifies whether to run the command as administrator.
        """
        return pulumi.get(self, "run_elevated")


@pulumi.output_type
class DistributionGroupListReceiverValueResponse(dict):
    """
    The user object receiver value.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionGroups":
            suggest = "distribution_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionGroupListReceiverValueResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionGroupListReceiverValueResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionGroupListReceiverValueResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_groups: Optional[Sequence[str]] = None):
        """
        The user object receiver value.
        :param Sequence[str] distribution_groups: The list of distribution groups.
        """
        DistributionGroupListReceiverValueResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            distribution_groups=distribution_groups,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             distribution_groups: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if distribution_groups is None and 'distributionGroups' in kwargs:
            distribution_groups = kwargs['distributionGroups']

        if distribution_groups is not None:
            _setter("distribution_groups", distribution_groups)

    @property
    @pulumi.getter(name="distributionGroups")
    def distribution_groups(self) -> Optional[Sequence[str]]:
        """
        The list of distribution groups.
        """
        return pulumi.get(self, "distribution_groups")


@pulumi.output_type
class NotificationEventReceiverResponse(dict):
    """
    A notification event receivers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "receiverType":
            suggest = "receiver_type"
        elif key == "receiverValue":
            suggest = "receiver_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationEventReceiverResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationEventReceiverResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationEventReceiverResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 receiver_type: Optional[str] = None,
                 receiver_value: Optional['outputs.NotificationReceiverValueResponse'] = None):
        """
        A notification event receivers.
        :param str receiver_type: The type of the notification event receiver.
        :param 'NotificationReceiverValueResponse' receiver_value: The notification event receiver value.
        """
        NotificationEventReceiverResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            receiver_type=receiver_type,
            receiver_value=receiver_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             receiver_type: Optional[str] = None,
             receiver_value: Optional['outputs.NotificationReceiverValueResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if receiver_type is None and 'receiverType' in kwargs:
            receiver_type = kwargs['receiverType']
        if receiver_value is None and 'receiverValue' in kwargs:
            receiver_value = kwargs['receiverValue']

        if receiver_type is not None:
            _setter("receiver_type", receiver_type)
        if receiver_value is not None:
            _setter("receiver_value", receiver_value)

    @property
    @pulumi.getter(name="receiverType")
    def receiver_type(self) -> Optional[str]:
        """
        The type of the notification event receiver.
        """
        return pulumi.get(self, "receiver_type")

    @property
    @pulumi.getter(name="receiverValue")
    def receiver_value(self) -> Optional['outputs.NotificationReceiverValueResponse']:
        """
        The notification event receiver value.
        """
        return pulumi.get(self, "receiver_value")


@pulumi.output_type
class NotificationReceiverValueResponse(dict):
    """
    A notification event receiver value.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionGroupListReceiverValue":
            suggest = "distribution_group_list_receiver_value"
        elif key == "subscriptionReceiverValue":
            suggest = "subscription_receiver_value"
        elif key == "userObjectReceiverValue":
            suggest = "user_object_receiver_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationReceiverValueResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationReceiverValueResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationReceiverValueResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_group_list_receiver_value: Optional['outputs.DistributionGroupListReceiverValueResponse'] = None,
                 subscription_receiver_value: Optional['outputs.SubscriptionReceiverValueResponse'] = None,
                 user_object_receiver_value: Optional['outputs.UserObjectReceiverValueResponse'] = None):
        """
        A notification event receiver value.
        :param 'DistributionGroupListReceiverValueResponse' distribution_group_list_receiver_value: The user object receiver value.
        :param 'SubscriptionReceiverValueResponse' subscription_receiver_value: The user object receiver value.
        :param 'UserObjectReceiverValueResponse' user_object_receiver_value: The user object receiver value.
        """
        NotificationReceiverValueResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            distribution_group_list_receiver_value=distribution_group_list_receiver_value,
            subscription_receiver_value=subscription_receiver_value,
            user_object_receiver_value=user_object_receiver_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             distribution_group_list_receiver_value: Optional['outputs.DistributionGroupListReceiverValueResponse'] = None,
             subscription_receiver_value: Optional['outputs.SubscriptionReceiverValueResponse'] = None,
             user_object_receiver_value: Optional['outputs.UserObjectReceiverValueResponse'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if distribution_group_list_receiver_value is None and 'distributionGroupListReceiverValue' in kwargs:
            distribution_group_list_receiver_value = kwargs['distributionGroupListReceiverValue']
        if subscription_receiver_value is None and 'subscriptionReceiverValue' in kwargs:
            subscription_receiver_value = kwargs['subscriptionReceiverValue']
        if user_object_receiver_value is None and 'userObjectReceiverValue' in kwargs:
            user_object_receiver_value = kwargs['userObjectReceiverValue']

        if distribution_group_list_receiver_value is not None:
            _setter("distribution_group_list_receiver_value", distribution_group_list_receiver_value)
        if subscription_receiver_value is not None:
            _setter("subscription_receiver_value", subscription_receiver_value)
        if user_object_receiver_value is not None:
            _setter("user_object_receiver_value", user_object_receiver_value)

    @property
    @pulumi.getter(name="distributionGroupListReceiverValue")
    def distribution_group_list_receiver_value(self) -> Optional['outputs.DistributionGroupListReceiverValueResponse']:
        """
        The user object receiver value.
        """
        return pulumi.get(self, "distribution_group_list_receiver_value")

    @property
    @pulumi.getter(name="subscriptionReceiverValue")
    def subscription_receiver_value(self) -> Optional['outputs.SubscriptionReceiverValueResponse']:
        """
        The user object receiver value.
        """
        return pulumi.get(self, "subscription_receiver_value")

    @property
    @pulumi.getter(name="userObjectReceiverValue")
    def user_object_receiver_value(self) -> Optional['outputs.UserObjectReceiverValueResponse']:
        """
        The user object receiver value.
        """
        return pulumi.get(self, "user_object_receiver_value")


@pulumi.output_type
class PackageValidationResultResponse(dict):
    """
    The validation results. There's validation on package when it's created or updated.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isValid":
            suggest = "is_valid"
        elif key == "validationName":
            suggest = "validation_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PackageValidationResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PackageValidationResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PackageValidationResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 errors: Sequence[str],
                 is_valid: bool,
                 validation_name: str):
        """
        The validation results. There's validation on package when it's created or updated.
        :param Sequence[str] errors: Error information.
        :param bool is_valid: Indicates whether the package passed the validation.
        :param str validation_name: Validation name.
        """
        PackageValidationResultResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            errors=errors,
            is_valid=is_valid,
            validation_name=validation_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             errors: Optional[Sequence[str]] = None,
             is_valid: Optional[bool] = None,
             validation_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if errors is None:
            raise TypeError("Missing 'errors' argument")
        if is_valid is None and 'isValid' in kwargs:
            is_valid = kwargs['isValid']
        if is_valid is None:
            raise TypeError("Missing 'is_valid' argument")
        if validation_name is None and 'validationName' in kwargs:
            validation_name = kwargs['validationName']
        if validation_name is None:
            raise TypeError("Missing 'validation_name' argument")

        _setter("errors", errors)
        _setter("is_valid", is_valid)
        _setter("validation_name", validation_name)

    @property
    @pulumi.getter
    def errors(self) -> Sequence[str]:
        """
        Error information.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter(name="isValid")
    def is_valid(self) -> bool:
        """
        Indicates whether the package passed the validation.
        """
        return pulumi.get(self, "is_valid")

    @property
    @pulumi.getter(name="validationName")
    def validation_name(self) -> str:
        """
        Validation name.
        """
        return pulumi.get(self, "validation_name")


@pulumi.output_type
class SubscriptionReceiverValueResponse(dict):
    """
    The subscription role receiver value.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "subscriptionName":
            suggest = "subscription_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionReceiverValueResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionReceiverValueResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionReceiverValueResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 subscription_name: Optional[str] = None):
        """
        The subscription role receiver value.
        :param str role: The role of the notification receiver.
        :param str subscription_id: The subscription id of the notification receiver.
        :param str subscription_name: The subscription name of the notification receiver.
        """
        SubscriptionReceiverValueResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role=role,
            subscription_id=subscription_id,
            subscription_name=subscription_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role: Optional[str] = None,
             subscription_id: Optional[str] = None,
             subscription_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if subscription_id is None and 'subscriptionId' in kwargs:
            subscription_id = kwargs['subscriptionId']
        if subscription_name is None and 'subscriptionName' in kwargs:
            subscription_name = kwargs['subscriptionName']

        if role is not None:
            _setter("role", role)
        if subscription_id is not None:
            _setter("subscription_id", subscription_id)
        if subscription_name is not None:
            _setter("subscription_name", subscription_name)

    @property
    @pulumi.getter
    def role(self) -> Optional[str]:
        """
        The role of the notification receiver.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        The subscription id of the notification receiver.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> Optional[str]:
        """
        The subscription name of the notification receiver.
        """
        return pulumi.get(self, "subscription_name")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The type of identity that last modified the resource.
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if created_at is None and 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if created_by is None and 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if created_by_type is None and 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if last_modified_at is None and 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if last_modified_by is None and 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if last_modified_by_type is None and 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TargetOSInfoResponse(dict):
    """
    The information of the target OS to be tested.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "osUpdateType":
            suggest = "os_update_type"
        elif key == "targetOSs":
            suggest = "target_oss"
        elif key == "baselineOSs":
            suggest = "baseline_oss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetOSInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetOSInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetOSInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 os_update_type: str,
                 target_oss: Sequence[str],
                 baseline_oss: Optional[Sequence[str]] = None):
        """
        The information of the target OS to be tested.
        :param str os_update_type: Specifies the OS update type to test against, e.g., 'Security updates' or 'Feature updates'.
        :param Sequence[str] target_oss: Specifies the target OSs to be tested.
        :param Sequence[str] baseline_oss: Specifies the baseline OSs to be tested.
        """
        TargetOSInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            os_update_type=os_update_type,
            target_oss=target_oss,
            baseline_oss=baseline_oss,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             os_update_type: Optional[str] = None,
             target_oss: Optional[Sequence[str]] = None,
             baseline_oss: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if os_update_type is None and 'osUpdateType' in kwargs:
            os_update_type = kwargs['osUpdateType']
        if os_update_type is None:
            raise TypeError("Missing 'os_update_type' argument")
        if target_oss is None and 'targetOSs' in kwargs:
            target_oss = kwargs['targetOSs']
        if target_oss is None:
            raise TypeError("Missing 'target_oss' argument")
        if baseline_oss is None and 'baselineOSs' in kwargs:
            baseline_oss = kwargs['baselineOSs']

        _setter("os_update_type", os_update_type)
        _setter("target_oss", target_oss)
        if baseline_oss is not None:
            _setter("baseline_oss", baseline_oss)

    @property
    @pulumi.getter(name="osUpdateType")
    def os_update_type(self) -> str:
        """
        Specifies the OS update type to test against, e.g., 'Security updates' or 'Feature updates'.
        """
        return pulumi.get(self, "os_update_type")

    @property
    @pulumi.getter(name="targetOSs")
    def target_oss(self) -> Sequence[str]:
        """
        Specifies the target OSs to be tested.
        """
        return pulumi.get(self, "target_oss")

    @property
    @pulumi.getter(name="baselineOSs")
    def baseline_oss(self) -> Optional[Sequence[str]]:
        """
        Specifies the baseline OSs to be tested.
        """
        return pulumi.get(self, "baseline_oss")


@pulumi.output_type
class TestBaseAccountSKUCapabilityResponse(dict):
    """
    Properties of the Test Base Account SKU Capability.
    """
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        Properties of the Test Base Account SKU Capability.
        :param str name: An invariant to describe the feature, such as 'SLA'.
        :param str value: An invariant if the feature is measured by quantity, such as 99.9%.
        """
        TestBaseAccountSKUCapabilityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        An invariant to describe the feature, such as 'SLA'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        An invariant if the feature is measured by quantity, such as 99.9%.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TestBaseAccountSKUResponse(dict):
    """
    Describes a Test Base Account SKU.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TestBaseAccountSKUResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TestBaseAccountSKUResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TestBaseAccountSKUResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capabilities: Sequence['outputs.TestBaseAccountSKUCapabilityResponse'],
                 name: str,
                 tier: str,
                 locations: Optional[Sequence[str]] = None,
                 resource_type: Optional[str] = None):
        """
        Describes a Test Base Account SKU.
        :param Sequence['TestBaseAccountSKUCapabilityResponse'] capabilities: The capabilities of a SKU.
        :param str name: The name of the SKU. This is typically a letter + number code, such as B0 or S0.
        :param str tier: The tier of this particular SKU.
        :param Sequence[str] locations: The locations that the SKU is available.
        :param str resource_type: The type of resource the SKU applies to.
        """
        TestBaseAccountSKUResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capabilities=capabilities,
            name=name,
            tier=tier,
            locations=locations,
            resource_type=resource_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capabilities: Optional[Sequence['outputs.TestBaseAccountSKUCapabilityResponse']] = None,
             name: Optional[str] = None,
             tier: Optional[str] = None,
             locations: Optional[Sequence[str]] = None,
             resource_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if capabilities is None:
            raise TypeError("Missing 'capabilities' argument")
        if name is None:
            raise TypeError("Missing 'name' argument")
        if tier is None:
            raise TypeError("Missing 'tier' argument")
        if resource_type is None and 'resourceType' in kwargs:
            resource_type = kwargs['resourceType']

        _setter("capabilities", capabilities)
        _setter("name", name)
        _setter("tier", tier)
        if locations is not None:
            _setter("locations", locations)
        if resource_type is not None:
            _setter("resource_type", resource_type)

    @property
    @pulumi.getter
    def capabilities(self) -> Sequence['outputs.TestBaseAccountSKUCapabilityResponse']:
        """
        The capabilities of a SKU.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the SKU. This is typically a letter + number code, such as B0 or S0.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        The tier of this particular SKU.
        """
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        """
        The locations that the SKU is available.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        The type of resource the SKU applies to.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class TestResponse(dict):
    """
    The definition of a Test.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testType":
            suggest = "test_type"
        elif key == "validationResultId":
            suggest = "validation_result_id"
        elif key == "validationRunStatus":
            suggest = "validation_run_status"
        elif key == "isActive":
            suggest = "is_active"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TestResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TestResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TestResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence['outputs.CommandResponse'],
                 test_type: str,
                 validation_result_id: str,
                 validation_run_status: str,
                 is_active: Optional[bool] = None):
        """
        The definition of a Test.
        :param Sequence['CommandResponse'] commands: The commands used in the test.
        :param str test_type: The type of the test.
        :param str validation_result_id: Resource identifier of the validation test result.
        :param str validation_run_status: The status of the validation run of the package.
        :param bool is_active: Indicates if this test is active.It doesn't schedule test for not active Test.
        """
        TestResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
            test_type=test_type,
            validation_result_id=validation_result_id,
            validation_run_status=validation_run_status,
            is_active=is_active,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Optional[Sequence['outputs.CommandResponse']] = None,
             test_type: Optional[str] = None,
             validation_result_id: Optional[str] = None,
             validation_run_status: Optional[str] = None,
             is_active: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if commands is None:
            raise TypeError("Missing 'commands' argument")
        if test_type is None and 'testType' in kwargs:
            test_type = kwargs['testType']
        if test_type is None:
            raise TypeError("Missing 'test_type' argument")
        if validation_result_id is None and 'validationResultId' in kwargs:
            validation_result_id = kwargs['validationResultId']
        if validation_result_id is None:
            raise TypeError("Missing 'validation_result_id' argument")
        if validation_run_status is None and 'validationRunStatus' in kwargs:
            validation_run_status = kwargs['validationRunStatus']
        if validation_run_status is None:
            raise TypeError("Missing 'validation_run_status' argument")
        if is_active is None and 'isActive' in kwargs:
            is_active = kwargs['isActive']

        _setter("commands", commands)
        _setter("test_type", test_type)
        _setter("validation_result_id", validation_result_id)
        _setter("validation_run_status", validation_run_status)
        if is_active is not None:
            _setter("is_active", is_active)

    @property
    @pulumi.getter
    def commands(self) -> Sequence['outputs.CommandResponse']:
        """
        The commands used in the test.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="testType")
    def test_type(self) -> str:
        """
        The type of the test.
        """
        return pulumi.get(self, "test_type")

    @property
    @pulumi.getter(name="validationResultId")
    def validation_result_id(self) -> str:
        """
        Resource identifier of the validation test result.
        """
        return pulumi.get(self, "validation_result_id")

    @property
    @pulumi.getter(name="validationRunStatus")
    def validation_run_status(self) -> str:
        """
        The status of the validation run of the package.
        """
        return pulumi.get(self, "validation_run_status")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[bool]:
        """
        Indicates if this test is active.It doesn't schedule test for not active Test.
        """
        return pulumi.get(self, "is_active")


@pulumi.output_type
class UserObjectReceiverValueResponse(dict):
    """
    The user object receiver value.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userObjectIds":
            suggest = "user_object_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserObjectReceiverValueResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserObjectReceiverValueResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserObjectReceiverValueResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_object_ids: Optional[Sequence[str]] = None):
        """
        The user object receiver value.
        :param Sequence[str] user_object_ids: user object ids.
        """
        UserObjectReceiverValueResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            user_object_ids=user_object_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             user_object_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if user_object_ids is None and 'userObjectIds' in kwargs:
            user_object_ids = kwargs['userObjectIds']

        if user_object_ids is not None:
            _setter("user_object_ids", user_object_ids)

    @property
    @pulumi.getter(name="userObjectIds")
    def user_object_ids(self) -> Optional[Sequence[str]]:
        """
        user object ids.
        """
        return pulumi.get(self, "user_object_ids")


