# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'BillingHubExecutionUsageDetailResponse',
    'BillingHubFreeHourIncrementEntryResponse',
    'BillingHubGetUsageRequestResponse',
    'BillingHubPackageUsageResponse',
    'BillingHubUsageGroupResponse',
    'BillingHubUsageGroupedByUpdateTypeResponse',
    'CommandResponse',
    'DistributionGroupListReceiverValueResponse',
    'DraftPackageIntuneAppMetadataItemResponse',
    'DraftPackageIntuneAppMetadataResponse',
    'EnrolledIntuneAppResponse',
    'FirstPartyAppDefinitionResponse',
    'GalleryAppDefinitionResponse',
    'HighlightedFileResponse',
    'ImageValidationResultsResponse',
    'InplaceUpgradeOSInfoResponse',
    'IntuneEnrollmentMetadataResponse',
    'NotificationEventReceiverResponse',
    'NotificationReceiverValueResponse',
    'OsPropertiesResponse',
    'PackageValidationResultResponse',
    'PreReleaseAccessRequestSpecResponse',
    'ReleasePropertiesResponse',
    'SubscriptionReceiverValueResponse',
    'SystemAssignedServiceIdentityResponse',
    'SystemDataResponse',
    'TabStateResponse',
    'TargetOSInfoResponse',
    'TestBaseAccountSKUCapabilityResponse',
    'TestBaseAccountSKUResponse',
    'TestResponse',
    'UserObjectReceiverValueResponse',
    'VerificationResultResponse',
]

@pulumi.output_type
class BillingHubExecutionUsageDetailResponse(dict):
    def __init__(__self__, *,
                 application_name: Optional[builtins.str] = None,
                 application_version: Optional[builtins.str] = None,
                 billed_charges: Optional[builtins.float] = None,
                 end_time_stamp: Optional[builtins.str] = None,
                 execution_request_id: Optional[builtins.str] = None,
                 meter_id: Optional[builtins.str] = None,
                 os_build: Optional[builtins.str] = None,
                 release: Optional[builtins.str] = None,
                 sku: Optional[builtins.str] = None,
                 start_time_stamp: Optional[builtins.str] = None,
                 test_type: Optional[builtins.str] = None,
                 update_type: Optional[builtins.str] = None,
                 used_billable_hours: Optional[builtins.float] = None,
                 used_free_hours: Optional[builtins.float] = None):
        if application_name is not None:
            pulumi.set(__self__, "application_name", application_name)
        if application_version is not None:
            pulumi.set(__self__, "application_version", application_version)
        if billed_charges is not None:
            pulumi.set(__self__, "billed_charges", billed_charges)
        if end_time_stamp is not None:
            pulumi.set(__self__, "end_time_stamp", end_time_stamp)
        if execution_request_id is not None:
            pulumi.set(__self__, "execution_request_id", execution_request_id)
        if meter_id is not None:
            pulumi.set(__self__, "meter_id", meter_id)
        if os_build is not None:
            pulumi.set(__self__, "os_build", os_build)
        if release is not None:
            pulumi.set(__self__, "release", release)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)
        if start_time_stamp is not None:
            pulumi.set(__self__, "start_time_stamp", start_time_stamp)
        if test_type is not None:
            pulumi.set(__self__, "test_type", test_type)
        if update_type is not None:
            pulumi.set(__self__, "update_type", update_type)
        if used_billable_hours is not None:
            pulumi.set(__self__, "used_billable_hours", used_billable_hours)
        if used_free_hours is not None:
            pulumi.set(__self__, "used_free_hours", used_free_hours)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="applicationVersion")
    def application_version(self) -> Optional[builtins.str]:
        return pulumi.get(self, "application_version")

    @property
    @pulumi.getter(name="billedCharges")
    def billed_charges(self) -> Optional[builtins.float]:
        return pulumi.get(self, "billed_charges")

    @property
    @pulumi.getter(name="endTimeStamp")
    def end_time_stamp(self) -> Optional[builtins.str]:
        return pulumi.get(self, "end_time_stamp")

    @property
    @pulumi.getter(name="executionRequestId")
    def execution_request_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "execution_request_id")

    @property
    @pulumi.getter(name="meterId")
    def meter_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "meter_id")

    @property
    @pulumi.getter(name="osBuild")
    def os_build(self) -> Optional[builtins.str]:
        return pulumi.get(self, "os_build")

    @property
    @pulumi.getter
    def release(self) -> Optional[builtins.str]:
        return pulumi.get(self, "release")

    @property
    @pulumi.getter
    def sku(self) -> Optional[builtins.str]:
        return pulumi.get(self, "sku")

    @property
    @pulumi.getter(name="startTimeStamp")
    def start_time_stamp(self) -> Optional[builtins.str]:
        return pulumi.get(self, "start_time_stamp")

    @property
    @pulumi.getter(name="testType")
    def test_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "test_type")

    @property
    @pulumi.getter(name="updateType")
    def update_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "update_type")

    @property
    @pulumi.getter(name="usedBillableHours")
    def used_billable_hours(self) -> Optional[builtins.float]:
        return pulumi.get(self, "used_billable_hours")

    @property
    @pulumi.getter(name="usedFreeHours")
    def used_free_hours(self) -> Optional[builtins.float]:
        return pulumi.get(self, "used_free_hours")


@pulumi.output_type
class BillingHubFreeHourIncrementEntryResponse(dict):
    def __init__(__self__, *,
                 create_time_stamp: Optional[builtins.str] = None,
                 expiration_time_stamp: Optional[builtins.str] = None,
                 free_hour_status: Optional[builtins.str] = None,
                 free_hour_type: Optional[builtins.str] = None,
                 incremental_free_hours: Optional[builtins.float] = None,
                 remaining_free_hours: Optional[builtins.float] = None):
        if create_time_stamp is not None:
            pulumi.set(__self__, "create_time_stamp", create_time_stamp)
        if expiration_time_stamp is not None:
            pulumi.set(__self__, "expiration_time_stamp", expiration_time_stamp)
        if free_hour_status is not None:
            pulumi.set(__self__, "free_hour_status", free_hour_status)
        if free_hour_type is not None:
            pulumi.set(__self__, "free_hour_type", free_hour_type)
        if incremental_free_hours is not None:
            pulumi.set(__self__, "incremental_free_hours", incremental_free_hours)
        if remaining_free_hours is not None:
            pulumi.set(__self__, "remaining_free_hours", remaining_free_hours)

    @property
    @pulumi.getter(name="createTimeStamp")
    def create_time_stamp(self) -> Optional[builtins.str]:
        return pulumi.get(self, "create_time_stamp")

    @property
    @pulumi.getter(name="expirationTimeStamp")
    def expiration_time_stamp(self) -> Optional[builtins.str]:
        return pulumi.get(self, "expiration_time_stamp")

    @property
    @pulumi.getter(name="freeHourStatus")
    def free_hour_status(self) -> Optional[builtins.str]:
        return pulumi.get(self, "free_hour_status")

    @property
    @pulumi.getter(name="freeHourType")
    def free_hour_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "free_hour_type")

    @property
    @pulumi.getter(name="incrementalFreeHours")
    def incremental_free_hours(self) -> Optional[builtins.float]:
        return pulumi.get(self, "incremental_free_hours")

    @property
    @pulumi.getter(name="remainingFreeHours")
    def remaining_free_hours(self) -> Optional[builtins.float]:
        return pulumi.get(self, "remaining_free_hours")


@pulumi.output_type
class BillingHubGetUsageRequestResponse(dict):
    def __init__(__self__, *,
                 end_time_stamp: builtins.str,
                 start_time_stamp: builtins.str,
                 page_index: Optional[builtins.int] = None,
                 page_size: Optional[builtins.int] = None):
        pulumi.set(__self__, "end_time_stamp", end_time_stamp)
        pulumi.set(__self__, "start_time_stamp", start_time_stamp)
        if page_index is not None:
            pulumi.set(__self__, "page_index", page_index)
        if page_size is not None:
            pulumi.set(__self__, "page_size", page_size)

    @property
    @pulumi.getter(name="endTimeStamp")
    def end_time_stamp(self) -> builtins.str:
        return pulumi.get(self, "end_time_stamp")

    @property
    @pulumi.getter(name="startTimeStamp")
    def start_time_stamp(self) -> builtins.str:
        return pulumi.get(self, "start_time_stamp")

    @property
    @pulumi.getter(name="pageIndex")
    def page_index(self) -> Optional[builtins.int]:
        return pulumi.get(self, "page_index")

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[builtins.int]:
        return pulumi.get(self, "page_size")


@pulumi.output_type
class BillingHubPackageUsageResponse(dict):
    def __init__(__self__, *,
                 application_name: Optional[builtins.str] = None,
                 application_version: Optional[builtins.str] = None,
                 azure_resource_uri: Optional[builtins.str] = None,
                 total_charges: Optional[builtins.float] = None,
                 total_used_billable_hours: Optional[builtins.float] = None,
                 total_used_free_hours: Optional[builtins.float] = None,
                 usage_entries_grouped_by_update_type: Optional[Sequence['outputs.BillingHubUsageGroupedByUpdateTypeResponse']] = None):
        if application_name is not None:
            pulumi.set(__self__, "application_name", application_name)
        if application_version is not None:
            pulumi.set(__self__, "application_version", application_version)
        if azure_resource_uri is not None:
            pulumi.set(__self__, "azure_resource_uri", azure_resource_uri)
        if total_charges is not None:
            pulumi.set(__self__, "total_charges", total_charges)
        if total_used_billable_hours is not None:
            pulumi.set(__self__, "total_used_billable_hours", total_used_billable_hours)
        if total_used_free_hours is not None:
            pulumi.set(__self__, "total_used_free_hours", total_used_free_hours)
        if usage_entries_grouped_by_update_type is not None:
            pulumi.set(__self__, "usage_entries_grouped_by_update_type", usage_entries_grouped_by_update_type)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="applicationVersion")
    def application_version(self) -> Optional[builtins.str]:
        return pulumi.get(self, "application_version")

    @property
    @pulumi.getter(name="azureResourceUri")
    def azure_resource_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "azure_resource_uri")

    @property
    @pulumi.getter(name="totalCharges")
    def total_charges(self) -> Optional[builtins.float]:
        return pulumi.get(self, "total_charges")

    @property
    @pulumi.getter(name="totalUsedBillableHours")
    def total_used_billable_hours(self) -> Optional[builtins.float]:
        return pulumi.get(self, "total_used_billable_hours")

    @property
    @pulumi.getter(name="totalUsedFreeHours")
    def total_used_free_hours(self) -> Optional[builtins.float]:
        return pulumi.get(self, "total_used_free_hours")

    @property
    @pulumi.getter(name="usageEntriesGroupedByUpdateType")
    def usage_entries_grouped_by_update_type(self) -> Optional[Sequence['outputs.BillingHubUsageGroupedByUpdateTypeResponse']]:
        return pulumi.get(self, "usage_entries_grouped_by_update_type")


@pulumi.output_type
class BillingHubUsageGroupResponse(dict):
    def __init__(__self__, *,
                 execution_usage_details: Optional[Sequence['outputs.BillingHubExecutionUsageDetailResponse']] = None,
                 os_build: Optional[builtins.str] = None,
                 product_family: Optional[builtins.str] = None,
                 release: Optional[builtins.str] = None,
                 release_build_date: Optional[builtins.str] = None,
                 release_build_number: Optional[builtins.float] = None,
                 release_build_revision: Optional[builtins.float] = None,
                 test_type: Optional[builtins.str] = None,
                 total_charges: Optional[builtins.float] = None,
                 total_used_billable_hours: Optional[builtins.float] = None,
                 total_used_free_hours: Optional[builtins.float] = None):
        if execution_usage_details is not None:
            pulumi.set(__self__, "execution_usage_details", execution_usage_details)
        if os_build is not None:
            pulumi.set(__self__, "os_build", os_build)
        if product_family is not None:
            pulumi.set(__self__, "product_family", product_family)
        if release is not None:
            pulumi.set(__self__, "release", release)
        if release_build_date is not None:
            pulumi.set(__self__, "release_build_date", release_build_date)
        if release_build_number is not None:
            pulumi.set(__self__, "release_build_number", release_build_number)
        if release_build_revision is not None:
            pulumi.set(__self__, "release_build_revision", release_build_revision)
        if test_type is not None:
            pulumi.set(__self__, "test_type", test_type)
        if total_charges is not None:
            pulumi.set(__self__, "total_charges", total_charges)
        if total_used_billable_hours is not None:
            pulumi.set(__self__, "total_used_billable_hours", total_used_billable_hours)
        if total_used_free_hours is not None:
            pulumi.set(__self__, "total_used_free_hours", total_used_free_hours)

    @property
    @pulumi.getter(name="executionUsageDetails")
    def execution_usage_details(self) -> Optional[Sequence['outputs.BillingHubExecutionUsageDetailResponse']]:
        return pulumi.get(self, "execution_usage_details")

    @property
    @pulumi.getter(name="osBuild")
    def os_build(self) -> Optional[builtins.str]:
        return pulumi.get(self, "os_build")

    @property
    @pulumi.getter(name="productFamily")
    def product_family(self) -> Optional[builtins.str]:
        return pulumi.get(self, "product_family")

    @property
    @pulumi.getter
    def release(self) -> Optional[builtins.str]:
        return pulumi.get(self, "release")

    @property
    @pulumi.getter(name="releaseBuildDate")
    def release_build_date(self) -> Optional[builtins.str]:
        return pulumi.get(self, "release_build_date")

    @property
    @pulumi.getter(name="releaseBuildNumber")
    def release_build_number(self) -> Optional[builtins.float]:
        return pulumi.get(self, "release_build_number")

    @property
    @pulumi.getter(name="releaseBuildRevision")
    def release_build_revision(self) -> Optional[builtins.float]:
        return pulumi.get(self, "release_build_revision")

    @property
    @pulumi.getter(name="testType")
    def test_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "test_type")

    @property
    @pulumi.getter(name="totalCharges")
    def total_charges(self) -> Optional[builtins.float]:
        return pulumi.get(self, "total_charges")

    @property
    @pulumi.getter(name="totalUsedBillableHours")
    def total_used_billable_hours(self) -> Optional[builtins.float]:
        return pulumi.get(self, "total_used_billable_hours")

    @property
    @pulumi.getter(name="totalUsedFreeHours")
    def total_used_free_hours(self) -> Optional[builtins.float]:
        return pulumi.get(self, "total_used_free_hours")


@pulumi.output_type
class BillingHubUsageGroupedByUpdateTypeResponse(dict):
    def __init__(__self__, *,
                 total_charges: Optional[builtins.float] = None,
                 total_used_billable_hours: Optional[builtins.float] = None,
                 total_used_free_hours: Optional[builtins.float] = None,
                 update_type: Optional[builtins.str] = None,
                 usage_groups: Optional[Sequence['outputs.BillingHubUsageGroupResponse']] = None):
        if total_charges is not None:
            pulumi.set(__self__, "total_charges", total_charges)
        if total_used_billable_hours is not None:
            pulumi.set(__self__, "total_used_billable_hours", total_used_billable_hours)
        if total_used_free_hours is not None:
            pulumi.set(__self__, "total_used_free_hours", total_used_free_hours)
        if update_type is not None:
            pulumi.set(__self__, "update_type", update_type)
        if usage_groups is not None:
            pulumi.set(__self__, "usage_groups", usage_groups)

    @property
    @pulumi.getter(name="totalCharges")
    def total_charges(self) -> Optional[builtins.float]:
        return pulumi.get(self, "total_charges")

    @property
    @pulumi.getter(name="totalUsedBillableHours")
    def total_used_billable_hours(self) -> Optional[builtins.float]:
        return pulumi.get(self, "total_used_billable_hours")

    @property
    @pulumi.getter(name="totalUsedFreeHours")
    def total_used_free_hours(self) -> Optional[builtins.float]:
        return pulumi.get(self, "total_used_free_hours")

    @property
    @pulumi.getter(name="updateType")
    def update_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "update_type")

    @property
    @pulumi.getter(name="usageGroups")
    def usage_groups(self) -> Optional[Sequence['outputs.BillingHubUsageGroupResponse']]:
        return pulumi.get(self, "usage_groups")


@pulumi.output_type
class CommandResponse(dict):
    """
    The command used in the test
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "alwaysRun":
            suggest = "always_run"
        elif key == "applyUpdateBefore":
            suggest = "apply_update_before"
        elif key == "enrollIntuneBefore":
            suggest = "enroll_intune_before"
        elif key == "install1PAppBefore":
            suggest = "install1_p_app_before"
        elif key == "maxRunTime":
            suggest = "max_run_time"
        elif key == "postUpgrade":
            suggest = "post_upgrade"
        elif key == "preUpgrade":
            suggest = "pre_upgrade"
        elif key == "restartAfter":
            suggest = "restart_after"
        elif key == "runAsInteractive":
            suggest = "run_as_interactive"
        elif key == "runElevated":
            suggest = "run_elevated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CommandResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CommandResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CommandResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: builtins.str,
                 content: builtins.str,
                 content_type: builtins.str,
                 name: builtins.str,
                 always_run: Optional[builtins.bool] = None,
                 apply_update_before: Optional[builtins.bool] = None,
                 enroll_intune_before: Optional[builtins.bool] = None,
                 install1_p_app_before: Optional[builtins.bool] = None,
                 max_run_time: Optional[builtins.int] = None,
                 post_upgrade: Optional[builtins.bool] = None,
                 pre_upgrade: Optional[builtins.bool] = None,
                 restart_after: Optional[builtins.bool] = None,
                 run_as_interactive: Optional[builtins.bool] = None,
                 run_elevated: Optional[builtins.bool] = None):
        """
        The command used in the test
        :param builtins.str action: The action of the command.
        :param builtins.str content: The content of the command. The content depends on source type.
        :param builtins.str content_type: The type of command content.
        :param builtins.str name: The name of the command.
        :param builtins.bool always_run: Specifies whether to run the command even if a previous command is failed.
        :param builtins.bool apply_update_before: Specifies whether to apply update before the command.
        :param builtins.bool enroll_intune_before: Specifies whether to enroll Intune before the command.
        :param builtins.bool install1_p_app_before: Specifies whether to install first party applications before running the command.
        :param builtins.int max_run_time: Specifies the max run time of the command.
        :param builtins.bool post_upgrade: Specifies whether the command is assigned to be executed after in-place upgrade.
        :param builtins.bool pre_upgrade: Specifies whether the command is assigned to be executed before in-place upgrade.
        :param builtins.bool restart_after: Specifies whether to restart the VM after the command executed.
        :param builtins.bool run_as_interactive: Specifies whether to run the command in interactive mode.
        :param builtins.bool run_elevated: Specifies whether to run the command as administrator.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "name", name)
        if always_run is not None:
            pulumi.set(__self__, "always_run", always_run)
        if apply_update_before is not None:
            pulumi.set(__self__, "apply_update_before", apply_update_before)
        if enroll_intune_before is not None:
            pulumi.set(__self__, "enroll_intune_before", enroll_intune_before)
        if install1_p_app_before is not None:
            pulumi.set(__self__, "install1_p_app_before", install1_p_app_before)
        if max_run_time is not None:
            pulumi.set(__self__, "max_run_time", max_run_time)
        if post_upgrade is not None:
            pulumi.set(__self__, "post_upgrade", post_upgrade)
        if pre_upgrade is not None:
            pulumi.set(__self__, "pre_upgrade", pre_upgrade)
        if restart_after is not None:
            pulumi.set(__self__, "restart_after", restart_after)
        if run_as_interactive is not None:
            pulumi.set(__self__, "run_as_interactive", run_as_interactive)
        if run_elevated is not None:
            pulumi.set(__self__, "run_elevated", run_elevated)

    @property
    @pulumi.getter
    def action(self) -> builtins.str:
        """
        The action of the command.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def content(self) -> builtins.str:
        """
        The content of the command. The content depends on source type.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> builtins.str:
        """
        The type of command content.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the command.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="alwaysRun")
    def always_run(self) -> Optional[builtins.bool]:
        """
        Specifies whether to run the command even if a previous command is failed.
        """
        return pulumi.get(self, "always_run")

    @property
    @pulumi.getter(name="applyUpdateBefore")
    def apply_update_before(self) -> Optional[builtins.bool]:
        """
        Specifies whether to apply update before the command.
        """
        return pulumi.get(self, "apply_update_before")

    @property
    @pulumi.getter(name="enrollIntuneBefore")
    def enroll_intune_before(self) -> Optional[builtins.bool]:
        """
        Specifies whether to enroll Intune before the command.
        """
        return pulumi.get(self, "enroll_intune_before")

    @property
    @pulumi.getter(name="install1PAppBefore")
    def install1_p_app_before(self) -> Optional[builtins.bool]:
        """
        Specifies whether to install first party applications before running the command.
        """
        return pulumi.get(self, "install1_p_app_before")

    @property
    @pulumi.getter(name="maxRunTime")
    def max_run_time(self) -> Optional[builtins.int]:
        """
        Specifies the max run time of the command.
        """
        return pulumi.get(self, "max_run_time")

    @property
    @pulumi.getter(name="postUpgrade")
    def post_upgrade(self) -> Optional[builtins.bool]:
        """
        Specifies whether the command is assigned to be executed after in-place upgrade.
        """
        return pulumi.get(self, "post_upgrade")

    @property
    @pulumi.getter(name="preUpgrade")
    def pre_upgrade(self) -> Optional[builtins.bool]:
        """
        Specifies whether the command is assigned to be executed before in-place upgrade.
        """
        return pulumi.get(self, "pre_upgrade")

    @property
    @pulumi.getter(name="restartAfter")
    def restart_after(self) -> Optional[builtins.bool]:
        """
        Specifies whether to restart the VM after the command executed.
        """
        return pulumi.get(self, "restart_after")

    @property
    @pulumi.getter(name="runAsInteractive")
    def run_as_interactive(self) -> Optional[builtins.bool]:
        """
        Specifies whether to run the command in interactive mode.
        """
        return pulumi.get(self, "run_as_interactive")

    @property
    @pulumi.getter(name="runElevated")
    def run_elevated(self) -> Optional[builtins.bool]:
        """
        Specifies whether to run the command as administrator.
        """
        return pulumi.get(self, "run_elevated")


@pulumi.output_type
class DistributionGroupListReceiverValueResponse(dict):
    """
    The user object receiver value.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionGroups":
            suggest = "distribution_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DistributionGroupListReceiverValueResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DistributionGroupListReceiverValueResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DistributionGroupListReceiverValueResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_groups: Optional[Sequence[builtins.str]] = None):
        """
        The user object receiver value.
        :param Sequence[builtins.str] distribution_groups: The list of distribution groups.
        """
        if distribution_groups is not None:
            pulumi.set(__self__, "distribution_groups", distribution_groups)

    @property
    @pulumi.getter(name="distributionGroups")
    def distribution_groups(self) -> Optional[Sequence[builtins.str]]:
        """
        The list of distribution groups.
        """
        return pulumi.get(self, "distribution_groups")


@pulumi.output_type
class DraftPackageIntuneAppMetadataItemResponse(dict):
    """
    The Metadata of a single Intune App.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appName":
            suggest = "app_name"
        elif key == "createDate":
            suggest = "create_date"
        elif key == "dependencyIds":
            suggest = "dependency_ids"
        elif key == "dependentAppCount":
            suggest = "dependent_app_count"
        elif key == "expectedExitCodes":
            suggest = "expected_exit_codes"
        elif key == "installCommand":
            suggest = "install_command"
        elif key == "lastProcessed":
            suggest = "last_processed"
        elif key == "minimumSupportedOS":
            suggest = "minimum_supported_os"
        elif key == "setupFile":
            suggest = "setup_file"
        elif key == "uninstallCommand":
            suggest = "uninstall_command"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DraftPackageIntuneAppMetadataItemResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DraftPackageIntuneAppMetadataItemResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DraftPackageIntuneAppMetadataItemResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[builtins.str] = None,
                 app_name: Optional[builtins.str] = None,
                 create_date: Optional[builtins.str] = None,
                 dependency_ids: Optional[Sequence[builtins.str]] = None,
                 dependent_app_count: Optional[builtins.int] = None,
                 description: Optional[builtins.str] = None,
                 expected_exit_codes: Optional[Sequence[builtins.str]] = None,
                 install_command: Optional[builtins.str] = None,
                 last_processed: Optional[builtins.float] = None,
                 minimum_supported_os: Optional[builtins.str] = None,
                 owner: Optional[builtins.str] = None,
                 publisher: Optional[builtins.str] = None,
                 setup_file: Optional[builtins.str] = None,
                 status: Optional[builtins.str] = None,
                 uninstall_command: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        The Metadata of a single Intune App.
        :param builtins.str app_id: Intune app id.
        :param builtins.str app_name: Intune app name.
        :param builtins.str create_date: Creation date of the app.
        :param Sequence[builtins.str] dependency_ids: Ids of dependency apps.
        :param builtins.int dependent_app_count: Count of dependency apps.
        :param builtins.str description: Description of the app.
        :param Sequence[builtins.str] expected_exit_codes: Expected exit codes returned from Intune App.
        :param builtins.str install_command: Install command.
        :param builtins.float last_processed: last processed time tickets.
        :param builtins.str minimum_supported_os: Minimum supported OS. The OS version must be greater than this version to run this app.
        :param builtins.str owner: Owner of the app.
        :param builtins.str publisher: Publisher of the app.
        :param builtins.str setup_file: Setup file path.
        :param builtins.str status: Extract status.
        :param builtins.str uninstall_command: Uninstall command.
        :param builtins.str version: Intune app version.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_name is not None:
            pulumi.set(__self__, "app_name", app_name)
        if create_date is not None:
            pulumi.set(__self__, "create_date", create_date)
        if dependency_ids is not None:
            pulumi.set(__self__, "dependency_ids", dependency_ids)
        if dependent_app_count is not None:
            pulumi.set(__self__, "dependent_app_count", dependent_app_count)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expected_exit_codes is not None:
            pulumi.set(__self__, "expected_exit_codes", expected_exit_codes)
        if install_command is not None:
            pulumi.set(__self__, "install_command", install_command)
        if last_processed is not None:
            pulumi.set(__self__, "last_processed", last_processed)
        if minimum_supported_os is not None:
            pulumi.set(__self__, "minimum_supported_os", minimum_supported_os)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if publisher is not None:
            pulumi.set(__self__, "publisher", publisher)
        if setup_file is not None:
            pulumi.set(__self__, "setup_file", setup_file)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if uninstall_command is not None:
            pulumi.set(__self__, "uninstall_command", uninstall_command)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[builtins.str]:
        """
        Intune app id.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> Optional[builtins.str]:
        """
        Intune app name.
        """
        return pulumi.get(self, "app_name")

    @property
    @pulumi.getter(name="createDate")
    def create_date(self) -> Optional[builtins.str]:
        """
        Creation date of the app.
        """
        return pulumi.get(self, "create_date")

    @property
    @pulumi.getter(name="dependencyIds")
    def dependency_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        Ids of dependency apps.
        """
        return pulumi.get(self, "dependency_ids")

    @property
    @pulumi.getter(name="dependentAppCount")
    def dependent_app_count(self) -> Optional[builtins.int]:
        """
        Count of dependency apps.
        """
        return pulumi.get(self, "dependent_app_count")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the app.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="expectedExitCodes")
    def expected_exit_codes(self) -> Optional[Sequence[builtins.str]]:
        """
        Expected exit codes returned from Intune App.
        """
        return pulumi.get(self, "expected_exit_codes")

    @property
    @pulumi.getter(name="installCommand")
    def install_command(self) -> Optional[builtins.str]:
        """
        Install command.
        """
        return pulumi.get(self, "install_command")

    @property
    @pulumi.getter(name="lastProcessed")
    def last_processed(self) -> Optional[builtins.float]:
        """
        last processed time tickets.
        """
        return pulumi.get(self, "last_processed")

    @property
    @pulumi.getter(name="minimumSupportedOS")
    def minimum_supported_os(self) -> Optional[builtins.str]:
        """
        Minimum supported OS. The OS version must be greater than this version to run this app.
        """
        return pulumi.get(self, "minimum_supported_os")

    @property
    @pulumi.getter
    def owner(self) -> Optional[builtins.str]:
        """
        Owner of the app.
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter
    def publisher(self) -> Optional[builtins.str]:
        """
        Publisher of the app.
        """
        return pulumi.get(self, "publisher")

    @property
    @pulumi.getter(name="setupFile")
    def setup_file(self) -> Optional[builtins.str]:
        """
        Setup file path.
        """
        return pulumi.get(self, "setup_file")

    @property
    @pulumi.getter
    def status(self) -> Optional[builtins.str]:
        """
        Extract status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="uninstallCommand")
    def uninstall_command(self) -> Optional[builtins.str]:
        """
        Uninstall command.
        """
        return pulumi.get(self, "uninstall_command")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Intune app version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DraftPackageIntuneAppMetadataResponse(dict):
    """
    The metadata of Intune app(s) used for generation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intuneApp":
            suggest = "intune_app"
        elif key == "intuneAppDependencies":
            suggest = "intune_app_dependencies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DraftPackageIntuneAppMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DraftPackageIntuneAppMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DraftPackageIntuneAppMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 intune_app: Optional['outputs.DraftPackageIntuneAppMetadataItemResponse'] = None,
                 intune_app_dependencies: Optional[Sequence['outputs.DraftPackageIntuneAppMetadataItemResponse']] = None):
        """
        The metadata of Intune app(s) used for generation.
        :param 'DraftPackageIntuneAppMetadataItemResponse' intune_app: The Metadata of the Intune App through intunewin file uploading.
        :param Sequence['DraftPackageIntuneAppMetadataItemResponse'] intune_app_dependencies: The Metadata of dependencies of the Intune App through intunewin file uploading.
        """
        if intune_app is not None:
            pulumi.set(__self__, "intune_app", intune_app)
        if intune_app_dependencies is not None:
            pulumi.set(__self__, "intune_app_dependencies", intune_app_dependencies)

    @property
    @pulumi.getter(name="intuneApp")
    def intune_app(self) -> Optional['outputs.DraftPackageIntuneAppMetadataItemResponse']:
        """
        The Metadata of the Intune App through intunewin file uploading.
        """
        return pulumi.get(self, "intune_app")

    @property
    @pulumi.getter(name="intuneAppDependencies")
    def intune_app_dependencies(self) -> Optional[Sequence['outputs.DraftPackageIntuneAppMetadataItemResponse']]:
        """
        The Metadata of dependencies of the Intune App through intunewin file uploading.
        """
        return pulumi.get(self, "intune_app_dependencies")


@pulumi.output_type
class EnrolledIntuneAppResponse(dict):
    """
    Metadata of the enrolled Intune app.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appName":
            suggest = "app_name"
        elif key == "expectedInstallationPath":
            suggest = "expected_installation_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnrolledIntuneAppResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnrolledIntuneAppResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnrolledIntuneAppResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: builtins.str,
                 app_name: builtins.str,
                 expected_installation_path: builtins.str):
        """
        Metadata of the enrolled Intune app.
        :param builtins.str app_id: Intune app id.
        :param builtins.str app_name: Intune app name.
        :param builtins.str expected_installation_path: Intune app expected installation path.
        """
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "app_name", app_name)
        pulumi.set(__self__, "expected_installation_path", expected_installation_path)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> builtins.str:
        """
        Intune app id.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> builtins.str:
        """
        Intune app name.
        """
        return pulumi.get(self, "app_name")

    @property
    @pulumi.getter(name="expectedInstallationPath")
    def expected_installation_path(self) -> builtins.str:
        """
        Intune app expected installation path.
        """
        return pulumi.get(self, "expected_installation_path")


@pulumi.output_type
class FirstPartyAppDefinitionResponse(dict):
    """
    Properties of the definition of a first party application of the Test Base package.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interopExecutionMode":
            suggest = "interop_execution_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirstPartyAppDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirstPartyAppDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirstPartyAppDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 architecture: Optional[builtins.str] = None,
                 channel: Optional[builtins.str] = None,
                 interop_execution_mode: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 ring: Optional[builtins.str] = None):
        """
        Properties of the definition of a first party application of the Test Base package.
        :param builtins.str architecture: The architecture of a first party application of a Test Base Account.
        :param builtins.str channel: The channel info of a first party application of a Test Base Account.
        :param builtins.str interop_execution_mode: Specifies how the first party applications should be inter-operated with user's application.
        :param builtins.str name: The media name of a first party application of a Test Base Account.
        :param builtins.str ring: The ring info of a first party application of a Test Base Account.
        """
        if architecture is not None:
            pulumi.set(__self__, "architecture", architecture)
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if interop_execution_mode is None:
            interop_execution_mode = 'firstPartyAppWithTests'
        if interop_execution_mode is not None:
            pulumi.set(__self__, "interop_execution_mode", interop_execution_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ring is not None:
            pulumi.set(__self__, "ring", ring)

    @property
    @pulumi.getter
    def architecture(self) -> Optional[builtins.str]:
        """
        The architecture of a first party application of a Test Base Account.
        """
        return pulumi.get(self, "architecture")

    @property
    @pulumi.getter
    def channel(self) -> Optional[builtins.str]:
        """
        The channel info of a first party application of a Test Base Account.
        """
        return pulumi.get(self, "channel")

    @property
    @pulumi.getter(name="interopExecutionMode")
    def interop_execution_mode(self) -> Optional[builtins.str]:
        """
        Specifies how the first party applications should be inter-operated with user's application.
        """
        return pulumi.get(self, "interop_execution_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        The media name of a first party application of a Test Base Account.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ring(self) -> Optional[builtins.str]:
        """
        The ring info of a first party application of a Test Base Account.
        """
        return pulumi.get(self, "ring")


@pulumi.output_type
class GalleryAppDefinitionResponse(dict):
    """
    Properties of the definition of a gallery application used in Test Base package.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skuId":
            suggest = "sku_id"
        elif key == "isConsented":
            suggest = "is_consented"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GalleryAppDefinitionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GalleryAppDefinitionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GalleryAppDefinitionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sku_id: builtins.str,
                 is_consented: Optional[builtins.bool] = None):
        """
        Properties of the definition of a gallery application used in Test Base package.
        :param builtins.str sku_id: The SKU id of the gallery application.
        :param builtins.bool is_consented: Whether the disclaimer of the gallery application is accepted.
        """
        pulumi.set(__self__, "sku_id", sku_id)
        if is_consented is None:
            is_consented = False
        if is_consented is not None:
            pulumi.set(__self__, "is_consented", is_consented)

    @property
    @pulumi.getter(name="skuId")
    def sku_id(self) -> builtins.str:
        """
        The SKU id of the gallery application.
        """
        return pulumi.get(self, "sku_id")

    @property
    @pulumi.getter(name="isConsented")
    def is_consented(self) -> Optional[builtins.bool]:
        """
        Whether the disclaimer of the gallery application is accepted.
        """
        return pulumi.get(self, "is_consented")


@pulumi.output_type
class HighlightedFileResponse(dict):
    """
    The information of a highlighted file that user should pay attention to.
    """
    def __init__(__self__, *,
                 path: builtins.str,
                 sections: Optional[Sequence[builtins.str]] = None,
                 visited: Optional[builtins.bool] = None):
        """
        The information of a highlighted file that user should pay attention to.
        :param builtins.str path: The path of the highlighted file.
        :param Sequence[builtins.str] sections: The name of sections to highlight.
        :param builtins.bool visited: A flag to save whether this file is viewed by user.
        """
        pulumi.set(__self__, "path", path)
        if sections is not None:
            pulumi.set(__self__, "sections", sections)
        if visited is None:
            visited = False
        if visited is not None:
            pulumi.set(__self__, "visited", visited)

    @property
    @pulumi.getter
    def path(self) -> builtins.str:
        """
        The path of the highlighted file.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def sections(self) -> Optional[Sequence[builtins.str]]:
        """
        The name of sections to highlight.
        """
        return pulumi.get(self, "sections")

    @property
    @pulumi.getter
    def visited(self) -> Optional[builtins.bool]:
        """
        A flag to save whether this file is viewed by user.
        """
        return pulumi.get(self, "visited")


@pulumi.output_type
class ImageValidationResultsResponse(dict):
    """
    The image validation result.
    """
    def __init__(__self__, *,
                 results: Optional[Sequence['outputs.VerificationResultResponse']] = None):
        """
        The image validation result.
        :param Sequence['VerificationResultResponse'] results: The validation results of the image.
        """
        if results is not None:
            pulumi.set(__self__, "results", results)

    @property
    @pulumi.getter
    def results(self) -> Optional[Sequence['outputs.VerificationResultResponse']]:
        """
        The validation results of the image.
        """
        return pulumi.get(self, "results")


@pulumi.output_type
class InplaceUpgradeOSInfoResponse(dict):
    """
    Specifies the baseline os and target os for in-place upgrade tests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baselineOS":
            suggest = "baseline_os"
        elif key == "targetOS":
            suggest = "target_os"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InplaceUpgradeOSInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InplaceUpgradeOSInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InplaceUpgradeOSInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 baseline_os: Optional['outputs.OsPropertiesResponse'] = None,
                 target_os: Optional[builtins.str] = None):
        """
        Specifies the baseline os and target os for in-place upgrade tests.
        :param 'OsPropertiesResponse' baseline_os: Specifies the baseline os for in-place upgrade tests.
        :param builtins.str target_os: Specifies the target os for in-place upgrade tests.
        """
        if baseline_os is not None:
            pulumi.set(__self__, "baseline_os", baseline_os)
        if target_os is not None:
            pulumi.set(__self__, "target_os", target_os)

    @property
    @pulumi.getter(name="baselineOS")
    def baseline_os(self) -> Optional['outputs.OsPropertiesResponse']:
        """
        Specifies the baseline os for in-place upgrade tests.
        """
        return pulumi.get(self, "baseline_os")

    @property
    @pulumi.getter(name="targetOS")
    def target_os(self) -> Optional[builtins.str]:
        """
        Specifies the target os for in-place upgrade tests.
        """
        return pulumi.get(self, "target_os")


@pulumi.output_type
class IntuneEnrollmentMetadataResponse(dict):
    """
    The metadata of Intune enrollment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appList":
            suggest = "app_list"
        elif key == "credentialId":
            suggest = "credential_id"
        elif key == "expectedDeploymentDurationInMinute":
            suggest = "expected_deployment_duration_in_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntuneEnrollmentMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntuneEnrollmentMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntuneEnrollmentMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_list: Optional[Sequence['outputs.EnrolledIntuneAppResponse']] = None,
                 credential_id: Optional[builtins.str] = None,
                 expected_deployment_duration_in_minute: Optional[builtins.int] = None):
        """
        The metadata of Intune enrollment.
        :param Sequence['EnrolledIntuneAppResponse'] app_list: The enrolled Intune apps.
        :param builtins.str credential_id: The id of the Intune enrollment credential.
        :param builtins.int expected_deployment_duration_in_minute: The expected duration of Intune applications and policies deployment.
        """
        if app_list is not None:
            pulumi.set(__self__, "app_list", app_list)
        if credential_id is not None:
            pulumi.set(__self__, "credential_id", credential_id)
        if expected_deployment_duration_in_minute is not None:
            pulumi.set(__self__, "expected_deployment_duration_in_minute", expected_deployment_duration_in_minute)

    @property
    @pulumi.getter(name="appList")
    def app_list(self) -> Optional[Sequence['outputs.EnrolledIntuneAppResponse']]:
        """
        The enrolled Intune apps.
        """
        return pulumi.get(self, "app_list")

    @property
    @pulumi.getter(name="credentialId")
    def credential_id(self) -> Optional[builtins.str]:
        """
        The id of the Intune enrollment credential.
        """
        return pulumi.get(self, "credential_id")

    @property
    @pulumi.getter(name="expectedDeploymentDurationInMinute")
    def expected_deployment_duration_in_minute(self) -> Optional[builtins.int]:
        """
        The expected duration of Intune applications and policies deployment.
        """
        return pulumi.get(self, "expected_deployment_duration_in_minute")


@pulumi.output_type
class NotificationEventReceiverResponse(dict):
    """
    A notification event receivers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "receiverType":
            suggest = "receiver_type"
        elif key == "receiverValue":
            suggest = "receiver_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationEventReceiverResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationEventReceiverResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationEventReceiverResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 receiver_type: Optional[builtins.str] = None,
                 receiver_value: Optional['outputs.NotificationReceiverValueResponse'] = None):
        """
        A notification event receivers.
        :param builtins.str receiver_type: The type of the notification event receiver.
        :param 'NotificationReceiverValueResponse' receiver_value: The notification event receiver value.
        """
        if receiver_type is not None:
            pulumi.set(__self__, "receiver_type", receiver_type)
        if receiver_value is not None:
            pulumi.set(__self__, "receiver_value", receiver_value)

    @property
    @pulumi.getter(name="receiverType")
    def receiver_type(self) -> Optional[builtins.str]:
        """
        The type of the notification event receiver.
        """
        return pulumi.get(self, "receiver_type")

    @property
    @pulumi.getter(name="receiverValue")
    def receiver_value(self) -> Optional['outputs.NotificationReceiverValueResponse']:
        """
        The notification event receiver value.
        """
        return pulumi.get(self, "receiver_value")


@pulumi.output_type
class NotificationReceiverValueResponse(dict):
    """
    A notification event receiver value.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributionGroupListReceiverValue":
            suggest = "distribution_group_list_receiver_value"
        elif key == "subscriptionReceiverValue":
            suggest = "subscription_receiver_value"
        elif key == "userObjectReceiverValue":
            suggest = "user_object_receiver_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationReceiverValueResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationReceiverValueResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationReceiverValueResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distribution_group_list_receiver_value: Optional['outputs.DistributionGroupListReceiverValueResponse'] = None,
                 subscription_receiver_value: Optional['outputs.SubscriptionReceiverValueResponse'] = None,
                 user_object_receiver_value: Optional['outputs.UserObjectReceiverValueResponse'] = None):
        """
        A notification event receiver value.
        :param 'DistributionGroupListReceiverValueResponse' distribution_group_list_receiver_value: The user object receiver value.
        :param 'SubscriptionReceiverValueResponse' subscription_receiver_value: The user object receiver value.
        :param 'UserObjectReceiverValueResponse' user_object_receiver_value: The user object receiver value.
        """
        if distribution_group_list_receiver_value is not None:
            pulumi.set(__self__, "distribution_group_list_receiver_value", distribution_group_list_receiver_value)
        if subscription_receiver_value is not None:
            pulumi.set(__self__, "subscription_receiver_value", subscription_receiver_value)
        if user_object_receiver_value is not None:
            pulumi.set(__self__, "user_object_receiver_value", user_object_receiver_value)

    @property
    @pulumi.getter(name="distributionGroupListReceiverValue")
    def distribution_group_list_receiver_value(self) -> Optional['outputs.DistributionGroupListReceiverValueResponse']:
        """
        The user object receiver value.
        """
        return pulumi.get(self, "distribution_group_list_receiver_value")

    @property
    @pulumi.getter(name="subscriptionReceiverValue")
    def subscription_receiver_value(self) -> Optional['outputs.SubscriptionReceiverValueResponse']:
        """
        The user object receiver value.
        """
        return pulumi.get(self, "subscription_receiver_value")

    @property
    @pulumi.getter(name="userObjectReceiverValue")
    def user_object_receiver_value(self) -> Optional['outputs.UserObjectReceiverValueResponse']:
        """
        The user object receiver value.
        """
        return pulumi.get(self, "user_object_receiver_value")


@pulumi.output_type
class OsPropertiesResponse(dict):
    """
    The properties of an operating system.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customImageDisplayName":
            suggest = "custom_image_display_name"
        elif key == "customImageId":
            suggest = "custom_image_id"
        elif key == "osName":
            suggest = "os_name"
        elif key == "releaseProperties":
            suggest = "release_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OsPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OsPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OsPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_image_display_name: builtins.str,
                 custom_image_id: Optional[builtins.str] = None,
                 os_name: Optional[builtins.str] = None,
                 release_properties: Optional['outputs.ReleasePropertiesResponse'] = None):
        """
        The properties of an operating system.
        :param builtins.str custom_image_display_name: The name of the custom image resource.
        :param builtins.str custom_image_id: Specify the referenced Test Base Custom Image Id if available.
        :param builtins.str os_name: The name of the OS.
        :param 'ReleasePropertiesResponse' release_properties: The properties of the OS release.
        """
        pulumi.set(__self__, "custom_image_display_name", custom_image_display_name)
        if custom_image_id is not None:
            pulumi.set(__self__, "custom_image_id", custom_image_id)
        if os_name is not None:
            pulumi.set(__self__, "os_name", os_name)
        if release_properties is not None:
            pulumi.set(__self__, "release_properties", release_properties)

    @property
    @pulumi.getter(name="customImageDisplayName")
    def custom_image_display_name(self) -> builtins.str:
        """
        The name of the custom image resource.
        """
        return pulumi.get(self, "custom_image_display_name")

    @property
    @pulumi.getter(name="customImageId")
    def custom_image_id(self) -> Optional[builtins.str]:
        """
        Specify the referenced Test Base Custom Image Id if available.
        """
        return pulumi.get(self, "custom_image_id")

    @property
    @pulumi.getter(name="osName")
    def os_name(self) -> Optional[builtins.str]:
        """
        The name of the OS.
        """
        return pulumi.get(self, "os_name")

    @property
    @pulumi.getter(name="releaseProperties")
    def release_properties(self) -> Optional['outputs.ReleasePropertiesResponse']:
        """
        The properties of the OS release.
        """
        return pulumi.get(self, "release_properties")


@pulumi.output_type
class PackageValidationResultResponse(dict):
    """
    The validation results. There's validation on package when it's created or updated.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isValid":
            suggest = "is_valid"
        elif key == "validationName":
            suggest = "validation_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PackageValidationResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PackageValidationResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PackageValidationResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 errors: Sequence[builtins.str],
                 is_valid: builtins.bool,
                 validation_name: builtins.str):
        """
        The validation results. There's validation on package when it's created or updated.
        :param Sequence[builtins.str] errors: Error information.
        :param builtins.bool is_valid: Indicates whether the package passed the validation.
        :param builtins.str validation_name: Validation name.
        """
        pulumi.set(__self__, "errors", errors)
        pulumi.set(__self__, "is_valid", is_valid)
        pulumi.set(__self__, "validation_name", validation_name)

    @property
    @pulumi.getter
    def errors(self) -> Sequence[builtins.str]:
        """
        Error information.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter(name="isValid")
    def is_valid(self) -> builtins.bool:
        """
        Indicates whether the package passed the validation.
        """
        return pulumi.get(self, "is_valid")

    @property
    @pulumi.getter(name="validationName")
    def validation_name(self) -> builtins.str:
        """
        Validation name.
        """
        return pulumi.get(self, "validation_name")


@pulumi.output_type
class PreReleaseAccessRequestSpecResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "companyWebsite":
            suggest = "company_website"
        elif key == "countryAndRegion":
            suggest = "country_and_region"
        elif key == "organizationName":
            suggest = "organization_name"
        elif key == "stateOrProvince":
            suggest = "state_or_province"
        elif key == "streetAddress":
            suggest = "street_address"
        elif key == "zipCode":
            suggest = "zip_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PreReleaseAccessRequestSpecResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PreReleaseAccessRequestSpecResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PreReleaseAccessRequestSpecResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 city: Optional[builtins.str] = None,
                 company_website: Optional[builtins.str] = None,
                 country_and_region: Optional[builtins.str] = None,
                 email: Optional[builtins.str] = None,
                 engagements: Optional[Sequence[builtins.str]] = None,
                 organization_name: Optional[builtins.str] = None,
                 state_or_province: Optional[builtins.str] = None,
                 street_address: Optional[builtins.str] = None,
                 zip_code: Optional[builtins.str] = None):
        if city is not None:
            pulumi.set(__self__, "city", city)
        if company_website is not None:
            pulumi.set(__self__, "company_website", company_website)
        if country_and_region is not None:
            pulumi.set(__self__, "country_and_region", country_and_region)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if engagements is not None:
            pulumi.set(__self__, "engagements", engagements)
        if organization_name is not None:
            pulumi.set(__self__, "organization_name", organization_name)
        if state_or_province is not None:
            pulumi.set(__self__, "state_or_province", state_or_province)
        if street_address is not None:
            pulumi.set(__self__, "street_address", street_address)
        if zip_code is not None:
            pulumi.set(__self__, "zip_code", zip_code)

    @property
    @pulumi.getter
    def city(self) -> Optional[builtins.str]:
        return pulumi.get(self, "city")

    @property
    @pulumi.getter(name="companyWebsite")
    def company_website(self) -> Optional[builtins.str]:
        return pulumi.get(self, "company_website")

    @property
    @pulumi.getter(name="countryAndRegion")
    def country_and_region(self) -> Optional[builtins.str]:
        return pulumi.get(self, "country_and_region")

    @property
    @pulumi.getter
    def email(self) -> Optional[builtins.str]:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def engagements(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "engagements")

    @property
    @pulumi.getter(name="organizationName")
    def organization_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "organization_name")

    @property
    @pulumi.getter(name="stateOrProvince")
    def state_or_province(self) -> Optional[builtins.str]:
        return pulumi.get(self, "state_or_province")

    @property
    @pulumi.getter(name="streetAddress")
    def street_address(self) -> Optional[builtins.str]:
        return pulumi.get(self, "street_address")

    @property
    @pulumi.getter(name="zipCode")
    def zip_code(self) -> Optional[builtins.str]:
        return pulumi.get(self, "zip_code")


@pulumi.output_type
class ReleasePropertiesResponse(dict):
    """
    The properties of an operating system release.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildNumber":
            suggest = "build_number"
        elif key == "buildRevision":
            suggest = "build_revision"
        elif key == "releaseName":
            suggest = "release_name"
        elif key == "releaseVersionDate":
            suggest = "release_version_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReleasePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReleasePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReleasePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 build_number: Optional[builtins.str] = None,
                 build_revision: Optional[builtins.str] = None,
                 release_name: Optional[builtins.str] = None,
                 release_version_date: Optional[builtins.str] = None):
        """
        The properties of an operating system release.
        :param builtins.str build_number: The build number of the OS release.
        :param builtins.str build_revision: The build revision of the OS release.
        :param builtins.str release_name: The name of the OS release.
        :param builtins.str release_version_date: The release version date of the OS release.
        """
        if build_number is not None:
            pulumi.set(__self__, "build_number", build_number)
        if build_revision is not None:
            pulumi.set(__self__, "build_revision", build_revision)
        if release_name is not None:
            pulumi.set(__self__, "release_name", release_name)
        if release_version_date is not None:
            pulumi.set(__self__, "release_version_date", release_version_date)

    @property
    @pulumi.getter(name="buildNumber")
    def build_number(self) -> Optional[builtins.str]:
        """
        The build number of the OS release.
        """
        return pulumi.get(self, "build_number")

    @property
    @pulumi.getter(name="buildRevision")
    def build_revision(self) -> Optional[builtins.str]:
        """
        The build revision of the OS release.
        """
        return pulumi.get(self, "build_revision")

    @property
    @pulumi.getter(name="releaseName")
    def release_name(self) -> Optional[builtins.str]:
        """
        The name of the OS release.
        """
        return pulumi.get(self, "release_name")

    @property
    @pulumi.getter(name="releaseVersionDate")
    def release_version_date(self) -> Optional[builtins.str]:
        """
        The release version date of the OS release.
        """
        return pulumi.get(self, "release_version_date")


@pulumi.output_type
class SubscriptionReceiverValueResponse(dict):
    """
    The subscription role receiver value.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "subscriptionName":
            suggest = "subscription_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionReceiverValueResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionReceiverValueResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionReceiverValueResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role: Optional[builtins.str] = None,
                 subscription_id: Optional[builtins.str] = None,
                 subscription_name: Optional[builtins.str] = None):
        """
        The subscription role receiver value.
        :param builtins.str role: The role of the notification receiver.
        :param builtins.str subscription_id: The subscription id of the notification receiver.
        :param builtins.str subscription_name: The subscription name of the notification receiver.
        """
        if role is not None:
            pulumi.set(__self__, "role", role)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if subscription_name is not None:
            pulumi.set(__self__, "subscription_name", subscription_name)

    @property
    @pulumi.getter
    def role(self) -> Optional[builtins.str]:
        """
        The role of the notification receiver.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[builtins.str]:
        """
        The subscription id of the notification receiver.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> Optional[builtins.str]:
        """
        The subscription name of the notification receiver.
        """
        return pulumi.get(self, "subscription_name")


@pulumi.output_type
class SystemAssignedServiceIdentityResponse(dict):
    """
    Managed service identity (either system assigned, or none)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemAssignedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemAssignedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemAssignedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: builtins.str,
                 tenant_id: builtins.str,
                 type: builtins.str):
        """
        Managed service identity (either system assigned, or none)
        :param builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param builtins.str type: Type of managed service identity (either system assigned, or none).
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of managed service identity (either system assigned, or none).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[builtins.str] = None,
                 created_by: Optional[builtins.str] = None,
                 created_by_type: Optional[builtins.str] = None,
                 last_modified_at: Optional[builtins.str] = None,
                 last_modified_by: Optional[builtins.str] = None,
                 last_modified_by_type: Optional[builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param builtins.str created_at: The timestamp of resource creation (UTC).
        :param builtins.str created_by: The identity that created the resource.
        :param builtins.str created_by_type: The type of identity that created the resource.
        :param builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param builtins.str last_modified_by: The identity that last modified the resource.
        :param builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TabStateResponse(dict):
    """
    Specifies current state of tabs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentTab":
            suggest = "current_tab"
        elif key == "visitedTabs":
            suggest = "visited_tabs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TabStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TabStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TabStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 current_tab: Optional[builtins.str] = None,
                 visited_tabs: Optional[Sequence[builtins.str]] = None):
        """
        Specifies current state of tabs.
        :param builtins.str current_tab: Current tab.
        :param Sequence[builtins.str] visited_tabs: visited tabs.
        """
        if current_tab is not None:
            pulumi.set(__self__, "current_tab", current_tab)
        if visited_tabs is not None:
            pulumi.set(__self__, "visited_tabs", visited_tabs)

    @property
    @pulumi.getter(name="currentTab")
    def current_tab(self) -> Optional[builtins.str]:
        """
        Current tab.
        """
        return pulumi.get(self, "current_tab")

    @property
    @pulumi.getter(name="visitedTabs")
    def visited_tabs(self) -> Optional[Sequence[builtins.str]]:
        """
        visited tabs.
        """
        return pulumi.get(self, "visited_tabs")


@pulumi.output_type
class TargetOSInfoResponse(dict):
    """
    The information of the target OS to be tested.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "osUpdateType":
            suggest = "os_update_type"
        elif key == "baselineOSs":
            suggest = "baseline_oss"
        elif key == "insiderChannelIds":
            suggest = "insider_channel_ids"
        elif key == "targetOSImageIds":
            suggest = "target_os_image_ids"
        elif key == "targetOSs":
            suggest = "target_oss"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetOSInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetOSInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetOSInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 os_update_type: builtins.str,
                 baseline_oss: Optional[Sequence[builtins.str]] = None,
                 insider_channel_ids: Optional[Sequence[builtins.str]] = None,
                 target_os_image_ids: Optional[Sequence[builtins.str]] = None,
                 target_oss: Optional[Sequence[builtins.str]] = None):
        """
        The information of the target OS to be tested.
        :param builtins.str os_update_type: Specifies the OS update type to test against, e.g., 'Security updates' or 'Feature updates'.
        :param Sequence[builtins.str] baseline_oss: Specifies the baseline OSs to be tested.
        :param Sequence[builtins.str] insider_channel_ids: Insider Channel Ids. Only used for feature update.
        :param Sequence[builtins.str] target_os_image_ids: Specifies the ids of the target OSs from Custom Images to be tested.
        :param Sequence[builtins.str] target_oss: Specifies the target OSs to be tested.
        """
        pulumi.set(__self__, "os_update_type", os_update_type)
        if baseline_oss is not None:
            pulumi.set(__self__, "baseline_oss", baseline_oss)
        if insider_channel_ids is not None:
            pulumi.set(__self__, "insider_channel_ids", insider_channel_ids)
        if target_os_image_ids is not None:
            pulumi.set(__self__, "target_os_image_ids", target_os_image_ids)
        if target_oss is not None:
            pulumi.set(__self__, "target_oss", target_oss)

    @property
    @pulumi.getter(name="osUpdateType")
    def os_update_type(self) -> builtins.str:
        """
        Specifies the OS update type to test against, e.g., 'Security updates' or 'Feature updates'.
        """
        return pulumi.get(self, "os_update_type")

    @property
    @pulumi.getter(name="baselineOSs")
    def baseline_oss(self) -> Optional[Sequence[builtins.str]]:
        """
        Specifies the baseline OSs to be tested.
        """
        return pulumi.get(self, "baseline_oss")

    @property
    @pulumi.getter(name="insiderChannelIds")
    def insider_channel_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        Insider Channel Ids. Only used for feature update.
        """
        return pulumi.get(self, "insider_channel_ids")

    @property
    @pulumi.getter(name="targetOSImageIds")
    def target_os_image_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        Specifies the ids of the target OSs from Custom Images to be tested.
        """
        return pulumi.get(self, "target_os_image_ids")

    @property
    @pulumi.getter(name="targetOSs")
    def target_oss(self) -> Optional[Sequence[builtins.str]]:
        """
        Specifies the target OSs to be tested.
        """
        return pulumi.get(self, "target_oss")


@pulumi.output_type
class TestBaseAccountSKUCapabilityResponse(dict):
    """
    Properties of the Test Base Account SKU Capability.
    """
    def __init__(__self__, *,
                 name: builtins.str,
                 value: builtins.str):
        """
        Properties of the Test Base Account SKU Capability.
        :param builtins.str name: An invariant to describe the feature, such as 'SLA'.
        :param builtins.str value: An invariant if the feature is measured by quantity, such as 99.9%.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        An invariant to describe the feature, such as 'SLA'.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        An invariant if the feature is measured by quantity, such as 99.9%.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TestBaseAccountSKUResponse(dict):
    """
    Describes a Test Base Account SKU.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TestBaseAccountSKUResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TestBaseAccountSKUResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TestBaseAccountSKUResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capabilities: Sequence['outputs.TestBaseAccountSKUCapabilityResponse'],
                 name: builtins.str,
                 tier: builtins.str,
                 locations: Optional[Sequence[builtins.str]] = None,
                 resource_type: Optional[builtins.str] = None):
        """
        Describes a Test Base Account SKU.
        :param Sequence['TestBaseAccountSKUCapabilityResponse'] capabilities: The capabilities of a SKU.
        :param builtins.str name: The name of the SKU. This is typically a letter + number code, such as B0 or S0.
        :param builtins.str tier: The tier of this particular SKU.
        :param Sequence[builtins.str] locations: The locations that the SKU is available.
        :param builtins.str resource_type: The type of resource the SKU applies to.
        """
        pulumi.set(__self__, "capabilities", capabilities)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tier", tier)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter
    def capabilities(self) -> Sequence['outputs.TestBaseAccountSKUCapabilityResponse']:
        """
        The capabilities of a SKU.
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the SKU. This is typically a letter + number code, such as B0 or S0.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tier(self) -> builtins.str:
        """
        The tier of this particular SKU.
        """
        return pulumi.get(self, "tier")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[builtins.str]]:
        """
        The locations that the SKU is available.
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[builtins.str]:
        """
        The type of resource the SKU applies to.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class TestResponse(dict):
    """
    The definition of a Test.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testType":
            suggest = "test_type"
        elif key == "validationResultId":
            suggest = "validation_result_id"
        elif key == "validationRunStatus":
            suggest = "validation_run_status"
        elif key == "isActive":
            suggest = "is_active"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TestResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TestResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TestResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commands: Sequence['outputs.CommandResponse'],
                 test_type: builtins.str,
                 validation_result_id: builtins.str,
                 validation_run_status: builtins.str,
                 is_active: Optional[builtins.bool] = None):
        """
        The definition of a Test.
        :param Sequence['CommandResponse'] commands: The commands used in the test.
        :param builtins.str test_type: The type of the test.
        :param builtins.str validation_result_id: Resource identifier of the validation test result.
        :param builtins.str validation_run_status: The status of the validation run of the package.
        :param builtins.bool is_active: Indicates if this test is active.It doesn't schedule test for not active Test.
        """
        pulumi.set(__self__, "commands", commands)
        pulumi.set(__self__, "test_type", test_type)
        pulumi.set(__self__, "validation_result_id", validation_result_id)
        pulumi.set(__self__, "validation_run_status", validation_run_status)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)

    @property
    @pulumi.getter
    def commands(self) -> Sequence['outputs.CommandResponse']:
        """
        The commands used in the test.
        """
        return pulumi.get(self, "commands")

    @property
    @pulumi.getter(name="testType")
    def test_type(self) -> builtins.str:
        """
        The type of the test.
        """
        return pulumi.get(self, "test_type")

    @property
    @pulumi.getter(name="validationResultId")
    def validation_result_id(self) -> builtins.str:
        """
        Resource identifier of the validation test result.
        """
        return pulumi.get(self, "validation_result_id")

    @property
    @pulumi.getter(name="validationRunStatus")
    def validation_run_status(self) -> builtins.str:
        """
        The status of the validation run of the package.
        """
        return pulumi.get(self, "validation_run_status")

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[builtins.bool]:
        """
        Indicates if this test is active.It doesn't schedule test for not active Test.
        """
        return pulumi.get(self, "is_active")


@pulumi.output_type
class UserObjectReceiverValueResponse(dict):
    """
    The user object receiver value.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userObjectIds":
            suggest = "user_object_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserObjectReceiverValueResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserObjectReceiverValueResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserObjectReceiverValueResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_object_ids: Optional[Sequence[builtins.str]] = None):
        """
        The user object receiver value.
        :param Sequence[builtins.str] user_object_ids: user object ids.
        """
        if user_object_ids is not None:
            pulumi.set(__self__, "user_object_ids", user_object_ids)

    @property
    @pulumi.getter(name="userObjectIds")
    def user_object_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        user object ids.
        """
        return pulumi.get(self, "user_object_ids")


@pulumi.output_type
class VerificationResultResponse(dict):
    """
    The detailed result of a validation or rule checking.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verificationName":
            suggest = "verification_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerificationResultResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerificationResultResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerificationResultResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 result: builtins.str,
                 message: Optional[builtins.str] = None,
                 verification_name: Optional[builtins.str] = None):
        """
        The detailed result of a validation or rule checking.
        :param builtins.str result: Indicates if the validation or rule checking is passed.
        :param builtins.str message: Message for clarification.
        :param builtins.str verification_name: The name of the verification rule.
        """
        pulumi.set(__self__, "result", result)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if verification_name is not None:
            pulumi.set(__self__, "verification_name", verification_name)

    @property
    @pulumi.getter
    def result(self) -> builtins.str:
        """
        Indicates if the validation or rule checking is passed.
        """
        return pulumi.get(self, "result")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Message for clarification.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="verificationName")
    def verification_name(self) -> Optional[builtins.str]:
        """
        The name of the verification rule.
        """
        return pulumi.get(self, "verification_name")


