# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AnalyticalStorageConfigurationArgs',
    'AnalyticalStorageConfigurationArgsDict',
    'ApiPropertiesArgs',
    'ApiPropertiesArgsDict',
    'AuthenticationMethodLdapPropertiesArgs',
    'AuthenticationMethodLdapPropertiesArgsDict',
    'AutoscaleSettingsArgs',
    'AutoscaleSettingsArgsDict',
    'BackupPolicyMigrationStateArgs',
    'BackupPolicyMigrationStateArgsDict',
    'CapabilityArgs',
    'CapabilityArgsDict',
    'CapacityArgs',
    'CapacityArgsDict',
    'CassandraErrorArgs',
    'CassandraErrorArgsDict',
    'CassandraKeyspaceResourceArgs',
    'CassandraKeyspaceResourceArgsDict',
    'CassandraPartitionKeyArgs',
    'CassandraPartitionKeyArgsDict',
    'CassandraSchemaArgs',
    'CassandraSchemaArgsDict',
    'CassandraTableResourceArgs',
    'CassandraTableResourceArgsDict',
    'CassandraViewResourceArgs',
    'CassandraViewResourceArgsDict',
    'CertificateArgs',
    'CertificateArgsDict',
    'ClientEncryptionIncludedPathArgs',
    'ClientEncryptionIncludedPathArgsDict',
    'ClientEncryptionPolicyArgs',
    'ClientEncryptionPolicyArgsDict',
    'ClusterKeyArgs',
    'ClusterKeyArgsDict',
    'ClusterResourcePropertiesArgs',
    'ClusterResourcePropertiesArgsDict',
    'ColumnArgs',
    'ColumnArgsDict',
    'CompositePathArgs',
    'CompositePathArgsDict',
    'ComputedPropertyArgs',
    'ComputedPropertyArgsDict',
    'ConflictResolutionPolicyArgs',
    'ConflictResolutionPolicyArgsDict',
    'ConsistencyPolicyArgs',
    'ConsistencyPolicyArgsDict',
    'ContainerPartitionKeyArgs',
    'ContainerPartitionKeyArgsDict',
    'ContinuousModeBackupPolicyArgs',
    'ContinuousModeBackupPolicyArgsDict',
    'ContinuousModePropertiesArgs',
    'ContinuousModePropertiesArgsDict',
    'CorsPolicyArgs',
    'CorsPolicyArgsDict',
    'CreateUpdateOptionsArgs',
    'CreateUpdateOptionsArgsDict',
    'DataCenterResourcePropertiesArgs',
    'DataCenterResourcePropertiesArgsDict',
    'DataTransferServiceResourceCreateUpdatePropertiesArgs',
    'DataTransferServiceResourceCreateUpdatePropertiesArgsDict',
    'DatabaseRestoreResourceArgs',
    'DatabaseRestoreResourceArgsDict',
    'ExcludedPathArgs',
    'ExcludedPathArgsDict',
    'FleetspacePropertiesThroughputPoolConfigurationArgs',
    'FleetspacePropertiesThroughputPoolConfigurationArgsDict',
    'GraphAPIComputeServiceResourceCreateUpdatePropertiesArgs',
    'GraphAPIComputeServiceResourceCreateUpdatePropertiesArgsDict',
    'GraphResourceArgs',
    'GraphResourceArgsDict',
    'GremlinDatabaseResourceArgs',
    'GremlinDatabaseResourceArgsDict',
    'GremlinDatabaseRestoreResourceArgs',
    'GremlinDatabaseRestoreResourceArgsDict',
    'GremlinGraphResourceArgs',
    'GremlinGraphResourceArgsDict',
    'IncludedPathArgs',
    'IncludedPathArgsDict',
    'IndexesArgs',
    'IndexesArgsDict',
    'IndexingPolicyArgs',
    'IndexingPolicyArgsDict',
    'IpAddressOrRangeArgs',
    'IpAddressOrRangeArgsDict',
    'LocationArgs',
    'LocationArgsDict',
    'ManagedCassandraManagedServiceIdentityArgs',
    'ManagedCassandraManagedServiceIdentityArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'MaterializedViewsBuilderServiceResourceCreateUpdatePropertiesArgs',
    'MaterializedViewsBuilderServiceResourceCreateUpdatePropertiesArgsDict',
    'MongoClusterRestoreParametersArgs',
    'MongoClusterRestoreParametersArgsDict',
    'MongoDBCollectionResourceArgs',
    'MongoDBCollectionResourceArgsDict',
    'MongoDBDatabaseResourceArgs',
    'MongoDBDatabaseResourceArgsDict',
    'MongoIndexKeysArgs',
    'MongoIndexKeysArgsDict',
    'MongoIndexOptionsArgs',
    'MongoIndexOptionsArgsDict',
    'MongoIndexArgs',
    'MongoIndexArgsDict',
    'NodeGroupSpecArgs',
    'NodeGroupSpecArgsDict',
    'PeriodicModeBackupPolicyArgs',
    'PeriodicModeBackupPolicyArgsDict',
    'PeriodicModePropertiesArgs',
    'PeriodicModePropertiesArgsDict',
    'PermissionArgs',
    'PermissionArgsDict',
    'PrivateEndpointPropertyArgs',
    'PrivateEndpointPropertyArgsDict',
    'PrivateLinkServiceConnectionStatePropertyArgs',
    'PrivateLinkServiceConnectionStatePropertyArgsDict',
    'PrivilegeResourceArgs',
    'PrivilegeResourceArgsDict',
    'PrivilegeArgs',
    'PrivilegeArgsDict',
    'ResourceRestoreParametersArgs',
    'ResourceRestoreParametersArgsDict',
    'RestoreParametersArgs',
    'RestoreParametersArgsDict',
    'RoleArgs',
    'RoleArgsDict',
    'SeedNodeArgs',
    'SeedNodeArgsDict',
    'SpatialSpecArgs',
    'SpatialSpecArgsDict',
    'SqlContainerResourceArgs',
    'SqlContainerResourceArgsDict',
    'SqlDatabaseResourceArgs',
    'SqlDatabaseResourceArgsDict',
    'SqlDedicatedGatewayServiceResourceCreateUpdatePropertiesArgs',
    'SqlDedicatedGatewayServiceResourceCreateUpdatePropertiesArgsDict',
    'SqlStoredProcedureResourceArgs',
    'SqlStoredProcedureResourceArgsDict',
    'SqlTriggerResourceArgs',
    'SqlTriggerResourceArgsDict',
    'SqlUserDefinedFunctionResourceArgs',
    'SqlUserDefinedFunctionResourceArgsDict',
    'TableResourceArgs',
    'TableResourceArgsDict',
    'UniqueKeyPolicyArgs',
    'UniqueKeyPolicyArgsDict',
    'UniqueKeyArgs',
    'UniqueKeyArgsDict',
    'VectorEmbeddingPolicyArgs',
    'VectorEmbeddingPolicyArgsDict',
    'VectorEmbeddingArgs',
    'VectorEmbeddingArgsDict',
    'VectorIndexArgs',
    'VectorIndexArgsDict',
    'VirtualNetworkRuleArgs',
    'VirtualNetworkRuleArgsDict',
]

MYPY = False

if not MYPY:
    class AnalyticalStorageConfigurationArgsDict(TypedDict):
        """
        Analytical storage specific properties.
        """
        schema_type: NotRequired[pulumi.Input[Union[builtins.str, 'AnalyticalStorageSchemaType']]]
        """
        Describes the types of schema for analytical storage.
        """
elif False:
    AnalyticalStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalyticalStorageConfigurationArgs:
    def __init__(__self__, *,
                 schema_type: Optional[pulumi.Input[Union[builtins.str, 'AnalyticalStorageSchemaType']]] = None):
        """
        Analytical storage specific properties.
        :param pulumi.Input[Union[builtins.str, 'AnalyticalStorageSchemaType']] schema_type: Describes the types of schema for analytical storage.
        """
        if schema_type is not None:
            pulumi.set(__self__, "schema_type", schema_type)

    @property
    @pulumi.getter(name="schemaType")
    def schema_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'AnalyticalStorageSchemaType']]]:
        """
        Describes the types of schema for analytical storage.
        """
        return pulumi.get(self, "schema_type")

    @schema_type.setter
    def schema_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'AnalyticalStorageSchemaType']]]):
        pulumi.set(self, "schema_type", value)


if not MYPY:
    class ApiPropertiesArgsDict(TypedDict):
        server_version: NotRequired[pulumi.Input[Union[builtins.str, 'ServerVersion']]]
        """
        Describes the version of the MongoDB account.
        """
elif False:
    ApiPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiPropertiesArgs:
    def __init__(__self__, *,
                 server_version: Optional[pulumi.Input[Union[builtins.str, 'ServerVersion']]] = None):
        """
        :param pulumi.Input[Union[builtins.str, 'ServerVersion']] server_version: Describes the version of the MongoDB account.
        """
        if server_version is not None:
            pulumi.set(__self__, "server_version", server_version)

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> Optional[pulumi.Input[Union[builtins.str, 'ServerVersion']]]:
        """
        Describes the version of the MongoDB account.
        """
        return pulumi.get(self, "server_version")

    @server_version.setter
    def server_version(self, value: Optional[pulumi.Input[Union[builtins.str, 'ServerVersion']]]):
        pulumi.set(self, "server_version", value)


if not MYPY:
    class AuthenticationMethodLdapPropertiesArgsDict(TypedDict):
        """
        Ldap authentication method properties. This feature is in preview.
        """
        connection_timeout_in_ms: NotRequired[pulumi.Input[builtins.int]]
        """
        Timeout for connecting to the LDAP server in miliseconds. The default is 5000 ms.
        """
        search_base_distinguished_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Distinguished name of the object to start the recursive search of users from.
        """
        search_filter_template: NotRequired[pulumi.Input[builtins.str]]
        """
        Template to use for searching. Defaults to (cn=%s) where %s will be replaced by the username used to login.
        """
        server_certificates: NotRequired[pulumi.Input[Sequence[pulumi.Input['CertificateArgsDict']]]]
        server_hostname: NotRequired[pulumi.Input[builtins.str]]
        """
        Hostname of the LDAP server.
        """
        server_port: NotRequired[pulumi.Input[builtins.int]]
        """
        Port of the LDAP server.
        """
        service_user_distinguished_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Distinguished name of the look up user account, who can look up user details on authentication.
        """
        service_user_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Password of the look up user.
        """
elif False:
    AuthenticationMethodLdapPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationMethodLdapPropertiesArgs:
    def __init__(__self__, *,
                 connection_timeout_in_ms: Optional[pulumi.Input[builtins.int]] = None,
                 search_base_distinguished_name: Optional[pulumi.Input[builtins.str]] = None,
                 search_filter_template: Optional[pulumi.Input[builtins.str]] = None,
                 server_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]] = None,
                 server_hostname: Optional[pulumi.Input[builtins.str]] = None,
                 server_port: Optional[pulumi.Input[builtins.int]] = None,
                 service_user_distinguished_name: Optional[pulumi.Input[builtins.str]] = None,
                 service_user_password: Optional[pulumi.Input[builtins.str]] = None):
        """
        Ldap authentication method properties. This feature is in preview.
        :param pulumi.Input[builtins.int] connection_timeout_in_ms: Timeout for connecting to the LDAP server in miliseconds. The default is 5000 ms.
        :param pulumi.Input[builtins.str] search_base_distinguished_name: Distinguished name of the object to start the recursive search of users from.
        :param pulumi.Input[builtins.str] search_filter_template: Template to use for searching. Defaults to (cn=%s) where %s will be replaced by the username used to login.
        :param pulumi.Input[builtins.str] server_hostname: Hostname of the LDAP server.
        :param pulumi.Input[builtins.int] server_port: Port of the LDAP server.
        :param pulumi.Input[builtins.str] service_user_distinguished_name: Distinguished name of the look up user account, who can look up user details on authentication.
        :param pulumi.Input[builtins.str] service_user_password: Password of the look up user.
        """
        if connection_timeout_in_ms is not None:
            pulumi.set(__self__, "connection_timeout_in_ms", connection_timeout_in_ms)
        if search_base_distinguished_name is not None:
            pulumi.set(__self__, "search_base_distinguished_name", search_base_distinguished_name)
        if search_filter_template is not None:
            pulumi.set(__self__, "search_filter_template", search_filter_template)
        if server_certificates is not None:
            pulumi.set(__self__, "server_certificates", server_certificates)
        if server_hostname is not None:
            pulumi.set(__self__, "server_hostname", server_hostname)
        if server_port is not None:
            pulumi.set(__self__, "server_port", server_port)
        if service_user_distinguished_name is not None:
            pulumi.set(__self__, "service_user_distinguished_name", service_user_distinguished_name)
        if service_user_password is not None:
            pulumi.set(__self__, "service_user_password", service_user_password)

    @property
    @pulumi.getter(name="connectionTimeoutInMs")
    def connection_timeout_in_ms(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Timeout for connecting to the LDAP server in miliseconds. The default is 5000 ms.
        """
        return pulumi.get(self, "connection_timeout_in_ms")

    @connection_timeout_in_ms.setter
    def connection_timeout_in_ms(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "connection_timeout_in_ms", value)

    @property
    @pulumi.getter(name="searchBaseDistinguishedName")
    def search_base_distinguished_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Distinguished name of the object to start the recursive search of users from.
        """
        return pulumi.get(self, "search_base_distinguished_name")

    @search_base_distinguished_name.setter
    def search_base_distinguished_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "search_base_distinguished_name", value)

    @property
    @pulumi.getter(name="searchFilterTemplate")
    def search_filter_template(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Template to use for searching. Defaults to (cn=%s) where %s will be replaced by the username used to login.
        """
        return pulumi.get(self, "search_filter_template")

    @search_filter_template.setter
    def search_filter_template(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "search_filter_template", value)

    @property
    @pulumi.getter(name="serverCertificates")
    def server_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]]:
        return pulumi.get(self, "server_certificates")

    @server_certificates.setter
    def server_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]]):
        pulumi.set(self, "server_certificates", value)

    @property
    @pulumi.getter(name="serverHostname")
    def server_hostname(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Hostname of the LDAP server.
        """
        return pulumi.get(self, "server_hostname")

    @server_hostname.setter
    def server_hostname(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_hostname", value)

    @property
    @pulumi.getter(name="serverPort")
    def server_port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Port of the LDAP server.
        """
        return pulumi.get(self, "server_port")

    @server_port.setter
    def server_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "server_port", value)

    @property
    @pulumi.getter(name="serviceUserDistinguishedName")
    def service_user_distinguished_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Distinguished name of the look up user account, who can look up user details on authentication.
        """
        return pulumi.get(self, "service_user_distinguished_name")

    @service_user_distinguished_name.setter
    def service_user_distinguished_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_user_distinguished_name", value)

    @property
    @pulumi.getter(name="serviceUserPassword")
    def service_user_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Password of the look up user.
        """
        return pulumi.get(self, "service_user_password")

    @service_user_password.setter
    def service_user_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_user_password", value)


if not MYPY:
    class AutoscaleSettingsArgsDict(TypedDict):
        max_throughput: NotRequired[pulumi.Input[builtins.int]]
        """
        Represents maximum throughput, the resource can scale up to.
        """
elif False:
    AutoscaleSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutoscaleSettingsArgs:
    def __init__(__self__, *,
                 max_throughput: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] max_throughput: Represents maximum throughput, the resource can scale up to.
        """
        if max_throughput is not None:
            pulumi.set(__self__, "max_throughput", max_throughput)

    @property
    @pulumi.getter(name="maxThroughput")
    def max_throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Represents maximum throughput, the resource can scale up to.
        """
        return pulumi.get(self, "max_throughput")

    @max_throughput.setter
    def max_throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_throughput", value)


if not MYPY:
    class BackupPolicyMigrationStateArgsDict(TypedDict):
        """
        The object representing the state of the migration between the backup policies.
        """
        start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Time at which the backup policy migration started (ISO-8601 format).
        """
        status: NotRequired[pulumi.Input[Union[builtins.str, 'BackupPolicyMigrationStatus']]]
        """
        Describes the status of migration between backup policy types.
        """
        target_type: NotRequired[pulumi.Input[Union[builtins.str, 'BackupPolicyType']]]
        """
        Describes the target backup policy type of the backup policy migration.
        """
elif False:
    BackupPolicyMigrationStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPolicyMigrationStateArgs:
    def __init__(__self__, *,
                 start_time: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[Union[builtins.str, 'BackupPolicyMigrationStatus']]] = None,
                 target_type: Optional[pulumi.Input[Union[builtins.str, 'BackupPolicyType']]] = None):
        """
        The object representing the state of the migration between the backup policies.
        :param pulumi.Input[builtins.str] start_time: Time at which the backup policy migration started (ISO-8601 format).
        :param pulumi.Input[Union[builtins.str, 'BackupPolicyMigrationStatus']] status: Describes the status of migration between backup policy types.
        :param pulumi.Input[Union[builtins.str, 'BackupPolicyType']] target_type: Describes the target backup policy type of the backup policy migration.
        """
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if target_type is not None:
            pulumi.set(__self__, "target_type", target_type)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time at which the backup policy migration started (ISO-8601 format).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[builtins.str, 'BackupPolicyMigrationStatus']]]:
        """
        Describes the status of migration between backup policy types.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[builtins.str, 'BackupPolicyMigrationStatus']]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'BackupPolicyType']]]:
        """
        Describes the target backup policy type of the backup policy migration.
        """
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'BackupPolicyType']]]):
        pulumi.set(self, "target_type", value)


if not MYPY:
    class CapabilityArgsDict(TypedDict):
        """
        Cosmos DB capability object
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the Cosmos DB capability. For example, "name": "EnableCassandra". Current values also include "EnableTable" and "EnableGremlin".
        """
elif False:
    CapabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Cosmos DB capability object
        :param pulumi.Input[builtins.str] name: Name of the Cosmos DB capability. For example, "name": "EnableCassandra". Current values also include "EnableTable" and "EnableGremlin".
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the Cosmos DB capability. For example, "name": "EnableCassandra". Current values also include "EnableTable" and "EnableGremlin".
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CapacityArgsDict(TypedDict):
        """
        The object that represents all properties related to capacity enforcement on an account.
        """
        total_throughput_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        The total throughput limit imposed on the account. A totalThroughputLimit of 2000 imposes a strict limit of max throughput that can be provisioned on that account to be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning of throughput.
        """
elif False:
    CapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityArgs:
    def __init__(__self__, *,
                 total_throughput_limit: Optional[pulumi.Input[builtins.int]] = None):
        """
        The object that represents all properties related to capacity enforcement on an account.
        :param pulumi.Input[builtins.int] total_throughput_limit: The total throughput limit imposed on the account. A totalThroughputLimit of 2000 imposes a strict limit of max throughput that can be provisioned on that account to be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning of throughput.
        """
        if total_throughput_limit is not None:
            pulumi.set(__self__, "total_throughput_limit", total_throughput_limit)

    @property
    @pulumi.getter(name="totalThroughputLimit")
    def total_throughput_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The total throughput limit imposed on the account. A totalThroughputLimit of 2000 imposes a strict limit of max throughput that can be provisioned on that account to be 2000. A totalThroughputLimit of -1 indicates no limits on provisioning of throughput.
        """
        return pulumi.get(self, "total_throughput_limit")

    @total_throughput_limit.setter
    def total_throughput_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "total_throughput_limit", value)


if not MYPY:
    class CassandraErrorArgsDict(TypedDict):
        additional_error_info: NotRequired[pulumi.Input[builtins.str]]
        """
        Additional information about the error.
        """
        code: NotRequired[pulumi.Input[builtins.str]]
        """
        The code of error that occurred.
        """
        message: NotRequired[pulumi.Input[builtins.str]]
        """
        The message of the error.
        """
        target: NotRequired[pulumi.Input[builtins.str]]
        """
        The target resource of the error.
        """
elif False:
    CassandraErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CassandraErrorArgs:
    def __init__(__self__, *,
                 additional_error_info: Optional[pulumi.Input[builtins.str]] = None,
                 code: Optional[pulumi.Input[builtins.str]] = None,
                 message: Optional[pulumi.Input[builtins.str]] = None,
                 target: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] additional_error_info: Additional information about the error.
        :param pulumi.Input[builtins.str] code: The code of error that occurred.
        :param pulumi.Input[builtins.str] message: The message of the error.
        :param pulumi.Input[builtins.str] target: The target resource of the error.
        """
        if additional_error_info is not None:
            pulumi.set(__self__, "additional_error_info", additional_error_info)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="additionalErrorInfo")
    def additional_error_info(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Additional information about the error.
        """
        return pulumi.get(self, "additional_error_info")

    @additional_error_info.setter
    def additional_error_info(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "additional_error_info", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The code of error that occurred.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The message of the error.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The target resource of the error.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class CassandraKeyspaceResourceArgsDict(TypedDict):
        """
        Cosmos DB Cassandra keyspace id object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB Cassandra keyspace
        """
elif False:
    CassandraKeyspaceResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CassandraKeyspaceResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str]):
        """
        Cosmos DB Cassandra keyspace id object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB Cassandra keyspace
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB Cassandra keyspace
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CassandraPartitionKeyArgsDict(TypedDict):
        """
        Cosmos DB Cassandra table partition key
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the Cosmos DB Cassandra table partition key
        """
elif False:
    CassandraPartitionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CassandraPartitionKeyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Cosmos DB Cassandra table partition key
        :param pulumi.Input[builtins.str] name: Name of the Cosmos DB Cassandra table partition key
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the Cosmos DB Cassandra table partition key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CassandraSchemaArgsDict(TypedDict):
        """
        Cosmos DB Cassandra table schema
        """
        cluster_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterKeyArgsDict']]]]
        """
        List of cluster key.
        """
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ColumnArgsDict']]]]
        """
        List of Cassandra table columns.
        """
        partition_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['CassandraPartitionKeyArgsDict']]]]
        """
        List of partition key.
        """
elif False:
    CassandraSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CassandraSchemaArgs:
    def __init__(__self__, *,
                 cluster_keys: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterKeyArgs']]]] = None,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]]] = None,
                 partition_keys: Optional[pulumi.Input[Sequence[pulumi.Input['CassandraPartitionKeyArgs']]]] = None):
        """
        Cosmos DB Cassandra table schema
        :param pulumi.Input[Sequence[pulumi.Input['ClusterKeyArgs']]] cluster_keys: List of cluster key.
        :param pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]] columns: List of Cassandra table columns.
        :param pulumi.Input[Sequence[pulumi.Input['CassandraPartitionKeyArgs']]] partition_keys: List of partition key.
        """
        if cluster_keys is not None:
            pulumi.set(__self__, "cluster_keys", cluster_keys)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if partition_keys is not None:
            pulumi.set(__self__, "partition_keys", partition_keys)

    @property
    @pulumi.getter(name="clusterKeys")
    def cluster_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterKeyArgs']]]]:
        """
        List of cluster key.
        """
        return pulumi.get(self, "cluster_keys")

    @cluster_keys.setter
    def cluster_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterKeyArgs']]]]):
        pulumi.set(self, "cluster_keys", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]]]:
        """
        List of Cassandra table columns.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter(name="partitionKeys")
    def partition_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CassandraPartitionKeyArgs']]]]:
        """
        List of partition key.
        """
        return pulumi.get(self, "partition_keys")

    @partition_keys.setter
    def partition_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CassandraPartitionKeyArgs']]]]):
        pulumi.set(self, "partition_keys", value)


if not MYPY:
    class CassandraTableResourceArgsDict(TypedDict):
        """
        Cosmos DB Cassandra table id object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB Cassandra table
        """
        analytical_storage_ttl: NotRequired[pulumi.Input[builtins.int]]
        """
        Analytical TTL.
        """
        default_ttl: NotRequired[pulumi.Input[builtins.int]]
        """
        Time to live of the Cosmos DB Cassandra table
        """
        schema: NotRequired[pulumi.Input['CassandraSchemaArgsDict']]
        """
        Schema of the Cosmos DB Cassandra table
        """
elif False:
    CassandraTableResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CassandraTableResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 analytical_storage_ttl: Optional[pulumi.Input[builtins.int]] = None,
                 default_ttl: Optional[pulumi.Input[builtins.int]] = None,
                 schema: Optional[pulumi.Input['CassandraSchemaArgs']] = None):
        """
        Cosmos DB Cassandra table id object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB Cassandra table
        :param pulumi.Input[builtins.int] analytical_storage_ttl: Analytical TTL.
        :param pulumi.Input[builtins.int] default_ttl: Time to live of the Cosmos DB Cassandra table
        :param pulumi.Input['CassandraSchemaArgs'] schema: Schema of the Cosmos DB Cassandra table
        """
        pulumi.set(__self__, "id", id)
        if analytical_storage_ttl is not None:
            pulumi.set(__self__, "analytical_storage_ttl", analytical_storage_ttl)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB Cassandra table
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="analyticalStorageTtl")
    def analytical_storage_ttl(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Analytical TTL.
        """
        return pulumi.get(self, "analytical_storage_ttl")

    @analytical_storage_ttl.setter
    def analytical_storage_ttl(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "analytical_storage_ttl", value)

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Time to live of the Cosmos DB Cassandra table
        """
        return pulumi.get(self, "default_ttl")

    @default_ttl.setter
    def default_ttl(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "default_ttl", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input['CassandraSchemaArgs']]:
        """
        Schema of the Cosmos DB Cassandra table
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input['CassandraSchemaArgs']]):
        pulumi.set(self, "schema", value)


if not MYPY:
    class CassandraViewResourceArgsDict(TypedDict):
        """
        Cosmos DB Cassandra view resource object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB Cassandra view
        """
        view_definition: pulumi.Input[builtins.str]
        """
        View Definition of the Cosmos DB Cassandra view
        """
elif False:
    CassandraViewResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CassandraViewResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 view_definition: pulumi.Input[builtins.str]):
        """
        Cosmos DB Cassandra view resource object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB Cassandra view
        :param pulumi.Input[builtins.str] view_definition: View Definition of the Cosmos DB Cassandra view
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "view_definition", view_definition)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB Cassandra view
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="viewDefinition")
    def view_definition(self) -> pulumi.Input[builtins.str]:
        """
        View Definition of the Cosmos DB Cassandra view
        """
        return pulumi.get(self, "view_definition")

    @view_definition.setter
    def view_definition(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "view_definition", value)


if not MYPY:
    class CertificateArgsDict(TypedDict):
        pem: NotRequired[pulumi.Input[builtins.str]]
        """
        PEM formatted public key.
        """
elif False:
    CertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateArgs:
    def __init__(__self__, *,
                 pem: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] pem: PEM formatted public key.
        """
        if pem is not None:
            pulumi.set(__self__, "pem", pem)

    @property
    @pulumi.getter
    def pem(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PEM formatted public key.
        """
        return pulumi.get(self, "pem")

    @pem.setter
    def pem(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pem", value)


if not MYPY:
    class ClientEncryptionIncludedPathArgsDict(TypedDict):
        """
        .
        """
        client_encryption_key_id: pulumi.Input[builtins.str]
        """
        The identifier of the Client Encryption Key to be used to encrypt the path.
        """
        encryption_algorithm: pulumi.Input[builtins.str]
        """
        The encryption algorithm which will be used. Eg - AEAD_AES_256_CBC_HMAC_SHA256.
        """
        encryption_type: pulumi.Input[builtins.str]
        """
        The type of encryption to be performed. Eg - Deterministic, Randomized.
        """
        path: pulumi.Input[builtins.str]
        """
        Path that needs to be encrypted.
        """
elif False:
    ClientEncryptionIncludedPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientEncryptionIncludedPathArgs:
    def __init__(__self__, *,
                 client_encryption_key_id: pulumi.Input[builtins.str],
                 encryption_algorithm: pulumi.Input[builtins.str],
                 encryption_type: pulumi.Input[builtins.str],
                 path: pulumi.Input[builtins.str]):
        """
        .
        :param pulumi.Input[builtins.str] client_encryption_key_id: The identifier of the Client Encryption Key to be used to encrypt the path.
        :param pulumi.Input[builtins.str] encryption_algorithm: The encryption algorithm which will be used. Eg - AEAD_AES_256_CBC_HMAC_SHA256.
        :param pulumi.Input[builtins.str] encryption_type: The type of encryption to be performed. Eg - Deterministic, Randomized.
        :param pulumi.Input[builtins.str] path: Path that needs to be encrypted.
        """
        pulumi.set(__self__, "client_encryption_key_id", client_encryption_key_id)
        pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)
        pulumi.set(__self__, "encryption_type", encryption_type)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="clientEncryptionKeyId")
    def client_encryption_key_id(self) -> pulumi.Input[builtins.str]:
        """
        The identifier of the Client Encryption Key to be used to encrypt the path.
        """
        return pulumi.get(self, "client_encryption_key_id")

    @client_encryption_key_id.setter
    def client_encryption_key_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_encryption_key_id", value)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> pulumi.Input[builtins.str]:
        """
        The encryption algorithm which will be used. Eg - AEAD_AES_256_CBC_HMAC_SHA256.
        """
        return pulumi.get(self, "encryption_algorithm")

    @encryption_algorithm.setter
    def encryption_algorithm(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "encryption_algorithm", value)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of encryption to be performed. Eg - Deterministic, Randomized.
        """
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[builtins.str]:
        """
        Path that needs to be encrypted.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ClientEncryptionPolicyArgsDict(TypedDict):
        """
        Cosmos DB client encryption policy.
        """
        included_paths: pulumi.Input[Sequence[pulumi.Input['ClientEncryptionIncludedPathArgsDict']]]
        """
        Paths of the item that need encryption along with path-specific settings.
        """
        policy_format_version: pulumi.Input[builtins.int]
        """
        Version of the client encryption policy definition. Supported versions are 1 and 2. Version 2 supports id and partition key path encryption. 
        """
elif False:
    ClientEncryptionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientEncryptionPolicyArgs:
    def __init__(__self__, *,
                 included_paths: pulumi.Input[Sequence[pulumi.Input['ClientEncryptionIncludedPathArgs']]],
                 policy_format_version: pulumi.Input[builtins.int]):
        """
        Cosmos DB client encryption policy.
        :param pulumi.Input[Sequence[pulumi.Input['ClientEncryptionIncludedPathArgs']]] included_paths: Paths of the item that need encryption along with path-specific settings.
        :param pulumi.Input[builtins.int] policy_format_version: Version of the client encryption policy definition. Supported versions are 1 and 2. Version 2 supports id and partition key path encryption. 
        """
        pulumi.set(__self__, "included_paths", included_paths)
        pulumi.set(__self__, "policy_format_version", policy_format_version)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> pulumi.Input[Sequence[pulumi.Input['ClientEncryptionIncludedPathArgs']]]:
        """
        Paths of the item that need encryption along with path-specific settings.
        """
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: pulumi.Input[Sequence[pulumi.Input['ClientEncryptionIncludedPathArgs']]]):
        pulumi.set(self, "included_paths", value)

    @property
    @pulumi.getter(name="policyFormatVersion")
    def policy_format_version(self) -> pulumi.Input[builtins.int]:
        """
        Version of the client encryption policy definition. Supported versions are 1 and 2. Version 2 supports id and partition key path encryption. 
        """
        return pulumi.get(self, "policy_format_version")

    @policy_format_version.setter
    def policy_format_version(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "policy_format_version", value)


if not MYPY:
    class ClusterKeyArgsDict(TypedDict):
        """
        Cosmos DB Cassandra table cluster key
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the Cosmos DB Cassandra table cluster key
        """
        order_by: NotRequired[pulumi.Input[builtins.str]]
        """
        Order of the Cosmos DB Cassandra table cluster key, only support "Asc" and "Desc"
        """
elif False:
    ClusterKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterKeyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 order_by: Optional[pulumi.Input[builtins.str]] = None):
        """
        Cosmos DB Cassandra table cluster key
        :param pulumi.Input[builtins.str] name: Name of the Cosmos DB Cassandra table cluster key
        :param pulumi.Input[builtins.str] order_by: Order of the Cosmos DB Cassandra table cluster key, only support "Asc" and "Desc"
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the Cosmos DB Cassandra table cluster key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Order of the Cosmos DB Cassandra table cluster key, only support "Asc" and "Desc"
        """
        return pulumi.get(self, "order_by")

    @order_by.setter
    def order_by(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "order_by", value)


if not MYPY:
    class ClusterResourcePropertiesArgsDict(TypedDict):
        """
        Properties of a managed Cassandra cluster.
        """
        authentication_method: NotRequired[pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]]
        """
        Which authentication method Cassandra should use to authenticate clients. 'None' turns off authentication, so should not be used except in emergencies. 'Cassandra' is the default password based authentication. The default is 'Cassandra'.
        """
        azure_connection_method: NotRequired[pulumi.Input[Union[builtins.str, 'AzureConnectionType']]]
        """
        How to connect to the azure services needed for running the cluster
        """
        cassandra_audit_logging_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether Cassandra audit logging is enabled
        """
        cassandra_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Which version of Cassandra should this cluster converge to running (e.g., 3.11). When updated, the cluster may take some time to migrate to the new version.
        """
        client_certificates: NotRequired[pulumi.Input[Sequence[pulumi.Input['CertificateArgsDict']]]]
        """
        List of TLS certificates used to authorize clients connecting to the cluster. All connections are TLS encrypted whether clientCertificates is set or not, but if clientCertificates is set, the managed Cassandra cluster will reject all connections not bearing a TLS client certificate that can be validated from one or more of the public certificates in this property.
        """
        cluster_name_override: NotRequired[pulumi.Input[builtins.str]]
        """
        If you need to set the clusterName property in cassandra.yaml to something besides the resource name of the cluster, set the value to use on this property.
        """
        deallocated: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the cluster and associated data centers has been deallocated.
        """
        delegated_management_subnet_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource id of a subnet that this cluster's management service should have its network interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The resource id must be of the form '/subscriptions/<subscription id>/resourceGroups/<resource group>/providers/Microsoft.Network/virtualNetworks/<virtual network>/subnets/<subnet>'
        """
        external_gossip_certificates: NotRequired[pulumi.Input[Sequence[pulumi.Input['CertificateArgsDict']]]]
        """
        List of TLS certificates used to authorize gossip from unmanaged data centers. The TLS certificates of all nodes in unmanaged data centers must be verifiable using one of the certificates provided in this property.
        """
        external_seed_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['SeedNodeArgsDict']]]]
        """
        List of IP addresses of seed nodes in unmanaged data centers. These will be added to the seed node lists of all managed nodes.
        """
        hours_between_backups: NotRequired[pulumi.Input[builtins.int]]
        """
        (Deprecated) Number of hours to wait between taking a backup of the cluster.
        """
        initial_cassandra_admin_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Initial password for clients connecting as admin to the cluster. Should be changed after cluster creation. Returns null on GET. This field only applies when the authenticationMethod field is 'Cassandra'.
        """
        prometheus_endpoint: NotRequired[pulumi.Input['SeedNodeArgsDict']]
        """
        Hostname or IP address where the Prometheus endpoint containing data about the managed Cassandra nodes can be reached.
        """
        provision_error: NotRequired[pulumi.Input['CassandraErrorArgsDict']]
        """
        Error related to resource provisioning.
        """
        provisioning_state: NotRequired[pulumi.Input[Union[builtins.str, 'ManagedCassandraProvisioningState']]]
        """
        The status of the resource at the time the operation was called.
        """
        repair_enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Should automatic repairs run on this cluster? If omitted, this is true, and should stay true unless you are running a hybrid cluster where you are already doing your own repairs.
        """
        restore_from_backup_id: NotRequired[pulumi.Input[builtins.str]]
        """
        To create an empty cluster, omit this field or set it to null. To restore a backup into a new cluster, set this field to the resource id of the backup.
        """
elif False:
    ClusterResourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterResourcePropertiesArgs:
    def __init__(__self__, *,
                 authentication_method: Optional[pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]] = None,
                 azure_connection_method: Optional[pulumi.Input[Union[builtins.str, 'AzureConnectionType']]] = None,
                 cassandra_audit_logging_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 cassandra_version: Optional[pulumi.Input[builtins.str]] = None,
                 client_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]] = None,
                 cluster_name_override: Optional[pulumi.Input[builtins.str]] = None,
                 deallocated: Optional[pulumi.Input[builtins.bool]] = None,
                 delegated_management_subnet_id: Optional[pulumi.Input[builtins.str]] = None,
                 external_gossip_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]] = None,
                 external_seed_nodes: Optional[pulumi.Input[Sequence[pulumi.Input['SeedNodeArgs']]]] = None,
                 hours_between_backups: Optional[pulumi.Input[builtins.int]] = None,
                 initial_cassandra_admin_password: Optional[pulumi.Input[builtins.str]] = None,
                 prometheus_endpoint: Optional[pulumi.Input['SeedNodeArgs']] = None,
                 provision_error: Optional[pulumi.Input['CassandraErrorArgs']] = None,
                 provisioning_state: Optional[pulumi.Input[Union[builtins.str, 'ManagedCassandraProvisioningState']]] = None,
                 repair_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 restore_from_backup_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Properties of a managed Cassandra cluster.
        :param pulumi.Input[Union[builtins.str, 'AuthenticationMethod']] authentication_method: Which authentication method Cassandra should use to authenticate clients. 'None' turns off authentication, so should not be used except in emergencies. 'Cassandra' is the default password based authentication. The default is 'Cassandra'.
        :param pulumi.Input[Union[builtins.str, 'AzureConnectionType']] azure_connection_method: How to connect to the azure services needed for running the cluster
        :param pulumi.Input[builtins.bool] cassandra_audit_logging_enabled: Whether Cassandra audit logging is enabled
        :param pulumi.Input[builtins.str] cassandra_version: Which version of Cassandra should this cluster converge to running (e.g., 3.11). When updated, the cluster may take some time to migrate to the new version.
        :param pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]] client_certificates: List of TLS certificates used to authorize clients connecting to the cluster. All connections are TLS encrypted whether clientCertificates is set or not, but if clientCertificates is set, the managed Cassandra cluster will reject all connections not bearing a TLS client certificate that can be validated from one or more of the public certificates in this property.
        :param pulumi.Input[builtins.str] cluster_name_override: If you need to set the clusterName property in cassandra.yaml to something besides the resource name of the cluster, set the value to use on this property.
        :param pulumi.Input[builtins.bool] deallocated: Whether the cluster and associated data centers has been deallocated.
        :param pulumi.Input[builtins.str] delegated_management_subnet_id: Resource id of a subnet that this cluster's management service should have its network interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The resource id must be of the form '/subscriptions/<subscription id>/resourceGroups/<resource group>/providers/Microsoft.Network/virtualNetworks/<virtual network>/subnets/<subnet>'
        :param pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]] external_gossip_certificates: List of TLS certificates used to authorize gossip from unmanaged data centers. The TLS certificates of all nodes in unmanaged data centers must be verifiable using one of the certificates provided in this property.
        :param pulumi.Input[Sequence[pulumi.Input['SeedNodeArgs']]] external_seed_nodes: List of IP addresses of seed nodes in unmanaged data centers. These will be added to the seed node lists of all managed nodes.
        :param pulumi.Input[builtins.int] hours_between_backups: (Deprecated) Number of hours to wait between taking a backup of the cluster.
        :param pulumi.Input[builtins.str] initial_cassandra_admin_password: Initial password for clients connecting as admin to the cluster. Should be changed after cluster creation. Returns null on GET. This field only applies when the authenticationMethod field is 'Cassandra'.
        :param pulumi.Input['SeedNodeArgs'] prometheus_endpoint: Hostname or IP address where the Prometheus endpoint containing data about the managed Cassandra nodes can be reached.
        :param pulumi.Input['CassandraErrorArgs'] provision_error: Error related to resource provisioning.
        :param pulumi.Input[Union[builtins.str, 'ManagedCassandraProvisioningState']] provisioning_state: The status of the resource at the time the operation was called.
        :param pulumi.Input[builtins.bool] repair_enabled: Should automatic repairs run on this cluster? If omitted, this is true, and should stay true unless you are running a hybrid cluster where you are already doing your own repairs.
        :param pulumi.Input[builtins.str] restore_from_backup_id: To create an empty cluster, omit this field or set it to null. To restore a backup into a new cluster, set this field to the resource id of the backup.
        """
        if authentication_method is not None:
            pulumi.set(__self__, "authentication_method", authentication_method)
        if azure_connection_method is not None:
            pulumi.set(__self__, "azure_connection_method", azure_connection_method)
        if cassandra_audit_logging_enabled is not None:
            pulumi.set(__self__, "cassandra_audit_logging_enabled", cassandra_audit_logging_enabled)
        if cassandra_version is not None:
            pulumi.set(__self__, "cassandra_version", cassandra_version)
        if client_certificates is not None:
            pulumi.set(__self__, "client_certificates", client_certificates)
        if cluster_name_override is not None:
            pulumi.set(__self__, "cluster_name_override", cluster_name_override)
        if deallocated is not None:
            pulumi.set(__self__, "deallocated", deallocated)
        if delegated_management_subnet_id is not None:
            pulumi.set(__self__, "delegated_management_subnet_id", delegated_management_subnet_id)
        if external_gossip_certificates is not None:
            pulumi.set(__self__, "external_gossip_certificates", external_gossip_certificates)
        if external_seed_nodes is not None:
            pulumi.set(__self__, "external_seed_nodes", external_seed_nodes)
        if hours_between_backups is not None:
            pulumi.set(__self__, "hours_between_backups", hours_between_backups)
        if initial_cassandra_admin_password is not None:
            pulumi.set(__self__, "initial_cassandra_admin_password", initial_cassandra_admin_password)
        if prometheus_endpoint is not None:
            pulumi.set(__self__, "prometheus_endpoint", prometheus_endpoint)
        if provision_error is not None:
            pulumi.set(__self__, "provision_error", provision_error)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)
        if repair_enabled is not None:
            pulumi.set(__self__, "repair_enabled", repair_enabled)
        if restore_from_backup_id is not None:
            pulumi.set(__self__, "restore_from_backup_id", restore_from_backup_id)

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]]:
        """
        Which authentication method Cassandra should use to authenticate clients. 'None' turns off authentication, so should not be used except in emergencies. 'Cassandra' is the default password based authentication. The default is 'Cassandra'.
        """
        return pulumi.get(self, "authentication_method")

    @authentication_method.setter
    def authentication_method(self, value: Optional[pulumi.Input[Union[builtins.str, 'AuthenticationMethod']]]):
        pulumi.set(self, "authentication_method", value)

    @property
    @pulumi.getter(name="azureConnectionMethod")
    def azure_connection_method(self) -> Optional[pulumi.Input[Union[builtins.str, 'AzureConnectionType']]]:
        """
        How to connect to the azure services needed for running the cluster
        """
        return pulumi.get(self, "azure_connection_method")

    @azure_connection_method.setter
    def azure_connection_method(self, value: Optional[pulumi.Input[Union[builtins.str, 'AzureConnectionType']]]):
        pulumi.set(self, "azure_connection_method", value)

    @property
    @pulumi.getter(name="cassandraAuditLoggingEnabled")
    def cassandra_audit_logging_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether Cassandra audit logging is enabled
        """
        return pulumi.get(self, "cassandra_audit_logging_enabled")

    @cassandra_audit_logging_enabled.setter
    def cassandra_audit_logging_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "cassandra_audit_logging_enabled", value)

    @property
    @pulumi.getter(name="cassandraVersion")
    def cassandra_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Which version of Cassandra should this cluster converge to running (e.g., 3.11). When updated, the cluster may take some time to migrate to the new version.
        """
        return pulumi.get(self, "cassandra_version")

    @cassandra_version.setter
    def cassandra_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cassandra_version", value)

    @property
    @pulumi.getter(name="clientCertificates")
    def client_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]]:
        """
        List of TLS certificates used to authorize clients connecting to the cluster. All connections are TLS encrypted whether clientCertificates is set or not, but if clientCertificates is set, the managed Cassandra cluster will reject all connections not bearing a TLS client certificate that can be validated from one or more of the public certificates in this property.
        """
        return pulumi.get(self, "client_certificates")

    @client_certificates.setter
    def client_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]]):
        pulumi.set(self, "client_certificates", value)

    @property
    @pulumi.getter(name="clusterNameOverride")
    def cluster_name_override(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If you need to set the clusterName property in cassandra.yaml to something besides the resource name of the cluster, set the value to use on this property.
        """
        return pulumi.get(self, "cluster_name_override")

    @cluster_name_override.setter
    def cluster_name_override(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_name_override", value)

    @property
    @pulumi.getter
    def deallocated(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the cluster and associated data centers has been deallocated.
        """
        return pulumi.get(self, "deallocated")

    @deallocated.setter
    def deallocated(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "deallocated", value)

    @property
    @pulumi.getter(name="delegatedManagementSubnetId")
    def delegated_management_subnet_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource id of a subnet that this cluster's management service should have its network interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The resource id must be of the form '/subscriptions/<subscription id>/resourceGroups/<resource group>/providers/Microsoft.Network/virtualNetworks/<virtual network>/subnets/<subnet>'
        """
        return pulumi.get(self, "delegated_management_subnet_id")

    @delegated_management_subnet_id.setter
    def delegated_management_subnet_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delegated_management_subnet_id", value)

    @property
    @pulumi.getter(name="externalGossipCertificates")
    def external_gossip_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]]:
        """
        List of TLS certificates used to authorize gossip from unmanaged data centers. The TLS certificates of all nodes in unmanaged data centers must be verifiable using one of the certificates provided in this property.
        """
        return pulumi.get(self, "external_gossip_certificates")

    @external_gossip_certificates.setter
    def external_gossip_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]]):
        pulumi.set(self, "external_gossip_certificates", value)

    @property
    @pulumi.getter(name="externalSeedNodes")
    def external_seed_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SeedNodeArgs']]]]:
        """
        List of IP addresses of seed nodes in unmanaged data centers. These will be added to the seed node lists of all managed nodes.
        """
        return pulumi.get(self, "external_seed_nodes")

    @external_seed_nodes.setter
    def external_seed_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SeedNodeArgs']]]]):
        pulumi.set(self, "external_seed_nodes", value)

    @property
    @pulumi.getter(name="hoursBetweenBackups")
    def hours_between_backups(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Deprecated) Number of hours to wait between taking a backup of the cluster.
        """
        return pulumi.get(self, "hours_between_backups")

    @hours_between_backups.setter
    def hours_between_backups(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "hours_between_backups", value)

    @property
    @pulumi.getter(name="initialCassandraAdminPassword")
    def initial_cassandra_admin_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Initial password for clients connecting as admin to the cluster. Should be changed after cluster creation. Returns null on GET. This field only applies when the authenticationMethod field is 'Cassandra'.
        """
        return pulumi.get(self, "initial_cassandra_admin_password")

    @initial_cassandra_admin_password.setter
    def initial_cassandra_admin_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "initial_cassandra_admin_password", value)

    @property
    @pulumi.getter(name="prometheusEndpoint")
    def prometheus_endpoint(self) -> Optional[pulumi.Input['SeedNodeArgs']]:
        """
        Hostname or IP address where the Prometheus endpoint containing data about the managed Cassandra nodes can be reached.
        """
        return pulumi.get(self, "prometheus_endpoint")

    @prometheus_endpoint.setter
    def prometheus_endpoint(self, value: Optional[pulumi.Input['SeedNodeArgs']]):
        pulumi.set(self, "prometheus_endpoint", value)

    @property
    @pulumi.getter(name="provisionError")
    def provision_error(self) -> Optional[pulumi.Input['CassandraErrorArgs']]:
        """
        Error related to resource provisioning.
        """
        return pulumi.get(self, "provision_error")

    @provision_error.setter
    def provision_error(self, value: Optional[pulumi.Input['CassandraErrorArgs']]):
        pulumi.set(self, "provision_error", value)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[pulumi.Input[Union[builtins.str, 'ManagedCassandraProvisioningState']]]:
        """
        The status of the resource at the time the operation was called.
        """
        return pulumi.get(self, "provisioning_state")

    @provisioning_state.setter
    def provisioning_state(self, value: Optional[pulumi.Input[Union[builtins.str, 'ManagedCassandraProvisioningState']]]):
        pulumi.set(self, "provisioning_state", value)

    @property
    @pulumi.getter(name="repairEnabled")
    def repair_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Should automatic repairs run on this cluster? If omitted, this is true, and should stay true unless you are running a hybrid cluster where you are already doing your own repairs.
        """
        return pulumi.get(self, "repair_enabled")

    @repair_enabled.setter
    def repair_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "repair_enabled", value)

    @property
    @pulumi.getter(name="restoreFromBackupId")
    def restore_from_backup_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        To create an empty cluster, omit this field or set it to null. To restore a backup into a new cluster, set this field to the resource id of the backup.
        """
        return pulumi.get(self, "restore_from_backup_id")

    @restore_from_backup_id.setter
    def restore_from_backup_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "restore_from_backup_id", value)


if not MYPY:
    class ColumnArgsDict(TypedDict):
        """
        Cosmos DB Cassandra table column
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the Cosmos DB Cassandra table column
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of the Cosmos DB Cassandra table column
        """
elif False:
    ColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ColumnArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        Cosmos DB Cassandra table column
        :param pulumi.Input[builtins.str] name: Name of the Cosmos DB Cassandra table column
        :param pulumi.Input[builtins.str] type: Type of the Cosmos DB Cassandra table column
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the Cosmos DB Cassandra table column
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of the Cosmos DB Cassandra table column
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CompositePathArgsDict(TypedDict):
        order: NotRequired[pulumi.Input[Union[builtins.str, 'CompositePathSortOrder']]]
        """
        Sort order for composite paths.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
elif False:
    CompositePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CompositePathArgs:
    def __init__(__self__, *,
                 order: Optional[pulumi.Input[Union[builtins.str, 'CompositePathSortOrder']]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Union[builtins.str, 'CompositePathSortOrder']] order: Sort order for composite paths.
        :param pulumi.Input[builtins.str] path: The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
        if order is not None:
            pulumi.set(__self__, "order", order)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[Union[builtins.str, 'CompositePathSortOrder']]]:
        """
        Sort order for composite paths.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[Union[builtins.str, 'CompositePathSortOrder']]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ComputedPropertyArgsDict(TypedDict):
        """
        The definition of a computed property
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of a computed property, for example - "cp_lowerName"
        """
        query: NotRequired[pulumi.Input[builtins.str]]
        """
        The query that evaluates the value for computed property, for example - "SELECT VALUE LOWER(c.name) FROM c"
        """
elif False:
    ComputedPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputedPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 query: Optional[pulumi.Input[builtins.str]] = None):
        """
        The definition of a computed property
        :param pulumi.Input[builtins.str] name: The name of a computed property, for example - "cp_lowerName"
        :param pulumi.Input[builtins.str] query: The query that evaluates the value for computed property, for example - "SELECT VALUE LOWER(c.name) FROM c"
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of a computed property, for example - "cp_lowerName"
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The query that evaluates the value for computed property, for example - "SELECT VALUE LOWER(c.name) FROM c"
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "query", value)


if not MYPY:
    class ConflictResolutionPolicyArgsDict(TypedDict):
        """
        The conflict resolution policy for the container.
        """
        conflict_resolution_path: NotRequired[pulumi.Input[builtins.str]]
        """
        The conflict resolution path in the case of LastWriterWins mode.
        """
        conflict_resolution_procedure: NotRequired[pulumi.Input[builtins.str]]
        """
        The procedure to resolve conflicts in the case of custom mode.
        """
        mode: NotRequired[pulumi.Input[Union[builtins.str, 'ConflictResolutionMode']]]
        """
        Indicates the conflict resolution mode.
        """
elif False:
    ConflictResolutionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConflictResolutionPolicyArgs:
    def __init__(__self__, *,
                 conflict_resolution_path: Optional[pulumi.Input[builtins.str]] = None,
                 conflict_resolution_procedure: Optional[pulumi.Input[builtins.str]] = None,
                 mode: Optional[pulumi.Input[Union[builtins.str, 'ConflictResolutionMode']]] = None):
        """
        The conflict resolution policy for the container.
        :param pulumi.Input[builtins.str] conflict_resolution_path: The conflict resolution path in the case of LastWriterWins mode.
        :param pulumi.Input[builtins.str] conflict_resolution_procedure: The procedure to resolve conflicts in the case of custom mode.
        :param pulumi.Input[Union[builtins.str, 'ConflictResolutionMode']] mode: Indicates the conflict resolution mode.
        """
        if conflict_resolution_path is not None:
            pulumi.set(__self__, "conflict_resolution_path", conflict_resolution_path)
        if conflict_resolution_procedure is not None:
            pulumi.set(__self__, "conflict_resolution_procedure", conflict_resolution_procedure)
        if mode is None:
            mode = 'LastWriterWins'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="conflictResolutionPath")
    def conflict_resolution_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The conflict resolution path in the case of LastWriterWins mode.
        """
        return pulumi.get(self, "conflict_resolution_path")

    @conflict_resolution_path.setter
    def conflict_resolution_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "conflict_resolution_path", value)

    @property
    @pulumi.getter(name="conflictResolutionProcedure")
    def conflict_resolution_procedure(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The procedure to resolve conflicts in the case of custom mode.
        """
        return pulumi.get(self, "conflict_resolution_procedure")

    @conflict_resolution_procedure.setter
    def conflict_resolution_procedure(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "conflict_resolution_procedure", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'ConflictResolutionMode']]]:
        """
        Indicates the conflict resolution mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'ConflictResolutionMode']]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ConsistencyPolicyArgsDict(TypedDict):
        """
        The consistency policy for the Cosmos DB database account.
        """
        default_consistency_level: pulumi.Input['DefaultConsistencyLevel']
        """
        The default consistency level and configuration settings of the Cosmos DB account.
        """
        max_interval_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        When used with the Bounded Staleness consistency level, this value represents the time amount of staleness (in seconds) tolerated. Accepted range for this value is 5 - 86400. Required when defaultConsistencyPolicy is set to 'BoundedStaleness'.
        """
        max_staleness_prefix: NotRequired[pulumi.Input[builtins.float]]
        """
        When used with the Bounded Staleness consistency level, this value represents the number of stale requests tolerated. Accepted range for this value is 1  2,147,483,647. Required when defaultConsistencyPolicy is set to 'BoundedStaleness'.
        """
elif False:
    ConsistencyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConsistencyPolicyArgs:
    def __init__(__self__, *,
                 default_consistency_level: pulumi.Input['DefaultConsistencyLevel'],
                 max_interval_in_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 max_staleness_prefix: Optional[pulumi.Input[builtins.float]] = None):
        """
        The consistency policy for the Cosmos DB database account.
        :param pulumi.Input['DefaultConsistencyLevel'] default_consistency_level: The default consistency level and configuration settings of the Cosmos DB account.
        :param pulumi.Input[builtins.int] max_interval_in_seconds: When used with the Bounded Staleness consistency level, this value represents the time amount of staleness (in seconds) tolerated. Accepted range for this value is 5 - 86400. Required when defaultConsistencyPolicy is set to 'BoundedStaleness'.
        :param pulumi.Input[builtins.float] max_staleness_prefix: When used with the Bounded Staleness consistency level, this value represents the number of stale requests tolerated. Accepted range for this value is 1  2,147,483,647. Required when defaultConsistencyPolicy is set to 'BoundedStaleness'.
        """
        pulumi.set(__self__, "default_consistency_level", default_consistency_level)
        if max_interval_in_seconds is not None:
            pulumi.set(__self__, "max_interval_in_seconds", max_interval_in_seconds)
        if max_staleness_prefix is not None:
            pulumi.set(__self__, "max_staleness_prefix", max_staleness_prefix)

    @property
    @pulumi.getter(name="defaultConsistencyLevel")
    def default_consistency_level(self) -> pulumi.Input['DefaultConsistencyLevel']:
        """
        The default consistency level and configuration settings of the Cosmos DB account.
        """
        return pulumi.get(self, "default_consistency_level")

    @default_consistency_level.setter
    def default_consistency_level(self, value: pulumi.Input['DefaultConsistencyLevel']):
        pulumi.set(self, "default_consistency_level", value)

    @property
    @pulumi.getter(name="maxIntervalInSeconds")
    def max_interval_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        When used with the Bounded Staleness consistency level, this value represents the time amount of staleness (in seconds) tolerated. Accepted range for this value is 5 - 86400. Required when defaultConsistencyPolicy is set to 'BoundedStaleness'.
        """
        return pulumi.get(self, "max_interval_in_seconds")

    @max_interval_in_seconds.setter
    def max_interval_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_interval_in_seconds", value)

    @property
    @pulumi.getter(name="maxStalenessPrefix")
    def max_staleness_prefix(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        When used with the Bounded Staleness consistency level, this value represents the number of stale requests tolerated. Accepted range for this value is 1  2,147,483,647. Required when defaultConsistencyPolicy is set to 'BoundedStaleness'.
        """
        return pulumi.get(self, "max_staleness_prefix")

    @max_staleness_prefix.setter
    def max_staleness_prefix(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "max_staleness_prefix", value)


if not MYPY:
    class ContainerPartitionKeyArgsDict(TypedDict):
        """
        The configuration of the partition key to be used for partitioning data into multiple partitions
        """
        kind: NotRequired[pulumi.Input[Union[builtins.str, 'PartitionKind']]]
        """
        Indicates the kind of algorithm used for partitioning. For MultiHash, multiple partition keys (upto three maximum) are supported for container create
        """
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of paths using which data within the container can be partitioned
        """
        version: NotRequired[pulumi.Input[builtins.int]]
        """
        Indicates the version of the partition key definition
        """
elif False:
    ContainerPartitionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerPartitionKeyArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[Union[builtins.str, 'PartitionKind']]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 version: Optional[pulumi.Input[builtins.int]] = None):
        """
        The configuration of the partition key to be used for partitioning data into multiple partitions
        :param pulumi.Input[Union[builtins.str, 'PartitionKind']] kind: Indicates the kind of algorithm used for partitioning. For MultiHash, multiple partition keys (upto three maximum) are supported for container create
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] paths: List of paths using which data within the container can be partitioned
        :param pulumi.Input[builtins.int] version: Indicates the version of the partition key definition
        """
        if kind is None:
            kind = 'Hash'
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[Union[builtins.str, 'PartitionKind']]]:
        """
        Indicates the kind of algorithm used for partitioning. For MultiHash, multiple partition keys (upto three maximum) are supported for container create
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[Union[builtins.str, 'PartitionKind']]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of paths using which data within the container can be partitioned
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "paths", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Indicates the version of the partition key definition
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ContinuousModeBackupPolicyArgsDict(TypedDict):
        """
        The object representing continuous mode backup policy.
        """
        type: pulumi.Input[builtins.str]
        """
        Describes the mode of backups.
        Expected value is 'Continuous'.
        """
        continuous_mode_properties: NotRequired[pulumi.Input['ContinuousModePropertiesArgsDict']]
        """
        Configuration values for continuous mode backup
        """
        migration_state: NotRequired[pulumi.Input['BackupPolicyMigrationStateArgsDict']]
        """
        The object representing the state of the migration between the backup policies.
        """
elif False:
    ContinuousModeBackupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContinuousModeBackupPolicyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 continuous_mode_properties: Optional[pulumi.Input['ContinuousModePropertiesArgs']] = None,
                 migration_state: Optional[pulumi.Input['BackupPolicyMigrationStateArgs']] = None):
        """
        The object representing continuous mode backup policy.
        :param pulumi.Input[builtins.str] type: Describes the mode of backups.
               Expected value is 'Continuous'.
        :param pulumi.Input['ContinuousModePropertiesArgs'] continuous_mode_properties: Configuration values for continuous mode backup
        :param pulumi.Input['BackupPolicyMigrationStateArgs'] migration_state: The object representing the state of the migration between the backup policies.
        """
        pulumi.set(__self__, "type", 'Continuous')
        if continuous_mode_properties is not None:
            pulumi.set(__self__, "continuous_mode_properties", continuous_mode_properties)
        if migration_state is not None:
            pulumi.set(__self__, "migration_state", migration_state)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Describes the mode of backups.
        Expected value is 'Continuous'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="continuousModeProperties")
    def continuous_mode_properties(self) -> Optional[pulumi.Input['ContinuousModePropertiesArgs']]:
        """
        Configuration values for continuous mode backup
        """
        return pulumi.get(self, "continuous_mode_properties")

    @continuous_mode_properties.setter
    def continuous_mode_properties(self, value: Optional[pulumi.Input['ContinuousModePropertiesArgs']]):
        pulumi.set(self, "continuous_mode_properties", value)

    @property
    @pulumi.getter(name="migrationState")
    def migration_state(self) -> Optional[pulumi.Input['BackupPolicyMigrationStateArgs']]:
        """
        The object representing the state of the migration between the backup policies.
        """
        return pulumi.get(self, "migration_state")

    @migration_state.setter
    def migration_state(self, value: Optional[pulumi.Input['BackupPolicyMigrationStateArgs']]):
        pulumi.set(self, "migration_state", value)


if not MYPY:
    class ContinuousModePropertiesArgsDict(TypedDict):
        """
        Configuration values for periodic mode backup
        """
        tier: NotRequired[pulumi.Input[Union[builtins.str, 'ContinuousTier']]]
        """
        Enum to indicate type of Continuous backup mode
        """
elif False:
    ContinuousModePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContinuousModePropertiesArgs:
    def __init__(__self__, *,
                 tier: Optional[pulumi.Input[Union[builtins.str, 'ContinuousTier']]] = None):
        """
        Configuration values for periodic mode backup
        :param pulumi.Input[Union[builtins.str, 'ContinuousTier']] tier: Enum to indicate type of Continuous backup mode
        """
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def tier(self) -> Optional[pulumi.Input[Union[builtins.str, 'ContinuousTier']]]:
        """
        Enum to indicate type of Continuous backup mode
        """
        return pulumi.get(self, "tier")

    @tier.setter
    def tier(self, value: Optional[pulumi.Input[Union[builtins.str, 'ContinuousTier']]]):
        pulumi.set(self, "tier", value)


if not MYPY:
    class CorsPolicyArgsDict(TypedDict):
        """
        The CORS policy for the Cosmos DB database account.
        """
        allowed_origins: pulumi.Input[builtins.str]
        """
        The origin domains that are permitted to make a request against the service via CORS.
        """
        allowed_headers: NotRequired[pulumi.Input[builtins.str]]
        """
        The request headers that the origin domain may specify on the CORS request.
        """
        allowed_methods: NotRequired[pulumi.Input[builtins.str]]
        """
        The methods (HTTP request verbs) that the origin domain may use for a CORS request.
        """
        exposed_headers: NotRequired[pulumi.Input[builtins.str]]
        """
        The response headers that may be sent in the response to the CORS request and exposed by the browser to the request issuer.
        """
        max_age_in_seconds: NotRequired[pulumi.Input[builtins.float]]
        """
        The maximum amount time that a browser should cache the preflight OPTIONS request.
        """
elif False:
    CorsPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CorsPolicyArgs:
    def __init__(__self__, *,
                 allowed_origins: pulumi.Input[builtins.str],
                 allowed_headers: Optional[pulumi.Input[builtins.str]] = None,
                 allowed_methods: Optional[pulumi.Input[builtins.str]] = None,
                 exposed_headers: Optional[pulumi.Input[builtins.str]] = None,
                 max_age_in_seconds: Optional[pulumi.Input[builtins.float]] = None):
        """
        The CORS policy for the Cosmos DB database account.
        :param pulumi.Input[builtins.str] allowed_origins: The origin domains that are permitted to make a request against the service via CORS.
        :param pulumi.Input[builtins.str] allowed_headers: The request headers that the origin domain may specify on the CORS request.
        :param pulumi.Input[builtins.str] allowed_methods: The methods (HTTP request verbs) that the origin domain may use for a CORS request.
        :param pulumi.Input[builtins.str] exposed_headers: The response headers that may be sent in the response to the CORS request and exposed by the browser to the request issuer.
        :param pulumi.Input[builtins.float] max_age_in_seconds: The maximum amount time that a browser should cache the preflight OPTIONS request.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if exposed_headers is not None:
            pulumi.set(__self__, "exposed_headers", exposed_headers)
        if max_age_in_seconds is not None:
            pulumi.set(__self__, "max_age_in_seconds", max_age_in_seconds)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[builtins.str]:
        """
        The origin domains that are permitted to make a request against the service via CORS.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The request headers that the origin domain may specify on the CORS request.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The methods (HTTP request verbs) that the origin domain may use for a CORS request.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The response headers that may be sent in the response to the CORS request and exposed by the browser to the request issuer.
        """
        return pulumi.get(self, "exposed_headers")

    @exposed_headers.setter
    def exposed_headers(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "exposed_headers", value)

    @property
    @pulumi.getter(name="maxAgeInSeconds")
    def max_age_in_seconds(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The maximum amount time that a browser should cache the preflight OPTIONS request.
        """
        return pulumi.get(self, "max_age_in_seconds")

    @max_age_in_seconds.setter
    def max_age_in_seconds(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "max_age_in_seconds", value)


if not MYPY:
    class CreateUpdateOptionsArgsDict(TypedDict):
        """
        CreateUpdateOptions are a list of key-value pairs that describe the resource. Supported keys are "If-Match", "If-None-Match", "Session-Token" and "Throughput"
        """
        autoscale_settings: NotRequired[pulumi.Input['AutoscaleSettingsArgsDict']]
        """
        Specifies the Autoscale settings. Note: Either throughput or autoscaleSettings is required, but not both.
        """
        throughput: NotRequired[pulumi.Input[builtins.int]]
        """
        Request Units per second. For example, "throughput": 10000.
        """
elif False:
    CreateUpdateOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CreateUpdateOptionsArgs:
    def __init__(__self__, *,
                 autoscale_settings: Optional[pulumi.Input['AutoscaleSettingsArgs']] = None,
                 throughput: Optional[pulumi.Input[builtins.int]] = None):
        """
        CreateUpdateOptions are a list of key-value pairs that describe the resource. Supported keys are "If-Match", "If-None-Match", "Session-Token" and "Throughput"
        :param pulumi.Input['AutoscaleSettingsArgs'] autoscale_settings: Specifies the Autoscale settings. Note: Either throughput or autoscaleSettings is required, but not both.
        :param pulumi.Input[builtins.int] throughput: Request Units per second. For example, "throughput": 10000.
        """
        if autoscale_settings is not None:
            pulumi.set(__self__, "autoscale_settings", autoscale_settings)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @property
    @pulumi.getter(name="autoscaleSettings")
    def autoscale_settings(self) -> Optional[pulumi.Input['AutoscaleSettingsArgs']]:
        """
        Specifies the Autoscale settings. Note: Either throughput or autoscaleSettings is required, but not both.
        """
        return pulumi.get(self, "autoscale_settings")

    @autoscale_settings.setter
    def autoscale_settings(self, value: Optional[pulumi.Input['AutoscaleSettingsArgs']]):
        pulumi.set(self, "autoscale_settings", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Request Units per second. For example, "throughput": 10000.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class DataCenterResourcePropertiesArgsDict(TypedDict):
        """
        Properties of a managed Cassandra data center.
        """
        authentication_method_ldap_properties: NotRequired[pulumi.Input['AuthenticationMethodLdapPropertiesArgsDict']]
        """
        Ldap authentication method properties. This feature is in preview.
        """
        availability_zone: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the data center has Availability Zone support, apply it to the Virtual Machine ScaleSet that host the cassandra data center virtual machines.
        """
        backup_storage_customer_key_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the Key Uri of the customer key to use for encryption of the backup storage account.
        """
        base64_encoded_cassandra_yaml_fragment: NotRequired[pulumi.Input[builtins.str]]
        """
        A fragment of a cassandra.yaml configuration file to be included in the cassandra.yaml for all nodes in this data center. The fragment should be Base64 encoded, and only a subset of keys are allowed.
        """
        data_center_location: NotRequired[pulumi.Input[builtins.str]]
        """
        The region this data center should be created in.
        """
        deallocated: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the data center has been deallocated.
        """
        delegated_subnet_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource id of a subnet the nodes in this data center should have their network interfaces connected to. The subnet must be in the same region specified in 'dataCenterLocation' and must be able to route to the subnet specified in the cluster's 'delegatedManagementSubnetId' property. This resource id will be of the form '/subscriptions/<subscription id>/resourceGroups/<resource group>/providers/Microsoft.Network/virtualNetworks/<virtual network>/subnets/<subnet>'.
        """
        disk_capacity: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of disks attached to each node. Default is 4.
        """
        disk_sku: NotRequired[pulumi.Input[builtins.str]]
        """
        Disk SKU used for data centers. Default value is P30.
        """
        managed_disk_customer_key_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        Key uri to use for encryption of managed disks. Ensure the system assigned identity of the cluster has been assigned appropriate permissions(key get/wrap/unwrap permissions) on the key.
        """
        node_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of nodes the data center should have. This is the desired number. After it is set, it may take some time for the data center to be scaled to match. To monitor the number of nodes and their status, use the fetchNodeStatus method on the cluster.
        """
        private_endpoint_ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        Ip of the VPN Endpoint for this data center.
        """
        provision_error: NotRequired[pulumi.Input['CassandraErrorArgsDict']]
        """
        Error related to resource provisioning.
        """
        provisioning_state: NotRequired[pulumi.Input[Union[builtins.str, 'ManagedCassandraProvisioningState']]]
        """
        The status of the resource at the time the operation was called.
        """
        sku: NotRequired[pulumi.Input[builtins.str]]
        """
        Virtual Machine SKU used for data centers. Default value is Standard_DS14_v2
        """
elif False:
    DataCenterResourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataCenterResourcePropertiesArgs:
    def __init__(__self__, *,
                 authentication_method_ldap_properties: Optional[pulumi.Input['AuthenticationMethodLdapPropertiesArgs']] = None,
                 availability_zone: Optional[pulumi.Input[builtins.bool]] = None,
                 backup_storage_customer_key_uri: Optional[pulumi.Input[builtins.str]] = None,
                 base64_encoded_cassandra_yaml_fragment: Optional[pulumi.Input[builtins.str]] = None,
                 data_center_location: Optional[pulumi.Input[builtins.str]] = None,
                 deallocated: Optional[pulumi.Input[builtins.bool]] = None,
                 delegated_subnet_id: Optional[pulumi.Input[builtins.str]] = None,
                 disk_capacity: Optional[pulumi.Input[builtins.int]] = None,
                 disk_sku: Optional[pulumi.Input[builtins.str]] = None,
                 managed_disk_customer_key_uri: Optional[pulumi.Input[builtins.str]] = None,
                 node_count: Optional[pulumi.Input[builtins.int]] = None,
                 private_endpoint_ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 provision_error: Optional[pulumi.Input['CassandraErrorArgs']] = None,
                 provisioning_state: Optional[pulumi.Input[Union[builtins.str, 'ManagedCassandraProvisioningState']]] = None,
                 sku: Optional[pulumi.Input[builtins.str]] = None):
        """
        Properties of a managed Cassandra data center.
        :param pulumi.Input['AuthenticationMethodLdapPropertiesArgs'] authentication_method_ldap_properties: Ldap authentication method properties. This feature is in preview.
        :param pulumi.Input[builtins.bool] availability_zone: If the data center has Availability Zone support, apply it to the Virtual Machine ScaleSet that host the cassandra data center virtual machines.
        :param pulumi.Input[builtins.str] backup_storage_customer_key_uri: Indicates the Key Uri of the customer key to use for encryption of the backup storage account.
        :param pulumi.Input[builtins.str] base64_encoded_cassandra_yaml_fragment: A fragment of a cassandra.yaml configuration file to be included in the cassandra.yaml for all nodes in this data center. The fragment should be Base64 encoded, and only a subset of keys are allowed.
        :param pulumi.Input[builtins.str] data_center_location: The region this data center should be created in.
        :param pulumi.Input[builtins.bool] deallocated: Whether the data center has been deallocated.
        :param pulumi.Input[builtins.str] delegated_subnet_id: Resource id of a subnet the nodes in this data center should have their network interfaces connected to. The subnet must be in the same region specified in 'dataCenterLocation' and must be able to route to the subnet specified in the cluster's 'delegatedManagementSubnetId' property. This resource id will be of the form '/subscriptions/<subscription id>/resourceGroups/<resource group>/providers/Microsoft.Network/virtualNetworks/<virtual network>/subnets/<subnet>'.
        :param pulumi.Input[builtins.int] disk_capacity: Number of disks attached to each node. Default is 4.
        :param pulumi.Input[builtins.str] disk_sku: Disk SKU used for data centers. Default value is P30.
        :param pulumi.Input[builtins.str] managed_disk_customer_key_uri: Key uri to use for encryption of managed disks. Ensure the system assigned identity of the cluster has been assigned appropriate permissions(key get/wrap/unwrap permissions) on the key.
        :param pulumi.Input[builtins.int] node_count: The number of nodes the data center should have. This is the desired number. After it is set, it may take some time for the data center to be scaled to match. To monitor the number of nodes and their status, use the fetchNodeStatus method on the cluster.
        :param pulumi.Input[builtins.str] private_endpoint_ip_address: Ip of the VPN Endpoint for this data center.
        :param pulumi.Input['CassandraErrorArgs'] provision_error: Error related to resource provisioning.
        :param pulumi.Input[Union[builtins.str, 'ManagedCassandraProvisioningState']] provisioning_state: The status of the resource at the time the operation was called.
        :param pulumi.Input[builtins.str] sku: Virtual Machine SKU used for data centers. Default value is Standard_DS14_v2
        """
        if authentication_method_ldap_properties is not None:
            pulumi.set(__self__, "authentication_method_ldap_properties", authentication_method_ldap_properties)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if backup_storage_customer_key_uri is not None:
            pulumi.set(__self__, "backup_storage_customer_key_uri", backup_storage_customer_key_uri)
        if base64_encoded_cassandra_yaml_fragment is not None:
            pulumi.set(__self__, "base64_encoded_cassandra_yaml_fragment", base64_encoded_cassandra_yaml_fragment)
        if data_center_location is not None:
            pulumi.set(__self__, "data_center_location", data_center_location)
        if deallocated is not None:
            pulumi.set(__self__, "deallocated", deallocated)
        if delegated_subnet_id is not None:
            pulumi.set(__self__, "delegated_subnet_id", delegated_subnet_id)
        if disk_capacity is not None:
            pulumi.set(__self__, "disk_capacity", disk_capacity)
        if disk_sku is not None:
            pulumi.set(__self__, "disk_sku", disk_sku)
        if managed_disk_customer_key_uri is not None:
            pulumi.set(__self__, "managed_disk_customer_key_uri", managed_disk_customer_key_uri)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if private_endpoint_ip_address is not None:
            pulumi.set(__self__, "private_endpoint_ip_address", private_endpoint_ip_address)
        if provision_error is not None:
            pulumi.set(__self__, "provision_error", provision_error)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter(name="authenticationMethodLdapProperties")
    def authentication_method_ldap_properties(self) -> Optional[pulumi.Input['AuthenticationMethodLdapPropertiesArgs']]:
        """
        Ldap authentication method properties. This feature is in preview.
        """
        return pulumi.get(self, "authentication_method_ldap_properties")

    @authentication_method_ldap_properties.setter
    def authentication_method_ldap_properties(self, value: Optional[pulumi.Input['AuthenticationMethodLdapPropertiesArgs']]):
        pulumi.set(self, "authentication_method_ldap_properties", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the data center has Availability Zone support, apply it to the Virtual Machine ScaleSet that host the cassandra data center virtual machines.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="backupStorageCustomerKeyUri")
    def backup_storage_customer_key_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the Key Uri of the customer key to use for encryption of the backup storage account.
        """
        return pulumi.get(self, "backup_storage_customer_key_uri")

    @backup_storage_customer_key_uri.setter
    def backup_storage_customer_key_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backup_storage_customer_key_uri", value)

    @property
    @pulumi.getter(name="base64EncodedCassandraYamlFragment")
    def base64_encoded_cassandra_yaml_fragment(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A fragment of a cassandra.yaml configuration file to be included in the cassandra.yaml for all nodes in this data center. The fragment should be Base64 encoded, and only a subset of keys are allowed.
        """
        return pulumi.get(self, "base64_encoded_cassandra_yaml_fragment")

    @base64_encoded_cassandra_yaml_fragment.setter
    def base64_encoded_cassandra_yaml_fragment(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base64_encoded_cassandra_yaml_fragment", value)

    @property
    @pulumi.getter(name="dataCenterLocation")
    def data_center_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The region this data center should be created in.
        """
        return pulumi.get(self, "data_center_location")

    @data_center_location.setter
    def data_center_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_center_location", value)

    @property
    @pulumi.getter
    def deallocated(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the data center has been deallocated.
        """
        return pulumi.get(self, "deallocated")

    @deallocated.setter
    def deallocated(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "deallocated", value)

    @property
    @pulumi.getter(name="delegatedSubnetId")
    def delegated_subnet_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource id of a subnet the nodes in this data center should have their network interfaces connected to. The subnet must be in the same region specified in 'dataCenterLocation' and must be able to route to the subnet specified in the cluster's 'delegatedManagementSubnetId' property. This resource id will be of the form '/subscriptions/<subscription id>/resourceGroups/<resource group>/providers/Microsoft.Network/virtualNetworks/<virtual network>/subnets/<subnet>'.
        """
        return pulumi.get(self, "delegated_subnet_id")

    @delegated_subnet_id.setter
    def delegated_subnet_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delegated_subnet_id", value)

    @property
    @pulumi.getter(name="diskCapacity")
    def disk_capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of disks attached to each node. Default is 4.
        """
        return pulumi.get(self, "disk_capacity")

    @disk_capacity.setter
    def disk_capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "disk_capacity", value)

    @property
    @pulumi.getter(name="diskSku")
    def disk_sku(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Disk SKU used for data centers. Default value is P30.
        """
        return pulumi.get(self, "disk_sku")

    @disk_sku.setter
    def disk_sku(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "disk_sku", value)

    @property
    @pulumi.getter(name="managedDiskCustomerKeyUri")
    def managed_disk_customer_key_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Key uri to use for encryption of managed disks. Ensure the system assigned identity of the cluster has been assigned appropriate permissions(key get/wrap/unwrap permissions) on the key.
        """
        return pulumi.get(self, "managed_disk_customer_key_uri")

    @managed_disk_customer_key_uri.setter
    def managed_disk_customer_key_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "managed_disk_customer_key_uri", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of nodes the data center should have. This is the desired number. After it is set, it may take some time for the data center to be scaled to match. To monitor the number of nodes and their status, use the fetchNodeStatus method on the cluster.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter(name="privateEndpointIpAddress")
    def private_endpoint_ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Ip of the VPN Endpoint for this data center.
        """
        return pulumi.get(self, "private_endpoint_ip_address")

    @private_endpoint_ip_address.setter
    def private_endpoint_ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_endpoint_ip_address", value)

    @property
    @pulumi.getter(name="provisionError")
    def provision_error(self) -> Optional[pulumi.Input['CassandraErrorArgs']]:
        """
        Error related to resource provisioning.
        """
        return pulumi.get(self, "provision_error")

    @provision_error.setter
    def provision_error(self, value: Optional[pulumi.Input['CassandraErrorArgs']]):
        pulumi.set(self, "provision_error", value)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[pulumi.Input[Union[builtins.str, 'ManagedCassandraProvisioningState']]]:
        """
        The status of the resource at the time the operation was called.
        """
        return pulumi.get(self, "provisioning_state")

    @provisioning_state.setter
    def provisioning_state(self, value: Optional[pulumi.Input[Union[builtins.str, 'ManagedCassandraProvisioningState']]]):
        pulumi.set(self, "provisioning_state", value)

    @property
    @pulumi.getter
    def sku(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Virtual Machine SKU used for data centers. Default value is Standard_DS14_v2
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sku", value)


if not MYPY:
    class DataTransferServiceResourceCreateUpdatePropertiesArgsDict(TypedDict):
        """
        Properties for Create or Update request for DataTransferServiceResource
        """
        service_type: pulumi.Input[builtins.str]
        """
        ServiceType for the service.
        Expected value is 'DataTransfer'.
        """
        instance_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Instance count for the service.
        """
        instance_size: NotRequired[pulumi.Input[Union[builtins.str, 'ServiceSize']]]
        """
        Instance type for the service.
        """
elif False:
    DataTransferServiceResourceCreateUpdatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataTransferServiceResourceCreateUpdatePropertiesArgs:
    def __init__(__self__, *,
                 service_type: pulumi.Input[builtins.str],
                 instance_count: Optional[pulumi.Input[builtins.int]] = None,
                 instance_size: Optional[pulumi.Input[Union[builtins.str, 'ServiceSize']]] = None):
        """
        Properties for Create or Update request for DataTransferServiceResource
        :param pulumi.Input[builtins.str] service_type: ServiceType for the service.
               Expected value is 'DataTransfer'.
        :param pulumi.Input[builtins.int] instance_count: Instance count for the service.
        :param pulumi.Input[Union[builtins.str, 'ServiceSize']] instance_size: Instance type for the service.
        """
        pulumi.set(__self__, "service_type", 'DataTransfer')
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size is not None:
            pulumi.set(__self__, "instance_size", instance_size)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> pulumi.Input[builtins.str]:
        """
        ServiceType for the service.
        Expected value is 'DataTransfer'.
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_type", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Instance count for the service.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> Optional[pulumi.Input[Union[builtins.str, 'ServiceSize']]]:
        """
        Instance type for the service.
        """
        return pulumi.get(self, "instance_size")

    @instance_size.setter
    def instance_size(self, value: Optional[pulumi.Input[Union[builtins.str, 'ServiceSize']]]):
        pulumi.set(self, "instance_size", value)


if not MYPY:
    class DatabaseRestoreResourceArgsDict(TypedDict):
        """
        Specific Databases to restore.
        """
        collection_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The names of the collections available for restore.
        """
        database_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the database available for restore.
        """
elif False:
    DatabaseRestoreResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseRestoreResourceArgs:
    def __init__(__self__, *,
                 collection_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 database_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Specific Databases to restore.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] collection_names: The names of the collections available for restore.
        :param pulumi.Input[builtins.str] database_name: The name of the database available for restore.
        """
        if collection_names is not None:
            pulumi.set(__self__, "collection_names", collection_names)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="collectionNames")
    def collection_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The names of the collections available for restore.
        """
        return pulumi.get(self, "collection_names")

    @collection_names.setter
    def collection_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "collection_names", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the database available for restore.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "database_name", value)


if not MYPY:
    class ExcludedPathArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
elif False:
    ExcludedPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExcludedPathArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] path: The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class FleetspacePropertiesThroughputPoolConfigurationArgsDict(TypedDict):
        """
        Configuration for throughput pool in the fleetspace.
        """
        data_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of data regions assigned to the fleetspace. Eg [westus2]
        """
        max_throughput: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum throughput for the pool.
        """
        min_throughput: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum throughput for the pool.
        """
        service_tier: NotRequired[pulumi.Input[Union[builtins.str, 'ServiceTier']]]
        """
        Service Tier for the fleetspace. GeneralPurpose types refers to single write region accounts that can be added to this fleetspace, whereas BusinessCritical refers to multi write region.
        """
elif False:
    FleetspacePropertiesThroughputPoolConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetspacePropertiesThroughputPoolConfigurationArgs:
    def __init__(__self__, *,
                 data_regions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 max_throughput: Optional[pulumi.Input[builtins.int]] = None,
                 min_throughput: Optional[pulumi.Input[builtins.int]] = None,
                 service_tier: Optional[pulumi.Input[Union[builtins.str, 'ServiceTier']]] = None):
        """
        Configuration for throughput pool in the fleetspace.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] data_regions: List of data regions assigned to the fleetspace. Eg [westus2]
        :param pulumi.Input[builtins.int] max_throughput: Maximum throughput for the pool.
        :param pulumi.Input[builtins.int] min_throughput: Minimum throughput for the pool.
        :param pulumi.Input[Union[builtins.str, 'ServiceTier']] service_tier: Service Tier for the fleetspace. GeneralPurpose types refers to single write region accounts that can be added to this fleetspace, whereas BusinessCritical refers to multi write region.
        """
        if data_regions is not None:
            pulumi.set(__self__, "data_regions", data_regions)
        if max_throughput is not None:
            pulumi.set(__self__, "max_throughput", max_throughput)
        if min_throughput is not None:
            pulumi.set(__self__, "min_throughput", min_throughput)
        if service_tier is not None:
            pulumi.set(__self__, "service_tier", service_tier)

    @property
    @pulumi.getter(name="dataRegions")
    def data_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of data regions assigned to the fleetspace. Eg [westus2]
        """
        return pulumi.get(self, "data_regions")

    @data_regions.setter
    def data_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "data_regions", value)

    @property
    @pulumi.getter(name="maxThroughput")
    def max_throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum throughput for the pool.
        """
        return pulumi.get(self, "max_throughput")

    @max_throughput.setter
    def max_throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_throughput", value)

    @property
    @pulumi.getter(name="minThroughput")
    def min_throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum throughput for the pool.
        """
        return pulumi.get(self, "min_throughput")

    @min_throughput.setter
    def min_throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_throughput", value)

    @property
    @pulumi.getter(name="serviceTier")
    def service_tier(self) -> Optional[pulumi.Input[Union[builtins.str, 'ServiceTier']]]:
        """
        Service Tier for the fleetspace. GeneralPurpose types refers to single write region accounts that can be added to this fleetspace, whereas BusinessCritical refers to multi write region.
        """
        return pulumi.get(self, "service_tier")

    @service_tier.setter
    def service_tier(self, value: Optional[pulumi.Input[Union[builtins.str, 'ServiceTier']]]):
        pulumi.set(self, "service_tier", value)


if not MYPY:
    class GraphAPIComputeServiceResourceCreateUpdatePropertiesArgsDict(TypedDict):
        """
        Properties for Create or Update request for GraphAPIComputeServiceResource
        """
        service_type: pulumi.Input[builtins.str]
        """
        ServiceType for the service.
        Expected value is 'GraphAPICompute'.
        """
        instance_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Instance count for the service.
        """
        instance_size: NotRequired[pulumi.Input[Union[builtins.str, 'ServiceSize']]]
        """
        Instance type for the service.
        """
elif False:
    GraphAPIComputeServiceResourceCreateUpdatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GraphAPIComputeServiceResourceCreateUpdatePropertiesArgs:
    def __init__(__self__, *,
                 service_type: pulumi.Input[builtins.str],
                 instance_count: Optional[pulumi.Input[builtins.int]] = None,
                 instance_size: Optional[pulumi.Input[Union[builtins.str, 'ServiceSize']]] = None):
        """
        Properties for Create or Update request for GraphAPIComputeServiceResource
        :param pulumi.Input[builtins.str] service_type: ServiceType for the service.
               Expected value is 'GraphAPICompute'.
        :param pulumi.Input[builtins.int] instance_count: Instance count for the service.
        :param pulumi.Input[Union[builtins.str, 'ServiceSize']] instance_size: Instance type for the service.
        """
        pulumi.set(__self__, "service_type", 'GraphAPICompute')
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size is not None:
            pulumi.set(__self__, "instance_size", instance_size)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> pulumi.Input[builtins.str]:
        """
        ServiceType for the service.
        Expected value is 'GraphAPICompute'.
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_type", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Instance count for the service.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> Optional[pulumi.Input[Union[builtins.str, 'ServiceSize']]]:
        """
        Instance type for the service.
        """
        return pulumi.get(self, "instance_size")

    @instance_size.setter
    def instance_size(self, value: Optional[pulumi.Input[Union[builtins.str, 'ServiceSize']]]):
        pulumi.set(self, "instance_size", value)


if not MYPY:
    class GraphResourceArgsDict(TypedDict):
        """
        Cosmos DB Graph resource object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB Graph
        """
elif False:
    GraphResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GraphResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str]):
        """
        Cosmos DB Graph resource object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB Graph
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB Graph
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class GremlinDatabaseResourceArgsDict(TypedDict):
        """
        Cosmos DB Gremlin database resource object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB Gremlin database
        """
        create_mode: NotRequired[pulumi.Input[Union[builtins.str, 'CreateMode']]]
        """
        Enum to indicate the mode of resource creation.
        """
        restore_parameters: NotRequired[pulumi.Input['ResourceRestoreParametersArgsDict']]
        """
        Parameters to indicate the information about the restore
        """
elif False:
    GremlinDatabaseResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GremlinDatabaseResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 create_mode: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]] = None,
                 restore_parameters: Optional[pulumi.Input['ResourceRestoreParametersArgs']] = None):
        """
        Cosmos DB Gremlin database resource object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB Gremlin database
        :param pulumi.Input[Union[builtins.str, 'CreateMode']] create_mode: Enum to indicate the mode of resource creation.
        :param pulumi.Input['ResourceRestoreParametersArgs'] restore_parameters: Parameters to indicate the information about the restore
        """
        pulumi.set(__self__, "id", id)
        if create_mode is not None:
            pulumi.set(__self__, "create_mode", create_mode)
        if restore_parameters is not None:
            pulumi.set(__self__, "restore_parameters", restore_parameters)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB Gremlin database
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]:
        """
        Enum to indicate the mode of resource creation.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="restoreParameters")
    def restore_parameters(self) -> Optional[pulumi.Input['ResourceRestoreParametersArgs']]:
        """
        Parameters to indicate the information about the restore
        """
        return pulumi.get(self, "restore_parameters")

    @restore_parameters.setter
    def restore_parameters(self, value: Optional[pulumi.Input['ResourceRestoreParametersArgs']]):
        pulumi.set(self, "restore_parameters", value)


if not MYPY:
    class GremlinDatabaseRestoreResourceArgsDict(TypedDict):
        """
        Specific Gremlin Databases to restore.
        """
        database_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the gremlin database available for restore.
        """
        graph_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The names of the graphs available for restore.
        """
elif False:
    GremlinDatabaseRestoreResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GremlinDatabaseRestoreResourceArgs:
    def __init__(__self__, *,
                 database_name: Optional[pulumi.Input[builtins.str]] = None,
                 graph_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Specific Gremlin Databases to restore.
        :param pulumi.Input[builtins.str] database_name: The name of the gremlin database available for restore.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] graph_names: The names of the graphs available for restore.
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if graph_names is not None:
            pulumi.set(__self__, "graph_names", graph_names)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the gremlin database available for restore.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="graphNames")
    def graph_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The names of the graphs available for restore.
        """
        return pulumi.get(self, "graph_names")

    @graph_names.setter
    def graph_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "graph_names", value)


if not MYPY:
    class GremlinGraphResourceArgsDict(TypedDict):
        """
        Cosmos DB Gremlin graph resource object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB Gremlin graph
        """
        analytical_storage_ttl: NotRequired[pulumi.Input[builtins.float]]
        """
        Analytical TTL.
        """
        conflict_resolution_policy: NotRequired[pulumi.Input['ConflictResolutionPolicyArgsDict']]
        """
        The conflict resolution policy for the graph.
        """
        create_mode: NotRequired[pulumi.Input[Union[builtins.str, 'CreateMode']]]
        """
        Enum to indicate the mode of resource creation.
        """
        default_ttl: NotRequired[pulumi.Input[builtins.int]]
        """
        Default time to live
        """
        indexing_policy: NotRequired[pulumi.Input['IndexingPolicyArgsDict']]
        """
        The configuration of the indexing policy. By default, the indexing is automatic for all document paths within the graph
        """
        partition_key: NotRequired[pulumi.Input['ContainerPartitionKeyArgsDict']]
        """
        The configuration of the partition key to be used for partitioning data into multiple partitions
        """
        restore_parameters: NotRequired[pulumi.Input['ResourceRestoreParametersArgsDict']]
        """
        Parameters to indicate the information about the restore
        """
        unique_key_policy: NotRequired[pulumi.Input['UniqueKeyPolicyArgsDict']]
        """
        The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        """
elif False:
    GremlinGraphResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GremlinGraphResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 analytical_storage_ttl: Optional[pulumi.Input[builtins.float]] = None,
                 conflict_resolution_policy: Optional[pulumi.Input['ConflictResolutionPolicyArgs']] = None,
                 create_mode: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]] = None,
                 default_ttl: Optional[pulumi.Input[builtins.int]] = None,
                 indexing_policy: Optional[pulumi.Input['IndexingPolicyArgs']] = None,
                 partition_key: Optional[pulumi.Input['ContainerPartitionKeyArgs']] = None,
                 restore_parameters: Optional[pulumi.Input['ResourceRestoreParametersArgs']] = None,
                 unique_key_policy: Optional[pulumi.Input['UniqueKeyPolicyArgs']] = None):
        """
        Cosmos DB Gremlin graph resource object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB Gremlin graph
        :param pulumi.Input[builtins.float] analytical_storage_ttl: Analytical TTL.
        :param pulumi.Input['ConflictResolutionPolicyArgs'] conflict_resolution_policy: The conflict resolution policy for the graph.
        :param pulumi.Input[Union[builtins.str, 'CreateMode']] create_mode: Enum to indicate the mode of resource creation.
        :param pulumi.Input[builtins.int] default_ttl: Default time to live
        :param pulumi.Input['IndexingPolicyArgs'] indexing_policy: The configuration of the indexing policy. By default, the indexing is automatic for all document paths within the graph
        :param pulumi.Input['ContainerPartitionKeyArgs'] partition_key: The configuration of the partition key to be used for partitioning data into multiple partitions
        :param pulumi.Input['ResourceRestoreParametersArgs'] restore_parameters: Parameters to indicate the information about the restore
        :param pulumi.Input['UniqueKeyPolicyArgs'] unique_key_policy: The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        """
        pulumi.set(__self__, "id", id)
        if analytical_storage_ttl is not None:
            pulumi.set(__self__, "analytical_storage_ttl", analytical_storage_ttl)
        if conflict_resolution_policy is not None:
            pulumi.set(__self__, "conflict_resolution_policy", conflict_resolution_policy)
        if create_mode is not None:
            pulumi.set(__self__, "create_mode", create_mode)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if indexing_policy is not None:
            pulumi.set(__self__, "indexing_policy", indexing_policy)
        if partition_key is not None:
            pulumi.set(__self__, "partition_key", partition_key)
        if restore_parameters is not None:
            pulumi.set(__self__, "restore_parameters", restore_parameters)
        if unique_key_policy is not None:
            pulumi.set(__self__, "unique_key_policy", unique_key_policy)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB Gremlin graph
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="analyticalStorageTtl")
    def analytical_storage_ttl(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Analytical TTL.
        """
        return pulumi.get(self, "analytical_storage_ttl")

    @analytical_storage_ttl.setter
    def analytical_storage_ttl(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "analytical_storage_ttl", value)

    @property
    @pulumi.getter(name="conflictResolutionPolicy")
    def conflict_resolution_policy(self) -> Optional[pulumi.Input['ConflictResolutionPolicyArgs']]:
        """
        The conflict resolution policy for the graph.
        """
        return pulumi.get(self, "conflict_resolution_policy")

    @conflict_resolution_policy.setter
    def conflict_resolution_policy(self, value: Optional[pulumi.Input['ConflictResolutionPolicyArgs']]):
        pulumi.set(self, "conflict_resolution_policy", value)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]:
        """
        Enum to indicate the mode of resource creation.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Default time to live
        """
        return pulumi.get(self, "default_ttl")

    @default_ttl.setter
    def default_ttl(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "default_ttl", value)

    @property
    @pulumi.getter(name="indexingPolicy")
    def indexing_policy(self) -> Optional[pulumi.Input['IndexingPolicyArgs']]:
        """
        The configuration of the indexing policy. By default, the indexing is automatic for all document paths within the graph
        """
        return pulumi.get(self, "indexing_policy")

    @indexing_policy.setter
    def indexing_policy(self, value: Optional[pulumi.Input['IndexingPolicyArgs']]):
        pulumi.set(self, "indexing_policy", value)

    @property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> Optional[pulumi.Input['ContainerPartitionKeyArgs']]:
        """
        The configuration of the partition key to be used for partitioning data into multiple partitions
        """
        return pulumi.get(self, "partition_key")

    @partition_key.setter
    def partition_key(self, value: Optional[pulumi.Input['ContainerPartitionKeyArgs']]):
        pulumi.set(self, "partition_key", value)

    @property
    @pulumi.getter(name="restoreParameters")
    def restore_parameters(self) -> Optional[pulumi.Input['ResourceRestoreParametersArgs']]:
        """
        Parameters to indicate the information about the restore
        """
        return pulumi.get(self, "restore_parameters")

    @restore_parameters.setter
    def restore_parameters(self, value: Optional[pulumi.Input['ResourceRestoreParametersArgs']]):
        pulumi.set(self, "restore_parameters", value)

    @property
    @pulumi.getter(name="uniqueKeyPolicy")
    def unique_key_policy(self) -> Optional[pulumi.Input['UniqueKeyPolicyArgs']]:
        """
        The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        """
        return pulumi.get(self, "unique_key_policy")

    @unique_key_policy.setter
    def unique_key_policy(self, value: Optional[pulumi.Input['UniqueKeyPolicyArgs']]):
        pulumi.set(self, "unique_key_policy", value)


if not MYPY:
    class IncludedPathArgsDict(TypedDict):
        """
        The paths that are included in indexing
        """
        indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input['IndexesArgsDict']]]]
        """
        List of indexes for this path
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
elif False:
    IncludedPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncludedPathArgs:
    def __init__(__self__, *,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input['IndexesArgs']]]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None):
        """
        The paths that are included in indexing
        :param pulumi.Input[Sequence[pulumi.Input['IndexesArgs']]] indexes: List of indexes for this path
        :param pulumi.Input[builtins.str] path: The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexesArgs']]]]:
        """
        List of indexes for this path
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexesArgs']]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class IndexesArgsDict(TypedDict):
        """
        The indexes for the path.
        """
        data_type: NotRequired[pulumi.Input[Union[builtins.str, 'DataType']]]
        """
        The datatype for which the indexing behavior is applied to.
        """
        kind: NotRequired[pulumi.Input[Union[builtins.str, 'IndexKind']]]
        """
        Indicates the type of index.
        """
        precision: NotRequired[pulumi.Input[builtins.int]]
        """
        The precision of the index. -1 is maximum precision.
        """
elif False:
    IndexesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexesArgs:
    def __init__(__self__, *,
                 data_type: Optional[pulumi.Input[Union[builtins.str, 'DataType']]] = None,
                 kind: Optional[pulumi.Input[Union[builtins.str, 'IndexKind']]] = None,
                 precision: Optional[pulumi.Input[builtins.int]] = None):
        """
        The indexes for the path.
        :param pulumi.Input[Union[builtins.str, 'DataType']] data_type: The datatype for which the indexing behavior is applied to.
        :param pulumi.Input[Union[builtins.str, 'IndexKind']] kind: Indicates the type of index.
        :param pulumi.Input[builtins.int] precision: The precision of the index. -1 is maximum precision.
        """
        if data_type is None:
            data_type = 'String'
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if kind is None:
            kind = 'Hash'
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'DataType']]]:
        """
        The datatype for which the indexing behavior is applied to.
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'DataType']]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[Union[builtins.str, 'IndexKind']]]:
        """
        Indicates the type of index.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[Union[builtins.str, 'IndexKind']]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The precision of the index. -1 is maximum precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "precision", value)


if not MYPY:
    class IndexingPolicyArgsDict(TypedDict):
        """
        Cosmos DB indexing policy
        """
        automatic: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if the indexing policy is automatic
        """
        composite_indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input['CompositePathArgsDict']]]]]]
        """
        List of composite path list
        """
        excluded_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExcludedPathArgsDict']]]]
        """
        List of paths to exclude from indexing
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['IncludedPathArgsDict']]]]
        """
        List of paths to include in the indexing
        """
        indexing_mode: NotRequired[pulumi.Input[Union[builtins.str, 'IndexingMode']]]
        """
        Indicates the indexing mode.
        """
        spatial_indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpatialSpecArgsDict']]]]
        """
        List of spatial specifics
        """
        vector_indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input['VectorIndexArgsDict']]]]
        """
        List of paths to include in the vector indexing
        """
elif False:
    IndexingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexingPolicyArgs:
    def __init__(__self__, *,
                 automatic: Optional[pulumi.Input[builtins.bool]] = None,
                 composite_indexes: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input['CompositePathArgs']]]]]] = None,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input['ExcludedPathArgs']]]] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input['IncludedPathArgs']]]] = None,
                 indexing_mode: Optional[pulumi.Input[Union[builtins.str, 'IndexingMode']]] = None,
                 spatial_indexes: Optional[pulumi.Input[Sequence[pulumi.Input['SpatialSpecArgs']]]] = None,
                 vector_indexes: Optional[pulumi.Input[Sequence[pulumi.Input['VectorIndexArgs']]]] = None):
        """
        Cosmos DB indexing policy
        :param pulumi.Input[builtins.bool] automatic: Indicates if the indexing policy is automatic
        :param pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input['CompositePathArgs']]]]] composite_indexes: List of composite path list
        :param pulumi.Input[Sequence[pulumi.Input['ExcludedPathArgs']]] excluded_paths: List of paths to exclude from indexing
        :param pulumi.Input[Sequence[pulumi.Input['IncludedPathArgs']]] included_paths: List of paths to include in the indexing
        :param pulumi.Input[Union[builtins.str, 'IndexingMode']] indexing_mode: Indicates the indexing mode.
        :param pulumi.Input[Sequence[pulumi.Input['SpatialSpecArgs']]] spatial_indexes: List of spatial specifics
        :param pulumi.Input[Sequence[pulumi.Input['VectorIndexArgs']]] vector_indexes: List of paths to include in the vector indexing
        """
        if automatic is not None:
            pulumi.set(__self__, "automatic", automatic)
        if composite_indexes is not None:
            pulumi.set(__self__, "composite_indexes", composite_indexes)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)
        if indexing_mode is None:
            indexing_mode = 'consistent'
        if indexing_mode is not None:
            pulumi.set(__self__, "indexing_mode", indexing_mode)
        if spatial_indexes is not None:
            pulumi.set(__self__, "spatial_indexes", spatial_indexes)
        if vector_indexes is not None:
            pulumi.set(__self__, "vector_indexes", vector_indexes)

    @property
    @pulumi.getter
    def automatic(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if the indexing policy is automatic
        """
        return pulumi.get(self, "automatic")

    @automatic.setter
    def automatic(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "automatic", value)

    @property
    @pulumi.getter(name="compositeIndexes")
    def composite_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input['CompositePathArgs']]]]]]:
        """
        List of composite path list
        """
        return pulumi.get(self, "composite_indexes")

    @composite_indexes.setter
    def composite_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input['CompositePathArgs']]]]]]):
        pulumi.set(self, "composite_indexes", value)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExcludedPathArgs']]]]:
        """
        List of paths to exclude from indexing
        """
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExcludedPathArgs']]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IncludedPathArgs']]]]:
        """
        List of paths to include in the indexing
        """
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IncludedPathArgs']]]]):
        pulumi.set(self, "included_paths", value)

    @property
    @pulumi.getter(name="indexingMode")
    def indexing_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'IndexingMode']]]:
        """
        Indicates the indexing mode.
        """
        return pulumi.get(self, "indexing_mode")

    @indexing_mode.setter
    def indexing_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'IndexingMode']]]):
        pulumi.set(self, "indexing_mode", value)

    @property
    @pulumi.getter(name="spatialIndexes")
    def spatial_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpatialSpecArgs']]]]:
        """
        List of spatial specifics
        """
        return pulumi.get(self, "spatial_indexes")

    @spatial_indexes.setter
    def spatial_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpatialSpecArgs']]]]):
        pulumi.set(self, "spatial_indexes", value)

    @property
    @pulumi.getter(name="vectorIndexes")
    def vector_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VectorIndexArgs']]]]:
        """
        List of paths to include in the vector indexing
        """
        return pulumi.get(self, "vector_indexes")

    @vector_indexes.setter
    def vector_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VectorIndexArgs']]]]):
        pulumi.set(self, "vector_indexes", value)


if not MYPY:
    class IpAddressOrRangeArgsDict(TypedDict):
        """
        IpAddressOrRange object
        """
        ip_address_or_range: NotRequired[pulumi.Input[builtins.str]]
        """
        A single IPv4 address or a single IPv4 address range in CIDR format. Provided IPs must be well-formatted and cannot be contained in one of the following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12, 192.168.0.0/16, since these are not enforceable by the IP address filter. Example of valid inputs: 23.40.210.245 or 23.40.210.0/8.
        """
elif False:
    IpAddressOrRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpAddressOrRangeArgs:
    def __init__(__self__, *,
                 ip_address_or_range: Optional[pulumi.Input[builtins.str]] = None):
        """
        IpAddressOrRange object
        :param pulumi.Input[builtins.str] ip_address_or_range: A single IPv4 address or a single IPv4 address range in CIDR format. Provided IPs must be well-formatted and cannot be contained in one of the following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12, 192.168.0.0/16, since these are not enforceable by the IP address filter. Example of valid inputs: 23.40.210.245 or 23.40.210.0/8.
        """
        if ip_address_or_range is not None:
            pulumi.set(__self__, "ip_address_or_range", ip_address_or_range)

    @property
    @pulumi.getter(name="ipAddressOrRange")
    def ip_address_or_range(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A single IPv4 address or a single IPv4 address range in CIDR format. Provided IPs must be well-formatted and cannot be contained in one of the following ranges: 10.0.0.0/8, 100.64.0.0/10, 172.16.0.0/12, 192.168.0.0/16, since these are not enforceable by the IP address filter. Example of valid inputs: 23.40.210.245 or 23.40.210.0/8.
        """
        return pulumi.get(self, "ip_address_or_range")

    @ip_address_or_range.setter
    def ip_address_or_range(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address_or_range", value)


if not MYPY:
    class LocationArgsDict(TypedDict):
        """
        A region in which the Azure Cosmos DB database account is deployed.
        """
        failover_priority: NotRequired[pulumi.Input[builtins.int]]
        """
        The failover priority of the region. A failover priority of 0 indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists.
        """
        is_zone_redundant: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to indicate whether or not this region is an AvailabilityZone region
        """
        location_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the region.
        """
elif False:
    LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocationArgs:
    def __init__(__self__, *,
                 failover_priority: Optional[pulumi.Input[builtins.int]] = None,
                 is_zone_redundant: Optional[pulumi.Input[builtins.bool]] = None,
                 location_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        A region in which the Azure Cosmos DB database account is deployed.
        :param pulumi.Input[builtins.int] failover_priority: The failover priority of the region. A failover priority of 0 indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists.
        :param pulumi.Input[builtins.bool] is_zone_redundant: Flag to indicate whether or not this region is an AvailabilityZone region
        :param pulumi.Input[builtins.str] location_name: The name of the region.
        """
        if failover_priority is not None:
            pulumi.set(__self__, "failover_priority", failover_priority)
        if is_zone_redundant is not None:
            pulumi.set(__self__, "is_zone_redundant", is_zone_redundant)
        if location_name is not None:
            pulumi.set(__self__, "location_name", location_name)

    @property
    @pulumi.getter(name="failoverPriority")
    def failover_priority(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The failover priority of the region. A failover priority of 0 indicates a write region. The maximum value for a failover priority = (total number of regions - 1). Failover priority values must be unique for each of the regions in which the database account exists.
        """
        return pulumi.get(self, "failover_priority")

    @failover_priority.setter
    def failover_priority(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "failover_priority", value)

    @property
    @pulumi.getter(name="isZoneRedundant")
    def is_zone_redundant(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to indicate whether or not this region is an AvailabilityZone region
        """
        return pulumi.get(self, "is_zone_redundant")

    @is_zone_redundant.setter
    def is_zone_redundant(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_zone_redundant", value)

    @property
    @pulumi.getter(name="locationName")
    def location_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the region.
        """
        return pulumi.get(self, "location_name")

    @location_name.setter
    def location_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "location_name", value)


if not MYPY:
    class ManagedCassandraManagedServiceIdentityArgsDict(TypedDict):
        """
        Identity for the resource.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'ManagedCassandraResourceIdentityType']]]
        """
        The type of the resource.
        """
elif False:
    ManagedCassandraManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedCassandraManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[Union[builtins.str, 'ManagedCassandraResourceIdentityType']]] = None):
        """
        Identity for the resource.
        :param pulumi.Input[Union[builtins.str, 'ManagedCassandraResourceIdentityType']] type: The type of the resource.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ManagedCassandraResourceIdentityType']]]:
        """
        The type of the resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ManagedCassandraResourceIdentityType']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Identity for the resource.
        """
        type: NotRequired[pulumi.Input['ResourceIdentityType']]
        """
        The type of identity used for the resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ResourceIdentityType']] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Identity for the resource.
        :param pulumi.Input['ResourceIdentityType'] type: The type of identity used for the resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_assigned_identities: The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ResourceIdentityType']]:
        """
        The type of identity used for the resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ResourceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class MaterializedViewsBuilderServiceResourceCreateUpdatePropertiesArgsDict(TypedDict):
        """
        Properties for Create or Update request for MaterializedViewsBuilderServiceResource
        """
        service_type: pulumi.Input[builtins.str]
        """
        ServiceType for the service.
        Expected value is 'MaterializedViewsBuilder'.
        """
        instance_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Instance count for the service.
        """
        instance_size: NotRequired[pulumi.Input[Union[builtins.str, 'ServiceSize']]]
        """
        Instance type for the service.
        """
elif False:
    MaterializedViewsBuilderServiceResourceCreateUpdatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MaterializedViewsBuilderServiceResourceCreateUpdatePropertiesArgs:
    def __init__(__self__, *,
                 service_type: pulumi.Input[builtins.str],
                 instance_count: Optional[pulumi.Input[builtins.int]] = None,
                 instance_size: Optional[pulumi.Input[Union[builtins.str, 'ServiceSize']]] = None):
        """
        Properties for Create or Update request for MaterializedViewsBuilderServiceResource
        :param pulumi.Input[builtins.str] service_type: ServiceType for the service.
               Expected value is 'MaterializedViewsBuilder'.
        :param pulumi.Input[builtins.int] instance_count: Instance count for the service.
        :param pulumi.Input[Union[builtins.str, 'ServiceSize']] instance_size: Instance type for the service.
        """
        pulumi.set(__self__, "service_type", 'MaterializedViewsBuilder')
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size is not None:
            pulumi.set(__self__, "instance_size", instance_size)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> pulumi.Input[builtins.str]:
        """
        ServiceType for the service.
        Expected value is 'MaterializedViewsBuilder'.
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_type", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Instance count for the service.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> Optional[pulumi.Input[Union[builtins.str, 'ServiceSize']]]:
        """
        Instance type for the service.
        """
        return pulumi.get(self, "instance_size")

    @instance_size.setter
    def instance_size(self, value: Optional[pulumi.Input[Union[builtins.str, 'ServiceSize']]]):
        pulumi.set(self, "instance_size", value)


if not MYPY:
    class MongoClusterRestoreParametersArgsDict(TypedDict):
        """
        Parameters used for restore operations
        """
        point_in_time_utc: NotRequired[pulumi.Input[builtins.str]]
        """
        UTC point in time to restore a mongo cluster
        """
        source_resource_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ID to locate the source cluster to restore
        """
elif False:
    MongoClusterRestoreParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoClusterRestoreParametersArgs:
    def __init__(__self__, *,
                 point_in_time_utc: Optional[pulumi.Input[builtins.str]] = None,
                 source_resource_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Parameters used for restore operations
        :param pulumi.Input[builtins.str] point_in_time_utc: UTC point in time to restore a mongo cluster
        :param pulumi.Input[builtins.str] source_resource_id: Resource ID to locate the source cluster to restore
        """
        if point_in_time_utc is not None:
            pulumi.set(__self__, "point_in_time_utc", point_in_time_utc)
        if source_resource_id is not None:
            pulumi.set(__self__, "source_resource_id", source_resource_id)

    @property
    @pulumi.getter(name="pointInTimeUTC")
    def point_in_time_utc(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        UTC point in time to restore a mongo cluster
        """
        return pulumi.get(self, "point_in_time_utc")

    @point_in_time_utc.setter
    def point_in_time_utc(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "point_in_time_utc", value)

    @property
    @pulumi.getter(name="sourceResourceId")
    def source_resource_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ID to locate the source cluster to restore
        """
        return pulumi.get(self, "source_resource_id")

    @source_resource_id.setter
    def source_resource_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_resource_id", value)


if not MYPY:
    class MongoDBCollectionResourceArgsDict(TypedDict):
        """
        Cosmos DB MongoDB collection resource object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB MongoDB collection
        """
        analytical_storage_ttl: NotRequired[pulumi.Input[builtins.int]]
        """
        Analytical TTL.
        """
        create_mode: NotRequired[pulumi.Input[Union[builtins.str, 'CreateMode']]]
        """
        Enum to indicate the mode of resource creation.
        """
        indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input['MongoIndexArgsDict']]]]
        """
        List of index keys
        """
        restore_parameters: NotRequired[pulumi.Input['ResourceRestoreParametersArgsDict']]
        """
        Parameters to indicate the information about the restore
        """
        shard_key: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        A key-value pair of shard keys to be applied for the request.
        """
elif False:
    MongoDBCollectionResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoDBCollectionResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 analytical_storage_ttl: Optional[pulumi.Input[builtins.int]] = None,
                 create_mode: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]] = None,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input['MongoIndexArgs']]]] = None,
                 restore_parameters: Optional[pulumi.Input['ResourceRestoreParametersArgs']] = None,
                 shard_key: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        Cosmos DB MongoDB collection resource object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB MongoDB collection
        :param pulumi.Input[builtins.int] analytical_storage_ttl: Analytical TTL.
        :param pulumi.Input[Union[builtins.str, 'CreateMode']] create_mode: Enum to indicate the mode of resource creation.
        :param pulumi.Input[Sequence[pulumi.Input['MongoIndexArgs']]] indexes: List of index keys
        :param pulumi.Input['ResourceRestoreParametersArgs'] restore_parameters: Parameters to indicate the information about the restore
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] shard_key: A key-value pair of shard keys to be applied for the request.
        """
        pulumi.set(__self__, "id", id)
        if analytical_storage_ttl is not None:
            pulumi.set(__self__, "analytical_storage_ttl", analytical_storage_ttl)
        if create_mode is not None:
            pulumi.set(__self__, "create_mode", create_mode)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if restore_parameters is not None:
            pulumi.set(__self__, "restore_parameters", restore_parameters)
        if shard_key is not None:
            pulumi.set(__self__, "shard_key", shard_key)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB MongoDB collection
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="analyticalStorageTtl")
    def analytical_storage_ttl(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Analytical TTL.
        """
        return pulumi.get(self, "analytical_storage_ttl")

    @analytical_storage_ttl.setter
    def analytical_storage_ttl(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "analytical_storage_ttl", value)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]:
        """
        Enum to indicate the mode of resource creation.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MongoIndexArgs']]]]:
        """
        List of index keys
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MongoIndexArgs']]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter(name="restoreParameters")
    def restore_parameters(self) -> Optional[pulumi.Input['ResourceRestoreParametersArgs']]:
        """
        Parameters to indicate the information about the restore
        """
        return pulumi.get(self, "restore_parameters")

    @restore_parameters.setter
    def restore_parameters(self, value: Optional[pulumi.Input['ResourceRestoreParametersArgs']]):
        pulumi.set(self, "restore_parameters", value)

    @property
    @pulumi.getter(name="shardKey")
    def shard_key(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        A key-value pair of shard keys to be applied for the request.
        """
        return pulumi.get(self, "shard_key")

    @shard_key.setter
    def shard_key(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "shard_key", value)


if not MYPY:
    class MongoDBDatabaseResourceArgsDict(TypedDict):
        """
        Cosmos DB MongoDB database resource object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB MongoDB database
        """
        create_mode: NotRequired[pulumi.Input[Union[builtins.str, 'CreateMode']]]
        """
        Enum to indicate the mode of resource creation.
        """
        restore_parameters: NotRequired[pulumi.Input['ResourceRestoreParametersArgsDict']]
        """
        Parameters to indicate the information about the restore
        """
elif False:
    MongoDBDatabaseResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoDBDatabaseResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 create_mode: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]] = None,
                 restore_parameters: Optional[pulumi.Input['ResourceRestoreParametersArgs']] = None):
        """
        Cosmos DB MongoDB database resource object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB MongoDB database
        :param pulumi.Input[Union[builtins.str, 'CreateMode']] create_mode: Enum to indicate the mode of resource creation.
        :param pulumi.Input['ResourceRestoreParametersArgs'] restore_parameters: Parameters to indicate the information about the restore
        """
        pulumi.set(__self__, "id", id)
        if create_mode is not None:
            pulumi.set(__self__, "create_mode", create_mode)
        if restore_parameters is not None:
            pulumi.set(__self__, "restore_parameters", restore_parameters)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB MongoDB database
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]:
        """
        Enum to indicate the mode of resource creation.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="restoreParameters")
    def restore_parameters(self) -> Optional[pulumi.Input['ResourceRestoreParametersArgs']]:
        """
        Parameters to indicate the information about the restore
        """
        return pulumi.get(self, "restore_parameters")

    @restore_parameters.setter
    def restore_parameters(self, value: Optional[pulumi.Input['ResourceRestoreParametersArgs']]):
        pulumi.set(self, "restore_parameters", value)


if not MYPY:
    class MongoIndexKeysArgsDict(TypedDict):
        """
        Cosmos DB MongoDB collection resource object
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of keys for each MongoDB collection in the Azure Cosmos DB service
        """
elif False:
    MongoIndexKeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoIndexKeysArgs:
    def __init__(__self__, *,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Cosmos DB MongoDB collection resource object
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] keys: List of keys for each MongoDB collection in the Azure Cosmos DB service
        """
        if keys is not None:
            pulumi.set(__self__, "keys", keys)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of keys for each MongoDB collection in the Azure Cosmos DB service
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "keys", value)


if not MYPY:
    class MongoIndexOptionsArgsDict(TypedDict):
        """
        Cosmos DB MongoDB collection index options
        """
        expire_after_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Expire after seconds
        """
        unique: NotRequired[pulumi.Input[builtins.bool]]
        """
        Is unique or not
        """
elif False:
    MongoIndexOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoIndexOptionsArgs:
    def __init__(__self__, *,
                 expire_after_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 unique: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Cosmos DB MongoDB collection index options
        :param pulumi.Input[builtins.int] expire_after_seconds: Expire after seconds
        :param pulumi.Input[builtins.bool] unique: Is unique or not
        """
        if expire_after_seconds is not None:
            pulumi.set(__self__, "expire_after_seconds", expire_after_seconds)
        if unique is not None:
            pulumi.set(__self__, "unique", unique)

    @property
    @pulumi.getter(name="expireAfterSeconds")
    def expire_after_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Expire after seconds
        """
        return pulumi.get(self, "expire_after_seconds")

    @expire_after_seconds.setter
    def expire_after_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "expire_after_seconds", value)

    @property
    @pulumi.getter
    def unique(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Is unique or not
        """
        return pulumi.get(self, "unique")

    @unique.setter
    def unique(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "unique", value)


if not MYPY:
    class MongoIndexArgsDict(TypedDict):
        """
        Cosmos DB MongoDB collection index key
        """
        key: NotRequired[pulumi.Input['MongoIndexKeysArgsDict']]
        """
        Cosmos DB MongoDB collection index keys
        """
        options: NotRequired[pulumi.Input['MongoIndexOptionsArgsDict']]
        """
        Cosmos DB MongoDB collection index key options
        """
elif False:
    MongoIndexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoIndexArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input['MongoIndexKeysArgs']] = None,
                 options: Optional[pulumi.Input['MongoIndexOptionsArgs']] = None):
        """
        Cosmos DB MongoDB collection index key
        :param pulumi.Input['MongoIndexKeysArgs'] key: Cosmos DB MongoDB collection index keys
        :param pulumi.Input['MongoIndexOptionsArgs'] options: Cosmos DB MongoDB collection index key options
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input['MongoIndexKeysArgs']]:
        """
        Cosmos DB MongoDB collection index keys
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input['MongoIndexKeysArgs']]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input['MongoIndexOptionsArgs']]:
        """
        Cosmos DB MongoDB collection index key options
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input['MongoIndexOptionsArgs']]):
        pulumi.set(self, "options", value)


if not MYPY:
    class NodeGroupSpecArgsDict(TypedDict):
        """
        Specification for a node group.
        """
        disk_size_gb: NotRequired[pulumi.Input[builtins.float]]
        """
        The disk storage size for the node group in GB. Example values: 128, 256, 512, 1024.
        """
        enable_ha: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether high availability is enabled on the node group.
        """
        kind: NotRequired[pulumi.Input[Union[builtins.str, 'NodeKind']]]
        """
        The node type deployed in the node group.
        """
        node_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of nodes in the node group.
        """
        sku: NotRequired[pulumi.Input[builtins.str]]
        """
        The resource sku for the node group. This defines the size of CPU and memory that is provisioned for each node. Example values: 'M30', 'M40'.
        """
elif False:
    NodeGroupSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeGroupSpecArgs:
    def __init__(__self__, *,
                 disk_size_gb: Optional[pulumi.Input[builtins.float]] = None,
                 enable_ha: Optional[pulumi.Input[builtins.bool]] = None,
                 kind: Optional[pulumi.Input[Union[builtins.str, 'NodeKind']]] = None,
                 node_count: Optional[pulumi.Input[builtins.int]] = None,
                 sku: Optional[pulumi.Input[builtins.str]] = None):
        """
        Specification for a node group.
        :param pulumi.Input[builtins.float] disk_size_gb: The disk storage size for the node group in GB. Example values: 128, 256, 512, 1024.
        :param pulumi.Input[builtins.bool] enable_ha: Whether high availability is enabled on the node group.
        :param pulumi.Input[Union[builtins.str, 'NodeKind']] kind: The node type deployed in the node group.
        :param pulumi.Input[builtins.int] node_count: The number of nodes in the node group.
        :param pulumi.Input[builtins.str] sku: The resource sku for the node group. This defines the size of CPU and memory that is provisioned for each node. Example values: 'M30', 'M40'.
        """
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if enable_ha is not None:
            pulumi.set(__self__, "enable_ha", enable_ha)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if sku is not None:
            pulumi.set(__self__, "sku", sku)

    @property
    @pulumi.getter(name="diskSizeGB")
    def disk_size_gb(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The disk storage size for the node group in GB. Example values: 128, 256, 512, 1024.
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="enableHa")
    def enable_ha(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether high availability is enabled on the node group.
        """
        return pulumi.get(self, "enable_ha")

    @enable_ha.setter
    def enable_ha(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_ha", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[Union[builtins.str, 'NodeKind']]]:
        """
        The node type deployed in the node group.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[Union[builtins.str, 'NodeKind']]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of nodes in the node group.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter
    def sku(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The resource sku for the node group. This defines the size of CPU and memory that is provisioned for each node. Example values: 'M30', 'M40'.
        """
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sku", value)


if not MYPY:
    class PeriodicModeBackupPolicyArgsDict(TypedDict):
        """
        The object representing periodic mode backup policy.
        """
        type: pulumi.Input[builtins.str]
        """
        Describes the mode of backups.
        Expected value is 'Periodic'.
        """
        migration_state: NotRequired[pulumi.Input['BackupPolicyMigrationStateArgsDict']]
        """
        The object representing the state of the migration between the backup policies.
        """
        periodic_mode_properties: NotRequired[pulumi.Input['PeriodicModePropertiesArgsDict']]
        """
        Configuration values for periodic mode backup
        """
elif False:
    PeriodicModeBackupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PeriodicModeBackupPolicyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 migration_state: Optional[pulumi.Input['BackupPolicyMigrationStateArgs']] = None,
                 periodic_mode_properties: Optional[pulumi.Input['PeriodicModePropertiesArgs']] = None):
        """
        The object representing periodic mode backup policy.
        :param pulumi.Input[builtins.str] type: Describes the mode of backups.
               Expected value is 'Periodic'.
        :param pulumi.Input['BackupPolicyMigrationStateArgs'] migration_state: The object representing the state of the migration between the backup policies.
        :param pulumi.Input['PeriodicModePropertiesArgs'] periodic_mode_properties: Configuration values for periodic mode backup
        """
        pulumi.set(__self__, "type", 'Periodic')
        if migration_state is not None:
            pulumi.set(__self__, "migration_state", migration_state)
        if periodic_mode_properties is not None:
            pulumi.set(__self__, "periodic_mode_properties", periodic_mode_properties)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Describes the mode of backups.
        Expected value is 'Periodic'.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="migrationState")
    def migration_state(self) -> Optional[pulumi.Input['BackupPolicyMigrationStateArgs']]:
        """
        The object representing the state of the migration between the backup policies.
        """
        return pulumi.get(self, "migration_state")

    @migration_state.setter
    def migration_state(self, value: Optional[pulumi.Input['BackupPolicyMigrationStateArgs']]):
        pulumi.set(self, "migration_state", value)

    @property
    @pulumi.getter(name="periodicModeProperties")
    def periodic_mode_properties(self) -> Optional[pulumi.Input['PeriodicModePropertiesArgs']]:
        """
        Configuration values for periodic mode backup
        """
        return pulumi.get(self, "periodic_mode_properties")

    @periodic_mode_properties.setter
    def periodic_mode_properties(self, value: Optional[pulumi.Input['PeriodicModePropertiesArgs']]):
        pulumi.set(self, "periodic_mode_properties", value)


if not MYPY:
    class PeriodicModePropertiesArgsDict(TypedDict):
        """
        Configuration values for periodic mode backup
        """
        backup_interval_in_minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        An integer representing the interval in minutes between two backups
        """
        backup_retention_interval_in_hours: NotRequired[pulumi.Input[builtins.int]]
        """
        An integer representing the time (in hours) that each backup is retained
        """
        backup_storage_redundancy: NotRequired[pulumi.Input[Union[builtins.str, 'BackupStorageRedundancy']]]
        """
        Enum to indicate type of backup residency
        """
elif False:
    PeriodicModePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PeriodicModePropertiesArgs:
    def __init__(__self__, *,
                 backup_interval_in_minutes: Optional[pulumi.Input[builtins.int]] = None,
                 backup_retention_interval_in_hours: Optional[pulumi.Input[builtins.int]] = None,
                 backup_storage_redundancy: Optional[pulumi.Input[Union[builtins.str, 'BackupStorageRedundancy']]] = None):
        """
        Configuration values for periodic mode backup
        :param pulumi.Input[builtins.int] backup_interval_in_minutes: An integer representing the interval in minutes between two backups
        :param pulumi.Input[builtins.int] backup_retention_interval_in_hours: An integer representing the time (in hours) that each backup is retained
        :param pulumi.Input[Union[builtins.str, 'BackupStorageRedundancy']] backup_storage_redundancy: Enum to indicate type of backup residency
        """
        if backup_interval_in_minutes is not None:
            pulumi.set(__self__, "backup_interval_in_minutes", backup_interval_in_minutes)
        if backup_retention_interval_in_hours is not None:
            pulumi.set(__self__, "backup_retention_interval_in_hours", backup_retention_interval_in_hours)
        if backup_storage_redundancy is not None:
            pulumi.set(__self__, "backup_storage_redundancy", backup_storage_redundancy)

    @property
    @pulumi.getter(name="backupIntervalInMinutes")
    def backup_interval_in_minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        An integer representing the interval in minutes between two backups
        """
        return pulumi.get(self, "backup_interval_in_minutes")

    @backup_interval_in_minutes.setter
    def backup_interval_in_minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_interval_in_minutes", value)

    @property
    @pulumi.getter(name="backupRetentionIntervalInHours")
    def backup_retention_interval_in_hours(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        An integer representing the time (in hours) that each backup is retained
        """
        return pulumi.get(self, "backup_retention_interval_in_hours")

    @backup_retention_interval_in_hours.setter
    def backup_retention_interval_in_hours(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "backup_retention_interval_in_hours", value)

    @property
    @pulumi.getter(name="backupStorageRedundancy")
    def backup_storage_redundancy(self) -> Optional[pulumi.Input[Union[builtins.str, 'BackupStorageRedundancy']]]:
        """
        Enum to indicate type of backup residency
        """
        return pulumi.get(self, "backup_storage_redundancy")

    @backup_storage_redundancy.setter
    def backup_storage_redundancy(self, value: Optional[pulumi.Input[Union[builtins.str, 'BackupStorageRedundancy']]]):
        pulumi.set(self, "backup_storage_redundancy", value)


if not MYPY:
    class PermissionArgsDict(TypedDict):
        """
        The set of data plane operations permitted through this Role Definition.
        """
        data_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        An array of data actions that are allowed.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The id for the permission.
        """
        not_data_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        An array of data actions that are denied.
        """
elif False:
    PermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PermissionArgs:
    def __init__(__self__, *,
                 data_actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 not_data_actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The set of data plane operations permitted through this Role Definition.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] data_actions: An array of data actions that are allowed.
        :param pulumi.Input[builtins.str] id: The id for the permission.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] not_data_actions: An array of data actions that are denied.
        """
        if data_actions is not None:
            pulumi.set(__self__, "data_actions", data_actions)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if not_data_actions is not None:
            pulumi.set(__self__, "not_data_actions", not_data_actions)

    @property
    @pulumi.getter(name="dataActions")
    def data_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        An array of data actions that are allowed.
        """
        return pulumi.get(self, "data_actions")

    @data_actions.setter
    def data_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "data_actions", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id for the permission.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="notDataActions")
    def not_data_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        An array of data actions that are denied.
        """
        return pulumi.get(self, "not_data_actions")

    @not_data_actions.setter
    def not_data_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "not_data_actions", value)


if not MYPY:
    class PrivateEndpointPropertyArgsDict(TypedDict):
        """
        Private endpoint which the connection belongs to.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource id of the private endpoint.
        """
elif False:
    PrivateEndpointPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateEndpointPropertyArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Private endpoint which the connection belongs to.
        :param pulumi.Input[builtins.str] id: Resource id of the private endpoint.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource id of the private endpoint.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class PrivateLinkServiceConnectionStatePropertyArgsDict(TypedDict):
        """
        Connection State of the Private Endpoint Connection.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The private link service connection description.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        The private link service connection status.
        """
elif False:
    PrivateLinkServiceConnectionStatePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateLinkServiceConnectionStatePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None):
        """
        Connection State of the Private Endpoint Connection.
        :param pulumi.Input[builtins.str] description: The private link service connection description.
        :param pulumi.Input[builtins.str] status: The private link service connection status.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The private link service connection description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The private link service connection status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class PrivilegeResourceArgsDict(TypedDict):
        """
        An Azure Cosmos DB Mongo DB Resource.
        """
        collection: NotRequired[pulumi.Input[builtins.str]]
        """
        The collection name the role is applied.
        """
        db: NotRequired[pulumi.Input[builtins.str]]
        """
        The database name the role is applied.
        """
elif False:
    PrivilegeResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivilegeResourceArgs:
    def __init__(__self__, *,
                 collection: Optional[pulumi.Input[builtins.str]] = None,
                 db: Optional[pulumi.Input[builtins.str]] = None):
        """
        An Azure Cosmos DB Mongo DB Resource.
        :param pulumi.Input[builtins.str] collection: The collection name the role is applied.
        :param pulumi.Input[builtins.str] db: The database name the role is applied.
        """
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if db is not None:
            pulumi.set(__self__, "db", db)

    @property
    @pulumi.getter
    def collection(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The collection name the role is applied.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter
    def db(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The database name the role is applied.
        """
        return pulumi.get(self, "db")

    @db.setter
    def db(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "db", value)


if not MYPY:
    class PrivilegeArgsDict(TypedDict):
        """
        The set of data plane operations permitted through this Role Definition.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        An array of actions that are allowed.
        """
        resource: NotRequired[pulumi.Input['PrivilegeResourceArgsDict']]
        """
        An Azure Cosmos DB Mongo DB Resource.
        """
elif False:
    PrivilegeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivilegeArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 resource: Optional[pulumi.Input['PrivilegeResourceArgs']] = None):
        """
        The set of data plane operations permitted through this Role Definition.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: An array of actions that are allowed.
        :param pulumi.Input['PrivilegeResourceArgs'] resource: An Azure Cosmos DB Mongo DB Resource.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        An array of actions that are allowed.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input['PrivilegeResourceArgs']]:
        """
        An Azure Cosmos DB Mongo DB Resource.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input['PrivilegeResourceArgs']]):
        pulumi.set(self, "resource", value)


if not MYPY:
    class ResourceRestoreParametersArgsDict(TypedDict):
        """
        Parameters to indicate the information about the restore.
        """
        restore_source: NotRequired[pulumi.Input[builtins.str]]
        """
        The id of the restorable database account from which the restore has to be initiated. For example: /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}
        """
        restore_timestamp_in_utc: NotRequired[pulumi.Input[builtins.str]]
        """
        Time to which the account has to be restored (ISO-8601 format).
        """
        restore_with_ttl_disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether the restored account will have Time-To-Live disabled upon the successful restore.
        """
elif False:
    ResourceRestoreParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceRestoreParametersArgs:
    def __init__(__self__, *,
                 restore_source: Optional[pulumi.Input[builtins.str]] = None,
                 restore_timestamp_in_utc: Optional[pulumi.Input[builtins.str]] = None,
                 restore_with_ttl_disabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Parameters to indicate the information about the restore.
        :param pulumi.Input[builtins.str] restore_source: The id of the restorable database account from which the restore has to be initiated. For example: /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}
        :param pulumi.Input[builtins.str] restore_timestamp_in_utc: Time to which the account has to be restored (ISO-8601 format).
        :param pulumi.Input[builtins.bool] restore_with_ttl_disabled: Specifies whether the restored account will have Time-To-Live disabled upon the successful restore.
        """
        if restore_source is not None:
            pulumi.set(__self__, "restore_source", restore_source)
        if restore_timestamp_in_utc is not None:
            pulumi.set(__self__, "restore_timestamp_in_utc", restore_timestamp_in_utc)
        if restore_with_ttl_disabled is not None:
            pulumi.set(__self__, "restore_with_ttl_disabled", restore_with_ttl_disabled)

    @property
    @pulumi.getter(name="restoreSource")
    def restore_source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id of the restorable database account from which the restore has to be initiated. For example: /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}
        """
        return pulumi.get(self, "restore_source")

    @restore_source.setter
    def restore_source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "restore_source", value)

    @property
    @pulumi.getter(name="restoreTimestampInUtc")
    def restore_timestamp_in_utc(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time to which the account has to be restored (ISO-8601 format).
        """
        return pulumi.get(self, "restore_timestamp_in_utc")

    @restore_timestamp_in_utc.setter
    def restore_timestamp_in_utc(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "restore_timestamp_in_utc", value)

    @property
    @pulumi.getter(name="restoreWithTtlDisabled")
    def restore_with_ttl_disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether the restored account will have Time-To-Live disabled upon the successful restore.
        """
        return pulumi.get(self, "restore_with_ttl_disabled")

    @restore_with_ttl_disabled.setter
    def restore_with_ttl_disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "restore_with_ttl_disabled", value)


if not MYPY:
    class RestoreParametersArgsDict(TypedDict):
        """
        Parameters to indicate the information about the restore.
        """
        databases_to_restore: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatabaseRestoreResourceArgsDict']]]]
        """
        List of specific databases available for restore.
        """
        gremlin_databases_to_restore: NotRequired[pulumi.Input[Sequence[pulumi.Input['GremlinDatabaseRestoreResourceArgsDict']]]]
        """
        List of specific gremlin databases available for restore.
        """
        restore_mode: NotRequired[pulumi.Input[Union[builtins.str, 'RestoreMode']]]
        """
        Describes the mode of the restore.
        """
        restore_source: NotRequired[pulumi.Input[builtins.str]]
        """
        The id of the restorable database account from which the restore has to be initiated. For example: /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}
        """
        restore_timestamp_in_utc: NotRequired[pulumi.Input[builtins.str]]
        """
        Time to which the account has to be restored (ISO-8601 format).
        """
        restore_with_ttl_disabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether the restored account will have Time-To-Live disabled upon the successful restore.
        """
        tables_to_restore: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of specific tables available for restore.
        """
elif False:
    RestoreParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RestoreParametersArgs:
    def __init__(__self__, *,
                 databases_to_restore: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseRestoreResourceArgs']]]] = None,
                 gremlin_databases_to_restore: Optional[pulumi.Input[Sequence[pulumi.Input['GremlinDatabaseRestoreResourceArgs']]]] = None,
                 restore_mode: Optional[pulumi.Input[Union[builtins.str, 'RestoreMode']]] = None,
                 restore_source: Optional[pulumi.Input[builtins.str]] = None,
                 restore_timestamp_in_utc: Optional[pulumi.Input[builtins.str]] = None,
                 restore_with_ttl_disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 tables_to_restore: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Parameters to indicate the information about the restore.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseRestoreResourceArgs']]] databases_to_restore: List of specific databases available for restore.
        :param pulumi.Input[Sequence[pulumi.Input['GremlinDatabaseRestoreResourceArgs']]] gremlin_databases_to_restore: List of specific gremlin databases available for restore.
        :param pulumi.Input[Union[builtins.str, 'RestoreMode']] restore_mode: Describes the mode of the restore.
        :param pulumi.Input[builtins.str] restore_source: The id of the restorable database account from which the restore has to be initiated. For example: /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}
        :param pulumi.Input[builtins.str] restore_timestamp_in_utc: Time to which the account has to be restored (ISO-8601 format).
        :param pulumi.Input[builtins.bool] restore_with_ttl_disabled: Specifies whether the restored account will have Time-To-Live disabled upon the successful restore.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tables_to_restore: List of specific tables available for restore.
        """
        if databases_to_restore is not None:
            pulumi.set(__self__, "databases_to_restore", databases_to_restore)
        if gremlin_databases_to_restore is not None:
            pulumi.set(__self__, "gremlin_databases_to_restore", gremlin_databases_to_restore)
        if restore_mode is not None:
            pulumi.set(__self__, "restore_mode", restore_mode)
        if restore_source is not None:
            pulumi.set(__self__, "restore_source", restore_source)
        if restore_timestamp_in_utc is not None:
            pulumi.set(__self__, "restore_timestamp_in_utc", restore_timestamp_in_utc)
        if restore_with_ttl_disabled is not None:
            pulumi.set(__self__, "restore_with_ttl_disabled", restore_with_ttl_disabled)
        if tables_to_restore is not None:
            pulumi.set(__self__, "tables_to_restore", tables_to_restore)

    @property
    @pulumi.getter(name="databasesToRestore")
    def databases_to_restore(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseRestoreResourceArgs']]]]:
        """
        List of specific databases available for restore.
        """
        return pulumi.get(self, "databases_to_restore")

    @databases_to_restore.setter
    def databases_to_restore(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseRestoreResourceArgs']]]]):
        pulumi.set(self, "databases_to_restore", value)

    @property
    @pulumi.getter(name="gremlinDatabasesToRestore")
    def gremlin_databases_to_restore(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GremlinDatabaseRestoreResourceArgs']]]]:
        """
        List of specific gremlin databases available for restore.
        """
        return pulumi.get(self, "gremlin_databases_to_restore")

    @gremlin_databases_to_restore.setter
    def gremlin_databases_to_restore(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GremlinDatabaseRestoreResourceArgs']]]]):
        pulumi.set(self, "gremlin_databases_to_restore", value)

    @property
    @pulumi.getter(name="restoreMode")
    def restore_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'RestoreMode']]]:
        """
        Describes the mode of the restore.
        """
        return pulumi.get(self, "restore_mode")

    @restore_mode.setter
    def restore_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'RestoreMode']]]):
        pulumi.set(self, "restore_mode", value)

    @property
    @pulumi.getter(name="restoreSource")
    def restore_source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id of the restorable database account from which the restore has to be initiated. For example: /subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/locations/{location}/restorableDatabaseAccounts/{restorableDatabaseAccountName}
        """
        return pulumi.get(self, "restore_source")

    @restore_source.setter
    def restore_source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "restore_source", value)

    @property
    @pulumi.getter(name="restoreTimestampInUtc")
    def restore_timestamp_in_utc(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time to which the account has to be restored (ISO-8601 format).
        """
        return pulumi.get(self, "restore_timestamp_in_utc")

    @restore_timestamp_in_utc.setter
    def restore_timestamp_in_utc(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "restore_timestamp_in_utc", value)

    @property
    @pulumi.getter(name="restoreWithTtlDisabled")
    def restore_with_ttl_disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether the restored account will have Time-To-Live disabled upon the successful restore.
        """
        return pulumi.get(self, "restore_with_ttl_disabled")

    @restore_with_ttl_disabled.setter
    def restore_with_ttl_disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "restore_with_ttl_disabled", value)

    @property
    @pulumi.getter(name="tablesToRestore")
    def tables_to_restore(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of specific tables available for restore.
        """
        return pulumi.get(self, "tables_to_restore")

    @tables_to_restore.setter
    def tables_to_restore(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tables_to_restore", value)


if not MYPY:
    class RoleArgsDict(TypedDict):
        """
        The set of roles permitted through this Role Definition.
        """
        db: NotRequired[pulumi.Input[builtins.str]]
        """
        The database name the role is applied.
        """
        role: NotRequired[pulumi.Input[builtins.str]]
        """
        The role name.
        """
elif False:
    RoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleArgs:
    def __init__(__self__, *,
                 db: Optional[pulumi.Input[builtins.str]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None):
        """
        The set of roles permitted through this Role Definition.
        :param pulumi.Input[builtins.str] db: The database name the role is applied.
        :param pulumi.Input[builtins.str] role: The role name.
        """
        if db is not None:
            pulumi.set(__self__, "db", db)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def db(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The database name the role is applied.
        """
        return pulumi.get(self, "db")

    @db.setter
    def db(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "db", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The role name.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class SeedNodeArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        IP address of this seed node.
        """
elif False:
    SeedNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SeedNodeArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] ip_address: IP address of this seed node.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IP address of this seed node.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class SpatialSpecArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'SpatialType']]]]]
        """
        List of path's spatial type
        """
elif False:
    SpatialSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpatialSpecArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 types: Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'SpatialType']]]]] = None):
        """
        :param pulumi.Input[builtins.str] path: The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        :param pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'SpatialType']]]] types: List of path's spatial type
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'SpatialType']]]]]:
        """
        List of path's spatial type
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union[builtins.str, 'SpatialType']]]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class SqlContainerResourceArgsDict(TypedDict):
        """
        Cosmos DB SQL container resource object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB SQL container
        """
        analytical_storage_ttl: NotRequired[pulumi.Input[builtins.float]]
        """
        Analytical TTL.
        """
        client_encryption_policy: NotRequired[pulumi.Input['ClientEncryptionPolicyArgsDict']]
        """
        The client encryption policy for the container.
        """
        computed_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputedPropertyArgsDict']]]]
        """
        List of computed properties
        """
        conflict_resolution_policy: NotRequired[pulumi.Input['ConflictResolutionPolicyArgsDict']]
        """
        The conflict resolution policy for the container.
        """
        create_mode: NotRequired[pulumi.Input[Union[builtins.str, 'CreateMode']]]
        """
        Enum to indicate the mode of resource creation.
        """
        default_ttl: NotRequired[pulumi.Input[builtins.int]]
        """
        Default time to live
        """
        indexing_policy: NotRequired[pulumi.Input['IndexingPolicyArgsDict']]
        """
        The configuration of the indexing policy. By default, the indexing is automatic for all document paths within the container
        """
        partition_key: NotRequired[pulumi.Input['ContainerPartitionKeyArgsDict']]
        """
        The configuration of the partition key to be used for partitioning data into multiple partitions
        """
        restore_parameters: NotRequired[pulumi.Input['ResourceRestoreParametersArgsDict']]
        """
        Parameters to indicate the information about the restore
        """
        unique_key_policy: NotRequired[pulumi.Input['UniqueKeyPolicyArgsDict']]
        """
        The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        """
        vector_embedding_policy: NotRequired[pulumi.Input['VectorEmbeddingPolicyArgsDict']]
        """
        The vector embedding policy for the container.
        """
elif False:
    SqlContainerResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlContainerResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 analytical_storage_ttl: Optional[pulumi.Input[builtins.float]] = None,
                 client_encryption_policy: Optional[pulumi.Input['ClientEncryptionPolicyArgs']] = None,
                 computed_properties: Optional[pulumi.Input[Sequence[pulumi.Input['ComputedPropertyArgs']]]] = None,
                 conflict_resolution_policy: Optional[pulumi.Input['ConflictResolutionPolicyArgs']] = None,
                 create_mode: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]] = None,
                 default_ttl: Optional[pulumi.Input[builtins.int]] = None,
                 indexing_policy: Optional[pulumi.Input['IndexingPolicyArgs']] = None,
                 partition_key: Optional[pulumi.Input['ContainerPartitionKeyArgs']] = None,
                 restore_parameters: Optional[pulumi.Input['ResourceRestoreParametersArgs']] = None,
                 unique_key_policy: Optional[pulumi.Input['UniqueKeyPolicyArgs']] = None,
                 vector_embedding_policy: Optional[pulumi.Input['VectorEmbeddingPolicyArgs']] = None):
        """
        Cosmos DB SQL container resource object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB SQL container
        :param pulumi.Input[builtins.float] analytical_storage_ttl: Analytical TTL.
        :param pulumi.Input['ClientEncryptionPolicyArgs'] client_encryption_policy: The client encryption policy for the container.
        :param pulumi.Input[Sequence[pulumi.Input['ComputedPropertyArgs']]] computed_properties: List of computed properties
        :param pulumi.Input['ConflictResolutionPolicyArgs'] conflict_resolution_policy: The conflict resolution policy for the container.
        :param pulumi.Input[Union[builtins.str, 'CreateMode']] create_mode: Enum to indicate the mode of resource creation.
        :param pulumi.Input[builtins.int] default_ttl: Default time to live
        :param pulumi.Input['IndexingPolicyArgs'] indexing_policy: The configuration of the indexing policy. By default, the indexing is automatic for all document paths within the container
        :param pulumi.Input['ContainerPartitionKeyArgs'] partition_key: The configuration of the partition key to be used for partitioning data into multiple partitions
        :param pulumi.Input['ResourceRestoreParametersArgs'] restore_parameters: Parameters to indicate the information about the restore
        :param pulumi.Input['UniqueKeyPolicyArgs'] unique_key_policy: The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        :param pulumi.Input['VectorEmbeddingPolicyArgs'] vector_embedding_policy: The vector embedding policy for the container.
        """
        pulumi.set(__self__, "id", id)
        if analytical_storage_ttl is not None:
            pulumi.set(__self__, "analytical_storage_ttl", analytical_storage_ttl)
        if client_encryption_policy is not None:
            pulumi.set(__self__, "client_encryption_policy", client_encryption_policy)
        if computed_properties is not None:
            pulumi.set(__self__, "computed_properties", computed_properties)
        if conflict_resolution_policy is not None:
            pulumi.set(__self__, "conflict_resolution_policy", conflict_resolution_policy)
        if create_mode is not None:
            pulumi.set(__self__, "create_mode", create_mode)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if indexing_policy is not None:
            pulumi.set(__self__, "indexing_policy", indexing_policy)
        if partition_key is not None:
            pulumi.set(__self__, "partition_key", partition_key)
        if restore_parameters is not None:
            pulumi.set(__self__, "restore_parameters", restore_parameters)
        if unique_key_policy is not None:
            pulumi.set(__self__, "unique_key_policy", unique_key_policy)
        if vector_embedding_policy is not None:
            pulumi.set(__self__, "vector_embedding_policy", vector_embedding_policy)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB SQL container
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="analyticalStorageTtl")
    def analytical_storage_ttl(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Analytical TTL.
        """
        return pulumi.get(self, "analytical_storage_ttl")

    @analytical_storage_ttl.setter
    def analytical_storage_ttl(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "analytical_storage_ttl", value)

    @property
    @pulumi.getter(name="clientEncryptionPolicy")
    def client_encryption_policy(self) -> Optional[pulumi.Input['ClientEncryptionPolicyArgs']]:
        """
        The client encryption policy for the container.
        """
        return pulumi.get(self, "client_encryption_policy")

    @client_encryption_policy.setter
    def client_encryption_policy(self, value: Optional[pulumi.Input['ClientEncryptionPolicyArgs']]):
        pulumi.set(self, "client_encryption_policy", value)

    @property
    @pulumi.getter(name="computedProperties")
    def computed_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputedPropertyArgs']]]]:
        """
        List of computed properties
        """
        return pulumi.get(self, "computed_properties")

    @computed_properties.setter
    def computed_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputedPropertyArgs']]]]):
        pulumi.set(self, "computed_properties", value)

    @property
    @pulumi.getter(name="conflictResolutionPolicy")
    def conflict_resolution_policy(self) -> Optional[pulumi.Input['ConflictResolutionPolicyArgs']]:
        """
        The conflict resolution policy for the container.
        """
        return pulumi.get(self, "conflict_resolution_policy")

    @conflict_resolution_policy.setter
    def conflict_resolution_policy(self, value: Optional[pulumi.Input['ConflictResolutionPolicyArgs']]):
        pulumi.set(self, "conflict_resolution_policy", value)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]:
        """
        Enum to indicate the mode of resource creation.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Default time to live
        """
        return pulumi.get(self, "default_ttl")

    @default_ttl.setter
    def default_ttl(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "default_ttl", value)

    @property
    @pulumi.getter(name="indexingPolicy")
    def indexing_policy(self) -> Optional[pulumi.Input['IndexingPolicyArgs']]:
        """
        The configuration of the indexing policy. By default, the indexing is automatic for all document paths within the container
        """
        return pulumi.get(self, "indexing_policy")

    @indexing_policy.setter
    def indexing_policy(self, value: Optional[pulumi.Input['IndexingPolicyArgs']]):
        pulumi.set(self, "indexing_policy", value)

    @property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> Optional[pulumi.Input['ContainerPartitionKeyArgs']]:
        """
        The configuration of the partition key to be used for partitioning data into multiple partitions
        """
        return pulumi.get(self, "partition_key")

    @partition_key.setter
    def partition_key(self, value: Optional[pulumi.Input['ContainerPartitionKeyArgs']]):
        pulumi.set(self, "partition_key", value)

    @property
    @pulumi.getter(name="restoreParameters")
    def restore_parameters(self) -> Optional[pulumi.Input['ResourceRestoreParametersArgs']]:
        """
        Parameters to indicate the information about the restore
        """
        return pulumi.get(self, "restore_parameters")

    @restore_parameters.setter
    def restore_parameters(self, value: Optional[pulumi.Input['ResourceRestoreParametersArgs']]):
        pulumi.set(self, "restore_parameters", value)

    @property
    @pulumi.getter(name="uniqueKeyPolicy")
    def unique_key_policy(self) -> Optional[pulumi.Input['UniqueKeyPolicyArgs']]:
        """
        The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        """
        return pulumi.get(self, "unique_key_policy")

    @unique_key_policy.setter
    def unique_key_policy(self, value: Optional[pulumi.Input['UniqueKeyPolicyArgs']]):
        pulumi.set(self, "unique_key_policy", value)

    @property
    @pulumi.getter(name="vectorEmbeddingPolicy")
    def vector_embedding_policy(self) -> Optional[pulumi.Input['VectorEmbeddingPolicyArgs']]:
        """
        The vector embedding policy for the container.
        """
        return pulumi.get(self, "vector_embedding_policy")

    @vector_embedding_policy.setter
    def vector_embedding_policy(self, value: Optional[pulumi.Input['VectorEmbeddingPolicyArgs']]):
        pulumi.set(self, "vector_embedding_policy", value)


if not MYPY:
    class SqlDatabaseResourceArgsDict(TypedDict):
        """
        Cosmos DB SQL database resource object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB SQL database
        """
        create_mode: NotRequired[pulumi.Input[Union[builtins.str, 'CreateMode']]]
        """
        Enum to indicate the mode of resource creation.
        """
        restore_parameters: NotRequired[pulumi.Input['ResourceRestoreParametersArgsDict']]
        """
        Parameters to indicate the information about the restore
        """
elif False:
    SqlDatabaseResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlDatabaseResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 create_mode: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]] = None,
                 restore_parameters: Optional[pulumi.Input['ResourceRestoreParametersArgs']] = None):
        """
        Cosmos DB SQL database resource object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB SQL database
        :param pulumi.Input[Union[builtins.str, 'CreateMode']] create_mode: Enum to indicate the mode of resource creation.
        :param pulumi.Input['ResourceRestoreParametersArgs'] restore_parameters: Parameters to indicate the information about the restore
        """
        pulumi.set(__self__, "id", id)
        if create_mode is not None:
            pulumi.set(__self__, "create_mode", create_mode)
        if restore_parameters is not None:
            pulumi.set(__self__, "restore_parameters", restore_parameters)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB SQL database
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]:
        """
        Enum to indicate the mode of resource creation.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="restoreParameters")
    def restore_parameters(self) -> Optional[pulumi.Input['ResourceRestoreParametersArgs']]:
        """
        Parameters to indicate the information about the restore
        """
        return pulumi.get(self, "restore_parameters")

    @restore_parameters.setter
    def restore_parameters(self, value: Optional[pulumi.Input['ResourceRestoreParametersArgs']]):
        pulumi.set(self, "restore_parameters", value)


if not MYPY:
    class SqlDedicatedGatewayServiceResourceCreateUpdatePropertiesArgsDict(TypedDict):
        """
        Properties for Create or Update request for SqlDedicatedGatewayServiceResource
        """
        service_type: pulumi.Input[builtins.str]
        """
        ServiceType for the service.
        Expected value is 'SqlDedicatedGateway'.
        """
        dedicated_gateway_type: NotRequired[pulumi.Input[Union[builtins.str, 'DedicatedGatewayType']]]
        """
        DedicatedGatewayType for the service.
        """
        instance_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Instance count for the service.
        """
        instance_size: NotRequired[pulumi.Input[Union[builtins.str, 'ServiceSize']]]
        """
        Instance type for the service.
        """
elif False:
    SqlDedicatedGatewayServiceResourceCreateUpdatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlDedicatedGatewayServiceResourceCreateUpdatePropertiesArgs:
    def __init__(__self__, *,
                 service_type: pulumi.Input[builtins.str],
                 dedicated_gateway_type: Optional[pulumi.Input[Union[builtins.str, 'DedicatedGatewayType']]] = None,
                 instance_count: Optional[pulumi.Input[builtins.int]] = None,
                 instance_size: Optional[pulumi.Input[Union[builtins.str, 'ServiceSize']]] = None):
        """
        Properties for Create or Update request for SqlDedicatedGatewayServiceResource
        :param pulumi.Input[builtins.str] service_type: ServiceType for the service.
               Expected value is 'SqlDedicatedGateway'.
        :param pulumi.Input[Union[builtins.str, 'DedicatedGatewayType']] dedicated_gateway_type: DedicatedGatewayType for the service.
        :param pulumi.Input[builtins.int] instance_count: Instance count for the service.
        :param pulumi.Input[Union[builtins.str, 'ServiceSize']] instance_size: Instance type for the service.
        """
        pulumi.set(__self__, "service_type", 'SqlDedicatedGateway')
        if dedicated_gateway_type is not None:
            pulumi.set(__self__, "dedicated_gateway_type", dedicated_gateway_type)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size is not None:
            pulumi.set(__self__, "instance_size", instance_size)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> pulumi.Input[builtins.str]:
        """
        ServiceType for the service.
        Expected value is 'SqlDedicatedGateway'.
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_type", value)

    @property
    @pulumi.getter(name="dedicatedGatewayType")
    def dedicated_gateway_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'DedicatedGatewayType']]]:
        """
        DedicatedGatewayType for the service.
        """
        return pulumi.get(self, "dedicated_gateway_type")

    @dedicated_gateway_type.setter
    def dedicated_gateway_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'DedicatedGatewayType']]]):
        pulumi.set(self, "dedicated_gateway_type", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Instance count for the service.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> Optional[pulumi.Input[Union[builtins.str, 'ServiceSize']]]:
        """
        Instance type for the service.
        """
        return pulumi.get(self, "instance_size")

    @instance_size.setter
    def instance_size(self, value: Optional[pulumi.Input[Union[builtins.str, 'ServiceSize']]]):
        pulumi.set(self, "instance_size", value)


if not MYPY:
    class SqlStoredProcedureResourceArgsDict(TypedDict):
        """
        Cosmos DB SQL storedProcedure resource object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB SQL storedProcedure
        """
        body: NotRequired[pulumi.Input[builtins.str]]
        """
        Body of the Stored Procedure
        """
elif False:
    SqlStoredProcedureResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlStoredProcedureResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 body: Optional[pulumi.Input[builtins.str]] = None):
        """
        Cosmos DB SQL storedProcedure resource object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB SQL storedProcedure
        :param pulumi.Input[builtins.str] body: Body of the Stored Procedure
        """
        pulumi.set(__self__, "id", id)
        if body is not None:
            pulumi.set(__self__, "body", body)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB SQL storedProcedure
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Body of the Stored Procedure
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "body", value)


if not MYPY:
    class SqlTriggerResourceArgsDict(TypedDict):
        """
        Cosmos DB SQL trigger resource object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB SQL trigger
        """
        body: NotRequired[pulumi.Input[builtins.str]]
        """
        Body of the Trigger
        """
        trigger_operation: NotRequired[pulumi.Input[Union[builtins.str, 'TriggerOperation']]]
        """
        The operation the trigger is associated with
        """
        trigger_type: NotRequired[pulumi.Input[Union[builtins.str, 'TriggerType']]]
        """
        Type of the Trigger
        """
elif False:
    SqlTriggerResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlTriggerResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 body: Optional[pulumi.Input[builtins.str]] = None,
                 trigger_operation: Optional[pulumi.Input[Union[builtins.str, 'TriggerOperation']]] = None,
                 trigger_type: Optional[pulumi.Input[Union[builtins.str, 'TriggerType']]] = None):
        """
        Cosmos DB SQL trigger resource object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB SQL trigger
        :param pulumi.Input[builtins.str] body: Body of the Trigger
        :param pulumi.Input[Union[builtins.str, 'TriggerOperation']] trigger_operation: The operation the trigger is associated with
        :param pulumi.Input[Union[builtins.str, 'TriggerType']] trigger_type: Type of the Trigger
        """
        pulumi.set(__self__, "id", id)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if trigger_operation is not None:
            pulumi.set(__self__, "trigger_operation", trigger_operation)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB SQL trigger
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Body of the Trigger
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="triggerOperation")
    def trigger_operation(self) -> Optional[pulumi.Input[Union[builtins.str, 'TriggerOperation']]]:
        """
        The operation the trigger is associated with
        """
        return pulumi.get(self, "trigger_operation")

    @trigger_operation.setter
    def trigger_operation(self, value: Optional[pulumi.Input[Union[builtins.str, 'TriggerOperation']]]):
        pulumi.set(self, "trigger_operation", value)

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'TriggerType']]]:
        """
        Type of the Trigger
        """
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'TriggerType']]]):
        pulumi.set(self, "trigger_type", value)


if not MYPY:
    class SqlUserDefinedFunctionResourceArgsDict(TypedDict):
        """
        Cosmos DB SQL userDefinedFunction resource object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB SQL userDefinedFunction
        """
        body: NotRequired[pulumi.Input[builtins.str]]
        """
        Body of the User Defined Function
        """
elif False:
    SqlUserDefinedFunctionResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlUserDefinedFunctionResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 body: Optional[pulumi.Input[builtins.str]] = None):
        """
        Cosmos DB SQL userDefinedFunction resource object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB SQL userDefinedFunction
        :param pulumi.Input[builtins.str] body: Body of the User Defined Function
        """
        pulumi.set(__self__, "id", id)
        if body is not None:
            pulumi.set(__self__, "body", body)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB SQL userDefinedFunction
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Body of the User Defined Function
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "body", value)


if not MYPY:
    class TableResourceArgsDict(TypedDict):
        """
        Cosmos DB table resource object
        """
        id: pulumi.Input[builtins.str]
        """
        Name of the Cosmos DB table
        """
        create_mode: NotRequired[pulumi.Input[Union[builtins.str, 'CreateMode']]]
        """
        Enum to indicate the mode of resource creation.
        """
        restore_parameters: NotRequired[pulumi.Input['ResourceRestoreParametersArgsDict']]
        """
        Parameters to indicate the information about the restore
        """
elif False:
    TableResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 create_mode: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]] = None,
                 restore_parameters: Optional[pulumi.Input['ResourceRestoreParametersArgs']] = None):
        """
        Cosmos DB table resource object
        :param pulumi.Input[builtins.str] id: Name of the Cosmos DB table
        :param pulumi.Input[Union[builtins.str, 'CreateMode']] create_mode: Enum to indicate the mode of resource creation.
        :param pulumi.Input['ResourceRestoreParametersArgs'] restore_parameters: Parameters to indicate the information about the restore
        """
        pulumi.set(__self__, "id", id)
        if create_mode is not None:
            pulumi.set(__self__, "create_mode", create_mode)
        if restore_parameters is not None:
            pulumi.set(__self__, "restore_parameters", restore_parameters)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Cosmos DB table
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="createMode")
    def create_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]:
        """
        Enum to indicate the mode of resource creation.
        """
        return pulumi.get(self, "create_mode")

    @create_mode.setter
    def create_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'CreateMode']]]):
        pulumi.set(self, "create_mode", value)

    @property
    @pulumi.getter(name="restoreParameters")
    def restore_parameters(self) -> Optional[pulumi.Input['ResourceRestoreParametersArgs']]:
        """
        Parameters to indicate the information about the restore
        """
        return pulumi.get(self, "restore_parameters")

    @restore_parameters.setter
    def restore_parameters(self, value: Optional[pulumi.Input['ResourceRestoreParametersArgs']]):
        pulumi.set(self, "restore_parameters", value)


if not MYPY:
    class UniqueKeyPolicyArgsDict(TypedDict):
        """
        The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        """
        unique_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['UniqueKeyArgsDict']]]]
        """
        List of unique keys on that enforces uniqueness constraint on documents in the collection in the Azure Cosmos DB service.
        """
elif False:
    UniqueKeyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UniqueKeyPolicyArgs:
    def __init__(__self__, *,
                 unique_keys: Optional[pulumi.Input[Sequence[pulumi.Input['UniqueKeyArgs']]]] = None):
        """
        The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        :param pulumi.Input[Sequence[pulumi.Input['UniqueKeyArgs']]] unique_keys: List of unique keys on that enforces uniqueness constraint on documents in the collection in the Azure Cosmos DB service.
        """
        if unique_keys is not None:
            pulumi.set(__self__, "unique_keys", unique_keys)

    @property
    @pulumi.getter(name="uniqueKeys")
    def unique_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UniqueKeyArgs']]]]:
        """
        List of unique keys on that enforces uniqueness constraint on documents in the collection in the Azure Cosmos DB service.
        """
        return pulumi.get(self, "unique_keys")

    @unique_keys.setter
    def unique_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UniqueKeyArgs']]]]):
        pulumi.set(self, "unique_keys", value)


if not MYPY:
    class UniqueKeyArgsDict(TypedDict):
        """
        The unique key on that enforces uniqueness constraint on documents in the collection in the Azure Cosmos DB service.
        """
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of paths must be unique for each document in the Azure Cosmos DB service
        """
elif False:
    UniqueKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UniqueKeyArgs:
    def __init__(__self__, *,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The unique key on that enforces uniqueness constraint on documents in the collection in the Azure Cosmos DB service.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] paths: List of paths must be unique for each document in the Azure Cosmos DB service
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of paths must be unique for each document in the Azure Cosmos DB service
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "paths", value)


if not MYPY:
    class VectorEmbeddingPolicyArgsDict(TypedDict):
        """
        Cosmos DB Vector Embedding Policy
        """
        vector_embeddings: NotRequired[pulumi.Input[Sequence[pulumi.Input['VectorEmbeddingArgsDict']]]]
        """
        List of vector embeddings
        """
elif False:
    VectorEmbeddingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorEmbeddingPolicyArgs:
    def __init__(__self__, *,
                 vector_embeddings: Optional[pulumi.Input[Sequence[pulumi.Input['VectorEmbeddingArgs']]]] = None):
        """
        Cosmos DB Vector Embedding Policy
        :param pulumi.Input[Sequence[pulumi.Input['VectorEmbeddingArgs']]] vector_embeddings: List of vector embeddings
        """
        if vector_embeddings is not None:
            pulumi.set(__self__, "vector_embeddings", vector_embeddings)

    @property
    @pulumi.getter(name="vectorEmbeddings")
    def vector_embeddings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VectorEmbeddingArgs']]]]:
        """
        List of vector embeddings
        """
        return pulumi.get(self, "vector_embeddings")

    @vector_embeddings.setter
    def vector_embeddings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VectorEmbeddingArgs']]]]):
        pulumi.set(self, "vector_embeddings", value)


if not MYPY:
    class VectorEmbeddingArgsDict(TypedDict):
        """
        Represents a vector embedding. A vector embedding is used to define a vector field in the documents.
        """
        data_type: pulumi.Input[Union[builtins.str, 'VectorDataType']]
        """
        Indicates the data type of vector.
        """
        dimensions: pulumi.Input[builtins.int]
        """
        The number of dimensions in the vector.
        """
        distance_function: pulumi.Input[Union[builtins.str, 'DistanceFunction']]
        """
        The distance function to use for distance calculation in between vectors.
        """
        path: pulumi.Input[builtins.str]
        """
        The path to the vector field in the document.
        """
elif False:
    VectorEmbeddingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorEmbeddingArgs:
    def __init__(__self__, *,
                 data_type: pulumi.Input[Union[builtins.str, 'VectorDataType']],
                 dimensions: pulumi.Input[builtins.int],
                 distance_function: pulumi.Input[Union[builtins.str, 'DistanceFunction']],
                 path: pulumi.Input[builtins.str]):
        """
        Represents a vector embedding. A vector embedding is used to define a vector field in the documents.
        :param pulumi.Input[Union[builtins.str, 'VectorDataType']] data_type: Indicates the data type of vector.
        :param pulumi.Input[builtins.int] dimensions: The number of dimensions in the vector.
        :param pulumi.Input[Union[builtins.str, 'DistanceFunction']] distance_function: The distance function to use for distance calculation in between vectors.
        :param pulumi.Input[builtins.str] path: The path to the vector field in the document.
        """
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "distance_function", distance_function)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> pulumi.Input[Union[builtins.str, 'VectorDataType']]:
        """
        Indicates the data type of vector.
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: pulumi.Input[Union[builtins.str, 'VectorDataType']]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[builtins.int]:
        """
        The number of dimensions in the vector.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="distanceFunction")
    def distance_function(self) -> pulumi.Input[Union[builtins.str, 'DistanceFunction']]:
        """
        The distance function to use for distance calculation in between vectors.
        """
        return pulumi.get(self, "distance_function")

    @distance_function.setter
    def distance_function(self, value: pulumi.Input[Union[builtins.str, 'DistanceFunction']]):
        pulumi.set(self, "distance_function", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[builtins.str]:
        """
        The path to the vector field in the document.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class VectorIndexArgsDict(TypedDict):
        path: pulumi.Input[builtins.str]
        """
        The path to the vector field in the document.
        """
        type: pulumi.Input[Union[builtins.str, 'VectorIndexType']]
        """
        The index type of the vector. Currently, flat, diskANN, and quantizedFlat are supported.
        """
elif False:
    VectorIndexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorIndexArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[builtins.str],
                 type: pulumi.Input[Union[builtins.str, 'VectorIndexType']]):
        """
        :param pulumi.Input[builtins.str] path: The path to the vector field in the document.
        :param pulumi.Input[Union[builtins.str, 'VectorIndexType']] type: The index type of the vector. Currently, flat, diskANN, and quantizedFlat are supported.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[builtins.str]:
        """
        The path to the vector field in the document.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[builtins.str, 'VectorIndexType']]:
        """
        The index type of the vector. Currently, flat, diskANN, and quantizedFlat are supported.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[builtins.str, 'VectorIndexType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VirtualNetworkRuleArgsDict(TypedDict):
        """
        Virtual Network ACL Rule object
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
        """
        ignore_missing_v_net_service_endpoint: NotRequired[pulumi.Input[builtins.bool]]
        """
        Create firewall rule before the virtual network has vnet service endpoint enabled.
        """
elif False:
    VirtualNetworkRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualNetworkRuleArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 ignore_missing_v_net_service_endpoint: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Virtual Network ACL Rule object
        :param pulumi.Input[builtins.str] id: Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
        :param pulumi.Input[builtins.bool] ignore_missing_v_net_service_endpoint: Create firewall rule before the virtual network has vnet service endpoint enabled.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ignore_missing_v_net_service_endpoint is not None:
            pulumi.set(__self__, "ignore_missing_v_net_service_endpoint", ignore_missing_v_net_service_endpoint)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ignoreMissingVNetServiceEndpoint")
    def ignore_missing_v_net_service_endpoint(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Create firewall rule before the virtual network has vnet service endpoint enabled.
        """
        return pulumi.get(self, "ignore_missing_v_net_service_endpoint")

    @ignore_missing_v_net_service_endpoint.setter
    def ignore_missing_v_net_service_endpoint(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ignore_missing_v_net_service_endpoint", value)


