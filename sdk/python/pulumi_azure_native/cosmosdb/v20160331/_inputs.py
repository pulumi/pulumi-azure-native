# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'CassandraKeyspaceResourceArgs',
    'CassandraKeyspaceResourceArgsDict',
    'CassandraPartitionKeyArgs',
    'CassandraPartitionKeyArgsDict',
    'CassandraSchemaArgs',
    'CassandraSchemaArgsDict',
    'CassandraTableResourceArgs',
    'CassandraTableResourceArgsDict',
    'ClusterKeyArgs',
    'ClusterKeyArgsDict',
    'ColumnArgs',
    'ColumnArgsDict',
    'ConflictResolutionPolicyArgs',
    'ConflictResolutionPolicyArgsDict',
    'ContainerPartitionKeyArgs',
    'ContainerPartitionKeyArgsDict',
    'ExcludedPathArgs',
    'ExcludedPathArgsDict',
    'GremlinDatabaseResourceArgs',
    'GremlinDatabaseResourceArgsDict',
    'GremlinGraphResourceArgs',
    'GremlinGraphResourceArgsDict',
    'IncludedPathArgs',
    'IncludedPathArgsDict',
    'IndexesArgs',
    'IndexesArgsDict',
    'IndexingPolicyArgs',
    'IndexingPolicyArgsDict',
    'MongoDBCollectionResourceArgs',
    'MongoDBCollectionResourceArgsDict',
    'MongoDBDatabaseResourceArgs',
    'MongoDBDatabaseResourceArgsDict',
    'MongoIndexKeysArgs',
    'MongoIndexKeysArgsDict',
    'MongoIndexOptionsArgs',
    'MongoIndexOptionsArgsDict',
    'MongoIndexArgs',
    'MongoIndexArgsDict',
    'SqlContainerResourceArgs',
    'SqlContainerResourceArgsDict',
    'SqlDatabaseResourceArgs',
    'SqlDatabaseResourceArgsDict',
    'TableResourceArgs',
    'TableResourceArgsDict',
    'UniqueKeyPolicyArgs',
    'UniqueKeyPolicyArgsDict',
    'UniqueKeyArgs',
    'UniqueKeyArgsDict',
]

MYPY = False

if not MYPY:
    class CassandraKeyspaceResourceArgsDict(TypedDict):
        """
        Cosmos DB Cassandra keyspace id object
        """
        id: pulumi.Input[str]
        """
        Name of the Cosmos DB Cassandra keyspace
        """
elif False:
    CassandraKeyspaceResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CassandraKeyspaceResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        Cosmos DB Cassandra keyspace id object
        :param pulumi.Input[str] id: Name of the Cosmos DB Cassandra keyspace
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Name of the Cosmos DB Cassandra keyspace
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CassandraPartitionKeyArgsDict(TypedDict):
        """
        Cosmos DB Cassandra table partition key
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Cosmos DB Cassandra table partition key
        """
elif False:
    CassandraPartitionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CassandraPartitionKeyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Cosmos DB Cassandra table partition key
        :param pulumi.Input[str] name: Name of the Cosmos DB Cassandra table partition key
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Cosmos DB Cassandra table partition key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CassandraSchemaArgsDict(TypedDict):
        """
        Cosmos DB Cassandra table schema
        """
        cluster_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterKeyArgsDict']]]]
        """
        List of cluster key.
        """
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ColumnArgsDict']]]]
        """
        List of Cassandra table columns.
        """
        partition_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['CassandraPartitionKeyArgsDict']]]]
        """
        List of partition key.
        """
elif False:
    CassandraSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CassandraSchemaArgs:
    def __init__(__self__, *,
                 cluster_keys: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterKeyArgs']]]] = None,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]]] = None,
                 partition_keys: Optional[pulumi.Input[Sequence[pulumi.Input['CassandraPartitionKeyArgs']]]] = None):
        """
        Cosmos DB Cassandra table schema
        :param pulumi.Input[Sequence[pulumi.Input['ClusterKeyArgs']]] cluster_keys: List of cluster key.
        :param pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]] columns: List of Cassandra table columns.
        :param pulumi.Input[Sequence[pulumi.Input['CassandraPartitionKeyArgs']]] partition_keys: List of partition key.
        """
        if cluster_keys is not None:
            pulumi.set(__self__, "cluster_keys", cluster_keys)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if partition_keys is not None:
            pulumi.set(__self__, "partition_keys", partition_keys)

    @property
    @pulumi.getter(name="clusterKeys")
    def cluster_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterKeyArgs']]]]:
        """
        List of cluster key.
        """
        return pulumi.get(self, "cluster_keys")

    @cluster_keys.setter
    def cluster_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterKeyArgs']]]]):
        pulumi.set(self, "cluster_keys", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]]]:
        """
        List of Cassandra table columns.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter(name="partitionKeys")
    def partition_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CassandraPartitionKeyArgs']]]]:
        """
        List of partition key.
        """
        return pulumi.get(self, "partition_keys")

    @partition_keys.setter
    def partition_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CassandraPartitionKeyArgs']]]]):
        pulumi.set(self, "partition_keys", value)


if not MYPY:
    class CassandraTableResourceArgsDict(TypedDict):
        """
        Cosmos DB Cassandra table id object
        """
        id: pulumi.Input[str]
        """
        Name of the Cosmos DB Cassandra table
        """
        default_ttl: NotRequired[pulumi.Input[int]]
        """
        Time to live of the Cosmos DB Cassandra table
        """
        schema: NotRequired[pulumi.Input['CassandraSchemaArgsDict']]
        """
        Schema of the Cosmos DB Cassandra table
        """
elif False:
    CassandraTableResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CassandraTableResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 default_ttl: Optional[pulumi.Input[int]] = None,
                 schema: Optional[pulumi.Input['CassandraSchemaArgs']] = None):
        """
        Cosmos DB Cassandra table id object
        :param pulumi.Input[str] id: Name of the Cosmos DB Cassandra table
        :param pulumi.Input[int] default_ttl: Time to live of the Cosmos DB Cassandra table
        :param pulumi.Input['CassandraSchemaArgs'] schema: Schema of the Cosmos DB Cassandra table
        """
        pulumi.set(__self__, "id", id)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Name of the Cosmos DB Cassandra table
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Time to live of the Cosmos DB Cassandra table
        """
        return pulumi.get(self, "default_ttl")

    @default_ttl.setter
    def default_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_ttl", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input['CassandraSchemaArgs']]:
        """
        Schema of the Cosmos DB Cassandra table
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input['CassandraSchemaArgs']]):
        pulumi.set(self, "schema", value)


if not MYPY:
    class ClusterKeyArgsDict(TypedDict):
        """
        Cosmos DB Cassandra table cluster key
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Cosmos DB Cassandra table cluster key
        """
        order_by: NotRequired[pulumi.Input[str]]
        """
        Order of the Cosmos DB Cassandra table cluster key, only support "Asc" and "Desc"
        """
elif False:
    ClusterKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterKeyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 order_by: Optional[pulumi.Input[str]] = None):
        """
        Cosmos DB Cassandra table cluster key
        :param pulumi.Input[str] name: Name of the Cosmos DB Cassandra table cluster key
        :param pulumi.Input[str] order_by: Order of the Cosmos DB Cassandra table cluster key, only support "Asc" and "Desc"
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Cosmos DB Cassandra table cluster key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[pulumi.Input[str]]:
        """
        Order of the Cosmos DB Cassandra table cluster key, only support "Asc" and "Desc"
        """
        return pulumi.get(self, "order_by")

    @order_by.setter
    def order_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "order_by", value)


if not MYPY:
    class ColumnArgsDict(TypedDict):
        """
        Cosmos DB Cassandra table column
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Cosmos DB Cassandra table column
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the Cosmos DB Cassandra table column
        """
elif False:
    ColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ColumnArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Cosmos DB Cassandra table column
        :param pulumi.Input[str] name: Name of the Cosmos DB Cassandra table column
        :param pulumi.Input[str] type: Type of the Cosmos DB Cassandra table column
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Cosmos DB Cassandra table column
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the Cosmos DB Cassandra table column
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConflictResolutionPolicyArgsDict(TypedDict):
        """
        The conflict resolution policy for the container.
        """
        conflict_resolution_path: NotRequired[pulumi.Input[str]]
        """
        The conflict resolution path in the case of LastWriterWins mode.
        """
        conflict_resolution_procedure: NotRequired[pulumi.Input[str]]
        """
        The procedure to resolve conflicts in the case of custom mode.
        """
        mode: NotRequired[pulumi.Input[Union[str, 'ConflictResolutionMode']]]
        """
        Indicates the conflict resolution mode.
        """
elif False:
    ConflictResolutionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConflictResolutionPolicyArgs:
    def __init__(__self__, *,
                 conflict_resolution_path: Optional[pulumi.Input[str]] = None,
                 conflict_resolution_procedure: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[Union[str, 'ConflictResolutionMode']]] = None):
        """
        The conflict resolution policy for the container.
        :param pulumi.Input[str] conflict_resolution_path: The conflict resolution path in the case of LastWriterWins mode.
        :param pulumi.Input[str] conflict_resolution_procedure: The procedure to resolve conflicts in the case of custom mode.
        :param pulumi.Input[Union[str, 'ConflictResolutionMode']] mode: Indicates the conflict resolution mode.
        """
        if conflict_resolution_path is not None:
            pulumi.set(__self__, "conflict_resolution_path", conflict_resolution_path)
        if conflict_resolution_procedure is not None:
            pulumi.set(__self__, "conflict_resolution_procedure", conflict_resolution_procedure)
        if mode is None:
            mode = 'LastWriterWins'
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="conflictResolutionPath")
    def conflict_resolution_path(self) -> Optional[pulumi.Input[str]]:
        """
        The conflict resolution path in the case of LastWriterWins mode.
        """
        return pulumi.get(self, "conflict_resolution_path")

    @conflict_resolution_path.setter
    def conflict_resolution_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "conflict_resolution_path", value)

    @property
    @pulumi.getter(name="conflictResolutionProcedure")
    def conflict_resolution_procedure(self) -> Optional[pulumi.Input[str]]:
        """
        The procedure to resolve conflicts in the case of custom mode.
        """
        return pulumi.get(self, "conflict_resolution_procedure")

    @conflict_resolution_procedure.setter
    def conflict_resolution_procedure(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "conflict_resolution_procedure", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[Union[str, 'ConflictResolutionMode']]]:
        """
        Indicates the conflict resolution mode.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[Union[str, 'ConflictResolutionMode']]]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ContainerPartitionKeyArgsDict(TypedDict):
        """
        The configuration of the partition key to be used for partitioning data into multiple partitions
        """
        kind: NotRequired[pulumi.Input[Union[str, 'PartitionKind']]]
        """
        Indicates the kind of algorithm used for partitioning
        """
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of paths using which data within the container can be partitioned
        """
elif False:
    ContainerPartitionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerPartitionKeyArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[Union[str, 'PartitionKind']]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The configuration of the partition key to be used for partitioning data into multiple partitions
        :param pulumi.Input[Union[str, 'PartitionKind']] kind: Indicates the kind of algorithm used for partitioning
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: List of paths using which data within the container can be partitioned
        """
        if kind is None:
            kind = 'Hash'
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[Union[str, 'PartitionKind']]]:
        """
        Indicates the kind of algorithm used for partitioning
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[Union[str, 'PartitionKind']]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of paths using which data within the container can be partitioned
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "paths", value)


if not MYPY:
    class ExcludedPathArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[str]]
        """
        The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
elif False:
    ExcludedPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExcludedPathArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class GremlinDatabaseResourceArgsDict(TypedDict):
        """
        Cosmos DB Gremlin database id object
        """
        id: pulumi.Input[str]
        """
        Name of the Cosmos DB Gremlin database
        """
elif False:
    GremlinDatabaseResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GremlinDatabaseResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        Cosmos DB Gremlin database id object
        :param pulumi.Input[str] id: Name of the Cosmos DB Gremlin database
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Name of the Cosmos DB Gremlin database
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class GremlinGraphResourceArgsDict(TypedDict):
        """
        Cosmos DB Gremlin graph resource object
        """
        id: pulumi.Input[str]
        """
        Name of the Cosmos DB Gremlin graph
        """
        conflict_resolution_policy: NotRequired[pulumi.Input['ConflictResolutionPolicyArgsDict']]
        """
        The conflict resolution policy for the graph.
        """
        default_ttl: NotRequired[pulumi.Input[int]]
        """
        Default time to live
        """
        indexing_policy: NotRequired[pulumi.Input['IndexingPolicyArgsDict']]
        """
        The configuration of the indexing policy. By default, the indexing is automatic for all document paths within the graph
        """
        partition_key: NotRequired[pulumi.Input['ContainerPartitionKeyArgsDict']]
        """
        The configuration of the partition key to be used for partitioning data into multiple partitions
        """
        unique_key_policy: NotRequired[pulumi.Input['UniqueKeyPolicyArgsDict']]
        """
        The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        """
elif False:
    GremlinGraphResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GremlinGraphResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 conflict_resolution_policy: Optional[pulumi.Input['ConflictResolutionPolicyArgs']] = None,
                 default_ttl: Optional[pulumi.Input[int]] = None,
                 indexing_policy: Optional[pulumi.Input['IndexingPolicyArgs']] = None,
                 partition_key: Optional[pulumi.Input['ContainerPartitionKeyArgs']] = None,
                 unique_key_policy: Optional[pulumi.Input['UniqueKeyPolicyArgs']] = None):
        """
        Cosmos DB Gremlin graph resource object
        :param pulumi.Input[str] id: Name of the Cosmos DB Gremlin graph
        :param pulumi.Input['ConflictResolutionPolicyArgs'] conflict_resolution_policy: The conflict resolution policy for the graph.
        :param pulumi.Input[int] default_ttl: Default time to live
        :param pulumi.Input['IndexingPolicyArgs'] indexing_policy: The configuration of the indexing policy. By default, the indexing is automatic for all document paths within the graph
        :param pulumi.Input['ContainerPartitionKeyArgs'] partition_key: The configuration of the partition key to be used for partitioning data into multiple partitions
        :param pulumi.Input['UniqueKeyPolicyArgs'] unique_key_policy: The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        """
        pulumi.set(__self__, "id", id)
        if conflict_resolution_policy is not None:
            pulumi.set(__self__, "conflict_resolution_policy", conflict_resolution_policy)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if indexing_policy is not None:
            pulumi.set(__self__, "indexing_policy", indexing_policy)
        if partition_key is not None:
            pulumi.set(__self__, "partition_key", partition_key)
        if unique_key_policy is not None:
            pulumi.set(__self__, "unique_key_policy", unique_key_policy)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Name of the Cosmos DB Gremlin graph
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="conflictResolutionPolicy")
    def conflict_resolution_policy(self) -> Optional[pulumi.Input['ConflictResolutionPolicyArgs']]:
        """
        The conflict resolution policy for the graph.
        """
        return pulumi.get(self, "conflict_resolution_policy")

    @conflict_resolution_policy.setter
    def conflict_resolution_policy(self, value: Optional[pulumi.Input['ConflictResolutionPolicyArgs']]):
        pulumi.set(self, "conflict_resolution_policy", value)

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Default time to live
        """
        return pulumi.get(self, "default_ttl")

    @default_ttl.setter
    def default_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_ttl", value)

    @property
    @pulumi.getter(name="indexingPolicy")
    def indexing_policy(self) -> Optional[pulumi.Input['IndexingPolicyArgs']]:
        """
        The configuration of the indexing policy. By default, the indexing is automatic for all document paths within the graph
        """
        return pulumi.get(self, "indexing_policy")

    @indexing_policy.setter
    def indexing_policy(self, value: Optional[pulumi.Input['IndexingPolicyArgs']]):
        pulumi.set(self, "indexing_policy", value)

    @property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> Optional[pulumi.Input['ContainerPartitionKeyArgs']]:
        """
        The configuration of the partition key to be used for partitioning data into multiple partitions
        """
        return pulumi.get(self, "partition_key")

    @partition_key.setter
    def partition_key(self, value: Optional[pulumi.Input['ContainerPartitionKeyArgs']]):
        pulumi.set(self, "partition_key", value)

    @property
    @pulumi.getter(name="uniqueKeyPolicy")
    def unique_key_policy(self) -> Optional[pulumi.Input['UniqueKeyPolicyArgs']]:
        """
        The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        """
        return pulumi.get(self, "unique_key_policy")

    @unique_key_policy.setter
    def unique_key_policy(self, value: Optional[pulumi.Input['UniqueKeyPolicyArgs']]):
        pulumi.set(self, "unique_key_policy", value)


if not MYPY:
    class IncludedPathArgsDict(TypedDict):
        """
        The paths that are included in indexing
        """
        indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input['IndexesArgsDict']]]]
        """
        List of indexes for this path
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
elif False:
    IncludedPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncludedPathArgs:
    def __init__(__self__, *,
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input['IndexesArgs']]]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        The paths that are included in indexing
        :param pulumi.Input[Sequence[pulumi.Input['IndexesArgs']]] indexes: List of indexes for this path
        :param pulumi.Input[str] path: The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexesArgs']]]]:
        """
        List of indexes for this path
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexesArgs']]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path for which the indexing behavior applies to. Index paths typically start with root and end with wildcard (/path/*)
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class IndexesArgsDict(TypedDict):
        """
        The indexes for the path.
        """
        data_type: NotRequired[pulumi.Input[Union[str, 'DataType']]]
        """
        The datatype for which the indexing behavior is applied to.
        """
        kind: NotRequired[pulumi.Input[Union[str, 'IndexKind']]]
        """
        Indicates the type of index.
        """
        precision: NotRequired[pulumi.Input[int]]
        """
        The precision of the index. -1 is maximum precision.
        """
elif False:
    IndexesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexesArgs:
    def __init__(__self__, *,
                 data_type: Optional[pulumi.Input[Union[str, 'DataType']]] = None,
                 kind: Optional[pulumi.Input[Union[str, 'IndexKind']]] = None,
                 precision: Optional[pulumi.Input[int]] = None):
        """
        The indexes for the path.
        :param pulumi.Input[Union[str, 'DataType']] data_type: The datatype for which the indexing behavior is applied to.
        :param pulumi.Input[Union[str, 'IndexKind']] kind: Indicates the type of index.
        :param pulumi.Input[int] precision: The precision of the index. -1 is maximum precision.
        """
        if data_type is None:
            data_type = 'String'
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if kind is None:
            kind = 'Hash'
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[Union[str, 'DataType']]]:
        """
        The datatype for which the indexing behavior is applied to.
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[Union[str, 'DataType']]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[Union[str, 'IndexKind']]]:
        """
        Indicates the type of index.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[Union[str, 'IndexKind']]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        The precision of the index. -1 is maximum precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)


if not MYPY:
    class IndexingPolicyArgsDict(TypedDict):
        """
        Cosmos DB indexing policy
        """
        automatic: NotRequired[pulumi.Input[bool]]
        """
        Indicates if the indexing policy is automatic
        """
        excluded_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExcludedPathArgsDict']]]]
        """
        List of paths to exclude from indexing
        """
        included_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['IncludedPathArgsDict']]]]
        """
        List of paths to include in the indexing
        """
        indexing_mode: NotRequired[pulumi.Input[Union[str, 'IndexingMode']]]
        """
        Indicates the indexing mode.
        """
elif False:
    IndexingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexingPolicyArgs:
    def __init__(__self__, *,
                 automatic: Optional[pulumi.Input[bool]] = None,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input['ExcludedPathArgs']]]] = None,
                 included_paths: Optional[pulumi.Input[Sequence[pulumi.Input['IncludedPathArgs']]]] = None,
                 indexing_mode: Optional[pulumi.Input[Union[str, 'IndexingMode']]] = None):
        """
        Cosmos DB indexing policy
        :param pulumi.Input[bool] automatic: Indicates if the indexing policy is automatic
        :param pulumi.Input[Sequence[pulumi.Input['ExcludedPathArgs']]] excluded_paths: List of paths to exclude from indexing
        :param pulumi.Input[Sequence[pulumi.Input['IncludedPathArgs']]] included_paths: List of paths to include in the indexing
        :param pulumi.Input[Union[str, 'IndexingMode']] indexing_mode: Indicates the indexing mode.
        """
        if automatic is not None:
            pulumi.set(__self__, "automatic", automatic)
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if included_paths is not None:
            pulumi.set(__self__, "included_paths", included_paths)
        if indexing_mode is None:
            indexing_mode = 'Consistent'
        if indexing_mode is not None:
            pulumi.set(__self__, "indexing_mode", indexing_mode)

    @property
    @pulumi.getter
    def automatic(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the indexing policy is automatic
        """
        return pulumi.get(self, "automatic")

    @automatic.setter
    def automatic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automatic", value)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExcludedPathArgs']]]]:
        """
        List of paths to exclude from indexing
        """
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExcludedPathArgs']]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter(name="includedPaths")
    def included_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IncludedPathArgs']]]]:
        """
        List of paths to include in the indexing
        """
        return pulumi.get(self, "included_paths")

    @included_paths.setter
    def included_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IncludedPathArgs']]]]):
        pulumi.set(self, "included_paths", value)

    @property
    @pulumi.getter(name="indexingMode")
    def indexing_mode(self) -> Optional[pulumi.Input[Union[str, 'IndexingMode']]]:
        """
        Indicates the indexing mode.
        """
        return pulumi.get(self, "indexing_mode")

    @indexing_mode.setter
    def indexing_mode(self, value: Optional[pulumi.Input[Union[str, 'IndexingMode']]]):
        pulumi.set(self, "indexing_mode", value)


if not MYPY:
    class MongoDBCollectionResourceArgsDict(TypedDict):
        """
        Cosmos DB MongoDB collection resource object
        """
        id: pulumi.Input[str]
        """
        Name of the Cosmos DB MongoDB collection
        """
        indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input['MongoIndexArgsDict']]]]
        """
        List of index keys
        """
        shard_key: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A key-value pair of shard keys to be applied for the request.
        """
elif False:
    MongoDBCollectionResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoDBCollectionResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 indexes: Optional[pulumi.Input[Sequence[pulumi.Input['MongoIndexArgs']]]] = None,
                 shard_key: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Cosmos DB MongoDB collection resource object
        :param pulumi.Input[str] id: Name of the Cosmos DB MongoDB collection
        :param pulumi.Input[Sequence[pulumi.Input['MongoIndexArgs']]] indexes: List of index keys
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] shard_key: A key-value pair of shard keys to be applied for the request.
        """
        pulumi.set(__self__, "id", id)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if shard_key is not None:
            pulumi.set(__self__, "shard_key", shard_key)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Name of the Cosmos DB MongoDB collection
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MongoIndexArgs']]]]:
        """
        List of index keys
        """
        return pulumi.get(self, "indexes")

    @indexes.setter
    def indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MongoIndexArgs']]]]):
        pulumi.set(self, "indexes", value)

    @property
    @pulumi.getter(name="shardKey")
    def shard_key(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A key-value pair of shard keys to be applied for the request.
        """
        return pulumi.get(self, "shard_key")

    @shard_key.setter
    def shard_key(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "shard_key", value)


if not MYPY:
    class MongoDBDatabaseResourceArgsDict(TypedDict):
        """
        Cosmos DB MongoDB database id object
        """
        id: pulumi.Input[str]
        """
        Name of the Cosmos DB MongoDB database
        """
elif False:
    MongoDBDatabaseResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoDBDatabaseResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        Cosmos DB MongoDB database id object
        :param pulumi.Input[str] id: Name of the Cosmos DB MongoDB database
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Name of the Cosmos DB MongoDB database
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class MongoIndexKeysArgsDict(TypedDict):
        """
        Cosmos DB MongoDB collection resource object
        """
        keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of keys for each MongoDB collection in the Azure Cosmos DB service
        """
elif False:
    MongoIndexKeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoIndexKeysArgs:
    def __init__(__self__, *,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Cosmos DB MongoDB collection resource object
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: List of keys for each MongoDB collection in the Azure Cosmos DB service
        """
        if keys is not None:
            pulumi.set(__self__, "keys", keys)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of keys for each MongoDB collection in the Azure Cosmos DB service
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "keys", value)


if not MYPY:
    class MongoIndexOptionsArgsDict(TypedDict):
        """
        Cosmos DB MongoDB collection index options
        """
        expire_after_seconds: NotRequired[pulumi.Input[int]]
        """
        Expire after seconds
        """
        unique: NotRequired[pulumi.Input[bool]]
        """
        Is unique or not
        """
elif False:
    MongoIndexOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoIndexOptionsArgs:
    def __init__(__self__, *,
                 expire_after_seconds: Optional[pulumi.Input[int]] = None,
                 unique: Optional[pulumi.Input[bool]] = None):
        """
        Cosmos DB MongoDB collection index options
        :param pulumi.Input[int] expire_after_seconds: Expire after seconds
        :param pulumi.Input[bool] unique: Is unique or not
        """
        if expire_after_seconds is not None:
            pulumi.set(__self__, "expire_after_seconds", expire_after_seconds)
        if unique is not None:
            pulumi.set(__self__, "unique", unique)

    @property
    @pulumi.getter(name="expireAfterSeconds")
    def expire_after_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Expire after seconds
        """
        return pulumi.get(self, "expire_after_seconds")

    @expire_after_seconds.setter
    def expire_after_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire_after_seconds", value)

    @property
    @pulumi.getter
    def unique(self) -> Optional[pulumi.Input[bool]]:
        """
        Is unique or not
        """
        return pulumi.get(self, "unique")

    @unique.setter
    def unique(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "unique", value)


if not MYPY:
    class MongoIndexArgsDict(TypedDict):
        """
        Cosmos DB MongoDB collection index key
        """
        key: NotRequired[pulumi.Input['MongoIndexKeysArgsDict']]
        """
        Cosmos DB MongoDB collection index keys
        """
        options: NotRequired[pulumi.Input['MongoIndexOptionsArgsDict']]
        """
        Cosmos DB MongoDB collection index key options
        """
elif False:
    MongoIndexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MongoIndexArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input['MongoIndexKeysArgs']] = None,
                 options: Optional[pulumi.Input['MongoIndexOptionsArgs']] = None):
        """
        Cosmos DB MongoDB collection index key
        :param pulumi.Input['MongoIndexKeysArgs'] key: Cosmos DB MongoDB collection index keys
        :param pulumi.Input['MongoIndexOptionsArgs'] options: Cosmos DB MongoDB collection index key options
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input['MongoIndexKeysArgs']]:
        """
        Cosmos DB MongoDB collection index keys
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input['MongoIndexKeysArgs']]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input['MongoIndexOptionsArgs']]:
        """
        Cosmos DB MongoDB collection index key options
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input['MongoIndexOptionsArgs']]):
        pulumi.set(self, "options", value)


if not MYPY:
    class SqlContainerResourceArgsDict(TypedDict):
        """
        Cosmos DB SQL container resource object
        """
        id: pulumi.Input[str]
        """
        Name of the Cosmos DB SQL container
        """
        conflict_resolution_policy: NotRequired[pulumi.Input['ConflictResolutionPolicyArgsDict']]
        """
        The conflict resolution policy for the container.
        """
        default_ttl: NotRequired[pulumi.Input[int]]
        """
        Default time to live
        """
        indexing_policy: NotRequired[pulumi.Input['IndexingPolicyArgsDict']]
        """
        The configuration of the indexing policy. By default, the indexing is automatic for all document paths within the container
        """
        partition_key: NotRequired[pulumi.Input['ContainerPartitionKeyArgsDict']]
        """
        The configuration of the partition key to be used for partitioning data into multiple partitions
        """
        unique_key_policy: NotRequired[pulumi.Input['UniqueKeyPolicyArgsDict']]
        """
        The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        """
elif False:
    SqlContainerResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlContainerResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 conflict_resolution_policy: Optional[pulumi.Input['ConflictResolutionPolicyArgs']] = None,
                 default_ttl: Optional[pulumi.Input[int]] = None,
                 indexing_policy: Optional[pulumi.Input['IndexingPolicyArgs']] = None,
                 partition_key: Optional[pulumi.Input['ContainerPartitionKeyArgs']] = None,
                 unique_key_policy: Optional[pulumi.Input['UniqueKeyPolicyArgs']] = None):
        """
        Cosmos DB SQL container resource object
        :param pulumi.Input[str] id: Name of the Cosmos DB SQL container
        :param pulumi.Input['ConflictResolutionPolicyArgs'] conflict_resolution_policy: The conflict resolution policy for the container.
        :param pulumi.Input[int] default_ttl: Default time to live
        :param pulumi.Input['IndexingPolicyArgs'] indexing_policy: The configuration of the indexing policy. By default, the indexing is automatic for all document paths within the container
        :param pulumi.Input['ContainerPartitionKeyArgs'] partition_key: The configuration of the partition key to be used for partitioning data into multiple partitions
        :param pulumi.Input['UniqueKeyPolicyArgs'] unique_key_policy: The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        """
        pulumi.set(__self__, "id", id)
        if conflict_resolution_policy is not None:
            pulumi.set(__self__, "conflict_resolution_policy", conflict_resolution_policy)
        if default_ttl is not None:
            pulumi.set(__self__, "default_ttl", default_ttl)
        if indexing_policy is not None:
            pulumi.set(__self__, "indexing_policy", indexing_policy)
        if partition_key is not None:
            pulumi.set(__self__, "partition_key", partition_key)
        if unique_key_policy is not None:
            pulumi.set(__self__, "unique_key_policy", unique_key_policy)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Name of the Cosmos DB SQL container
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="conflictResolutionPolicy")
    def conflict_resolution_policy(self) -> Optional[pulumi.Input['ConflictResolutionPolicyArgs']]:
        """
        The conflict resolution policy for the container.
        """
        return pulumi.get(self, "conflict_resolution_policy")

    @conflict_resolution_policy.setter
    def conflict_resolution_policy(self, value: Optional[pulumi.Input['ConflictResolutionPolicyArgs']]):
        pulumi.set(self, "conflict_resolution_policy", value)

    @property
    @pulumi.getter(name="defaultTtl")
    def default_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Default time to live
        """
        return pulumi.get(self, "default_ttl")

    @default_ttl.setter
    def default_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_ttl", value)

    @property
    @pulumi.getter(name="indexingPolicy")
    def indexing_policy(self) -> Optional[pulumi.Input['IndexingPolicyArgs']]:
        """
        The configuration of the indexing policy. By default, the indexing is automatic for all document paths within the container
        """
        return pulumi.get(self, "indexing_policy")

    @indexing_policy.setter
    def indexing_policy(self, value: Optional[pulumi.Input['IndexingPolicyArgs']]):
        pulumi.set(self, "indexing_policy", value)

    @property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> Optional[pulumi.Input['ContainerPartitionKeyArgs']]:
        """
        The configuration of the partition key to be used for partitioning data into multiple partitions
        """
        return pulumi.get(self, "partition_key")

    @partition_key.setter
    def partition_key(self, value: Optional[pulumi.Input['ContainerPartitionKeyArgs']]):
        pulumi.set(self, "partition_key", value)

    @property
    @pulumi.getter(name="uniqueKeyPolicy")
    def unique_key_policy(self) -> Optional[pulumi.Input['UniqueKeyPolicyArgs']]:
        """
        The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        """
        return pulumi.get(self, "unique_key_policy")

    @unique_key_policy.setter
    def unique_key_policy(self, value: Optional[pulumi.Input['UniqueKeyPolicyArgs']]):
        pulumi.set(self, "unique_key_policy", value)


if not MYPY:
    class SqlDatabaseResourceArgsDict(TypedDict):
        """
        Cosmos DB SQL database id object
        """
        id: pulumi.Input[str]
        """
        Name of the Cosmos DB SQL database
        """
elif False:
    SqlDatabaseResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SqlDatabaseResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        Cosmos DB SQL database id object
        :param pulumi.Input[str] id: Name of the Cosmos DB SQL database
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Name of the Cosmos DB SQL database
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class TableResourceArgsDict(TypedDict):
        """
        Cosmos DB table id object
        """
        id: pulumi.Input[str]
        """
        Name of the Cosmos DB table
        """
elif False:
    TableResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableResourceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        Cosmos DB table id object
        :param pulumi.Input[str] id: Name of the Cosmos DB table
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Name of the Cosmos DB table
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class UniqueKeyPolicyArgsDict(TypedDict):
        """
        The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        """
        unique_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['UniqueKeyArgsDict']]]]
        """
        List of unique keys on that enforces uniqueness constraint on documents in the collection in the Azure Cosmos DB service.
        """
elif False:
    UniqueKeyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UniqueKeyPolicyArgs:
    def __init__(__self__, *,
                 unique_keys: Optional[pulumi.Input[Sequence[pulumi.Input['UniqueKeyArgs']]]] = None):
        """
        The unique key policy configuration for specifying uniqueness constraints on documents in the collection in the Azure Cosmos DB service.
        :param pulumi.Input[Sequence[pulumi.Input['UniqueKeyArgs']]] unique_keys: List of unique keys on that enforces uniqueness constraint on documents in the collection in the Azure Cosmos DB service.
        """
        if unique_keys is not None:
            pulumi.set(__self__, "unique_keys", unique_keys)

    @property
    @pulumi.getter(name="uniqueKeys")
    def unique_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UniqueKeyArgs']]]]:
        """
        List of unique keys on that enforces uniqueness constraint on documents in the collection in the Azure Cosmos DB service.
        """
        return pulumi.get(self, "unique_keys")

    @unique_keys.setter
    def unique_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UniqueKeyArgs']]]]):
        pulumi.set(self, "unique_keys", value)


if not MYPY:
    class UniqueKeyArgsDict(TypedDict):
        """
        The unique key on that enforces uniqueness constraint on documents in the collection in the Azure Cosmos DB service.
        """
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of paths must be unique for each document in the Azure Cosmos DB service
        """
elif False:
    UniqueKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UniqueKeyArgs:
    def __init__(__self__, *,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The unique key on that enforces uniqueness constraint on documents in the collection in the Azure Cosmos DB service.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: List of paths must be unique for each document in the Azure Cosmos DB service
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of paths must be unique for each document in the Azure Cosmos DB service
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "paths", value)


