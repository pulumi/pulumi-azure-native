# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'CertificateArgs',
    'CertificateArgsDict',
    'ClusterResourcePropertiesArgs',
    'ClusterResourcePropertiesArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'SeedNodeArgs',
    'SeedNodeArgsDict',
]

MYPY = False

if not MYPY:
    class CertificateArgsDict(TypedDict):
        pem: NotRequired[pulumi.Input[str]]
        """
        PEM formatted public key.
        """
elif False:
    CertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateArgs:
    def __init__(__self__, *,
                 pem: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pem: PEM formatted public key.
        """
        if pem is not None:
            pulumi.set(__self__, "pem", pem)

    @property
    @pulumi.getter
    def pem(self) -> Optional[pulumi.Input[str]]:
        """
        PEM formatted public key.
        """
        return pulumi.get(self, "pem")

    @pem.setter
    def pem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pem", value)


if not MYPY:
    class ClusterResourcePropertiesArgsDict(TypedDict):
        """
        Properties of a managed Cassandra cluster.
        """
        authentication_method: NotRequired[pulumi.Input[Union[str, 'AuthenticationMethod']]]
        """
        Which authentication method Cassandra should use to authenticate clients. 'None' turns off authentication, so should not be used except in emergencies. 'Cassandra' is the default password based authentication. The default is 'Cassandra'.
        """
        cassandra_version: NotRequired[pulumi.Input[str]]
        """
        Which version of Cassandra should this cluster converge to running (e.g., 3.11). When updated, the cluster may take some time to migrate to the new version.
        """
        client_certificates: NotRequired[pulumi.Input[Sequence[pulumi.Input['CertificateArgsDict']]]]
        """
        List of TLS certificates used to authorize clients connecting to the cluster. All connections are TLS encrypted whether clientCertificates is set or not, but if clientCertificates is set, the managed Cassandra cluster will reject all connections not bearing a TLS client certificate that can be validated from one or more of the public certificates in this property.
        """
        cluster_name_override: NotRequired[pulumi.Input[str]]
        """
        If you need to set the clusterName property in cassandra.yaml to something besides the resource name of the cluster, set the value to use on this property.
        """
        delegated_management_subnet_id: NotRequired[pulumi.Input[str]]
        """
        Resource id of a subnet that this cluster's management service should have its network interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The resource id must be of the form '/subscriptions/<subscription id>/resourceGroups/<resource group>/providers/Microsoft.Network/virtualNetworks/<virtual network>/subnets/<subnet>'
        """
        external_gossip_certificates: NotRequired[pulumi.Input[Sequence[pulumi.Input['CertificateArgsDict']]]]
        """
        List of TLS certificates used to authorize gossip from unmanaged data centers. The TLS certificates of all nodes in unmanaged data centers must be verifiable using one of the certificates provided in this property.
        """
        external_seed_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['SeedNodeArgsDict']]]]
        """
        List of IP addresses of seed nodes in unmanaged data centers. These will be added to the seed node lists of all managed nodes.
        """
        hours_between_backups: NotRequired[pulumi.Input[int]]
        """
        Number of hours to wait between taking a backup of the cluster. To disable backups, set this property to 0.
        """
        initial_cassandra_admin_password: NotRequired[pulumi.Input[str]]
        """
        Initial password for clients connecting as admin to the cluster. Should be changed after cluster creation. Returns null on GET. This field only applies when the authenticationMethod field is 'Cassandra'.
        """
        prometheus_endpoint: NotRequired[pulumi.Input['SeedNodeArgsDict']]
        """
        Hostname or IP address where the Prometheus endpoint containing data about the managed Cassandra nodes can be reached.
        """
        provisioning_state: NotRequired[pulumi.Input[Union[str, 'ManagedCassandraProvisioningState']]]
        """
        The status of the resource at the time the operation was called.
        """
        repair_enabled: NotRequired[pulumi.Input[bool]]
        """
        Should automatic repairs run on this cluster? If omitted, this is true, and should stay true unless you are running a hybrid cluster where you are already doing your own repairs.
        """
        restore_from_backup_id: NotRequired[pulumi.Input[str]]
        """
        To create an empty cluster, omit this field or set it to null. To restore a backup into a new cluster, set this field to the resource id of the backup.
        """
elif False:
    ClusterResourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterResourcePropertiesArgs:
    def __init__(__self__, *,
                 authentication_method: Optional[pulumi.Input[Union[str, 'AuthenticationMethod']]] = None,
                 cassandra_version: Optional[pulumi.Input[str]] = None,
                 client_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]] = None,
                 cluster_name_override: Optional[pulumi.Input[str]] = None,
                 delegated_management_subnet_id: Optional[pulumi.Input[str]] = None,
                 external_gossip_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]] = None,
                 external_seed_nodes: Optional[pulumi.Input[Sequence[pulumi.Input['SeedNodeArgs']]]] = None,
                 hours_between_backups: Optional[pulumi.Input[int]] = None,
                 initial_cassandra_admin_password: Optional[pulumi.Input[str]] = None,
                 prometheus_endpoint: Optional[pulumi.Input['SeedNodeArgs']] = None,
                 provisioning_state: Optional[pulumi.Input[Union[str, 'ManagedCassandraProvisioningState']]] = None,
                 repair_enabled: Optional[pulumi.Input[bool]] = None,
                 restore_from_backup_id: Optional[pulumi.Input[str]] = None):
        """
        Properties of a managed Cassandra cluster.
        :param pulumi.Input[Union[str, 'AuthenticationMethod']] authentication_method: Which authentication method Cassandra should use to authenticate clients. 'None' turns off authentication, so should not be used except in emergencies. 'Cassandra' is the default password based authentication. The default is 'Cassandra'.
        :param pulumi.Input[str] cassandra_version: Which version of Cassandra should this cluster converge to running (e.g., 3.11). When updated, the cluster may take some time to migrate to the new version.
        :param pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]] client_certificates: List of TLS certificates used to authorize clients connecting to the cluster. All connections are TLS encrypted whether clientCertificates is set or not, but if clientCertificates is set, the managed Cassandra cluster will reject all connections not bearing a TLS client certificate that can be validated from one or more of the public certificates in this property.
        :param pulumi.Input[str] cluster_name_override: If you need to set the clusterName property in cassandra.yaml to something besides the resource name of the cluster, set the value to use on this property.
        :param pulumi.Input[str] delegated_management_subnet_id: Resource id of a subnet that this cluster's management service should have its network interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The resource id must be of the form '/subscriptions/<subscription id>/resourceGroups/<resource group>/providers/Microsoft.Network/virtualNetworks/<virtual network>/subnets/<subnet>'
        :param pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]] external_gossip_certificates: List of TLS certificates used to authorize gossip from unmanaged data centers. The TLS certificates of all nodes in unmanaged data centers must be verifiable using one of the certificates provided in this property.
        :param pulumi.Input[Sequence[pulumi.Input['SeedNodeArgs']]] external_seed_nodes: List of IP addresses of seed nodes in unmanaged data centers. These will be added to the seed node lists of all managed nodes.
        :param pulumi.Input[int] hours_between_backups: Number of hours to wait between taking a backup of the cluster. To disable backups, set this property to 0.
        :param pulumi.Input[str] initial_cassandra_admin_password: Initial password for clients connecting as admin to the cluster. Should be changed after cluster creation. Returns null on GET. This field only applies when the authenticationMethod field is 'Cassandra'.
        :param pulumi.Input['SeedNodeArgs'] prometheus_endpoint: Hostname or IP address where the Prometheus endpoint containing data about the managed Cassandra nodes can be reached.
        :param pulumi.Input[Union[str, 'ManagedCassandraProvisioningState']] provisioning_state: The status of the resource at the time the operation was called.
        :param pulumi.Input[bool] repair_enabled: Should automatic repairs run on this cluster? If omitted, this is true, and should stay true unless you are running a hybrid cluster where you are already doing your own repairs.
        :param pulumi.Input[str] restore_from_backup_id: To create an empty cluster, omit this field or set it to null. To restore a backup into a new cluster, set this field to the resource id of the backup.
        """
        if authentication_method is not None:
            pulumi.set(__self__, "authentication_method", authentication_method)
        if cassandra_version is not None:
            pulumi.set(__self__, "cassandra_version", cassandra_version)
        if client_certificates is not None:
            pulumi.set(__self__, "client_certificates", client_certificates)
        if cluster_name_override is not None:
            pulumi.set(__self__, "cluster_name_override", cluster_name_override)
        if delegated_management_subnet_id is not None:
            pulumi.set(__self__, "delegated_management_subnet_id", delegated_management_subnet_id)
        if external_gossip_certificates is not None:
            pulumi.set(__self__, "external_gossip_certificates", external_gossip_certificates)
        if external_seed_nodes is not None:
            pulumi.set(__self__, "external_seed_nodes", external_seed_nodes)
        if hours_between_backups is not None:
            pulumi.set(__self__, "hours_between_backups", hours_between_backups)
        if initial_cassandra_admin_password is not None:
            pulumi.set(__self__, "initial_cassandra_admin_password", initial_cassandra_admin_password)
        if prometheus_endpoint is not None:
            pulumi.set(__self__, "prometheus_endpoint", prometheus_endpoint)
        if provisioning_state is not None:
            pulumi.set(__self__, "provisioning_state", provisioning_state)
        if repair_enabled is not None:
            pulumi.set(__self__, "repair_enabled", repair_enabled)
        if restore_from_backup_id is not None:
            pulumi.set(__self__, "restore_from_backup_id", restore_from_backup_id)

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[pulumi.Input[Union[str, 'AuthenticationMethod']]]:
        """
        Which authentication method Cassandra should use to authenticate clients. 'None' turns off authentication, so should not be used except in emergencies. 'Cassandra' is the default password based authentication. The default is 'Cassandra'.
        """
        return pulumi.get(self, "authentication_method")

    @authentication_method.setter
    def authentication_method(self, value: Optional[pulumi.Input[Union[str, 'AuthenticationMethod']]]):
        pulumi.set(self, "authentication_method", value)

    @property
    @pulumi.getter(name="cassandraVersion")
    def cassandra_version(self) -> Optional[pulumi.Input[str]]:
        """
        Which version of Cassandra should this cluster converge to running (e.g., 3.11). When updated, the cluster may take some time to migrate to the new version.
        """
        return pulumi.get(self, "cassandra_version")

    @cassandra_version.setter
    def cassandra_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cassandra_version", value)

    @property
    @pulumi.getter(name="clientCertificates")
    def client_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]]:
        """
        List of TLS certificates used to authorize clients connecting to the cluster. All connections are TLS encrypted whether clientCertificates is set or not, but if clientCertificates is set, the managed Cassandra cluster will reject all connections not bearing a TLS client certificate that can be validated from one or more of the public certificates in this property.
        """
        return pulumi.get(self, "client_certificates")

    @client_certificates.setter
    def client_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]]):
        pulumi.set(self, "client_certificates", value)

    @property
    @pulumi.getter(name="clusterNameOverride")
    def cluster_name_override(self) -> Optional[pulumi.Input[str]]:
        """
        If you need to set the clusterName property in cassandra.yaml to something besides the resource name of the cluster, set the value to use on this property.
        """
        return pulumi.get(self, "cluster_name_override")

    @cluster_name_override.setter
    def cluster_name_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name_override", value)

    @property
    @pulumi.getter(name="delegatedManagementSubnetId")
    def delegated_management_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource id of a subnet that this cluster's management service should have its network interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The resource id must be of the form '/subscriptions/<subscription id>/resourceGroups/<resource group>/providers/Microsoft.Network/virtualNetworks/<virtual network>/subnets/<subnet>'
        """
        return pulumi.get(self, "delegated_management_subnet_id")

    @delegated_management_subnet_id.setter
    def delegated_management_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delegated_management_subnet_id", value)

    @property
    @pulumi.getter(name="externalGossipCertificates")
    def external_gossip_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]]:
        """
        List of TLS certificates used to authorize gossip from unmanaged data centers. The TLS certificates of all nodes in unmanaged data centers must be verifiable using one of the certificates provided in this property.
        """
        return pulumi.get(self, "external_gossip_certificates")

    @external_gossip_certificates.setter
    def external_gossip_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CertificateArgs']]]]):
        pulumi.set(self, "external_gossip_certificates", value)

    @property
    @pulumi.getter(name="externalSeedNodes")
    def external_seed_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SeedNodeArgs']]]]:
        """
        List of IP addresses of seed nodes in unmanaged data centers. These will be added to the seed node lists of all managed nodes.
        """
        return pulumi.get(self, "external_seed_nodes")

    @external_seed_nodes.setter
    def external_seed_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SeedNodeArgs']]]]):
        pulumi.set(self, "external_seed_nodes", value)

    @property
    @pulumi.getter(name="hoursBetweenBackups")
    def hours_between_backups(self) -> Optional[pulumi.Input[int]]:
        """
        Number of hours to wait between taking a backup of the cluster. To disable backups, set this property to 0.
        """
        return pulumi.get(self, "hours_between_backups")

    @hours_between_backups.setter
    def hours_between_backups(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours_between_backups", value)

    @property
    @pulumi.getter(name="initialCassandraAdminPassword")
    def initial_cassandra_admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        Initial password for clients connecting as admin to the cluster. Should be changed after cluster creation. Returns null on GET. This field only applies when the authenticationMethod field is 'Cassandra'.
        """
        return pulumi.get(self, "initial_cassandra_admin_password")

    @initial_cassandra_admin_password.setter
    def initial_cassandra_admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initial_cassandra_admin_password", value)

    @property
    @pulumi.getter(name="prometheusEndpoint")
    def prometheus_endpoint(self) -> Optional[pulumi.Input['SeedNodeArgs']]:
        """
        Hostname or IP address where the Prometheus endpoint containing data about the managed Cassandra nodes can be reached.
        """
        return pulumi.get(self, "prometheus_endpoint")

    @prometheus_endpoint.setter
    def prometheus_endpoint(self, value: Optional[pulumi.Input['SeedNodeArgs']]):
        pulumi.set(self, "prometheus_endpoint", value)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[pulumi.Input[Union[str, 'ManagedCassandraProvisioningState']]]:
        """
        The status of the resource at the time the operation was called.
        """
        return pulumi.get(self, "provisioning_state")

    @provisioning_state.setter
    def provisioning_state(self, value: Optional[pulumi.Input[Union[str, 'ManagedCassandraProvisioningState']]]):
        pulumi.set(self, "provisioning_state", value)

    @property
    @pulumi.getter(name="repairEnabled")
    def repair_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Should automatic repairs run on this cluster? If omitted, this is true, and should stay true unless you are running a hybrid cluster where you are already doing your own repairs.
        """
        return pulumi.get(self, "repair_enabled")

    @repair_enabled.setter
    def repair_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "repair_enabled", value)

    @property
    @pulumi.getter(name="restoreFromBackupId")
    def restore_from_backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        To create an empty cluster, omit this field or set it to null. To restore a backup into a new cluster, set this field to the resource id of the backup.
        """
        return pulumi.get(self, "restore_from_backup_id")

    @restore_from_backup_id.setter
    def restore_from_backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "restore_from_backup_id", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Identity for the resource.
        """
        type: NotRequired[pulumi.Input['ResourceIdentityType']]
        """
        The type of identity used for the resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ResourceIdentityType']] = None,
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Identity for the resource.
        :param pulumi.Input['ResourceIdentityType'] type: The type of identity used for the resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ResourceIdentityType']]:
        """
        The type of identity used for the resource. The type 'SystemAssigned,UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ResourceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of user identities associated with resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class SeedNodeArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[str]]
        """
        IP address of this seed node.
        """
elif False:
    SeedNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SeedNodeArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip_address: IP address of this seed node.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        IP address of this seed node.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)


