# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AllowedAudiencesValidationResponse',
    'AllowedPrincipalsResponse',
    'AppInsightsConfigurationResponse',
    'AppLogsConfigurationResponse',
    'AppRegistrationResponse',
    'AppleRegistrationResponse',
    'AppleResponse',
    'AuthPlatformResponse',
    'AzureActiveDirectoryLoginResponse',
    'AzureActiveDirectoryRegistrationResponse',
    'AzureActiveDirectoryResponse',
    'AzureActiveDirectoryValidationResponse',
    'AzureCredentialsResponse',
    'AzureFilePropertiesResponse',
    'AzureStaticWebAppsRegistrationResponse',
    'AzureStaticWebAppsResponse',
    'BlobStorageTokenStoreResponse',
    'BuildConfigurationResponse',
    'CertificateKeyVaultPropertiesResponse',
    'CertificateResponseProperties',
    'CircuitBreakerPolicyResponse',
    'ClientRegistrationResponse',
    'ConfigurationResponse',
    'ConnectedEnvironmentStorageResponseProperties',
    'ContainerAppProbeResponse',
    'ContainerAppProbeResponseHttpGet',
    'ContainerAppProbeResponseHttpHeaders',
    'ContainerAppProbeResponseTcpSocket',
    'ContainerAppResponsePatchingConfiguration',
    'ContainerAppSecretResponse',
    'ContainerRegistryResponse',
    'ContainerRegistryWithCustomImageResponse',
    'ContainerResourcesResponse',
    'ContainerResponse',
    'CookieExpirationResponse',
    'CorsPolicyResponse',
    'CustomContainerTemplateResponse',
    'CustomDomainConfigurationResponse',
    'CustomDomainResponse',
    'CustomHostnameAnalysisResultResponseCustomDomainVerificationFailureInfo',
    'CustomHostnameAnalysisResultResponseDetails',
    'CustomOpenIdConnectProviderResponse',
    'CustomScaleRuleResponse',
    'DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationResponse',
    'DaprComponentResiliencyPolicyConfigurationResponse',
    'DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationResponse',
    'DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationResponse',
    'DaprComponentResiliencyPolicyTimeoutPolicyConfigurationResponse',
    'DaprComponentServiceBindingResponse',
    'DaprConfigurationResponse',
    'DaprMetadataResponse',
    'DaprResponse',
    'DaprResponseAppHealth',
    'DaprSecretResponse',
    'DaprServiceBindMetadataResponse',
    'DaprSubscriptionBulkSubscribeOptionsResponse',
    'DaprSubscriptionRouteRuleResponse',
    'DaprSubscriptionRoutesResponse',
    'DataDogConfigurationResponse',
    'DefaultAuthorizationPolicyResponse',
    'DestinationsConfigurationResponse',
    'DiskEncryptionConfigurationResponse',
    'DiskEncryptionConfigurationResponseAuth',
    'DiskEncryptionConfigurationResponseKeyVaultConfiguration',
    'DotNetComponentConfigurationPropertyResponse',
    'DotNetComponentServiceBindResponse',
    'DynamicPoolConfigurationResponse',
    'EncryptionSettingsResponse',
    'EnvironmentVarResponse',
    'EnvironmentVariableResponse',
    'ErrorEntityResponse',
    'ExtendedLocationResponse',
    'FacebookResponse',
    'ForwardProxyResponse',
    'GitHubResponse',
    'GithubActionConfigurationResponse',
    'GlobalValidationResponse',
    'GoogleResponse',
    'HeaderMatchResponse',
    'HeaderResponse',
    'HttpConnectionPoolResponse',
    'HttpGetResponse',
    'HttpRetryPolicyResponse',
    'HttpRouteActionResponse',
    'HttpRouteConfigResponseProperties',
    'HttpRouteMatchResponse',
    'HttpRouteProvisioningErrorsResponse',
    'HttpRouteResponse',
    'HttpRouteRuleResponse',
    'HttpRouteTargetResponse',
    'HttpScaleRuleResponse',
    'HttpSettingsResponse',
    'HttpSettingsRoutesResponse',
    'IdentityProvidersResponse',
    'IdentitySettingsResponse',
    'IngressConfigurationResponse',
    'IngressConfigurationResponseScale',
    'IngressPortMappingResponse',
    'IngressResponse',
    'IngressResponseStickySessions',
    'InitContainerResponse',
    'IpSecurityRestrictionRuleResponse',
    'JavaComponentConfigurationPropertyResponse',
    'JavaComponentIngressResponse',
    'JavaComponentPropertiesResponseScale',
    'JavaComponentServiceBindResponse',
    'JobConfigurationResponse',
    'JobConfigurationResponseEventTriggerConfig',
    'JobConfigurationResponseManualTriggerConfig',
    'JobConfigurationResponseScheduleTriggerConfig',
    'JobScaleResponse',
    'JobScaleRuleResponse',
    'JobTemplateResponse',
    'JwtClaimChecksResponse',
    'KedaConfigurationResponse',
    'LifecycleConfigurationResponse',
    'LogAnalyticsConfigurationResponse',
    'LoggerSettingResponse',
    'LoginResponse',
    'LoginRoutesResponse',
    'LoginScopesResponse',
    'LogsConfigurationResponse',
    'ManagedCertificateResponseProperties',
    'ManagedEnvironmentResponseEncryption',
    'ManagedEnvironmentResponsePeerAuthentication',
    'ManagedEnvironmentResponsePeerTrafficConfiguration',
    'ManagedEnvironmentStorageResponseProperties',
    'ManagedIdentitySettingResponse',
    'ManagedServiceIdentityResponse',
    'MetricsConfigurationResponse',
    'MtlsResponse',
    'NacosComponentResponse',
    'NfsAzureFilePropertiesResponse',
    'NonceResponse',
    'OpenIdConnectClientCredentialResponse',
    'OpenIdConnectConfigResponse',
    'OpenIdConnectLoginResponse',
    'OpenIdConnectRegistrationResponse',
    'OpenTelemetryConfigurationResponse',
    'OtlpConfigurationResponse',
    'PreBuildStepResponse',
    'PrivateEndpointConnectionResponse',
    'PrivateEndpointResponse',
    'PrivateLinkServiceConnectionStateResponse',
    'QueueScaleRuleResponse',
    'RegistryCredentialsResponse',
    'RegistryInfoResponse',
    'RuntimeResponse',
    'RuntimeResponseDotnet',
    'RuntimeResponseJava',
    'RuntimeResponseJavaAgent',
    'RuntimeResponseLogging',
    'ScaleConfigurationResponse',
    'ScaleResponse',
    'ScaleRuleAuthResponse',
    'ScaleRuleResponse',
    'ScgRouteResponse',
    'ScheduledEntryResponse',
    'SecretKeyVaultPropertiesResponse',
    'SecretResponse',
    'SecretVolumeItemResponse',
    'ServiceBindResponse',
    'ServiceResponse',
    'SessionContainerResourcesResponse',
    'SessionContainerResponse',
    'SessionIngressResponse',
    'SessionNetworkConfigurationResponse',
    'SessionPoolSecretResponse',
    'SessionProbeResponse',
    'SessionProbeResponseHttpGet',
    'SessionProbeResponseHttpHeaders',
    'SessionProbeResponseTcpSocket',
    'SessionRegistryCredentialsResponse',
    'SmbStorageResponse',
    'SpringBootAdminComponentResponse',
    'SpringCloudConfigComponentResponse',
    'SpringCloudEurekaComponentResponse',
    'SpringCloudGatewayComponentResponse',
    'SystemDataResponse',
    'TcpConnectionPoolResponse',
    'TcpRetryPolicyResponse',
    'TcpScaleRuleResponse',
    'TemplateResponse',
    'TimeoutPolicyResponse',
    'TokenStoreResponse',
    'TracesConfigurationResponse',
    'TrafficWeightResponse',
    'TwitterRegistrationResponse',
    'TwitterResponse',
    'UserAssignedIdentityResponse',
    'VnetConfigurationResponse',
    'VolumeMountResponse',
    'VolumeResponse',
    'WorkflowEnvelopeResponseProperties',
    'WorkflowHealthResponse',
    'WorkloadProfileResponse',
]

@pulumi.output_type
class AllowedAudiencesValidationResponse(dict):
    """
    The configuration settings of the Allowed Audiences validation flow.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAudiences":
            suggest = "allowed_audiences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AllowedAudiencesValidationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AllowedAudiencesValidationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AllowedAudiencesValidationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_audiences: Optional[Sequence[_builtins.str]] = None):
        """
        The configuration settings of the Allowed Audiences validation flow.
        :param Sequence[_builtins.str] allowed_audiences: The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)

    @_builtins.property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[_builtins.str]]:
        """
        The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
        return pulumi.get(self, "allowed_audiences")


@pulumi.output_type
class AllowedPrincipalsResponse(dict):
    """
    The configuration settings of the Azure Active Directory allowed principals.
    """
    def __init__(__self__, *,
                 groups: Optional[Sequence[_builtins.str]] = None,
                 identities: Optional[Sequence[_builtins.str]] = None):
        """
        The configuration settings of the Azure Active Directory allowed principals.
        :param Sequence[_builtins.str] groups: The list of the allowed groups.
        :param Sequence[_builtins.str] identities: The list of the allowed identities.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if identities is not None:
            pulumi.set(__self__, "identities", identities)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of the allowed groups.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def identities(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of the allowed identities.
        """
        return pulumi.get(self, "identities")


@pulumi.output_type
class AppInsightsConfigurationResponse(dict):
    """
    Configuration of Application Insights 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppInsightsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppInsightsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppInsightsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: Optional[_builtins.str] = None):
        """
        Configuration of Application Insights 
        :param _builtins.str connection_string: Application Insights connection string
        """
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[_builtins.str]:
        """
        Application Insights connection string
        """
        return pulumi.get(self, "connection_string")


@pulumi.output_type
class AppLogsConfigurationResponse(dict):
    """
    Configuration of application logs
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logAnalyticsConfiguration":
            suggest = "log_analytics_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppLogsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppLogsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppLogsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional[_builtins.str] = None,
                 log_analytics_configuration: Optional['outputs.LogAnalyticsConfigurationResponse'] = None):
        """
        Configuration of application logs
        :param _builtins.str destination: Logs destination, can be 'log-analytics', 'azure-monitor' or 'none'
        :param 'LogAnalyticsConfigurationResponse' log_analytics_configuration: Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if log_analytics_configuration is not None:
            pulumi.set(__self__, "log_analytics_configuration", log_analytics_configuration)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[_builtins.str]:
        """
        Logs destination, can be 'log-analytics', 'azure-monitor' or 'none'
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsConfiguration")
    def log_analytics_configuration(self) -> Optional['outputs.LogAnalyticsConfigurationResponse']:
        """
        Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
        """
        return pulumi.get(self, "log_analytics_configuration")


@pulumi.output_type
class AppRegistrationResponse(dict):
    """
    The configuration settings of the app registration for providers that have app ids and app secrets
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appId":
            suggest = "app_id"
        elif key == "appSecretSettingName":
            suggest = "app_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_id: Optional[_builtins.str] = None,
                 app_secret_setting_name: Optional[_builtins.str] = None):
        """
        The configuration settings of the app registration for providers that have app ids and app secrets
        :param _builtins.str app_id: The App ID of the app used for login.
        :param _builtins.str app_secret_setting_name: The app setting name that contains the app secret.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        The App ID of the app used for login.
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[_builtins.str]:
        """
        The app setting name that contains the app secret.
        """
        return pulumi.get(self, "app_secret_setting_name")


@pulumi.output_type
class AppleRegistrationResponse(dict):
    """
    The configuration settings of the registration for the Apple provider
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppleRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppleRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppleRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 client_secret_setting_name: Optional[_builtins.str] = None):
        """
        The configuration settings of the registration for the Apple provider
        :param _builtins.str client_id: The Client ID of the app used for login.
        :param _builtins.str client_secret_setting_name: The app setting name that contains the client secret.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[_builtins.str]:
        """
        The app setting name that contains the client secret.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class AppleResponse(dict):
    """
    The configuration settings of the Apple provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.AppleRegistrationResponse'] = None):
        """
        The configuration settings of the Apple provider.
        :param _builtins.bool enabled: <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'AppleRegistrationResponse' registration: The configuration settings of the Apple registration.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @_builtins.property
    @pulumi.getter
    def registration(self) -> Optional['outputs.AppleRegistrationResponse']:
        """
        The configuration settings of the Apple registration.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class AuthPlatformResponse(dict):
    """
    The configuration settings of the platform of ContainerApp Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AuthPlatformResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AuthPlatformResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AuthPlatformResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 runtime_version: Optional[_builtins.str] = None):
        """
        The configuration settings of the platform of ContainerApp Service Authentication/Authorization.
        :param _builtins.bool enabled: <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        :param _builtins.str runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
               The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[_builtins.str]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
        return pulumi.get(self, "runtime_version")


@pulumi.output_type
class AzureActiveDirectoryLoginResponse(dict):
    """
    The configuration settings of the Azure Active Directory login flow.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableWWWAuthenticate":
            suggest = "disable_www_authenticate"
        elif key == "loginParameters":
            suggest = "login_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureActiveDirectoryLoginResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureActiveDirectoryLoginResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureActiveDirectoryLoginResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_www_authenticate: Optional[_builtins.bool] = None,
                 login_parameters: Optional[Sequence[_builtins.str]] = None):
        """
        The configuration settings of the Azure Active Directory login flow.
        :param _builtins.bool disable_www_authenticate: <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        :param Sequence[_builtins.str] login_parameters: Login parameters to send to the OpenID Connect authorization endpoint when
               a user logs in. Each parameter must be in the form "key=value".
        """
        if disable_www_authenticate is not None:
            pulumi.set(__self__, "disable_www_authenticate", disable_www_authenticate)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)

    @_builtins.property
    @pulumi.getter(name="disableWWWAuthenticate")
    def disable_www_authenticate(self) -> Optional[_builtins.bool]:
        """
        <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "disable_www_authenticate")

    @_builtins.property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when
        a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "login_parameters")


@pulumi.output_type
class AzureActiveDirectoryRegistrationResponse(dict):
    """
    The configuration settings of the Azure Active Directory app registration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretCertificateIssuer":
            suggest = "client_secret_certificate_issuer"
        elif key == "clientSecretCertificateSubjectAlternativeName":
            suggest = "client_secret_certificate_subject_alternative_name"
        elif key == "clientSecretCertificateThumbprint":
            suggest = "client_secret_certificate_thumbprint"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"
        elif key == "openIdIssuer":
            suggest = "open_id_issuer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureActiveDirectoryRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureActiveDirectoryRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureActiveDirectoryRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 client_secret_certificate_issuer: Optional[_builtins.str] = None,
                 client_secret_certificate_subject_alternative_name: Optional[_builtins.str] = None,
                 client_secret_certificate_thumbprint: Optional[_builtins.str] = None,
                 client_secret_setting_name: Optional[_builtins.str] = None,
                 open_id_issuer: Optional[_builtins.str] = None):
        """
        The configuration settings of the Azure Active Directory app registration.
        :param _builtins.str client_id: The Client ID of this relying party application, known as the client_id.
               This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
               other 3rd party OpenID Connect providers.
               More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        :param _builtins.str client_secret_certificate_issuer: An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        :param _builtins.str client_secret_certificate_subject_alternative_name: An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        :param _builtins.str client_secret_certificate_thumbprint: An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret. It is also optional.
        :param _builtins.str client_secret_setting_name: The app setting name that contains the client secret of the relying party application.
        :param _builtins.str open_id_issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
               When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://login.microsoftonline.com/v2.0/{tenant-guid}/.
               This URI is a case-sensitive identifier for the token issuer.
               More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_certificate_issuer is not None:
            pulumi.set(__self__, "client_secret_certificate_issuer", client_secret_certificate_issuer)
        if client_secret_certificate_subject_alternative_name is not None:
            pulumi.set(__self__, "client_secret_certificate_subject_alternative_name", client_secret_certificate_subject_alternative_name)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if open_id_issuer is not None:
            pulumi.set(__self__, "open_id_issuer", open_id_issuer)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The Client ID of this relying party application, known as the client_id.
        This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
        other 3rd party OpenID Connect providers.
        More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecretCertificateIssuer")
    def client_secret_certificate_issuer(self) -> Optional[_builtins.str]:
        """
        An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_issuer")

    @_builtins.property
    @pulumi.getter(name="clientSecretCertificateSubjectAlternativeName")
    def client_secret_certificate_subject_alternative_name(self) -> Optional[_builtins.str]:
        """
        An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_subject_alternative_name")

    @_builtins.property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[_builtins.str]:
        """
        An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @_builtins.property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[_builtins.str]:
        """
        The app setting name that contains the client secret of the relying party application.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @_builtins.property
    @pulumi.getter(name="openIdIssuer")
    def open_id_issuer(self) -> Optional[_builtins.str]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
        When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://login.microsoftonline.com/v2.0/{tenant-guid}/.
        This URI is a case-sensitive identifier for the token issuer.
        More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
        return pulumi.get(self, "open_id_issuer")


@pulumi.output_type
class AzureActiveDirectoryResponse(dict):
    """
    The configuration settings of the Azure Active directory provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isAutoProvisioned":
            suggest = "is_auto_provisioned"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureActiveDirectoryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureActiveDirectoryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureActiveDirectoryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 is_auto_provisioned: Optional[_builtins.bool] = None,
                 login: Optional['outputs.AzureActiveDirectoryLoginResponse'] = None,
                 registration: Optional['outputs.AzureActiveDirectoryRegistrationResponse'] = None,
                 validation: Optional['outputs.AzureActiveDirectoryValidationResponse'] = None):
        """
        The configuration settings of the Azure Active directory provider.
        :param _builtins.bool enabled: <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param _builtins.bool is_auto_provisioned: Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
               This is an internal flag primarily intended to support the Azure Management Portal. Users should not
               read or write to this property.
        :param 'AzureActiveDirectoryLoginResponse' login: The configuration settings of the Azure Active Directory login flow.
        :param 'AzureActiveDirectoryRegistrationResponse' registration: The configuration settings of the Azure Active Directory app registration.
        :param 'AzureActiveDirectoryValidationResponse' validation: The configuration settings of the Azure Active Directory token validation flow.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if is_auto_provisioned is not None:
            pulumi.set(__self__, "is_auto_provisioned", is_auto_provisioned)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="isAutoProvisioned")
    def is_auto_provisioned(self) -> Optional[_builtins.bool]:
        """
        Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
        This is an internal flag primarily intended to support the Azure Management Portal. Users should not
        read or write to this property.
        """
        return pulumi.get(self, "is_auto_provisioned")

    @_builtins.property
    @pulumi.getter
    def login(self) -> Optional['outputs.AzureActiveDirectoryLoginResponse']:
        """
        The configuration settings of the Azure Active Directory login flow.
        """
        return pulumi.get(self, "login")

    @_builtins.property
    @pulumi.getter
    def registration(self) -> Optional['outputs.AzureActiveDirectoryRegistrationResponse']:
        """
        The configuration settings of the Azure Active Directory app registration.
        """
        return pulumi.get(self, "registration")

    @_builtins.property
    @pulumi.getter
    def validation(self) -> Optional['outputs.AzureActiveDirectoryValidationResponse']:
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class AzureActiveDirectoryValidationResponse(dict):
    """
    The configuration settings of the Azure Active Directory token validation flow.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAudiences":
            suggest = "allowed_audiences"
        elif key == "defaultAuthorizationPolicy":
            suggest = "default_authorization_policy"
        elif key == "jwtClaimChecks":
            suggest = "jwt_claim_checks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureActiveDirectoryValidationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureActiveDirectoryValidationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureActiveDirectoryValidationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_audiences: Optional[Sequence[_builtins.str]] = None,
                 default_authorization_policy: Optional['outputs.DefaultAuthorizationPolicyResponse'] = None,
                 jwt_claim_checks: Optional['outputs.JwtClaimChecksResponse'] = None):
        """
        The configuration settings of the Azure Active Directory token validation flow.
        :param Sequence[_builtins.str] allowed_audiences: The list of audiences that can make successful authentication/authorization requests.
        :param 'DefaultAuthorizationPolicyResponse' default_authorization_policy: The configuration settings of the default authorization policy.
        :param 'JwtClaimChecksResponse' jwt_claim_checks: The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if default_authorization_policy is not None:
            pulumi.set(__self__, "default_authorization_policy", default_authorization_policy)
        if jwt_claim_checks is not None:
            pulumi.set(__self__, "jwt_claim_checks", jwt_claim_checks)

    @_builtins.property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of audiences that can make successful authentication/authorization requests.
        """
        return pulumi.get(self, "allowed_audiences")

    @_builtins.property
    @pulumi.getter(name="defaultAuthorizationPolicy")
    def default_authorization_policy(self) -> Optional['outputs.DefaultAuthorizationPolicyResponse']:
        """
        The configuration settings of the default authorization policy.
        """
        return pulumi.get(self, "default_authorization_policy")

    @_builtins.property
    @pulumi.getter(name="jwtClaimChecks")
    def jwt_claim_checks(self) -> Optional['outputs.JwtClaimChecksResponse']:
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        return pulumi.get(self, "jwt_claim_checks")


@pulumi.output_type
class AzureCredentialsResponse(dict):
    """
    Container App credentials.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subscription_id: Optional[_builtins.str] = None):
        """
        Container App credentials.
        :param _builtins.str subscription_id: Subscription Id.
        """
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[_builtins.str]:
        """
        Subscription Id.
        """
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class AzureFilePropertiesResponse(dict):
    """
    Azure File Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessMode":
            suggest = "access_mode"
        elif key == "accountKey":
            suggest = "account_key"
        elif key == "accountKeyVaultProperties":
            suggest = "account_key_vault_properties"
        elif key == "accountName":
            suggest = "account_name"
        elif key == "shareName":
            suggest = "share_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureFilePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureFilePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureFilePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_mode: Optional[_builtins.str] = None,
                 account_key: Optional[_builtins.str] = None,
                 account_key_vault_properties: Optional['outputs.SecretKeyVaultPropertiesResponse'] = None,
                 account_name: Optional[_builtins.str] = None,
                 share_name: Optional[_builtins.str] = None):
        """
        Azure File Properties.
        :param _builtins.str access_mode: Access mode for storage
        :param _builtins.str account_key: Storage account key for azure file.
        :param 'SecretKeyVaultPropertiesResponse' account_key_vault_properties: Storage account key stored as an Azure Key Vault secret.
        :param _builtins.str account_name: Storage account name for azure file.
        :param _builtins.str share_name: Azure file share name.
        """
        if access_mode is not None:
            pulumi.set(__self__, "access_mode", access_mode)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if account_key_vault_properties is not None:
            pulumi.set(__self__, "account_key_vault_properties", account_key_vault_properties)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)

    @_builtins.property
    @pulumi.getter(name="accessMode")
    def access_mode(self) -> Optional[_builtins.str]:
        """
        Access mode for storage
        """
        return pulumi.get(self, "access_mode")

    @_builtins.property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[_builtins.str]:
        """
        Storage account key for azure file.
        """
        return pulumi.get(self, "account_key")

    @_builtins.property
    @pulumi.getter(name="accountKeyVaultProperties")
    def account_key_vault_properties(self) -> Optional['outputs.SecretKeyVaultPropertiesResponse']:
        """
        Storage account key stored as an Azure Key Vault secret.
        """
        return pulumi.get(self, "account_key_vault_properties")

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[_builtins.str]:
        """
        Storage account name for azure file.
        """
        return pulumi.get(self, "account_name")

    @_builtins.property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[_builtins.str]:
        """
        Azure file share name.
        """
        return pulumi.get(self, "share_name")


@pulumi.output_type
class AzureStaticWebAppsRegistrationResponse(dict):
    """
    The configuration settings of the registration for the Azure Static Web Apps provider
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureStaticWebAppsRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureStaticWebAppsRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureStaticWebAppsRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None):
        """
        The configuration settings of the registration for the Azure Static Web Apps provider
        :param _builtins.str client_id: The Client ID of the app used for login.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class AzureStaticWebAppsResponse(dict):
    """
    The configuration settings of the Azure Static Web Apps provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 registration: Optional['outputs.AzureStaticWebAppsRegistrationResponse'] = None):
        """
        The configuration settings of the Azure Static Web Apps provider.
        :param _builtins.bool enabled: <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'AzureStaticWebAppsRegistrationResponse' registration: The configuration settings of the Azure Static Web Apps registration.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def registration(self) -> Optional['outputs.AzureStaticWebAppsRegistrationResponse']:
        """
        The configuration settings of the Azure Static Web Apps registration.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class BlobStorageTokenStoreResponse(dict):
    """
    The configuration settings of the storage of the tokens if blob storage is used.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blobContainerUri":
            suggest = "blob_container_uri"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "managedIdentityResourceId":
            suggest = "managed_identity_resource_id"
        elif key == "sasUrlSettingName":
            suggest = "sas_url_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BlobStorageTokenStoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BlobStorageTokenStoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BlobStorageTokenStoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blob_container_uri: Optional[_builtins.str] = None,
                 client_id: Optional[_builtins.str] = None,
                 managed_identity_resource_id: Optional[_builtins.str] = None,
                 sas_url_setting_name: Optional[_builtins.str] = None):
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        :param _builtins.str blob_container_uri: The URI of the blob storage containing the tokens. Should not be used along with sasUrlSettingName.
        :param _builtins.str client_id: The Client ID of a User-Assigned Managed Identity. Should not be used along with managedIdentityResourceId.
        :param _builtins.str managed_identity_resource_id: The Resource ID of a User-Assigned Managed Identity. Should not be used along with clientId.
        :param _builtins.str sas_url_setting_name: The name of the app secrets containing the SAS URL of the blob storage containing the tokens. Should not be used along with blobContainerUri.
        """
        if blob_container_uri is not None:
            pulumi.set(__self__, "blob_container_uri", blob_container_uri)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if managed_identity_resource_id is not None:
            pulumi.set(__self__, "managed_identity_resource_id", managed_identity_resource_id)
        if sas_url_setting_name is not None:
            pulumi.set(__self__, "sas_url_setting_name", sas_url_setting_name)

    @_builtins.property
    @pulumi.getter(name="blobContainerUri")
    def blob_container_uri(self) -> Optional[_builtins.str]:
        """
        The URI of the blob storage containing the tokens. Should not be used along with sasUrlSettingName.
        """
        return pulumi.get(self, "blob_container_uri")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The Client ID of a User-Assigned Managed Identity. Should not be used along with managedIdentityResourceId.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="managedIdentityResourceId")
    def managed_identity_resource_id(self) -> Optional[_builtins.str]:
        """
        The Resource ID of a User-Assigned Managed Identity. Should not be used along with clientId.
        """
        return pulumi.get(self, "managed_identity_resource_id")

    @_builtins.property
    @pulumi.getter(name="sasUrlSettingName")
    def sas_url_setting_name(self) -> Optional[_builtins.str]:
        """
        The name of the app secrets containing the SAS URL of the blob storage containing the tokens. Should not be used along with blobContainerUri.
        """
        return pulumi.get(self, "sas_url_setting_name")


@pulumi.output_type
class BuildConfigurationResponse(dict):
    """
    Configuration of the build.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseOs":
            suggest = "base_os"
        elif key == "environmentVariables":
            suggest = "environment_variables"
        elif key == "platformVersion":
            suggest = "platform_version"
        elif key == "preBuildSteps":
            suggest = "pre_build_steps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BuildConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BuildConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BuildConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_os: Optional[_builtins.str] = None,
                 environment_variables: Optional[Sequence['outputs.EnvironmentVariableResponse']] = None,
                 platform: Optional[_builtins.str] = None,
                 platform_version: Optional[_builtins.str] = None,
                 pre_build_steps: Optional[Sequence['outputs.PreBuildStepResponse']] = None):
        """
        Configuration of the build.
        :param _builtins.str base_os: Base OS used to build and run the app.
        :param Sequence['EnvironmentVariableResponse'] environment_variables: List of environment variables to be passed to the build, secrets should not be used in environment variable.
        :param _builtins.str platform: Platform to be used to build and run the app.
        :param _builtins.str platform_version: Platform version to be used to build and run the app.
        :param Sequence['PreBuildStepResponse'] pre_build_steps: List of steps to perform before the build.
        """
        if base_os is not None:
            pulumi.set(__self__, "base_os", base_os)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if platform_version is not None:
            pulumi.set(__self__, "platform_version", platform_version)
        if pre_build_steps is not None:
            pulumi.set(__self__, "pre_build_steps", pre_build_steps)

    @_builtins.property
    @pulumi.getter(name="baseOs")
    def base_os(self) -> Optional[_builtins.str]:
        """
        Base OS used to build and run the app.
        """
        return pulumi.get(self, "base_os")

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Sequence['outputs.EnvironmentVariableResponse']]:
        """
        List of environment variables to be passed to the build, secrets should not be used in environment variable.
        """
        return pulumi.get(self, "environment_variables")

    @_builtins.property
    @pulumi.getter
    def platform(self) -> Optional[_builtins.str]:
        """
        Platform to be used to build and run the app.
        """
        return pulumi.get(self, "platform")

    @_builtins.property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> Optional[_builtins.str]:
        """
        Platform version to be used to build and run the app.
        """
        return pulumi.get(self, "platform_version")

    @_builtins.property
    @pulumi.getter(name="preBuildSteps")
    def pre_build_steps(self) -> Optional[Sequence['outputs.PreBuildStepResponse']]:
        """
        List of steps to perform before the build.
        """
        return pulumi.get(self, "pre_build_steps")


@pulumi.output_type
class CertificateKeyVaultPropertiesResponse(dict):
    """
    Properties for a certificate stored in a Key Vault.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultUrl":
            suggest = "key_vault_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateKeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateKeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateKeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: Optional[_builtins.str] = None,
                 key_vault_url: Optional[_builtins.str] = None):
        """
        Properties for a certificate stored in a Key Vault.
        :param _builtins.str identity: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        :param _builtins.str key_vault_url: URL pointing to the Azure Key Vault secret that holds the certificate.
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if key_vault_url is not None:
            pulumi.set(__self__, "key_vault_url", key_vault_url)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter(name="keyVaultUrl")
    def key_vault_url(self) -> Optional[_builtins.str]:
        """
        URL pointing to the Azure Key Vault secret that holds the certificate.
        """
        return pulumi.get(self, "key_vault_url")


@pulumi.output_type
class CertificateResponseProperties(dict):
    """
    Certificate resource specific properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentErrors":
            suggest = "deployment_errors"
        elif key == "expirationDate":
            suggest = "expiration_date"
        elif key == "issueDate":
            suggest = "issue_date"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "publicKeyHash":
            suggest = "public_key_hash"
        elif key == "subjectAlternativeNames":
            suggest = "subject_alternative_names"
        elif key == "subjectName":
            suggest = "subject_name"
        elif key == "certificateKeyVaultProperties":
            suggest = "certificate_key_vault_properties"
        elif key == "certificateType":
            suggest = "certificate_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CertificateResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CertificateResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CertificateResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_errors: _builtins.str,
                 expiration_date: _builtins.str,
                 issue_date: _builtins.str,
                 issuer: _builtins.str,
                 provisioning_state: _builtins.str,
                 public_key_hash: _builtins.str,
                 subject_alternative_names: Sequence[_builtins.str],
                 subject_name: _builtins.str,
                 thumbprint: _builtins.str,
                 valid: _builtins.bool,
                 certificate_key_vault_properties: Optional['outputs.CertificateKeyVaultPropertiesResponse'] = None,
                 certificate_type: Optional[_builtins.str] = None):
        """
        Certificate resource specific properties
        :param _builtins.str deployment_errors: Any errors that occurred during deployment or deployment validation
        :param _builtins.str expiration_date: Certificate expiration date.
        :param _builtins.str issue_date: Certificate issue Date.
        :param _builtins.str issuer: Certificate issuer.
        :param _builtins.str provisioning_state: Provisioning state of the certificate.
        :param _builtins.str public_key_hash: Public key hash.
        :param Sequence[_builtins.str] subject_alternative_names: Subject alternative names the certificate applies to.
        :param _builtins.str subject_name: Subject name of the certificate.
        :param _builtins.str thumbprint: Certificate thumbprint.
        :param _builtins.bool valid: Is the certificate valid?.
        :param 'CertificateKeyVaultPropertiesResponse' certificate_key_vault_properties: Properties for a certificate stored in a Key Vault.
        :param _builtins.str certificate_type: The type of the certificate. Allowed values are `ServerSSLCertificate` and `ImagePullTrustedCA`
        """
        pulumi.set(__self__, "deployment_errors", deployment_errors)
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "issue_date", issue_date)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "public_key_hash", public_key_hash)
        pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)
        pulumi.set(__self__, "subject_name", subject_name)
        pulumi.set(__self__, "thumbprint", thumbprint)
        pulumi.set(__self__, "valid", valid)
        if certificate_key_vault_properties is not None:
            pulumi.set(__self__, "certificate_key_vault_properties", certificate_key_vault_properties)
        if certificate_type is not None:
            pulumi.set(__self__, "certificate_type", certificate_type)

    @_builtins.property
    @pulumi.getter(name="deploymentErrors")
    def deployment_errors(self) -> _builtins.str:
        """
        Any errors that occurred during deployment or deployment validation
        """
        return pulumi.get(self, "deployment_errors")

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> _builtins.str:
        """
        Certificate expiration date.
        """
        return pulumi.get(self, "expiration_date")

    @_builtins.property
    @pulumi.getter(name="issueDate")
    def issue_date(self) -> _builtins.str:
        """
        Certificate issue Date.
        """
        return pulumi.get(self, "issue_date")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> _builtins.str:
        """
        Certificate issuer.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the certificate.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="publicKeyHash")
    def public_key_hash(self) -> _builtins.str:
        """
        Public key hash.
        """
        return pulumi.get(self, "public_key_hash")

    @_builtins.property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Sequence[_builtins.str]:
        """
        Subject alternative names the certificate applies to.
        """
        return pulumi.get(self, "subject_alternative_names")

    @_builtins.property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> _builtins.str:
        """
        Subject name of the certificate.
        """
        return pulumi.get(self, "subject_name")

    @_builtins.property
    @pulumi.getter
    def thumbprint(self) -> _builtins.str:
        """
        Certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @_builtins.property
    @pulumi.getter
    def valid(self) -> _builtins.bool:
        """
        Is the certificate valid?.
        """
        return pulumi.get(self, "valid")

    @_builtins.property
    @pulumi.getter(name="certificateKeyVaultProperties")
    def certificate_key_vault_properties(self) -> Optional['outputs.CertificateKeyVaultPropertiesResponse']:
        """
        Properties for a certificate stored in a Key Vault.
        """
        return pulumi.get(self, "certificate_key_vault_properties")

    @_builtins.property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> Optional[_builtins.str]:
        """
        The type of the certificate. Allowed values are `ServerSSLCertificate` and `ImagePullTrustedCA`
        """
        return pulumi.get(self, "certificate_type")


@pulumi.output_type
class CircuitBreakerPolicyResponse(dict):
    """
    Policy that defines circuit breaker conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consecutiveErrors":
            suggest = "consecutive_errors"
        elif key == "intervalInSeconds":
            suggest = "interval_in_seconds"
        elif key == "maxEjectionPercent":
            suggest = "max_ejection_percent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CircuitBreakerPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CircuitBreakerPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CircuitBreakerPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consecutive_errors: Optional[_builtins.int] = None,
                 interval_in_seconds: Optional[_builtins.int] = None,
                 max_ejection_percent: Optional[_builtins.int] = None):
        """
        Policy that defines circuit breaker conditions
        :param _builtins.int consecutive_errors: Number of consecutive errors before the circuit breaker opens
        :param _builtins.int interval_in_seconds: The time interval, in seconds, between endpoint checks. This can result in opening the circuit breaker if the check fails as well as closing the circuit breaker if the check succeeds. Defaults to 10s.
        :param _builtins.int max_ejection_percent: Maximum percentage of hosts that will be ejected after failure threshold has been met
        """
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)

    @_builtins.property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[_builtins.int]:
        """
        Number of consecutive errors before the circuit breaker opens
        """
        return pulumi.get(self, "consecutive_errors")

    @_builtins.property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[_builtins.int]:
        """
        The time interval, in seconds, between endpoint checks. This can result in opening the circuit breaker if the check fails as well as closing the circuit breaker if the check succeeds. Defaults to 10s.
        """
        return pulumi.get(self, "interval_in_seconds")

    @_builtins.property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[_builtins.int]:
        """
        Maximum percentage of hosts that will be ejected after failure threshold has been met
        """
        return pulumi.get(self, "max_ejection_percent")


@pulumi.output_type
class ClientRegistrationResponse(dict):
    """
    The configuration settings of the app registration for providers that have client ids and client secrets
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 client_secret_setting_name: Optional[_builtins.str] = None):
        """
        The configuration settings of the app registration for providers that have client ids and client secrets
        :param _builtins.str client_id: The Client ID of the app used for login.
        :param _builtins.str client_secret_setting_name: The app setting name that contains the client secret.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[_builtins.str]:
        """
        The app setting name that contains the client secret.
        """
        return pulumi.get(self, "client_secret_setting_name")


@pulumi.output_type
class ConfigurationResponse(dict):
    """
    Non versioned Container App configuration properties that define the mutable settings of a Container app
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeRevisionsMode":
            suggest = "active_revisions_mode"
        elif key == "identitySettings":
            suggest = "identity_settings"
        elif key == "maxInactiveRevisions":
            suggest = "max_inactive_revisions"
        elif key == "revisionTransitionThreshold":
            suggest = "revision_transition_threshold"
        elif key == "targetLabel":
            suggest = "target_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_revisions_mode: Optional[_builtins.str] = None,
                 dapr: Optional['outputs.DaprResponse'] = None,
                 identity_settings: Optional[Sequence['outputs.IdentitySettingsResponse']] = None,
                 ingress: Optional['outputs.IngressResponse'] = None,
                 max_inactive_revisions: Optional[_builtins.int] = None,
                 registries: Optional[Sequence['outputs.RegistryCredentialsResponse']] = None,
                 revision_transition_threshold: Optional[_builtins.int] = None,
                 runtime: Optional['outputs.RuntimeResponse'] = None,
                 secrets: Optional[Sequence['outputs.SecretResponse']] = None,
                 service: Optional['outputs.ServiceResponse'] = None,
                 target_label: Optional[_builtins.str] = None):
        """
        Non versioned Container App configuration properties that define the mutable settings of a Container app
        :param _builtins.str active_revisions_mode: ActiveRevisionsMode controls how active revisions are handled for the Container app:
               <list><item>Single: Only one revision can be active at a time. Traffic weights cannot be used. This is the default.</item><item>Multiple: Multiple revisions can be active, including optional traffic weights and labels.</item><item>Labels: Only revisions with labels are active. Traffic weights can be applied to labels.</item></list>
        :param 'DaprResponse' dapr: Dapr configuration for the Container App.
        :param Sequence['IdentitySettingsResponse'] identity_settings: Optional settings for Managed Identities that are assigned to the Container App. If a Managed Identity is not specified here, default settings will be used.
        :param 'IngressResponse' ingress: Ingress configurations.
        :param _builtins.int max_inactive_revisions: Optional. Max inactive revisions a Container App can have.
        :param Sequence['RegistryCredentialsResponse'] registries: Collection of private container registry credentials for containers used by the Container app
        :param _builtins.int revision_transition_threshold: Optional. The percent of the total number of replicas that must be brought up before revision transition occurs. Defaults to 100 when none is given. Value must be greater than 0 and less than or equal to 100.
        :param 'RuntimeResponse' runtime: App runtime configuration for the Container App.
        :param Sequence['SecretResponse'] secrets: Collection of secrets used by a Container app
        :param 'ServiceResponse' service: Container App to be a dev Container App Service
        :param _builtins.str target_label: Required in labels revisions mode. Label to apply to newly created revision.
        """
        if active_revisions_mode is None:
            active_revisions_mode = 'Single'
        if active_revisions_mode is not None:
            pulumi.set(__self__, "active_revisions_mode", active_revisions_mode)
        if dapr is not None:
            pulumi.set(__self__, "dapr", dapr)
        if identity_settings is not None:
            pulumi.set(__self__, "identity_settings", identity_settings)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if max_inactive_revisions is not None:
            pulumi.set(__self__, "max_inactive_revisions", max_inactive_revisions)
        if registries is not None:
            pulumi.set(__self__, "registries", registries)
        if revision_transition_threshold is not None:
            pulumi.set(__self__, "revision_transition_threshold", revision_transition_threshold)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if target_label is not None:
            pulumi.set(__self__, "target_label", target_label)

    @_builtins.property
    @pulumi.getter(name="activeRevisionsMode")
    def active_revisions_mode(self) -> Optional[_builtins.str]:
        """
        ActiveRevisionsMode controls how active revisions are handled for the Container app:
        <list><item>Single: Only one revision can be active at a time. Traffic weights cannot be used. This is the default.</item><item>Multiple: Multiple revisions can be active, including optional traffic weights and labels.</item><item>Labels: Only revisions with labels are active. Traffic weights can be applied to labels.</item></list>
        """
        return pulumi.get(self, "active_revisions_mode")

    @_builtins.property
    @pulumi.getter
    def dapr(self) -> Optional['outputs.DaprResponse']:
        """
        Dapr configuration for the Container App.
        """
        return pulumi.get(self, "dapr")

    @_builtins.property
    @pulumi.getter(name="identitySettings")
    def identity_settings(self) -> Optional[Sequence['outputs.IdentitySettingsResponse']]:
        """
        Optional settings for Managed Identities that are assigned to the Container App. If a Managed Identity is not specified here, default settings will be used.
        """
        return pulumi.get(self, "identity_settings")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> Optional['outputs.IngressResponse']:
        """
        Ingress configurations.
        """
        return pulumi.get(self, "ingress")

    @_builtins.property
    @pulumi.getter(name="maxInactiveRevisions")
    def max_inactive_revisions(self) -> Optional[_builtins.int]:
        """
        Optional. Max inactive revisions a Container App can have.
        """
        return pulumi.get(self, "max_inactive_revisions")

    @_builtins.property
    @pulumi.getter
    def registries(self) -> Optional[Sequence['outputs.RegistryCredentialsResponse']]:
        """
        Collection of private container registry credentials for containers used by the Container app
        """
        return pulumi.get(self, "registries")

    @_builtins.property
    @pulumi.getter(name="revisionTransitionThreshold")
    def revision_transition_threshold(self) -> Optional[_builtins.int]:
        """
        Optional. The percent of the total number of replicas that must be brought up before revision transition occurs. Defaults to 100 when none is given. Value must be greater than 0 and less than or equal to 100.
        """
        return pulumi.get(self, "revision_transition_threshold")

    @_builtins.property
    @pulumi.getter
    def runtime(self) -> Optional['outputs.RuntimeResponse']:
        """
        App runtime configuration for the Container App.
        """
        return pulumi.get(self, "runtime")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.SecretResponse']]:
        """
        Collection of secrets used by a Container app
        """
        return pulumi.get(self, "secrets")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional['outputs.ServiceResponse']:
        """
        Container App to be a dev Container App Service
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="targetLabel")
    def target_label(self) -> Optional[_builtins.str]:
        """
        Required in labels revisions mode. Label to apply to newly created revision.
        """
        return pulumi.get(self, "target_label")


@pulumi.output_type
class ConnectedEnvironmentStorageResponseProperties(dict):
    """
    Storage properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deploymentErrors":
            suggest = "deployment_errors"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "azureFile":
            suggest = "azure_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectedEnvironmentStorageResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectedEnvironmentStorageResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectedEnvironmentStorageResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deployment_errors: _builtins.str,
                 provisioning_state: _builtins.str,
                 azure_file: Optional['outputs.AzureFilePropertiesResponse'] = None,
                 smb: Optional['outputs.SmbStorageResponse'] = None):
        """
        Storage properties
        :param _builtins.str deployment_errors: Any errors that occurred during deployment or deployment validation
        :param _builtins.str provisioning_state: Provisioning state of the storage.
        :param 'AzureFilePropertiesResponse' azure_file: Azure file properties
        :param 'SmbStorageResponse' smb: SMB storage properties
        """
        pulumi.set(__self__, "deployment_errors", deployment_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if azure_file is not None:
            pulumi.set(__self__, "azure_file", azure_file)
        if smb is not None:
            pulumi.set(__self__, "smb", smb)

    @_builtins.property
    @pulumi.getter(name="deploymentErrors")
    def deployment_errors(self) -> _builtins.str:
        """
        Any errors that occurred during deployment or deployment validation
        """
        return pulumi.get(self, "deployment_errors")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the storage.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="azureFile")
    def azure_file(self) -> Optional['outputs.AzureFilePropertiesResponse']:
        """
        Azure file properties
        """
        return pulumi.get(self, "azure_file")

    @_builtins.property
    @pulumi.getter
    def smb(self) -> Optional['outputs.SmbStorageResponse']:
        """
        SMB storage properties
        """
        return pulumi.get(self, "smb")


@pulumi.output_type
class ContainerAppProbeResponse(dict):
    """
    Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSocket":
            suggest = "tcp_socket"
        elif key == "terminationGracePeriodSeconds":
            suggest = "termination_grace_period_seconds"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerAppProbeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerAppProbeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerAppProbeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_threshold: Optional[_builtins.int] = None,
                 http_get: Optional['outputs.ContainerAppProbeResponseHttpGet'] = None,
                 initial_delay_seconds: Optional[_builtins.int] = None,
                 period_seconds: Optional[_builtins.int] = None,
                 success_threshold: Optional[_builtins.int] = None,
                 tcp_socket: Optional['outputs.ContainerAppProbeResponseTcpSocket'] = None,
                 termination_grace_period_seconds: Optional[_builtins.float] = None,
                 timeout_seconds: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        """
        Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
        :param _builtins.int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        :param 'ContainerAppProbeResponseHttpGet' http_get: HTTPGet specifies the http request to perform.
        :param _builtins.int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        :param _builtins.int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        :param _builtins.int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        :param 'ContainerAppProbeResponseTcpSocket' tcp_socket: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        :param _builtins.float termination_grace_period_seconds: Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        :param _builtins.int timeout_seconds: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        :param _builtins.str type: The type of probe.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[_builtins.int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        """
        return pulumi.get(self, "failure_threshold")

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.ContainerAppProbeResponseHttpGet']:
        """
        HTTPGet specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[_builtins.int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[_builtins.int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[_builtins.int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        """
        return pulumi.get(self, "success_threshold")

    @_builtins.property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.ContainerAppProbeResponseTcpSocket']:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        """
        return pulumi.get(self, "tcp_socket")

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[_builtins.float]:
        """
        Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        """
        return pulumi.get(self, "timeout_seconds")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of probe.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ContainerAppProbeResponseHttpGet(dict):
    """
    HTTPGet specifies the http request to perform.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerAppProbeResponseHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerAppProbeResponseHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerAppProbeResponseHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: _builtins.int,
                 host: Optional[_builtins.str] = None,
                 http_headers: Optional[Sequence['outputs.ContainerAppProbeResponseHttpHeaders']] = None,
                 path: Optional[_builtins.str] = None,
                 scheme: Optional[_builtins.str] = None):
        """
        HTTPGet specifies the http request to perform.
        :param _builtins.int port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param _builtins.str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['ContainerAppProbeResponseHttpHeaders'] http_headers: Custom headers to set in the request. HTTP allows repeated headers.
        :param _builtins.str path: Path to access on the HTTP server.
        :param _builtins.str scheme: Scheme to use for connecting to the host. Defaults to HTTP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.ContainerAppProbeResponseHttpHeaders']]:
        """
        Custom headers to set in the request. HTTP allows repeated headers.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[_builtins.str]:
        """
        Scheme to use for connecting to the host. Defaults to HTTP.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class ContainerAppProbeResponseHttpHeaders(dict):
    """
    HTTPHeader describes a custom header to be used in HTTP probes
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        HTTPHeader describes a custom header to be used in HTTP probes
        :param _builtins.str name: The header field name
        :param _builtins.str value: The header field value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ContainerAppProbeResponseTcpSocket(dict):
    """
    TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
    """
    def __init__(__self__, *,
                 port: _builtins.int,
                 host: Optional[_builtins.str] = None):
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        :param _builtins.int port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param _builtins.str host: Optional: Host name to connect to, defaults to the pod IP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Optional: Host name to connect to, defaults to the pod IP.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class ContainerAppResponsePatchingConfiguration(dict):
    """
    Container App auto patch configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patchingMode":
            suggest = "patching_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerAppResponsePatchingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerAppResponsePatchingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerAppResponsePatchingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 patching_mode: Optional[_builtins.str] = None):
        """
        Container App auto patch configuration.
        :param _builtins.str patching_mode: Patching mode for the container app. Null or default in this field will be interpreted as Automatic by RP. Automatic mode will automatically apply available patches. Manual mode will require the user to manually apply patches. Disabled mode will stop patch detection and auto patching.
        """
        if patching_mode is not None:
            pulumi.set(__self__, "patching_mode", patching_mode)

    @_builtins.property
    @pulumi.getter(name="patchingMode")
    def patching_mode(self) -> Optional[_builtins.str]:
        """
        Patching mode for the container app. Null or default in this field will be interpreted as Automatic by RP. Automatic mode will automatically apply available patches. Manual mode will require the user to manually apply patches. Disabled mode will stop patch detection and auto patching.
        """
        return pulumi.get(self, "patching_mode")


@pulumi.output_type
class ContainerAppSecretResponse(dict):
    """
    Container App Secret.
    """
    def __init__(__self__, *,
                 identity: _builtins.str,
                 key_vault_url: _builtins.str,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        Container App Secret.
        :param _builtins.str identity: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        :param _builtins.str key_vault_url: Azure Key Vault URL pointing to the secret referenced by the container app.
        :param _builtins.str name: Secret Name.
        :param _builtins.str value: Secret Value.
        """
        pulumi.set(__self__, "identity", identity)
        pulumi.set(__self__, "key_vault_url", key_vault_url)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> _builtins.str:
        """
        Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter(name="keyVaultUrl")
    def key_vault_url(self) -> _builtins.str:
        """
        Azure Key Vault URL pointing to the secret referenced by the container app.
        """
        return pulumi.get(self, "key_vault_url")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Secret Name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Secret Value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ContainerRegistryResponse(dict):
    """
    Model representing a mapping from a container registry to the identity used to connect to it.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerRegistryServer":
            suggest = "container_registry_server"
        elif key == "identityResourceId":
            suggest = "identity_resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerRegistryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerRegistryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerRegistryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_registry_server: _builtins.str,
                 identity_resource_id: _builtins.str):
        """
        Model representing a mapping from a container registry to the identity used to connect to it.
        :param _builtins.str container_registry_server: Login server of the container registry.
        :param _builtins.str identity_resource_id: Resource ID of the managed identity.
        """
        pulumi.set(__self__, "container_registry_server", container_registry_server)
        pulumi.set(__self__, "identity_resource_id", identity_resource_id)

    @_builtins.property
    @pulumi.getter(name="containerRegistryServer")
    def container_registry_server(self) -> _builtins.str:
        """
        Login server of the container registry.
        """
        return pulumi.get(self, "container_registry_server")

    @_builtins.property
    @pulumi.getter(name="identityResourceId")
    def identity_resource_id(self) -> _builtins.str:
        """
        Resource ID of the managed identity.
        """
        return pulumi.get(self, "identity_resource_id")


@pulumi.output_type
class ContainerRegistryWithCustomImageResponse(dict):
    """
    Container registry that the final image will be uploaded to.
    """
    def __init__(__self__, *,
                 server: _builtins.str,
                 image: Optional[_builtins.str] = None):
        """
        Container registry that the final image will be uploaded to.
        :param _builtins.str server: Login server of the container registry that the final image should be uploaded to. Builder resource needs to have this container registry defined along with an identity to use to access it.
        :param _builtins.str image: Full name that the final image should be uploaded as, including both image name and tag.
        """
        pulumi.set(__self__, "server", server)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @_builtins.property
    @pulumi.getter
    def server(self) -> _builtins.str:
        """
        Login server of the container registry that the final image should be uploaded to. Builder resource needs to have this container registry defined along with an identity to use to access it.
        """
        return pulumi.get(self, "server")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Full name that the final image should be uploaded as, including both image name and tag.
        """
        return pulumi.get(self, "image")


@pulumi.output_type
class ContainerResourcesResponse(dict):
    """
    Container App container resource requirements.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ephemeralStorage":
            suggest = "ephemeral_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerResourcesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerResourcesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerResourcesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ephemeral_storage: _builtins.str,
                 cpu: Optional[_builtins.float] = None,
                 gpu: Optional[_builtins.float] = None,
                 memory: Optional[_builtins.str] = None):
        """
        Container App container resource requirements.
        :param _builtins.str ephemeral_storage: Ephemeral Storage, e.g. "1Gi"
        :param _builtins.float cpu: Required CPU in cores, e.g. 0.5
        :param _builtins.float gpu: Required GPU in cores for GPU based app, e.g. 1.0
        :param _builtins.str memory: Required memory, e.g. "250Mb"
        """
        pulumi.set(__self__, "ephemeral_storage", ephemeral_storage)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if gpu is not None:
            pulumi.set(__self__, "gpu", gpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter(name="ephemeralStorage")
    def ephemeral_storage(self) -> _builtins.str:
        """
        Ephemeral Storage, e.g. "1Gi"
        """
        return pulumi.get(self, "ephemeral_storage")

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[_builtins.float]:
        """
        Required CPU in cores, e.g. 0.5
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def gpu(self) -> Optional[_builtins.float]:
        """
        Required GPU in cores for GPU based app, e.g. 1.0
        """
        return pulumi.get(self, "gpu")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[_builtins.str]:
        """
        Required memory, e.g. "250Mb"
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ContainerResponse(dict):
    """
    Container App container definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageType":
            suggest = "image_type"
        elif key == "volumeMounts":
            suggest = "volume_mounts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 args: Optional[Sequence[_builtins.str]] = None,
                 command: Optional[Sequence[_builtins.str]] = None,
                 env: Optional[Sequence['outputs.EnvironmentVarResponse']] = None,
                 image: Optional[_builtins.str] = None,
                 image_type: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 probes: Optional[Sequence['outputs.ContainerAppProbeResponse']] = None,
                 resources: Optional['outputs.ContainerResourcesResponse'] = None,
                 volume_mounts: Optional[Sequence['outputs.VolumeMountResponse']] = None):
        """
        Container App container definition
        :param Sequence[_builtins.str] args: Container start command arguments.
        :param Sequence[_builtins.str] command: Container start command.
        :param Sequence['EnvironmentVarResponse'] env: Container environment variables.
        :param _builtins.str image: Container image tag.
        :param _builtins.str image_type: The type of the image. Set to CloudBuild to let the system manages the image, where user will not be able to update image through image field. Set to ContainerImage for user provided image.
        :param _builtins.str name: Custom container name.
        :param Sequence['ContainerAppProbeResponse'] probes: List of probes for the container.
        :param 'ContainerResourcesResponse' resources: Container resource requirements.
        :param Sequence['VolumeMountResponse'] volume_mounts: Container volume mounts.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if image_type is not None:
            pulumi.set(__self__, "image_type", image_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[Sequence[_builtins.str]]:
        """
        Container start command arguments.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[Sequence[_builtins.str]]:
        """
        Container start command.
        """
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.EnvironmentVarResponse']]:
        """
        Container environment variables.
        """
        return pulumi.get(self, "env")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Container image tag.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="imageType")
    def image_type(self) -> Optional[_builtins.str]:
        """
        The type of the image. Set to CloudBuild to let the system manages the image, where user will not be able to update image through image field. Set to ContainerImage for user provided image.
        """
        return pulumi.get(self, "image_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Custom container name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def probes(self) -> Optional[Sequence['outputs.ContainerAppProbeResponse']]:
        """
        List of probes for the container.
        """
        return pulumi.get(self, "probes")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional['outputs.ContainerResourcesResponse']:
        """
        Container resource requirements.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[Sequence['outputs.VolumeMountResponse']]:
        """
        Container volume mounts.
        """
        return pulumi.get(self, "volume_mounts")


@pulumi.output_type
class CookieExpirationResponse(dict):
    """
    The configuration settings of the session cookie's expiration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeToExpiration":
            suggest = "time_to_expiration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CookieExpirationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CookieExpirationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CookieExpirationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 convention: Optional[_builtins.str] = None,
                 time_to_expiration: Optional[_builtins.str] = None):
        """
        The configuration settings of the session cookie's expiration.
        :param _builtins.str convention: The convention used when determining the session cookie's expiration.
        :param _builtins.str time_to_expiration: The time after the request is made when the session cookie should expire.
        """
        if convention is not None:
            pulumi.set(__self__, "convention", convention)
        if time_to_expiration is not None:
            pulumi.set(__self__, "time_to_expiration", time_to_expiration)

    @_builtins.property
    @pulumi.getter
    def convention(self) -> Optional[_builtins.str]:
        """
        The convention used when determining the session cookie's expiration.
        """
        return pulumi.get(self, "convention")

    @_builtins.property
    @pulumi.getter(name="timeToExpiration")
    def time_to_expiration(self) -> Optional[_builtins.str]:
        """
        The time after the request is made when the session cookie should expire.
        """
        return pulumi.get(self, "time_to_expiration")


@pulumi.output_type
class CorsPolicyResponse(dict):
    """
    Cross-Origin-Resource-Sharing policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CorsPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CorsPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CorsPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_origins: Sequence[_builtins.str],
                 allow_credentials: Optional[_builtins.bool] = None,
                 allowed_headers: Optional[Sequence[_builtins.str]] = None,
                 allowed_methods: Optional[Sequence[_builtins.str]] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.int] = None):
        """
        Cross-Origin-Resource-Sharing policy
        :param Sequence[_builtins.str] allowed_origins: Specifies the content for the access-control-allow-origins header
        :param _builtins.bool allow_credentials: Specifies whether the resource allows credentials
        :param Sequence[_builtins.str] allowed_headers: Specifies the content for the access-control-allow-headers header
        :param Sequence[_builtins.str] allowed_methods: Specifies the content for the access-control-allow-methods header
        :param Sequence[_builtins.str] expose_headers: Specifies the content for the access-control-expose-headers header 
        :param _builtins.int max_age: Specifies the content for the access-control-max-age header
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[_builtins.str]:
        """
        Specifies the content for the access-control-allow-origins header
        """
        return pulumi.get(self, "allowed_origins")

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the resource allows credentials
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the access-control-allow-headers header
        """
        return pulumi.get(self, "allowed_headers")

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the access-control-allow-methods header
        """
        return pulumi.get(self, "allowed_methods")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the content for the access-control-expose-headers header 
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Specifies the content for the access-control-max-age header
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class CustomContainerTemplateResponse(dict):
    """
    Custom container configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryCredentials":
            suggest = "registry_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomContainerTemplateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomContainerTemplateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomContainerTemplateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 containers: Optional[Sequence['outputs.SessionContainerResponse']] = None,
                 ingress: Optional['outputs.SessionIngressResponse'] = None,
                 registry_credentials: Optional['outputs.SessionRegistryCredentialsResponse'] = None):
        """
        Custom container configuration.
        :param Sequence['SessionContainerResponse'] containers: List of container definitions for the sessions of the session pool.
        :param 'SessionIngressResponse' ingress: Session pool ingress configuration.
        :param 'SessionRegistryCredentialsResponse' registry_credentials: Private container registry credentials for containers used by the sessions of the session pool.
        """
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)

    @_builtins.property
    @pulumi.getter
    def containers(self) -> Optional[Sequence['outputs.SessionContainerResponse']]:
        """
        List of container definitions for the sessions of the session pool.
        """
        return pulumi.get(self, "containers")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> Optional['outputs.SessionIngressResponse']:
        """
        Session pool ingress configuration.
        """
        return pulumi.get(self, "ingress")

    @_builtins.property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional['outputs.SessionRegistryCredentialsResponse']:
        """
        Private container registry credentials for containers used by the sessions of the session pool.
        """
        return pulumi.get(self, "registry_credentials")


@pulumi.output_type
class CustomDomainConfigurationResponse(dict):
    """
    Configuration properties for apps environment custom domain
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customDomainVerificationId":
            suggest = "custom_domain_verification_id"
        elif key == "expirationDate":
            suggest = "expiration_date"
        elif key == "subjectName":
            suggest = "subject_name"
        elif key == "certificateKeyVaultProperties":
            suggest = "certificate_key_vault_properties"
        elif key == "certificatePassword":
            suggest = "certificate_password"
        elif key == "certificateValue":
            suggest = "certificate_value"
        elif key == "dnsSuffix":
            suggest = "dns_suffix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDomainConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDomainConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDomainConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_domain_verification_id: _builtins.str,
                 expiration_date: _builtins.str,
                 subject_name: _builtins.str,
                 thumbprint: _builtins.str,
                 certificate_key_vault_properties: Optional['outputs.CertificateKeyVaultPropertiesResponse'] = None,
                 certificate_password: Optional[_builtins.str] = None,
                 certificate_value: Optional[_builtins.str] = None,
                 dns_suffix: Optional[_builtins.str] = None):
        """
        Configuration properties for apps environment custom domain
        :param _builtins.str custom_domain_verification_id: Id used to verify domain name ownership
        :param _builtins.str expiration_date: Certificate expiration date.
        :param _builtins.str subject_name: Subject name of the certificate.
        :param _builtins.str thumbprint: Certificate thumbprint.
        :param 'CertificateKeyVaultPropertiesResponse' certificate_key_vault_properties: Certificate stored in Azure Key Vault.
        :param _builtins.str certificate_password: Certificate password
        :param _builtins.str certificate_value: PFX or PEM blob
        :param _builtins.str dns_suffix: Dns suffix for the environment domain
        """
        pulumi.set(__self__, "custom_domain_verification_id", custom_domain_verification_id)
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "subject_name", subject_name)
        pulumi.set(__self__, "thumbprint", thumbprint)
        if certificate_key_vault_properties is not None:
            pulumi.set(__self__, "certificate_key_vault_properties", certificate_key_vault_properties)
        if certificate_password is not None:
            pulumi.set(__self__, "certificate_password", certificate_password)
        if certificate_value is not None:
            pulumi.set(__self__, "certificate_value", certificate_value)
        if dns_suffix is not None:
            pulumi.set(__self__, "dns_suffix", dns_suffix)

    @_builtins.property
    @pulumi.getter(name="customDomainVerificationId")
    def custom_domain_verification_id(self) -> _builtins.str:
        """
        Id used to verify domain name ownership
        """
        return pulumi.get(self, "custom_domain_verification_id")

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> _builtins.str:
        """
        Certificate expiration date.
        """
        return pulumi.get(self, "expiration_date")

    @_builtins.property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> _builtins.str:
        """
        Subject name of the certificate.
        """
        return pulumi.get(self, "subject_name")

    @_builtins.property
    @pulumi.getter
    def thumbprint(self) -> _builtins.str:
        """
        Certificate thumbprint.
        """
        return pulumi.get(self, "thumbprint")

    @_builtins.property
    @pulumi.getter(name="certificateKeyVaultProperties")
    def certificate_key_vault_properties(self) -> Optional['outputs.CertificateKeyVaultPropertiesResponse']:
        """
        Certificate stored in Azure Key Vault.
        """
        return pulumi.get(self, "certificate_key_vault_properties")

    @_builtins.property
    @pulumi.getter(name="certificatePassword")
    def certificate_password(self) -> Optional[_builtins.str]:
        """
        Certificate password
        """
        return pulumi.get(self, "certificate_password")

    @_builtins.property
    @pulumi.getter(name="certificateValue")
    def certificate_value(self) -> Optional[_builtins.str]:
        """
        PFX or PEM blob
        """
        return pulumi.get(self, "certificate_value")

    @_builtins.property
    @pulumi.getter(name="dnsSuffix")
    def dns_suffix(self) -> Optional[_builtins.str]:
        """
        Dns suffix for the environment domain
        """
        return pulumi.get(self, "dns_suffix")


@pulumi.output_type
class CustomDomainResponse(dict):
    """
    Custom Domain of a Container App
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindingType":
            suggest = "binding_type"
        elif key == "certificateId":
            suggest = "certificate_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDomainResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDomainResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDomainResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 binding_type: Optional[_builtins.str] = None,
                 certificate_id: Optional[_builtins.str] = None):
        """
        Custom Domain of a Container App
        :param _builtins.str name: Hostname.
        :param _builtins.str binding_type: Custom Domain binding type.
        :param _builtins.str certificate_id: Resource Id of the Certificate to be bound to this hostname. Must exist in the Managed Environment.
        """
        pulumi.set(__self__, "name", name)
        if binding_type is not None:
            pulumi.set(__self__, "binding_type", binding_type)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Hostname.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="bindingType")
    def binding_type(self) -> Optional[_builtins.str]:
        """
        Custom Domain binding type.
        """
        return pulumi.get(self, "binding_type")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[_builtins.str]:
        """
        Resource Id of the Certificate to be bound to this hostname. Must exist in the Managed Environment.
        """
        return pulumi.get(self, "certificate_id")


@pulumi.output_type
class CustomHostnameAnalysisResultResponseCustomDomainVerificationFailureInfo(dict):
    """
    Raw failure information if DNS verification fails.
    """
    def __init__(__self__, *,
                 code: _builtins.str,
                 message: _builtins.str,
                 target: _builtins.str,
                 details: Optional[Sequence['outputs.CustomHostnameAnalysisResultResponseDetails']] = None):
        """
        Raw failure information if DNS verification fails.
        :param _builtins.str code: Standardized string to programmatically identify the error.
        :param _builtins.str message: Detailed error description and debugging information.
        :param _builtins.str target: Detailed error description and debugging information.
        :param Sequence['CustomHostnameAnalysisResultResponseDetails'] details: Details or the error
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "target", target)
        if details is not None:
            pulumi.set(__self__, "details", details)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        Standardized string to programmatically identify the error.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Detailed error description and debugging information.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        Detailed error description and debugging information.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.CustomHostnameAnalysisResultResponseDetails']]:
        """
        Details or the error
        """
        return pulumi.get(self, "details")


@pulumi.output_type
class CustomHostnameAnalysisResultResponseDetails(dict):
    """
    Detailed errors.
    """
    def __init__(__self__, *,
                 code: _builtins.str,
                 message: _builtins.str,
                 target: _builtins.str):
        """
        Detailed errors.
        :param _builtins.str code: Standardized string to programmatically identify the error.
        :param _builtins.str message: Detailed error description and debugging information.
        :param _builtins.str target: Detailed error description and debugging information.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        Standardized string to programmatically identify the error.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Detailed error description and debugging information.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        Detailed error description and debugging information.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class CustomOpenIdConnectProviderResponse(dict):
    """
    The configuration settings of the custom Open ID Connect provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 login: Optional['outputs.OpenIdConnectLoginResponse'] = None,
                 registration: Optional['outputs.OpenIdConnectRegistrationResponse'] = None):
        """
        The configuration settings of the custom Open ID Connect provider.
        :param _builtins.bool enabled: <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        :param 'OpenIdConnectLoginResponse' login: The configuration settings of the login flow of the custom Open ID Connect provider.
        :param 'OpenIdConnectRegistrationResponse' registration: The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def login(self) -> Optional['outputs.OpenIdConnectLoginResponse']:
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "login")

    @_builtins.property
    @pulumi.getter
    def registration(self) -> Optional['outputs.OpenIdConnectRegistrationResponse']:
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class CustomScaleRuleResponse(dict):
    """
    Container App container Custom scaling rule.
    """
    def __init__(__self__, *,
                 auth: Optional[Sequence['outputs.ScaleRuleAuthResponse']] = None,
                 identity: Optional[_builtins.str] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None,
                 type: Optional[_builtins.str] = None):
        """
        Container App container Custom scaling rule.
        :param Sequence['ScaleRuleAuthResponse'] auth: Authentication secrets for the custom scale rule.
        :param _builtins.str identity: The resource ID of a user-assigned managed identity that is assigned to the Container App, or 'system' for system-assigned identity.
        :param Mapping[str, _builtins.str] metadata: Metadata properties to describe custom scale rule.
        :param _builtins.str type: Type of the custom scale rule
               eg: azure-servicebus, redis etc.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[Sequence['outputs.ScaleRuleAuthResponse']]:
        """
        Authentication secrets for the custom scale rule.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        The resource ID of a user-assigned managed identity that is assigned to the Container App, or 'system' for system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Metadata properties to describe custom scale rule.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the custom scale rule
        eg: azure-servicebus, redis etc.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationResponse(dict):
    """
    Dapr Component Resiliency Policy Circuit Breaker Policy Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consecutiveErrors":
            suggest = "consecutive_errors"
        elif key == "intervalInSeconds":
            suggest = "interval_in_seconds"
        elif key == "timeoutInSeconds":
            suggest = "timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consecutive_errors: Optional[_builtins.int] = None,
                 interval_in_seconds: Optional[_builtins.int] = None,
                 timeout_in_seconds: Optional[_builtins.int] = None):
        """
        Dapr Component Resiliency Policy Circuit Breaker Policy Configuration.
        :param _builtins.int consecutive_errors: The number of consecutive errors before the circuit is opened.
        :param _builtins.int interval_in_seconds: The optional interval in seconds after which the error count resets to 0. An interval of 0 will never reset. If not specified, the timeoutInSeconds value will be used.
        :param _builtins.int timeout_in_seconds: The interval in seconds until a retry attempt is made after the circuit is opened.
        """
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @_builtins.property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[_builtins.int]:
        """
        The number of consecutive errors before the circuit is opened.
        """
        return pulumi.get(self, "consecutive_errors")

    @_builtins.property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[_builtins.int]:
        """
        The optional interval in seconds after which the error count resets to 0. An interval of 0 will never reset. If not specified, the timeoutInSeconds value will be used.
        """
        return pulumi.get(self, "interval_in_seconds")

    @_builtins.property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[_builtins.int]:
        """
        The interval in seconds until a retry attempt is made after the circuit is opened.
        """
        return pulumi.get(self, "timeout_in_seconds")


@pulumi.output_type
class DaprComponentResiliencyPolicyConfigurationResponse(dict):
    """
    Dapr Component Resiliency Policy Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "circuitBreakerPolicy":
            suggest = "circuit_breaker_policy"
        elif key == "httpRetryPolicy":
            suggest = "http_retry_policy"
        elif key == "timeoutPolicy":
            suggest = "timeout_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DaprComponentResiliencyPolicyConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DaprComponentResiliencyPolicyConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DaprComponentResiliencyPolicyConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 circuit_breaker_policy: Optional['outputs.DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationResponse'] = None,
                 http_retry_policy: Optional['outputs.DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationResponse'] = None,
                 timeout_policy: Optional['outputs.DaprComponentResiliencyPolicyTimeoutPolicyConfigurationResponse'] = None):
        """
        Dapr Component Resiliency Policy Configuration.
        :param 'DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationResponse' circuit_breaker_policy: The optional circuit breaker policy configuration
        :param 'DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationResponse' http_retry_policy: The optional HTTP retry policy configuration
        :param 'DaprComponentResiliencyPolicyTimeoutPolicyConfigurationResponse' timeout_policy: The optional timeout policy configuration
        """
        if circuit_breaker_policy is not None:
            pulumi.set(__self__, "circuit_breaker_policy", circuit_breaker_policy)
        if http_retry_policy is not None:
            pulumi.set(__self__, "http_retry_policy", http_retry_policy)
        if timeout_policy is not None:
            pulumi.set(__self__, "timeout_policy", timeout_policy)

    @_builtins.property
    @pulumi.getter(name="circuitBreakerPolicy")
    def circuit_breaker_policy(self) -> Optional['outputs.DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationResponse']:
        """
        The optional circuit breaker policy configuration
        """
        return pulumi.get(self, "circuit_breaker_policy")

    @_builtins.property
    @pulumi.getter(name="httpRetryPolicy")
    def http_retry_policy(self) -> Optional['outputs.DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationResponse']:
        """
        The optional HTTP retry policy configuration
        """
        return pulumi.get(self, "http_retry_policy")

    @_builtins.property
    @pulumi.getter(name="timeoutPolicy")
    def timeout_policy(self) -> Optional['outputs.DaprComponentResiliencyPolicyTimeoutPolicyConfigurationResponse']:
        """
        The optional timeout policy configuration
        """
        return pulumi.get(self, "timeout_policy")


@pulumi.output_type
class DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationResponse(dict):
    """
    Dapr Component Resiliency Policy HTTP Retry Backoff Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialDelayInMilliseconds":
            suggest = "initial_delay_in_milliseconds"
        elif key == "maxIntervalInMilliseconds":
            suggest = "max_interval_in_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_delay_in_milliseconds: Optional[_builtins.int] = None,
                 max_interval_in_milliseconds: Optional[_builtins.int] = None):
        """
        Dapr Component Resiliency Policy HTTP Retry Backoff Configuration.
        :param _builtins.int initial_delay_in_milliseconds: The optional initial delay in milliseconds before an operation is retried
        :param _builtins.int max_interval_in_milliseconds: The optional maximum time interval in milliseconds between retry attempts
        """
        if initial_delay_in_milliseconds is not None:
            pulumi.set(__self__, "initial_delay_in_milliseconds", initial_delay_in_milliseconds)
        if max_interval_in_milliseconds is not None:
            pulumi.set(__self__, "max_interval_in_milliseconds", max_interval_in_milliseconds)

    @_builtins.property
    @pulumi.getter(name="initialDelayInMilliseconds")
    def initial_delay_in_milliseconds(self) -> Optional[_builtins.int]:
        """
        The optional initial delay in milliseconds before an operation is retried
        """
        return pulumi.get(self, "initial_delay_in_milliseconds")

    @_builtins.property
    @pulumi.getter(name="maxIntervalInMilliseconds")
    def max_interval_in_milliseconds(self) -> Optional[_builtins.int]:
        """
        The optional maximum time interval in milliseconds between retry attempts
        """
        return pulumi.get(self, "max_interval_in_milliseconds")


@pulumi.output_type
class DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationResponse(dict):
    """
    Dapr Component Resiliency Policy HTTP Retry Policy Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRetries":
            suggest = "max_retries"
        elif key == "retryBackOff":
            suggest = "retry_back_off"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_retries: Optional[_builtins.int] = None,
                 retry_back_off: Optional['outputs.DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationResponse'] = None):
        """
        Dapr Component Resiliency Policy HTTP Retry Policy Configuration.
        :param _builtins.int max_retries: The optional maximum number of retries
        :param 'DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationResponse' retry_back_off: The optional retry backoff configuration
        """
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if retry_back_off is not None:
            pulumi.set(__self__, "retry_back_off", retry_back_off)

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        """
        The optional maximum number of retries
        """
        return pulumi.get(self, "max_retries")

    @_builtins.property
    @pulumi.getter(name="retryBackOff")
    def retry_back_off(self) -> Optional['outputs.DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationResponse']:
        """
        The optional retry backoff configuration
        """
        return pulumi.get(self, "retry_back_off")


@pulumi.output_type
class DaprComponentResiliencyPolicyTimeoutPolicyConfigurationResponse(dict):
    """
    Dapr Component Resiliency Policy Timeout Policy Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseTimeoutInSeconds":
            suggest = "response_timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DaprComponentResiliencyPolicyTimeoutPolicyConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DaprComponentResiliencyPolicyTimeoutPolicyConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DaprComponentResiliencyPolicyTimeoutPolicyConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_timeout_in_seconds: Optional[_builtins.int] = None):
        """
        Dapr Component Resiliency Policy Timeout Policy Configuration.
        :param _builtins.int response_timeout_in_seconds: The optional response timeout in seconds
        """
        if response_timeout_in_seconds is not None:
            pulumi.set(__self__, "response_timeout_in_seconds", response_timeout_in_seconds)

    @_builtins.property
    @pulumi.getter(name="responseTimeoutInSeconds")
    def response_timeout_in_seconds(self) -> Optional[_builtins.int]:
        """
        The optional response timeout in seconds
        """
        return pulumi.get(self, "response_timeout_in_seconds")


@pulumi.output_type
class DaprComponentServiceBindingResponse(dict):
    """
    Configuration to bind a Dapr Component to a dev ContainerApp Service
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DaprComponentServiceBindingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DaprComponentServiceBindingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DaprComponentServiceBindingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata: Optional['outputs.DaprServiceBindMetadataResponse'] = None,
                 name: Optional[_builtins.str] = None,
                 service_id: Optional[_builtins.str] = None):
        """
        Configuration to bind a Dapr Component to a dev ContainerApp Service
        :param 'DaprServiceBindMetadataResponse' metadata: Service bind metadata
        :param _builtins.str name: Name of the service bind
        :param _builtins.str service_id: Resource id of the target service
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.DaprServiceBindMetadataResponse']:
        """
        Service bind metadata
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the service bind
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[_builtins.str]:
        """
        Resource id of the target service
        """
        return pulumi.get(self, "service_id")


@pulumi.output_type
class DaprConfigurationResponse(dict):
    """
    Configuration properties Dapr component
    """
    def __init__(__self__, *,
                 version: _builtins.str):
        """
        Configuration properties Dapr component
        :param _builtins.str version: The version of Dapr
        """
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of Dapr
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DaprMetadataResponse(dict):
    """
    Dapr component metadata.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DaprMetadataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DaprMetadataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DaprMetadataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 secret_ref: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        Dapr component metadata.
        :param _builtins.str name: Metadata property name.
        :param _builtins.str secret_ref: Name of the Dapr Component secret from which to pull the metadata property value.
        :param _builtins.str value: Metadata property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Metadata property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[_builtins.str]:
        """
        Name of the Dapr Component secret from which to pull the metadata property value.
        """
        return pulumi.get(self, "secret_ref")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Metadata property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DaprResponse(dict):
    """
    Container App Dapr configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appHealth":
            suggest = "app_health"
        elif key == "appId":
            suggest = "app_id"
        elif key == "appPort":
            suggest = "app_port"
        elif key == "appProtocol":
            suggest = "app_protocol"
        elif key == "enableApiLogging":
            suggest = "enable_api_logging"
        elif key == "httpMaxRequestSize":
            suggest = "http_max_request_size"
        elif key == "httpReadBufferSize":
            suggest = "http_read_buffer_size"
        elif key == "logLevel":
            suggest = "log_level"
        elif key == "maxConcurrency":
            suggest = "max_concurrency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DaprResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DaprResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DaprResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_health: Optional['outputs.DaprResponseAppHealth'] = None,
                 app_id: Optional[_builtins.str] = None,
                 app_port: Optional[_builtins.int] = None,
                 app_protocol: Optional[_builtins.str] = None,
                 enable_api_logging: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 http_max_request_size: Optional[_builtins.int] = None,
                 http_read_buffer_size: Optional[_builtins.int] = None,
                 log_level: Optional[_builtins.str] = None,
                 max_concurrency: Optional[_builtins.int] = None):
        """
        Container App Dapr configuration.
        :param 'DaprResponseAppHealth' app_health: Dapr application health check configuration
        :param _builtins.str app_id: Dapr application identifier
        :param _builtins.int app_port: Tells Dapr which port your application is listening on
        :param _builtins.str app_protocol: Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
        :param _builtins.bool enable_api_logging: Enables API logging for the Dapr sidecar
        :param _builtins.bool enabled: Boolean indicating if the Dapr side car is enabled
        :param _builtins.int http_max_request_size: Increasing max size of request body http and grpc servers parameter in MB to handle uploading of big files. Default is 4 MB.
        :param _builtins.int http_read_buffer_size: Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        :param _builtins.str log_level: Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        :param _builtins.int max_concurrency: Maximum number of concurrent requests, events handled by the Dapr sidecar
        """
        if app_health is not None:
            pulumi.set(__self__, "app_health", app_health)
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_port is not None:
            pulumi.set(__self__, "app_port", app_port)
        if app_protocol is None:
            app_protocol = 'http'
        if app_protocol is not None:
            pulumi.set(__self__, "app_protocol", app_protocol)
        if enable_api_logging is not None:
            pulumi.set(__self__, "enable_api_logging", enable_api_logging)
        if enabled is None:
            enabled = False
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if http_max_request_size is not None:
            pulumi.set(__self__, "http_max_request_size", http_max_request_size)
        if http_read_buffer_size is not None:
            pulumi.set(__self__, "http_read_buffer_size", http_read_buffer_size)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if max_concurrency is not None:
            pulumi.set(__self__, "max_concurrency", max_concurrency)

    @_builtins.property
    @pulumi.getter(name="appHealth")
    def app_health(self) -> Optional['outputs.DaprResponseAppHealth']:
        """
        Dapr application health check configuration
        """
        return pulumi.get(self, "app_health")

    @_builtins.property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[_builtins.str]:
        """
        Dapr application identifier
        """
        return pulumi.get(self, "app_id")

    @_builtins.property
    @pulumi.getter(name="appPort")
    def app_port(self) -> Optional[_builtins.int]:
        """
        Tells Dapr which port your application is listening on
        """
        return pulumi.get(self, "app_port")

    @_builtins.property
    @pulumi.getter(name="appProtocol")
    def app_protocol(self) -> Optional[_builtins.str]:
        """
        Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
        """
        return pulumi.get(self, "app_protocol")

    @_builtins.property
    @pulumi.getter(name="enableApiLogging")
    def enable_api_logging(self) -> Optional[_builtins.bool]:
        """
        Enables API logging for the Dapr sidecar
        """
        return pulumi.get(self, "enable_api_logging")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating if the Dapr side car is enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="httpMaxRequestSize")
    def http_max_request_size(self) -> Optional[_builtins.int]:
        """
        Increasing max size of request body http and grpc servers parameter in MB to handle uploading of big files. Default is 4 MB.
        """
        return pulumi.get(self, "http_max_request_size")

    @_builtins.property
    @pulumi.getter(name="httpReadBufferSize")
    def http_read_buffer_size(self) -> Optional[_builtins.int]:
        """
        Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        """
        return pulumi.get(self, "http_read_buffer_size")

    @_builtins.property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[_builtins.str]:
        """
        Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        """
        return pulumi.get(self, "log_level")

    @_builtins.property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[_builtins.int]:
        """
        Maximum number of concurrent requests, events handled by the Dapr sidecar
        """
        return pulumi.get(self, "max_concurrency")


@pulumi.output_type
class DaprResponseAppHealth(dict):
    """
    Dapr application health check configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "probeIntervalSeconds":
            suggest = "probe_interval_seconds"
        elif key == "probeTimeoutMilliseconds":
            suggest = "probe_timeout_milliseconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DaprResponseAppHealth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DaprResponseAppHealth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DaprResponseAppHealth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 path: Optional[_builtins.str] = None,
                 probe_interval_seconds: Optional[_builtins.int] = None,
                 probe_timeout_milliseconds: Optional[_builtins.int] = None,
                 threshold: Optional[_builtins.int] = None):
        """
        Dapr application health check configuration
        :param _builtins.bool enabled: Boolean indicating if the health probe is enabled
        :param _builtins.str path: Path for the health probe
        :param _builtins.int probe_interval_seconds: Interval for the health probe in seconds
        :param _builtins.int probe_timeout_milliseconds: Timeout for the health probe in milliseconds
        :param _builtins.int threshold: Threshold for the health probe
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if probe_interval_seconds is not None:
            pulumi.set(__self__, "probe_interval_seconds", probe_interval_seconds)
        if probe_timeout_milliseconds is not None:
            pulumi.set(__self__, "probe_timeout_milliseconds", probe_timeout_milliseconds)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating if the health probe is enabled
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path for the health probe
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="probeIntervalSeconds")
    def probe_interval_seconds(self) -> Optional[_builtins.int]:
        """
        Interval for the health probe in seconds
        """
        return pulumi.get(self, "probe_interval_seconds")

    @_builtins.property
    @pulumi.getter(name="probeTimeoutMilliseconds")
    def probe_timeout_milliseconds(self) -> Optional[_builtins.int]:
        """
        Timeout for the health probe in milliseconds
        """
        return pulumi.get(self, "probe_timeout_milliseconds")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.int]:
        """
        Threshold for the health probe
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class DaprSecretResponse(dict):
    """
    Dapr component Secret for ListSecrets Action
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        Dapr component Secret for ListSecrets Action
        :param _builtins.str name: Secret Name.
        :param _builtins.str value: Secret Value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Secret Name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Secret Value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DaprServiceBindMetadataResponse(dict):
    """
    Dapr component metadata.
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        Dapr component metadata.
        :param _builtins.str name: Service bind metadata property name.
        :param _builtins.str value: Service bind metadata property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Service bind metadata property name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Service bind metadata property value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DaprSubscriptionBulkSubscribeOptionsResponse(dict):
    """
    Dapr PubSub Bulk Subscription Options.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAwaitDurationMs":
            suggest = "max_await_duration_ms"
        elif key == "maxMessagesCount":
            suggest = "max_messages_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DaprSubscriptionBulkSubscribeOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DaprSubscriptionBulkSubscribeOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DaprSubscriptionBulkSubscribeOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 max_await_duration_ms: Optional[_builtins.int] = None,
                 max_messages_count: Optional[_builtins.int] = None):
        """
        Dapr PubSub Bulk Subscription Options.
        :param _builtins.bool enabled: Enable bulk subscription
        :param _builtins.int max_await_duration_ms: Maximum duration in milliseconds to wait before a bulk message is sent to the app.
        :param _builtins.int max_messages_count: Maximum number of messages to deliver in a bulk message.
        """
        if enabled is None:
            enabled = False
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_await_duration_ms is not None:
            pulumi.set(__self__, "max_await_duration_ms", max_await_duration_ms)
        if max_messages_count is not None:
            pulumi.set(__self__, "max_messages_count", max_messages_count)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable bulk subscription
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxAwaitDurationMs")
    def max_await_duration_ms(self) -> Optional[_builtins.int]:
        """
        Maximum duration in milliseconds to wait before a bulk message is sent to the app.
        """
        return pulumi.get(self, "max_await_duration_ms")

    @_builtins.property
    @pulumi.getter(name="maxMessagesCount")
    def max_messages_count(self) -> Optional[_builtins.int]:
        """
        Maximum number of messages to deliver in a bulk message.
        """
        return pulumi.get(self, "max_messages_count")


@pulumi.output_type
class DaprSubscriptionRouteRuleResponse(dict):
    """
    Dapr Pubsub Event Subscription Route Rule is used to specify the condition for sending a message to a specific path.
    """
    def __init__(__self__, *,
                 match: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None):
        """
        Dapr Pubsub Event Subscription Route Rule is used to specify the condition for sending a message to a specific path.
        :param _builtins.str match: The optional CEL expression used to match the event. If the match is not specified, then the route is considered the default. The rules are tested in the order specified, so they should be define from most-to-least specific. The default route should appear last in the list.
        :param _builtins.str path: The path for events that match this rule
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[_builtins.str]:
        """
        The optional CEL expression used to match the event. If the match is not specified, then the route is considered the default. The rules are tested in the order specified, so they should be define from most-to-least specific. The default route should appear last in the list.
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        The path for events that match this rule
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class DaprSubscriptionRoutesResponse(dict):
    """
    Dapr PubSub Event Subscription Routes configuration.
    """
    def __init__(__self__, *,
                 default: Optional[_builtins.str] = None,
                 rules: Optional[Sequence['outputs.DaprSubscriptionRouteRuleResponse']] = None):
        """
        Dapr PubSub Event Subscription Routes configuration.
        :param _builtins.str default: The default path to deliver events that do not match any of the rules.
        :param Sequence['DaprSubscriptionRouteRuleResponse'] rules: The list of Dapr PubSub Event Subscription Route Rules.
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        """
        The default path to deliver events that do not match any of the rules.
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.DaprSubscriptionRouteRuleResponse']]:
        """
        The list of Dapr PubSub Event Subscription Route Rules.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class DataDogConfigurationResponse(dict):
    """
    Configuration of datadog 
    """
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 site: Optional[_builtins.str] = None):
        """
        Configuration of datadog 
        :param _builtins.str key: The data dog api key
        :param _builtins.str site: The data dog site
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if site is not None:
            pulumi.set(__self__, "site", site)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The data dog api key
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def site(self) -> Optional[_builtins.str]:
        """
        The data dog site
        """
        return pulumi.get(self, "site")


@pulumi.output_type
class DefaultAuthorizationPolicyResponse(dict):
    """
    The configuration settings of the Azure Active Directory default authorization policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedApplications":
            suggest = "allowed_applications"
        elif key == "allowedPrincipals":
            suggest = "allowed_principals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultAuthorizationPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultAuthorizationPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultAuthorizationPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_applications: Optional[Sequence[_builtins.str]] = None,
                 allowed_principals: Optional['outputs.AllowedPrincipalsResponse'] = None):
        """
        The configuration settings of the Azure Active Directory default authorization policy.
        :param Sequence[_builtins.str] allowed_applications: The configuration settings of the Azure Active Directory allowed applications.
        :param 'AllowedPrincipalsResponse' allowed_principals: The configuration settings of the Azure Active Directory allowed principals.
        """
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_principals is not None:
            pulumi.set(__self__, "allowed_principals", allowed_principals)

    @_builtins.property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[Sequence[_builtins.str]]:
        """
        The configuration settings of the Azure Active Directory allowed applications.
        """
        return pulumi.get(self, "allowed_applications")

    @_builtins.property
    @pulumi.getter(name="allowedPrincipals")
    def allowed_principals(self) -> Optional['outputs.AllowedPrincipalsResponse']:
        """
        The configuration settings of the Azure Active Directory allowed principals.
        """
        return pulumi.get(self, "allowed_principals")


@pulumi.output_type
class DestinationsConfigurationResponse(dict):
    """
    Configuration of Open Telemetry destinations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataDogConfiguration":
            suggest = "data_dog_configuration"
        elif key == "otlpConfigurations":
            suggest = "otlp_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_dog_configuration: Optional['outputs.DataDogConfigurationResponse'] = None,
                 otlp_configurations: Optional[Sequence['outputs.OtlpConfigurationResponse']] = None):
        """
        Configuration of Open Telemetry destinations
        :param 'DataDogConfigurationResponse' data_dog_configuration: Open telemetry datadog destination configuration
        :param Sequence['OtlpConfigurationResponse'] otlp_configurations: Open telemetry otlp configurations
        """
        if data_dog_configuration is not None:
            pulumi.set(__self__, "data_dog_configuration", data_dog_configuration)
        if otlp_configurations is not None:
            pulumi.set(__self__, "otlp_configurations", otlp_configurations)

    @_builtins.property
    @pulumi.getter(name="dataDogConfiguration")
    def data_dog_configuration(self) -> Optional['outputs.DataDogConfigurationResponse']:
        """
        Open telemetry datadog destination configuration
        """
        return pulumi.get(self, "data_dog_configuration")

    @_builtins.property
    @pulumi.getter(name="otlpConfigurations")
    def otlp_configurations(self) -> Optional[Sequence['outputs.OtlpConfigurationResponse']]:
        """
        Open telemetry otlp configurations
        """
        return pulumi.get(self, "otlp_configurations")


@pulumi.output_type
class DiskEncryptionConfigurationResponse(dict):
    """
    Configuration properties for disk encryption
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultConfiguration":
            suggest = "key_vault_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskEncryptionConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskEncryptionConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskEncryptionConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_vault_configuration: Optional['outputs.DiskEncryptionConfigurationResponseKeyVaultConfiguration'] = None):
        """
        Configuration properties for disk encryption
        :param 'DiskEncryptionConfigurationResponseKeyVaultConfiguration' key_vault_configuration: The Key Vault that contains your key to use for disk encryption. The Key Vault must be in the same region as the Managed Environment.
        """
        if key_vault_configuration is not None:
            pulumi.set(__self__, "key_vault_configuration", key_vault_configuration)

    @_builtins.property
    @pulumi.getter(name="keyVaultConfiguration")
    def key_vault_configuration(self) -> Optional['outputs.DiskEncryptionConfigurationResponseKeyVaultConfiguration']:
        """
        The Key Vault that contains your key to use for disk encryption. The Key Vault must be in the same region as the Managed Environment.
        """
        return pulumi.get(self, "key_vault_configuration")


@pulumi.output_type
class DiskEncryptionConfigurationResponseAuth(dict):
    """
    Configuration properties for the authentication to the Key Vault
    """
    def __init__(__self__, *,
                 identity: Optional[_builtins.str] = None):
        """
        Configuration properties for the authentication to the Key Vault
        :param _builtins.str identity: Resource ID of a user-assigned managed identity to authenticate to the Key Vault. The identity must be assigned to the managed environment, in the same tenant as the Key Vault, and it must have the following key permissions on the Key Vault: wrapkey, unwrapkey, get.
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        Resource ID of a user-assigned managed identity to authenticate to the Key Vault. The identity must be assigned to the managed environment, in the same tenant as the Key Vault, and it must have the following key permissions on the Key Vault: wrapkey, unwrapkey, get.
        """
        return pulumi.get(self, "identity")


@pulumi.output_type
class DiskEncryptionConfigurationResponseKeyVaultConfiguration(dict):
    """
    The Key Vault that contains your key to use for disk encryption. The Key Vault must be in the same region as the Managed Environment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyUrl":
            suggest = "key_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DiskEncryptionConfigurationResponseKeyVaultConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DiskEncryptionConfigurationResponseKeyVaultConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DiskEncryptionConfigurationResponseKeyVaultConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: Optional['outputs.DiskEncryptionConfigurationResponseAuth'] = None,
                 key_url: Optional[_builtins.str] = None):
        """
        The Key Vault that contains your key to use for disk encryption. The Key Vault must be in the same region as the Managed Environment.
        :param 'DiskEncryptionConfigurationResponseAuth' auth: Configuration properties for the authentication to the Key Vault
        :param _builtins.str key_url: Key URL pointing to a key in KeyVault. Version segment of the Url is required.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if key_url is not None:
            pulumi.set(__self__, "key_url", key_url)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional['outputs.DiskEncryptionConfigurationResponseAuth']:
        """
        Configuration properties for the authentication to the Key Vault
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter(name="keyUrl")
    def key_url(self) -> Optional[_builtins.str]:
        """
        Key URL pointing to a key in KeyVault. Version segment of the Url is required.
        """
        return pulumi.get(self, "key_url")


@pulumi.output_type
class DotNetComponentConfigurationPropertyResponse(dict):
    """
    Configuration properties for a .NET Component
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertyName":
            suggest = "property_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DotNetComponentConfigurationPropertyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DotNetComponentConfigurationPropertyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DotNetComponentConfigurationPropertyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 property_name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        Configuration properties for a .NET Component
        :param _builtins.str property_name: The name of the property
        :param _builtins.str value: The value of the property
        """
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[_builtins.str]:
        """
        The name of the property
        """
        return pulumi.get(self, "property_name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the property
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DotNetComponentServiceBindResponse(dict):
    """
    Configuration to bind a .NET Component to another .NET Component
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DotNetComponentServiceBindResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DotNetComponentServiceBindResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DotNetComponentServiceBindResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 service_id: Optional[_builtins.str] = None):
        """
        Configuration to bind a .NET Component to another .NET Component
        :param _builtins.str name: Name of the service bind
        :param _builtins.str service_id: Resource id of the target service
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the service bind
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[_builtins.str]:
        """
        Resource id of the target service
        """
        return pulumi.get(self, "service_id")


@pulumi.output_type
class DynamicPoolConfigurationResponse(dict):
    """
    Dynamic pool configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lifecycleConfiguration":
            suggest = "lifecycle_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DynamicPoolConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DynamicPoolConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DynamicPoolConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lifecycle_configuration: Optional['outputs.LifecycleConfigurationResponse'] = None):
        """
        Dynamic pool configuration.
        :param 'LifecycleConfigurationResponse' lifecycle_configuration: The lifecycle configuration of a session in the dynamic session pool
        """
        if lifecycle_configuration is not None:
            pulumi.set(__self__, "lifecycle_configuration", lifecycle_configuration)

    @_builtins.property
    @pulumi.getter(name="lifecycleConfiguration")
    def lifecycle_configuration(self) -> Optional['outputs.LifecycleConfigurationResponse']:
        """
        The lifecycle configuration of a session in the dynamic session pool
        """
        return pulumi.get(self, "lifecycle_configuration")


@pulumi.output_type
class EncryptionSettingsResponse(dict):
    """
    The configuration settings of the secrets references of encryption key and signing key for ContainerApp Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerAppAuthEncryptionSecretName":
            suggest = "container_app_auth_encryption_secret_name"
        elif key == "containerAppAuthSigningSecretName":
            suggest = "container_app_auth_signing_secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_app_auth_encryption_secret_name: Optional[_builtins.str] = None,
                 container_app_auth_signing_secret_name: Optional[_builtins.str] = None):
        """
        The configuration settings of the secrets references of encryption key and signing key for ContainerApp Service Authentication/Authorization.
        :param _builtins.str container_app_auth_encryption_secret_name: The secret name which is referenced for EncryptionKey.
        :param _builtins.str container_app_auth_signing_secret_name: The secret name which is referenced for SigningKey.
        """
        if container_app_auth_encryption_secret_name is not None:
            pulumi.set(__self__, "container_app_auth_encryption_secret_name", container_app_auth_encryption_secret_name)
        if container_app_auth_signing_secret_name is not None:
            pulumi.set(__self__, "container_app_auth_signing_secret_name", container_app_auth_signing_secret_name)

    @_builtins.property
    @pulumi.getter(name="containerAppAuthEncryptionSecretName")
    def container_app_auth_encryption_secret_name(self) -> Optional[_builtins.str]:
        """
        The secret name which is referenced for EncryptionKey.
        """
        return pulumi.get(self, "container_app_auth_encryption_secret_name")

    @_builtins.property
    @pulumi.getter(name="containerAppAuthSigningSecretName")
    def container_app_auth_signing_secret_name(self) -> Optional[_builtins.str]:
        """
        The secret name which is referenced for SigningKey.
        """
        return pulumi.get(self, "container_app_auth_signing_secret_name")


@pulumi.output_type
class EnvironmentVarResponse(dict):
    """
    Container App container environment variable.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentVarResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentVarResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentVarResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 secret_ref: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        Container App container environment variable.
        :param _builtins.str name: Environment variable name.
        :param _builtins.str secret_ref: Name of the Container App secret from which to pull the environment variable value.
        :param _builtins.str value: Non-secret environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Environment variable name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[_builtins.str]:
        """
        Name of the Container App secret from which to pull the environment variable value.
        """
        return pulumi.get(self, "secret_ref")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Non-secret environment variable value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EnvironmentVariableResponse(dict):
    """
    Model representing an environment variable.
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        Model representing an environment variable.
        :param _builtins.str name: Environment variable name.
        :param _builtins.str value: Environment variable value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Environment variable name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ErrorEntityResponse(dict):
    """
    Body of the error response returned from the API.
    """
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 details: Optional[Sequence['outputs.ErrorEntityResponse']] = None,
                 extended_code: Optional[_builtins.str] = None,
                 inner_errors: Optional[Sequence['outputs.ErrorEntityResponse']] = None,
                 message: Optional[_builtins.str] = None,
                 message_template: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence[_builtins.str]] = None,
                 target: Optional[_builtins.str] = None):
        """
        Body of the error response returned from the API.
        :param _builtins.str code: Basic error code.
        :param Sequence['ErrorEntityResponse'] details: Error Details.
        :param _builtins.str extended_code: Type of error.
        :param Sequence['ErrorEntityResponse'] inner_errors: Inner errors.
        :param _builtins.str message: Any details of the error.
        :param _builtins.str message_template: Message template.
        :param Sequence[_builtins.str] parameters: Parameters for the template.
        :param _builtins.str target: The error target.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if extended_code is not None:
            pulumi.set(__self__, "extended_code", extended_code)
        if inner_errors is not None:
            pulumi.set(__self__, "inner_errors", inner_errors)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if message_template is not None:
            pulumi.set(__self__, "message_template", message_template)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        Basic error code.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.ErrorEntityResponse']]:
        """
        Error Details.
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter(name="extendedCode")
    def extended_code(self) -> Optional[_builtins.str]:
        """
        Type of error.
        """
        return pulumi.get(self, "extended_code")

    @_builtins.property
    @pulumi.getter(name="innerErrors")
    def inner_errors(self) -> Optional[Sequence['outputs.ErrorEntityResponse']]:
        """
        Inner errors.
        """
        return pulumi.get(self, "inner_errors")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        Any details of the error.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="messageTemplate")
    def message_template(self) -> Optional[_builtins.str]:
        """
        Message template.
        """
        return pulumi.get(self, "message_template")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Parameters for the template.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        The error target.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ExtendedLocationResponse(dict):
    """
    The complex type of the extended location.
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        The complex type of the extended location.
        :param _builtins.str name: The name of the extended location.
        :param _builtins.str type: The type of the extended location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the extended location.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FacebookResponse(dict):
    """
    The configuration settings of the Facebook provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "graphApiVersion":
            suggest = "graph_api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FacebookResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FacebookResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FacebookResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 graph_api_version: Optional[_builtins.str] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.AppRegistrationResponse'] = None):
        """
        The configuration settings of the Facebook provider.
        :param _builtins.bool enabled: <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param _builtins.str graph_api_version: The version of the Facebook api to be used while logging in.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'AppRegistrationResponse' registration: The configuration settings of the app registration for the Facebook provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[_builtins.str]:
        """
        The version of the Facebook api to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @_builtins.property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @_builtins.property
    @pulumi.getter
    def registration(self) -> Optional['outputs.AppRegistrationResponse']:
        """
        The configuration settings of the app registration for the Facebook provider.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class ForwardProxyResponse(dict):
    """
    The configuration settings of a forward proxy used to make the requests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHostHeaderName":
            suggest = "custom_host_header_name"
        elif key == "customProtoHeaderName":
            suggest = "custom_proto_header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ForwardProxyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ForwardProxyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ForwardProxyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 convention: Optional[_builtins.str] = None,
                 custom_host_header_name: Optional[_builtins.str] = None,
                 custom_proto_header_name: Optional[_builtins.str] = None):
        """
        The configuration settings of a forward proxy used to make the requests.
        :param _builtins.str convention: The convention used to determine the url of the request made.
        :param _builtins.str custom_host_header_name: The name of the header containing the host of the request.
        :param _builtins.str custom_proto_header_name: The name of the header containing the scheme of the request.
        """
        if convention is not None:
            pulumi.set(__self__, "convention", convention)
        if custom_host_header_name is not None:
            pulumi.set(__self__, "custom_host_header_name", custom_host_header_name)
        if custom_proto_header_name is not None:
            pulumi.set(__self__, "custom_proto_header_name", custom_proto_header_name)

    @_builtins.property
    @pulumi.getter
    def convention(self) -> Optional[_builtins.str]:
        """
        The convention used to determine the url of the request made.
        """
        return pulumi.get(self, "convention")

    @_builtins.property
    @pulumi.getter(name="customHostHeaderName")
    def custom_host_header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header containing the host of the request.
        """
        return pulumi.get(self, "custom_host_header_name")

    @_builtins.property
    @pulumi.getter(name="customProtoHeaderName")
    def custom_proto_header_name(self) -> Optional[_builtins.str]:
        """
        The name of the header containing the scheme of the request.
        """
        return pulumi.get(self, "custom_proto_header_name")


@pulumi.output_type
class GitHubResponse(dict):
    """
    The configuration settings of the GitHub provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.ClientRegistrationResponse'] = None):
        """
        The configuration settings of the GitHub provider.
        :param _builtins.bool enabled: <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'ClientRegistrationResponse' registration: The configuration settings of the app registration for the GitHub provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @_builtins.property
    @pulumi.getter
    def registration(self) -> Optional['outputs.ClientRegistrationResponse']:
        """
        The configuration settings of the app registration for the GitHub provider.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class GithubActionConfigurationResponse(dict):
    """
    Configuration properties that define the mutable settings of a Container App SourceControl
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureCredentials":
            suggest = "azure_credentials"
        elif key == "buildEnvironmentVariables":
            suggest = "build_environment_variables"
        elif key == "contextPath":
            suggest = "context_path"
        elif key == "dockerfilePath":
            suggest = "dockerfile_path"
        elif key == "publishType":
            suggest = "publish_type"
        elif key == "registryInfo":
            suggest = "registry_info"
        elif key == "runtimeStack":
            suggest = "runtime_stack"
        elif key == "runtimeVersion":
            suggest = "runtime_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GithubActionConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GithubActionConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GithubActionConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_credentials: Optional['outputs.AzureCredentialsResponse'] = None,
                 build_environment_variables: Optional[Sequence['outputs.EnvironmentVariableResponse']] = None,
                 context_path: Optional[_builtins.str] = None,
                 dockerfile_path: Optional[_builtins.str] = None,
                 image: Optional[_builtins.str] = None,
                 os: Optional[_builtins.str] = None,
                 publish_type: Optional[_builtins.str] = None,
                 registry_info: Optional['outputs.RegistryInfoResponse'] = None,
                 runtime_stack: Optional[_builtins.str] = None,
                 runtime_version: Optional[_builtins.str] = None):
        """
        Configuration properties that define the mutable settings of a Container App SourceControl
        :param 'AzureCredentialsResponse' azure_credentials: AzureCredentials configurations.
        :param Sequence['EnvironmentVariableResponse'] build_environment_variables: List of environment variables to be passed to the build.
        :param _builtins.str context_path: Context path
        :param _builtins.str dockerfile_path: Dockerfile path
        :param _builtins.str image: Image name
        :param _builtins.str os: Operation system
        :param _builtins.str publish_type: Code or Image
        :param 'RegistryInfoResponse' registry_info: Registry configurations.
        :param _builtins.str runtime_stack: Runtime stack
        :param _builtins.str runtime_version: Runtime version
        """
        if azure_credentials is not None:
            pulumi.set(__self__, "azure_credentials", azure_credentials)
        if build_environment_variables is not None:
            pulumi.set(__self__, "build_environment_variables", build_environment_variables)
        if context_path is not None:
            pulumi.set(__self__, "context_path", context_path)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if publish_type is not None:
            pulumi.set(__self__, "publish_type", publish_type)
        if registry_info is not None:
            pulumi.set(__self__, "registry_info", registry_info)
        if runtime_stack is not None:
            pulumi.set(__self__, "runtime_stack", runtime_stack)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)

    @_builtins.property
    @pulumi.getter(name="azureCredentials")
    def azure_credentials(self) -> Optional['outputs.AzureCredentialsResponse']:
        """
        AzureCredentials configurations.
        """
        return pulumi.get(self, "azure_credentials")

    @_builtins.property
    @pulumi.getter(name="buildEnvironmentVariables")
    def build_environment_variables(self) -> Optional[Sequence['outputs.EnvironmentVariableResponse']]:
        """
        List of environment variables to be passed to the build.
        """
        return pulumi.get(self, "build_environment_variables")

    @_builtins.property
    @pulumi.getter(name="contextPath")
    def context_path(self) -> Optional[_builtins.str]:
        """
        Context path
        """
        return pulumi.get(self, "context_path")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[_builtins.str]:
        """
        Dockerfile path
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Image name
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def os(self) -> Optional[_builtins.str]:
        """
        Operation system
        """
        return pulumi.get(self, "os")

    @_builtins.property
    @pulumi.getter(name="publishType")
    def publish_type(self) -> Optional[_builtins.str]:
        """
        Code or Image
        """
        return pulumi.get(self, "publish_type")

    @_builtins.property
    @pulumi.getter(name="registryInfo")
    def registry_info(self) -> Optional['outputs.RegistryInfoResponse']:
        """
        Registry configurations.
        """
        return pulumi.get(self, "registry_info")

    @_builtins.property
    @pulumi.getter(name="runtimeStack")
    def runtime_stack(self) -> Optional[_builtins.str]:
        """
        Runtime stack
        """
        return pulumi.get(self, "runtime_stack")

    @_builtins.property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[_builtins.str]:
        """
        Runtime version
        """
        return pulumi.get(self, "runtime_version")


@pulumi.output_type
class GlobalValidationResponse(dict):
    """
    The configuration settings that determines the validation flow of users using ContainerApp Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedPaths":
            suggest = "excluded_paths"
        elif key == "redirectToProvider":
            suggest = "redirect_to_provider"
        elif key == "unauthenticatedClientAction":
            suggest = "unauthenticated_client_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalValidationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalValidationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalValidationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 excluded_paths: Optional[Sequence[_builtins.str]] = None,
                 redirect_to_provider: Optional[_builtins.str] = None,
                 unauthenticated_client_action: Optional[_builtins.str] = None):
        """
        The configuration settings that determines the validation flow of users using ContainerApp Service Authentication/Authorization.
        :param Sequence[_builtins.str] excluded_paths: The paths for which unauthenticated flow would not be redirected to the login page.
        :param _builtins.str redirect_to_provider: The default authentication provider to use when multiple providers are configured.
               This setting is only needed if multiple providers are configured and the unauthenticated client
               action is set to "RedirectToLoginPage".
        :param _builtins.str unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app.
        """
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if redirect_to_provider is not None:
            pulumi.set(__self__, "redirect_to_provider", redirect_to_provider)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @_builtins.property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        The paths for which unauthenticated flow would not be redirected to the login page.
        """
        return pulumi.get(self, "excluded_paths")

    @_builtins.property
    @pulumi.getter(name="redirectToProvider")
    def redirect_to_provider(self) -> Optional[_builtins.str]:
        """
        The default authentication provider to use when multiple providers are configured.
        This setting is only needed if multiple providers are configured and the unauthenticated client
        action is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "redirect_to_provider")

    @_builtins.property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[_builtins.str]:
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")


@pulumi.output_type
class GoogleResponse(dict):
    """
    The configuration settings of the Google provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 login: Optional['outputs.LoginScopesResponse'] = None,
                 registration: Optional['outputs.ClientRegistrationResponse'] = None,
                 validation: Optional['outputs.AllowedAudiencesValidationResponse'] = None):
        """
        The configuration settings of the Google provider.
        :param _builtins.bool enabled: <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'LoginScopesResponse' login: The configuration settings of the login flow.
        :param 'ClientRegistrationResponse' registration: The configuration settings of the app registration for the Google provider.
        :param 'AllowedAudiencesValidationResponse' validation: The configuration settings of the Azure Active Directory token validation flow.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def login(self) -> Optional['outputs.LoginScopesResponse']:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @_builtins.property
    @pulumi.getter
    def registration(self) -> Optional['outputs.ClientRegistrationResponse']:
        """
        The configuration settings of the app registration for the Google provider.
        """
        return pulumi.get(self, "registration")

    @_builtins.property
    @pulumi.getter
    def validation(self) -> Optional['outputs.AllowedAudiencesValidationResponse']:
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        return pulumi.get(self, "validation")


@pulumi.output_type
class HeaderMatchResponse(dict):
    """
    Conditions required to match a header
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exactMatch":
            suggest = "exact_match"
        elif key == "prefixMatch":
            suggest = "prefix_match"
        elif key == "regexMatch":
            suggest = "regex_match"
        elif key == "suffixMatch":
            suggest = "suffix_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HeaderMatchResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HeaderMatchResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HeaderMatchResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exact_match: Optional[_builtins.str] = None,
                 header: Optional[_builtins.str] = None,
                 prefix_match: Optional[_builtins.str] = None,
                 regex_match: Optional[_builtins.str] = None,
                 suffix_match: Optional[_builtins.str] = None):
        """
        Conditions required to match a header
        :param _builtins.str exact_match: Exact value of the header
        :param _builtins.str header: Name of the header
        :param _builtins.str prefix_match: Prefix value of the header
        :param _builtins.str regex_match: Regex value of the header
        :param _builtins.str suffix_match: Suffix value of the header
        """
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)
        if suffix_match is not None:
            pulumi.set(__self__, "suffix_match", suffix_match)

    @_builtins.property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[_builtins.str]:
        """
        Exact value of the header
        """
        return pulumi.get(self, "exact_match")

    @_builtins.property
    @pulumi.getter
    def header(self) -> Optional[_builtins.str]:
        """
        Name of the header
        """
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[_builtins.str]:
        """
        Prefix value of the header
        """
        return pulumi.get(self, "prefix_match")

    @_builtins.property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[_builtins.str]:
        """
        Regex value of the header
        """
        return pulumi.get(self, "regex_match")

    @_builtins.property
    @pulumi.getter(name="suffixMatch")
    def suffix_match(self) -> Optional[_builtins.str]:
        """
        Suffix value of the header
        """
        return pulumi.get(self, "suffix_match")


@pulumi.output_type
class HeaderResponse(dict):
    """
    Header of otlp configuration
    """
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        Header of otlp configuration
        :param _builtins.str key: The key of otlp configuration header
        :param _builtins.str value: The value of otlp configuration header
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The key of otlp configuration header
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of otlp configuration header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HttpConnectionPoolResponse(dict):
    """
    Defines parameters for http connection pooling
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "http1MaxPendingRequests":
            suggest = "http1_max_pending_requests"
        elif key == "http2MaxRequests":
            suggest = "http2_max_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpConnectionPoolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpConnectionPoolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpConnectionPoolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http1_max_pending_requests: Optional[_builtins.int] = None,
                 http2_max_requests: Optional[_builtins.int] = None):
        """
        Defines parameters for http connection pooling
        :param _builtins.int http1_max_pending_requests: Maximum number of pending http1 requests allowed
        :param _builtins.int http2_max_requests: Maximum number of http2 requests allowed
        """
        if http1_max_pending_requests is not None:
            pulumi.set(__self__, "http1_max_pending_requests", http1_max_pending_requests)
        if http2_max_requests is not None:
            pulumi.set(__self__, "http2_max_requests", http2_max_requests)

    @_builtins.property
    @pulumi.getter(name="http1MaxPendingRequests")
    def http1_max_pending_requests(self) -> Optional[_builtins.int]:
        """
        Maximum number of pending http1 requests allowed
        """
        return pulumi.get(self, "http1_max_pending_requests")

    @_builtins.property
    @pulumi.getter(name="http2MaxRequests")
    def http2_max_requests(self) -> Optional[_builtins.int]:
        """
        Maximum number of http2 requests allowed
        """
        return pulumi.get(self, "http2_max_requests")


@pulumi.output_type
class HttpGetResponse(dict):
    """
    Model representing a http get request.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileName":
            suggest = "file_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpGetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpGetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpGetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 file_name: Optional[_builtins.str] = None,
                 headers: Optional[Sequence[_builtins.str]] = None):
        """
        Model representing a http get request.
        :param _builtins.str url: URL to make HTTP GET request against.
        :param _builtins.str file_name: Name of the file that the request should be saved to.
        :param Sequence[_builtins.str] headers: List of headers to send with the request.
        """
        pulumi.set(__self__, "url", url)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL to make HTTP GET request against.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[_builtins.str]:
        """
        Name of the file that the request should be saved to.
        """
        return pulumi.get(self, "file_name")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of headers to send with the request.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class HttpRetryPolicyResponse(dict):
    """
    Policy that defines http request retry conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpStatusCodes":
            suggest = "http_status_codes"
        elif key == "initialDelayInMilliseconds":
            suggest = "initial_delay_in_milliseconds"
        elif key == "maxIntervalInMilliseconds":
            suggest = "max_interval_in_milliseconds"
        elif key == "maxRetries":
            suggest = "max_retries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpRetryPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpRetryPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpRetryPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 errors: Optional[Sequence[_builtins.str]] = None,
                 headers: Optional[Sequence['outputs.HeaderMatchResponse']] = None,
                 http_status_codes: Optional[Sequence[_builtins.int]] = None,
                 initial_delay_in_milliseconds: Optional[_builtins.float] = None,
                 max_interval_in_milliseconds: Optional[_builtins.float] = None,
                 max_retries: Optional[_builtins.int] = None):
        """
        Policy that defines http request retry conditions
        :param Sequence[_builtins.str] errors: Errors that can trigger a retry
        :param Sequence['HeaderMatchResponse'] headers: Headers that must be present for a request to be retried
        :param Sequence[_builtins.int] http_status_codes: Additional http status codes that can trigger a retry
        :param _builtins.float initial_delay_in_milliseconds: Initial delay, in milliseconds, before retrying a request
        :param _builtins.float max_interval_in_milliseconds: Maximum interval, in milliseconds, between retries
        :param _builtins.int max_retries: Maximum number of times a request will retry
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_status_codes is not None:
            pulumi.set(__self__, "http_status_codes", http_status_codes)
        if initial_delay_in_milliseconds is not None:
            pulumi.set(__self__, "initial_delay_in_milliseconds", initial_delay_in_milliseconds)
        if max_interval_in_milliseconds is not None:
            pulumi.set(__self__, "max_interval_in_milliseconds", max_interval_in_milliseconds)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)

    @_builtins.property
    @pulumi.getter
    def errors(self) -> Optional[Sequence[_builtins.str]]:
        """
        Errors that can trigger a retry
        """
        return pulumi.get(self, "errors")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.HeaderMatchResponse']]:
        """
        Headers that must be present for a request to be retried
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="httpStatusCodes")
    def http_status_codes(self) -> Optional[Sequence[_builtins.int]]:
        """
        Additional http status codes that can trigger a retry
        """
        return pulumi.get(self, "http_status_codes")

    @_builtins.property
    @pulumi.getter(name="initialDelayInMilliseconds")
    def initial_delay_in_milliseconds(self) -> Optional[_builtins.float]:
        """
        Initial delay, in milliseconds, before retrying a request
        """
        return pulumi.get(self, "initial_delay_in_milliseconds")

    @_builtins.property
    @pulumi.getter(name="maxIntervalInMilliseconds")
    def max_interval_in_milliseconds(self) -> Optional[_builtins.float]:
        """
        Maximum interval, in milliseconds, between retries
        """
        return pulumi.get(self, "max_interval_in_milliseconds")

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[_builtins.int]:
        """
        Maximum number of times a request will retry
        """
        return pulumi.get(self, "max_retries")


@pulumi.output_type
class HttpRouteActionResponse(dict):
    """
    Action to perform once matching of routes is done
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixRewrite":
            suggest = "prefix_rewrite"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpRouteActionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpRouteActionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpRouteActionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefix_rewrite: Optional[_builtins.str] = None):
        """
        Action to perform once matching of routes is done
        :param _builtins.str prefix_rewrite: Rewrite prefix, default is no rewrites
        """
        if prefix_rewrite is not None:
            pulumi.set(__self__, "prefix_rewrite", prefix_rewrite)

    @_builtins.property
    @pulumi.getter(name="prefixRewrite")
    def prefix_rewrite(self) -> Optional[_builtins.str]:
        """
        Rewrite prefix, default is no rewrites
        """
        return pulumi.get(self, "prefix_rewrite")


@pulumi.output_type
class HttpRouteConfigResponseProperties(dict):
    """
    Http Route Config properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningErrors":
            suggest = "provisioning_errors"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "customDomains":
            suggest = "custom_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpRouteConfigResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpRouteConfigResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpRouteConfigResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 provisioning_errors: Sequence['outputs.HttpRouteProvisioningErrorsResponse'],
                 provisioning_state: _builtins.str,
                 custom_domains: Optional[Sequence['outputs.CustomDomainResponse']] = None,
                 rules: Optional[Sequence['outputs.HttpRouteRuleResponse']] = None):
        """
        Http Route Config properties
        :param _builtins.str fqdn: FQDN of the route resource.
        :param Sequence['HttpRouteProvisioningErrorsResponse'] provisioning_errors: List of errors when trying to reconcile http routes
        :param _builtins.str provisioning_state: The provisioning state of the Http Route Config in cluster
        :param Sequence['CustomDomainResponse'] custom_domains: Custom domain bindings for http Routes' hostnames.
        :param Sequence['HttpRouteRuleResponse'] rules: Routing Rules for http route resource.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "provisioning_errors", provisioning_errors)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if custom_domains is not None:
            pulumi.set(__self__, "custom_domains", custom_domains)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        FQDN of the route resource.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="provisioningErrors")
    def provisioning_errors(self) -> Sequence['outputs.HttpRouteProvisioningErrorsResponse']:
        """
        List of errors when trying to reconcile http routes
        """
        return pulumi.get(self, "provisioning_errors")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the Http Route Config in cluster
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="customDomains")
    def custom_domains(self) -> Optional[Sequence['outputs.CustomDomainResponse']]:
        """
        Custom domain bindings for http Routes' hostnames.
        """
        return pulumi.get(self, "custom_domains")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.HttpRouteRuleResponse']]:
        """
        Routing Rules for http route resource.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class HttpRouteMatchResponse(dict):
    """
    Criteria to match on
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "pathSeparatedPrefix":
            suggest = "path_separated_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpRouteMatchResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpRouteMatchResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpRouteMatchResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitive: Optional[_builtins.bool] = None,
                 path: Optional[_builtins.str] = None,
                 path_separated_prefix: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None):
        """
        Criteria to match on
        :param _builtins.bool case_sensitive: path case sensitive, default is true
        :param _builtins.str path: match on exact path
        :param _builtins.str path_separated_prefix: match on all prefix's. Not exact
        :param _builtins.str prefix: match on all prefix's. Not exact
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if path_separated_prefix is not None:
            pulumi.set(__self__, "path_separated_prefix", path_separated_prefix)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[_builtins.bool]:
        """
        path case sensitive, default is true
        """
        return pulumi.get(self, "case_sensitive")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        match on exact path
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="pathSeparatedPrefix")
    def path_separated_prefix(self) -> Optional[_builtins.str]:
        """
        match on all prefix's. Not exact
        """
        return pulumi.get(self, "path_separated_prefix")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        match on all prefix's. Not exact
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class HttpRouteProvisioningErrorsResponse(dict):
    """
    List of provisioning errors for a http route config object
    """
    def __init__(__self__, *,
                 message: _builtins.str,
                 timestamp: _builtins.str):
        """
        List of provisioning errors for a http route config object
        :param _builtins.str message: Description or error message
        :param _builtins.str timestamp: Timestamp error occured at
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        Description or error message
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.str:
        """
        Timestamp error occured at
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class HttpRouteResponse(dict):
    """
    Http Routes configuration, including paths to match on and whether or not rewrites are to be done.
    """
    def __init__(__self__, *,
                 action: Optional['outputs.HttpRouteActionResponse'] = None,
                 match: Optional['outputs.HttpRouteMatchResponse'] = None):
        """
        Http Routes configuration, including paths to match on and whether or not rewrites are to be done.
        :param 'HttpRouteActionResponse' action: Once route is matched, what is the desired action
        :param 'HttpRouteMatchResponse' match: Conditions route will match on
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional['outputs.HttpRouteActionResponse']:
        """
        Once route is matched, what is the desired action
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional['outputs.HttpRouteMatchResponse']:
        """
        Conditions route will match on
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class HttpRouteRuleResponse(dict):
    """
    Http Route rule.
    """
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 routes: Optional[Sequence['outputs.HttpRouteResponse']] = None,
                 targets: Optional[Sequence['outputs.HttpRouteTargetResponse']] = None):
        """
        Http Route rule.
        :param _builtins.str description: Description of rule. Optional.
        :param Sequence['HttpRouteResponse'] routes: Routing configuration that will allow matches on specific paths/headers.
        :param Sequence['HttpRouteTargetResponse'] targets: Targets- container apps, revisions, labels
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of rule. Optional.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.HttpRouteResponse']]:
        """
        Routing configuration that will allow matches on specific paths/headers.
        """
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Optional[Sequence['outputs.HttpRouteTargetResponse']]:
        """
        Targets- container apps, revisions, labels
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class HttpRouteTargetResponse(dict):
    """
    Targets - Container App Names, Revision Names, Labels.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerApp":
            suggest = "container_app"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpRouteTargetResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpRouteTargetResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpRouteTargetResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_app: _builtins.str,
                 label: Optional[_builtins.str] = None,
                 revision: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        """
        Targets - Container App Names, Revision Names, Labels.
        :param _builtins.str container_app: Container App Name to route requests to
        :param _builtins.str label: Label/Revision to route requests to
        :param _builtins.str revision: Revision to route requests to
        :param _builtins.int weight: Weighted routing
        """
        pulumi.set(__self__, "container_app", container_app)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="containerApp")
    def container_app(self) -> _builtins.str:
        """
        Container App Name to route requests to
        """
        return pulumi.get(self, "container_app")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Label/Revision to route requests to
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def revision(self) -> Optional[_builtins.str]:
        """
        Revision to route requests to
        """
        return pulumi.get(self, "revision")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Weighted routing
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class HttpScaleRuleResponse(dict):
    """
    Container App container Http scaling rule.
    """
    def __init__(__self__, *,
                 auth: Optional[Sequence['outputs.ScaleRuleAuthResponse']] = None,
                 identity: Optional[_builtins.str] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None):
        """
        Container App container Http scaling rule.
        :param Sequence['ScaleRuleAuthResponse'] auth: Authentication secrets for the custom scale rule.
        :param _builtins.str identity: The resource ID of a user-assigned managed identity that is assigned to the Container App, or 'system' for system-assigned identity.
        :param Mapping[str, _builtins.str] metadata: Metadata properties to describe http scale rule.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[Sequence['outputs.ScaleRuleAuthResponse']]:
        """
        Authentication secrets for the custom scale rule.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        The resource ID of a user-assigned managed identity that is assigned to the Container App, or 'system' for system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Metadata properties to describe http scale rule.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class HttpSettingsResponse(dict):
    """
    The configuration settings of the HTTP requests for authentication and authorization requests made against ContainerApp Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardProxy":
            suggest = "forward_proxy"
        elif key == "requireHttps":
            suggest = "require_https"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpSettingsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpSettingsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpSettingsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forward_proxy: Optional['outputs.ForwardProxyResponse'] = None,
                 require_https: Optional[_builtins.bool] = None,
                 routes: Optional['outputs.HttpSettingsRoutesResponse'] = None):
        """
        The configuration settings of the HTTP requests for authentication and authorization requests made against ContainerApp Service Authentication/Authorization.
        :param 'ForwardProxyResponse' forward_proxy: The configuration settings of a forward proxy used to make the requests.
        :param _builtins.bool require_https: <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        :param 'HttpSettingsRoutesResponse' routes: The configuration settings of the paths HTTP requests.
        """
        if forward_proxy is not None:
            pulumi.set(__self__, "forward_proxy", forward_proxy)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @_builtins.property
    @pulumi.getter(name="forwardProxy")
    def forward_proxy(self) -> Optional['outputs.ForwardProxyResponse']:
        """
        The configuration settings of a forward proxy used to make the requests.
        """
        return pulumi.get(self, "forward_proxy")

    @_builtins.property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[_builtins.bool]:
        """
        <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "require_https")

    @_builtins.property
    @pulumi.getter
    def routes(self) -> Optional['outputs.HttpSettingsRoutesResponse']:
        """
        The configuration settings of the paths HTTP requests.
        """
        return pulumi.get(self, "routes")


@pulumi.output_type
class HttpSettingsRoutesResponse(dict):
    """
    The configuration settings of the paths HTTP requests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiPrefix":
            suggest = "api_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpSettingsRoutesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpSettingsRoutesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpSettingsRoutesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_prefix: Optional[_builtins.str] = None):
        """
        The configuration settings of the paths HTTP requests.
        :param _builtins.str api_prefix: The prefix that should precede all the authentication/authorization paths.
        """
        if api_prefix is not None:
            pulumi.set(__self__, "api_prefix", api_prefix)

    @_builtins.property
    @pulumi.getter(name="apiPrefix")
    def api_prefix(self) -> Optional[_builtins.str]:
        """
        The prefix that should precede all the authentication/authorization paths.
        """
        return pulumi.get(self, "api_prefix")


@pulumi.output_type
class IdentityProvidersResponse(dict):
    """
    The configuration settings of each of the identity providers used to configure ContainerApp Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureActiveDirectory":
            suggest = "azure_active_directory"
        elif key == "azureStaticWebApps":
            suggest = "azure_static_web_apps"
        elif key == "customOpenIdConnectProviders":
            suggest = "custom_open_id_connect_providers"
        elif key == "gitHub":
            suggest = "git_hub"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityProvidersResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityProvidersResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityProvidersResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apple: Optional['outputs.AppleResponse'] = None,
                 azure_active_directory: Optional['outputs.AzureActiveDirectoryResponse'] = None,
                 azure_static_web_apps: Optional['outputs.AzureStaticWebAppsResponse'] = None,
                 custom_open_id_connect_providers: Optional[Mapping[str, 'outputs.CustomOpenIdConnectProviderResponse']] = None,
                 facebook: Optional['outputs.FacebookResponse'] = None,
                 git_hub: Optional['outputs.GitHubResponse'] = None,
                 google: Optional['outputs.GoogleResponse'] = None,
                 twitter: Optional['outputs.TwitterResponse'] = None):
        """
        The configuration settings of each of the identity providers used to configure ContainerApp Service Authentication/Authorization.
        :param 'AppleResponse' apple: The configuration settings of the Apple provider.
        :param 'AzureActiveDirectoryResponse' azure_active_directory: The configuration settings of the Azure Active directory provider.
        :param 'AzureStaticWebAppsResponse' azure_static_web_apps: The configuration settings of the Azure Static Web Apps provider.
        :param Mapping[str, 'CustomOpenIdConnectProviderResponse'] custom_open_id_connect_providers: The map of the name of the alias of each custom Open ID Connect provider to the
               configuration settings of the custom Open ID Connect provider.
        :param 'FacebookResponse' facebook: The configuration settings of the Facebook provider.
        :param 'GitHubResponse' git_hub: The configuration settings of the GitHub provider.
        :param 'GoogleResponse' google: The configuration settings of the Google provider.
        :param 'TwitterResponse' twitter: The configuration settings of the Twitter provider.
        """
        if apple is not None:
            pulumi.set(__self__, "apple", apple)
        if azure_active_directory is not None:
            pulumi.set(__self__, "azure_active_directory", azure_active_directory)
        if azure_static_web_apps is not None:
            pulumi.set(__self__, "azure_static_web_apps", azure_static_web_apps)
        if custom_open_id_connect_providers is not None:
            pulumi.set(__self__, "custom_open_id_connect_providers", custom_open_id_connect_providers)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if git_hub is not None:
            pulumi.set(__self__, "git_hub", git_hub)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)

    @_builtins.property
    @pulumi.getter
    def apple(self) -> Optional['outputs.AppleResponse']:
        """
        The configuration settings of the Apple provider.
        """
        return pulumi.get(self, "apple")

    @_builtins.property
    @pulumi.getter(name="azureActiveDirectory")
    def azure_active_directory(self) -> Optional['outputs.AzureActiveDirectoryResponse']:
        """
        The configuration settings of the Azure Active directory provider.
        """
        return pulumi.get(self, "azure_active_directory")

    @_builtins.property
    @pulumi.getter(name="azureStaticWebApps")
    def azure_static_web_apps(self) -> Optional['outputs.AzureStaticWebAppsResponse']:
        """
        The configuration settings of the Azure Static Web Apps provider.
        """
        return pulumi.get(self, "azure_static_web_apps")

    @_builtins.property
    @pulumi.getter(name="customOpenIdConnectProviders")
    def custom_open_id_connect_providers(self) -> Optional[Mapping[str, 'outputs.CustomOpenIdConnectProviderResponse']]:
        """
        The map of the name of the alias of each custom Open ID Connect provider to the
        configuration settings of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "custom_open_id_connect_providers")

    @_builtins.property
    @pulumi.getter
    def facebook(self) -> Optional['outputs.FacebookResponse']:
        """
        The configuration settings of the Facebook provider.
        """
        return pulumi.get(self, "facebook")

    @_builtins.property
    @pulumi.getter(name="gitHub")
    def git_hub(self) -> Optional['outputs.GitHubResponse']:
        """
        The configuration settings of the GitHub provider.
        """
        return pulumi.get(self, "git_hub")

    @_builtins.property
    @pulumi.getter
    def google(self) -> Optional['outputs.GoogleResponse']:
        """
        The configuration settings of the Google provider.
        """
        return pulumi.get(self, "google")

    @_builtins.property
    @pulumi.getter
    def twitter(self) -> Optional['outputs.TwitterResponse']:
        """
        The configuration settings of the Twitter provider.
        """
        return pulumi.get(self, "twitter")


@pulumi.output_type
class IdentitySettingsResponse(dict):
    """
    Optional settings for a Managed Identity that is assigned to the Container App.
    """
    def __init__(__self__, *,
                 identity: _builtins.str,
                 lifecycle: Optional[_builtins.str] = None):
        """
        Optional settings for a Managed Identity that is assigned to the Container App.
        :param _builtins.str identity: The resource ID of a user-assigned managed identity that is assigned to the Container App, or 'system' for system-assigned identity.
        :param _builtins.str lifecycle: Use to select the lifecycle stages of a Container App during which the Managed Identity should be available.
        """
        pulumi.set(__self__, "identity", identity)
        if lifecycle is None:
            lifecycle = 'All'
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> _builtins.str:
        """
        The resource ID of a user-assigned managed identity that is assigned to the Container App, or 'system' for system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def lifecycle(self) -> Optional[_builtins.str]:
        """
        Use to select the lifecycle stages of a Container App during which the Managed Identity should be available.
        """
        return pulumi.get(self, "lifecycle")


@pulumi.output_type
class IngressConfigurationResponse(dict):
    """
    Settings for the ingress component, including workload profile, scaling, and connection handling.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerCountLimit":
            suggest = "header_count_limit"
        elif key == "requestIdleTimeout":
            suggest = "request_idle_timeout"
        elif key == "terminationGracePeriodSeconds":
            suggest = "termination_grace_period_seconds"
        elif key == "workloadProfileName":
            suggest = "workload_profile_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IngressConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IngressConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IngressConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_count_limit: Optional[_builtins.int] = None,
                 request_idle_timeout: Optional[_builtins.int] = None,
                 scale: Optional['outputs.IngressConfigurationResponseScale'] = None,
                 termination_grace_period_seconds: Optional[_builtins.int] = None,
                 workload_profile_name: Optional[_builtins.str] = None):
        """
        Settings for the ingress component, including workload profile, scaling, and connection handling.
        :param _builtins.int header_count_limit: Maximum number of headers per request allowed by the ingress. Must be at least 1. Defaults to 100.
        :param _builtins.int request_idle_timeout: Duration (in minutes) before idle requests are timed out. Must be at least 1 minute. Defaults to 4 minutes.
        :param 'IngressConfigurationResponseScale' scale: Scaling configuration for the ingress component. Required.
        :param _builtins.int termination_grace_period_seconds: Time (in seconds) to allow active connections to complete on termination. Must be between 0 and 3600. Defaults to 480 seconds.
        :param _builtins.str workload_profile_name: Name of the workload profile used by the ingress component. Required.
        """
        if header_count_limit is not None:
            pulumi.set(__self__, "header_count_limit", header_count_limit)
        if request_idle_timeout is not None:
            pulumi.set(__self__, "request_idle_timeout", request_idle_timeout)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if workload_profile_name is not None:
            pulumi.set(__self__, "workload_profile_name", workload_profile_name)

    @_builtins.property
    @pulumi.getter(name="headerCountLimit")
    def header_count_limit(self) -> Optional[_builtins.int]:
        """
        Maximum number of headers per request allowed by the ingress. Must be at least 1. Defaults to 100.
        """
        return pulumi.get(self, "header_count_limit")

    @_builtins.property
    @pulumi.getter(name="requestIdleTimeout")
    def request_idle_timeout(self) -> Optional[_builtins.int]:
        """
        Duration (in minutes) before idle requests are timed out. Must be at least 1 minute. Defaults to 4 minutes.
        """
        return pulumi.get(self, "request_idle_timeout")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional['outputs.IngressConfigurationResponseScale']:
        """
        Scaling configuration for the ingress component. Required.
        """
        return pulumi.get(self, "scale")

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[_builtins.int]:
        """
        Time (in seconds) to allow active connections to complete on termination. Must be between 0 and 3600. Defaults to 480 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @_builtins.property
    @pulumi.getter(name="workloadProfileName")
    def workload_profile_name(self) -> Optional[_builtins.str]:
        """
        Name of the workload profile used by the ingress component. Required.
        """
        return pulumi.get(self, "workload_profile_name")


@pulumi.output_type
class IngressConfigurationResponseScale(dict):
    """
    Scaling configuration for the ingress component. Required.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IngressConfigurationResponseScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IngressConfigurationResponseScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IngressConfigurationResponseScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_replicas: Optional[_builtins.int] = None,
                 min_replicas: Optional[_builtins.int] = None):
        """
        Scaling configuration for the ingress component. Required.
        :param _builtins.int max_replicas: Maximum number of ingress replicas. Must be greater than or equal to minReplicas.
        :param _builtins.int min_replicas: Minimum number of ingress replicas. Must be at least 2. Required.
        """
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[_builtins.int]:
        """
        Maximum number of ingress replicas. Must be greater than or equal to minReplicas.
        """
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[_builtins.int]:
        """
        Minimum number of ingress replicas. Must be at least 2. Required.
        """
        return pulumi.get(self, "min_replicas")


@pulumi.output_type
class IngressPortMappingResponse(dict):
    """
    Port mappings of container app ingress
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetPort":
            suggest = "target_port"
        elif key == "exposedPort":
            suggest = "exposed_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IngressPortMappingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IngressPortMappingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IngressPortMappingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external: _builtins.bool,
                 target_port: _builtins.int,
                 exposed_port: Optional[_builtins.int] = None):
        """
        Port mappings of container app ingress
        :param _builtins.bool external: Specifies whether the app port is accessible outside of the environment
        :param _builtins.int target_port: Specifies the port user's container listens on
        :param _builtins.int exposed_port: Specifies the exposed port for the target port. If not specified, it defaults to target port
        """
        pulumi.set(__self__, "external", external)
        pulumi.set(__self__, "target_port", target_port)
        if exposed_port is not None:
            pulumi.set(__self__, "exposed_port", exposed_port)

    @_builtins.property
    @pulumi.getter
    def external(self) -> _builtins.bool:
        """
        Specifies whether the app port is accessible outside of the environment
        """
        return pulumi.get(self, "external")

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> _builtins.int:
        """
        Specifies the port user's container listens on
        """
        return pulumi.get(self, "target_port")

    @_builtins.property
    @pulumi.getter(name="exposedPort")
    def exposed_port(self) -> Optional[_builtins.int]:
        """
        Specifies the exposed port for the target port. If not specified, it defaults to target port
        """
        return pulumi.get(self, "exposed_port")


@pulumi.output_type
class IngressResponse(dict):
    """
    Container App Ingress configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalPortMappings":
            suggest = "additional_port_mappings"
        elif key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "clientCertificateMode":
            suggest = "client_certificate_mode"
        elif key == "corsPolicy":
            suggest = "cors_policy"
        elif key == "customDomains":
            suggest = "custom_domains"
        elif key == "exposedPort":
            suggest = "exposed_port"
        elif key == "ipSecurityRestrictions":
            suggest = "ip_security_restrictions"
        elif key == "stickySessions":
            suggest = "sticky_sessions"
        elif key == "targetPort":
            suggest = "target_port"
        elif key == "targetPortHttpScheme":
            suggest = "target_port_http_scheme"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IngressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IngressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IngressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 additional_port_mappings: Optional[Sequence['outputs.IngressPortMappingResponse']] = None,
                 allow_insecure: Optional[_builtins.bool] = None,
                 client_certificate_mode: Optional[_builtins.str] = None,
                 cors_policy: Optional['outputs.CorsPolicyResponse'] = None,
                 custom_domains: Optional[Sequence['outputs.CustomDomainResponse']] = None,
                 exposed_port: Optional[_builtins.int] = None,
                 external: Optional[_builtins.bool] = None,
                 ip_security_restrictions: Optional[Sequence['outputs.IpSecurityRestrictionRuleResponse']] = None,
                 sticky_sessions: Optional['outputs.IngressResponseStickySessions'] = None,
                 target_port: Optional[_builtins.int] = None,
                 target_port_http_scheme: Optional[_builtins.str] = None,
                 traffic: Optional[Sequence['outputs.TrafficWeightResponse']] = None,
                 transport: Optional[_builtins.str] = None):
        """
        Container App Ingress configuration.
        :param _builtins.str fqdn: Hostname.
        :param Sequence['IngressPortMappingResponse'] additional_port_mappings: Settings to expose additional ports on container app
        :param _builtins.bool allow_insecure: Bool indicating if HTTP connections to is allowed. If set to false HTTP connections are automatically redirected to HTTPS connections
        :param _builtins.str client_certificate_mode: Client certificate mode for mTLS authentication. Ignore indicates server drops client certificate on forwarding. Accept indicates server forwards client certificate but does not require a client certificate. Require indicates server requires a client certificate.
        :param 'CorsPolicyResponse' cors_policy: CORS policy for container app
        :param Sequence['CustomDomainResponse'] custom_domains: custom domain bindings for Container Apps' hostnames.
        :param _builtins.int exposed_port: Exposed Port in containers for TCP traffic from ingress
        :param _builtins.bool external: Bool indicating if app exposes an external http endpoint
        :param Sequence['IpSecurityRestrictionRuleResponse'] ip_security_restrictions: Rules to restrict incoming IP address.
        :param 'IngressResponseStickySessions' sticky_sessions: Sticky Sessions for Single Revision Mode
        :param _builtins.int target_port: Target Port in containers for traffic from ingress
        :param _builtins.str target_port_http_scheme: Whether an http app listens on http or https
        :param Sequence['TrafficWeightResponse'] traffic: Traffic weights for app's revisions
        :param _builtins.str transport: Ingress transport protocol
        """
        pulumi.set(__self__, "fqdn", fqdn)
        if additional_port_mappings is not None:
            pulumi.set(__self__, "additional_port_mappings", additional_port_mappings)
        if allow_insecure is None:
            allow_insecure = False
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if client_certificate_mode is not None:
            pulumi.set(__self__, "client_certificate_mode", client_certificate_mode)
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if custom_domains is not None:
            pulumi.set(__self__, "custom_domains", custom_domains)
        if exposed_port is not None:
            pulumi.set(__self__, "exposed_port", exposed_port)
        if external is None:
            external = False
        if external is not None:
            pulumi.set(__self__, "external", external)
        if ip_security_restrictions is not None:
            pulumi.set(__self__, "ip_security_restrictions", ip_security_restrictions)
        if sticky_sessions is not None:
            pulumi.set(__self__, "sticky_sessions", sticky_sessions)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)
        if target_port_http_scheme is not None:
            pulumi.set(__self__, "target_port_http_scheme", target_port_http_scheme)
        if traffic is not None:
            pulumi.set(__self__, "traffic", traffic)
        if transport is None:
            transport = 'auto'
        if transport is not None:
            pulumi.set(__self__, "transport", transport)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        Hostname.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="additionalPortMappings")
    def additional_port_mappings(self) -> Optional[Sequence['outputs.IngressPortMappingResponse']]:
        """
        Settings to expose additional ports on container app
        """
        return pulumi.get(self, "additional_port_mappings")

    @_builtins.property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[_builtins.bool]:
        """
        Bool indicating if HTTP connections to is allowed. If set to false HTTP connections are automatically redirected to HTTPS connections
        """
        return pulumi.get(self, "allow_insecure")

    @_builtins.property
    @pulumi.getter(name="clientCertificateMode")
    def client_certificate_mode(self) -> Optional[_builtins.str]:
        """
        Client certificate mode for mTLS authentication. Ignore indicates server drops client certificate on forwarding. Accept indicates server forwards client certificate but does not require a client certificate. Require indicates server requires a client certificate.
        """
        return pulumi.get(self, "client_certificate_mode")

    @_builtins.property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.CorsPolicyResponse']:
        """
        CORS policy for container app
        """
        return pulumi.get(self, "cors_policy")

    @_builtins.property
    @pulumi.getter(name="customDomains")
    def custom_domains(self) -> Optional[Sequence['outputs.CustomDomainResponse']]:
        """
        custom domain bindings for Container Apps' hostnames.
        """
        return pulumi.get(self, "custom_domains")

    @_builtins.property
    @pulumi.getter(name="exposedPort")
    def exposed_port(self) -> Optional[_builtins.int]:
        """
        Exposed Port in containers for TCP traffic from ingress
        """
        return pulumi.get(self, "exposed_port")

    @_builtins.property
    @pulumi.getter
    def external(self) -> Optional[_builtins.bool]:
        """
        Bool indicating if app exposes an external http endpoint
        """
        return pulumi.get(self, "external")

    @_builtins.property
    @pulumi.getter(name="ipSecurityRestrictions")
    def ip_security_restrictions(self) -> Optional[Sequence['outputs.IpSecurityRestrictionRuleResponse']]:
        """
        Rules to restrict incoming IP address.
        """
        return pulumi.get(self, "ip_security_restrictions")

    @_builtins.property
    @pulumi.getter(name="stickySessions")
    def sticky_sessions(self) -> Optional['outputs.IngressResponseStickySessions']:
        """
        Sticky Sessions for Single Revision Mode
        """
        return pulumi.get(self, "sticky_sessions")

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[_builtins.int]:
        """
        Target Port in containers for traffic from ingress
        """
        return pulumi.get(self, "target_port")

    @_builtins.property
    @pulumi.getter(name="targetPortHttpScheme")
    def target_port_http_scheme(self) -> Optional[_builtins.str]:
        """
        Whether an http app listens on http or https
        """
        return pulumi.get(self, "target_port_http_scheme")

    @_builtins.property
    @pulumi.getter
    def traffic(self) -> Optional[Sequence['outputs.TrafficWeightResponse']]:
        """
        Traffic weights for app's revisions
        """
        return pulumi.get(self, "traffic")

    @_builtins.property
    @pulumi.getter
    def transport(self) -> Optional[_builtins.str]:
        """
        Ingress transport protocol
        """
        return pulumi.get(self, "transport")


@pulumi.output_type
class IngressResponseStickySessions(dict):
    """
    Sticky Sessions for Single Revision Mode
    """
    def __init__(__self__, *,
                 affinity: Optional[_builtins.str] = None):
        """
        Sticky Sessions for Single Revision Mode
        :param _builtins.str affinity: Sticky Session Affinity
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)

    @_builtins.property
    @pulumi.getter
    def affinity(self) -> Optional[_builtins.str]:
        """
        Sticky Session Affinity
        """
        return pulumi.get(self, "affinity")


@pulumi.output_type
class InitContainerResponse(dict):
    """
    Container App init container definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageType":
            suggest = "image_type"
        elif key == "volumeMounts":
            suggest = "volume_mounts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InitContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InitContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InitContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 args: Optional[Sequence[_builtins.str]] = None,
                 command: Optional[Sequence[_builtins.str]] = None,
                 env: Optional[Sequence['outputs.EnvironmentVarResponse']] = None,
                 image: Optional[_builtins.str] = None,
                 image_type: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 resources: Optional['outputs.ContainerResourcesResponse'] = None,
                 volume_mounts: Optional[Sequence['outputs.VolumeMountResponse']] = None):
        """
        Container App init container definition
        :param Sequence[_builtins.str] args: Container start command arguments.
        :param Sequence[_builtins.str] command: Container start command.
        :param Sequence['EnvironmentVarResponse'] env: Container environment variables.
        :param _builtins.str image: Container image tag.
        :param _builtins.str image_type: The type of the image. Set to CloudBuild to let the system manages the image, where user will not be able to update image through image field. Set to ContainerImage for user provided image.
        :param _builtins.str name: Custom container name.
        :param 'ContainerResourcesResponse' resources: Container resource requirements.
        :param Sequence['VolumeMountResponse'] volume_mounts: Container volume mounts.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if image_type is not None:
            pulumi.set(__self__, "image_type", image_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[Sequence[_builtins.str]]:
        """
        Container start command arguments.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[Sequence[_builtins.str]]:
        """
        Container start command.
        """
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.EnvironmentVarResponse']]:
        """
        Container environment variables.
        """
        return pulumi.get(self, "env")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Container image tag.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="imageType")
    def image_type(self) -> Optional[_builtins.str]:
        """
        The type of the image. Set to CloudBuild to let the system manages the image, where user will not be able to update image through image field. Set to ContainerImage for user provided image.
        """
        return pulumi.get(self, "image_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Custom container name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional['outputs.ContainerResourcesResponse']:
        """
        Container resource requirements.
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[Sequence['outputs.VolumeMountResponse']]:
        """
        Container volume mounts.
        """
        return pulumi.get(self, "volume_mounts")


@pulumi.output_type
class IpSecurityRestrictionRuleResponse(dict):
    """
    Rule to restrict incoming IP address.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddressRange":
            suggest = "ip_address_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpSecurityRestrictionRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpSecurityRestrictionRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpSecurityRestrictionRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 ip_address_range: _builtins.str,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        Rule to restrict incoming IP address.
        :param _builtins.str action: Allow or Deny rules to determine for incoming IP. Note: Rules can only consist of ALL Allow or ALL Deny
        :param _builtins.str ip_address_range: CIDR notation to match incoming IP address
        :param _builtins.str name: Name for the IP restriction rule.
        :param _builtins.str description: Describe the IP restriction rule that is being sent to the container-app. This is an optional field.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "ip_address_range", ip_address_range)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Allow or Deny rules to determine for incoming IP. Note: Rules can only consist of ALL Allow or ALL Deny
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="ipAddressRange")
    def ip_address_range(self) -> _builtins.str:
        """
        CIDR notation to match incoming IP address
        """
        return pulumi.get(self, "ip_address_range")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name for the IP restriction rule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Describe the IP restriction rule that is being sent to the container-app. This is an optional field.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class JavaComponentConfigurationPropertyResponse(dict):
    """
    Configuration properties for a Java Component
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertyName":
            suggest = "property_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JavaComponentConfigurationPropertyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JavaComponentConfigurationPropertyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JavaComponentConfigurationPropertyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 property_name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        Configuration properties for a Java Component
        :param _builtins.str property_name: The name of the property
        :param _builtins.str value: The value of the property
        """
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[_builtins.str]:
        """
        The name of the property
        """
        return pulumi.get(self, "property_name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the property
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class JavaComponentIngressResponse(dict):
    """
    Container App Ingress configuration.
    """
    def __init__(__self__, *,
                 fqdn: _builtins.str):
        """
        Container App Ingress configuration.
        :param _builtins.str fqdn: Hostname of the Java Component endpoint
        """
        pulumi.set(__self__, "fqdn", fqdn)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        Hostname of the Java Component endpoint
        """
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class JavaComponentPropertiesResponseScale(dict):
    """
    Java component scaling configurations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JavaComponentPropertiesResponseScale. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JavaComponentPropertiesResponseScale.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JavaComponentPropertiesResponseScale.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_replicas: Optional[_builtins.int] = None,
                 min_replicas: Optional[_builtins.int] = None):
        """
        Java component scaling configurations
        :param _builtins.int max_replicas: Optional. Maximum number of Java component replicas
        :param _builtins.int min_replicas: Optional. Minimum number of Java component replicas. Defaults to 1 if not set
        """
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[_builtins.int]:
        """
        Optional. Maximum number of Java component replicas
        """
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[_builtins.int]:
        """
        Optional. Minimum number of Java component replicas. Defaults to 1 if not set
        """
        return pulumi.get(self, "min_replicas")


@pulumi.output_type
class JavaComponentServiceBindResponse(dict):
    """
    Configuration to bind a Java Component to another Java Component
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JavaComponentServiceBindResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JavaComponentServiceBindResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JavaComponentServiceBindResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 service_id: Optional[_builtins.str] = None):
        """
        Configuration to bind a Java Component to another Java Component
        :param _builtins.str name: Name of the service bind
        :param _builtins.str service_id: Resource id of the target service
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the service bind
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[_builtins.str]:
        """
        Resource id of the target service
        """
        return pulumi.get(self, "service_id")


@pulumi.output_type
class JobConfigurationResponse(dict):
    """
    Non versioned Container Apps Job configuration properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicaTimeout":
            suggest = "replica_timeout"
        elif key == "triggerType":
            suggest = "trigger_type"
        elif key == "eventTriggerConfig":
            suggest = "event_trigger_config"
        elif key == "identitySettings":
            suggest = "identity_settings"
        elif key == "manualTriggerConfig":
            suggest = "manual_trigger_config"
        elif key == "replicaRetryLimit":
            suggest = "replica_retry_limit"
        elif key == "scheduleTriggerConfig":
            suggest = "schedule_trigger_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replica_timeout: _builtins.int,
                 trigger_type: Optional[_builtins.str] = None,
                 event_trigger_config: Optional['outputs.JobConfigurationResponseEventTriggerConfig'] = None,
                 identity_settings: Optional[Sequence['outputs.IdentitySettingsResponse']] = None,
                 manual_trigger_config: Optional['outputs.JobConfigurationResponseManualTriggerConfig'] = None,
                 registries: Optional[Sequence['outputs.RegistryCredentialsResponse']] = None,
                 replica_retry_limit: Optional[_builtins.int] = None,
                 schedule_trigger_config: Optional['outputs.JobConfigurationResponseScheduleTriggerConfig'] = None,
                 secrets: Optional[Sequence['outputs.SecretResponse']] = None):
        """
        Non versioned Container Apps Job configuration properties
        :param _builtins.int replica_timeout: Maximum number of seconds a replica is allowed to run.
        :param _builtins.str trigger_type: Trigger type of the job
        :param 'JobConfigurationResponseEventTriggerConfig' event_trigger_config: Trigger configuration of an event driven job.
        :param Sequence['IdentitySettingsResponse'] identity_settings: Optional settings for Managed Identities that are assigned to the Container App Job. If a Managed Identity is not specified here, default settings will be used.
        :param 'JobConfigurationResponseManualTriggerConfig' manual_trigger_config: Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        :param Sequence['RegistryCredentialsResponse'] registries: Collection of private container registry credentials used by a Container apps job
        :param _builtins.int replica_retry_limit: Maximum number of retries before failing the job.
        :param 'JobConfigurationResponseScheduleTriggerConfig' schedule_trigger_config: Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        :param Sequence['SecretResponse'] secrets: Collection of secrets used by a Container Apps Job
        """
        pulumi.set(__self__, "replica_timeout", replica_timeout)
        if trigger_type is None:
            trigger_type = 'Manual'
        pulumi.set(__self__, "trigger_type", trigger_type)
        if event_trigger_config is not None:
            pulumi.set(__self__, "event_trigger_config", event_trigger_config)
        if identity_settings is not None:
            pulumi.set(__self__, "identity_settings", identity_settings)
        if manual_trigger_config is not None:
            pulumi.set(__self__, "manual_trigger_config", manual_trigger_config)
        if registries is not None:
            pulumi.set(__self__, "registries", registries)
        if replica_retry_limit is not None:
            pulumi.set(__self__, "replica_retry_limit", replica_retry_limit)
        if schedule_trigger_config is not None:
            pulumi.set(__self__, "schedule_trigger_config", schedule_trigger_config)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter(name="replicaTimeout")
    def replica_timeout(self) -> _builtins.int:
        """
        Maximum number of seconds a replica is allowed to run.
        """
        return pulumi.get(self, "replica_timeout")

    @_builtins.property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> _builtins.str:
        """
        Trigger type of the job
        """
        return pulumi.get(self, "trigger_type")

    @_builtins.property
    @pulumi.getter(name="eventTriggerConfig")
    def event_trigger_config(self) -> Optional['outputs.JobConfigurationResponseEventTriggerConfig']:
        """
        Trigger configuration of an event driven job.
        """
        return pulumi.get(self, "event_trigger_config")

    @_builtins.property
    @pulumi.getter(name="identitySettings")
    def identity_settings(self) -> Optional[Sequence['outputs.IdentitySettingsResponse']]:
        """
        Optional settings for Managed Identities that are assigned to the Container App Job. If a Managed Identity is not specified here, default settings will be used.
        """
        return pulumi.get(self, "identity_settings")

    @_builtins.property
    @pulumi.getter(name="manualTriggerConfig")
    def manual_trigger_config(self) -> Optional['outputs.JobConfigurationResponseManualTriggerConfig']:
        """
        Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        """
        return pulumi.get(self, "manual_trigger_config")

    @_builtins.property
    @pulumi.getter
    def registries(self) -> Optional[Sequence['outputs.RegistryCredentialsResponse']]:
        """
        Collection of private container registry credentials used by a Container apps job
        """
        return pulumi.get(self, "registries")

    @_builtins.property
    @pulumi.getter(name="replicaRetryLimit")
    def replica_retry_limit(self) -> Optional[_builtins.int]:
        """
        Maximum number of retries before failing the job.
        """
        return pulumi.get(self, "replica_retry_limit")

    @_builtins.property
    @pulumi.getter(name="scheduleTriggerConfig")
    def schedule_trigger_config(self) -> Optional['outputs.JobConfigurationResponseScheduleTriggerConfig']:
        """
        Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        """
        return pulumi.get(self, "schedule_trigger_config")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.SecretResponse']]:
        """
        Collection of secrets used by a Container Apps Job
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class JobConfigurationResponseEventTriggerConfig(dict):
    """
    Trigger configuration of an event driven job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicaCompletionCount":
            suggest = "replica_completion_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobConfigurationResponseEventTriggerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobConfigurationResponseEventTriggerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobConfigurationResponseEventTriggerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parallelism: Optional[_builtins.int] = None,
                 replica_completion_count: Optional[_builtins.int] = None,
                 scale: Optional['outputs.JobScaleResponse'] = None):
        """
        Trigger configuration of an event driven job.
        :param _builtins.int parallelism: Number of parallel replicas of a job that can run at a given time.
        :param _builtins.int replica_completion_count: Minimum number of successful replica completions before overall job completion.
        :param 'JobScaleResponse' scale: Scaling configurations for event driven jobs.
        """
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if replica_completion_count is not None:
            pulumi.set(__self__, "replica_completion_count", replica_completion_count)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @_builtins.property
    @pulumi.getter
    def parallelism(self) -> Optional[_builtins.int]:
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        return pulumi.get(self, "parallelism")

    @_builtins.property
    @pulumi.getter(name="replicaCompletionCount")
    def replica_completion_count(self) -> Optional[_builtins.int]:
        """
        Minimum number of successful replica completions before overall job completion.
        """
        return pulumi.get(self, "replica_completion_count")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional['outputs.JobScaleResponse']:
        """
        Scaling configurations for event driven jobs.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class JobConfigurationResponseManualTriggerConfig(dict):
    """
    Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicaCompletionCount":
            suggest = "replica_completion_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobConfigurationResponseManualTriggerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobConfigurationResponseManualTriggerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobConfigurationResponseManualTriggerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parallelism: Optional[_builtins.int] = None,
                 replica_completion_count: Optional[_builtins.int] = None):
        """
        Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        :param _builtins.int parallelism: Number of parallel replicas of a job that can run at a given time.
        :param _builtins.int replica_completion_count: Minimum number of successful replica completions before overall job completion.
        """
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if replica_completion_count is not None:
            pulumi.set(__self__, "replica_completion_count", replica_completion_count)

    @_builtins.property
    @pulumi.getter
    def parallelism(self) -> Optional[_builtins.int]:
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        return pulumi.get(self, "parallelism")

    @_builtins.property
    @pulumi.getter(name="replicaCompletionCount")
    def replica_completion_count(self) -> Optional[_builtins.int]:
        """
        Minimum number of successful replica completions before overall job completion.
        """
        return pulumi.get(self, "replica_completion_count")


@pulumi.output_type
class JobConfigurationResponseScheduleTriggerConfig(dict):
    """
    Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "replicaCompletionCount":
            suggest = "replica_completion_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobConfigurationResponseScheduleTriggerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobConfigurationResponseScheduleTriggerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobConfigurationResponseScheduleTriggerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: _builtins.str,
                 parallelism: Optional[_builtins.int] = None,
                 replica_completion_count: Optional[_builtins.int] = None):
        """
        Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        :param _builtins.str cron_expression: Cron formatted repeating schedule ("* * * * *") of a Cron Job.
        :param _builtins.int parallelism: Number of parallel replicas of a job that can run at a given time.
        :param _builtins.int replica_completion_count: Minimum number of successful replica completions before overall job completion.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if replica_completion_count is not None:
            pulumi.set(__self__, "replica_completion_count", replica_completion_count)

    @_builtins.property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> _builtins.str:
        """
        Cron formatted repeating schedule ("* * * * *") of a Cron Job.
        """
        return pulumi.get(self, "cron_expression")

    @_builtins.property
    @pulumi.getter
    def parallelism(self) -> Optional[_builtins.int]:
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        return pulumi.get(self, "parallelism")

    @_builtins.property
    @pulumi.getter(name="replicaCompletionCount")
    def replica_completion_count(self) -> Optional[_builtins.int]:
        """
        Minimum number of successful replica completions before overall job completion.
        """
        return pulumi.get(self, "replica_completion_count")


@pulumi.output_type
class JobScaleResponse(dict):
    """
    Scaling configurations for event driven jobs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxExecutions":
            suggest = "max_executions"
        elif key == "minExecutions":
            suggest = "min_executions"
        elif key == "pollingInterval":
            suggest = "polling_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobScaleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobScaleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobScaleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_executions: Optional[_builtins.int] = None,
                 min_executions: Optional[_builtins.int] = None,
                 polling_interval: Optional[_builtins.int] = None,
                 rules: Optional[Sequence['outputs.JobScaleRuleResponse']] = None):
        """
        Scaling configurations for event driven jobs.
        :param _builtins.int max_executions: Maximum number of job executions that are created for a trigger, default 100.
        :param _builtins.int min_executions: Minimum number of job executions that are created for a trigger, default 0
        :param _builtins.int polling_interval: Interval to check each event source in seconds. Defaults to 30s
        :param Sequence['JobScaleRuleResponse'] rules: Scaling rules.
        """
        if max_executions is None:
            max_executions = 100
        if max_executions is not None:
            pulumi.set(__self__, "max_executions", max_executions)
        if min_executions is None:
            min_executions = 0
        if min_executions is not None:
            pulumi.set(__self__, "min_executions", min_executions)
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="maxExecutions")
    def max_executions(self) -> Optional[_builtins.int]:
        """
        Maximum number of job executions that are created for a trigger, default 100.
        """
        return pulumi.get(self, "max_executions")

    @_builtins.property
    @pulumi.getter(name="minExecutions")
    def min_executions(self) -> Optional[_builtins.int]:
        """
        Minimum number of job executions that are created for a trigger, default 0
        """
        return pulumi.get(self, "min_executions")

    @_builtins.property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[_builtins.int]:
        """
        Interval to check each event source in seconds. Defaults to 30s
        """
        return pulumi.get(self, "polling_interval")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.JobScaleRuleResponse']]:
        """
        Scaling rules.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class JobScaleRuleResponse(dict):
    """
    Scaling rule.
    """
    def __init__(__self__, *,
                 auth: Optional[Sequence['outputs.ScaleRuleAuthResponse']] = None,
                 identity: Optional[_builtins.str] = None,
                 metadata: Optional[Any] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Scaling rule.
        :param Sequence['ScaleRuleAuthResponse'] auth: Authentication secrets for the scale rule.
        :param _builtins.str identity: The resource ID of a user-assigned managed identity that is assigned to the job, or 'system' for system-assigned identity.
        :param Any metadata: Metadata properties to describe the scale rule.
        :param _builtins.str name: Scale Rule Name
        :param _builtins.str type: Type of the scale rule
               eg: azure-servicebus, redis etc.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[Sequence['outputs.ScaleRuleAuthResponse']]:
        """
        Authentication secrets for the scale rule.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        The resource ID of a user-assigned managed identity that is assigned to the job, or 'system' for system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Any]:
        """
        Metadata properties to describe the scale rule.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Scale Rule Name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the scale rule
        eg: azure-servicebus, redis etc.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class JobTemplateResponse(dict):
    """
    Container Apps Job versioned application definition. Defines the desired state of an immutable revision. Any changes to this section Will result in a new revision being created
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initContainers":
            suggest = "init_containers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTemplateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTemplateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTemplateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 containers: Optional[Sequence['outputs.ContainerResponse']] = None,
                 init_containers: Optional[Sequence['outputs.InitContainerResponse']] = None,
                 volumes: Optional[Sequence['outputs.VolumeResponse']] = None):
        """
        Container Apps Job versioned application definition. Defines the desired state of an immutable revision. Any changes to this section Will result in a new revision being created
        :param Sequence['ContainerResponse'] containers: List of container definitions for the Container App.
        :param Sequence['InitContainerResponse'] init_containers: List of specialized containers that run before app containers.
        :param Sequence['VolumeResponse'] volumes: List of volume definitions for the Container App.
        """
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if init_containers is not None:
            pulumi.set(__self__, "init_containers", init_containers)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def containers(self) -> Optional[Sequence['outputs.ContainerResponse']]:
        """
        List of container definitions for the Container App.
        """
        return pulumi.get(self, "containers")

    @_builtins.property
    @pulumi.getter(name="initContainers")
    def init_containers(self) -> Optional[Sequence['outputs.InitContainerResponse']]:
        """
        List of specialized containers that run before app containers.
        """
        return pulumi.get(self, "init_containers")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.VolumeResponse']]:
        """
        List of volume definitions for the Container App.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class JwtClaimChecksResponse(dict):
    """
    The configuration settings of the checks that should be made while validating the JWT Claims.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedClientApplications":
            suggest = "allowed_client_applications"
        elif key == "allowedGroups":
            suggest = "allowed_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JwtClaimChecksResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JwtClaimChecksResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JwtClaimChecksResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_client_applications: Optional[Sequence[_builtins.str]] = None,
                 allowed_groups: Optional[Sequence[_builtins.str]] = None):
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        :param Sequence[_builtins.str] allowed_client_applications: The list of the allowed client applications.
        :param Sequence[_builtins.str] allowed_groups: The list of the allowed groups.
        """
        if allowed_client_applications is not None:
            pulumi.set(__self__, "allowed_client_applications", allowed_client_applications)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)

    @_builtins.property
    @pulumi.getter(name="allowedClientApplications")
    def allowed_client_applications(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of the allowed client applications.
        """
        return pulumi.get(self, "allowed_client_applications")

    @_builtins.property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of the allowed groups.
        """
        return pulumi.get(self, "allowed_groups")


@pulumi.output_type
class KedaConfigurationResponse(dict):
    """
    Configuration properties Keda component
    """
    def __init__(__self__, *,
                 version: _builtins.str):
        """
        Configuration properties Keda component
        :param _builtins.str version: The version of Keda
        """
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version of Keda
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class LifecycleConfigurationResponse(dict):
    """
    The lifecycle configuration properties of a session in the dynamic session pool
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cooldownPeriodInSeconds":
            suggest = "cooldown_period_in_seconds"
        elif key == "lifecycleType":
            suggest = "lifecycle_type"
        elif key == "maxAlivePeriodInSeconds":
            suggest = "max_alive_period_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LifecycleConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LifecycleConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LifecycleConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cooldown_period_in_seconds: Optional[_builtins.int] = None,
                 lifecycle_type: Optional[_builtins.str] = None,
                 max_alive_period_in_seconds: Optional[_builtins.int] = None):
        """
        The lifecycle configuration properties of a session in the dynamic session pool
        :param _builtins.int cooldown_period_in_seconds: The cooldown period of a session in seconds when the lifecycle type is 'Timed'.
        :param _builtins.str lifecycle_type: The lifecycle type of the session pool.
        :param _builtins.int max_alive_period_in_seconds: The maximum alive period of a session in seconds when the lifecycle type is 'OnContainerExit'.
        """
        if cooldown_period_in_seconds is not None:
            pulumi.set(__self__, "cooldown_period_in_seconds", cooldown_period_in_seconds)
        if lifecycle_type is not None:
            pulumi.set(__self__, "lifecycle_type", lifecycle_type)
        if max_alive_period_in_seconds is not None:
            pulumi.set(__self__, "max_alive_period_in_seconds", max_alive_period_in_seconds)

    @_builtins.property
    @pulumi.getter(name="cooldownPeriodInSeconds")
    def cooldown_period_in_seconds(self) -> Optional[_builtins.int]:
        """
        The cooldown period of a session in seconds when the lifecycle type is 'Timed'.
        """
        return pulumi.get(self, "cooldown_period_in_seconds")

    @_builtins.property
    @pulumi.getter(name="lifecycleType")
    def lifecycle_type(self) -> Optional[_builtins.str]:
        """
        The lifecycle type of the session pool.
        """
        return pulumi.get(self, "lifecycle_type")

    @_builtins.property
    @pulumi.getter(name="maxAlivePeriodInSeconds")
    def max_alive_period_in_seconds(self) -> Optional[_builtins.int]:
        """
        The maximum alive period of a session in seconds when the lifecycle type is 'OnContainerExit'.
        """
        return pulumi.get(self, "max_alive_period_in_seconds")


@pulumi.output_type
class LogAnalyticsConfigurationResponse(dict):
    """
    Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerId":
            suggest = "customer_id"
        elif key == "dynamicJsonColumns":
            suggest = "dynamic_json_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogAnalyticsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogAnalyticsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogAnalyticsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_id: Optional[_builtins.str] = None,
                 dynamic_json_columns: Optional[_builtins.bool] = None):
        """
        Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
        :param _builtins.str customer_id: Log analytics customer id
        :param _builtins.bool dynamic_json_columns: Boolean indicating whether to parse json string log into dynamic json columns
        """
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)
        if dynamic_json_columns is not None:
            pulumi.set(__self__, "dynamic_json_columns", dynamic_json_columns)

    @_builtins.property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[_builtins.str]:
        """
        Log analytics customer id
        """
        return pulumi.get(self, "customer_id")

    @_builtins.property
    @pulumi.getter(name="dynamicJsonColumns")
    def dynamic_json_columns(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating whether to parse json string log into dynamic json columns
        """
        return pulumi.get(self, "dynamic_json_columns")


@pulumi.output_type
class LoggerSettingResponse(dict):
    """
    Logger settings for java workloads.
    """
    def __init__(__self__, *,
                 level: _builtins.str,
                 logger: _builtins.str):
        """
        Logger settings for java workloads.
        :param _builtins.str level: The specified logger's log level.
        :param _builtins.str logger: Logger name.
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "logger", logger)

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        """
        The specified logger's log level.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def logger(self) -> _builtins.str:
        """
        Logger name.
        """
        return pulumi.get(self, "logger")


@pulumi.output_type
class LoginResponse(dict):
    """
    The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedExternalRedirectUrls":
            suggest = "allowed_external_redirect_urls"
        elif key == "cookieExpiration":
            suggest = "cookie_expiration"
        elif key == "preserveUrlFragmentsForLogins":
            suggest = "preserve_url_fragments_for_logins"
        elif key == "tokenStore":
            suggest = "token_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoginResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoginResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoginResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[Sequence[_builtins.str]] = None,
                 cookie_expiration: Optional['outputs.CookieExpirationResponse'] = None,
                 nonce: Optional['outputs.NonceResponse'] = None,
                 preserve_url_fragments_for_logins: Optional[_builtins.bool] = None,
                 routes: Optional['outputs.LoginRoutesResponse'] = None,
                 token_store: Optional['outputs.TokenStoreResponse'] = None):
        """
        The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
        :param Sequence[_builtins.str] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
               This is an advanced setting typically only needed by Windows Store application backends.
               Note that URLs within the current domain are always implicitly allowed.
        :param 'CookieExpirationResponse' cookie_expiration: The configuration settings of the session cookie's expiration.
        :param 'NonceResponse' nonce: The configuration settings of the nonce used in the login flow.
        :param _builtins.bool preserve_url_fragments_for_logins: <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        :param 'LoginRoutesResponse' routes: The routes that specify the endpoints used for login and logout requests.
        :param 'TokenStoreResponse' token_store: The configuration settings of the token store.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration is not None:
            pulumi.set(__self__, "cookie_expiration", cookie_expiration)
        if nonce is not None:
            pulumi.set(__self__, "nonce", nonce)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if token_store is not None:
            pulumi.set(__self__, "token_store", token_store)

    @_builtins.property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
        This is an advanced setting typically only needed by Windows Store application backends.
        Note that URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @_builtins.property
    @pulumi.getter(name="cookieExpiration")
    def cookie_expiration(self) -> Optional['outputs.CookieExpirationResponse']:
        """
        The configuration settings of the session cookie's expiration.
        """
        return pulumi.get(self, "cookie_expiration")

    @_builtins.property
    @pulumi.getter
    def nonce(self) -> Optional['outputs.NonceResponse']:
        """
        The configuration settings of the nonce used in the login flow.
        """
        return pulumi.get(self, "nonce")

    @_builtins.property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[_builtins.bool]:
        """
        <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @_builtins.property
    @pulumi.getter
    def routes(self) -> Optional['outputs.LoginRoutesResponse']:
        """
        The routes that specify the endpoints used for login and logout requests.
        """
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter(name="tokenStore")
    def token_store(self) -> Optional['outputs.TokenStoreResponse']:
        """
        The configuration settings of the token store.
        """
        return pulumi.get(self, "token_store")


@pulumi.output_type
class LoginRoutesResponse(dict):
    """
    The routes that specify the endpoints used for login and logout requests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logoutEndpoint":
            suggest = "logout_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoginRoutesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoginRoutesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoginRoutesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logout_endpoint: Optional[_builtins.str] = None):
        """
        The routes that specify the endpoints used for login and logout requests.
        :param _builtins.str logout_endpoint: The endpoint at which a logout request should be made.
        """
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)

    @_builtins.property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[_builtins.str]:
        """
        The endpoint at which a logout request should be made.
        """
        return pulumi.get(self, "logout_endpoint")


@pulumi.output_type
class LoginScopesResponse(dict):
    """
    The configuration settings of the login flow, including the scopes that should be requested.
    """
    def __init__(__self__, *,
                 scopes: Optional[Sequence[_builtins.str]] = None):
        """
        The configuration settings of the login flow, including the scopes that should be requested.
        :param Sequence[_builtins.str] scopes: A list of the scopes that should be requested while authenticating.
        """
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class LogsConfigurationResponse(dict):
    """
    Configuration of Open Telemetry logs
    """
    def __init__(__self__, *,
                 destinations: Optional[Sequence[_builtins.str]] = None):
        """
        Configuration of Open Telemetry logs
        :param Sequence[_builtins.str] destinations: Open telemetry logs destinations
        """
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence[_builtins.str]]:
        """
        Open telemetry logs destinations
        """
        return pulumi.get(self, "destinations")


@pulumi.output_type
class ManagedCertificateResponseProperties(dict):
    """
    Certificate resource specific properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "validationToken":
            suggest = "validation_token"
        elif key == "domainControlValidation":
            suggest = "domain_control_validation"
        elif key == "subjectName":
            suggest = "subject_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedCertificateResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedCertificateResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedCertificateResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: _builtins.str,
                 provisioning_state: _builtins.str,
                 validation_token: _builtins.str,
                 domain_control_validation: Optional[_builtins.str] = None,
                 subject_name: Optional[_builtins.str] = None):
        """
        Certificate resource specific properties
        :param _builtins.str error: Any error occurred during the certificate provision.
        :param _builtins.str provisioning_state: Provisioning state of the certificate.
        :param _builtins.str validation_token: A TXT token used for DNS TXT domain control validation when issuing this type of managed certificates.
        :param _builtins.str domain_control_validation: Selected type of domain control validation for managed certificates.
        :param _builtins.str subject_name: Subject name of the certificate.
        """
        pulumi.set(__self__, "error", error)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "validation_token", validation_token)
        if domain_control_validation is not None:
            pulumi.set(__self__, "domain_control_validation", domain_control_validation)
        if subject_name is not None:
            pulumi.set(__self__, "subject_name", subject_name)

    @_builtins.property
    @pulumi.getter
    def error(self) -> _builtins.str:
        """
        Any error occurred during the certificate provision.
        """
        return pulumi.get(self, "error")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the certificate.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="validationToken")
    def validation_token(self) -> _builtins.str:
        """
        A TXT token used for DNS TXT domain control validation when issuing this type of managed certificates.
        """
        return pulumi.get(self, "validation_token")

    @_builtins.property
    @pulumi.getter(name="domainControlValidation")
    def domain_control_validation(self) -> Optional[_builtins.str]:
        """
        Selected type of domain control validation for managed certificates.
        """
        return pulumi.get(self, "domain_control_validation")

    @_builtins.property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> Optional[_builtins.str]:
        """
        Subject name of the certificate.
        """
        return pulumi.get(self, "subject_name")


@pulumi.output_type
class ManagedEnvironmentResponseEncryption(dict):
    """
    Peer traffic encryption settings for the Managed Environment
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        Peer traffic encryption settings for the Managed Environment
        :param _builtins.bool enabled: Boolean indicating whether the peer traffic encryption is enabled
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating whether the peer traffic encryption is enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ManagedEnvironmentResponsePeerAuthentication(dict):
    """
    Peer authentication settings for the Managed Environment
    """
    def __init__(__self__, *,
                 mtls: Optional['outputs.MtlsResponse'] = None):
        """
        Peer authentication settings for the Managed Environment
        :param 'MtlsResponse' mtls: Mutual TLS authentication settings for the Managed Environment
        """
        if mtls is not None:
            pulumi.set(__self__, "mtls", mtls)

    @_builtins.property
    @pulumi.getter
    def mtls(self) -> Optional['outputs.MtlsResponse']:
        """
        Mutual TLS authentication settings for the Managed Environment
        """
        return pulumi.get(self, "mtls")


@pulumi.output_type
class ManagedEnvironmentResponsePeerTrafficConfiguration(dict):
    """
    Peer traffic settings for the Managed Environment
    """
    def __init__(__self__, *,
                 encryption: Optional['outputs.ManagedEnvironmentResponseEncryption'] = None):
        """
        Peer traffic settings for the Managed Environment
        :param 'ManagedEnvironmentResponseEncryption' encryption: Peer traffic encryption settings for the Managed Environment
        """
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)

    @_builtins.property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.ManagedEnvironmentResponseEncryption']:
        """
        Peer traffic encryption settings for the Managed Environment
        """
        return pulumi.get(self, "encryption")


@pulumi.output_type
class ManagedEnvironmentStorageResponseProperties(dict):
    """
    Storage properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureFile":
            suggest = "azure_file"
        elif key == "nfsAzureFile":
            suggest = "nfs_azure_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedEnvironmentStorageResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedEnvironmentStorageResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedEnvironmentStorageResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_file: Optional['outputs.AzureFilePropertiesResponse'] = None,
                 nfs_azure_file: Optional['outputs.NfsAzureFilePropertiesResponse'] = None):
        """
        Storage properties
        :param 'AzureFilePropertiesResponse' azure_file: Azure file properties
        :param 'NfsAzureFilePropertiesResponse' nfs_azure_file: NFS Azure file properties
        """
        if azure_file is not None:
            pulumi.set(__self__, "azure_file", azure_file)
        if nfs_azure_file is not None:
            pulumi.set(__self__, "nfs_azure_file", nfs_azure_file)

    @_builtins.property
    @pulumi.getter(name="azureFile")
    def azure_file(self) -> Optional['outputs.AzureFilePropertiesResponse']:
        """
        Azure file properties
        """
        return pulumi.get(self, "azure_file")

    @_builtins.property
    @pulumi.getter(name="nfsAzureFile")
    def nfs_azure_file(self) -> Optional['outputs.NfsAzureFilePropertiesResponse']:
        """
        NFS Azure file properties
        """
        return pulumi.get(self, "nfs_azure_file")


@pulumi.output_type
class ManagedIdentitySettingResponse(dict):
    """
    Optional settings for a Managed Identity that is assigned to the Session pool.
    """
    def __init__(__self__, *,
                 identity: _builtins.str,
                 lifecycle: Optional[_builtins.str] = None):
        """
        Optional settings for a Managed Identity that is assigned to the Session pool.
        :param _builtins.str identity: The resource ID of a user-assigned managed identity that is assigned to the Session Pool, or 'system' for system-assigned identity.
        :param _builtins.str lifecycle: Use to select the lifecycle stages of a Session Pool during which the Managed Identity should be available.
        """
        pulumi.set(__self__, "identity", identity)
        if lifecycle is None:
            lifecycle = 'None'
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> _builtins.str:
        """
        The resource ID of a user-assigned managed identity that is assigned to the Session Pool, or 'system' for system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def lifecycle(self) -> Optional[_builtins.str]:
        """
        Use to select the lifecycle stages of a Session Pool during which the Managed Identity should be available.
        """
        return pulumi.get(self, "lifecycle")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: _builtins.str,
                 tenant_id: _builtins.str,
                 type: _builtins.str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param _builtins.str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param _builtins.str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class MetricsConfigurationResponse(dict):
    """
    Configuration of Open Telemetry metrics
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeKeda":
            suggest = "include_keda"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destinations: Optional[Sequence[_builtins.str]] = None,
                 include_keda: Optional[_builtins.bool] = None):
        """
        Configuration of Open Telemetry metrics
        :param Sequence[_builtins.str] destinations: Open telemetry metrics destinations
        :param _builtins.bool include_keda: Boolean indicating if including keda metrics
        """
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if include_keda is not None:
            pulumi.set(__self__, "include_keda", include_keda)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence[_builtins.str]]:
        """
        Open telemetry metrics destinations
        """
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter(name="includeKeda")
    def include_keda(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating if including keda metrics
        """
        return pulumi.get(self, "include_keda")


@pulumi.output_type
class MtlsResponse(dict):
    """
    Configuration properties for mutual TLS authentication
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        Configuration properties for mutual TLS authentication
        :param _builtins.bool enabled: Boolean indicating whether the mutual TLS authentication is enabled
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating whether the mutual TLS authentication is enabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class NacosComponentResponse(dict):
    """
    Nacos properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentType":
            suggest = "component_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "serviceBinds":
            suggest = "service_binds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NacosComponentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NacosComponentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NacosComponentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_type: _builtins.str,
                 provisioning_state: _builtins.str,
                 configurations: Optional[Sequence['outputs.JavaComponentConfigurationPropertyResponse']] = None,
                 ingress: Optional['outputs.JavaComponentIngressResponse'] = None,
                 scale: Optional['outputs.JavaComponentPropertiesResponseScale'] = None,
                 service_binds: Optional[Sequence['outputs.JavaComponentServiceBindResponse']] = None):
        """
        Nacos properties.
        :param _builtins.str component_type: Type of the Java Component.
               Expected value is 'Nacos'.
        :param _builtins.str provisioning_state: Provisioning state of the Java Component.
        :param Sequence['JavaComponentConfigurationPropertyResponse'] configurations: List of Java Components configuration properties
        :param 'JavaComponentIngressResponse' ingress: Java Component Ingress configurations.
        :param 'JavaComponentPropertiesResponseScale' scale: Java component scaling configurations
        :param Sequence['JavaComponentServiceBindResponse'] service_binds: List of Java Components that are bound to the Java component
        """
        pulumi.set(__self__, "component_type", 'Nacos')
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if service_binds is not None:
            pulumi.set(__self__, "service_binds", service_binds)

    @_builtins.property
    @pulumi.getter(name="componentType")
    def component_type(self) -> _builtins.str:
        """
        Type of the Java Component.
        Expected value is 'Nacos'.
        """
        return pulumi.get(self, "component_type")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the Java Component.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.JavaComponentConfigurationPropertyResponse']]:
        """
        List of Java Components configuration properties
        """
        return pulumi.get(self, "configurations")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> Optional['outputs.JavaComponentIngressResponse']:
        """
        Java Component Ingress configurations.
        """
        return pulumi.get(self, "ingress")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional['outputs.JavaComponentPropertiesResponseScale']:
        """
        Java component scaling configurations
        """
        return pulumi.get(self, "scale")

    @_builtins.property
    @pulumi.getter(name="serviceBinds")
    def service_binds(self) -> Optional[Sequence['outputs.JavaComponentServiceBindResponse']]:
        """
        List of Java Components that are bound to the Java component
        """
        return pulumi.get(self, "service_binds")


@pulumi.output_type
class NfsAzureFilePropertiesResponse(dict):
    """
    NFS Azure File Properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessMode":
            suggest = "access_mode"
        elif key == "shareName":
            suggest = "share_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NfsAzureFilePropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NfsAzureFilePropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NfsAzureFilePropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_mode: Optional[_builtins.str] = None,
                 server: Optional[_builtins.str] = None,
                 share_name: Optional[_builtins.str] = None):
        """
        NFS Azure File Properties.
        :param _builtins.str access_mode: Access mode for storage
        :param _builtins.str server: Server for NFS azure file.
        :param _builtins.str share_name: NFS Azure file share name.
        """
        if access_mode is not None:
            pulumi.set(__self__, "access_mode", access_mode)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)

    @_builtins.property
    @pulumi.getter(name="accessMode")
    def access_mode(self) -> Optional[_builtins.str]:
        """
        Access mode for storage
        """
        return pulumi.get(self, "access_mode")

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional[_builtins.str]:
        """
        Server for NFS azure file.
        """
        return pulumi.get(self, "server")

    @_builtins.property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[_builtins.str]:
        """
        NFS Azure file share name.
        """
        return pulumi.get(self, "share_name")


@pulumi.output_type
class NonceResponse(dict):
    """
    The configuration settings of the nonce used in the login flow.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nonceExpirationInterval":
            suggest = "nonce_expiration_interval"
        elif key == "validateNonce":
            suggest = "validate_nonce"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NonceResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NonceResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NonceResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nonce_expiration_interval: Optional[_builtins.str] = None,
                 validate_nonce: Optional[_builtins.bool] = None):
        """
        The configuration settings of the nonce used in the login flow.
        :param _builtins.str nonce_expiration_interval: The time after the request is made when the nonce should expire.
        :param _builtins.bool validate_nonce: <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
        if nonce_expiration_interval is not None:
            pulumi.set(__self__, "nonce_expiration_interval", nonce_expiration_interval)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @_builtins.property
    @pulumi.getter(name="nonceExpirationInterval")
    def nonce_expiration_interval(self) -> Optional[_builtins.str]:
        """
        The time after the request is made when the nonce should expire.
        """
        return pulumi.get(self, "nonce_expiration_interval")

    @_builtins.property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[_builtins.bool]:
        """
        <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "validate_nonce")


@pulumi.output_type
class OpenIdConnectClientCredentialResponse(dict):
    """
    The authentication client credentials of the custom Open ID Connect provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientSecretSettingName":
            suggest = "client_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdConnectClientCredentialResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdConnectClientCredentialResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdConnectClientCredentialResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_secret_setting_name: Optional[_builtins.str] = None,
                 method: Optional[_builtins.str] = None):
        """
        The authentication client credentials of the custom Open ID Connect provider.
        :param _builtins.str client_secret_setting_name: The app setting that contains the client secret for the custom Open ID Connect provider.
        :param _builtins.str method: The method that should be used to authenticate the user.
        """
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @_builtins.property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[_builtins.str]:
        """
        The app setting that contains the client secret for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        The method that should be used to authenticate the user.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class OpenIdConnectConfigResponse(dict):
    """
    The configuration settings of the endpoints used for the custom Open ID Connect provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "certificationUri":
            suggest = "certification_uri"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "wellKnownOpenIdConfiguration":
            suggest = "well_known_open_id_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdConnectConfigResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdConnectConfigResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdConnectConfigResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 certification_uri: Optional[_builtins.str] = None,
                 issuer: Optional[_builtins.str] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 well_known_open_id_configuration: Optional[_builtins.str] = None):
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        :param _builtins.str authorization_endpoint: The endpoint to be used to make an authorization request.
        :param _builtins.str certification_uri: The endpoint that provides the keys necessary to validate the token.
        :param _builtins.str issuer: The endpoint that issues the token.
        :param _builtins.str token_endpoint: The endpoint to be used to request a token.
        :param _builtins.str well_known_open_id_configuration: The endpoint that contains all the configuration endpoints for the provider.
        """
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if well_known_open_id_configuration is not None:
            pulumi.set(__self__, "well_known_open_id_configuration", well_known_open_id_configuration)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The endpoint to be used to make an authorization request.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[_builtins.str]:
        """
        The endpoint that provides the keys necessary to validate the token.
        """
        return pulumi.get(self, "certification_uri")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The endpoint that issues the token.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        The endpoint to be used to request a token.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="wellKnownOpenIdConfiguration")
    def well_known_open_id_configuration(self) -> Optional[_builtins.str]:
        """
        The endpoint that contains all the configuration endpoints for the provider.
        """
        return pulumi.get(self, "well_known_open_id_configuration")


@pulumi.output_type
class OpenIdConnectLoginResponse(dict):
    """
    The configuration settings of the login flow of the custom Open ID Connect provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nameClaimType":
            suggest = "name_claim_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdConnectLoginResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdConnectLoginResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdConnectLoginResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name_claim_type: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None):
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        :param _builtins.str name_claim_type: The name of the claim that contains the users name.
        :param Sequence[_builtins.str] scopes: A list of the scopes that should be requested while authenticating.
        """
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[_builtins.str]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class OpenIdConnectRegistrationResponse(dict):
    """
    The configuration settings of the app registration for the custom Open ID Connect provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCredential":
            suggest = "client_credential"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "openIdConnectConfiguration":
            suggest = "open_id_connect_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenIdConnectRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenIdConnectRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenIdConnectRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_credential: Optional['outputs.OpenIdConnectClientCredentialResponse'] = None,
                 client_id: Optional[_builtins.str] = None,
                 open_id_connect_configuration: Optional['outputs.OpenIdConnectConfigResponse'] = None):
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        :param 'OpenIdConnectClientCredentialResponse' client_credential: The authentication credentials of the custom Open ID Connect provider.
        :param _builtins.str client_id: The client id of the custom Open ID Connect provider.
        :param 'OpenIdConnectConfigResponse' open_id_connect_configuration: The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        if client_credential is not None:
            pulumi.set(__self__, "client_credential", client_credential)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if open_id_connect_configuration is not None:
            pulumi.set(__self__, "open_id_connect_configuration", open_id_connect_configuration)

    @_builtins.property
    @pulumi.getter(name="clientCredential")
    def client_credential(self) -> Optional['outputs.OpenIdConnectClientCredentialResponse']:
        """
        The authentication credentials of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_credential")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client id of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="openIdConnectConfiguration")
    def open_id_connect_configuration(self) -> Optional['outputs.OpenIdConnectConfigResponse']:
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "open_id_connect_configuration")


@pulumi.output_type
class OpenTelemetryConfigurationResponse(dict):
    """
    Configuration of Open Telemetry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationsConfiguration":
            suggest = "destinations_configuration"
        elif key == "logsConfiguration":
            suggest = "logs_configuration"
        elif key == "metricsConfiguration":
            suggest = "metrics_configuration"
        elif key == "tracesConfiguration":
            suggest = "traces_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenTelemetryConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenTelemetryConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenTelemetryConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destinations_configuration: Optional['outputs.DestinationsConfigurationResponse'] = None,
                 logs_configuration: Optional['outputs.LogsConfigurationResponse'] = None,
                 metrics_configuration: Optional['outputs.MetricsConfigurationResponse'] = None,
                 traces_configuration: Optional['outputs.TracesConfigurationResponse'] = None):
        """
        Configuration of Open Telemetry
        :param 'DestinationsConfigurationResponse' destinations_configuration: Open telemetry destinations configuration
        :param 'LogsConfigurationResponse' logs_configuration: Open telemetry logs configuration
        :param 'MetricsConfigurationResponse' metrics_configuration: Open telemetry metrics configuration
        :param 'TracesConfigurationResponse' traces_configuration: Open telemetry trace configuration
        """
        if destinations_configuration is not None:
            pulumi.set(__self__, "destinations_configuration", destinations_configuration)
        if logs_configuration is not None:
            pulumi.set(__self__, "logs_configuration", logs_configuration)
        if metrics_configuration is not None:
            pulumi.set(__self__, "metrics_configuration", metrics_configuration)
        if traces_configuration is not None:
            pulumi.set(__self__, "traces_configuration", traces_configuration)

    @_builtins.property
    @pulumi.getter(name="destinationsConfiguration")
    def destinations_configuration(self) -> Optional['outputs.DestinationsConfigurationResponse']:
        """
        Open telemetry destinations configuration
        """
        return pulumi.get(self, "destinations_configuration")

    @_builtins.property
    @pulumi.getter(name="logsConfiguration")
    def logs_configuration(self) -> Optional['outputs.LogsConfigurationResponse']:
        """
        Open telemetry logs configuration
        """
        return pulumi.get(self, "logs_configuration")

    @_builtins.property
    @pulumi.getter(name="metricsConfiguration")
    def metrics_configuration(self) -> Optional['outputs.MetricsConfigurationResponse']:
        """
        Open telemetry metrics configuration
        """
        return pulumi.get(self, "metrics_configuration")

    @_builtins.property
    @pulumi.getter(name="tracesConfiguration")
    def traces_configuration(self) -> Optional['outputs.TracesConfigurationResponse']:
        """
        Open telemetry trace configuration
        """
        return pulumi.get(self, "traces_configuration")


@pulumi.output_type
class OtlpConfigurationResponse(dict):
    """
    Configuration of otlp 
    """
    def __init__(__self__, *,
                 endpoint: Optional[_builtins.str] = None,
                 headers: Optional[Sequence['outputs.HeaderResponse']] = None,
                 insecure: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None):
        """
        Configuration of otlp 
        :param _builtins.str endpoint: The endpoint of otlp configuration
        :param Sequence['HeaderResponse'] headers: Headers of otlp configurations
        :param _builtins.bool insecure: Boolean indicating if otlp configuration is insecure
        :param _builtins.str name: The name of otlp configuration
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        The endpoint of otlp configuration
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.HeaderResponse']]:
        """
        Headers of otlp configurations
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating if otlp configuration is insecure
        """
        return pulumi.get(self, "insecure")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of otlp configuration
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PreBuildStepResponse(dict):
    """
    Model representing a pre-build step.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpGet":
            suggest = "http_get"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PreBuildStepResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PreBuildStepResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PreBuildStepResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 http_get: Optional['outputs.HttpGetResponse'] = None,
                 scripts: Optional[Sequence[_builtins.str]] = None):
        """
        Model representing a pre-build step.
        :param _builtins.str description: Description of the pre-build step.
        :param 'HttpGetResponse' http_get: Http get request to send before the build.
        :param Sequence[_builtins.str] scripts: List of custom commands to run.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if scripts is not None:
            pulumi.set(__self__, "scripts", scripts)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the pre-build step.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.HttpGetResponse']:
        """
        Http get request to send before the build.
        """
        return pulumi.get(self, "http_get")

    @_builtins.property
    @pulumi.getter
    def scripts(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of custom commands to run.
        """
        return pulumi.get(self, "scripts")


@pulumi.output_type
class PrivateEndpointConnectionResponse(dict):
    """
    The Private Endpoint Connection resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupIds":
            suggest = "group_ids"
        elif key == "privateLinkServiceConnectionState":
            suggest = "private_link_service_connection_state"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "systemData":
            suggest = "system_data"
        elif key == "privateEndpoint":
            suggest = "private_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateEndpointConnectionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateEndpointConnectionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_ids: Sequence[_builtins.str],
                 id: _builtins.str,
                 name: _builtins.str,
                 private_link_service_connection_state: 'outputs.PrivateLinkServiceConnectionStateResponse',
                 provisioning_state: _builtins.str,
                 system_data: 'outputs.SystemDataResponse',
                 type: _builtins.str,
                 private_endpoint: Optional['outputs.PrivateEndpointResponse'] = None):
        """
        The Private Endpoint Connection resource.
        :param Sequence[_builtins.str] group_ids: The group ids for the private endpoint resource.
        :param _builtins.str id: Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        :param _builtins.str name: The name of the resource
        :param 'PrivateLinkServiceConnectionStateResponse' private_link_service_connection_state: A collection of information about the state of the connection between service consumer and provider.
        :param _builtins.str provisioning_state: The provisioning state of the private endpoint connection resource.
        :param 'SystemDataResponse' system_data: Azure Resource Manager metadata containing createdBy and modifiedBy information.
        :param _builtins.str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        :param 'PrivateEndpointResponse' private_endpoint: The resource of private end point.
        """
        pulumi.set(__self__, "group_ids", group_ids)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_link_service_connection_state", private_link_service_connection_state)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "system_data", system_data)
        pulumi.set(__self__, "type", type)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)

    @_builtins.property
    @pulumi.getter(name="groupIds")
    def group_ids(self) -> Sequence[_builtins.str]:
        """
        The group ids for the private endpoint resource.
        """
        return pulumi.get(self, "group_ids")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="privateLinkServiceConnectionState")
    def private_link_service_connection_state(self) -> 'outputs.PrivateLinkServiceConnectionStateResponse':
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        return pulumi.get(self, "private_link_service_connection_state")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        The provisioning state of the private endpoint connection resource.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Azure Resource Manager metadata containing createdBy and modifiedBy information.
        """
        return pulumi.get(self, "system_data")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional['outputs.PrivateEndpointResponse']:
        """
        The resource of private end point.
        """
        return pulumi.get(self, "private_endpoint")


@pulumi.output_type
class PrivateEndpointResponse(dict):
    """
    The Private Endpoint resource.
    """
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        The Private Endpoint resource.
        :param _builtins.str id: The ARM identifier for Private Endpoint
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ARM identifier for Private Endpoint
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PrivateLinkServiceConnectionStateResponse(dict):
    """
    A collection of information about the state of the connection between service consumer and provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionsRequired":
            suggest = "actions_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkServiceConnectionStateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkServiceConnectionStateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions_required: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param _builtins.str actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param _builtins.str description: The reason for approval/rejection of the connection.
        :param _builtins.str status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[_builtins.str]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class QueueScaleRuleResponse(dict):
    """
    Container App container Azure Queue based scaling rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountName":
            suggest = "account_name"
        elif key == "queueLength":
            suggest = "queue_length"
        elif key == "queueName":
            suggest = "queue_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QueueScaleRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QueueScaleRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QueueScaleRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_name: Optional[_builtins.str] = None,
                 auth: Optional[Sequence['outputs.ScaleRuleAuthResponse']] = None,
                 identity: Optional[_builtins.str] = None,
                 queue_length: Optional[_builtins.int] = None,
                 queue_name: Optional[_builtins.str] = None):
        """
        Container App container Azure Queue based scaling rule.
        :param _builtins.str account_name: Storage account name. required if using managed identity to authenticate
        :param Sequence['ScaleRuleAuthResponse'] auth: Authentication secrets for the queue scale rule.
        :param _builtins.str identity: The resource ID of a user-assigned managed identity that is assigned to the Container App, or 'system' for system-assigned identity.
        :param _builtins.int queue_length: Queue length.
        :param _builtins.str queue_name: Queue name.
        """
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if queue_length is not None:
            pulumi.set(__self__, "queue_length", queue_length)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[_builtins.str]:
        """
        Storage account name. required if using managed identity to authenticate
        """
        return pulumi.get(self, "account_name")

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[Sequence['outputs.ScaleRuleAuthResponse']]:
        """
        Authentication secrets for the queue scale rule.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        The resource ID of a user-assigned managed identity that is assigned to the Container App, or 'system' for system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter(name="queueLength")
    def queue_length(self) -> Optional[_builtins.int]:
        """
        Queue length.
        """
        return pulumi.get(self, "queue_length")

    @_builtins.property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[_builtins.str]:
        """
        Queue name.
        """
        return pulumi.get(self, "queue_name")


@pulumi.output_type
class RegistryCredentialsResponse(dict):
    """
    Container App Private Registry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordSecretRef":
            suggest = "password_secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: Optional[_builtins.str] = None,
                 password_secret_ref: Optional[_builtins.str] = None,
                 server: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        Container App Private Registry
        :param _builtins.str identity: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        :param _builtins.str password_secret_ref: The name of the Secret that contains the registry login password
        :param _builtins.str server: Container Registry Server
        :param _builtins.str username: Container Registry Username
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if password_secret_ref is not None:
            pulumi.set(__self__, "password_secret_ref", password_secret_ref)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter(name="passwordSecretRef")
    def password_secret_ref(self) -> Optional[_builtins.str]:
        """
        The name of the Secret that contains the registry login password
        """
        return pulumi.get(self, "password_secret_ref")

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional[_builtins.str]:
        """
        Container Registry Server
        """
        return pulumi.get(self, "server")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Container Registry Username
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class RegistryInfoResponse(dict):
    """
    Container App registry information.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryUrl":
            suggest = "registry_url"
        elif key == "registryUserName":
            suggest = "registry_user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_url: Optional[_builtins.str] = None,
                 registry_user_name: Optional[_builtins.str] = None):
        """
        Container App registry information.
        :param _builtins.str registry_url: registry server Url.
        :param _builtins.str registry_user_name: registry username.
        """
        if registry_url is not None:
            pulumi.set(__self__, "registry_url", registry_url)
        if registry_user_name is not None:
            pulumi.set(__self__, "registry_user_name", registry_user_name)

    @_builtins.property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> Optional[_builtins.str]:
        """
        registry server Url.
        """
        return pulumi.get(self, "registry_url")

    @_builtins.property
    @pulumi.getter(name="registryUserName")
    def registry_user_name(self) -> Optional[_builtins.str]:
        """
        registry username.
        """
        return pulumi.get(self, "registry_user_name")


@pulumi.output_type
class RuntimeResponse(dict):
    """
    Container App Runtime configuration.
    """
    def __init__(__self__, *,
                 dotnet: Optional['outputs.RuntimeResponseDotnet'] = None,
                 java: Optional['outputs.RuntimeResponseJava'] = None):
        """
        Container App Runtime configuration.
        :param 'RuntimeResponseDotnet' dotnet: .NET app configuration
        :param 'RuntimeResponseJava' java: Java app configuration
        """
        if dotnet is not None:
            pulumi.set(__self__, "dotnet", dotnet)
        if java is not None:
            pulumi.set(__self__, "java", java)

    @_builtins.property
    @pulumi.getter
    def dotnet(self) -> Optional['outputs.RuntimeResponseDotnet']:
        """
        .NET app configuration
        """
        return pulumi.get(self, "dotnet")

    @_builtins.property
    @pulumi.getter
    def java(self) -> Optional['outputs.RuntimeResponseJava']:
        """
        Java app configuration
        """
        return pulumi.get(self, "java")


@pulumi.output_type
class RuntimeResponseDotnet(dict):
    """
    .NET app configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoConfigureDataProtection":
            suggest = "auto_configure_data_protection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeResponseDotnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeResponseDotnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeResponseDotnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_configure_data_protection: Optional[_builtins.bool] = None):
        """
        .NET app configuration
        :param _builtins.bool auto_configure_data_protection: Auto configure the ASP.NET Core Data Protection feature
        """
        if auto_configure_data_protection is not None:
            pulumi.set(__self__, "auto_configure_data_protection", auto_configure_data_protection)

    @_builtins.property
    @pulumi.getter(name="autoConfigureDataProtection")
    def auto_configure_data_protection(self) -> Optional[_builtins.bool]:
        """
        Auto configure the ASP.NET Core Data Protection feature
        """
        return pulumi.get(self, "auto_configure_data_protection")


@pulumi.output_type
class RuntimeResponseJava(dict):
    """
    Java app configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableMetrics":
            suggest = "enable_metrics"
        elif key == "javaAgent":
            suggest = "java_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeResponseJava. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeResponseJava.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeResponseJava.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_metrics: Optional[_builtins.bool] = None,
                 java_agent: Optional['outputs.RuntimeResponseJavaAgent'] = None):
        """
        Java app configuration
        :param _builtins.bool enable_metrics: Enable jmx core metrics for the java app
        :param 'RuntimeResponseJavaAgent' java_agent: Diagnostic capabilities achieved by java agent
        """
        if enable_metrics is not None:
            pulumi.set(__self__, "enable_metrics", enable_metrics)
        if java_agent is not None:
            pulumi.set(__self__, "java_agent", java_agent)

    @_builtins.property
    @pulumi.getter(name="enableMetrics")
    def enable_metrics(self) -> Optional[_builtins.bool]:
        """
        Enable jmx core metrics for the java app
        """
        return pulumi.get(self, "enable_metrics")

    @_builtins.property
    @pulumi.getter(name="javaAgent")
    def java_agent(self) -> Optional['outputs.RuntimeResponseJavaAgent']:
        """
        Diagnostic capabilities achieved by java agent
        """
        return pulumi.get(self, "java_agent")


@pulumi.output_type
class RuntimeResponseJavaAgent(dict):
    """
    Diagnostic capabilities achieved by java agent
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 logging: Optional['outputs.RuntimeResponseLogging'] = None):
        """
        Diagnostic capabilities achieved by java agent
        :param _builtins.bool enabled: Enable java agent injection for the java app.
        :param 'RuntimeResponseLogging' logging: Capabilities on the java logging scenario.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable java agent injection for the java app.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def logging(self) -> Optional['outputs.RuntimeResponseLogging']:
        """
        Capabilities on the java logging scenario.
        """
        return pulumi.get(self, "logging")


@pulumi.output_type
class RuntimeResponseLogging(dict):
    """
    Capabilities on the java logging scenario.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loggerSettings":
            suggest = "logger_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeResponseLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeResponseLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeResponseLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logger_settings: Optional[Sequence['outputs.LoggerSettingResponse']] = None):
        """
        Capabilities on the java logging scenario.
        :param Sequence['LoggerSettingResponse'] logger_settings: Settings of the logger for the java app.
        """
        if logger_settings is not None:
            pulumi.set(__self__, "logger_settings", logger_settings)

    @_builtins.property
    @pulumi.getter(name="loggerSettings")
    def logger_settings(self) -> Optional[Sequence['outputs.LoggerSettingResponse']]:
        """
        Settings of the logger for the java app.
        """
        return pulumi.get(self, "logger_settings")


@pulumi.output_type
class ScaleConfigurationResponse(dict):
    """
    Scale configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentSessions":
            suggest = "max_concurrent_sessions"
        elif key == "readySessionInstances":
            suggest = "ready_session_instances"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_sessions: Optional[_builtins.int] = None,
                 ready_session_instances: Optional[_builtins.int] = None):
        """
        Scale configuration.
        :param _builtins.int max_concurrent_sessions: The maximum count of sessions at the same time.
        :param _builtins.int ready_session_instances: The minimum count of ready session instances.
        """
        if max_concurrent_sessions is not None:
            pulumi.set(__self__, "max_concurrent_sessions", max_concurrent_sessions)
        if ready_session_instances is not None:
            pulumi.set(__self__, "ready_session_instances", ready_session_instances)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentSessions")
    def max_concurrent_sessions(self) -> Optional[_builtins.int]:
        """
        The maximum count of sessions at the same time.
        """
        return pulumi.get(self, "max_concurrent_sessions")

    @_builtins.property
    @pulumi.getter(name="readySessionInstances")
    def ready_session_instances(self) -> Optional[_builtins.int]:
        """
        The minimum count of ready session instances.
        """
        return pulumi.get(self, "ready_session_instances")


@pulumi.output_type
class ScaleResponse(dict):
    """
    Container App scaling configurations.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cooldownPeriod":
            suggest = "cooldown_period"
        elif key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"
        elif key == "pollingInterval":
            suggest = "polling_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cooldown_period: Optional[_builtins.int] = None,
                 max_replicas: Optional[_builtins.int] = None,
                 min_replicas: Optional[_builtins.int] = None,
                 polling_interval: Optional[_builtins.int] = None,
                 rules: Optional[Sequence['outputs.ScaleRuleResponse']] = None):
        """
        Container App scaling configurations.
        :param _builtins.int cooldown_period: Optional. KEDA Cooldown Period. Defaults to 300 seconds if not set.
        :param _builtins.int max_replicas: Optional. Maximum number of container replicas. Defaults to 10 if not set.
        :param _builtins.int min_replicas: Optional. Minimum number of container replicas.
        :param _builtins.int polling_interval: Optional. KEDA Polling Interval. Defaults to 30 seconds if not set.
        :param Sequence['ScaleRuleResponse'] rules: Scaling rules.
        """
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if max_replicas is None:
            max_replicas = 10
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[_builtins.int]:
        """
        Optional. KEDA Cooldown Period. Defaults to 300 seconds if not set.
        """
        return pulumi.get(self, "cooldown_period")

    @_builtins.property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[_builtins.int]:
        """
        Optional. Maximum number of container replicas. Defaults to 10 if not set.
        """
        return pulumi.get(self, "max_replicas")

    @_builtins.property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[_builtins.int]:
        """
        Optional. Minimum number of container replicas.
        """
        return pulumi.get(self, "min_replicas")

    @_builtins.property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[_builtins.int]:
        """
        Optional. KEDA Polling Interval. Defaults to 30 seconds if not set.
        """
        return pulumi.get(self, "polling_interval")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.ScaleRuleResponse']]:
        """
        Scaling rules.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class ScaleRuleAuthResponse(dict):
    """
    Auth Secrets for Scale Rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"
        elif key == "triggerParameter":
            suggest = "trigger_parameter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleRuleAuthResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleRuleAuthResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleRuleAuthResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_ref: Optional[_builtins.str] = None,
                 trigger_parameter: Optional[_builtins.str] = None):
        """
        Auth Secrets for Scale Rule
        :param _builtins.str secret_ref: Name of the secret from which to pull the auth params.
        :param _builtins.str trigger_parameter: Trigger Parameter that uses the secret
        """
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if trigger_parameter is not None:
            pulumi.set(__self__, "trigger_parameter", trigger_parameter)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[_builtins.str]:
        """
        Name of the secret from which to pull the auth params.
        """
        return pulumi.get(self, "secret_ref")

    @_builtins.property
    @pulumi.getter(name="triggerParameter")
    def trigger_parameter(self) -> Optional[_builtins.str]:
        """
        Trigger Parameter that uses the secret
        """
        return pulumi.get(self, "trigger_parameter")


@pulumi.output_type
class ScaleRuleResponse(dict):
    """
    Container App container scaling rule.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureQueue":
            suggest = "azure_queue"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_queue: Optional['outputs.QueueScaleRuleResponse'] = None,
                 custom: Optional['outputs.CustomScaleRuleResponse'] = None,
                 http: Optional['outputs.HttpScaleRuleResponse'] = None,
                 name: Optional[_builtins.str] = None,
                 tcp: Optional['outputs.TcpScaleRuleResponse'] = None):
        """
        Container App container scaling rule.
        :param 'QueueScaleRuleResponse' azure_queue: Azure Queue based scaling.
        :param 'CustomScaleRuleResponse' custom: Custom scale rule.
        :param 'HttpScaleRuleResponse' http: HTTP requests based scaling.
        :param _builtins.str name: Scale Rule Name
        :param 'TcpScaleRuleResponse' tcp: Tcp requests based scaling.
        """
        if azure_queue is not None:
            pulumi.set(__self__, "azure_queue", azure_queue)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)

    @_builtins.property
    @pulumi.getter(name="azureQueue")
    def azure_queue(self) -> Optional['outputs.QueueScaleRuleResponse']:
        """
        Azure Queue based scaling.
        """
        return pulumi.get(self, "azure_queue")

    @_builtins.property
    @pulumi.getter
    def custom(self) -> Optional['outputs.CustomScaleRuleResponse']:
        """
        Custom scale rule.
        """
        return pulumi.get(self, "custom")

    @_builtins.property
    @pulumi.getter
    def http(self) -> Optional['outputs.HttpScaleRuleResponse']:
        """
        HTTP requests based scaling.
        """
        return pulumi.get(self, "http")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Scale Rule Name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.TcpScaleRuleResponse']:
        """
        Tcp requests based scaling.
        """
        return pulumi.get(self, "tcp")


@pulumi.output_type
class ScgRouteResponse(dict):
    """
    Spring Cloud Gateway route definition
    """
    def __init__(__self__, *,
                 id: _builtins.str,
                 uri: _builtins.str,
                 filters: Optional[Sequence[_builtins.str]] = None,
                 order: Optional[_builtins.float] = None,
                 predicates: Optional[Sequence[_builtins.str]] = None):
        """
        Spring Cloud Gateway route definition
        :param _builtins.str id: Id of the route
        :param _builtins.str uri: Uri of the route
        :param Sequence[_builtins.str] filters: Filters of the route
        :param _builtins.float order: Order of the route
        :param Sequence[_builtins.str] predicates: Predicates of the route
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "uri", uri)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if predicates is not None:
            pulumi.set(__self__, "predicates", predicates)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the route
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> _builtins.str:
        """
        Uri of the route
        """
        return pulumi.get(self, "uri")

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Filters of the route
        """
        return pulumi.get(self, "filters")

    @_builtins.property
    @pulumi.getter
    def order(self) -> Optional[_builtins.float]:
        """
        Order of the route
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter
    def predicates(self) -> Optional[Sequence[_builtins.str]]:
        """
        Predicates of the route
        """
        return pulumi.get(self, "predicates")


@pulumi.output_type
class ScheduledEntryResponse(dict):
    """
    Maintenance schedule entry for a managed environment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationHours":
            suggest = "duration_hours"
        elif key == "startHourUtc":
            suggest = "start_hour_utc"
        elif key == "weekDay":
            suggest = "week_day"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduledEntryResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduledEntryResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduledEntryResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_hours: _builtins.int,
                 start_hour_utc: _builtins.int,
                 week_day: _builtins.str):
        """
        Maintenance schedule entry for a managed environment.
        :param _builtins.int duration_hours: Length of maintenance window range from 8 to 24 hours.
        :param _builtins.int start_hour_utc: Start hour after which managed environment maintenance can start from 0 to 23 hour.
        :param _builtins.str week_day: Day of the week when a managed environment can be patched.
        """
        pulumi.set(__self__, "duration_hours", duration_hours)
        pulumi.set(__self__, "start_hour_utc", start_hour_utc)
        pulumi.set(__self__, "week_day", week_day)

    @_builtins.property
    @pulumi.getter(name="durationHours")
    def duration_hours(self) -> _builtins.int:
        """
        Length of maintenance window range from 8 to 24 hours.
        """
        return pulumi.get(self, "duration_hours")

    @_builtins.property
    @pulumi.getter(name="startHourUtc")
    def start_hour_utc(self) -> _builtins.int:
        """
        Start hour after which managed environment maintenance can start from 0 to 23 hour.
        """
        return pulumi.get(self, "start_hour_utc")

    @_builtins.property
    @pulumi.getter(name="weekDay")
    def week_day(self) -> _builtins.str:
        """
        Day of the week when a managed environment can be patched.
        """
        return pulumi.get(self, "week_day")


@pulumi.output_type
class SecretKeyVaultPropertiesResponse(dict):
    """
    Properties for a secret stored in a Key Vault.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultUrl":
            suggest = "key_vault_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretKeyVaultPropertiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretKeyVaultPropertiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretKeyVaultPropertiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: Optional[_builtins.str] = None,
                 key_vault_url: Optional[_builtins.str] = None):
        """
        Properties for a secret stored in a Key Vault.
        :param _builtins.str identity: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        :param _builtins.str key_vault_url: URL pointing to the Azure Key Vault secret.
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if key_vault_url is not None:
            pulumi.set(__self__, "key_vault_url", key_vault_url)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter(name="keyVaultUrl")
    def key_vault_url(self) -> Optional[_builtins.str]:
        """
        URL pointing to the Azure Key Vault secret.
        """
        return pulumi.get(self, "key_vault_url")


@pulumi.output_type
class SecretResponse(dict):
    """
    Secret definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultUrl":
            suggest = "key_vault_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: Optional[_builtins.str] = None,
                 key_vault_url: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        Secret definition.
        :param _builtins.str identity: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        :param _builtins.str key_vault_url: Azure Key Vault URL pointing to the secret referenced by the container app.
        :param _builtins.str name: Secret Name.
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if key_vault_url is not None:
            pulumi.set(__self__, "key_vault_url", key_vault_url)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter(name="keyVaultUrl")
    def key_vault_url(self) -> Optional[_builtins.str]:
        """
        Azure Key Vault URL pointing to the secret referenced by the container app.
        """
        return pulumi.get(self, "key_vault_url")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Secret Name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecretVolumeItemResponse(dict):
    """
    Secret to be added to volume.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretVolumeItemResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretVolumeItemResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretVolumeItemResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None,
                 secret_ref: Optional[_builtins.str] = None):
        """
        Secret to be added to volume.
        :param _builtins.str path: Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
        :param _builtins.str secret_ref: Name of the Container App secret from which to pull the secret value.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[_builtins.str]:
        """
        Name of the Container App secret from which to pull the secret value.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class ServiceBindResponse(dict):
    """
    Configuration to bind a ContainerApp to a dev ContainerApp Service
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientType":
            suggest = "client_type"
        elif key == "customizedKeys":
            suggest = "customized_keys"
        elif key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceBindResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceBindResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceBindResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_type: Optional[_builtins.str] = None,
                 customized_keys: Optional[Mapping[str, _builtins.str]] = None,
                 name: Optional[_builtins.str] = None,
                 service_id: Optional[_builtins.str] = None):
        """
        Configuration to bind a ContainerApp to a dev ContainerApp Service
        :param _builtins.str client_type: Type of the client to be used to connect to the service
        :param Mapping[str, _builtins.str] customized_keys: Customized keys for customizing injected values to the app
        :param _builtins.str name: Name of the service bind
        :param _builtins.str service_id: Resource id of the target service
        """
        if client_type is not None:
            pulumi.set(__self__, "client_type", client_type)
        if customized_keys is not None:
            pulumi.set(__self__, "customized_keys", customized_keys)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)

    @_builtins.property
    @pulumi.getter(name="clientType")
    def client_type(self) -> Optional[_builtins.str]:
        """
        Type of the client to be used to connect to the service
        """
        return pulumi.get(self, "client_type")

    @_builtins.property
    @pulumi.getter(name="customizedKeys")
    def customized_keys(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Customized keys for customizing injected values to the app
        """
        return pulumi.get(self, "customized_keys")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the service bind
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[_builtins.str]:
        """
        Resource id of the target service
        """
        return pulumi.get(self, "service_id")


@pulumi.output_type
class ServiceResponse(dict):
    """
    Container App to be a dev service
    """
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        Container App to be a dev service
        :param _builtins.str type: Dev ContainerApp service type
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Dev ContainerApp service type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SessionContainerResourcesResponse(dict):
    """
    Container resource requirements for sessions of the session pool.
    """
    def __init__(__self__, *,
                 cpu: Optional[_builtins.float] = None,
                 memory: Optional[_builtins.str] = None):
        """
        Container resource requirements for sessions of the session pool.
        :param _builtins.float cpu: Required CPU in cores, e.g. 0.5
        :param _builtins.str memory: Required memory, e.g. "250Mb"
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[_builtins.float]:
        """
        Required CPU in cores, e.g. 0.5
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[_builtins.str]:
        """
        Required memory, e.g. "250Mb"
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class SessionContainerResponse(dict):
    """
    Container definitions for the sessions of the session pool.
    """
    def __init__(__self__, *,
                 args: Optional[Sequence[_builtins.str]] = None,
                 command: Optional[Sequence[_builtins.str]] = None,
                 env: Optional[Sequence['outputs.EnvironmentVarResponse']] = None,
                 image: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 probes: Optional[Sequence['outputs.SessionProbeResponse']] = None,
                 resources: Optional['outputs.SessionContainerResourcesResponse'] = None):
        """
        Container definitions for the sessions of the session pool.
        :param Sequence[_builtins.str] args: Container start command arguments.
        :param Sequence[_builtins.str] command: Container start command.
        :param Sequence['EnvironmentVarResponse'] env: Container environment variables.
        :param _builtins.str image: Container image tag.
        :param _builtins.str name: Custom container name.
        :param Sequence['SessionProbeResponse'] probes: List of probes for the container.
        :param 'SessionContainerResourcesResponse' resources: Container resource requirements.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[Sequence[_builtins.str]]:
        """
        Container start command arguments.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[Sequence[_builtins.str]]:
        """
        Container start command.
        """
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.EnvironmentVarResponse']]:
        """
        Container environment variables.
        """
        return pulumi.get(self, "env")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Container image tag.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Custom container name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def probes(self) -> Optional[Sequence['outputs.SessionProbeResponse']]:
        """
        List of probes for the container.
        """
        return pulumi.get(self, "probes")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional['outputs.SessionContainerResourcesResponse']:
        """
        Container resource requirements.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class SessionIngressResponse(dict):
    """
    Session pool ingress configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetPort":
            suggest = "target_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionIngressResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionIngressResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionIngressResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_port: Optional[_builtins.int] = None):
        """
        Session pool ingress configuration.
        :param _builtins.int target_port: Target port in containers for traffic from ingress
        """
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[_builtins.int]:
        """
        Target port in containers for traffic from ingress
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class SessionNetworkConfigurationResponse(dict):
    """
    Session network configuration.
    """
    def __init__(__self__, *,
                 status: Optional[_builtins.str] = None):
        """
        Session network configuration.
        :param _builtins.str status: Network status for the sessions.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Network status for the sessions.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SessionPoolSecretResponse(dict):
    """
    Secret definition.
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        Secret definition.
        :param _builtins.str name: Secret Name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Secret Name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SessionProbeResponse(dict):
    """
    Session probe configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSocket":
            suggest = "tcp_socket"
        elif key == "terminationGracePeriodSeconds":
            suggest = "termination_grace_period_seconds"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionProbeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionProbeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionProbeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_threshold: Optional[_builtins.int] = None,
                 http_get: Optional['outputs.SessionProbeResponseHttpGet'] = None,
                 initial_delay_seconds: Optional[_builtins.int] = None,
                 period_seconds: Optional[_builtins.int] = None,
                 success_threshold: Optional[_builtins.int] = None,
                 tcp_socket: Optional['outputs.SessionProbeResponseTcpSocket'] = None,
                 termination_grace_period_seconds: Optional[_builtins.float] = None,
                 timeout_seconds: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        """
        Session probe configuration.
        :param _builtins.int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        :param 'SessionProbeResponseHttpGet' http_get: HTTPGet specifies the http request to perform.
        :param _builtins.int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        :param _builtins.int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        :param _builtins.int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        :param 'SessionProbeResponseTcpSocket' tcp_socket: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        :param _builtins.float termination_grace_period_seconds: Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        :param _builtins.int timeout_seconds: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        :param _builtins.str type: Denotes the type of probe. Can be Liveness or Startup, Readiness probe is not supported in sessions. Type must be unique for each probe within the context of a list of probes (SessionProbes).
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[_builtins.int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        """
        return pulumi.get(self, "failure_threshold")

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.SessionProbeResponseHttpGet']:
        """
        HTTPGet specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[_builtins.int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[_builtins.int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[_builtins.int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        """
        return pulumi.get(self, "success_threshold")

    @_builtins.property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.SessionProbeResponseTcpSocket']:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        """
        return pulumi.get(self, "tcp_socket")

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[_builtins.float]:
        """
        Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        """
        return pulumi.get(self, "timeout_seconds")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Denotes the type of probe. Can be Liveness or Startup, Readiness probe is not supported in sessions. Type must be unique for each probe within the context of a list of probes (SessionProbes).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SessionProbeResponseHttpGet(dict):
    """
    HTTPGet specifies the http request to perform.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionProbeResponseHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionProbeResponseHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionProbeResponseHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: _builtins.int,
                 host: Optional[_builtins.str] = None,
                 http_headers: Optional[Sequence['outputs.SessionProbeResponseHttpHeaders']] = None,
                 path: Optional[_builtins.str] = None,
                 scheme: Optional[_builtins.str] = None):
        """
        HTTPGet specifies the http request to perform.
        :param _builtins.int port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param _builtins.str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['SessionProbeResponseHttpHeaders'] http_headers: Custom headers to set in the request. HTTP allows repeated headers.
        :param _builtins.str path: Path to access on the HTTP server.
        :param _builtins.str scheme: Scheme to use for connecting to the host. Defaults to HTTP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.SessionProbeResponseHttpHeaders']]:
        """
        Custom headers to set in the request. HTTP allows repeated headers.
        """
        return pulumi.get(self, "http_headers")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[_builtins.str]:
        """
        Scheme to use for connecting to the host. Defaults to HTTP.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class SessionProbeResponseHttpHeaders(dict):
    """
    HTTPHeader describes a custom header to be used in HTTP probes
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        HTTPHeader describes a custom header to be used in HTTP probes
        :param _builtins.str name: The header field name
        :param _builtins.str value: The header field value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SessionProbeResponseTcpSocket(dict):
    """
    TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
    """
    def __init__(__self__, *,
                 port: _builtins.int,
                 host: Optional[_builtins.str] = None):
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        :param _builtins.int port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param _builtins.str host: Optional: Host name to connect to, defaults to the pod IP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Optional: Host name to connect to, defaults to the pod IP.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class SessionRegistryCredentialsResponse(dict):
    """
    Session pool private registry credentials.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordSecretRef":
            suggest = "password_secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SessionRegistryCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SessionRegistryCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SessionRegistryCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: Optional[_builtins.str] = None,
                 password_secret_ref: Optional[_builtins.str] = None,
                 server: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        Session pool private registry credentials.
        :param _builtins.str identity: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        :param _builtins.str password_secret_ref: The name of the secret that contains the registry login password
        :param _builtins.str server: Container registry server.
        :param _builtins.str username: Container registry username.
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if password_secret_ref is not None:
            pulumi.set(__self__, "password_secret_ref", password_secret_ref)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter(name="passwordSecretRef")
    def password_secret_ref(self) -> Optional[_builtins.str]:
        """
        The name of the secret that contains the registry login password
        """
        return pulumi.get(self, "password_secret_ref")

    @_builtins.property
    @pulumi.getter
    def server(self) -> Optional[_builtins.str]:
        """
        Container registry server.
        """
        return pulumi.get(self, "server")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Container registry username.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SmbStorageResponse(dict):
    """
    SMB storage properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessMode":
            suggest = "access_mode"
        elif key == "shareName":
            suggest = "share_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SmbStorageResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SmbStorageResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SmbStorageResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_mode: Optional[_builtins.str] = None,
                 domain: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 share_name: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        SMB storage properties
        :param _builtins.str access_mode: Access mode for storage
        :param _builtins.str domain: The domain name for the user.
        :param _builtins.str host: The host name or IP address of the SMB server.
        :param _builtins.str password: The password for the user.
        :param _builtins.str share_name: The path to the SMB shared folder.
        :param _builtins.str username: The user to log on to the SMB server.
        """
        if access_mode is not None:
            pulumi.set(__self__, "access_mode", access_mode)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="accessMode")
    def access_mode(self) -> Optional[_builtins.str]:
        """
        Access mode for storage
        """
        return pulumi.get(self, "access_mode")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[_builtins.str]:
        """
        The domain name for the user.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The host name or IP address of the SMB server.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The password for the user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[_builtins.str]:
        """
        The path to the SMB shared folder.
        """
        return pulumi.get(self, "share_name")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The user to log on to the SMB server.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SpringBootAdminComponentResponse(dict):
    """
    Spring Boot Admin properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentType":
            suggest = "component_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "serviceBinds":
            suggest = "service_binds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpringBootAdminComponentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpringBootAdminComponentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpringBootAdminComponentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_type: _builtins.str,
                 provisioning_state: _builtins.str,
                 configurations: Optional[Sequence['outputs.JavaComponentConfigurationPropertyResponse']] = None,
                 ingress: Optional['outputs.JavaComponentIngressResponse'] = None,
                 scale: Optional['outputs.JavaComponentPropertiesResponseScale'] = None,
                 service_binds: Optional[Sequence['outputs.JavaComponentServiceBindResponse']] = None):
        """
        Spring Boot Admin properties.
        :param _builtins.str component_type: Type of the Java Component.
               Expected value is 'SpringBootAdmin'.
        :param _builtins.str provisioning_state: Provisioning state of the Java Component.
        :param Sequence['JavaComponentConfigurationPropertyResponse'] configurations: List of Java Components configuration properties
        :param 'JavaComponentIngressResponse' ingress: Java Component Ingress configurations.
        :param 'JavaComponentPropertiesResponseScale' scale: Java component scaling configurations
        :param Sequence['JavaComponentServiceBindResponse'] service_binds: List of Java Components that are bound to the Java component
        """
        pulumi.set(__self__, "component_type", 'SpringBootAdmin')
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if service_binds is not None:
            pulumi.set(__self__, "service_binds", service_binds)

    @_builtins.property
    @pulumi.getter(name="componentType")
    def component_type(self) -> _builtins.str:
        """
        Type of the Java Component.
        Expected value is 'SpringBootAdmin'.
        """
        return pulumi.get(self, "component_type")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the Java Component.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.JavaComponentConfigurationPropertyResponse']]:
        """
        List of Java Components configuration properties
        """
        return pulumi.get(self, "configurations")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> Optional['outputs.JavaComponentIngressResponse']:
        """
        Java Component Ingress configurations.
        """
        return pulumi.get(self, "ingress")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional['outputs.JavaComponentPropertiesResponseScale']:
        """
        Java component scaling configurations
        """
        return pulumi.get(self, "scale")

    @_builtins.property
    @pulumi.getter(name="serviceBinds")
    def service_binds(self) -> Optional[Sequence['outputs.JavaComponentServiceBindResponse']]:
        """
        List of Java Components that are bound to the Java component
        """
        return pulumi.get(self, "service_binds")


@pulumi.output_type
class SpringCloudConfigComponentResponse(dict):
    """
    Spring Cloud Config properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentType":
            suggest = "component_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "serviceBinds":
            suggest = "service_binds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpringCloudConfigComponentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpringCloudConfigComponentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpringCloudConfigComponentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_type: _builtins.str,
                 provisioning_state: _builtins.str,
                 configurations: Optional[Sequence['outputs.JavaComponentConfigurationPropertyResponse']] = None,
                 scale: Optional['outputs.JavaComponentPropertiesResponseScale'] = None,
                 service_binds: Optional[Sequence['outputs.JavaComponentServiceBindResponse']] = None):
        """
        Spring Cloud Config properties.
        :param _builtins.str component_type: Type of the Java Component.
               Expected value is 'SpringCloudConfig'.
        :param _builtins.str provisioning_state: Provisioning state of the Java Component.
        :param Sequence['JavaComponentConfigurationPropertyResponse'] configurations: List of Java Components configuration properties
        :param 'JavaComponentPropertiesResponseScale' scale: Java component scaling configurations
        :param Sequence['JavaComponentServiceBindResponse'] service_binds: List of Java Components that are bound to the Java component
        """
        pulumi.set(__self__, "component_type", 'SpringCloudConfig')
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if service_binds is not None:
            pulumi.set(__self__, "service_binds", service_binds)

    @_builtins.property
    @pulumi.getter(name="componentType")
    def component_type(self) -> _builtins.str:
        """
        Type of the Java Component.
        Expected value is 'SpringCloudConfig'.
        """
        return pulumi.get(self, "component_type")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the Java Component.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.JavaComponentConfigurationPropertyResponse']]:
        """
        List of Java Components configuration properties
        """
        return pulumi.get(self, "configurations")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional['outputs.JavaComponentPropertiesResponseScale']:
        """
        Java component scaling configurations
        """
        return pulumi.get(self, "scale")

    @_builtins.property
    @pulumi.getter(name="serviceBinds")
    def service_binds(self) -> Optional[Sequence['outputs.JavaComponentServiceBindResponse']]:
        """
        List of Java Components that are bound to the Java component
        """
        return pulumi.get(self, "service_binds")


@pulumi.output_type
class SpringCloudEurekaComponentResponse(dict):
    """
    Spring Cloud Eureka properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentType":
            suggest = "component_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "serviceBinds":
            suggest = "service_binds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpringCloudEurekaComponentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpringCloudEurekaComponentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpringCloudEurekaComponentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_type: _builtins.str,
                 provisioning_state: _builtins.str,
                 configurations: Optional[Sequence['outputs.JavaComponentConfigurationPropertyResponse']] = None,
                 ingress: Optional['outputs.JavaComponentIngressResponse'] = None,
                 scale: Optional['outputs.JavaComponentPropertiesResponseScale'] = None,
                 service_binds: Optional[Sequence['outputs.JavaComponentServiceBindResponse']] = None):
        """
        Spring Cloud Eureka properties.
        :param _builtins.str component_type: Type of the Java Component.
               Expected value is 'SpringCloudEureka'.
        :param _builtins.str provisioning_state: Provisioning state of the Java Component.
        :param Sequence['JavaComponentConfigurationPropertyResponse'] configurations: List of Java Components configuration properties
        :param 'JavaComponentIngressResponse' ingress: Java Component Ingress configurations.
        :param 'JavaComponentPropertiesResponseScale' scale: Java component scaling configurations
        :param Sequence['JavaComponentServiceBindResponse'] service_binds: List of Java Components that are bound to the Java component
        """
        pulumi.set(__self__, "component_type", 'SpringCloudEureka')
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if service_binds is not None:
            pulumi.set(__self__, "service_binds", service_binds)

    @_builtins.property
    @pulumi.getter(name="componentType")
    def component_type(self) -> _builtins.str:
        """
        Type of the Java Component.
        Expected value is 'SpringCloudEureka'.
        """
        return pulumi.get(self, "component_type")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the Java Component.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.JavaComponentConfigurationPropertyResponse']]:
        """
        List of Java Components configuration properties
        """
        return pulumi.get(self, "configurations")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> Optional['outputs.JavaComponentIngressResponse']:
        """
        Java Component Ingress configurations.
        """
        return pulumi.get(self, "ingress")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional['outputs.JavaComponentPropertiesResponseScale']:
        """
        Java component scaling configurations
        """
        return pulumi.get(self, "scale")

    @_builtins.property
    @pulumi.getter(name="serviceBinds")
    def service_binds(self) -> Optional[Sequence['outputs.JavaComponentServiceBindResponse']]:
        """
        List of Java Components that are bound to the Java component
        """
        return pulumi.get(self, "service_binds")


@pulumi.output_type
class SpringCloudGatewayComponentResponse(dict):
    """
    Spring Cloud Gateway properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentType":
            suggest = "component_type"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "serviceBinds":
            suggest = "service_binds"
        elif key == "springCloudGatewayRoutes":
            suggest = "spring_cloud_gateway_routes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpringCloudGatewayComponentResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpringCloudGatewayComponentResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpringCloudGatewayComponentResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_type: _builtins.str,
                 provisioning_state: _builtins.str,
                 configurations: Optional[Sequence['outputs.JavaComponentConfigurationPropertyResponse']] = None,
                 ingress: Optional['outputs.JavaComponentIngressResponse'] = None,
                 scale: Optional['outputs.JavaComponentPropertiesResponseScale'] = None,
                 service_binds: Optional[Sequence['outputs.JavaComponentServiceBindResponse']] = None,
                 spring_cloud_gateway_routes: Optional[Sequence['outputs.ScgRouteResponse']] = None):
        """
        Spring Cloud Gateway properties.
        :param _builtins.str component_type: Type of the Java Component.
               Expected value is 'SpringCloudGateway'.
        :param _builtins.str provisioning_state: Provisioning state of the Java Component.
        :param Sequence['JavaComponentConfigurationPropertyResponse'] configurations: List of Java Components configuration properties
        :param 'JavaComponentIngressResponse' ingress: Java Component Ingress configurations.
        :param 'JavaComponentPropertiesResponseScale' scale: Java component scaling configurations
        :param Sequence['JavaComponentServiceBindResponse'] service_binds: List of Java Components that are bound to the Java component
        :param Sequence['ScgRouteResponse'] spring_cloud_gateway_routes: Gateway route definition
        """
        pulumi.set(__self__, "component_type", 'SpringCloudGateway')
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if service_binds is not None:
            pulumi.set(__self__, "service_binds", service_binds)
        if spring_cloud_gateway_routes is not None:
            pulumi.set(__self__, "spring_cloud_gateway_routes", spring_cloud_gateway_routes)

    @_builtins.property
    @pulumi.getter(name="componentType")
    def component_type(self) -> _builtins.str:
        """
        Type of the Java Component.
        Expected value is 'SpringCloudGateway'.
        """
        return pulumi.get(self, "component_type")

    @_builtins.property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> _builtins.str:
        """
        Provisioning state of the Java Component.
        """
        return pulumi.get(self, "provisioning_state")

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.JavaComponentConfigurationPropertyResponse']]:
        """
        List of Java Components configuration properties
        """
        return pulumi.get(self, "configurations")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> Optional['outputs.JavaComponentIngressResponse']:
        """
        Java Component Ingress configurations.
        """
        return pulumi.get(self, "ingress")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional['outputs.JavaComponentPropertiesResponseScale']:
        """
        Java component scaling configurations
        """
        return pulumi.get(self, "scale")

    @_builtins.property
    @pulumi.getter(name="serviceBinds")
    def service_binds(self) -> Optional[Sequence['outputs.JavaComponentServiceBindResponse']]:
        """
        List of Java Components that are bound to the Java component
        """
        return pulumi.get(self, "service_binds")

    @_builtins.property
    @pulumi.getter(name="springCloudGatewayRoutes")
    def spring_cloud_gateway_routes(self) -> Optional[Sequence['outputs.ScgRouteResponse']]:
        """
        Gateway route definition
        """
        return pulumi.get(self, "spring_cloud_gateway_routes")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 created_by_type: Optional[_builtins.str] = None,
                 last_modified_at: Optional[_builtins.str] = None,
                 last_modified_by: Optional[_builtins.str] = None,
                 last_modified_by_type: Optional[_builtins.str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param _builtins.str created_at: The timestamp of resource creation (UTC).
        :param _builtins.str created_by: The identity that created the resource.
        :param _builtins.str created_by_type: The type of identity that created the resource.
        :param _builtins.str last_modified_at: The timestamp of resource last modification (UTC)
        :param _builtins.str last_modified_by: The identity that last modified the resource.
        :param _builtins.str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @_builtins.property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[_builtins.str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @_builtins.property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[_builtins.str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class TcpConnectionPoolResponse(dict):
    """
    Defines parameters for tcp connection pooling
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConnections":
            suggest = "max_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpConnectionPoolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpConnectionPoolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpConnectionPoolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_connections: Optional[_builtins.int] = None):
        """
        Defines parameters for tcp connection pooling
        :param _builtins.int max_connections: Maximum number of tcp connections allowed
        """
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)

    @_builtins.property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[_builtins.int]:
        """
        Maximum number of tcp connections allowed
        """
        return pulumi.get(self, "max_connections")


@pulumi.output_type
class TcpRetryPolicyResponse(dict):
    """
    Policy that defines tcp request retry conditions
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConnectAttempts":
            suggest = "max_connect_attempts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TcpRetryPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TcpRetryPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TcpRetryPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_connect_attempts: Optional[_builtins.int] = None):
        """
        Policy that defines tcp request retry conditions
        :param _builtins.int max_connect_attempts: Maximum number of attempts to connect to the tcp service
        """
        if max_connect_attempts is not None:
            pulumi.set(__self__, "max_connect_attempts", max_connect_attempts)

    @_builtins.property
    @pulumi.getter(name="maxConnectAttempts")
    def max_connect_attempts(self) -> Optional[_builtins.int]:
        """
        Maximum number of attempts to connect to the tcp service
        """
        return pulumi.get(self, "max_connect_attempts")


@pulumi.output_type
class TcpScaleRuleResponse(dict):
    """
    Container App container Tcp scaling rule.
    """
    def __init__(__self__, *,
                 auth: Optional[Sequence['outputs.ScaleRuleAuthResponse']] = None,
                 identity: Optional[_builtins.str] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None):
        """
        Container App container Tcp scaling rule.
        :param Sequence['ScaleRuleAuthResponse'] auth: Authentication secrets for the tcp scale rule.
        :param _builtins.str identity: The resource ID of a user-assigned managed identity that is assigned to the Container App, or 'system' for system-assigned identity.
        :param Mapping[str, _builtins.str] metadata: Metadata properties to describe tcp scale rule.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def auth(self) -> Optional[Sequence['outputs.ScaleRuleAuthResponse']]:
        """
        Authentication secrets for the tcp scale rule.
        """
        return pulumi.get(self, "auth")

    @_builtins.property
    @pulumi.getter
    def identity(self) -> Optional[_builtins.str]:
        """
        The resource ID of a user-assigned managed identity that is assigned to the Container App, or 'system' for system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Metadata properties to describe tcp scale rule.
        """
        return pulumi.get(self, "metadata")


@pulumi.output_type
class TemplateResponse(dict):
    """
    Container App versioned application definition.
    Defines the desired state of an immutable revision.
    Any changes to this section Will result in a new revision being created
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initContainers":
            suggest = "init_containers"
        elif key == "revisionSuffix":
            suggest = "revision_suffix"
        elif key == "serviceBinds":
            suggest = "service_binds"
        elif key == "terminationGracePeriodSeconds":
            suggest = "termination_grace_period_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 containers: Optional[Sequence['outputs.ContainerResponse']] = None,
                 init_containers: Optional[Sequence['outputs.InitContainerResponse']] = None,
                 revision_suffix: Optional[_builtins.str] = None,
                 scale: Optional['outputs.ScaleResponse'] = None,
                 service_binds: Optional[Sequence['outputs.ServiceBindResponse']] = None,
                 termination_grace_period_seconds: Optional[_builtins.float] = None,
                 volumes: Optional[Sequence['outputs.VolumeResponse']] = None):
        """
        Container App versioned application definition.
        Defines the desired state of an immutable revision.
        Any changes to this section Will result in a new revision being created
        :param Sequence['ContainerResponse'] containers: List of container definitions for the Container App.
        :param Sequence['InitContainerResponse'] init_containers: List of specialized containers that run before app containers.
        :param _builtins.str revision_suffix: User friendly suffix that is appended to the revision name
        :param 'ScaleResponse' scale: Scaling properties for the Container App.
        :param Sequence['ServiceBindResponse'] service_binds: List of container app services bound to the app
        :param _builtins.float termination_grace_period_seconds: Optional duration in seconds the Container App Instance needs to terminate gracefully. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
        :param Sequence['VolumeResponse'] volumes: List of volume definitions for the Container App.
        """
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if init_containers is not None:
            pulumi.set(__self__, "init_containers", init_containers)
        if revision_suffix is not None:
            pulumi.set(__self__, "revision_suffix", revision_suffix)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if service_binds is not None:
            pulumi.set(__self__, "service_binds", service_binds)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def containers(self) -> Optional[Sequence['outputs.ContainerResponse']]:
        """
        List of container definitions for the Container App.
        """
        return pulumi.get(self, "containers")

    @_builtins.property
    @pulumi.getter(name="initContainers")
    def init_containers(self) -> Optional[Sequence['outputs.InitContainerResponse']]:
        """
        List of specialized containers that run before app containers.
        """
        return pulumi.get(self, "init_containers")

    @_builtins.property
    @pulumi.getter(name="revisionSuffix")
    def revision_suffix(self) -> Optional[_builtins.str]:
        """
        User friendly suffix that is appended to the revision name
        """
        return pulumi.get(self, "revision_suffix")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional['outputs.ScaleResponse']:
        """
        Scaling properties for the Container App.
        """
        return pulumi.get(self, "scale")

    @_builtins.property
    @pulumi.getter(name="serviceBinds")
    def service_binds(self) -> Optional[Sequence['outputs.ServiceBindResponse']]:
        """
        List of container app services bound to the app
        """
        return pulumi.get(self, "service_binds")

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[_builtins.float]:
        """
        Optional duration in seconds the Container App Instance needs to terminate gracefully. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.VolumeResponse']]:
        """
        List of volume definitions for the Container App.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class TimeoutPolicyResponse(dict):
    """
    Policy to set request timeouts
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionTimeoutInSeconds":
            suggest = "connection_timeout_in_seconds"
        elif key == "responseTimeoutInSeconds":
            suggest = "response_timeout_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeoutPolicyResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeoutPolicyResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeoutPolicyResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_timeout_in_seconds: Optional[_builtins.int] = None,
                 response_timeout_in_seconds: Optional[_builtins.int] = None):
        """
        Policy to set request timeouts
        :param _builtins.int connection_timeout_in_seconds: Timeout, in seconds, for a request to initiate a connection
        :param _builtins.int response_timeout_in_seconds: Timeout, in seconds, for a request to respond
        """
        if connection_timeout_in_seconds is not None:
            pulumi.set(__self__, "connection_timeout_in_seconds", connection_timeout_in_seconds)
        if response_timeout_in_seconds is not None:
            pulumi.set(__self__, "response_timeout_in_seconds", response_timeout_in_seconds)

    @_builtins.property
    @pulumi.getter(name="connectionTimeoutInSeconds")
    def connection_timeout_in_seconds(self) -> Optional[_builtins.int]:
        """
        Timeout, in seconds, for a request to initiate a connection
        """
        return pulumi.get(self, "connection_timeout_in_seconds")

    @_builtins.property
    @pulumi.getter(name="responseTimeoutInSeconds")
    def response_timeout_in_seconds(self) -> Optional[_builtins.int]:
        """
        Timeout, in seconds, for a request to respond
        """
        return pulumi.get(self, "response_timeout_in_seconds")


@pulumi.output_type
class TokenStoreResponse(dict):
    """
    The configuration settings of the token store.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "tokenRefreshExtensionHours":
            suggest = "token_refresh_extension_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TokenStoreResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TokenStoreResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TokenStoreResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage: Optional['outputs.BlobStorageTokenStoreResponse'] = None,
                 enabled: Optional[_builtins.bool] = None,
                 token_refresh_extension_hours: Optional[_builtins.float] = None):
        """
        The configuration settings of the token store.
        :param 'BlobStorageTokenStoreResponse' azure_blob_storage: The configuration settings of the storage of the tokens if blob storage is used.
        :param _builtins.bool enabled: <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
                The default is <code>false</code>.
        :param _builtins.float token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to
               call the token refresh API. The default is 72 hours.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)

    @_builtins.property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.BlobStorageTokenStoreResponse']:
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        """
        return pulumi.get(self, "azure_blob_storage")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
         The default is <code>false</code>.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[_builtins.float]:
        """
        The number of hours after session token expiration that a session token can be used to
        call the token refresh API. The default is 72 hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")


@pulumi.output_type
class TracesConfigurationResponse(dict):
    """
    Configuration of Open Telemetry traces
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeDapr":
            suggest = "include_dapr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TracesConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TracesConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TracesConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destinations: Optional[Sequence[_builtins.str]] = None,
                 include_dapr: Optional[_builtins.bool] = None):
        """
        Configuration of Open Telemetry traces
        :param Sequence[_builtins.str] destinations: Open telemetry traces destinations
        :param _builtins.bool include_dapr: Boolean indicating if including dapr traces
        """
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if include_dapr is not None:
            pulumi.set(__self__, "include_dapr", include_dapr)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence[_builtins.str]]:
        """
        Open telemetry traces destinations
        """
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter(name="includeDapr")
    def include_dapr(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating if including dapr traces
        """
        return pulumi.get(self, "include_dapr")


@pulumi.output_type
class TrafficWeightResponse(dict):
    """
    Traffic weight assigned to a revision
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestRevision":
            suggest = "latest_revision"
        elif key == "revisionName":
            suggest = "revision_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficWeightResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficWeightResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficWeightResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label: Optional[_builtins.str] = None,
                 latest_revision: Optional[_builtins.bool] = None,
                 revision_name: Optional[_builtins.str] = None,
                 weight: Optional[_builtins.int] = None):
        """
        Traffic weight assigned to a revision
        :param _builtins.str label: Associates a traffic label with a revision
        :param _builtins.bool latest_revision: Indicates that the traffic weight belongs to a latest stable revision
        :param _builtins.str revision_name: Name of a revision
        :param _builtins.int weight: Traffic weight assigned to a revision
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if latest_revision is None:
            latest_revision = False
        if latest_revision is not None:
            pulumi.set(__self__, "latest_revision", latest_revision)
        if revision_name is not None:
            pulumi.set(__self__, "revision_name", revision_name)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Associates a traffic label with a revision
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter(name="latestRevision")
    def latest_revision(self) -> Optional[_builtins.bool]:
        """
        Indicates that the traffic weight belongs to a latest stable revision
        """
        return pulumi.get(self, "latest_revision")

    @_builtins.property
    @pulumi.getter(name="revisionName")
    def revision_name(self) -> Optional[_builtins.str]:
        """
        Name of a revision
        """
        return pulumi.get(self, "revision_name")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.int]:
        """
        Traffic weight assigned to a revision
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class TwitterRegistrationResponse(dict):
    """
    The configuration settings of the app registration for the Twitter provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecretSettingName":
            suggest = "consumer_secret_setting_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TwitterRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TwitterRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TwitterRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: Optional[_builtins.str] = None,
                 consumer_secret_setting_name: Optional[_builtins.str] = None):
        """
        The configuration settings of the app registration for the Twitter provider.
        :param _builtins.str consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
               This setting is required for enabling Twitter Sign-In.
               Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        :param _builtins.str consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
               application used for sign-in.
        """
        if consumer_key is not None:
            pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @_builtins.property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> Optional[_builtins.str]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        This setting is required for enabling Twitter Sign-In.
        Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        """
        return pulumi.get(self, "consumer_key")

    @_builtins.property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[_builtins.str]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
        application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")


@pulumi.output_type
class TwitterResponse(dict):
    """
    The configuration settings of the Twitter provider.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 registration: Optional['outputs.TwitterRegistrationResponse'] = None):
        """
        The configuration settings of the Twitter provider.
        :param _builtins.bool enabled: <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param 'TwitterRegistrationResponse' registration: The configuration settings of the app registration for the Twitter provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def registration(self) -> Optional['outputs.TwitterRegistrationResponse']:
        """
        The configuration settings of the app registration for the Twitter provider.
        """
        return pulumi.get(self, "registration")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 principal_id: _builtins.str):
        """
        User assigned identity properties
        :param _builtins.str client_id: The client ID of the assigned identity.
        :param _builtins.str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> _builtins.str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VnetConfigurationResponse(dict):
    """
    Configuration properties for apps environment to join a Virtual Network
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerBridgeCidr":
            suggest = "docker_bridge_cidr"
        elif key == "infrastructureSubnetId":
            suggest = "infrastructure_subnet_id"
        elif key == "platformReservedCidr":
            suggest = "platform_reserved_cidr"
        elif key == "platformReservedDnsIP":
            suggest = "platform_reserved_dns_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VnetConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VnetConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VnetConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_bridge_cidr: Optional[_builtins.str] = None,
                 infrastructure_subnet_id: Optional[_builtins.str] = None,
                 internal: Optional[_builtins.bool] = None,
                 platform_reserved_cidr: Optional[_builtins.str] = None,
                 platform_reserved_dns_ip: Optional[_builtins.str] = None):
        """
        Configuration properties for apps environment to join a Virtual Network
        :param _builtins.str docker_bridge_cidr: CIDR notation IP range assigned to the Docker bridge, network. Must not overlap with any other provided IP ranges.
        :param _builtins.str infrastructure_subnet_id: Resource ID of a subnet for infrastructure components. Must not overlap with any other provided IP ranges.
        :param _builtins.bool internal: Boolean indicating the environment only has an internal load balancer. These environments do not have a public static IP resource. They must provide infrastructureSubnetId if enabling this property
        :param _builtins.str platform_reserved_cidr: IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. Must not overlap with any other provided IP ranges.
        :param _builtins.str platform_reserved_dns_ip:  An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server.
        """
        if docker_bridge_cidr is not None:
            pulumi.set(__self__, "docker_bridge_cidr", docker_bridge_cidr)
        if infrastructure_subnet_id is not None:
            pulumi.set(__self__, "infrastructure_subnet_id", infrastructure_subnet_id)
        if internal is not None:
            pulumi.set(__self__, "internal", internal)
        if platform_reserved_cidr is not None:
            pulumi.set(__self__, "platform_reserved_cidr", platform_reserved_cidr)
        if platform_reserved_dns_ip is not None:
            pulumi.set(__self__, "platform_reserved_dns_ip", platform_reserved_dns_ip)

    @_builtins.property
    @pulumi.getter(name="dockerBridgeCidr")
    def docker_bridge_cidr(self) -> Optional[_builtins.str]:
        """
        CIDR notation IP range assigned to the Docker bridge, network. Must not overlap with any other provided IP ranges.
        """
        return pulumi.get(self, "docker_bridge_cidr")

    @_builtins.property
    @pulumi.getter(name="infrastructureSubnetId")
    def infrastructure_subnet_id(self) -> Optional[_builtins.str]:
        """
        Resource ID of a subnet for infrastructure components. Must not overlap with any other provided IP ranges.
        """
        return pulumi.get(self, "infrastructure_subnet_id")

    @_builtins.property
    @pulumi.getter
    def internal(self) -> Optional[_builtins.bool]:
        """
        Boolean indicating the environment only has an internal load balancer. These environments do not have a public static IP resource. They must provide infrastructureSubnetId if enabling this property
        """
        return pulumi.get(self, "internal")

    @_builtins.property
    @pulumi.getter(name="platformReservedCidr")
    def platform_reserved_cidr(self) -> Optional[_builtins.str]:
        """
        IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. Must not overlap with any other provided IP ranges.
        """
        return pulumi.get(self, "platform_reserved_cidr")

    @_builtins.property
    @pulumi.getter(name="platformReservedDnsIP")
    def platform_reserved_dns_ip(self) -> Optional[_builtins.str]:
        """
         An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server.
        """
        return pulumi.get(self, "platform_reserved_dns_ip")


@pulumi.output_type
class VolumeMountResponse(dict):
    """
    Volume mount for the Container App.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "subPath":
            suggest = "sub_path"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeMountResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeMountResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeMountResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: Optional[_builtins.str] = None,
                 sub_path: Optional[_builtins.str] = None,
                 volume_name: Optional[_builtins.str] = None):
        """
        Volume mount for the Container App.
        :param _builtins.str mount_path: Path within the container at which the volume should be mounted.Must not contain ':'.
        :param _builtins.str sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        :param _builtins.str volume_name: This must match the Name of a Volume.
        """
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[_builtins.str]:
        """
        Path within the container at which the volume should be mounted.Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @_builtins.property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[_builtins.str]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")

    @_builtins.property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[_builtins.str]:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class VolumeResponse(dict):
    """
    Volume definitions for the Container App.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountOptions":
            suggest = "mount_options"
        elif key == "storageName":
            suggest = "storage_name"
        elif key == "storageType":
            suggest = "storage_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_options: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secrets: Optional[Sequence['outputs.SecretVolumeItemResponse']] = None,
                 storage_name: Optional[_builtins.str] = None,
                 storage_type: Optional[_builtins.str] = None):
        """
        Volume definitions for the Container App.
        :param _builtins.str mount_options: Mount options used while mounting the Azure file share or NFS Azure file share. Must be a comma-separated string.
        :param _builtins.str name: Volume name.
        :param Sequence['SecretVolumeItemResponse'] secrets: List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
        :param _builtins.str storage_name: Name of storage resource. No need to provide for EmptyDir and Secret.
        :param _builtins.str storage_type: Storage type for the volume. If not provided, use EmptyDir.
        """
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if storage_name is not None:
            pulumi.set(__self__, "storage_name", storage_name)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @_builtins.property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[_builtins.str]:
        """
        Mount options used while mounting the Azure file share or NFS Azure file share. Must be a comma-separated string.
        """
        return pulumi.get(self, "mount_options")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Volume name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.SecretVolumeItemResponse']]:
        """
        List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
        """
        return pulumi.get(self, "secrets")

    @_builtins.property
    @pulumi.getter(name="storageName")
    def storage_name(self) -> Optional[_builtins.str]:
        """
        Name of storage resource. No need to provide for EmptyDir and Secret.
        """
        return pulumi.get(self, "storage_name")

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[_builtins.str]:
        """
        Storage type for the volume. If not provided, use EmptyDir.
        """
        return pulumi.get(self, "storage_type")


@pulumi.output_type
class WorkflowEnvelopeResponseProperties(dict):
    """
    Additional workflow properties.
    """
    def __init__(__self__, *,
                 files: Optional[Any] = None,
                 flow_state: Optional[_builtins.str] = None,
                 health: Optional['outputs.WorkflowHealthResponse'] = None):
        """
        Additional workflow properties.
        :param Any files: Gets or sets the files.
        :param _builtins.str flow_state: Gets or sets the state of the workflow.
        :param 'WorkflowHealthResponse' health: Gets or sets workflow health.
        """
        if files is not None:
            pulumi.set(__self__, "files", files)
        if flow_state is not None:
            pulumi.set(__self__, "flow_state", flow_state)
        if health is not None:
            pulumi.set(__self__, "health", health)

    @_builtins.property
    @pulumi.getter
    def files(self) -> Optional[Any]:
        """
        Gets or sets the files.
        """
        return pulumi.get(self, "files")

    @_builtins.property
    @pulumi.getter(name="flowState")
    def flow_state(self) -> Optional[_builtins.str]:
        """
        Gets or sets the state of the workflow.
        """
        return pulumi.get(self, "flow_state")

    @_builtins.property
    @pulumi.getter
    def health(self) -> Optional['outputs.WorkflowHealthResponse']:
        """
        Gets or sets workflow health.
        """
        return pulumi.get(self, "health")


@pulumi.output_type
class WorkflowHealthResponse(dict):
    """
    Represents the workflow health.
    """
    def __init__(__self__, *,
                 state: _builtins.str,
                 error: Optional['outputs.ErrorEntityResponse'] = None):
        """
        Represents the workflow health.
        :param _builtins.str state: Gets or sets the workflow health state.
        :param 'ErrorEntityResponse' error: Gets or sets the workflow error.
        """
        pulumi.set(__self__, "state", state)
        if error is not None:
            pulumi.set(__self__, "error", error)

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Gets or sets the workflow health state.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional['outputs.ErrorEntityResponse']:
        """
        Gets or sets the workflow error.
        """
        return pulumi.get(self, "error")


@pulumi.output_type
class WorkloadProfileResponse(dict):
    """
    Workload profile to scope container app execution.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workloadProfileType":
            suggest = "workload_profile_type"
        elif key == "enableFips":
            suggest = "enable_fips"
        elif key == "maximumCount":
            suggest = "maximum_count"
        elif key == "minimumCount":
            suggest = "minimum_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadProfileResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadProfileResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadProfileResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 workload_profile_type: _builtins.str,
                 enable_fips: Optional[_builtins.bool] = None,
                 maximum_count: Optional[_builtins.int] = None,
                 minimum_count: Optional[_builtins.int] = None):
        """
        Workload profile to scope container app execution.
        :param _builtins.str name: Workload profile type for the workloads to run on.
        :param _builtins.str workload_profile_type: Workload profile type for the workloads to run on.
        :param _builtins.bool enable_fips: Whether to use a FIPS-enabled OS. Supported only for dedicated workload profiles.
        :param _builtins.int maximum_count: The maximum capacity.
        :param _builtins.int minimum_count: The minimum capacity.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "workload_profile_type", workload_profile_type)
        if enable_fips is None:
            enable_fips = False
        if enable_fips is not None:
            pulumi.set(__self__, "enable_fips", enable_fips)
        if maximum_count is not None:
            pulumi.set(__self__, "maximum_count", maximum_count)
        if minimum_count is not None:
            pulumi.set(__self__, "minimum_count", minimum_count)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Workload profile type for the workloads to run on.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="workloadProfileType")
    def workload_profile_type(self) -> _builtins.str:
        """
        Workload profile type for the workloads to run on.
        """
        return pulumi.get(self, "workload_profile_type")

    @_builtins.property
    @pulumi.getter(name="enableFips")
    def enable_fips(self) -> Optional[_builtins.bool]:
        """
        Whether to use a FIPS-enabled OS. Supported only for dedicated workload profiles.
        """
        return pulumi.get(self, "enable_fips")

    @_builtins.property
    @pulumi.getter(name="maximumCount")
    def maximum_count(self) -> Optional[_builtins.int]:
        """
        The maximum capacity.
        """
        return pulumi.get(self, "maximum_count")

    @_builtins.property
    @pulumi.getter(name="minimumCount")
    def minimum_count(self) -> Optional[_builtins.int]:
        """
        The minimum capacity.
        """
        return pulumi.get(self, "minimum_count")


