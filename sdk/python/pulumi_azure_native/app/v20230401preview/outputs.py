# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ContainerAppProbeResponse',
    'ContainerAppProbeResponseHttpGet',
    'ContainerAppProbeResponseHttpHeaders',
    'ContainerAppProbeResponseTcpSocket',
    'ContainerResourcesResponse',
    'ContainerResponse',
    'EnvironmentVarResponse',
    'InitContainerResponse',
    'JobConfigurationResponse',
    'JobConfigurationResponseEventTriggerConfig',
    'JobConfigurationResponseManualTriggerConfig',
    'JobConfigurationResponseScheduleTriggerConfig',
    'JobScaleResponse',
    'JobScaleRuleResponse',
    'JobTemplateResponse',
    'ManagedCertificateResponseProperties',
    'ManagedServiceIdentityResponse',
    'RegistryCredentialsResponse',
    'ScaleRuleAuthResponse',
    'SecretResponse',
    'SecretVolumeItemResponse',
    'SystemDataResponse',
    'UserAssignedIdentityResponse',
    'VolumeMountResponse',
    'VolumeResponse',
]

@pulumi.output_type
class ContainerAppProbeResponse(dict):
    """
    Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSocket":
            suggest = "tcp_socket"
        elif key == "terminationGracePeriodSeconds":
            suggest = "termination_grace_period_seconds"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerAppProbeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerAppProbeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerAppProbeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_threshold: Optional[int] = None,
                 http_get: Optional['outputs.ContainerAppProbeResponseHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_socket: Optional['outputs.ContainerAppProbeResponseTcpSocket'] = None,
                 termination_grace_period_seconds: Optional[float] = None,
                 timeout_seconds: Optional[int] = None,
                 type: Optional[str] = None):
        """
        Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
        :param int failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        :param 'ContainerAppProbeResponseHttpGet' http_get: HTTPGet specifies the http request to perform.
        :param int initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        :param int period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        :param int success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        :param 'ContainerAppProbeResponseTcpSocket' tcp_socket: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        :param float termination_grace_period_seconds: Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        :param int timeout_seconds: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        :param str type: The type of probe.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        """
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.ContainerAppProbeResponseHttpGet']:
        """
        HTTPGet specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        """
        Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        """
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        """
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.ContainerAppProbeResponseTcpSocket']:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        """
        return pulumi.get(self, "tcp_socket")

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[float]:
        """
        Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        """
        Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        """
        return pulumi.get(self, "timeout_seconds")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of probe.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ContainerAppProbeResponseHttpGet(dict):
    """
    HTTPGet specifies the http request to perform.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerAppProbeResponseHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerAppProbeResponseHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerAppProbeResponseHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 host: Optional[str] = None,
                 http_headers: Optional[Sequence['outputs.ContainerAppProbeResponseHttpHeaders']] = None,
                 path: Optional[str] = None,
                 scheme: Optional[str] = None):
        """
        HTTPGet specifies the http request to perform.
        :param int port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param Sequence['ContainerAppProbeResponseHttpHeaders'] http_headers: Custom headers to set in the request. HTTP allows repeated headers.
        :param str path: Path to access on the HTTP server.
        :param str scheme: Scheme to use for connecting to the host. Defaults to HTTP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Sequence['outputs.ContainerAppProbeResponseHttpHeaders']]:
        """
        Custom headers to set in the request. HTTP allows repeated headers.
        """
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Scheme to use for connecting to the host. Defaults to HTTP.
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class ContainerAppProbeResponseHttpHeaders(dict):
    """
    HTTPHeader describes a custom header to be used in HTTP probes
    """
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        HTTPHeader describes a custom header to be used in HTTP probes
        :param str name: The header field name
        :param str value: The header field value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The header field value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ContainerAppProbeResponseTcpSocket(dict):
    """
    TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
    """
    def __init__(__self__, *,
                 port: int,
                 host: Optional[str] = None):
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        :param int port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param str host: Optional: Host name to connect to, defaults to the pod IP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Optional: Host name to connect to, defaults to the pod IP.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class ContainerResourcesResponse(dict):
    """
    Container App container resource requirements.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ephemeralStorage":
            suggest = "ephemeral_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerResourcesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerResourcesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerResourcesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ephemeral_storage: str,
                 cpu: Optional[float] = None,
                 memory: Optional[str] = None):
        """
        Container App container resource requirements.
        :param str ephemeral_storage: Ephemeral Storage, e.g. "1Gi"
        :param float cpu: Required CPU in cores, e.g. 0.5
        :param str memory: Required memory, e.g. "250Mb"
        """
        pulumi.set(__self__, "ephemeral_storage", ephemeral_storage)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter(name="ephemeralStorage")
    def ephemeral_storage(self) -> str:
        """
        Ephemeral Storage, e.g. "1Gi"
        """
        return pulumi.get(self, "ephemeral_storage")

    @property
    @pulumi.getter
    def cpu(self) -> Optional[float]:
        """
        Required CPU in cores, e.g. 0.5
        """
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> Optional[str]:
        """
        Required memory, e.g. "250Mb"
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class ContainerResponse(dict):
    """
    Container App container definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeMounts":
            suggest = "volume_mounts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 args: Optional[Sequence[str]] = None,
                 command: Optional[Sequence[str]] = None,
                 env: Optional[Sequence['outputs.EnvironmentVarResponse']] = None,
                 image: Optional[str] = None,
                 name: Optional[str] = None,
                 probes: Optional[Sequence['outputs.ContainerAppProbeResponse']] = None,
                 resources: Optional['outputs.ContainerResourcesResponse'] = None,
                 volume_mounts: Optional[Sequence['outputs.VolumeMountResponse']] = None):
        """
        Container App container definition
        :param Sequence[str] args: Container start command arguments.
        :param Sequence[str] command: Container start command.
        :param Sequence['EnvironmentVarResponse'] env: Container environment variables.
        :param str image: Container image tag.
        :param str name: Custom container name.
        :param Sequence['ContainerAppProbeResponse'] probes: List of probes for the container.
        :param 'ContainerResourcesResponse' resources: Container resource requirements.
        :param Sequence['VolumeMountResponse'] volume_mounts: Container volume mounts.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Container start command arguments.
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def command(self) -> Optional[Sequence[str]]:
        """
        Container start command.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.EnvironmentVarResponse']]:
        """
        Container environment variables.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Container image tag.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom container name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def probes(self) -> Optional[Sequence['outputs.ContainerAppProbeResponse']]:
        """
        List of probes for the container.
        """
        return pulumi.get(self, "probes")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.ContainerResourcesResponse']:
        """
        Container resource requirements.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[Sequence['outputs.VolumeMountResponse']]:
        """
        Container volume mounts.
        """
        return pulumi.get(self, "volume_mounts")


@pulumi.output_type
class EnvironmentVarResponse(dict):
    """
    Container App container environment variable.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentVarResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentVarResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentVarResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 secret_ref: Optional[str] = None,
                 value: Optional[str] = None):
        """
        Container App container environment variable.
        :param str name: Environment variable name.
        :param str secret_ref: Name of the Container App secret from which to pull the environment variable value.
        :param str value: Non-secret environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Environment variable name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[str]:
        """
        Name of the Container App secret from which to pull the environment variable value.
        """
        return pulumi.get(self, "secret_ref")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Non-secret environment variable value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InitContainerResponse(dict):
    """
    Container App init container definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeMounts":
            suggest = "volume_mounts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InitContainerResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InitContainerResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InitContainerResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 args: Optional[Sequence[str]] = None,
                 command: Optional[Sequence[str]] = None,
                 env: Optional[Sequence['outputs.EnvironmentVarResponse']] = None,
                 image: Optional[str] = None,
                 name: Optional[str] = None,
                 resources: Optional['outputs.ContainerResourcesResponse'] = None,
                 volume_mounts: Optional[Sequence['outputs.VolumeMountResponse']] = None):
        """
        Container App init container definition
        :param Sequence[str] args: Container start command arguments.
        :param Sequence[str] command: Container start command.
        :param Sequence['EnvironmentVarResponse'] env: Container environment variables.
        :param str image: Container image tag.
        :param str name: Custom container name.
        :param 'ContainerResourcesResponse' resources: Container resource requirements.
        :param Sequence['VolumeMountResponse'] volume_mounts: Container volume mounts.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Container start command arguments.
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def command(self) -> Optional[Sequence[str]]:
        """
        Container start command.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def env(self) -> Optional[Sequence['outputs.EnvironmentVarResponse']]:
        """
        Container environment variables.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        Container image tag.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom container name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.ContainerResourcesResponse']:
        """
        Container resource requirements.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[Sequence['outputs.VolumeMountResponse']]:
        """
        Container volume mounts.
        """
        return pulumi.get(self, "volume_mounts")


@pulumi.output_type
class JobConfigurationResponse(dict):
    """
    Non versioned Container Apps Job configuration properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicaTimeout":
            suggest = "replica_timeout"
        elif key == "triggerType":
            suggest = "trigger_type"
        elif key == "eventTriggerConfig":
            suggest = "event_trigger_config"
        elif key == "manualTriggerConfig":
            suggest = "manual_trigger_config"
        elif key == "replicaRetryLimit":
            suggest = "replica_retry_limit"
        elif key == "scheduleTriggerConfig":
            suggest = "schedule_trigger_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobConfigurationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobConfigurationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobConfigurationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replica_timeout: int,
                 trigger_type: Optional[str] = None,
                 event_trigger_config: Optional['outputs.JobConfigurationResponseEventTriggerConfig'] = None,
                 manual_trigger_config: Optional['outputs.JobConfigurationResponseManualTriggerConfig'] = None,
                 registries: Optional[Sequence['outputs.RegistryCredentialsResponse']] = None,
                 replica_retry_limit: Optional[int] = None,
                 schedule_trigger_config: Optional['outputs.JobConfigurationResponseScheduleTriggerConfig'] = None,
                 secrets: Optional[Sequence['outputs.SecretResponse']] = None):
        """
        Non versioned Container Apps Job configuration properties
        :param int replica_timeout: Maximum number of seconds a replica is allowed to run.
        :param str trigger_type: Trigger type of the job
        :param 'JobConfigurationResponseEventTriggerConfig' event_trigger_config: Trigger configuration of an event driven job.
        :param 'JobConfigurationResponseManualTriggerConfig' manual_trigger_config: Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        :param Sequence['RegistryCredentialsResponse'] registries: Collection of private container registry credentials used by a Container apps job
        :param int replica_retry_limit: Maximum number of retries before failing the job.
        :param 'JobConfigurationResponseScheduleTriggerConfig' schedule_trigger_config: Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        :param Sequence['SecretResponse'] secrets: Collection of secrets used by a Container Apps Job
        """
        pulumi.set(__self__, "replica_timeout", replica_timeout)
        if trigger_type is None:
            trigger_type = 'Manual'
        pulumi.set(__self__, "trigger_type", trigger_type)
        if event_trigger_config is not None:
            pulumi.set(__self__, "event_trigger_config", event_trigger_config)
        if manual_trigger_config is not None:
            pulumi.set(__self__, "manual_trigger_config", manual_trigger_config)
        if registries is not None:
            pulumi.set(__self__, "registries", registries)
        if replica_retry_limit is not None:
            pulumi.set(__self__, "replica_retry_limit", replica_retry_limit)
        if schedule_trigger_config is not None:
            pulumi.set(__self__, "schedule_trigger_config", schedule_trigger_config)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter(name="replicaTimeout")
    def replica_timeout(self) -> int:
        """
        Maximum number of seconds a replica is allowed to run.
        """
        return pulumi.get(self, "replica_timeout")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> str:
        """
        Trigger type of the job
        """
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter(name="eventTriggerConfig")
    def event_trigger_config(self) -> Optional['outputs.JobConfigurationResponseEventTriggerConfig']:
        """
        Trigger configuration of an event driven job.
        """
        return pulumi.get(self, "event_trigger_config")

    @property
    @pulumi.getter(name="manualTriggerConfig")
    def manual_trigger_config(self) -> Optional['outputs.JobConfigurationResponseManualTriggerConfig']:
        """
        Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        """
        return pulumi.get(self, "manual_trigger_config")

    @property
    @pulumi.getter
    def registries(self) -> Optional[Sequence['outputs.RegistryCredentialsResponse']]:
        """
        Collection of private container registry credentials used by a Container apps job
        """
        return pulumi.get(self, "registries")

    @property
    @pulumi.getter(name="replicaRetryLimit")
    def replica_retry_limit(self) -> Optional[int]:
        """
        Maximum number of retries before failing the job.
        """
        return pulumi.get(self, "replica_retry_limit")

    @property
    @pulumi.getter(name="scheduleTriggerConfig")
    def schedule_trigger_config(self) -> Optional['outputs.JobConfigurationResponseScheduleTriggerConfig']:
        """
        Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        """
        return pulumi.get(self, "schedule_trigger_config")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.SecretResponse']]:
        """
        Collection of secrets used by a Container Apps Job
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class JobConfigurationResponseEventTriggerConfig(dict):
    """
    Trigger configuration of an event driven job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicaCompletionCount":
            suggest = "replica_completion_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobConfigurationResponseEventTriggerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobConfigurationResponseEventTriggerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobConfigurationResponseEventTriggerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parallelism: Optional[int] = None,
                 replica_completion_count: Optional[int] = None,
                 scale: Optional['outputs.JobScaleResponse'] = None):
        """
        Trigger configuration of an event driven job.
        :param int parallelism: Number of parallel replicas of a job that can run at a given time.
        :param int replica_completion_count: Minimum number of successful replica completions before overall job completion.
        :param 'JobScaleResponse' scale: Scaling configurations for event driven jobs.
        """
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if replica_completion_count is not None:
            pulumi.set(__self__, "replica_completion_count", replica_completion_count)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[int]:
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        return pulumi.get(self, "parallelism")

    @property
    @pulumi.getter(name="replicaCompletionCount")
    def replica_completion_count(self) -> Optional[int]:
        """
        Minimum number of successful replica completions before overall job completion.
        """
        return pulumi.get(self, "replica_completion_count")

    @property
    @pulumi.getter
    def scale(self) -> Optional['outputs.JobScaleResponse']:
        """
        Scaling configurations for event driven jobs.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class JobConfigurationResponseManualTriggerConfig(dict):
    """
    Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicaCompletionCount":
            suggest = "replica_completion_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobConfigurationResponseManualTriggerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobConfigurationResponseManualTriggerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobConfigurationResponseManualTriggerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parallelism: Optional[int] = None,
                 replica_completion_count: Optional[int] = None):
        """
        Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        :param int parallelism: Number of parallel replicas of a job that can run at a given time.
        :param int replica_completion_count: Minimum number of successful replica completions before overall job completion.
        """
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if replica_completion_count is not None:
            pulumi.set(__self__, "replica_completion_count", replica_completion_count)

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[int]:
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        return pulumi.get(self, "parallelism")

    @property
    @pulumi.getter(name="replicaCompletionCount")
    def replica_completion_count(self) -> Optional[int]:
        """
        Minimum number of successful replica completions before overall job completion.
        """
        return pulumi.get(self, "replica_completion_count")


@pulumi.output_type
class JobConfigurationResponseScheduleTriggerConfig(dict):
    """
    Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cronExpression":
            suggest = "cron_expression"
        elif key == "replicaCompletionCount":
            suggest = "replica_completion_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobConfigurationResponseScheduleTriggerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobConfigurationResponseScheduleTriggerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobConfigurationResponseScheduleTriggerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cron_expression: str,
                 parallelism: Optional[int] = None,
                 replica_completion_count: Optional[int] = None):
        """
        Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        :param str cron_expression: Cron formatted repeating schedule ("* * * * *") of a Cron Job.
        :param int parallelism: Number of parallel replicas of a job that can run at a given time.
        :param int replica_completion_count: Minimum number of successful replica completions before overall job completion.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if replica_completion_count is not None:
            pulumi.set(__self__, "replica_completion_count", replica_completion_count)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> str:
        """
        Cron formatted repeating schedule ("* * * * *") of a Cron Job.
        """
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[int]:
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        return pulumi.get(self, "parallelism")

    @property
    @pulumi.getter(name="replicaCompletionCount")
    def replica_completion_count(self) -> Optional[int]:
        """
        Minimum number of successful replica completions before overall job completion.
        """
        return pulumi.get(self, "replica_completion_count")


@pulumi.output_type
class JobScaleResponse(dict):
    """
    Scaling configurations for event driven jobs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxExecutions":
            suggest = "max_executions"
        elif key == "minExecutions":
            suggest = "min_executions"
        elif key == "pollingInterval":
            suggest = "polling_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobScaleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobScaleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobScaleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_executions: Optional[int] = None,
                 min_executions: Optional[int] = None,
                 polling_interval: Optional[int] = None,
                 rules: Optional[Sequence['outputs.JobScaleRuleResponse']] = None):
        """
        Scaling configurations for event driven jobs.
        :param int max_executions: Maximum number of job executions that are created for a trigger, default 100.
        :param int min_executions: Minimum number of job executions that are created for a trigger, default 0
        :param int polling_interval: Interval to check each event source in seconds. Defaults to 30s
        :param Sequence['JobScaleRuleResponse'] rules: Scaling rules.
        """
        if max_executions is None:
            max_executions = 100
        if max_executions is not None:
            pulumi.set(__self__, "max_executions", max_executions)
        if min_executions is None:
            min_executions = 0
        if min_executions is not None:
            pulumi.set(__self__, "min_executions", min_executions)
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="maxExecutions")
    def max_executions(self) -> Optional[int]:
        """
        Maximum number of job executions that are created for a trigger, default 100.
        """
        return pulumi.get(self, "max_executions")

    @property
    @pulumi.getter(name="minExecutions")
    def min_executions(self) -> Optional[int]:
        """
        Minimum number of job executions that are created for a trigger, default 0
        """
        return pulumi.get(self, "min_executions")

    @property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[int]:
        """
        Interval to check each event source in seconds. Defaults to 30s
        """
        return pulumi.get(self, "polling_interval")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.JobScaleRuleResponse']]:
        """
        Scaling rules.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class JobScaleRuleResponse(dict):
    """
    Scaling rule.
    """
    def __init__(__self__, *,
                 auth: Optional[Sequence['outputs.ScaleRuleAuthResponse']] = None,
                 metadata: Optional[Any] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        Scaling rule.
        :param Sequence['ScaleRuleAuthResponse'] auth: Authentication secrets for the scale rule.
        :param Any metadata: Metadata properties to describe the scale rule.
        :param str name: Scale Rule Name
        :param str type: Type of the scale rule
               eg: azure-servicebus, redis etc.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def auth(self) -> Optional[Sequence['outputs.ScaleRuleAuthResponse']]:
        """
        Authentication secrets for the scale rule.
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Any]:
        """
        Metadata properties to describe the scale rule.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Scale Rule Name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the scale rule
        eg: azure-servicebus, redis etc.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class JobTemplateResponse(dict):
    """
    Container Apps Job versioned application definition. Defines the desired state of an immutable revision. Any changes to this section Will result in a new revision being created
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initContainers":
            suggest = "init_containers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTemplateResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTemplateResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTemplateResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 containers: Optional[Sequence['outputs.ContainerResponse']] = None,
                 init_containers: Optional[Sequence['outputs.InitContainerResponse']] = None,
                 volumes: Optional[Sequence['outputs.VolumeResponse']] = None):
        """
        Container Apps Job versioned application definition. Defines the desired state of an immutable revision. Any changes to this section Will result in a new revision being created
        :param Sequence['ContainerResponse'] containers: List of container definitions for the Container App.
        :param Sequence['InitContainerResponse'] init_containers: List of specialized containers that run before app containers.
        :param Sequence['VolumeResponse'] volumes: List of volume definitions for the Container App.
        """
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if init_containers is not None:
            pulumi.set(__self__, "init_containers", init_containers)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def containers(self) -> Optional[Sequence['outputs.ContainerResponse']]:
        """
        List of container definitions for the Container App.
        """
        return pulumi.get(self, "containers")

    @property
    @pulumi.getter(name="initContainers")
    def init_containers(self) -> Optional[Sequence['outputs.InitContainerResponse']]:
        """
        List of specialized containers that run before app containers.
        """
        return pulumi.get(self, "init_containers")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.VolumeResponse']]:
        """
        List of volume definitions for the Container App.
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class ManagedCertificateResponseProperties(dict):
    """
    Certificate resource specific properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "validationToken":
            suggest = "validation_token"
        elif key == "domainControlValidation":
            suggest = "domain_control_validation"
        elif key == "subjectName":
            suggest = "subject_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedCertificateResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedCertificateResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedCertificateResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: str,
                 provisioning_state: str,
                 validation_token: str,
                 domain_control_validation: Optional[str] = None,
                 subject_name: Optional[str] = None):
        """
        Certificate resource specific properties
        :param str error: Any error occurred during the certificate provision.
        :param str provisioning_state: Provisioning state of the certificate.
        :param str validation_token: A TXT token used for DNS TXT domain control validation when issuing this type of managed certificates.
        :param str domain_control_validation: Selected type of domain control validation for managed certificates.
        :param str subject_name: Subject name of the certificate.
        """
        pulumi.set(__self__, "error", error)
        pulumi.set(__self__, "provisioning_state", provisioning_state)
        pulumi.set(__self__, "validation_token", validation_token)
        if domain_control_validation is not None:
            pulumi.set(__self__, "domain_control_validation", domain_control_validation)
        if subject_name is not None:
            pulumi.set(__self__, "subject_name", subject_name)

    @property
    @pulumi.getter
    def error(self) -> str:
        """
        Any error occurred during the certificate provision.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> str:
        """
        Provisioning state of the certificate.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="validationToken")
    def validation_token(self) -> str:
        """
        A TXT token used for DNS TXT domain control validation when issuing this type of managed certificates.
        """
        return pulumi.get(self, "validation_token")

    @property
    @pulumi.getter(name="domainControlValidation")
    def domain_control_validation(self) -> Optional[str]:
        """
        Selected type of domain control validation for managed certificates.
        """
        return pulumi.get(self, "domain_control_validation")

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> Optional[str]:
        """
        Subject name of the certificate.
        """
        return pulumi.get(self, "subject_name")


@pulumi.output_type
class ManagedServiceIdentityResponse(dict):
    """
    Managed service identity (system assigned and/or user assigned identities)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userAssignedIdentities":
            suggest = "user_assigned_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedServiceIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedServiceIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 tenant_id: str,
                 type: str,
                 user_assigned_identities: Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param str principal_id: The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str tenant_id: The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        :param str type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param Mapping[str, 'UserAssignedIdentityResponse'] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "principal_id", principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[Mapping[str, 'outputs.UserAssignedIdentityResponse']]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")


@pulumi.output_type
class RegistryCredentialsResponse(dict):
    """
    Container App Private Registry
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordSecretRef":
            suggest = "password_secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryCredentialsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryCredentialsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryCredentialsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: Optional[str] = None,
                 password_secret_ref: Optional[str] = None,
                 server: Optional[str] = None,
                 username: Optional[str] = None):
        """
        Container App Private Registry
        :param str identity: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        :param str password_secret_ref: The name of the Secret that contains the registry login password
        :param str server: Container Registry Server
        :param str username: Container Registry Username
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if password_secret_ref is not None:
            pulumi.set(__self__, "password_secret_ref", password_secret_ref)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def identity(self) -> Optional[str]:
        """
        A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="passwordSecretRef")
    def password_secret_ref(self) -> Optional[str]:
        """
        The name of the Secret that contains the registry login password
        """
        return pulumi.get(self, "password_secret_ref")

    @property
    @pulumi.getter
    def server(self) -> Optional[str]:
        """
        Container Registry Server
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Container Registry Username
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ScaleRuleAuthResponse(dict):
    """
    Auth Secrets for Scale Rule
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"
        elif key == "triggerParameter":
            suggest = "trigger_parameter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScaleRuleAuthResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScaleRuleAuthResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScaleRuleAuthResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_ref: Optional[str] = None,
                 trigger_parameter: Optional[str] = None):
        """
        Auth Secrets for Scale Rule
        :param str secret_ref: Name of the secret from which to pull the auth params.
        :param str trigger_parameter: Trigger Parameter that uses the secret
        """
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if trigger_parameter is not None:
            pulumi.set(__self__, "trigger_parameter", trigger_parameter)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[str]:
        """
        Name of the secret from which to pull the auth params.
        """
        return pulumi.get(self, "secret_ref")

    @property
    @pulumi.getter(name="triggerParameter")
    def trigger_parameter(self) -> Optional[str]:
        """
        Trigger Parameter that uses the secret
        """
        return pulumi.get(self, "trigger_parameter")


@pulumi.output_type
class SecretResponse(dict):
    """
    Secret definition.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVaultUrl":
            suggest = "key_vault_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity: Optional[str] = None,
                 key_vault_url: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Secret definition.
        :param str identity: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        :param str key_vault_url: Azure Key Vault URL pointing to the secret referenced by the container app.
        :param str name: Secret Name.
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if key_vault_url is not None:
            pulumi.set(__self__, "key_vault_url", key_vault_url)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def identity(self) -> Optional[str]:
        """
        Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @property
    @pulumi.getter(name="keyVaultUrl")
    def key_vault_url(self) -> Optional[str]:
        """
        Azure Key Vault URL pointing to the secret referenced by the container app.
        """
        return pulumi.get(self, "key_vault_url")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Secret Name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecretVolumeItemResponse(dict):
    """
    Secret to be added to volume.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretVolumeItemResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretVolumeItemResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretVolumeItemResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: Optional[str] = None,
                 secret_ref: Optional[str] = None):
        """
        Secret to be added to volume.
        :param str path: Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
        :param str secret_ref: Name of the Container App secret from which to pull the secret value.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[str]:
        """
        Name of the Container App secret from which to pull the secret value.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if created_by_type is not None:
            pulumi.set(__self__, "created_by_type", created_by_type)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if last_modified_by is not None:
            pulumi.set(__self__, "last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            pulumi.set(__self__, "last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class UserAssignedIdentityResponse(dict):
    """
    User assigned identity properties
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "principalId":
            suggest = "principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserAssignedIdentityResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserAssignedIdentityResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 principal_id: str):
        """
        User assigned identity properties
        :param str client_id: The client ID of the assigned identity.
        :param str principal_id: The principal ID of the assigned identity.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "principal_id", principal_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the assigned identity.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        """
        The principal ID of the assigned identity.
        """
        return pulumi.get(self, "principal_id")


@pulumi.output_type
class VolumeMountResponse(dict):
    """
    Volume mount for the Container App.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPath":
            suggest = "mount_path"
        elif key == "subPath":
            suggest = "sub_path"
        elif key == "volumeName":
            suggest = "volume_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeMountResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeMountResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeMountResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_path: Optional[str] = None,
                 sub_path: Optional[str] = None,
                 volume_name: Optional[str] = None):
        """
        Volume mount for the Container App.
        :param str mount_path: Path within the container at which the volume should be mounted.Must not contain ':'.
        :param str sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        :param str volume_name: This must match the Name of a Volume.
        """
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[str]:
        """
        Path within the container at which the volume should be mounted.Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[str]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[str]:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "volume_name")


@pulumi.output_type
class VolumeResponse(dict):
    """
    Volume definitions for the Container App.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountOptions":
            suggest = "mount_options"
        elif key == "storageName":
            suggest = "storage_name"
        elif key == "storageType":
            suggest = "storage_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mount_options: Optional[str] = None,
                 name: Optional[str] = None,
                 secrets: Optional[Sequence['outputs.SecretVolumeItemResponse']] = None,
                 storage_name: Optional[str] = None,
                 storage_type: Optional[str] = None):
        """
        Volume definitions for the Container App.
        :param str mount_options: Mount options used while mounting the AzureFile. Must be a comma-separated string.
        :param str name: Volume name.
        :param Sequence['SecretVolumeItemResponse'] secrets: List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
        :param str storage_name: Name of storage resource. No need to provide for EmptyDir and Secret.
        :param str storage_type: Storage type for the volume. If not provided, use EmptyDir.
        """
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if storage_name is not None:
            pulumi.set(__self__, "storage_name", storage_name)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[str]:
        """
        Mount options used while mounting the AzureFile. Must be a comma-separated string.
        """
        return pulumi.get(self, "mount_options")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Volume name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.SecretVolumeItemResponse']]:
        """
        List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
        """
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter(name="storageName")
    def storage_name(self) -> Optional[str]:
        """
        Name of storage resource. No need to provide for EmptyDir and Secret.
        """
        return pulumi.get(self, "storage_name")

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[str]:
        """
        Storage type for the volume. If not provided, use EmptyDir.
        """
        return pulumi.get(self, "storage_type")


