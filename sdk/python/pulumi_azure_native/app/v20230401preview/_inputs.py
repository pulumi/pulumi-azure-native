# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ._enums import *

__all__ = [
    'ContainerAppProbeHttpGetArgs',
    'ContainerAppProbeHttpGetArgsDict',
    'ContainerAppProbeHttpHeadersArgs',
    'ContainerAppProbeHttpHeadersArgsDict',
    'ContainerAppProbeTcpSocketArgs',
    'ContainerAppProbeTcpSocketArgsDict',
    'ContainerAppProbeArgs',
    'ContainerAppProbeArgsDict',
    'ContainerResourcesArgs',
    'ContainerResourcesArgsDict',
    'ContainerArgs',
    'ContainerArgsDict',
    'EnvironmentVarArgs',
    'EnvironmentVarArgsDict',
    'InitContainerArgs',
    'InitContainerArgsDict',
    'JobConfigurationEventTriggerConfigArgs',
    'JobConfigurationEventTriggerConfigArgsDict',
    'JobConfigurationManualTriggerConfigArgs',
    'JobConfigurationManualTriggerConfigArgsDict',
    'JobConfigurationScheduleTriggerConfigArgs',
    'JobConfigurationScheduleTriggerConfigArgsDict',
    'JobConfigurationArgs',
    'JobConfigurationArgsDict',
    'JobScaleRuleArgs',
    'JobScaleRuleArgsDict',
    'JobScaleArgs',
    'JobScaleArgsDict',
    'JobTemplateArgs',
    'JobTemplateArgsDict',
    'ManagedCertificatePropertiesArgs',
    'ManagedCertificatePropertiesArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'RegistryCredentialsArgs',
    'RegistryCredentialsArgsDict',
    'ScaleRuleAuthArgs',
    'ScaleRuleAuthArgsDict',
    'SecretVolumeItemArgs',
    'SecretVolumeItemArgsDict',
    'SecretArgs',
    'SecretArgsDict',
    'VolumeMountArgs',
    'VolumeMountArgsDict',
    'VolumeArgs',
    'VolumeArgsDict',
]

MYPY = False

if not MYPY:
    class ContainerAppProbeHttpGetArgsDict(TypedDict):
        """
        HTTPGet specifies the http request to perform.
        """
        port: pulumi.Input[int]
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgsDict']]]]
        """
        Custom headers to set in the request. HTTP allows repeated headers.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[Union[str, 'Scheme']]]
        """
        Scheme to use for connecting to the host. Defaults to HTTP.
        """
elif False:
    ContainerAppProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerAppProbeHttpGetArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 host: Optional[pulumi.Input[str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgs']]]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 scheme: Optional[pulumi.Input[Union[str, 'Scheme']]] = None):
        """
        HTTPGet specifies the http request to perform.
        :param pulumi.Input[int] port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param pulumi.Input[str] host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgs']]] http_headers: Custom headers to set in the request. HTTP allows repeated headers.
        :param pulumi.Input[str] path: Path to access on the HTTP server.
        :param pulumi.Input[Union[str, 'Scheme']] scheme: Scheme to use for connecting to the host. Defaults to HTTP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgs']]]]:
        """
        Custom headers to set in the request. HTTP allows repeated headers.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[Union[str, 'Scheme']]]:
        """
        Scheme to use for connecting to the host. Defaults to HTTP.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[Union[str, 'Scheme']]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class ContainerAppProbeHttpHeadersArgsDict(TypedDict):
        """
        HTTPHeader describes a custom header to be used in HTTP probes
        """
        name: pulumi.Input[str]
        """
        The header field name
        """
        value: pulumi.Input[str]
        """
        The header field value
        """
elif False:
    ContainerAppProbeHttpHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerAppProbeHttpHeadersArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        HTTPHeader describes a custom header to be used in HTTP probes
        :param pulumi.Input[str] name: The header field name
        :param pulumi.Input[str] value: The header field value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ContainerAppProbeTcpSocketArgsDict(TypedDict):
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        """
        port: pulumi.Input[int]
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Optional: Host name to connect to, defaults to the pod IP.
        """
elif False:
    ContainerAppProbeTcpSocketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerAppProbeTcpSocketArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 host: Optional[pulumi.Input[str]] = None):
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        :param pulumi.Input[int] port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param pulumi.Input[str] host: Optional: Host name to connect to, defaults to the pod IP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Optional: Host name to connect to, defaults to the pod IP.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class ContainerAppProbeArgsDict(TypedDict):
        """
        Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
        """
        failure_threshold: NotRequired[pulumi.Input[int]]
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        """
        http_get: NotRequired[pulumi.Input['ContainerAppProbeHttpGetArgsDict']]
        """
        HTTPGet specifies the http request to perform.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[int]]
        """
        Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        """
        period_seconds: NotRequired[pulumi.Input[int]]
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        """
        success_threshold: NotRequired[pulumi.Input[int]]
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        """
        tcp_socket: NotRequired[pulumi.Input['ContainerAppProbeTcpSocketArgsDict']]
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[float]]
        """
        Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        """
        timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        """
        type: NotRequired[pulumi.Input[Union[str, 'Type']]]
        """
        The type of probe.
        """
elif False:
    ContainerAppProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerAppProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 http_get: Optional[pulumi.Input['ContainerAppProbeHttpGetArgs']] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 tcp_socket: Optional[pulumi.Input['ContainerAppProbeTcpSocketArgs']] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[float]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[Union[str, 'Type']]] = None):
        """
        Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        :param pulumi.Input['ContainerAppProbeHttpGetArgs'] http_get: HTTPGet specifies the http request to perform.
        :param pulumi.Input[int] initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        :param pulumi.Input['ContainerAppProbeTcpSocketArgs'] tcp_socket: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        :param pulumi.Input[float] termination_grace_period_seconds: Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        :param pulumi.Input[int] timeout_seconds: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        :param pulumi.Input[Union[str, 'Type']] type: The type of probe.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['ContainerAppProbeHttpGetArgs']]:
        """
        HTTPGet specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['ContainerAppProbeHttpGetArgs']]):
        pulumi.set(self, "http_get", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional[pulumi.Input['ContainerAppProbeTcpSocketArgs']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        """
        return pulumi.get(self, "tcp_socket")

    @tcp_socket.setter
    def tcp_socket(self, value: Optional[pulumi.Input['ContainerAppProbeTcpSocketArgs']]):
        pulumi.set(self, "tcp_socket", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "termination_grace_period_seconds", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'Type']]]:
        """
        The type of probe.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'Type']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ContainerResourcesArgsDict(TypedDict):
        """
        Container App container resource requirements.
        """
        cpu: NotRequired[pulumi.Input[float]]
        """
        Required CPU in cores, e.g. 0.5
        """
        memory: NotRequired[pulumi.Input[str]]
        """
        Required memory, e.g. "250Mb"
        """
elif False:
    ContainerResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerResourcesArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[float]] = None,
                 memory: Optional[pulumi.Input[str]] = None):
        """
        Container App container resource requirements.
        :param pulumi.Input[float] cpu: Required CPU in cores, e.g. 0.5
        :param pulumi.Input[str] memory: Required memory, e.g. "250Mb"
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[float]]:
        """
        Required CPU in cores, e.g. 0.5
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[str]]:
        """
        Required memory, e.g. "250Mb"
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class ContainerArgsDict(TypedDict):
        """
        Container App container definition
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Container start command arguments.
        """
        command: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Container start command.
        """
        env: NotRequired[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgsDict']]]]
        """
        Container environment variables.
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Container image tag.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Custom container name.
        """
        probes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgsDict']]]]
        """
        List of probes for the container.
        """
        resources: NotRequired[pulumi.Input['ContainerResourcesArgsDict']]
        """
        Container resource requirements.
        """
        volume_mounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgsDict']]]]
        """
        Container volume mounts.
        """
elif False:
    ContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 command: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 probes: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgs']]]] = None,
                 resources: Optional[pulumi.Input['ContainerResourcesArgs']] = None,
                 volume_mounts: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]] = None):
        """
        Container App container definition
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: Container start command arguments.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] command: Container start command.
        :param pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]] env: Container environment variables.
        :param pulumi.Input[str] image: Container image tag.
        :param pulumi.Input[str] name: Custom container name.
        :param pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgs']]] probes: List of probes for the container.
        :param pulumi.Input['ContainerResourcesArgs'] resources: Container resource requirements.
        :param pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]] volume_mounts: Container volume mounts.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Container start command arguments.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Container start command.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]]:
        """
        Container environment variables.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Container image tag.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Custom container name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def probes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgs']]]]:
        """
        List of probes for the container.
        """
        return pulumi.get(self, "probes")

    @probes.setter
    def probes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgs']]]]):
        pulumi.set(self, "probes", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['ContainerResourcesArgs']]:
        """
        Container resource requirements.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['ContainerResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]]:
        """
        Container volume mounts.
        """
        return pulumi.get(self, "volume_mounts")

    @volume_mounts.setter
    def volume_mounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]]):
        pulumi.set(self, "volume_mounts", value)


if not MYPY:
    class EnvironmentVarArgsDict(TypedDict):
        """
        Container App container environment variable.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Environment variable name.
        """
        secret_ref: NotRequired[pulumi.Input[str]]
        """
        Name of the Container App secret from which to pull the environment variable value.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Non-secret environment variable value.
        """
elif False:
    EnvironmentVarArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentVarArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 secret_ref: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Container App container environment variable.
        :param pulumi.Input[str] name: Environment variable name.
        :param pulumi.Input[str] secret_ref: Name of the Container App secret from which to pull the environment variable value.
        :param pulumi.Input[str] value: Non-secret environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Environment variable name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Container App secret from which to pull the environment variable value.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_ref", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Non-secret environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InitContainerArgsDict(TypedDict):
        """
        Container App init container definition
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Container start command arguments.
        """
        command: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Container start command.
        """
        env: NotRequired[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgsDict']]]]
        """
        Container environment variables.
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Container image tag.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Custom container name.
        """
        resources: NotRequired[pulumi.Input['ContainerResourcesArgsDict']]
        """
        Container resource requirements.
        """
        volume_mounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgsDict']]]]
        """
        Container volume mounts.
        """
elif False:
    InitContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InitContainerArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 command: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 resources: Optional[pulumi.Input['ContainerResourcesArgs']] = None,
                 volume_mounts: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]] = None):
        """
        Container App init container definition
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: Container start command arguments.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] command: Container start command.
        :param pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]] env: Container environment variables.
        :param pulumi.Input[str] image: Container image tag.
        :param pulumi.Input[str] name: Custom container name.
        :param pulumi.Input['ContainerResourcesArgs'] resources: Container resource requirements.
        :param pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]] volume_mounts: Container volume mounts.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Container start command arguments.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Container start command.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]]:
        """
        Container environment variables.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Container image tag.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Custom container name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['ContainerResourcesArgs']]:
        """
        Container resource requirements.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['ContainerResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]]:
        """
        Container volume mounts.
        """
        return pulumi.get(self, "volume_mounts")

    @volume_mounts.setter
    def volume_mounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]]):
        pulumi.set(self, "volume_mounts", value)


if not MYPY:
    class JobConfigurationEventTriggerConfigArgsDict(TypedDict):
        """
        Trigger configuration of an event driven job.
        """
        parallelism: NotRequired[pulumi.Input[int]]
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        replica_completion_count: NotRequired[pulumi.Input[int]]
        """
        Minimum number of successful replica completions before overall job completion.
        """
        scale: NotRequired[pulumi.Input['JobScaleArgsDict']]
        """
        Scaling configurations for event driven jobs.
        """
elif False:
    JobConfigurationEventTriggerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobConfigurationEventTriggerConfigArgs:
    def __init__(__self__, *,
                 parallelism: Optional[pulumi.Input[int]] = None,
                 replica_completion_count: Optional[pulumi.Input[int]] = None,
                 scale: Optional[pulumi.Input['JobScaleArgs']] = None):
        """
        Trigger configuration of an event driven job.
        :param pulumi.Input[int] parallelism: Number of parallel replicas of a job that can run at a given time.
        :param pulumi.Input[int] replica_completion_count: Minimum number of successful replica completions before overall job completion.
        :param pulumi.Input['JobScaleArgs'] scale: Scaling configurations for event driven jobs.
        """
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if replica_completion_count is not None:
            pulumi.set(__self__, "replica_completion_count", replica_completion_count)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[pulumi.Input[int]]:
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        return pulumi.get(self, "parallelism")

    @parallelism.setter
    def parallelism(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "parallelism", value)

    @property
    @pulumi.getter(name="replicaCompletionCount")
    def replica_completion_count(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of successful replica completions before overall job completion.
        """
        return pulumi.get(self, "replica_completion_count")

    @replica_completion_count.setter
    def replica_completion_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replica_completion_count", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input['JobScaleArgs']]:
        """
        Scaling configurations for event driven jobs.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input['JobScaleArgs']]):
        pulumi.set(self, "scale", value)


if not MYPY:
    class JobConfigurationManualTriggerConfigArgsDict(TypedDict):
        """
        Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        """
        parallelism: NotRequired[pulumi.Input[int]]
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        replica_completion_count: NotRequired[pulumi.Input[int]]
        """
        Minimum number of successful replica completions before overall job completion.
        """
elif False:
    JobConfigurationManualTriggerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobConfigurationManualTriggerConfigArgs:
    def __init__(__self__, *,
                 parallelism: Optional[pulumi.Input[int]] = None,
                 replica_completion_count: Optional[pulumi.Input[int]] = None):
        """
        Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        :param pulumi.Input[int] parallelism: Number of parallel replicas of a job that can run at a given time.
        :param pulumi.Input[int] replica_completion_count: Minimum number of successful replica completions before overall job completion.
        """
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if replica_completion_count is not None:
            pulumi.set(__self__, "replica_completion_count", replica_completion_count)

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[pulumi.Input[int]]:
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        return pulumi.get(self, "parallelism")

    @parallelism.setter
    def parallelism(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "parallelism", value)

    @property
    @pulumi.getter(name="replicaCompletionCount")
    def replica_completion_count(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of successful replica completions before overall job completion.
        """
        return pulumi.get(self, "replica_completion_count")

    @replica_completion_count.setter
    def replica_completion_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replica_completion_count", value)


if not MYPY:
    class JobConfigurationScheduleTriggerConfigArgsDict(TypedDict):
        """
        Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        """
        cron_expression: pulumi.Input[str]
        """
        Cron formatted repeating schedule ("* * * * *") of a Cron Job.
        """
        parallelism: NotRequired[pulumi.Input[int]]
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        replica_completion_count: NotRequired[pulumi.Input[int]]
        """
        Minimum number of successful replica completions before overall job completion.
        """
elif False:
    JobConfigurationScheduleTriggerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobConfigurationScheduleTriggerConfigArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[str],
                 parallelism: Optional[pulumi.Input[int]] = None,
                 replica_completion_count: Optional[pulumi.Input[int]] = None):
        """
        Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        :param pulumi.Input[str] cron_expression: Cron formatted repeating schedule ("* * * * *") of a Cron Job.
        :param pulumi.Input[int] parallelism: Number of parallel replicas of a job that can run at a given time.
        :param pulumi.Input[int] replica_completion_count: Minimum number of successful replica completions before overall job completion.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if replica_completion_count is not None:
            pulumi.set(__self__, "replica_completion_count", replica_completion_count)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[str]:
        """
        Cron formatted repeating schedule ("* * * * *") of a Cron Job.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[pulumi.Input[int]]:
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        return pulumi.get(self, "parallelism")

    @parallelism.setter
    def parallelism(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "parallelism", value)

    @property
    @pulumi.getter(name="replicaCompletionCount")
    def replica_completion_count(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of successful replica completions before overall job completion.
        """
        return pulumi.get(self, "replica_completion_count")

    @replica_completion_count.setter
    def replica_completion_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replica_completion_count", value)


if not MYPY:
    class JobConfigurationArgsDict(TypedDict):
        """
        Non versioned Container Apps Job configuration properties
        """
        replica_timeout: pulumi.Input[int]
        """
        Maximum number of seconds a replica is allowed to run.
        """
        trigger_type: pulumi.Input[Union[str, 'TriggerType']]
        """
        Trigger type of the job
        """
        event_trigger_config: NotRequired[pulumi.Input['JobConfigurationEventTriggerConfigArgsDict']]
        """
        Trigger configuration of an event driven job.
        """
        manual_trigger_config: NotRequired[pulumi.Input['JobConfigurationManualTriggerConfigArgsDict']]
        """
        Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        """
        registries: NotRequired[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgsDict']]]]
        """
        Collection of private container registry credentials used by a Container apps job
        """
        replica_retry_limit: NotRequired[pulumi.Input[int]]
        """
        Maximum number of retries before failing the job.
        """
        schedule_trigger_config: NotRequired[pulumi.Input['JobConfigurationScheduleTriggerConfigArgsDict']]
        """
        Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecretArgsDict']]]]
        """
        Collection of secrets used by a Container Apps Job
        """
elif False:
    JobConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobConfigurationArgs:
    def __init__(__self__, *,
                 replica_timeout: pulumi.Input[int],
                 trigger_type: Optional[pulumi.Input[Union[str, 'TriggerType']]] = None,
                 event_trigger_config: Optional[pulumi.Input['JobConfigurationEventTriggerConfigArgs']] = None,
                 manual_trigger_config: Optional[pulumi.Input['JobConfigurationManualTriggerConfigArgs']] = None,
                 registries: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]]] = None,
                 replica_retry_limit: Optional[pulumi.Input[int]] = None,
                 schedule_trigger_config: Optional[pulumi.Input['JobConfigurationScheduleTriggerConfigArgs']] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]] = None):
        """
        Non versioned Container Apps Job configuration properties
        :param pulumi.Input[int] replica_timeout: Maximum number of seconds a replica is allowed to run.
        :param pulumi.Input[Union[str, 'TriggerType']] trigger_type: Trigger type of the job
        :param pulumi.Input['JobConfigurationEventTriggerConfigArgs'] event_trigger_config: Trigger configuration of an event driven job.
        :param pulumi.Input['JobConfigurationManualTriggerConfigArgs'] manual_trigger_config: Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        :param pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]] registries: Collection of private container registry credentials used by a Container apps job
        :param pulumi.Input[int] replica_retry_limit: Maximum number of retries before failing the job.
        :param pulumi.Input['JobConfigurationScheduleTriggerConfigArgs'] schedule_trigger_config: Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        :param pulumi.Input[Sequence[pulumi.Input['SecretArgs']]] secrets: Collection of secrets used by a Container Apps Job
        """
        pulumi.set(__self__, "replica_timeout", replica_timeout)
        if trigger_type is None:
            trigger_type = 'Manual'
        pulumi.set(__self__, "trigger_type", trigger_type)
        if event_trigger_config is not None:
            pulumi.set(__self__, "event_trigger_config", event_trigger_config)
        if manual_trigger_config is not None:
            pulumi.set(__self__, "manual_trigger_config", manual_trigger_config)
        if registries is not None:
            pulumi.set(__self__, "registries", registries)
        if replica_retry_limit is not None:
            pulumi.set(__self__, "replica_retry_limit", replica_retry_limit)
        if schedule_trigger_config is not None:
            pulumi.set(__self__, "schedule_trigger_config", schedule_trigger_config)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter(name="replicaTimeout")
    def replica_timeout(self) -> pulumi.Input[int]:
        """
        Maximum number of seconds a replica is allowed to run.
        """
        return pulumi.get(self, "replica_timeout")

    @replica_timeout.setter
    def replica_timeout(self, value: pulumi.Input[int]):
        pulumi.set(self, "replica_timeout", value)

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> pulumi.Input[Union[str, 'TriggerType']]:
        """
        Trigger type of the job
        """
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: pulumi.Input[Union[str, 'TriggerType']]):
        pulumi.set(self, "trigger_type", value)

    @property
    @pulumi.getter(name="eventTriggerConfig")
    def event_trigger_config(self) -> Optional[pulumi.Input['JobConfigurationEventTriggerConfigArgs']]:
        """
        Trigger configuration of an event driven job.
        """
        return pulumi.get(self, "event_trigger_config")

    @event_trigger_config.setter
    def event_trigger_config(self, value: Optional[pulumi.Input['JobConfigurationEventTriggerConfigArgs']]):
        pulumi.set(self, "event_trigger_config", value)

    @property
    @pulumi.getter(name="manualTriggerConfig")
    def manual_trigger_config(self) -> Optional[pulumi.Input['JobConfigurationManualTriggerConfigArgs']]:
        """
        Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        """
        return pulumi.get(self, "manual_trigger_config")

    @manual_trigger_config.setter
    def manual_trigger_config(self, value: Optional[pulumi.Input['JobConfigurationManualTriggerConfigArgs']]):
        pulumi.set(self, "manual_trigger_config", value)

    @property
    @pulumi.getter
    def registries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]]]:
        """
        Collection of private container registry credentials used by a Container apps job
        """
        return pulumi.get(self, "registries")

    @registries.setter
    def registries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]]]):
        pulumi.set(self, "registries", value)

    @property
    @pulumi.getter(name="replicaRetryLimit")
    def replica_retry_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of retries before failing the job.
        """
        return pulumi.get(self, "replica_retry_limit")

    @replica_retry_limit.setter
    def replica_retry_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replica_retry_limit", value)

    @property
    @pulumi.getter(name="scheduleTriggerConfig")
    def schedule_trigger_config(self) -> Optional[pulumi.Input['JobConfigurationScheduleTriggerConfigArgs']]:
        """
        Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        """
        return pulumi.get(self, "schedule_trigger_config")

    @schedule_trigger_config.setter
    def schedule_trigger_config(self, value: Optional[pulumi.Input['JobConfigurationScheduleTriggerConfigArgs']]):
        pulumi.set(self, "schedule_trigger_config", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]]:
        """
        Collection of secrets used by a Container Apps Job
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class JobScaleRuleArgsDict(TypedDict):
        """
        Scaling rule.
        """
        auth: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgsDict']]]]
        """
        Authentication secrets for the scale rule.
        """
        metadata: NotRequired[Any]
        """
        Metadata properties to describe the scale rule.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Scale Rule Name
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the scale rule
        eg: azure-servicebus, redis etc.
        """
elif False:
    JobScaleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobScaleRuleArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
                 metadata: Optional[Any] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Scaling rule.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]] auth: Authentication secrets for the scale rule.
        :param Any metadata: Metadata properties to describe the scale rule.
        :param pulumi.Input[str] name: Scale Rule Name
        :param pulumi.Input[str] type: Type of the scale rule
               eg: azure-servicebus, redis etc.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]:
        """
        Authentication secrets for the scale rule.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Any]:
        """
        Metadata properties to describe the scale rule.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[Any]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Scale Rule Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the scale rule
        eg: azure-servicebus, redis etc.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class JobScaleArgsDict(TypedDict):
        """
        Scaling configurations for event driven jobs.
        """
        max_executions: NotRequired[pulumi.Input[int]]
        """
        Maximum number of job executions that are created for a trigger, default 100.
        """
        min_executions: NotRequired[pulumi.Input[int]]
        """
        Minimum number of job executions that are created for a trigger, default 0
        """
        polling_interval: NotRequired[pulumi.Input[int]]
        """
        Interval to check each event source in seconds. Defaults to 30s
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobScaleRuleArgsDict']]]]
        """
        Scaling rules.
        """
elif False:
    JobScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobScaleArgs:
    def __init__(__self__, *,
                 max_executions: Optional[pulumi.Input[int]] = None,
                 min_executions: Optional[pulumi.Input[int]] = None,
                 polling_interval: Optional[pulumi.Input[int]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['JobScaleRuleArgs']]]] = None):
        """
        Scaling configurations for event driven jobs.
        :param pulumi.Input[int] max_executions: Maximum number of job executions that are created for a trigger, default 100.
        :param pulumi.Input[int] min_executions: Minimum number of job executions that are created for a trigger, default 0
        :param pulumi.Input[int] polling_interval: Interval to check each event source in seconds. Defaults to 30s
        :param pulumi.Input[Sequence[pulumi.Input['JobScaleRuleArgs']]] rules: Scaling rules.
        """
        if max_executions is None:
            max_executions = 100
        if max_executions is not None:
            pulumi.set(__self__, "max_executions", max_executions)
        if min_executions is None:
            min_executions = 0
        if min_executions is not None:
            pulumi.set(__self__, "min_executions", min_executions)
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="maxExecutions")
    def max_executions(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of job executions that are created for a trigger, default 100.
        """
        return pulumi.get(self, "max_executions")

    @max_executions.setter
    def max_executions(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_executions", value)

    @property
    @pulumi.getter(name="minExecutions")
    def min_executions(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of job executions that are created for a trigger, default 0
        """
        return pulumi.get(self, "min_executions")

    @min_executions.setter
    def min_executions(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_executions", value)

    @property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[pulumi.Input[int]]:
        """
        Interval to check each event source in seconds. Defaults to 30s
        """
        return pulumi.get(self, "polling_interval")

    @polling_interval.setter
    def polling_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "polling_interval", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobScaleRuleArgs']]]]:
        """
        Scaling rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobScaleRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class JobTemplateArgsDict(TypedDict):
        """
        Container Apps Job versioned application definition. Defines the desired state of an immutable revision. Any changes to this section Will result in a new revision being created
        """
        containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContainerArgsDict']]]]
        """
        List of container definitions for the Container App.
        """
        init_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['InitContainerArgsDict']]]]
        """
        List of specialized containers that run before app containers.
        """
        volumes: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeArgsDict']]]]
        """
        List of volume definitions for the Container App.
        """
elif False:
    JobTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTemplateArgs:
    def __init__(__self__, *,
                 containers: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]]] = None,
                 init_containers: Optional[pulumi.Input[Sequence[pulumi.Input['InitContainerArgs']]]] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]]] = None):
        """
        Container Apps Job versioned application definition. Defines the desired state of an immutable revision. Any changes to this section Will result in a new revision being created
        :param pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]] containers: List of container definitions for the Container App.
        :param pulumi.Input[Sequence[pulumi.Input['InitContainerArgs']]] init_containers: List of specialized containers that run before app containers.
        :param pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]] volumes: List of volume definitions for the Container App.
        """
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if init_containers is not None:
            pulumi.set(__self__, "init_containers", init_containers)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]]]:
        """
        List of container definitions for the Container App.
        """
        return pulumi.get(self, "containers")

    @containers.setter
    def containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]]]):
        pulumi.set(self, "containers", value)

    @property
    @pulumi.getter(name="initContainers")
    def init_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InitContainerArgs']]]]:
        """
        List of specialized containers that run before app containers.
        """
        return pulumi.get(self, "init_containers")

    @init_containers.setter
    def init_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InitContainerArgs']]]]):
        pulumi.set(self, "init_containers", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]]]:
        """
        List of volume definitions for the Container App.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]]]):
        pulumi.set(self, "volumes", value)


if not MYPY:
    class ManagedCertificatePropertiesArgsDict(TypedDict):
        """
        Certificate resource specific properties
        """
        domain_control_validation: NotRequired[pulumi.Input[Union[str, 'ManagedCertificateDomainControlValidation']]]
        """
        Selected type of domain control validation for managed certificates.
        """
        subject_name: NotRequired[pulumi.Input[str]]
        """
        Subject name of the certificate.
        """
elif False:
    ManagedCertificatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedCertificatePropertiesArgs:
    def __init__(__self__, *,
                 domain_control_validation: Optional[pulumi.Input[Union[str, 'ManagedCertificateDomainControlValidation']]] = None,
                 subject_name: Optional[pulumi.Input[str]] = None):
        """
        Certificate resource specific properties
        :param pulumi.Input[Union[str, 'ManagedCertificateDomainControlValidation']] domain_control_validation: Selected type of domain control validation for managed certificates.
        :param pulumi.Input[str] subject_name: Subject name of the certificate.
        """
        if domain_control_validation is not None:
            pulumi.set(__self__, "domain_control_validation", domain_control_validation)
        if subject_name is not None:
            pulumi.set(__self__, "subject_name", subject_name)

    @property
    @pulumi.getter(name="domainControlValidation")
    def domain_control_validation(self) -> Optional[pulumi.Input[Union[str, 'ManagedCertificateDomainControlValidation']]]:
        """
        Selected type of domain control validation for managed certificates.
        """
        return pulumi.get(self, "domain_control_validation")

    @domain_control_validation.setter
    def domain_control_validation(self, value: Optional[pulumi.Input[Union[str, 'ManagedCertificateDomainControlValidation']]]):
        pulumi.set(self, "domain_control_validation", value)

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> Optional[pulumi.Input[str]]:
        """
        Subject name of the certificate.
        """
        return pulumi.get(self, "subject_name")

    @subject_name.setter
    def subject_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_name", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class RegistryCredentialsArgsDict(TypedDict):
        """
        Container App Private Registry
        """
        identity: NotRequired[pulumi.Input[str]]
        """
        A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        """
        password_secret_ref: NotRequired[pulumi.Input[str]]
        """
        The name of the Secret that contains the registry login password
        """
        server: NotRequired[pulumi.Input[str]]
        """
        Container Registry Server
        """
        username: NotRequired[pulumi.Input[str]]
        """
        Container Registry Username
        """
elif False:
    RegistryCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryCredentialsArgs:
    def __init__(__self__, *,
                 identity: Optional[pulumi.Input[str]] = None,
                 password_secret_ref: Optional[pulumi.Input[str]] = None,
                 server: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Container App Private Registry
        :param pulumi.Input[str] identity: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        :param pulumi.Input[str] password_secret_ref: The name of the Secret that contains the registry login password
        :param pulumi.Input[str] server: Container Registry Server
        :param pulumi.Input[str] username: Container Registry Username
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if password_secret_ref is not None:
            pulumi.set(__self__, "password_secret_ref", password_secret_ref)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[str]]:
        """
        A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter(name="passwordSecretRef")
    def password_secret_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Secret that contains the registry login password
        """
        return pulumi.get(self, "password_secret_ref")

    @password_secret_ref.setter
    def password_secret_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_secret_ref", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[str]]:
        """
        Container Registry Server
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Container Registry Username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ScaleRuleAuthArgsDict(TypedDict):
        """
        Auth Secrets for Scale Rule
        """
        secret_ref: NotRequired[pulumi.Input[str]]
        """
        Name of the secret from which to pull the auth params.
        """
        trigger_parameter: NotRequired[pulumi.Input[str]]
        """
        Trigger Parameter that uses the secret
        """
elif False:
    ScaleRuleAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleRuleAuthArgs:
    def __init__(__self__, *,
                 secret_ref: Optional[pulumi.Input[str]] = None,
                 trigger_parameter: Optional[pulumi.Input[str]] = None):
        """
        Auth Secrets for Scale Rule
        :param pulumi.Input[str] secret_ref: Name of the secret from which to pull the auth params.
        :param pulumi.Input[str] trigger_parameter: Trigger Parameter that uses the secret
        """
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if trigger_parameter is not None:
            pulumi.set(__self__, "trigger_parameter", trigger_parameter)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the secret from which to pull the auth params.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_ref", value)

    @property
    @pulumi.getter(name="triggerParameter")
    def trigger_parameter(self) -> Optional[pulumi.Input[str]]:
        """
        Trigger Parameter that uses the secret
        """
        return pulumi.get(self, "trigger_parameter")

    @trigger_parameter.setter
    def trigger_parameter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_parameter", value)


if not MYPY:
    class SecretVolumeItemArgsDict(TypedDict):
        """
        Secret to be added to volume.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
        """
        secret_ref: NotRequired[pulumi.Input[str]]
        """
        Name of the Container App secret from which to pull the secret value.
        """
elif False:
    SecretVolumeItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretVolumeItemArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 secret_ref: Optional[pulumi.Input[str]] = None):
        """
        Secret to be added to volume.
        :param pulumi.Input[str] path: Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
        :param pulumi.Input[str] secret_ref: Name of the Container App secret from which to pull the secret value.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Container App secret from which to pull the secret value.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class SecretArgsDict(TypedDict):
        """
        Secret definition.
        """
        identity: NotRequired[pulumi.Input[str]]
        """
        Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        """
        key_vault_url: NotRequired[pulumi.Input[str]]
        """
        Azure Key Vault URL pointing to the secret referenced by the container app.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Secret Name.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Secret Value.
        """
elif False:
    SecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretArgs:
    def __init__(__self__, *,
                 identity: Optional[pulumi.Input[str]] = None,
                 key_vault_url: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Secret definition.
        :param pulumi.Input[str] identity: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        :param pulumi.Input[str] key_vault_url: Azure Key Vault URL pointing to the secret referenced by the container app.
        :param pulumi.Input[str] name: Secret Name.
        :param pulumi.Input[str] value: Secret Value.
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if key_vault_url is not None:
            pulumi.set(__self__, "key_vault_url", key_vault_url)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter(name="keyVaultUrl")
    def key_vault_url(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Key Vault URL pointing to the secret referenced by the container app.
        """
        return pulumi.get(self, "key_vault_url")

    @key_vault_url.setter
    def key_vault_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_url", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Secret Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Secret Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VolumeMountArgsDict(TypedDict):
        """
        Volume mount for the Container App.
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        Path within the container at which the volume should be mounted.Must not contain ':'.
        """
        sub_path: NotRequired[pulumi.Input[str]]
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        volume_name: NotRequired[pulumi.Input[str]]
        """
        This must match the Name of a Volume.
        """
elif False:
    VolumeMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeMountArgs:
    def __init__(__self__, *,
                 mount_path: Optional[pulumi.Input[str]] = None,
                 sub_path: Optional[pulumi.Input[str]] = None,
                 volume_name: Optional[pulumi.Input[str]] = None):
        """
        Volume mount for the Container App.
        :param pulumi.Input[str] mount_path: Path within the container at which the volume should be mounted.Must not contain ':'.
        :param pulumi.Input[str] sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        :param pulumi.Input[str] volume_name: This must match the Name of a Volume.
        """
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path within the container at which the volume should be mounted.Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")

    @sub_path.setter
    def sub_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sub_path", value)

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[pulumi.Input[str]]:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "volume_name")

    @volume_name.setter
    def volume_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_name", value)


if not MYPY:
    class VolumeArgsDict(TypedDict):
        """
        Volume definitions for the Container App.
        """
        mount_options: NotRequired[pulumi.Input[str]]
        """
        Mount options used while mounting the AzureFile. Must be a comma-separated string.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Volume name.
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecretVolumeItemArgsDict']]]]
        """
        List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
        """
        storage_name: NotRequired[pulumi.Input[str]]
        """
        Name of storage resource. No need to provide for EmptyDir and Secret.
        """
        storage_type: NotRequired[pulumi.Input[Union[str, 'StorageType']]]
        """
        Storage type for the volume. If not provided, use EmptyDir.
        """
elif False:
    VolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeArgs:
    def __init__(__self__, *,
                 mount_options: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['SecretVolumeItemArgs']]]] = None,
                 storage_name: Optional[pulumi.Input[str]] = None,
                 storage_type: Optional[pulumi.Input[Union[str, 'StorageType']]] = None):
        """
        Volume definitions for the Container App.
        :param pulumi.Input[str] mount_options: Mount options used while mounting the AzureFile. Must be a comma-separated string.
        :param pulumi.Input[str] name: Volume name.
        :param pulumi.Input[Sequence[pulumi.Input['SecretVolumeItemArgs']]] secrets: List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
        :param pulumi.Input[str] storage_name: Name of storage resource. No need to provide for EmptyDir and Secret.
        :param pulumi.Input[Union[str, 'StorageType']] storage_type: Storage type for the volume. If not provided, use EmptyDir.
        """
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if storage_name is not None:
            pulumi.set(__self__, "storage_name", storage_name)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[pulumi.Input[str]]:
        """
        Mount options used while mounting the AzureFile. Must be a comma-separated string.
        """
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_options", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Volume name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecretVolumeItemArgs']]]]:
        """
        List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecretVolumeItemArgs']]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="storageName")
    def storage_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of storage resource. No need to provide for EmptyDir and Secret.
        """
        return pulumi.get(self, "storage_name")

    @storage_name.setter
    def storage_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_name", value)

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[Union[str, 'StorageType']]]:
        """
        Storage type for the volume. If not provided, use EmptyDir.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[Union[str, 'StorageType']]]):
        pulumi.set(self, "storage_type", value)


