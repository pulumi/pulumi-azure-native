# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AllowedAudiencesValidationArgs',
    'AllowedAudiencesValidationArgsDict',
    'AllowedPrincipalsArgs',
    'AllowedPrincipalsArgsDict',
    'AppLogsConfigurationArgs',
    'AppLogsConfigurationArgsDict',
    'AppRegistrationArgs',
    'AppRegistrationArgsDict',
    'AppleRegistrationArgs',
    'AppleRegistrationArgsDict',
    'AppleArgs',
    'AppleArgsDict',
    'AuthPlatformArgs',
    'AuthPlatformArgsDict',
    'AzureActiveDirectoryLoginArgs',
    'AzureActiveDirectoryLoginArgsDict',
    'AzureActiveDirectoryRegistrationArgs',
    'AzureActiveDirectoryRegistrationArgsDict',
    'AzureActiveDirectoryValidationArgs',
    'AzureActiveDirectoryValidationArgsDict',
    'AzureActiveDirectoryArgs',
    'AzureActiveDirectoryArgsDict',
    'AzureCredentialsArgs',
    'AzureCredentialsArgsDict',
    'AzureFilePropertiesArgs',
    'AzureFilePropertiesArgsDict',
    'AzureStaticWebAppsRegistrationArgs',
    'AzureStaticWebAppsRegistrationArgsDict',
    'AzureStaticWebAppsArgs',
    'AzureStaticWebAppsArgsDict',
    'BlobStorageTokenStoreArgs',
    'BlobStorageTokenStoreArgsDict',
    'BuildConfigurationArgs',
    'BuildConfigurationArgsDict',
    'CertificatePropertiesArgs',
    'CertificatePropertiesArgsDict',
    'CircuitBreakerPolicyArgs',
    'CircuitBreakerPolicyArgsDict',
    'ClientRegistrationArgs',
    'ClientRegistrationArgsDict',
    'ConfigurationArgs',
    'ConfigurationArgsDict',
    'ConnectedEnvironmentStoragePropertiesArgs',
    'ConnectedEnvironmentStoragePropertiesArgsDict',
    'ContainerAppProbeHttpGetArgs',
    'ContainerAppProbeHttpGetArgsDict',
    'ContainerAppProbeHttpHeadersArgs',
    'ContainerAppProbeHttpHeadersArgsDict',
    'ContainerAppProbeTcpSocketArgs',
    'ContainerAppProbeTcpSocketArgsDict',
    'ContainerAppProbeArgs',
    'ContainerAppProbeArgsDict',
    'ContainerRegistryWithCustomImageArgs',
    'ContainerRegistryWithCustomImageArgsDict',
    'ContainerRegistryArgs',
    'ContainerRegistryArgsDict',
    'ContainerResourcesArgs',
    'ContainerResourcesArgsDict',
    'ContainerArgs',
    'ContainerArgsDict',
    'CookieExpirationArgs',
    'CookieExpirationArgsDict',
    'CorsPolicyArgs',
    'CorsPolicyArgsDict',
    'CustomContainerTemplateArgs',
    'CustomContainerTemplateArgsDict',
    'CustomDomainConfigurationArgs',
    'CustomDomainConfigurationArgsDict',
    'CustomDomainArgs',
    'CustomDomainArgsDict',
    'CustomOpenIdConnectProviderArgs',
    'CustomOpenIdConnectProviderArgsDict',
    'CustomScaleRuleArgs',
    'CustomScaleRuleArgsDict',
    'DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationArgs',
    'DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationArgsDict',
    'DaprComponentResiliencyPolicyConfigurationArgs',
    'DaprComponentResiliencyPolicyConfigurationArgsDict',
    'DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationArgs',
    'DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationArgsDict',
    'DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationArgs',
    'DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationArgsDict',
    'DaprComponentResiliencyPolicyTimeoutPolicyConfigurationArgs',
    'DaprComponentResiliencyPolicyTimeoutPolicyConfigurationArgsDict',
    'DaprMetadataArgs',
    'DaprMetadataArgsDict',
    'DaprSubscriptionBulkSubscribeOptionsArgs',
    'DaprSubscriptionBulkSubscribeOptionsArgsDict',
    'DaprSubscriptionRouteRuleArgs',
    'DaprSubscriptionRouteRuleArgsDict',
    'DaprSubscriptionRoutesArgs',
    'DaprSubscriptionRoutesArgsDict',
    'DaprArgs',
    'DaprArgsDict',
    'DefaultAuthorizationPolicyArgs',
    'DefaultAuthorizationPolicyArgsDict',
    'DotNetComponentConfigurationPropertyArgs',
    'DotNetComponentConfigurationPropertyArgsDict',
    'DotNetComponentServiceBindArgs',
    'DotNetComponentServiceBindArgsDict',
    'DynamicPoolConfigurationArgs',
    'DynamicPoolConfigurationArgsDict',
    'EncryptionSettingsArgs',
    'EncryptionSettingsArgsDict',
    'EnvironmentVariableArgs',
    'EnvironmentVariableArgsDict',
    'EnvironmentVarArgs',
    'EnvironmentVarArgsDict',
    'ExtendedLocationArgs',
    'ExtendedLocationArgsDict',
    'FacebookArgs',
    'FacebookArgsDict',
    'ForwardProxyArgs',
    'ForwardProxyArgsDict',
    'GitHubArgs',
    'GitHubArgsDict',
    'GithubActionConfigurationArgs',
    'GithubActionConfigurationArgsDict',
    'GlobalValidationArgs',
    'GlobalValidationArgsDict',
    'GoogleArgs',
    'GoogleArgsDict',
    'HeaderMatchArgs',
    'HeaderMatchArgsDict',
    'HttpConnectionPoolArgs',
    'HttpConnectionPoolArgsDict',
    'HttpGetArgs',
    'HttpGetArgsDict',
    'HttpRetryPolicyArgs',
    'HttpRetryPolicyArgsDict',
    'HttpRouteActionArgs',
    'HttpRouteActionArgsDict',
    'HttpRouteConfigPropertiesArgs',
    'HttpRouteConfigPropertiesArgsDict',
    'HttpRouteMatchArgs',
    'HttpRouteMatchArgsDict',
    'HttpRouteRuleArgs',
    'HttpRouteRuleArgsDict',
    'HttpRouteTargetArgs',
    'HttpRouteTargetArgsDict',
    'HttpRouteArgs',
    'HttpRouteArgsDict',
    'HttpScaleRuleArgs',
    'HttpScaleRuleArgsDict',
    'HttpSettingsRoutesArgs',
    'HttpSettingsRoutesArgsDict',
    'HttpSettingsArgs',
    'HttpSettingsArgsDict',
    'IdentityProvidersArgs',
    'IdentityProvidersArgsDict',
    'IngressPortMappingArgs',
    'IngressPortMappingArgsDict',
    'IngressStickySessionsArgs',
    'IngressStickySessionsArgsDict',
    'IngressArgs',
    'IngressArgsDict',
    'InitContainerArgs',
    'InitContainerArgsDict',
    'IpSecurityRestrictionRuleArgs',
    'IpSecurityRestrictionRuleArgsDict',
    'JavaComponentConfigurationPropertyArgs',
    'JavaComponentConfigurationPropertyArgsDict',
    'JavaComponentPropertiesScaleArgs',
    'JavaComponentPropertiesScaleArgsDict',
    'JavaComponentServiceBindArgs',
    'JavaComponentServiceBindArgsDict',
    'JobConfigurationEventTriggerConfigArgs',
    'JobConfigurationEventTriggerConfigArgsDict',
    'JobConfigurationManualTriggerConfigArgs',
    'JobConfigurationManualTriggerConfigArgsDict',
    'JobConfigurationScheduleTriggerConfigArgs',
    'JobConfigurationScheduleTriggerConfigArgsDict',
    'JobConfigurationArgs',
    'JobConfigurationArgsDict',
    'JobScaleRuleArgs',
    'JobScaleRuleArgsDict',
    'JobScaleArgs',
    'JobScaleArgsDict',
    'JobTemplateArgs',
    'JobTemplateArgsDict',
    'JwtClaimChecksArgs',
    'JwtClaimChecksArgsDict',
    'LogAnalyticsConfigurationArgs',
    'LogAnalyticsConfigurationArgsDict',
    'LoginRoutesArgs',
    'LoginRoutesArgsDict',
    'LoginScopesArgs',
    'LoginScopesArgsDict',
    'LoginArgs',
    'LoginArgsDict',
    'ManagedCertificatePropertiesArgs',
    'ManagedCertificatePropertiesArgsDict',
    'ManagedEnvironmentEncryptionArgs',
    'ManagedEnvironmentEncryptionArgsDict',
    'ManagedEnvironmentPeerAuthenticationArgs',
    'ManagedEnvironmentPeerAuthenticationArgsDict',
    'ManagedEnvironmentPeerTrafficConfigurationArgs',
    'ManagedEnvironmentPeerTrafficConfigurationArgsDict',
    'ManagedEnvironmentStoragePropertiesArgs',
    'ManagedEnvironmentStoragePropertiesArgsDict',
    'ManagedIdentitySettingArgs',
    'ManagedIdentitySettingArgsDict',
    'ManagedServiceIdentityArgs',
    'ManagedServiceIdentityArgsDict',
    'MtlsArgs',
    'MtlsArgsDict',
    'NacosComponentArgs',
    'NacosComponentArgsDict',
    'NonceArgs',
    'NonceArgsDict',
    'OpenIdConnectClientCredentialArgs',
    'OpenIdConnectClientCredentialArgsDict',
    'OpenIdConnectConfigArgs',
    'OpenIdConnectConfigArgsDict',
    'OpenIdConnectLoginArgs',
    'OpenIdConnectLoginArgsDict',
    'OpenIdConnectRegistrationArgs',
    'OpenIdConnectRegistrationArgsDict',
    'PreBuildStepArgs',
    'PreBuildStepArgsDict',
    'PrivateLinkServiceConnectionStateArgs',
    'PrivateLinkServiceConnectionStateArgsDict',
    'QueueScaleRuleArgs',
    'QueueScaleRuleArgsDict',
    'RegistryCredentialsArgs',
    'RegistryCredentialsArgsDict',
    'RegistryInfoArgs',
    'RegistryInfoArgsDict',
    'ScaleConfigurationArgs',
    'ScaleConfigurationArgsDict',
    'ScaleRuleAuthArgs',
    'ScaleRuleAuthArgsDict',
    'ScaleRuleArgs',
    'ScaleRuleArgsDict',
    'ScaleArgs',
    'ScaleArgsDict',
    'ScgRouteArgs',
    'ScgRouteArgsDict',
    'ScheduledEntryArgs',
    'ScheduledEntryArgsDict',
    'SecretVolumeItemArgs',
    'SecretVolumeItemArgsDict',
    'SecretArgs',
    'SecretArgsDict',
    'ServiceBindArgs',
    'ServiceBindArgsDict',
    'ServiceArgs',
    'ServiceArgsDict',
    'SessionContainerResourcesArgs',
    'SessionContainerResourcesArgsDict',
    'SessionContainerArgs',
    'SessionContainerArgsDict',
    'SessionIngressArgs',
    'SessionIngressArgsDict',
    'SessionNetworkConfigurationArgs',
    'SessionNetworkConfigurationArgsDict',
    'SessionPoolSecretArgs',
    'SessionPoolSecretArgsDict',
    'SessionRegistryCredentialsArgs',
    'SessionRegistryCredentialsArgsDict',
    'SpringBootAdminComponentArgs',
    'SpringBootAdminComponentArgsDict',
    'SpringCloudConfigComponentArgs',
    'SpringCloudConfigComponentArgsDict',
    'SpringCloudEurekaComponentArgs',
    'SpringCloudEurekaComponentArgsDict',
    'SpringCloudGatewayComponentArgs',
    'SpringCloudGatewayComponentArgsDict',
    'TcpConnectionPoolArgs',
    'TcpConnectionPoolArgsDict',
    'TcpRetryPolicyArgs',
    'TcpRetryPolicyArgsDict',
    'TcpScaleRuleArgs',
    'TcpScaleRuleArgsDict',
    'TemplateArgs',
    'TemplateArgsDict',
    'TimeoutPolicyArgs',
    'TimeoutPolicyArgsDict',
    'TokenStoreArgs',
    'TokenStoreArgsDict',
    'TrafficWeightArgs',
    'TrafficWeightArgsDict',
    'TwitterRegistrationArgs',
    'TwitterRegistrationArgsDict',
    'TwitterArgs',
    'TwitterArgsDict',
    'VnetConfigurationArgs',
    'VnetConfigurationArgsDict',
    'VolumeMountArgs',
    'VolumeMountArgsDict',
    'VolumeArgs',
    'VolumeArgsDict',
    'WorkloadProfileArgs',
    'WorkloadProfileArgsDict',
]

MYPY = False

if not MYPY:
    class AllowedAudiencesValidationArgsDict(TypedDict):
        """
        The configuration settings of the Allowed Audiences validation flow.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
elif False:
    AllowedAudiencesValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AllowedAudiencesValidationArgs:
    def __init__(__self__, *,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The configuration settings of the Allowed Audiences validation flow.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_audiences: The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_audiences", value)


if not MYPY:
    class AllowedPrincipalsArgsDict(TypedDict):
        """
        The configuration settings of the Azure Active Directory allowed principals.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of the allowed groups.
        """
        identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of the allowed identities.
        """
elif False:
    AllowedPrincipalsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AllowedPrincipalsArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The configuration settings of the Azure Active Directory allowed principals.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] groups: The list of the allowed groups.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] identities: The list of the allowed identities.
        """
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if identities is not None:
            pulumi.set(__self__, "identities", identities)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of the allowed groups.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of the allowed identities.
        """
        return pulumi.get(self, "identities")

    @identities.setter
    def identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "identities", value)


if not MYPY:
    class AppLogsConfigurationArgsDict(TypedDict):
        """
        Configuration of application logs
        """
        destination: NotRequired[pulumi.Input[builtins.str]]
        """
        Logs destination, can be 'log-analytics', 'azure-monitor' or 'none'
        """
        log_analytics_configuration: NotRequired[pulumi.Input['LogAnalyticsConfigurationArgsDict']]
        """
        Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
        """
elif False:
    AppLogsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLogsConfigurationArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[builtins.str]] = None,
                 log_analytics_configuration: Optional[pulumi.Input['LogAnalyticsConfigurationArgs']] = None):
        """
        Configuration of application logs
        :param pulumi.Input[builtins.str] destination: Logs destination, can be 'log-analytics', 'azure-monitor' or 'none'
        :param pulumi.Input['LogAnalyticsConfigurationArgs'] log_analytics_configuration: Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if log_analytics_configuration is not None:
            pulumi.set(__self__, "log_analytics_configuration", log_analytics_configuration)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Logs destination, can be 'log-analytics', 'azure-monitor' or 'none'
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="logAnalyticsConfiguration")
    def log_analytics_configuration(self) -> Optional[pulumi.Input['LogAnalyticsConfigurationArgs']]:
        """
        Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
        """
        return pulumi.get(self, "log_analytics_configuration")

    @log_analytics_configuration.setter
    def log_analytics_configuration(self, value: Optional[pulumi.Input['LogAnalyticsConfigurationArgs']]):
        pulumi.set(self, "log_analytics_configuration", value)


if not MYPY:
    class AppRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the app registration for providers that have app ids and app secrets
        """
        app_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The App ID of the app used for login.
        """
        app_secret_setting_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The app setting name that contains the app secret.
        """
elif False:
    AppRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppRegistrationArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[builtins.str]] = None,
                 app_secret_setting_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the app registration for providers that have app ids and app secrets
        :param pulumi.Input[builtins.str] app_id: The App ID of the app used for login.
        :param pulumi.Input[builtins.str] app_secret_setting_name: The app setting name that contains the app secret.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_secret_setting_name is not None:
            pulumi.set(__self__, "app_secret_setting_name", app_secret_setting_name)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The App ID of the app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The app setting name that contains the app secret.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "app_secret_setting_name", value)


if not MYPY:
    class AppleRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the registration for the Apple provider
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Client ID of the app used for login.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The app setting name that contains the client secret.
        """
elif False:
    AppleRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppleRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the registration for the Apple provider
        :param pulumi.Input[builtins.str] client_id: The Client ID of the app used for login.
        :param pulumi.Input[builtins.str] client_secret_setting_name: The app setting name that contains the client secret.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The app setting name that contains the client secret.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_setting_name", value)


if not MYPY:
    class AppleArgsDict(TypedDict):
        """
        The configuration settings of the Apple provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        login: NotRequired[pulumi.Input['LoginScopesArgsDict']]
        """
        The configuration settings of the login flow.
        """
        registration: NotRequired[pulumi.Input['AppleRegistrationArgsDict']]
        """
        The configuration settings of the Apple registration.
        """
elif False:
    AppleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['AppleRegistrationArgs']] = None):
        """
        The configuration settings of the Apple provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['LoginScopesArgs'] login: The configuration settings of the login flow.
        :param pulumi.Input['AppleRegistrationArgs'] registration: The configuration settings of the Apple registration.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AppleRegistrationArgs']]:
        """
        The configuration settings of the Apple registration.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AppleRegistrationArgs']]):
        pulumi.set(self, "registration", value)


if not MYPY:
    class AuthPlatformArgsDict(TypedDict):
        """
        The configuration settings of the platform of ContainerApp Service Authentication/Authorization.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        """
        runtime_version: NotRequired[pulumi.Input[builtins.str]]
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
elif False:
    AuthPlatformArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthPlatformArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 runtime_version: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the platform of ContainerApp Service Authentication/Authorization.
        :param pulumi.Input[builtins.bool] enabled: <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        :param pulumi.Input[builtins.str] runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
               The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "runtime_version", value)


if not MYPY:
    class AzureActiveDirectoryLoginArgsDict(TypedDict):
        """
        The configuration settings of the Azure Active Directory login flow.
        """
        disable_www_authenticate: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        """
        login_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Login parameters to send to the OpenID Connect authorization endpoint when
        a user logs in. Each parameter must be in the form "key=value".
        """
elif False:
    AzureActiveDirectoryLoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureActiveDirectoryLoginArgs:
    def __init__(__self__, *,
                 disable_www_authenticate: Optional[pulumi.Input[builtins.bool]] = None,
                 login_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The configuration settings of the Azure Active Directory login flow.
        :param pulumi.Input[builtins.bool] disable_www_authenticate: <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] login_parameters: Login parameters to send to the OpenID Connect authorization endpoint when
               a user logs in. Each parameter must be in the form "key=value".
        """
        if disable_www_authenticate is not None:
            pulumi.set(__self__, "disable_www_authenticate", disable_www_authenticate)
        if login_parameters is not None:
            pulumi.set(__self__, "login_parameters", login_parameters)

    @property
    @pulumi.getter(name="disableWWWAuthenticate")
    def disable_www_authenticate(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "disable_www_authenticate")

    @disable_www_authenticate.setter
    def disable_www_authenticate(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_www_authenticate", value)

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when
        a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "login_parameters")

    @login_parameters.setter
    def login_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "login_parameters", value)


if not MYPY:
    class AzureActiveDirectoryRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the Azure Active Directory app registration.
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Client ID of this relying party application, known as the client_id.
        This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
        other 3rd party OpenID Connect providers.
        More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        """
        client_secret_certificate_issuer: NotRequired[pulumi.Input[builtins.str]]
        """
        An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        client_secret_certificate_subject_alternative_name: NotRequired[pulumi.Input[builtins.str]]
        """
        An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        client_secret_certificate_thumbprint: NotRequired[pulumi.Input[builtins.str]]
        """
        An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret. It is also optional.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The app setting name that contains the client secret of the relying party application.
        """
        open_id_issuer: NotRequired[pulumi.Input[builtins.str]]
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
        When using Azure Active Directory, this value is the URI of the directory tenant, e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
        This URI is a case-sensitive identifier for the token issuer.
        More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
elif False:
    AzureActiveDirectoryRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureActiveDirectoryRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret_certificate_issuer: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret_certificate_subject_alternative_name: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret_certificate_thumbprint: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[builtins.str]] = None,
                 open_id_issuer: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the Azure Active Directory app registration.
        :param pulumi.Input[builtins.str] client_id: The Client ID of this relying party application, known as the client_id.
               This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
               other 3rd party OpenID Connect providers.
               More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        :param pulumi.Input[builtins.str] client_secret_certificate_issuer: An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        :param pulumi.Input[builtins.str] client_secret_certificate_subject_alternative_name: An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        :param pulumi.Input[builtins.str] client_secret_certificate_thumbprint: An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret. It is also optional.
        :param pulumi.Input[builtins.str] client_secret_setting_name: The app setting name that contains the client secret of the relying party application.
        :param pulumi.Input[builtins.str] open_id_issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
               When using Azure Active Directory, this value is the URI of the directory tenant, e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
               This URI is a case-sensitive identifier for the token issuer.
               More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_certificate_issuer is not None:
            pulumi.set(__self__, "client_secret_certificate_issuer", client_secret_certificate_issuer)
        if client_secret_certificate_subject_alternative_name is not None:
            pulumi.set(__self__, "client_secret_certificate_subject_alternative_name", client_secret_certificate_subject_alternative_name)
        if client_secret_certificate_thumbprint is not None:
            pulumi.set(__self__, "client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if open_id_issuer is not None:
            pulumi.set(__self__, "open_id_issuer", open_id_issuer)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Client ID of this relying party application, known as the client_id.
        This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
        other 3rd party OpenID Connect providers.
        More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretCertificateIssuer")
    def client_secret_certificate_issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_issuer")

    @client_secret_certificate_issuer.setter
    def client_secret_certificate_issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_certificate_issuer", value)

    @property
    @pulumi.getter(name="clientSecretCertificateSubjectAlternativeName")
    def client_secret_certificate_subject_alternative_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_subject_alternative_name")

    @client_secret_certificate_subject_alternative_name.setter
    def client_secret_certificate_subject_alternative_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_certificate_subject_alternative_name", value)

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @client_secret_certificate_thumbprint.setter
    def client_secret_certificate_thumbprint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_certificate_thumbprint", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The app setting name that contains the client secret of the relying party application.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="openIdIssuer")
    def open_id_issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
        When using Azure Active Directory, this value is the URI of the directory tenant, e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
        This URI is a case-sensitive identifier for the token issuer.
        More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
        return pulumi.get(self, "open_id_issuer")

    @open_id_issuer.setter
    def open_id_issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "open_id_issuer", value)


if not MYPY:
    class AzureActiveDirectoryValidationArgsDict(TypedDict):
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        allowed_audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of audiences that can make successful authentication/authorization requests.
        """
        default_authorization_policy: NotRequired[pulumi.Input['DefaultAuthorizationPolicyArgsDict']]
        """
        The configuration settings of the default authorization policy.
        """
        jwt_claim_checks: NotRequired[pulumi.Input['JwtClaimChecksArgsDict']]
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        """
elif False:
    AzureActiveDirectoryValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureActiveDirectoryValidationArgs:
    def __init__(__self__, *,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 default_authorization_policy: Optional[pulumi.Input['DefaultAuthorizationPolicyArgs']] = None,
                 jwt_claim_checks: Optional[pulumi.Input['JwtClaimChecksArgs']] = None):
        """
        The configuration settings of the Azure Active Directory token validation flow.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_audiences: The list of audiences that can make successful authentication/authorization requests.
        :param pulumi.Input['DefaultAuthorizationPolicyArgs'] default_authorization_policy: The configuration settings of the default authorization policy.
        :param pulumi.Input['JwtClaimChecksArgs'] jwt_claim_checks: The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        if allowed_audiences is not None:
            pulumi.set(__self__, "allowed_audiences", allowed_audiences)
        if default_authorization_policy is not None:
            pulumi.set(__self__, "default_authorization_policy", default_authorization_policy)
        if jwt_claim_checks is not None:
            pulumi.set(__self__, "jwt_claim_checks", jwt_claim_checks)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of audiences that can make successful authentication/authorization requests.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="defaultAuthorizationPolicy")
    def default_authorization_policy(self) -> Optional[pulumi.Input['DefaultAuthorizationPolicyArgs']]:
        """
        The configuration settings of the default authorization policy.
        """
        return pulumi.get(self, "default_authorization_policy")

    @default_authorization_policy.setter
    def default_authorization_policy(self, value: Optional[pulumi.Input['DefaultAuthorizationPolicyArgs']]):
        pulumi.set(self, "default_authorization_policy", value)

    @property
    @pulumi.getter(name="jwtClaimChecks")
    def jwt_claim_checks(self) -> Optional[pulumi.Input['JwtClaimChecksArgs']]:
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        return pulumi.get(self, "jwt_claim_checks")

    @jwt_claim_checks.setter
    def jwt_claim_checks(self, value: Optional[pulumi.Input['JwtClaimChecksArgs']]):
        pulumi.set(self, "jwt_claim_checks", value)


if not MYPY:
    class AzureActiveDirectoryArgsDict(TypedDict):
        """
        The configuration settings of the Azure Active directory provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        is_auto_provisioned: NotRequired[pulumi.Input[builtins.bool]]
        """
        Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
        This is an internal flag primarily intended to support the Azure Management Portal. Users should not
        read or write to this property.
        """
        login: NotRequired[pulumi.Input['AzureActiveDirectoryLoginArgsDict']]
        """
        The configuration settings of the Azure Active Directory login flow.
        """
        registration: NotRequired[pulumi.Input['AzureActiveDirectoryRegistrationArgsDict']]
        """
        The configuration settings of the Azure Active Directory app registration.
        """
        validation: NotRequired[pulumi.Input['AzureActiveDirectoryValidationArgsDict']]
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
elif False:
    AzureActiveDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureActiveDirectoryArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 is_auto_provisioned: Optional[pulumi.Input[builtins.bool]] = None,
                 login: Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']] = None,
                 registration: Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']] = None,
                 validation: Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']] = None):
        """
        The configuration settings of the Azure Active directory provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input[builtins.bool] is_auto_provisioned: Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
               This is an internal flag primarily intended to support the Azure Management Portal. Users should not
               read or write to this property.
        :param pulumi.Input['AzureActiveDirectoryLoginArgs'] login: The configuration settings of the Azure Active Directory login flow.
        :param pulumi.Input['AzureActiveDirectoryRegistrationArgs'] registration: The configuration settings of the Azure Active Directory app registration.
        :param pulumi.Input['AzureActiveDirectoryValidationArgs'] validation: The configuration settings of the Azure Active Directory token validation flow.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if is_auto_provisioned is not None:
            pulumi.set(__self__, "is_auto_provisioned", is_auto_provisioned)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="isAutoProvisioned")
    def is_auto_provisioned(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
        This is an internal flag primarily intended to support the Azure Management Portal. Users should not
        read or write to this property.
        """
        return pulumi.get(self, "is_auto_provisioned")

    @is_auto_provisioned.setter
    def is_auto_provisioned(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_auto_provisioned", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']]:
        """
        The configuration settings of the Azure Active Directory login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']]:
        """
        The configuration settings of the Azure Active Directory app registration.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']]):
        pulumi.set(self, "registration", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']]:
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class AzureCredentialsArgsDict(TypedDict):
        """
        Container App credentials.
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Client Id.
        """
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        """
        Client Secret.
        """
        kind: NotRequired[pulumi.Input[builtins.str]]
        """
        Kind of auth github does for deploying the template
        """
        subscription_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Subscription Id.
        """
        tenant_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Tenant Id.
        """
elif False:
    AzureCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureCredentialsArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 kind: Optional[pulumi.Input[builtins.str]] = None,
                 subscription_id: Optional[pulumi.Input[builtins.str]] = None,
                 tenant_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Container App credentials.
        :param pulumi.Input[builtins.str] client_id: Client Id.
        :param pulumi.Input[builtins.str] client_secret: Client Secret.
        :param pulumi.Input[builtins.str] kind: Kind of auth github does for deploying the template
        :param pulumi.Input[builtins.str] subscription_id: Subscription Id.
        :param pulumi.Input[builtins.str] tenant_id: Tenant Id.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Client Id.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Client Secret.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kind of auth github does for deploying the template
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subscription Id.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Tenant Id.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class AzureFilePropertiesArgsDict(TypedDict):
        """
        Azure File Properties.
        """
        access_mode: NotRequired[pulumi.Input[Union[builtins.str, 'AccessMode']]]
        """
        Access mode for storage
        """
        account_key: NotRequired[pulumi.Input[builtins.str]]
        """
        Storage account key for azure file.
        """
        account_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Storage account name for azure file.
        """
        share_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Azure file share name.
        """
elif False:
    AzureFilePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureFilePropertiesArgs:
    def __init__(__self__, *,
                 access_mode: Optional[pulumi.Input[Union[builtins.str, 'AccessMode']]] = None,
                 account_key: Optional[pulumi.Input[builtins.str]] = None,
                 account_name: Optional[pulumi.Input[builtins.str]] = None,
                 share_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Azure File Properties.
        :param pulumi.Input[Union[builtins.str, 'AccessMode']] access_mode: Access mode for storage
        :param pulumi.Input[builtins.str] account_key: Storage account key for azure file.
        :param pulumi.Input[builtins.str] account_name: Storage account name for azure file.
        :param pulumi.Input[builtins.str] share_name: Azure file share name.
        """
        if access_mode is not None:
            pulumi.set(__self__, "access_mode", access_mode)
        if account_key is not None:
            pulumi.set(__self__, "account_key", account_key)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)

    @property
    @pulumi.getter(name="accessMode")
    def access_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'AccessMode']]]:
        """
        Access mode for storage
        """
        return pulumi.get(self, "access_mode")

    @access_mode.setter
    def access_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'AccessMode']]]):
        pulumi.set(self, "access_mode", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Storage account key for azure file.
        """
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Storage account name for azure file.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Azure file share name.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "share_name", value)


if not MYPY:
    class AzureStaticWebAppsRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the registration for the Azure Static Web Apps provider
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Client ID of the app used for login.
        """
elif False:
    AzureStaticWebAppsRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureStaticWebAppsRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the registration for the Azure Static Web Apps provider
        :param pulumi.Input[builtins.str] client_id: The Client ID of the app used for login.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)


if not MYPY:
    class AzureStaticWebAppsArgsDict(TypedDict):
        """
        The configuration settings of the Azure Static Web Apps provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        registration: NotRequired[pulumi.Input['AzureStaticWebAppsRegistrationArgsDict']]
        """
        The configuration settings of the Azure Static Web Apps registration.
        """
elif False:
    AzureStaticWebAppsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureStaticWebAppsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 registration: Optional[pulumi.Input['AzureStaticWebAppsRegistrationArgs']] = None):
        """
        The configuration settings of the Azure Static Web Apps provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['AzureStaticWebAppsRegistrationArgs'] registration: The configuration settings of the Azure Static Web Apps registration.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AzureStaticWebAppsRegistrationArgs']]:
        """
        The configuration settings of the Azure Static Web Apps registration.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AzureStaticWebAppsRegistrationArgs']]):
        pulumi.set(self, "registration", value)


if not MYPY:
    class BlobStorageTokenStoreArgsDict(TypedDict):
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        """
        sas_url_setting_name: pulumi.Input[builtins.str]
        """
        The name of the app secrets containing the SAS URL of the blob storage containing the tokens.
        """
elif False:
    BlobStorageTokenStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BlobStorageTokenStoreArgs:
    def __init__(__self__, *,
                 sas_url_setting_name: pulumi.Input[builtins.str]):
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        :param pulumi.Input[builtins.str] sas_url_setting_name: The name of the app secrets containing the SAS URL of the blob storage containing the tokens.
        """
        pulumi.set(__self__, "sas_url_setting_name", sas_url_setting_name)

    @property
    @pulumi.getter(name="sasUrlSettingName")
    def sas_url_setting_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the app secrets containing the SAS URL of the blob storage containing the tokens.
        """
        return pulumi.get(self, "sas_url_setting_name")

    @sas_url_setting_name.setter
    def sas_url_setting_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "sas_url_setting_name", value)


if not MYPY:
    class BuildConfigurationArgsDict(TypedDict):
        """
        Configuration of the build.
        """
        base_os: NotRequired[pulumi.Input[builtins.str]]
        """
        Base OS used to build and run the app.
        """
        environment_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['EnvironmentVariableArgsDict']]]]
        """
        List of environment variables to be passed to the build, secrets should not be used in environment variable.
        """
        platform: NotRequired[pulumi.Input[builtins.str]]
        """
        Platform to be used to build and run the app.
        """
        platform_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Platform version to be used to build and run the app.
        """
        pre_build_steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreBuildStepArgsDict']]]]
        """
        List of steps to perform before the build.
        """
elif False:
    BuildConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BuildConfigurationArgs:
    def __init__(__self__, *,
                 base_os: Optional[pulumi.Input[builtins.str]] = None,
                 environment_variables: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVariableArgs']]]] = None,
                 platform: Optional[pulumi.Input[builtins.str]] = None,
                 platform_version: Optional[pulumi.Input[builtins.str]] = None,
                 pre_build_steps: Optional[pulumi.Input[Sequence[pulumi.Input['PreBuildStepArgs']]]] = None):
        """
        Configuration of the build.
        :param pulumi.Input[builtins.str] base_os: Base OS used to build and run the app.
        :param pulumi.Input[Sequence[pulumi.Input['EnvironmentVariableArgs']]] environment_variables: List of environment variables to be passed to the build, secrets should not be used in environment variable.
        :param pulumi.Input[builtins.str] platform: Platform to be used to build and run the app.
        :param pulumi.Input[builtins.str] platform_version: Platform version to be used to build and run the app.
        :param pulumi.Input[Sequence[pulumi.Input['PreBuildStepArgs']]] pre_build_steps: List of steps to perform before the build.
        """
        if base_os is not None:
            pulumi.set(__self__, "base_os", base_os)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if platform_version is not None:
            pulumi.set(__self__, "platform_version", platform_version)
        if pre_build_steps is not None:
            pulumi.set(__self__, "pre_build_steps", pre_build_steps)

    @property
    @pulumi.getter(name="baseOs")
    def base_os(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Base OS used to build and run the app.
        """
        return pulumi.get(self, "base_os")

    @base_os.setter
    def base_os(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_os", value)

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVariableArgs']]]]:
        """
        List of environment variables to be passed to the build, secrets should not be used in environment variable.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVariableArgs']]]]):
        pulumi.set(self, "environment_variables", value)

    @property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Platform to be used to build and run the app.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Platform version to be used to build and run the app.
        """
        return pulumi.get(self, "platform_version")

    @platform_version.setter
    def platform_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "platform_version", value)

    @property
    @pulumi.getter(name="preBuildSteps")
    def pre_build_steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreBuildStepArgs']]]]:
        """
        List of steps to perform before the build.
        """
        return pulumi.get(self, "pre_build_steps")

    @pre_build_steps.setter
    def pre_build_steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreBuildStepArgs']]]]):
        pulumi.set(self, "pre_build_steps", value)


if not MYPY:
    class CertificatePropertiesArgsDict(TypedDict):
        """
        Certificate resource specific properties
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Certificate password.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        PFX or PEM blob
        """
elif False:
    CertificatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificatePropertiesArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Certificate resource specific properties
        :param pulumi.Input[builtins.str] password: Certificate password.
        :param pulumi.Input[builtins.str] value: PFX or PEM blob
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Certificate password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PFX or PEM blob
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CircuitBreakerPolicyArgsDict(TypedDict):
        """
        Policy that defines circuit breaker conditions
        """
        consecutive_errors: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of consecutive errors before the circuit breaker opens
        """
        interval_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        The time interval, in seconds, between endpoint checks. This can result in opening the circuit breaker if the check fails as well as closing the circuit breaker if the check succeeds. Defaults to 10s.
        """
        max_ejection_percent: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum percentage of hosts that will be ejected after failure threshold has been met
        """
elif False:
    CircuitBreakerPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CircuitBreakerPolicyArgs:
    def __init__(__self__, *,
                 consecutive_errors: Optional[pulumi.Input[builtins.int]] = None,
                 interval_in_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 max_ejection_percent: Optional[pulumi.Input[builtins.int]] = None):
        """
        Policy that defines circuit breaker conditions
        :param pulumi.Input[builtins.int] consecutive_errors: Number of consecutive errors before the circuit breaker opens
        :param pulumi.Input[builtins.int] interval_in_seconds: The time interval, in seconds, between endpoint checks. This can result in opening the circuit breaker if the check fails as well as closing the circuit breaker if the check succeeds. Defaults to 10s.
        :param pulumi.Input[builtins.int] max_ejection_percent: Maximum percentage of hosts that will be ejected after failure threshold has been met
        """
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of consecutive errors before the circuit breaker opens
        """
        return pulumi.get(self, "consecutive_errors")

    @consecutive_errors.setter
    def consecutive_errors(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "consecutive_errors", value)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The time interval, in seconds, between endpoint checks. This can result in opening the circuit breaker if the check fails as well as closing the circuit breaker if the check succeeds. Defaults to 10s.
        """
        return pulumi.get(self, "interval_in_seconds")

    @interval_in_seconds.setter
    def interval_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "interval_in_seconds", value)

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum percentage of hosts that will be ejected after failure threshold has been met
        """
        return pulumi.get(self, "max_ejection_percent")

    @max_ejection_percent.setter
    def max_ejection_percent(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_ejection_percent", value)


if not MYPY:
    class ClientRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the app registration for providers that have client ids and client secrets
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Client ID of the app used for login.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The app setting name that contains the client secret.
        """
elif False:
    ClientRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the app registration for providers that have client ids and client secrets
        :param pulumi.Input[builtins.str] client_id: The Client ID of the app used for login.
        :param pulumi.Input[builtins.str] client_secret_setting_name: The app setting name that contains the client secret.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The app setting name that contains the client secret.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_setting_name", value)


if not MYPY:
    class ConfigurationArgsDict(TypedDict):
        """
        Non versioned Container App configuration properties that define the mutable settings of a Container app
        """
        active_revisions_mode: NotRequired[pulumi.Input[Union[builtins.str, 'ActiveRevisionsMode']]]
        """
        ActiveRevisionsMode controls how active revisions are handled for the Container app:
        <list><item>Multiple: multiple revisions can be active.</item><item>Single: Only one revision can be active at a time. Revision weights can not be used in this mode. If no value if provided, this is the default.</item></list>
        """
        dapr: NotRequired[pulumi.Input['DaprArgsDict']]
        """
        Dapr configuration for the Container App.
        """
        ingress: NotRequired[pulumi.Input['IngressArgsDict']]
        """
        Ingress configurations.
        """
        max_inactive_revisions: NotRequired[pulumi.Input[builtins.int]]
        """
        Optional. Max inactive revisions a Container App can have.
        """
        registries: NotRequired[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgsDict']]]]
        """
        Collection of private container registry credentials for containers used by the Container app
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecretArgsDict']]]]
        """
        Collection of secrets used by a Container app
        """
        service: NotRequired[pulumi.Input['ServiceArgsDict']]
        """
        Container App to be a dev Container App Service
        """
elif False:
    ConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationArgs:
    def __init__(__self__, *,
                 active_revisions_mode: Optional[pulumi.Input[Union[builtins.str, 'ActiveRevisionsMode']]] = None,
                 dapr: Optional[pulumi.Input['DaprArgs']] = None,
                 ingress: Optional[pulumi.Input['IngressArgs']] = None,
                 max_inactive_revisions: Optional[pulumi.Input[builtins.int]] = None,
                 registries: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]] = None,
                 service: Optional[pulumi.Input['ServiceArgs']] = None):
        """
        Non versioned Container App configuration properties that define the mutable settings of a Container app
        :param pulumi.Input[Union[builtins.str, 'ActiveRevisionsMode']] active_revisions_mode: ActiveRevisionsMode controls how active revisions are handled for the Container app:
               <list><item>Multiple: multiple revisions can be active.</item><item>Single: Only one revision can be active at a time. Revision weights can not be used in this mode. If no value if provided, this is the default.</item></list>
        :param pulumi.Input['DaprArgs'] dapr: Dapr configuration for the Container App.
        :param pulumi.Input['IngressArgs'] ingress: Ingress configurations.
        :param pulumi.Input[builtins.int] max_inactive_revisions: Optional. Max inactive revisions a Container App can have.
        :param pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]] registries: Collection of private container registry credentials for containers used by the Container app
        :param pulumi.Input[Sequence[pulumi.Input['SecretArgs']]] secrets: Collection of secrets used by a Container app
        :param pulumi.Input['ServiceArgs'] service: Container App to be a dev Container App Service
        """
        if active_revisions_mode is None:
            active_revisions_mode = 'Single'
        if active_revisions_mode is not None:
            pulumi.set(__self__, "active_revisions_mode", active_revisions_mode)
        if dapr is not None:
            pulumi.set(__self__, "dapr", dapr)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if max_inactive_revisions is not None:
            pulumi.set(__self__, "max_inactive_revisions", max_inactive_revisions)
        if registries is not None:
            pulumi.set(__self__, "registries", registries)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="activeRevisionsMode")
    def active_revisions_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'ActiveRevisionsMode']]]:
        """
        ActiveRevisionsMode controls how active revisions are handled for the Container app:
        <list><item>Multiple: multiple revisions can be active.</item><item>Single: Only one revision can be active at a time. Revision weights can not be used in this mode. If no value if provided, this is the default.</item></list>
        """
        return pulumi.get(self, "active_revisions_mode")

    @active_revisions_mode.setter
    def active_revisions_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'ActiveRevisionsMode']]]):
        pulumi.set(self, "active_revisions_mode", value)

    @property
    @pulumi.getter
    def dapr(self) -> Optional[pulumi.Input['DaprArgs']]:
        """
        Dapr configuration for the Container App.
        """
        return pulumi.get(self, "dapr")

    @dapr.setter
    def dapr(self, value: Optional[pulumi.Input['DaprArgs']]):
        pulumi.set(self, "dapr", value)

    @property
    @pulumi.getter
    def ingress(self) -> Optional[pulumi.Input['IngressArgs']]:
        """
        Ingress configurations.
        """
        return pulumi.get(self, "ingress")

    @ingress.setter
    def ingress(self, value: Optional[pulumi.Input['IngressArgs']]):
        pulumi.set(self, "ingress", value)

    @property
    @pulumi.getter(name="maxInactiveRevisions")
    def max_inactive_revisions(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optional. Max inactive revisions a Container App can have.
        """
        return pulumi.get(self, "max_inactive_revisions")

    @max_inactive_revisions.setter
    def max_inactive_revisions(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_inactive_revisions", value)

    @property
    @pulumi.getter
    def registries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]]]:
        """
        Collection of private container registry credentials for containers used by the Container app
        """
        return pulumi.get(self, "registries")

    @registries.setter
    def registries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]]]):
        pulumi.set(self, "registries", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]]:
        """
        Collection of secrets used by a Container app
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input['ServiceArgs']]:
        """
        Container App to be a dev Container App Service
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input['ServiceArgs']]):
        pulumi.set(self, "service", value)


if not MYPY:
    class ConnectedEnvironmentStoragePropertiesArgsDict(TypedDict):
        """
        Storage properties
        """
        azure_file: NotRequired[pulumi.Input['AzureFilePropertiesArgsDict']]
        """
        Azure file properties
        """
elif False:
    ConnectedEnvironmentStoragePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectedEnvironmentStoragePropertiesArgs:
    def __init__(__self__, *,
                 azure_file: Optional[pulumi.Input['AzureFilePropertiesArgs']] = None):
        """
        Storage properties
        :param pulumi.Input['AzureFilePropertiesArgs'] azure_file: Azure file properties
        """
        if azure_file is not None:
            pulumi.set(__self__, "azure_file", azure_file)

    @property
    @pulumi.getter(name="azureFile")
    def azure_file(self) -> Optional[pulumi.Input['AzureFilePropertiesArgs']]:
        """
        Azure file properties
        """
        return pulumi.get(self, "azure_file")

    @azure_file.setter
    def azure_file(self, value: Optional[pulumi.Input['AzureFilePropertiesArgs']]):
        pulumi.set(self, "azure_file", value)


if not MYPY:
    class ContainerAppProbeHttpGetArgsDict(TypedDict):
        """
        HTTPGet specifies the http request to perform.
        """
        port: pulumi.Input[builtins.int]
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        http_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgsDict']]]]
        """
        Custom headers to set in the request. HTTP allows repeated headers.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path to access on the HTTP server.
        """
        scheme: NotRequired[pulumi.Input[Union[builtins.str, 'Scheme']]]
        """
        Scheme to use for connecting to the host. Defaults to HTTP.
        """
elif False:
    ContainerAppProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerAppProbeHttpGetArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[builtins.int],
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgs']]]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 scheme: Optional[pulumi.Input[Union[builtins.str, 'Scheme']]] = None):
        """
        HTTPGet specifies the http request to perform.
        :param pulumi.Input[builtins.int] port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param pulumi.Input[builtins.str] host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgs']]] http_headers: Custom headers to set in the request. HTTP allows repeated headers.
        :param pulumi.Input[builtins.str] path: Path to access on the HTTP server.
        :param pulumi.Input[Union[builtins.str, 'Scheme']] scheme: Scheme to use for connecting to the host. Defaults to HTTP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgs']]]]:
        """
        Custom headers to set in the request. HTTP allows repeated headers.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[Union[builtins.str, 'Scheme']]]:
        """
        Scheme to use for connecting to the host. Defaults to HTTP.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[Union[builtins.str, 'Scheme']]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class ContainerAppProbeHttpHeadersArgsDict(TypedDict):
        """
        HTTPHeader describes a custom header to be used in HTTP probes
        """
        name: pulumi.Input[builtins.str]
        """
        The header field name
        """
        value: pulumi.Input[builtins.str]
        """
        The header field value
        """
elif False:
    ContainerAppProbeHttpHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerAppProbeHttpHeadersArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        HTTPHeader describes a custom header to be used in HTTP probes
        :param pulumi.Input[builtins.str] name: The header field name
        :param pulumi.Input[builtins.str] value: The header field value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ContainerAppProbeTcpSocketArgsDict(TypedDict):
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        """
        port: pulumi.Input[builtins.int]
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional: Host name to connect to, defaults to the pod IP.
        """
elif False:
    ContainerAppProbeTcpSocketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerAppProbeTcpSocketArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[builtins.int],
                 host: Optional[pulumi.Input[builtins.str]] = None):
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        :param pulumi.Input[builtins.int] port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param pulumi.Input[builtins.str] host: Optional: Host name to connect to, defaults to the pod IP.
        """
        pulumi.set(__self__, "port", port)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional: Host name to connect to, defaults to the pod IP.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class ContainerAppProbeArgsDict(TypedDict):
        """
        Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
        """
        failure_threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        """
        http_get: NotRequired[pulumi.Input['ContainerAppProbeHttpGetArgsDict']]
        """
        HTTPGet specifies the http request to perform.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        """
        period_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        """
        success_threshold: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        """
        tcp_socket: NotRequired[pulumi.Input['ContainerAppProbeTcpSocketArgsDict']]
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[builtins.float]]
        """
        Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        """
        timeout_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'Type']]]
        """
        The type of probe.
        """
elif False:
    ContainerAppProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerAppProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[builtins.int]] = None,
                 http_get: Optional[pulumi.Input['ContainerAppProbeHttpGetArgs']] = None,
                 initial_delay_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[builtins.int]] = None,
                 tcp_socket: Optional[pulumi.Input['ContainerAppProbeTcpSocketArgs']] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[builtins.float]] = None,
                 timeout_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'Type']]] = None):
        """
        Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
        :param pulumi.Input[builtins.int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        :param pulumi.Input['ContainerAppProbeHttpGetArgs'] http_get: HTTPGet specifies the http request to perform.
        :param pulumi.Input[builtins.int] initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        :param pulumi.Input[builtins.int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        :param pulumi.Input[builtins.int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        :param pulumi.Input['ContainerAppProbeTcpSocketArgs'] tcp_socket: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        :param pulumi.Input[builtins.float] termination_grace_period_seconds: Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        :param pulumi.Input[builtins.int] timeout_seconds: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        :param pulumi.Input[Union[builtins.str, 'Type']] type: The type of probe.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['ContainerAppProbeHttpGetArgs']]:
        """
        HTTPGet specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['ContainerAppProbeHttpGetArgs']]):
        pulumi.set(self, "http_get", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional[pulumi.Input['ContainerAppProbeTcpSocketArgs']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        """
        return pulumi.get(self, "tcp_socket")

    @tcp_socket.setter
    def tcp_socket(self, value: Optional[pulumi.Input['ContainerAppProbeTcpSocketArgs']]):
        pulumi.set(self, "tcp_socket", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "termination_grace_period_seconds", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'Type']]]:
        """
        The type of probe.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'Type']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ContainerRegistryWithCustomImageArgsDict(TypedDict):
        """
        Container registry that the final image will be uploaded to.
        """
        server: pulumi.Input[builtins.str]
        """
        Login server of the container registry that the final image should be uploaded to. Builder resource needs to have this container registry defined along with an identity to use to access it.
        """
        image: NotRequired[pulumi.Input[builtins.str]]
        """
        Full name that the final image should be uploaded as, including both image name and tag.
        """
elif False:
    ContainerRegistryWithCustomImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerRegistryWithCustomImageArgs:
    def __init__(__self__, *,
                 server: pulumi.Input[builtins.str],
                 image: Optional[pulumi.Input[builtins.str]] = None):
        """
        Container registry that the final image will be uploaded to.
        :param pulumi.Input[builtins.str] server: Login server of the container registry that the final image should be uploaded to. Builder resource needs to have this container registry defined along with an identity to use to access it.
        :param pulumi.Input[builtins.str] image: Full name that the final image should be uploaded as, including both image name and tag.
        """
        pulumi.set(__self__, "server", server)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter
    def server(self) -> pulumi.Input[builtins.str]:
        """
        Login server of the container registry that the final image should be uploaded to. Builder resource needs to have this container registry defined along with an identity to use to access it.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Full name that the final image should be uploaded as, including both image name and tag.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "image", value)


if not MYPY:
    class ContainerRegistryArgsDict(TypedDict):
        """
        Model representing a mapping from a container registry to the identity used to connect to it.
        """
        container_registry_server: pulumi.Input[builtins.str]
        """
        Login server of the container registry.
        """
        identity_resource_id: pulumi.Input[builtins.str]
        """
        Resource ID of the managed identity.
        """
elif False:
    ContainerRegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerRegistryArgs:
    def __init__(__self__, *,
                 container_registry_server: pulumi.Input[builtins.str],
                 identity_resource_id: pulumi.Input[builtins.str]):
        """
        Model representing a mapping from a container registry to the identity used to connect to it.
        :param pulumi.Input[builtins.str] container_registry_server: Login server of the container registry.
        :param pulumi.Input[builtins.str] identity_resource_id: Resource ID of the managed identity.
        """
        pulumi.set(__self__, "container_registry_server", container_registry_server)
        pulumi.set(__self__, "identity_resource_id", identity_resource_id)

    @property
    @pulumi.getter(name="containerRegistryServer")
    def container_registry_server(self) -> pulumi.Input[builtins.str]:
        """
        Login server of the container registry.
        """
        return pulumi.get(self, "container_registry_server")

    @container_registry_server.setter
    def container_registry_server(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "container_registry_server", value)

    @property
    @pulumi.getter(name="identityResourceId")
    def identity_resource_id(self) -> pulumi.Input[builtins.str]:
        """
        Resource ID of the managed identity.
        """
        return pulumi.get(self, "identity_resource_id")

    @identity_resource_id.setter
    def identity_resource_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "identity_resource_id", value)


if not MYPY:
    class ContainerResourcesArgsDict(TypedDict):
        """
        Container App container resource requirements.
        """
        cpu: NotRequired[pulumi.Input[builtins.float]]
        """
        Required CPU in cores, e.g. 0.5
        """
        memory: NotRequired[pulumi.Input[builtins.str]]
        """
        Required memory, e.g. "250Mb"
        """
elif False:
    ContainerResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerResourcesArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[builtins.float]] = None,
                 memory: Optional[pulumi.Input[builtins.str]] = None):
        """
        Container App container resource requirements.
        :param pulumi.Input[builtins.float] cpu: Required CPU in cores, e.g. 0.5
        :param pulumi.Input[builtins.str] memory: Required memory, e.g. "250Mb"
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Required CPU in cores, e.g. 0.5
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required memory, e.g. "250Mb"
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class ContainerArgsDict(TypedDict):
        """
        Container App container definition
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Container start command arguments.
        """
        command: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Container start command.
        """
        env: NotRequired[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgsDict']]]]
        """
        Container environment variables.
        """
        image: NotRequired[pulumi.Input[builtins.str]]
        """
        Container image tag.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Custom container name.
        """
        probes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgsDict']]]]
        """
        List of probes for the container.
        """
        resources: NotRequired[pulumi.Input['ContainerResourcesArgsDict']]
        """
        Container resource requirements.
        """
        volume_mounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgsDict']]]]
        """
        Container volume mounts.
        """
elif False:
    ContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContainerArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 command: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]] = None,
                 image: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 probes: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgs']]]] = None,
                 resources: Optional[pulumi.Input['ContainerResourcesArgs']] = None,
                 volume_mounts: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]] = None):
        """
        Container App container definition
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] args: Container start command arguments.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] command: Container start command.
        :param pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]] env: Container environment variables.
        :param pulumi.Input[builtins.str] image: Container image tag.
        :param pulumi.Input[builtins.str] name: Custom container name.
        :param pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgs']]] probes: List of probes for the container.
        :param pulumi.Input['ContainerResourcesArgs'] resources: Container resource requirements.
        :param pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]] volume_mounts: Container volume mounts.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Container start command arguments.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Container start command.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]]:
        """
        Container environment variables.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Container image tag.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Custom container name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def probes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgs']]]]:
        """
        List of probes for the container.
        """
        return pulumi.get(self, "probes")

    @probes.setter
    def probes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgs']]]]):
        pulumi.set(self, "probes", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['ContainerResourcesArgs']]:
        """
        Container resource requirements.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['ContainerResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]]:
        """
        Container volume mounts.
        """
        return pulumi.get(self, "volume_mounts")

    @volume_mounts.setter
    def volume_mounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]]):
        pulumi.set(self, "volume_mounts", value)


if not MYPY:
    class CookieExpirationArgsDict(TypedDict):
        """
        The configuration settings of the session cookie's expiration.
        """
        convention: NotRequired[pulumi.Input['CookieExpirationConvention']]
        """
        The convention used when determining the session cookie's expiration.
        """
        time_to_expiration: NotRequired[pulumi.Input[builtins.str]]
        """
        The time after the request is made when the session cookie should expire.
        """
elif False:
    CookieExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CookieExpirationArgs:
    def __init__(__self__, *,
                 convention: Optional[pulumi.Input['CookieExpirationConvention']] = None,
                 time_to_expiration: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the session cookie's expiration.
        :param pulumi.Input['CookieExpirationConvention'] convention: The convention used when determining the session cookie's expiration.
        :param pulumi.Input[builtins.str] time_to_expiration: The time after the request is made when the session cookie should expire.
        """
        if convention is not None:
            pulumi.set(__self__, "convention", convention)
        if time_to_expiration is not None:
            pulumi.set(__self__, "time_to_expiration", time_to_expiration)

    @property
    @pulumi.getter
    def convention(self) -> Optional[pulumi.Input['CookieExpirationConvention']]:
        """
        The convention used when determining the session cookie's expiration.
        """
        return pulumi.get(self, "convention")

    @convention.setter
    def convention(self, value: Optional[pulumi.Input['CookieExpirationConvention']]):
        pulumi.set(self, "convention", value)

    @property
    @pulumi.getter(name="timeToExpiration")
    def time_to_expiration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The time after the request is made when the session cookie should expire.
        """
        return pulumi.get(self, "time_to_expiration")

    @time_to_expiration.setter
    def time_to_expiration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_to_expiration", value)


if not MYPY:
    class CorsPolicyArgsDict(TypedDict):
        """
        Cross-Origin-Resource-Sharing policy
        """
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Specifies the content for the access-control-allow-origins header
        """
        allow_credentials: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether the resource allows credentials
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the content for the access-control-allow-headers header
        """
        allowed_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the content for the access-control-allow-methods header
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the content for the access-control-expose-headers header 
        """
        max_age: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the content for the access-control-max-age header
        """
elif False:
    CorsPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CorsPolicyArgs:
    def __init__(__self__, *,
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 allow_credentials: Optional[pulumi.Input[builtins.bool]] = None,
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 max_age: Optional[pulumi.Input[builtins.int]] = None):
        """
        Cross-Origin-Resource-Sharing policy
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_origins: Specifies the content for the access-control-allow-origins header
        :param pulumi.Input[builtins.bool] allow_credentials: Specifies whether the resource allows credentials
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_headers: Specifies the content for the access-control-allow-headers header
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_methods: Specifies the content for the access-control-allow-methods header
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] expose_headers: Specifies the content for the access-control-expose-headers header 
        :param pulumi.Input[builtins.int] max_age: Specifies the content for the access-control-max-age header
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Specifies the content for the access-control-allow-origins header
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether the resource allows credentials
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the content for the access-control-allow-headers header
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the content for the access-control-allow-methods header
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the content for the access-control-expose-headers header 
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the content for the access-control-max-age header
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class CustomContainerTemplateArgsDict(TypedDict):
        """
        Custom container configuration.
        """
        containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SessionContainerArgsDict']]]]
        """
        List of container definitions for the sessions of the session pool.
        """
        ingress: NotRequired[pulumi.Input['SessionIngressArgsDict']]
        """
        Session pool ingress configuration.
        """
        registry_credentials: NotRequired[pulumi.Input['SessionRegistryCredentialsArgsDict']]
        """
        Private container registry credentials for containers used by the sessions of the session pool.
        """
elif False:
    CustomContainerTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomContainerTemplateArgs:
    def __init__(__self__, *,
                 containers: Optional[pulumi.Input[Sequence[pulumi.Input['SessionContainerArgs']]]] = None,
                 ingress: Optional[pulumi.Input['SessionIngressArgs']] = None,
                 registry_credentials: Optional[pulumi.Input['SessionRegistryCredentialsArgs']] = None):
        """
        Custom container configuration.
        :param pulumi.Input[Sequence[pulumi.Input['SessionContainerArgs']]] containers: List of container definitions for the sessions of the session pool.
        :param pulumi.Input['SessionIngressArgs'] ingress: Session pool ingress configuration.
        :param pulumi.Input['SessionRegistryCredentialsArgs'] registry_credentials: Private container registry credentials for containers used by the sessions of the session pool.
        """
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)

    @property
    @pulumi.getter
    def containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SessionContainerArgs']]]]:
        """
        List of container definitions for the sessions of the session pool.
        """
        return pulumi.get(self, "containers")

    @containers.setter
    def containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SessionContainerArgs']]]]):
        pulumi.set(self, "containers", value)

    @property
    @pulumi.getter
    def ingress(self) -> Optional[pulumi.Input['SessionIngressArgs']]:
        """
        Session pool ingress configuration.
        """
        return pulumi.get(self, "ingress")

    @ingress.setter
    def ingress(self, value: Optional[pulumi.Input['SessionIngressArgs']]):
        pulumi.set(self, "ingress", value)

    @property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional[pulumi.Input['SessionRegistryCredentialsArgs']]:
        """
        Private container registry credentials for containers used by the sessions of the session pool.
        """
        return pulumi.get(self, "registry_credentials")

    @registry_credentials.setter
    def registry_credentials(self, value: Optional[pulumi.Input['SessionRegistryCredentialsArgs']]):
        pulumi.set(self, "registry_credentials", value)


if not MYPY:
    class CustomDomainConfigurationArgsDict(TypedDict):
        """
        Configuration properties for apps environment custom domain
        """
        certificate_password: NotRequired[pulumi.Input[builtins.str]]
        """
        Certificate password
        """
        certificate_value: NotRequired[pulumi.Input[builtins.str]]
        """
        PFX or PEM blob
        """
        dns_suffix: NotRequired[pulumi.Input[builtins.str]]
        """
        Dns suffix for the environment domain
        """
elif False:
    CustomDomainConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDomainConfigurationArgs:
    def __init__(__self__, *,
                 certificate_password: Optional[pulumi.Input[builtins.str]] = None,
                 certificate_value: Optional[pulumi.Input[builtins.str]] = None,
                 dns_suffix: Optional[pulumi.Input[builtins.str]] = None):
        """
        Configuration properties for apps environment custom domain
        :param pulumi.Input[builtins.str] certificate_password: Certificate password
        :param pulumi.Input[builtins.str] certificate_value: PFX or PEM blob
        :param pulumi.Input[builtins.str] dns_suffix: Dns suffix for the environment domain
        """
        if certificate_password is not None:
            pulumi.set(__self__, "certificate_password", certificate_password)
        if certificate_value is not None:
            pulumi.set(__self__, "certificate_value", certificate_value)
        if dns_suffix is not None:
            pulumi.set(__self__, "dns_suffix", dns_suffix)

    @property
    @pulumi.getter(name="certificatePassword")
    def certificate_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Certificate password
        """
        return pulumi.get(self, "certificate_password")

    @certificate_password.setter
    def certificate_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_password", value)

    @property
    @pulumi.getter(name="certificateValue")
    def certificate_value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        PFX or PEM blob
        """
        return pulumi.get(self, "certificate_value")

    @certificate_value.setter
    def certificate_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_value", value)

    @property
    @pulumi.getter(name="dnsSuffix")
    def dns_suffix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Dns suffix for the environment domain
        """
        return pulumi.get(self, "dns_suffix")

    @dns_suffix.setter
    def dns_suffix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dns_suffix", value)


if not MYPY:
    class CustomDomainArgsDict(TypedDict):
        """
        Custom Domain of a Container App
        """
        name: pulumi.Input[builtins.str]
        """
        Hostname.
        """
        binding_type: NotRequired[pulumi.Input[Union[builtins.str, 'BindingType']]]
        """
        Custom Domain binding type.
        """
        certificate_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource Id of the Certificate to be bound to this hostname. Must exist in the Managed Environment.
        """
elif False:
    CustomDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDomainArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 binding_type: Optional[pulumi.Input[Union[builtins.str, 'BindingType']]] = None,
                 certificate_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Custom Domain of a Container App
        :param pulumi.Input[builtins.str] name: Hostname.
        :param pulumi.Input[Union[builtins.str, 'BindingType']] binding_type: Custom Domain binding type.
        :param pulumi.Input[builtins.str] certificate_id: Resource Id of the Certificate to be bound to this hostname. Must exist in the Managed Environment.
        """
        pulumi.set(__self__, "name", name)
        if binding_type is not None:
            pulumi.set(__self__, "binding_type", binding_type)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Hostname.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="bindingType")
    def binding_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'BindingType']]]:
        """
        Custom Domain binding type.
        """
        return pulumi.get(self, "binding_type")

    @binding_type.setter
    def binding_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'BindingType']]]):
        pulumi.set(self, "binding_type", value)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource Id of the Certificate to be bound to this hostname. Must exist in the Managed Environment.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_id", value)


if not MYPY:
    class CustomOpenIdConnectProviderArgsDict(TypedDict):
        """
        The configuration settings of the custom Open ID Connect provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        """
        login: NotRequired[pulumi.Input['OpenIdConnectLoginArgsDict']]
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        """
        registration: NotRequired[pulumi.Input['OpenIdConnectRegistrationArgsDict']]
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        """
elif False:
    CustomOpenIdConnectProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomOpenIdConnectProviderArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 login: Optional[pulumi.Input['OpenIdConnectLoginArgs']] = None,
                 registration: Optional[pulumi.Input['OpenIdConnectRegistrationArgs']] = None):
        """
        The configuration settings of the custom Open ID Connect provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        :param pulumi.Input['OpenIdConnectLoginArgs'] login: The configuration settings of the login flow of the custom Open ID Connect provider.
        :param pulumi.Input['OpenIdConnectRegistrationArgs'] registration: The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['OpenIdConnectLoginArgs']]:
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['OpenIdConnectLoginArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['OpenIdConnectRegistrationArgs']]:
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['OpenIdConnectRegistrationArgs']]):
        pulumi.set(self, "registration", value)


if not MYPY:
    class CustomScaleRuleArgsDict(TypedDict):
        """
        Container App container Custom scaling rule.
        """
        auth: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgsDict']]]]
        """
        Authentication secrets for the custom scale rule.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Metadata properties to describe custom scale rule.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of the custom scale rule
        eg: azure-servicebus, redis etc.
        """
elif False:
    CustomScaleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomScaleRuleArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        Container App container Custom scaling rule.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]] auth: Authentication secrets for the custom scale rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] metadata: Metadata properties to describe custom scale rule.
        :param pulumi.Input[builtins.str] type: Type of the custom scale rule
               eg: azure-servicebus, redis etc.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]:
        """
        Authentication secrets for the custom scale rule.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Metadata properties to describe custom scale rule.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of the custom scale rule
        eg: azure-servicebus, redis etc.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationArgsDict(TypedDict):
        """
        Dapr Component Resiliency Policy Circuit Breaker Policy Configuration.
        """
        consecutive_errors: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of consecutive errors before the circuit is opened.
        """
        interval_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        The optional interval in seconds after which the error count resets to 0. An interval of 0 will never reset. If not specified, the timeoutInSeconds value will be used.
        """
        timeout_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        The interval in seconds until a retry attempt is made after the circuit is opened.
        """
elif False:
    DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationArgs:
    def __init__(__self__, *,
                 consecutive_errors: Optional[pulumi.Input[builtins.int]] = None,
                 interval_in_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[builtins.int]] = None):
        """
        Dapr Component Resiliency Policy Circuit Breaker Policy Configuration.
        :param pulumi.Input[builtins.int] consecutive_errors: The number of consecutive errors before the circuit is opened.
        :param pulumi.Input[builtins.int] interval_in_seconds: The optional interval in seconds after which the error count resets to 0. An interval of 0 will never reset. If not specified, the timeoutInSeconds value will be used.
        :param pulumi.Input[builtins.int] timeout_in_seconds: The interval in seconds until a retry attempt is made after the circuit is opened.
        """
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of consecutive errors before the circuit is opened.
        """
        return pulumi.get(self, "consecutive_errors")

    @consecutive_errors.setter
    def consecutive_errors(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "consecutive_errors", value)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The optional interval in seconds after which the error count resets to 0. An interval of 0 will never reset. If not specified, the timeoutInSeconds value will be used.
        """
        return pulumi.get(self, "interval_in_seconds")

    @interval_in_seconds.setter
    def interval_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "interval_in_seconds", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The interval in seconds until a retry attempt is made after the circuit is opened.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout_in_seconds", value)


if not MYPY:
    class DaprComponentResiliencyPolicyConfigurationArgsDict(TypedDict):
        """
        Dapr Component Resiliency Policy Configuration.
        """
        circuit_breaker_policy: NotRequired[pulumi.Input['DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationArgsDict']]
        """
        The optional circuit breaker policy configuration
        """
        http_retry_policy: NotRequired[pulumi.Input['DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationArgsDict']]
        """
        The optional HTTP retry policy configuration
        """
        timeout_policy: NotRequired[pulumi.Input['DaprComponentResiliencyPolicyTimeoutPolicyConfigurationArgsDict']]
        """
        The optional timeout policy configuration
        """
elif False:
    DaprComponentResiliencyPolicyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DaprComponentResiliencyPolicyConfigurationArgs:
    def __init__(__self__, *,
                 circuit_breaker_policy: Optional[pulumi.Input['DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationArgs']] = None,
                 http_retry_policy: Optional[pulumi.Input['DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationArgs']] = None,
                 timeout_policy: Optional[pulumi.Input['DaprComponentResiliencyPolicyTimeoutPolicyConfigurationArgs']] = None):
        """
        Dapr Component Resiliency Policy Configuration.
        :param pulumi.Input['DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationArgs'] circuit_breaker_policy: The optional circuit breaker policy configuration
        :param pulumi.Input['DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationArgs'] http_retry_policy: The optional HTTP retry policy configuration
        :param pulumi.Input['DaprComponentResiliencyPolicyTimeoutPolicyConfigurationArgs'] timeout_policy: The optional timeout policy configuration
        """
        if circuit_breaker_policy is not None:
            pulumi.set(__self__, "circuit_breaker_policy", circuit_breaker_policy)
        if http_retry_policy is not None:
            pulumi.set(__self__, "http_retry_policy", http_retry_policy)
        if timeout_policy is not None:
            pulumi.set(__self__, "timeout_policy", timeout_policy)

    @property
    @pulumi.getter(name="circuitBreakerPolicy")
    def circuit_breaker_policy(self) -> Optional[pulumi.Input['DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationArgs']]:
        """
        The optional circuit breaker policy configuration
        """
        return pulumi.get(self, "circuit_breaker_policy")

    @circuit_breaker_policy.setter
    def circuit_breaker_policy(self, value: Optional[pulumi.Input['DaprComponentResiliencyPolicyCircuitBreakerPolicyConfigurationArgs']]):
        pulumi.set(self, "circuit_breaker_policy", value)

    @property
    @pulumi.getter(name="httpRetryPolicy")
    def http_retry_policy(self) -> Optional[pulumi.Input['DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationArgs']]:
        """
        The optional HTTP retry policy configuration
        """
        return pulumi.get(self, "http_retry_policy")

    @http_retry_policy.setter
    def http_retry_policy(self, value: Optional[pulumi.Input['DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationArgs']]):
        pulumi.set(self, "http_retry_policy", value)

    @property
    @pulumi.getter(name="timeoutPolicy")
    def timeout_policy(self) -> Optional[pulumi.Input['DaprComponentResiliencyPolicyTimeoutPolicyConfigurationArgs']]:
        """
        The optional timeout policy configuration
        """
        return pulumi.get(self, "timeout_policy")

    @timeout_policy.setter
    def timeout_policy(self, value: Optional[pulumi.Input['DaprComponentResiliencyPolicyTimeoutPolicyConfigurationArgs']]):
        pulumi.set(self, "timeout_policy", value)


if not MYPY:
    class DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationArgsDict(TypedDict):
        """
        Dapr Component Resiliency Policy HTTP Retry Backoff Configuration.
        """
        initial_delay_in_milliseconds: NotRequired[pulumi.Input[builtins.int]]
        """
        The optional initial delay in milliseconds before an operation is retried
        """
        max_interval_in_milliseconds: NotRequired[pulumi.Input[builtins.int]]
        """
        The optional maximum time interval in milliseconds between retry attempts
        """
elif False:
    DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationArgs:
    def __init__(__self__, *,
                 initial_delay_in_milliseconds: Optional[pulumi.Input[builtins.int]] = None,
                 max_interval_in_milliseconds: Optional[pulumi.Input[builtins.int]] = None):
        """
        Dapr Component Resiliency Policy HTTP Retry Backoff Configuration.
        :param pulumi.Input[builtins.int] initial_delay_in_milliseconds: The optional initial delay in milliseconds before an operation is retried
        :param pulumi.Input[builtins.int] max_interval_in_milliseconds: The optional maximum time interval in milliseconds between retry attempts
        """
        if initial_delay_in_milliseconds is not None:
            pulumi.set(__self__, "initial_delay_in_milliseconds", initial_delay_in_milliseconds)
        if max_interval_in_milliseconds is not None:
            pulumi.set(__self__, "max_interval_in_milliseconds", max_interval_in_milliseconds)

    @property
    @pulumi.getter(name="initialDelayInMilliseconds")
    def initial_delay_in_milliseconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The optional initial delay in milliseconds before an operation is retried
        """
        return pulumi.get(self, "initial_delay_in_milliseconds")

    @initial_delay_in_milliseconds.setter
    def initial_delay_in_milliseconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "initial_delay_in_milliseconds", value)

    @property
    @pulumi.getter(name="maxIntervalInMilliseconds")
    def max_interval_in_milliseconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The optional maximum time interval in milliseconds between retry attempts
        """
        return pulumi.get(self, "max_interval_in_milliseconds")

    @max_interval_in_milliseconds.setter
    def max_interval_in_milliseconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_interval_in_milliseconds", value)


if not MYPY:
    class DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationArgsDict(TypedDict):
        """
        Dapr Component Resiliency Policy HTTP Retry Policy Configuration.
        """
        max_retries: NotRequired[pulumi.Input[builtins.int]]
        """
        The optional maximum number of retries
        """
        retry_back_off: NotRequired[pulumi.Input['DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationArgsDict']]
        """
        The optional retry backoff configuration
        """
elif False:
    DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DaprComponentResiliencyPolicyHttpRetryPolicyConfigurationArgs:
    def __init__(__self__, *,
                 max_retries: Optional[pulumi.Input[builtins.int]] = None,
                 retry_back_off: Optional[pulumi.Input['DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationArgs']] = None):
        """
        Dapr Component Resiliency Policy HTTP Retry Policy Configuration.
        :param pulumi.Input[builtins.int] max_retries: The optional maximum number of retries
        :param pulumi.Input['DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationArgs'] retry_back_off: The optional retry backoff configuration
        """
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if retry_back_off is not None:
            pulumi.set(__self__, "retry_back_off", retry_back_off)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The optional maximum number of retries
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="retryBackOff")
    def retry_back_off(self) -> Optional[pulumi.Input['DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationArgs']]:
        """
        The optional retry backoff configuration
        """
        return pulumi.get(self, "retry_back_off")

    @retry_back_off.setter
    def retry_back_off(self, value: Optional[pulumi.Input['DaprComponentResiliencyPolicyHttpRetryBackOffConfigurationArgs']]):
        pulumi.set(self, "retry_back_off", value)


if not MYPY:
    class DaprComponentResiliencyPolicyTimeoutPolicyConfigurationArgsDict(TypedDict):
        """
        Dapr Component Resiliency Policy Timeout Policy Configuration.
        """
        response_timeout_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        The optional response timeout in seconds
        """
elif False:
    DaprComponentResiliencyPolicyTimeoutPolicyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DaprComponentResiliencyPolicyTimeoutPolicyConfigurationArgs:
    def __init__(__self__, *,
                 response_timeout_in_seconds: Optional[pulumi.Input[builtins.int]] = None):
        """
        Dapr Component Resiliency Policy Timeout Policy Configuration.
        :param pulumi.Input[builtins.int] response_timeout_in_seconds: The optional response timeout in seconds
        """
        if response_timeout_in_seconds is not None:
            pulumi.set(__self__, "response_timeout_in_seconds", response_timeout_in_seconds)

    @property
    @pulumi.getter(name="responseTimeoutInSeconds")
    def response_timeout_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The optional response timeout in seconds
        """
        return pulumi.get(self, "response_timeout_in_seconds")

    @response_timeout_in_seconds.setter
    def response_timeout_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "response_timeout_in_seconds", value)


if not MYPY:
    class DaprMetadataArgsDict(TypedDict):
        """
        Dapr component metadata.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Metadata property name.
        """
        secret_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the Dapr Component secret from which to pull the metadata property value.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Metadata property value.
        """
elif False:
    DaprMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DaprMetadataArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Dapr component metadata.
        :param pulumi.Input[builtins.str] name: Metadata property name.
        :param pulumi.Input[builtins.str] secret_ref: Name of the Dapr Component secret from which to pull the metadata property value.
        :param pulumi.Input[builtins.str] value: Metadata property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Metadata property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the Dapr Component secret from which to pull the metadata property value.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_ref", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Metadata property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DaprSubscriptionBulkSubscribeOptionsArgsDict(TypedDict):
        """
        Dapr PubSub Bulk Subscription Options.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable bulk subscription
        """
        max_await_duration_ms: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum duration in milliseconds to wait before a bulk message is sent to the app.
        """
        max_messages_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of messages to deliver in a bulk message.
        """
elif False:
    DaprSubscriptionBulkSubscribeOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DaprSubscriptionBulkSubscribeOptionsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 max_await_duration_ms: Optional[pulumi.Input[builtins.int]] = None,
                 max_messages_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        Dapr PubSub Bulk Subscription Options.
        :param pulumi.Input[builtins.bool] enabled: Enable bulk subscription
        :param pulumi.Input[builtins.int] max_await_duration_ms: Maximum duration in milliseconds to wait before a bulk message is sent to the app.
        :param pulumi.Input[builtins.int] max_messages_count: Maximum number of messages to deliver in a bulk message.
        """
        if enabled is None:
            enabled = False
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_await_duration_ms is not None:
            pulumi.set(__self__, "max_await_duration_ms", max_await_duration_ms)
        if max_messages_count is not None:
            pulumi.set(__self__, "max_messages_count", max_messages_count)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable bulk subscription
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxAwaitDurationMs")
    def max_await_duration_ms(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum duration in milliseconds to wait before a bulk message is sent to the app.
        """
        return pulumi.get(self, "max_await_duration_ms")

    @max_await_duration_ms.setter
    def max_await_duration_ms(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_await_duration_ms", value)

    @property
    @pulumi.getter(name="maxMessagesCount")
    def max_messages_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of messages to deliver in a bulk message.
        """
        return pulumi.get(self, "max_messages_count")

    @max_messages_count.setter
    def max_messages_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_messages_count", value)


if not MYPY:
    class DaprSubscriptionRouteRuleArgsDict(TypedDict):
        """
        Dapr Pubsub Event Subscription Route Rule is used to specify the condition for sending a message to a specific path.
        """
        match: NotRequired[pulumi.Input[builtins.str]]
        """
        The optional CEL expression used to match the event. If the match is not specified, then the route is considered the default. The rules are tested in the order specified, so they should be define from most-to-least specific. The default route should appear last in the list.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        The path for events that match this rule
        """
elif False:
    DaprSubscriptionRouteRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DaprSubscriptionRouteRuleArgs:
    def __init__(__self__, *,
                 match: Optional[pulumi.Input[builtins.str]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None):
        """
        Dapr Pubsub Event Subscription Route Rule is used to specify the condition for sending a message to a specific path.
        :param pulumi.Input[builtins.str] match: The optional CEL expression used to match the event. If the match is not specified, then the route is considered the default. The rules are tested in the order specified, so they should be define from most-to-least specific. The default route should appear last in the list.
        :param pulumi.Input[builtins.str] path: The path for events that match this rule
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The optional CEL expression used to match the event. If the match is not specified, then the route is considered the default. The rules are tested in the order specified, so they should be define from most-to-least specific. The default route should appear last in the list.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The path for events that match this rule
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class DaprSubscriptionRoutesArgsDict(TypedDict):
        """
        Dapr PubSub Event Subscription Routes configuration.
        """
        default: NotRequired[pulumi.Input[builtins.str]]
        """
        The default path to deliver events that do not match any of the rules.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DaprSubscriptionRouteRuleArgsDict']]]]
        """
        The list of Dapr PubSub Event Subscription Route Rules.
        """
elif False:
    DaprSubscriptionRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DaprSubscriptionRoutesArgs:
    def __init__(__self__, *,
                 default: Optional[pulumi.Input[builtins.str]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['DaprSubscriptionRouteRuleArgs']]]] = None):
        """
        Dapr PubSub Event Subscription Routes configuration.
        :param pulumi.Input[builtins.str] default: The default path to deliver events that do not match any of the rules.
        :param pulumi.Input[Sequence[pulumi.Input['DaprSubscriptionRouteRuleArgs']]] rules: The list of Dapr PubSub Event Subscription Route Rules.
        """
        if default is not None:
            pulumi.set(__self__, "default", default)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The default path to deliver events that do not match any of the rules.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DaprSubscriptionRouteRuleArgs']]]]:
        """
        The list of Dapr PubSub Event Subscription Route Rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DaprSubscriptionRouteRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class DaprArgsDict(TypedDict):
        """
        Container App Dapr configuration.
        """
        app_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Dapr application identifier
        """
        app_port: NotRequired[pulumi.Input[builtins.int]]
        """
        Tells Dapr which port your application is listening on
        """
        app_protocol: NotRequired[pulumi.Input[Union[builtins.str, 'AppProtocol']]]
        """
        Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
        """
        enable_api_logging: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enables API logging for the Dapr sidecar
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Boolean indicating if the Dapr side car is enabled
        """
        http_max_request_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Increasing max size of request body http and grpc servers parameter in MB to handle uploading of big files. Default is 4 MB.
        """
        http_read_buffer_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        """
        log_level: NotRequired[pulumi.Input[Union[builtins.str, 'LogLevel']]]
        """
        Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        """
elif False:
    DaprArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DaprArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[builtins.str]] = None,
                 app_port: Optional[pulumi.Input[builtins.int]] = None,
                 app_protocol: Optional[pulumi.Input[Union[builtins.str, 'AppProtocol']]] = None,
                 enable_api_logging: Optional[pulumi.Input[builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 http_max_request_size: Optional[pulumi.Input[builtins.int]] = None,
                 http_read_buffer_size: Optional[pulumi.Input[builtins.int]] = None,
                 log_level: Optional[pulumi.Input[Union[builtins.str, 'LogLevel']]] = None):
        """
        Container App Dapr configuration.
        :param pulumi.Input[builtins.str] app_id: Dapr application identifier
        :param pulumi.Input[builtins.int] app_port: Tells Dapr which port your application is listening on
        :param pulumi.Input[Union[builtins.str, 'AppProtocol']] app_protocol: Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
        :param pulumi.Input[builtins.bool] enable_api_logging: Enables API logging for the Dapr sidecar
        :param pulumi.Input[builtins.bool] enabled: Boolean indicating if the Dapr side car is enabled
        :param pulumi.Input[builtins.int] http_max_request_size: Increasing max size of request body http and grpc servers parameter in MB to handle uploading of big files. Default is 4 MB.
        :param pulumi.Input[builtins.int] http_read_buffer_size: Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        :param pulumi.Input[Union[builtins.str, 'LogLevel']] log_level: Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        """
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if app_port is not None:
            pulumi.set(__self__, "app_port", app_port)
        if app_protocol is None:
            app_protocol = 'http'
        if app_protocol is not None:
            pulumi.set(__self__, "app_protocol", app_protocol)
        if enable_api_logging is not None:
            pulumi.set(__self__, "enable_api_logging", enable_api_logging)
        if enabled is None:
            enabled = False
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if http_max_request_size is not None:
            pulumi.set(__self__, "http_max_request_size", http_max_request_size)
        if http_read_buffer_size is not None:
            pulumi.set(__self__, "http_read_buffer_size", http_read_buffer_size)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Dapr application identifier
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appPort")
    def app_port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Tells Dapr which port your application is listening on
        """
        return pulumi.get(self, "app_port")

    @app_port.setter
    def app_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "app_port", value)

    @property
    @pulumi.getter(name="appProtocol")
    def app_protocol(self) -> Optional[pulumi.Input[Union[builtins.str, 'AppProtocol']]]:
        """
        Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
        """
        return pulumi.get(self, "app_protocol")

    @app_protocol.setter
    def app_protocol(self, value: Optional[pulumi.Input[Union[builtins.str, 'AppProtocol']]]):
        pulumi.set(self, "app_protocol", value)

    @property
    @pulumi.getter(name="enableApiLogging")
    def enable_api_logging(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enables API logging for the Dapr sidecar
        """
        return pulumi.get(self, "enable_api_logging")

    @enable_api_logging.setter
    def enable_api_logging(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_api_logging", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Boolean indicating if the Dapr side car is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="httpMaxRequestSize")
    def http_max_request_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Increasing max size of request body http and grpc servers parameter in MB to handle uploading of big files. Default is 4 MB.
        """
        return pulumi.get(self, "http_max_request_size")

    @http_max_request_size.setter
    def http_max_request_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "http_max_request_size", value)

    @property
    @pulumi.getter(name="httpReadBufferSize")
    def http_read_buffer_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        """
        return pulumi.get(self, "http_read_buffer_size")

    @http_read_buffer_size.setter
    def http_read_buffer_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "http_read_buffer_size", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[Union[builtins.str, 'LogLevel']]]:
        """
        Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[Union[builtins.str, 'LogLevel']]]):
        pulumi.set(self, "log_level", value)


if not MYPY:
    class DefaultAuthorizationPolicyArgsDict(TypedDict):
        """
        The configuration settings of the Azure Active Directory default authorization policy.
        """
        allowed_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The configuration settings of the Azure Active Directory allowed applications.
        """
        allowed_principals: NotRequired[pulumi.Input['AllowedPrincipalsArgsDict']]
        """
        The configuration settings of the Azure Active Directory allowed principals.
        """
elif False:
    DefaultAuthorizationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefaultAuthorizationPolicyArgs:
    def __init__(__self__, *,
                 allowed_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 allowed_principals: Optional[pulumi.Input['AllowedPrincipalsArgs']] = None):
        """
        The configuration settings of the Azure Active Directory default authorization policy.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_applications: The configuration settings of the Azure Active Directory allowed applications.
        :param pulumi.Input['AllowedPrincipalsArgs'] allowed_principals: The configuration settings of the Azure Active Directory allowed principals.
        """
        if allowed_applications is not None:
            pulumi.set(__self__, "allowed_applications", allowed_applications)
        if allowed_principals is not None:
            pulumi.set(__self__, "allowed_principals", allowed_principals)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The configuration settings of the Azure Active Directory allowed applications.
        """
        return pulumi.get(self, "allowed_applications")

    @allowed_applications.setter
    def allowed_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_applications", value)

    @property
    @pulumi.getter(name="allowedPrincipals")
    def allowed_principals(self) -> Optional[pulumi.Input['AllowedPrincipalsArgs']]:
        """
        The configuration settings of the Azure Active Directory allowed principals.
        """
        return pulumi.get(self, "allowed_principals")

    @allowed_principals.setter
    def allowed_principals(self, value: Optional[pulumi.Input['AllowedPrincipalsArgs']]):
        pulumi.set(self, "allowed_principals", value)


if not MYPY:
    class DotNetComponentConfigurationPropertyArgsDict(TypedDict):
        """
        Configuration properties for a .NET Component
        """
        property_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the property
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        The value of the property
        """
elif False:
    DotNetComponentConfigurationPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DotNetComponentConfigurationPropertyArgs:
    def __init__(__self__, *,
                 property_name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Configuration properties for a .NET Component
        :param pulumi.Input[builtins.str] property_name: The name of the property
        :param pulumi.Input[builtins.str] value: The value of the property
        """
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the property
        """
        return pulumi.get(self, "property_name")

    @property_name.setter
    def property_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "property_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The value of the property
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DotNetComponentServiceBindArgsDict(TypedDict):
        """
        Configuration to bind a .NET Component to another .NET Component
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the service bind
        """
        service_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource id of the target service
        """
elif False:
    DotNetComponentServiceBindArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DotNetComponentServiceBindArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 service_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Configuration to bind a .NET Component to another .NET Component
        :param pulumi.Input[builtins.str] name: Name of the service bind
        :param pulumi.Input[builtins.str] service_id: Resource id of the target service
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the service bind
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource id of the target service
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_id", value)


if not MYPY:
    class DynamicPoolConfigurationArgsDict(TypedDict):
        """
        Dynamic pool configuration.
        """
        cooldown_period_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        The cooldown period of a session in seconds.
        """
        execution_type: NotRequired[pulumi.Input[Union[builtins.str, 'ExecutionType']]]
        """
        The execution type of the session pool.
        """
elif False:
    DynamicPoolConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DynamicPoolConfigurationArgs:
    def __init__(__self__, *,
                 cooldown_period_in_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 execution_type: Optional[pulumi.Input[Union[builtins.str, 'ExecutionType']]] = None):
        """
        Dynamic pool configuration.
        :param pulumi.Input[builtins.int] cooldown_period_in_seconds: The cooldown period of a session in seconds.
        :param pulumi.Input[Union[builtins.str, 'ExecutionType']] execution_type: The execution type of the session pool.
        """
        if cooldown_period_in_seconds is not None:
            pulumi.set(__self__, "cooldown_period_in_seconds", cooldown_period_in_seconds)
        if execution_type is not None:
            pulumi.set(__self__, "execution_type", execution_type)

    @property
    @pulumi.getter(name="cooldownPeriodInSeconds")
    def cooldown_period_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The cooldown period of a session in seconds.
        """
        return pulumi.get(self, "cooldown_period_in_seconds")

    @cooldown_period_in_seconds.setter
    def cooldown_period_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "cooldown_period_in_seconds", value)

    @property
    @pulumi.getter(name="executionType")
    def execution_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ExecutionType']]]:
        """
        The execution type of the session pool.
        """
        return pulumi.get(self, "execution_type")

    @execution_type.setter
    def execution_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ExecutionType']]]):
        pulumi.set(self, "execution_type", value)


if not MYPY:
    class EncryptionSettingsArgsDict(TypedDict):
        """
        The configuration settings of the secrets references of encryption key and signing key for ContainerApp Service Authentication/Authorization.
        """
        container_app_auth_encryption_secret_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The secret name which is referenced for EncryptionKey.
        """
        container_app_auth_signing_secret_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The secret name which is referenced for SigningKey.
        """
elif False:
    EncryptionSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionSettingsArgs:
    def __init__(__self__, *,
                 container_app_auth_encryption_secret_name: Optional[pulumi.Input[builtins.str]] = None,
                 container_app_auth_signing_secret_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the secrets references of encryption key and signing key for ContainerApp Service Authentication/Authorization.
        :param pulumi.Input[builtins.str] container_app_auth_encryption_secret_name: The secret name which is referenced for EncryptionKey.
        :param pulumi.Input[builtins.str] container_app_auth_signing_secret_name: The secret name which is referenced for SigningKey.
        """
        if container_app_auth_encryption_secret_name is not None:
            pulumi.set(__self__, "container_app_auth_encryption_secret_name", container_app_auth_encryption_secret_name)
        if container_app_auth_signing_secret_name is not None:
            pulumi.set(__self__, "container_app_auth_signing_secret_name", container_app_auth_signing_secret_name)

    @property
    @pulumi.getter(name="containerAppAuthEncryptionSecretName")
    def container_app_auth_encryption_secret_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The secret name which is referenced for EncryptionKey.
        """
        return pulumi.get(self, "container_app_auth_encryption_secret_name")

    @container_app_auth_encryption_secret_name.setter
    def container_app_auth_encryption_secret_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "container_app_auth_encryption_secret_name", value)

    @property
    @pulumi.getter(name="containerAppAuthSigningSecretName")
    def container_app_auth_signing_secret_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The secret name which is referenced for SigningKey.
        """
        return pulumi.get(self, "container_app_auth_signing_secret_name")

    @container_app_auth_signing_secret_name.setter
    def container_app_auth_signing_secret_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "container_app_auth_signing_secret_name", value)


if not MYPY:
    class EnvironmentVariableArgsDict(TypedDict):
        """
        Model representing an environment variable.
        """
        name: pulumi.Input[builtins.str]
        """
        Environment variable name.
        """
        value: pulumi.Input[builtins.str]
        """
        Environment variable value.
        """
elif False:
    EnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        Model representing an environment variable.
        :param pulumi.Input[builtins.str] name: Environment variable name.
        :param pulumi.Input[builtins.str] value: Environment variable value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Environment variable name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EnvironmentVarArgsDict(TypedDict):
        """
        Container App container environment variable.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Environment variable name.
        """
        secret_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the Container App secret from which to pull the environment variable value.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Non-secret environment variable value.
        """
elif False:
    EnvironmentVarArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentVarArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Container App container environment variable.
        :param pulumi.Input[builtins.str] name: Environment variable name.
        :param pulumi.Input[builtins.str] secret_ref: Name of the Container App secret from which to pull the environment variable value.
        :param pulumi.Input[builtins.str] value: Non-secret environment variable value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Environment variable name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the Container App secret from which to pull the environment variable value.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_ref", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Non-secret environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ExtendedLocationArgsDict(TypedDict):
        """
        The complex type of the extended location.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the extended location.
        """
        type: NotRequired[pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']]]
        """
        The type of the extended location.
        """
elif False:
    ExtendedLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExtendedLocationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']]] = None):
        """
        The complex type of the extended location.
        :param pulumi.Input[builtins.str] name: The name of the extended location.
        :param pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']] type: The type of the extended location.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the extended location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']]]:
        """
        The type of the extended location.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[builtins.str, 'ExtendedLocationTypes']]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FacebookArgsDict(TypedDict):
        """
        The configuration settings of the Facebook provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        graph_api_version: NotRequired[pulumi.Input[builtins.str]]
        """
        The version of the Facebook api to be used while logging in.
        """
        login: NotRequired[pulumi.Input['LoginScopesArgsDict']]
        """
        The configuration settings of the login flow.
        """
        registration: NotRequired[pulumi.Input['AppRegistrationArgsDict']]
        """
        The configuration settings of the app registration for the Facebook provider.
        """
elif False:
    FacebookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FacebookArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 graph_api_version: Optional[pulumi.Input[builtins.str]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['AppRegistrationArgs']] = None):
        """
        The configuration settings of the Facebook provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input[builtins.str] graph_api_version: The version of the Facebook api to be used while logging in.
        :param pulumi.Input['LoginScopesArgs'] login: The configuration settings of the login flow.
        :param pulumi.Input['AppRegistrationArgs'] registration: The configuration settings of the app registration for the Facebook provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if graph_api_version is not None:
            pulumi.set(__self__, "graph_api_version", graph_api_version)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The version of the Facebook api to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @graph_api_version.setter
    def graph_api_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "graph_api_version", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AppRegistrationArgs']]:
        """
        The configuration settings of the app registration for the Facebook provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AppRegistrationArgs']]):
        pulumi.set(self, "registration", value)


if not MYPY:
    class ForwardProxyArgsDict(TypedDict):
        """
        The configuration settings of a forward proxy used to make the requests.
        """
        convention: NotRequired[pulumi.Input['ForwardProxyConvention']]
        """
        The convention used to determine the url of the request made.
        """
        custom_host_header_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the header containing the host of the request.
        """
        custom_proto_header_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the header containing the scheme of the request.
        """
elif False:
    ForwardProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ForwardProxyArgs:
    def __init__(__self__, *,
                 convention: Optional[pulumi.Input['ForwardProxyConvention']] = None,
                 custom_host_header_name: Optional[pulumi.Input[builtins.str]] = None,
                 custom_proto_header_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of a forward proxy used to make the requests.
        :param pulumi.Input['ForwardProxyConvention'] convention: The convention used to determine the url of the request made.
        :param pulumi.Input[builtins.str] custom_host_header_name: The name of the header containing the host of the request.
        :param pulumi.Input[builtins.str] custom_proto_header_name: The name of the header containing the scheme of the request.
        """
        if convention is not None:
            pulumi.set(__self__, "convention", convention)
        if custom_host_header_name is not None:
            pulumi.set(__self__, "custom_host_header_name", custom_host_header_name)
        if custom_proto_header_name is not None:
            pulumi.set(__self__, "custom_proto_header_name", custom_proto_header_name)

    @property
    @pulumi.getter
    def convention(self) -> Optional[pulumi.Input['ForwardProxyConvention']]:
        """
        The convention used to determine the url of the request made.
        """
        return pulumi.get(self, "convention")

    @convention.setter
    def convention(self, value: Optional[pulumi.Input['ForwardProxyConvention']]):
        pulumi.set(self, "convention", value)

    @property
    @pulumi.getter(name="customHostHeaderName")
    def custom_host_header_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the header containing the host of the request.
        """
        return pulumi.get(self, "custom_host_header_name")

    @custom_host_header_name.setter
    def custom_host_header_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_host_header_name", value)

    @property
    @pulumi.getter(name="customProtoHeaderName")
    def custom_proto_header_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the header containing the scheme of the request.
        """
        return pulumi.get(self, "custom_proto_header_name")

    @custom_proto_header_name.setter
    def custom_proto_header_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_proto_header_name", value)


if not MYPY:
    class GitHubArgsDict(TypedDict):
        """
        The configuration settings of the GitHub provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        login: NotRequired[pulumi.Input['LoginScopesArgsDict']]
        """
        The configuration settings of the login flow.
        """
        registration: NotRequired[pulumi.Input['ClientRegistrationArgsDict']]
        """
        The configuration settings of the app registration for the GitHub provider.
        """
elif False:
    GitHubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitHubArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['ClientRegistrationArgs']] = None):
        """
        The configuration settings of the GitHub provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['LoginScopesArgs'] login: The configuration settings of the login flow.
        :param pulumi.Input['ClientRegistrationArgs'] registration: The configuration settings of the app registration for the GitHub provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['ClientRegistrationArgs']]:
        """
        The configuration settings of the app registration for the GitHub provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['ClientRegistrationArgs']]):
        pulumi.set(self, "registration", value)


if not MYPY:
    class GithubActionConfigurationArgsDict(TypedDict):
        """
        Configuration properties that define the mutable settings of a Container App SourceControl
        """
        azure_credentials: NotRequired[pulumi.Input['AzureCredentialsArgsDict']]
        """
        AzureCredentials configurations.
        """
        context_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Context path
        """
        github_personal_access_token: NotRequired[pulumi.Input[builtins.str]]
        """
        One time Github PAT to configure github environment
        """
        image: NotRequired[pulumi.Input[builtins.str]]
        """
        Image name
        """
        os: NotRequired[pulumi.Input[builtins.str]]
        """
        Operation system
        """
        publish_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Code or Image
        """
        registry_info: NotRequired[pulumi.Input['RegistryInfoArgsDict']]
        """
        Registry configurations.
        """
        runtime_stack: NotRequired[pulumi.Input[builtins.str]]
        """
        Runtime stack
        """
        runtime_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Runtime version
        """
elif False:
    GithubActionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GithubActionConfigurationArgs:
    def __init__(__self__, *,
                 azure_credentials: Optional[pulumi.Input['AzureCredentialsArgs']] = None,
                 context_path: Optional[pulumi.Input[builtins.str]] = None,
                 github_personal_access_token: Optional[pulumi.Input[builtins.str]] = None,
                 image: Optional[pulumi.Input[builtins.str]] = None,
                 os: Optional[pulumi.Input[builtins.str]] = None,
                 publish_type: Optional[pulumi.Input[builtins.str]] = None,
                 registry_info: Optional[pulumi.Input['RegistryInfoArgs']] = None,
                 runtime_stack: Optional[pulumi.Input[builtins.str]] = None,
                 runtime_version: Optional[pulumi.Input[builtins.str]] = None):
        """
        Configuration properties that define the mutable settings of a Container App SourceControl
        :param pulumi.Input['AzureCredentialsArgs'] azure_credentials: AzureCredentials configurations.
        :param pulumi.Input[builtins.str] context_path: Context path
        :param pulumi.Input[builtins.str] github_personal_access_token: One time Github PAT to configure github environment
        :param pulumi.Input[builtins.str] image: Image name
        :param pulumi.Input[builtins.str] os: Operation system
        :param pulumi.Input[builtins.str] publish_type: Code or Image
        :param pulumi.Input['RegistryInfoArgs'] registry_info: Registry configurations.
        :param pulumi.Input[builtins.str] runtime_stack: Runtime stack
        :param pulumi.Input[builtins.str] runtime_version: Runtime version
        """
        if azure_credentials is not None:
            pulumi.set(__self__, "azure_credentials", azure_credentials)
        if context_path is not None:
            pulumi.set(__self__, "context_path", context_path)
        if github_personal_access_token is not None:
            pulumi.set(__self__, "github_personal_access_token", github_personal_access_token)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if publish_type is not None:
            pulumi.set(__self__, "publish_type", publish_type)
        if registry_info is not None:
            pulumi.set(__self__, "registry_info", registry_info)
        if runtime_stack is not None:
            pulumi.set(__self__, "runtime_stack", runtime_stack)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="azureCredentials")
    def azure_credentials(self) -> Optional[pulumi.Input['AzureCredentialsArgs']]:
        """
        AzureCredentials configurations.
        """
        return pulumi.get(self, "azure_credentials")

    @azure_credentials.setter
    def azure_credentials(self, value: Optional[pulumi.Input['AzureCredentialsArgs']]):
        pulumi.set(self, "azure_credentials", value)

    @property
    @pulumi.getter(name="contextPath")
    def context_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Context path
        """
        return pulumi.get(self, "context_path")

    @context_path.setter
    def context_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "context_path", value)

    @property
    @pulumi.getter(name="githubPersonalAccessToken")
    def github_personal_access_token(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        One time Github PAT to configure github environment
        """
        return pulumi.get(self, "github_personal_access_token")

    @github_personal_access_token.setter
    def github_personal_access_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "github_personal_access_token", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Image name
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def os(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Operation system
        """
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "os", value)

    @property
    @pulumi.getter(name="publishType")
    def publish_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Code or Image
        """
        return pulumi.get(self, "publish_type")

    @publish_type.setter
    def publish_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "publish_type", value)

    @property
    @pulumi.getter(name="registryInfo")
    def registry_info(self) -> Optional[pulumi.Input['RegistryInfoArgs']]:
        """
        Registry configurations.
        """
        return pulumi.get(self, "registry_info")

    @registry_info.setter
    def registry_info(self, value: Optional[pulumi.Input['RegistryInfoArgs']]):
        pulumi.set(self, "registry_info", value)

    @property
    @pulumi.getter(name="runtimeStack")
    def runtime_stack(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Runtime stack
        """
        return pulumi.get(self, "runtime_stack")

    @runtime_stack.setter
    def runtime_stack(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "runtime_stack", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Runtime version
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "runtime_version", value)


if not MYPY:
    class GlobalValidationArgsDict(TypedDict):
        """
        The configuration settings that determines the validation flow of users using ContainerApp Service Authentication/Authorization.
        """
        excluded_paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The paths for which unauthenticated flow would not be redirected to the login page.
        """
        redirect_to_provider: NotRequired[pulumi.Input[builtins.str]]
        """
        The default authentication provider to use when multiple providers are configured.
        This setting is only needed if multiple providers are configured and the unauthenticated client
        action is set to "RedirectToLoginPage".
        """
        unauthenticated_client_action: NotRequired[pulumi.Input['UnauthenticatedClientActionV2']]
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
elif False:
    GlobalValidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalValidationArgs:
    def __init__(__self__, *,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 redirect_to_provider: Optional[pulumi.Input[builtins.str]] = None,
                 unauthenticated_client_action: Optional[pulumi.Input['UnauthenticatedClientActionV2']] = None):
        """
        The configuration settings that determines the validation flow of users using ContainerApp Service Authentication/Authorization.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excluded_paths: The paths for which unauthenticated flow would not be redirected to the login page.
        :param pulumi.Input[builtins.str] redirect_to_provider: The default authentication provider to use when multiple providers are configured.
               This setting is only needed if multiple providers are configured and the unauthenticated client
               action is set to "RedirectToLoginPage".
        :param pulumi.Input['UnauthenticatedClientActionV2'] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app.
        """
        if excluded_paths is not None:
            pulumi.set(__self__, "excluded_paths", excluded_paths)
        if redirect_to_provider is not None:
            pulumi.set(__self__, "redirect_to_provider", redirect_to_provider)
        if unauthenticated_client_action is not None:
            pulumi.set(__self__, "unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The paths for which unauthenticated flow would not be redirected to the login page.
        """
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter(name="redirectToProvider")
    def redirect_to_provider(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The default authentication provider to use when multiple providers are configured.
        This setting is only needed if multiple providers are configured and the unauthenticated client
        action is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "redirect_to_provider")

    @redirect_to_provider.setter
    def redirect_to_provider(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_to_provider", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input['UnauthenticatedClientActionV2']]:
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input['UnauthenticatedClientActionV2']]):
        pulumi.set(self, "unauthenticated_client_action", value)


if not MYPY:
    class GoogleArgsDict(TypedDict):
        """
        The configuration settings of the Google provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        login: NotRequired[pulumi.Input['LoginScopesArgsDict']]
        """
        The configuration settings of the login flow.
        """
        registration: NotRequired[pulumi.Input['ClientRegistrationArgsDict']]
        """
        The configuration settings of the app registration for the Google provider.
        """
        validation: NotRequired[pulumi.Input['AllowedAudiencesValidationArgsDict']]
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
elif False:
    GoogleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GoogleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['ClientRegistrationArgs']] = None,
                 validation: Optional[pulumi.Input['AllowedAudiencesValidationArgs']] = None):
        """
        The configuration settings of the Google provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['LoginScopesArgs'] login: The configuration settings of the login flow.
        :param pulumi.Input['ClientRegistrationArgs'] registration: The configuration settings of the app registration for the Google provider.
        :param pulumi.Input['AllowedAudiencesValidationArgs'] validation: The configuration settings of the Azure Active Directory token validation flow.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if login is not None:
            pulumi.set(__self__, "login", login)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['ClientRegistrationArgs']]:
        """
        The configuration settings of the app registration for the Google provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['ClientRegistrationArgs']]):
        pulumi.set(self, "registration", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input['AllowedAudiencesValidationArgs']]:
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input['AllowedAudiencesValidationArgs']]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class HeaderMatchArgsDict(TypedDict):
        """
        Conditions required to match a header
        """
        exact_match: NotRequired[pulumi.Input[builtins.str]]
        """
        Exact value of the header
        """
        header: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the header
        """
        prefix_match: NotRequired[pulumi.Input[builtins.str]]
        """
        Prefix value of the header
        """
        regex_match: NotRequired[pulumi.Input[builtins.str]]
        """
        Regex value of the header
        """
        suffix_match: NotRequired[pulumi.Input[builtins.str]]
        """
        Suffix value of the header
        """
elif False:
    HeaderMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HeaderMatchArgs:
    def __init__(__self__, *,
                 exact_match: Optional[pulumi.Input[builtins.str]] = None,
                 header: Optional[pulumi.Input[builtins.str]] = None,
                 prefix_match: Optional[pulumi.Input[builtins.str]] = None,
                 regex_match: Optional[pulumi.Input[builtins.str]] = None,
                 suffix_match: Optional[pulumi.Input[builtins.str]] = None):
        """
        Conditions required to match a header
        :param pulumi.Input[builtins.str] exact_match: Exact value of the header
        :param pulumi.Input[builtins.str] header: Name of the header
        :param pulumi.Input[builtins.str] prefix_match: Prefix value of the header
        :param pulumi.Input[builtins.str] regex_match: Regex value of the header
        :param pulumi.Input[builtins.str] suffix_match: Suffix value of the header
        """
        if exact_match is not None:
            pulumi.set(__self__, "exact_match", exact_match)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if prefix_match is not None:
            pulumi.set(__self__, "prefix_match", prefix_match)
        if regex_match is not None:
            pulumi.set(__self__, "regex_match", regex_match)
        if suffix_match is not None:
            pulumi.set(__self__, "suffix_match", suffix_match)

    @property
    @pulumi.getter(name="exactMatch")
    def exact_match(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Exact value of the header
        """
        return pulumi.get(self, "exact_match")

    @exact_match.setter
    def exact_match(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "exact_match", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the header
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="prefixMatch")
    def prefix_match(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Prefix value of the header
        """
        return pulumi.get(self, "prefix_match")

    @prefix_match.setter
    def prefix_match(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "prefix_match", value)

    @property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Regex value of the header
        """
        return pulumi.get(self, "regex_match")

    @regex_match.setter
    def regex_match(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "regex_match", value)

    @property
    @pulumi.getter(name="suffixMatch")
    def suffix_match(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Suffix value of the header
        """
        return pulumi.get(self, "suffix_match")

    @suffix_match.setter
    def suffix_match(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "suffix_match", value)


if not MYPY:
    class HttpConnectionPoolArgsDict(TypedDict):
        """
        Defines parameters for http connection pooling
        """
        http1_max_pending_requests: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of pending http1 requests allowed
        """
        http2_max_requests: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of http2 requests allowed
        """
elif False:
    HttpConnectionPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpConnectionPoolArgs:
    def __init__(__self__, *,
                 http1_max_pending_requests: Optional[pulumi.Input[builtins.int]] = None,
                 http2_max_requests: Optional[pulumi.Input[builtins.int]] = None):
        """
        Defines parameters for http connection pooling
        :param pulumi.Input[builtins.int] http1_max_pending_requests: Maximum number of pending http1 requests allowed
        :param pulumi.Input[builtins.int] http2_max_requests: Maximum number of http2 requests allowed
        """
        if http1_max_pending_requests is not None:
            pulumi.set(__self__, "http1_max_pending_requests", http1_max_pending_requests)
        if http2_max_requests is not None:
            pulumi.set(__self__, "http2_max_requests", http2_max_requests)

    @property
    @pulumi.getter(name="http1MaxPendingRequests")
    def http1_max_pending_requests(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of pending http1 requests allowed
        """
        return pulumi.get(self, "http1_max_pending_requests")

    @http1_max_pending_requests.setter
    def http1_max_pending_requests(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "http1_max_pending_requests", value)

    @property
    @pulumi.getter(name="http2MaxRequests")
    def http2_max_requests(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of http2 requests allowed
        """
        return pulumi.get(self, "http2_max_requests")

    @http2_max_requests.setter
    def http2_max_requests(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "http2_max_requests", value)


if not MYPY:
    class HttpGetArgsDict(TypedDict):
        """
        Model representing a http get request.
        """
        url: pulumi.Input[builtins.str]
        """
        URL to make HTTP GET request against.
        """
        file_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the file that the request should be saved to.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of headers to send with the request.
        """
elif False:
    HttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpGetArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[builtins.str],
                 file_name: Optional[pulumi.Input[builtins.str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Model representing a http get request.
        :param pulumi.Input[builtins.str] url: URL to make HTTP GET request against.
        :param pulumi.Input[builtins.str] file_name: Name of the file that the request should be saved to.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] headers: List of headers to send with the request.
        """
        pulumi.set(__self__, "url", url)
        if file_name is not None:
            pulumi.set(__self__, "file_name", file_name)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[builtins.str]:
        """
        URL to make HTTP GET request against.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the file that the request should be saved to.
        """
        return pulumi.get(self, "file_name")

    @file_name.setter
    def file_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file_name", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of headers to send with the request.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class HttpRetryPolicyArgsDict(TypedDict):
        """
        Policy that defines http request retry conditions
        """
        errors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Errors that can trigger a retry
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['HeaderMatchArgsDict']]]]
        """
        Headers that must be present for a request to be retried
        """
        http_status_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        Additional http status codes that can trigger a retry
        """
        initial_delay_in_milliseconds: NotRequired[pulumi.Input[builtins.float]]
        """
        Initial delay, in milliseconds, before retrying a request
        """
        max_interval_in_milliseconds: NotRequired[pulumi.Input[builtins.float]]
        """
        Maximum interval, in milliseconds, between retries
        """
        max_retries: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of times a request will retry
        """
elif False:
    HttpRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpRetryPolicyArgs:
    def __init__(__self__, *,
                 errors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['HeaderMatchArgs']]]] = None,
                 http_status_codes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 initial_delay_in_milliseconds: Optional[pulumi.Input[builtins.float]] = None,
                 max_interval_in_milliseconds: Optional[pulumi.Input[builtins.float]] = None,
                 max_retries: Optional[pulumi.Input[builtins.int]] = None):
        """
        Policy that defines http request retry conditions
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] errors: Errors that can trigger a retry
        :param pulumi.Input[Sequence[pulumi.Input['HeaderMatchArgs']]] headers: Headers that must be present for a request to be retried
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] http_status_codes: Additional http status codes that can trigger a retry
        :param pulumi.Input[builtins.float] initial_delay_in_milliseconds: Initial delay, in milliseconds, before retrying a request
        :param pulumi.Input[builtins.float] max_interval_in_milliseconds: Maximum interval, in milliseconds, between retries
        :param pulumi.Input[builtins.int] max_retries: Maximum number of times a request will retry
        """
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_status_codes is not None:
            pulumi.set(__self__, "http_status_codes", http_status_codes)
        if initial_delay_in_milliseconds is not None:
            pulumi.set(__self__, "initial_delay_in_milliseconds", initial_delay_in_milliseconds)
        if max_interval_in_milliseconds is not None:
            pulumi.set(__self__, "max_interval_in_milliseconds", max_interval_in_milliseconds)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)

    @property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Errors that can trigger a retry
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "errors", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HeaderMatchArgs']]]]:
        """
        Headers that must be present for a request to be retried
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HeaderMatchArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="httpStatusCodes")
    def http_status_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        Additional http status codes that can trigger a retry
        """
        return pulumi.get(self, "http_status_codes")

    @http_status_codes.setter
    def http_status_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "http_status_codes", value)

    @property
    @pulumi.getter(name="initialDelayInMilliseconds")
    def initial_delay_in_milliseconds(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Initial delay, in milliseconds, before retrying a request
        """
        return pulumi.get(self, "initial_delay_in_milliseconds")

    @initial_delay_in_milliseconds.setter
    def initial_delay_in_milliseconds(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "initial_delay_in_milliseconds", value)

    @property
    @pulumi.getter(name="maxIntervalInMilliseconds")
    def max_interval_in_milliseconds(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Maximum interval, in milliseconds, between retries
        """
        return pulumi.get(self, "max_interval_in_milliseconds")

    @max_interval_in_milliseconds.setter
    def max_interval_in_milliseconds(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "max_interval_in_milliseconds", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of times a request will retry
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_retries", value)


if not MYPY:
    class HttpRouteActionArgsDict(TypedDict):
        """
        Action to perform once matching of routes is done
        """
        prefix_rewrite: NotRequired[pulumi.Input[builtins.str]]
        """
        Rewrite prefix, default is no rewrites
        """
elif False:
    HttpRouteActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpRouteActionArgs:
    def __init__(__self__, *,
                 prefix_rewrite: Optional[pulumi.Input[builtins.str]] = None):
        """
        Action to perform once matching of routes is done
        :param pulumi.Input[builtins.str] prefix_rewrite: Rewrite prefix, default is no rewrites
        """
        if prefix_rewrite is not None:
            pulumi.set(__self__, "prefix_rewrite", prefix_rewrite)

    @property
    @pulumi.getter(name="prefixRewrite")
    def prefix_rewrite(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Rewrite prefix, default is no rewrites
        """
        return pulumi.get(self, "prefix_rewrite")

    @prefix_rewrite.setter
    def prefix_rewrite(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "prefix_rewrite", value)


if not MYPY:
    class HttpRouteConfigPropertiesArgsDict(TypedDict):
        """
        Http Route Config properties
        """
        custom_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomDomainArgsDict']]]]
        """
        Custom domain bindings for http Routes' hostnames.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpRouteRuleArgsDict']]]]
        """
        Routing Rules for http route resource.
        """
elif False:
    HttpRouteConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpRouteConfigPropertiesArgs:
    def __init__(__self__, *,
                 custom_domains: Optional[pulumi.Input[Sequence[pulumi.Input['CustomDomainArgs']]]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['HttpRouteRuleArgs']]]] = None):
        """
        Http Route Config properties
        :param pulumi.Input[Sequence[pulumi.Input['CustomDomainArgs']]] custom_domains: Custom domain bindings for http Routes' hostnames.
        :param pulumi.Input[Sequence[pulumi.Input['HttpRouteRuleArgs']]] rules: Routing Rules for http route resource.
        """
        if custom_domains is not None:
            pulumi.set(__self__, "custom_domains", custom_domains)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="customDomains")
    def custom_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomDomainArgs']]]]:
        """
        Custom domain bindings for http Routes' hostnames.
        """
        return pulumi.get(self, "custom_domains")

    @custom_domains.setter
    def custom_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomDomainArgs']]]]):
        pulumi.set(self, "custom_domains", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpRouteRuleArgs']]]]:
        """
        Routing Rules for http route resource.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpRouteRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class HttpRouteMatchArgsDict(TypedDict):
        """
        Criteria to match on
        """
        case_sensitive: NotRequired[pulumi.Input[builtins.bool]]
        """
        path case sensitive, default is true
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        match on exact path
        """
        path_separated_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        match on all prefix's. Not exact
        """
        prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        match on all prefix's. Not exact
        """
elif False:
    HttpRouteMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpRouteMatchArgs:
    def __init__(__self__, *,
                 case_sensitive: Optional[pulumi.Input[builtins.bool]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 path_separated_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 prefix: Optional[pulumi.Input[builtins.str]] = None):
        """
        Criteria to match on
        :param pulumi.Input[builtins.bool] case_sensitive: path case sensitive, default is true
        :param pulumi.Input[builtins.str] path: match on exact path
        :param pulumi.Input[builtins.str] path_separated_prefix: match on all prefix's. Not exact
        :param pulumi.Input[builtins.str] prefix: match on all prefix's. Not exact
        """
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if path_separated_prefix is not None:
            pulumi.set(__self__, "path_separated_prefix", path_separated_prefix)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        path case sensitive, default is true
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        match on exact path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="pathSeparatedPrefix")
    def path_separated_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        match on all prefix's. Not exact
        """
        return pulumi.get(self, "path_separated_prefix")

    @path_separated_prefix.setter
    def path_separated_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path_separated_prefix", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        match on all prefix's. Not exact
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class HttpRouteRuleArgsDict(TypedDict):
        """
        Http Route rule.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of rule. Optional.
        """
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpRouteArgsDict']]]]
        """
        Routing configuration that will allow matches on specific paths/headers.
        """
        targets: NotRequired[pulumi.Input[Sequence[pulumi.Input['HttpRouteTargetArgsDict']]]]
        """
        Targets- container apps, revisions, labels
        """
elif False:
    HttpRouteRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpRouteRuleArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['HttpRouteArgs']]]] = None,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input['HttpRouteTargetArgs']]]] = None):
        """
        Http Route rule.
        :param pulumi.Input[builtins.str] description: Description of rule. Optional.
        :param pulumi.Input[Sequence[pulumi.Input['HttpRouteArgs']]] routes: Routing configuration that will allow matches on specific paths/headers.
        :param pulumi.Input[Sequence[pulumi.Input['HttpRouteTargetArgs']]] targets: Targets- container apps, revisions, labels
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of rule. Optional.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpRouteArgs']]]]:
        """
        Routing configuration that will allow matches on specific paths/headers.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpRouteArgs']]]]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HttpRouteTargetArgs']]]]:
        """
        Targets- container apps, revisions, labels
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HttpRouteTargetArgs']]]]):
        pulumi.set(self, "targets", value)


if not MYPY:
    class HttpRouteTargetArgsDict(TypedDict):
        """
        Targets - Container App Names, Revision Names, Labels.
        """
        container_app: pulumi.Input[builtins.str]
        """
        Container App Name to route requests to
        """
        label: NotRequired[pulumi.Input[builtins.str]]
        """
        Label/Revision to route requests to
        """
        revision: NotRequired[pulumi.Input[builtins.str]]
        """
        Revision to route requests to
        """
        weight: NotRequired[pulumi.Input[builtins.int]]
        """
        Weighted routing
        """
elif False:
    HttpRouteTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpRouteTargetArgs:
    def __init__(__self__, *,
                 container_app: pulumi.Input[builtins.str],
                 label: Optional[pulumi.Input[builtins.str]] = None,
                 revision: Optional[pulumi.Input[builtins.str]] = None,
                 weight: Optional[pulumi.Input[builtins.int]] = None):
        """
        Targets - Container App Names, Revision Names, Labels.
        :param pulumi.Input[builtins.str] container_app: Container App Name to route requests to
        :param pulumi.Input[builtins.str] label: Label/Revision to route requests to
        :param pulumi.Input[builtins.str] revision: Revision to route requests to
        :param pulumi.Input[builtins.int] weight: Weighted routing
        """
        pulumi.set(__self__, "container_app", container_app)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="containerApp")
    def container_app(self) -> pulumi.Input[builtins.str]:
        """
        Container App Name to route requests to
        """
        return pulumi.get(self, "container_app")

    @container_app.setter
    def container_app(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "container_app", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Label/Revision to route requests to
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def revision(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Revision to route requests to
        """
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "revision", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Weighted routing
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class HttpRouteArgsDict(TypedDict):
        """
        Http Routes configuration, including paths to match on and whether or not rewrites are to be done.
        """
        action: NotRequired[pulumi.Input['HttpRouteActionArgsDict']]
        """
        Once route is matched, what is the desired action
        """
        match: NotRequired[pulumi.Input['HttpRouteMatchArgsDict']]
        """
        Conditions route will match on
        """
elif False:
    HttpRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpRouteArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['HttpRouteActionArgs']] = None,
                 match: Optional[pulumi.Input['HttpRouteMatchArgs']] = None):
        """
        Http Routes configuration, including paths to match on and whether or not rewrites are to be done.
        :param pulumi.Input['HttpRouteActionArgs'] action: Once route is matched, what is the desired action
        :param pulumi.Input['HttpRouteMatchArgs'] match: Conditions route will match on
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['HttpRouteActionArgs']]:
        """
        Once route is matched, what is the desired action
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['HttpRouteActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['HttpRouteMatchArgs']]:
        """
        Conditions route will match on
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['HttpRouteMatchArgs']]):
        pulumi.set(self, "match", value)


if not MYPY:
    class HttpScaleRuleArgsDict(TypedDict):
        """
        Container App container Http scaling rule.
        """
        auth: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgsDict']]]]
        """
        Authentication secrets for the custom scale rule.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Metadata properties to describe http scale rule.
        """
elif False:
    HttpScaleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpScaleRuleArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        Container App container Http scaling rule.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]] auth: Authentication secrets for the custom scale rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] metadata: Metadata properties to describe http scale rule.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]:
        """
        Authentication secrets for the custom scale rule.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Metadata properties to describe http scale rule.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class HttpSettingsRoutesArgsDict(TypedDict):
        """
        The configuration settings of the paths HTTP requests.
        """
        api_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        The prefix that should precede all the authentication/authorization paths.
        """
elif False:
    HttpSettingsRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpSettingsRoutesArgs:
    def __init__(__self__, *,
                 api_prefix: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the paths HTTP requests.
        :param pulumi.Input[builtins.str] api_prefix: The prefix that should precede all the authentication/authorization paths.
        """
        if api_prefix is not None:
            pulumi.set(__self__, "api_prefix", api_prefix)

    @property
    @pulumi.getter(name="apiPrefix")
    def api_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The prefix that should precede all the authentication/authorization paths.
        """
        return pulumi.get(self, "api_prefix")

    @api_prefix.setter
    def api_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_prefix", value)


if not MYPY:
    class HttpSettingsArgsDict(TypedDict):
        """
        The configuration settings of the HTTP requests for authentication and authorization requests made against ContainerApp Service Authentication/Authorization.
        """
        forward_proxy: NotRequired[pulumi.Input['ForwardProxyArgsDict']]
        """
        The configuration settings of a forward proxy used to make the requests.
        """
        require_https: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        """
        routes: NotRequired[pulumi.Input['HttpSettingsRoutesArgsDict']]
        """
        The configuration settings of the paths HTTP requests.
        """
elif False:
    HttpSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpSettingsArgs:
    def __init__(__self__, *,
                 forward_proxy: Optional[pulumi.Input['ForwardProxyArgs']] = None,
                 require_https: Optional[pulumi.Input[builtins.bool]] = None,
                 routes: Optional[pulumi.Input['HttpSettingsRoutesArgs']] = None):
        """
        The configuration settings of the HTTP requests for authentication and authorization requests made against ContainerApp Service Authentication/Authorization.
        :param pulumi.Input['ForwardProxyArgs'] forward_proxy: The configuration settings of a forward proxy used to make the requests.
        :param pulumi.Input[builtins.bool] require_https: <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        :param pulumi.Input['HttpSettingsRoutesArgs'] routes: The configuration settings of the paths HTTP requests.
        """
        if forward_proxy is not None:
            pulumi.set(__self__, "forward_proxy", forward_proxy)
        if require_https is not None:
            pulumi.set(__self__, "require_https", require_https)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)

    @property
    @pulumi.getter(name="forwardProxy")
    def forward_proxy(self) -> Optional[pulumi.Input['ForwardProxyArgs']]:
        """
        The configuration settings of a forward proxy used to make the requests.
        """
        return pulumi.get(self, "forward_proxy")

    @forward_proxy.setter
    def forward_proxy(self, value: Optional[pulumi.Input['ForwardProxyArgs']]):
        pulumi.set(self, "forward_proxy", value)

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "require_https")

    @require_https.setter
    def require_https(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_https", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input['HttpSettingsRoutesArgs']]:
        """
        The configuration settings of the paths HTTP requests.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input['HttpSettingsRoutesArgs']]):
        pulumi.set(self, "routes", value)


if not MYPY:
    class IdentityProvidersArgsDict(TypedDict):
        """
        The configuration settings of each of the identity providers used to configure ContainerApp Service Authentication/Authorization.
        """
        apple: NotRequired[pulumi.Input['AppleArgsDict']]
        """
        The configuration settings of the Apple provider.
        """
        azure_active_directory: NotRequired[pulumi.Input['AzureActiveDirectoryArgsDict']]
        """
        The configuration settings of the Azure Active directory provider.
        """
        azure_static_web_apps: NotRequired[pulumi.Input['AzureStaticWebAppsArgsDict']]
        """
        The configuration settings of the Azure Static Web Apps provider.
        """
        custom_open_id_connect_providers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgsDict']]]]
        """
        The map of the name of the alias of each custom Open ID Connect provider to the
        configuration settings of the custom Open ID Connect provider.
        """
        facebook: NotRequired[pulumi.Input['FacebookArgsDict']]
        """
        The configuration settings of the Facebook provider.
        """
        git_hub: NotRequired[pulumi.Input['GitHubArgsDict']]
        """
        The configuration settings of the GitHub provider.
        """
        google: NotRequired[pulumi.Input['GoogleArgsDict']]
        """
        The configuration settings of the Google provider.
        """
        twitter: NotRequired[pulumi.Input['TwitterArgsDict']]
        """
        The configuration settings of the Twitter provider.
        """
elif False:
    IdentityProvidersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityProvidersArgs:
    def __init__(__self__, *,
                 apple: Optional[pulumi.Input['AppleArgs']] = None,
                 azure_active_directory: Optional[pulumi.Input['AzureActiveDirectoryArgs']] = None,
                 azure_static_web_apps: Optional[pulumi.Input['AzureStaticWebAppsArgs']] = None,
                 custom_open_id_connect_providers: Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]] = None,
                 facebook: Optional[pulumi.Input['FacebookArgs']] = None,
                 git_hub: Optional[pulumi.Input['GitHubArgs']] = None,
                 google: Optional[pulumi.Input['GoogleArgs']] = None,
                 twitter: Optional[pulumi.Input['TwitterArgs']] = None):
        """
        The configuration settings of each of the identity providers used to configure ContainerApp Service Authentication/Authorization.
        :param pulumi.Input['AppleArgs'] apple: The configuration settings of the Apple provider.
        :param pulumi.Input['AzureActiveDirectoryArgs'] azure_active_directory: The configuration settings of the Azure Active directory provider.
        :param pulumi.Input['AzureStaticWebAppsArgs'] azure_static_web_apps: The configuration settings of the Azure Static Web Apps provider.
        :param pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]] custom_open_id_connect_providers: The map of the name of the alias of each custom Open ID Connect provider to the
               configuration settings of the custom Open ID Connect provider.
        :param pulumi.Input['FacebookArgs'] facebook: The configuration settings of the Facebook provider.
        :param pulumi.Input['GitHubArgs'] git_hub: The configuration settings of the GitHub provider.
        :param pulumi.Input['GoogleArgs'] google: The configuration settings of the Google provider.
        :param pulumi.Input['TwitterArgs'] twitter: The configuration settings of the Twitter provider.
        """
        if apple is not None:
            pulumi.set(__self__, "apple", apple)
        if azure_active_directory is not None:
            pulumi.set(__self__, "azure_active_directory", azure_active_directory)
        if azure_static_web_apps is not None:
            pulumi.set(__self__, "azure_static_web_apps", azure_static_web_apps)
        if custom_open_id_connect_providers is not None:
            pulumi.set(__self__, "custom_open_id_connect_providers", custom_open_id_connect_providers)
        if facebook is not None:
            pulumi.set(__self__, "facebook", facebook)
        if git_hub is not None:
            pulumi.set(__self__, "git_hub", git_hub)
        if google is not None:
            pulumi.set(__self__, "google", google)
        if twitter is not None:
            pulumi.set(__self__, "twitter", twitter)

    @property
    @pulumi.getter
    def apple(self) -> Optional[pulumi.Input['AppleArgs']]:
        """
        The configuration settings of the Apple provider.
        """
        return pulumi.get(self, "apple")

    @apple.setter
    def apple(self, value: Optional[pulumi.Input['AppleArgs']]):
        pulumi.set(self, "apple", value)

    @property
    @pulumi.getter(name="azureActiveDirectory")
    def azure_active_directory(self) -> Optional[pulumi.Input['AzureActiveDirectoryArgs']]:
        """
        The configuration settings of the Azure Active directory provider.
        """
        return pulumi.get(self, "azure_active_directory")

    @azure_active_directory.setter
    def azure_active_directory(self, value: Optional[pulumi.Input['AzureActiveDirectoryArgs']]):
        pulumi.set(self, "azure_active_directory", value)

    @property
    @pulumi.getter(name="azureStaticWebApps")
    def azure_static_web_apps(self) -> Optional[pulumi.Input['AzureStaticWebAppsArgs']]:
        """
        The configuration settings of the Azure Static Web Apps provider.
        """
        return pulumi.get(self, "azure_static_web_apps")

    @azure_static_web_apps.setter
    def azure_static_web_apps(self, value: Optional[pulumi.Input['AzureStaticWebAppsArgs']]):
        pulumi.set(self, "azure_static_web_apps", value)

    @property
    @pulumi.getter(name="customOpenIdConnectProviders")
    def custom_open_id_connect_providers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]]:
        """
        The map of the name of the alias of each custom Open ID Connect provider to the
        configuration settings of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "custom_open_id_connect_providers")

    @custom_open_id_connect_providers.setter
    def custom_open_id_connect_providers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]]):
        pulumi.set(self, "custom_open_id_connect_providers", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['FacebookArgs']]:
        """
        The configuration settings of the Facebook provider.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['FacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter(name="gitHub")
    def git_hub(self) -> Optional[pulumi.Input['GitHubArgs']]:
        """
        The configuration settings of the GitHub provider.
        """
        return pulumi.get(self, "git_hub")

    @git_hub.setter
    def git_hub(self, value: Optional[pulumi.Input['GitHubArgs']]):
        pulumi.set(self, "git_hub", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['GoogleArgs']]:
        """
        The configuration settings of the Google provider.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['GoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['TwitterArgs']]:
        """
        The configuration settings of the Twitter provider.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['TwitterArgs']]):
        pulumi.set(self, "twitter", value)


if not MYPY:
    class IngressPortMappingArgsDict(TypedDict):
        """
        Port mappings of container app ingress
        """
        external: pulumi.Input[builtins.bool]
        """
        Specifies whether the app port is accessible outside of the environment
        """
        target_port: pulumi.Input[builtins.int]
        """
        Specifies the port user's container listens on
        """
        exposed_port: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the exposed port for the target port. If not specified, it defaults to target port
        """
elif False:
    IngressPortMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IngressPortMappingArgs:
    def __init__(__self__, *,
                 external: pulumi.Input[builtins.bool],
                 target_port: pulumi.Input[builtins.int],
                 exposed_port: Optional[pulumi.Input[builtins.int]] = None):
        """
        Port mappings of container app ingress
        :param pulumi.Input[builtins.bool] external: Specifies whether the app port is accessible outside of the environment
        :param pulumi.Input[builtins.int] target_port: Specifies the port user's container listens on
        :param pulumi.Input[builtins.int] exposed_port: Specifies the exposed port for the target port. If not specified, it defaults to target port
        """
        pulumi.set(__self__, "external", external)
        pulumi.set(__self__, "target_port", target_port)
        if exposed_port is not None:
            pulumi.set(__self__, "exposed_port", exposed_port)

    @property
    @pulumi.getter
    def external(self) -> pulumi.Input[builtins.bool]:
        """
        Specifies whether the app port is accessible outside of the environment
        """
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "external", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> pulumi.Input[builtins.int]:
        """
        Specifies the port user's container listens on
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "target_port", value)

    @property
    @pulumi.getter(name="exposedPort")
    def exposed_port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the exposed port for the target port. If not specified, it defaults to target port
        """
        return pulumi.get(self, "exposed_port")

    @exposed_port.setter
    def exposed_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "exposed_port", value)


if not MYPY:
    class IngressStickySessionsArgsDict(TypedDict):
        """
        Sticky Sessions for Single Revision Mode
        """
        affinity: NotRequired[pulumi.Input[Union[builtins.str, 'Affinity']]]
        """
        Sticky Session Affinity
        """
elif False:
    IngressStickySessionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IngressStickySessionsArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input[Union[builtins.str, 'Affinity']]] = None):
        """
        Sticky Sessions for Single Revision Mode
        :param pulumi.Input[Union[builtins.str, 'Affinity']] affinity: Sticky Session Affinity
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input[Union[builtins.str, 'Affinity']]]:
        """
        Sticky Session Affinity
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input[Union[builtins.str, 'Affinity']]]):
        pulumi.set(self, "affinity", value)


if not MYPY:
    class IngressArgsDict(TypedDict):
        """
        Container App Ingress configuration.
        """
        additional_port_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['IngressPortMappingArgsDict']]]]
        """
        Settings to expose additional ports on container app
        """
        allow_insecure: NotRequired[pulumi.Input[builtins.bool]]
        """
        Bool indicating if HTTP connections to is allowed. If set to false HTTP connections are automatically redirected to HTTPS connections
        """
        client_certificate_mode: NotRequired[pulumi.Input[Union[builtins.str, 'IngressClientCertificateMode']]]
        """
        Client certificate mode for mTLS authentication. Ignore indicates server drops client certificate on forwarding. Accept indicates server forwards client certificate but does not require a client certificate. Require indicates server requires a client certificate.
        """
        cors_policy: NotRequired[pulumi.Input['CorsPolicyArgsDict']]
        """
        CORS policy for container app
        """
        custom_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input['CustomDomainArgsDict']]]]
        """
        custom domain bindings for Container Apps' hostnames.
        """
        exposed_port: NotRequired[pulumi.Input[builtins.int]]
        """
        Exposed Port in containers for TCP traffic from ingress
        """
        external: NotRequired[pulumi.Input[builtins.bool]]
        """
        Bool indicating if app exposes an external http endpoint
        """
        ip_security_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionRuleArgsDict']]]]
        """
        Rules to restrict incoming IP address.
        """
        sticky_sessions: NotRequired[pulumi.Input['IngressStickySessionsArgsDict']]
        """
        Sticky Sessions for Single Revision Mode
        """
        target_port: NotRequired[pulumi.Input[builtins.int]]
        """
        Target Port in containers for traffic from ingress
        """
        traffic: NotRequired[pulumi.Input[Sequence[pulumi.Input['TrafficWeightArgsDict']]]]
        """
        Traffic weights for app's revisions
        """
        transport: NotRequired[pulumi.Input[Union[builtins.str, 'IngressTransportMethod']]]
        """
        Ingress transport protocol
        """
elif False:
    IngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IngressArgs:
    def __init__(__self__, *,
                 additional_port_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['IngressPortMappingArgs']]]] = None,
                 allow_insecure: Optional[pulumi.Input[builtins.bool]] = None,
                 client_certificate_mode: Optional[pulumi.Input[Union[builtins.str, 'IngressClientCertificateMode']]] = None,
                 cors_policy: Optional[pulumi.Input['CorsPolicyArgs']] = None,
                 custom_domains: Optional[pulumi.Input[Sequence[pulumi.Input['CustomDomainArgs']]]] = None,
                 exposed_port: Optional[pulumi.Input[builtins.int]] = None,
                 external: Optional[pulumi.Input[builtins.bool]] = None,
                 ip_security_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionRuleArgs']]]] = None,
                 sticky_sessions: Optional[pulumi.Input['IngressStickySessionsArgs']] = None,
                 target_port: Optional[pulumi.Input[builtins.int]] = None,
                 traffic: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficWeightArgs']]]] = None,
                 transport: Optional[pulumi.Input[Union[builtins.str, 'IngressTransportMethod']]] = None):
        """
        Container App Ingress configuration.
        :param pulumi.Input[Sequence[pulumi.Input['IngressPortMappingArgs']]] additional_port_mappings: Settings to expose additional ports on container app
        :param pulumi.Input[builtins.bool] allow_insecure: Bool indicating if HTTP connections to is allowed. If set to false HTTP connections are automatically redirected to HTTPS connections
        :param pulumi.Input[Union[builtins.str, 'IngressClientCertificateMode']] client_certificate_mode: Client certificate mode for mTLS authentication. Ignore indicates server drops client certificate on forwarding. Accept indicates server forwards client certificate but does not require a client certificate. Require indicates server requires a client certificate.
        :param pulumi.Input['CorsPolicyArgs'] cors_policy: CORS policy for container app
        :param pulumi.Input[Sequence[pulumi.Input['CustomDomainArgs']]] custom_domains: custom domain bindings for Container Apps' hostnames.
        :param pulumi.Input[builtins.int] exposed_port: Exposed Port in containers for TCP traffic from ingress
        :param pulumi.Input[builtins.bool] external: Bool indicating if app exposes an external http endpoint
        :param pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionRuleArgs']]] ip_security_restrictions: Rules to restrict incoming IP address.
        :param pulumi.Input['IngressStickySessionsArgs'] sticky_sessions: Sticky Sessions for Single Revision Mode
        :param pulumi.Input[builtins.int] target_port: Target Port in containers for traffic from ingress
        :param pulumi.Input[Sequence[pulumi.Input['TrafficWeightArgs']]] traffic: Traffic weights for app's revisions
        :param pulumi.Input[Union[builtins.str, 'IngressTransportMethod']] transport: Ingress transport protocol
        """
        if additional_port_mappings is not None:
            pulumi.set(__self__, "additional_port_mappings", additional_port_mappings)
        if allow_insecure is None:
            allow_insecure = False
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if client_certificate_mode is not None:
            pulumi.set(__self__, "client_certificate_mode", client_certificate_mode)
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if custom_domains is not None:
            pulumi.set(__self__, "custom_domains", custom_domains)
        if exposed_port is not None:
            pulumi.set(__self__, "exposed_port", exposed_port)
        if external is None:
            external = False
        if external is not None:
            pulumi.set(__self__, "external", external)
        if ip_security_restrictions is not None:
            pulumi.set(__self__, "ip_security_restrictions", ip_security_restrictions)
        if sticky_sessions is not None:
            pulumi.set(__self__, "sticky_sessions", sticky_sessions)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)
        if traffic is not None:
            pulumi.set(__self__, "traffic", traffic)
        if transport is None:
            transport = 'auto'
        if transport is not None:
            pulumi.set(__self__, "transport", transport)

    @property
    @pulumi.getter(name="additionalPortMappings")
    def additional_port_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IngressPortMappingArgs']]]]:
        """
        Settings to expose additional ports on container app
        """
        return pulumi.get(self, "additional_port_mappings")

    @additional_port_mappings.setter
    def additional_port_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IngressPortMappingArgs']]]]):
        pulumi.set(self, "additional_port_mappings", value)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Bool indicating if HTTP connections to is allowed. If set to false HTTP connections are automatically redirected to HTTPS connections
        """
        return pulumi.get(self, "allow_insecure")

    @allow_insecure.setter
    def allow_insecure(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_insecure", value)

    @property
    @pulumi.getter(name="clientCertificateMode")
    def client_certificate_mode(self) -> Optional[pulumi.Input[Union[builtins.str, 'IngressClientCertificateMode']]]:
        """
        Client certificate mode for mTLS authentication. Ignore indicates server drops client certificate on forwarding. Accept indicates server forwards client certificate but does not require a client certificate. Require indicates server requires a client certificate.
        """
        return pulumi.get(self, "client_certificate_mode")

    @client_certificate_mode.setter
    def client_certificate_mode(self, value: Optional[pulumi.Input[Union[builtins.str, 'IngressClientCertificateMode']]]):
        pulumi.set(self, "client_certificate_mode", value)

    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional[pulumi.Input['CorsPolicyArgs']]:
        """
        CORS policy for container app
        """
        return pulumi.get(self, "cors_policy")

    @cors_policy.setter
    def cors_policy(self, value: Optional[pulumi.Input['CorsPolicyArgs']]):
        pulumi.set(self, "cors_policy", value)

    @property
    @pulumi.getter(name="customDomains")
    def custom_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomDomainArgs']]]]:
        """
        custom domain bindings for Container Apps' hostnames.
        """
        return pulumi.get(self, "custom_domains")

    @custom_domains.setter
    def custom_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomDomainArgs']]]]):
        pulumi.set(self, "custom_domains", value)

    @property
    @pulumi.getter(name="exposedPort")
    def exposed_port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Exposed Port in containers for TCP traffic from ingress
        """
        return pulumi.get(self, "exposed_port")

    @exposed_port.setter
    def exposed_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "exposed_port", value)

    @property
    @pulumi.getter
    def external(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Bool indicating if app exposes an external http endpoint
        """
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "external", value)

    @property
    @pulumi.getter(name="ipSecurityRestrictions")
    def ip_security_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionRuleArgs']]]]:
        """
        Rules to restrict incoming IP address.
        """
        return pulumi.get(self, "ip_security_restrictions")

    @ip_security_restrictions.setter
    def ip_security_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpSecurityRestrictionRuleArgs']]]]):
        pulumi.set(self, "ip_security_restrictions", value)

    @property
    @pulumi.getter(name="stickySessions")
    def sticky_sessions(self) -> Optional[pulumi.Input['IngressStickySessionsArgs']]:
        """
        Sticky Sessions for Single Revision Mode
        """
        return pulumi.get(self, "sticky_sessions")

    @sticky_sessions.setter
    def sticky_sessions(self, value: Optional[pulumi.Input['IngressStickySessionsArgs']]):
        pulumi.set(self, "sticky_sessions", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Target Port in containers for traffic from ingress
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "target_port", value)

    @property
    @pulumi.getter
    def traffic(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TrafficWeightArgs']]]]:
        """
        Traffic weights for app's revisions
        """
        return pulumi.get(self, "traffic")

    @traffic.setter
    def traffic(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficWeightArgs']]]]):
        pulumi.set(self, "traffic", value)

    @property
    @pulumi.getter
    def transport(self) -> Optional[pulumi.Input[Union[builtins.str, 'IngressTransportMethod']]]:
        """
        Ingress transport protocol
        """
        return pulumi.get(self, "transport")

    @transport.setter
    def transport(self, value: Optional[pulumi.Input[Union[builtins.str, 'IngressTransportMethod']]]):
        pulumi.set(self, "transport", value)


if not MYPY:
    class InitContainerArgsDict(TypedDict):
        """
        Container App init container definition
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Container start command arguments.
        """
        command: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Container start command.
        """
        env: NotRequired[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgsDict']]]]
        """
        Container environment variables.
        """
        image: NotRequired[pulumi.Input[builtins.str]]
        """
        Container image tag.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Custom container name.
        """
        resources: NotRequired[pulumi.Input['ContainerResourcesArgsDict']]
        """
        Container resource requirements.
        """
        volume_mounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgsDict']]]]
        """
        Container volume mounts.
        """
elif False:
    InitContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InitContainerArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 command: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]] = None,
                 image: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 resources: Optional[pulumi.Input['ContainerResourcesArgs']] = None,
                 volume_mounts: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]] = None):
        """
        Container App init container definition
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] args: Container start command arguments.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] command: Container start command.
        :param pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]] env: Container environment variables.
        :param pulumi.Input[builtins.str] image: Container image tag.
        :param pulumi.Input[builtins.str] name: Custom container name.
        :param pulumi.Input['ContainerResourcesArgs'] resources: Container resource requirements.
        :param pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]] volume_mounts: Container volume mounts.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if volume_mounts is not None:
            pulumi.set(__self__, "volume_mounts", volume_mounts)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Container start command arguments.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Container start command.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]]:
        """
        Container environment variables.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Container image tag.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Custom container name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['ContainerResourcesArgs']]:
        """
        Container resource requirements.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['ContainerResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]]:
        """
        Container volume mounts.
        """
        return pulumi.get(self, "volume_mounts")

    @volume_mounts.setter
    def volume_mounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]]):
        pulumi.set(self, "volume_mounts", value)


if not MYPY:
    class IpSecurityRestrictionRuleArgsDict(TypedDict):
        """
        Rule to restrict incoming IP address.
        """
        action: pulumi.Input[Union[builtins.str, 'Action']]
        """
        Allow or Deny rules to determine for incoming IP. Note: Rules can only consist of ALL Allow or ALL Deny
        """
        ip_address_range: pulumi.Input[builtins.str]
        """
        CIDR notation to match incoming IP address
        """
        name: pulumi.Input[builtins.str]
        """
        Name for the IP restriction rule.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Describe the IP restriction rule that is being sent to the container-app. This is an optional field.
        """
elif False:
    IpSecurityRestrictionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpSecurityRestrictionRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[Union[builtins.str, 'Action']],
                 ip_address_range: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        Rule to restrict incoming IP address.
        :param pulumi.Input[Union[builtins.str, 'Action']] action: Allow or Deny rules to determine for incoming IP. Note: Rules can only consist of ALL Allow or ALL Deny
        :param pulumi.Input[builtins.str] ip_address_range: CIDR notation to match incoming IP address
        :param pulumi.Input[builtins.str] name: Name for the IP restriction rule.
        :param pulumi.Input[builtins.str] description: Describe the IP restriction rule that is being sent to the container-app. This is an optional field.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "ip_address_range", ip_address_range)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[Union[builtins.str, 'Action']]:
        """
        Allow or Deny rules to determine for incoming IP. Note: Rules can only consist of ALL Allow or ALL Deny
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[Union[builtins.str, 'Action']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="ipAddressRange")
    def ip_address_range(self) -> pulumi.Input[builtins.str]:
        """
        CIDR notation to match incoming IP address
        """
        return pulumi.get(self, "ip_address_range")

    @ip_address_range.setter
    def ip_address_range(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip_address_range", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name for the IP restriction rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Describe the IP restriction rule that is being sent to the container-app. This is an optional field.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class JavaComponentConfigurationPropertyArgsDict(TypedDict):
        """
        Configuration properties for a Java Component
        """
        property_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the property
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        The value of the property
        """
elif False:
    JavaComponentConfigurationPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JavaComponentConfigurationPropertyArgs:
    def __init__(__self__, *,
                 property_name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Configuration properties for a Java Component
        :param pulumi.Input[builtins.str] property_name: The name of the property
        :param pulumi.Input[builtins.str] value: The value of the property
        """
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the property
        """
        return pulumi.get(self, "property_name")

    @property_name.setter
    def property_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "property_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The value of the property
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class JavaComponentPropertiesScaleArgsDict(TypedDict):
        """
        Java component scaling configurations
        """
        max_replicas: NotRequired[pulumi.Input[builtins.int]]
        """
        Optional. Maximum number of Java component replicas
        """
        min_replicas: NotRequired[pulumi.Input[builtins.int]]
        """
        Optional. Minimum number of Java component replicas. Defaults to 1 if not set
        """
elif False:
    JavaComponentPropertiesScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JavaComponentPropertiesScaleArgs:
    def __init__(__self__, *,
                 max_replicas: Optional[pulumi.Input[builtins.int]] = None,
                 min_replicas: Optional[pulumi.Input[builtins.int]] = None):
        """
        Java component scaling configurations
        :param pulumi.Input[builtins.int] max_replicas: Optional. Maximum number of Java component replicas
        :param pulumi.Input[builtins.int] min_replicas: Optional. Minimum number of Java component replicas. Defaults to 1 if not set
        """
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optional. Maximum number of Java component replicas
        """
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_replicas", value)

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optional. Minimum number of Java component replicas. Defaults to 1 if not set
        """
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_replicas", value)


if not MYPY:
    class JavaComponentServiceBindArgsDict(TypedDict):
        """
        Configuration to bind a Java Component to another Java Component
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the service bind
        """
        service_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource id of the target service
        """
elif False:
    JavaComponentServiceBindArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JavaComponentServiceBindArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 service_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Configuration to bind a Java Component to another Java Component
        :param pulumi.Input[builtins.str] name: Name of the service bind
        :param pulumi.Input[builtins.str] service_id: Resource id of the target service
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the service bind
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource id of the target service
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_id", value)


if not MYPY:
    class JobConfigurationEventTriggerConfigArgsDict(TypedDict):
        """
        Trigger configuration of an event driven job.
        """
        parallelism: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        replica_completion_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum number of successful replica completions before overall job completion.
        """
        scale: NotRequired[pulumi.Input['JobScaleArgsDict']]
        """
        Scaling configurations for event driven jobs.
        """
elif False:
    JobConfigurationEventTriggerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobConfigurationEventTriggerConfigArgs:
    def __init__(__self__, *,
                 parallelism: Optional[pulumi.Input[builtins.int]] = None,
                 replica_completion_count: Optional[pulumi.Input[builtins.int]] = None,
                 scale: Optional[pulumi.Input['JobScaleArgs']] = None):
        """
        Trigger configuration of an event driven job.
        :param pulumi.Input[builtins.int] parallelism: Number of parallel replicas of a job that can run at a given time.
        :param pulumi.Input[builtins.int] replica_completion_count: Minimum number of successful replica completions before overall job completion.
        :param pulumi.Input['JobScaleArgs'] scale: Scaling configurations for event driven jobs.
        """
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if replica_completion_count is not None:
            pulumi.set(__self__, "replica_completion_count", replica_completion_count)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        return pulumi.get(self, "parallelism")

    @parallelism.setter
    def parallelism(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "parallelism", value)

    @property
    @pulumi.getter(name="replicaCompletionCount")
    def replica_completion_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum number of successful replica completions before overall job completion.
        """
        return pulumi.get(self, "replica_completion_count")

    @replica_completion_count.setter
    def replica_completion_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "replica_completion_count", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input['JobScaleArgs']]:
        """
        Scaling configurations for event driven jobs.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input['JobScaleArgs']]):
        pulumi.set(self, "scale", value)


if not MYPY:
    class JobConfigurationManualTriggerConfigArgsDict(TypedDict):
        """
        Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        """
        parallelism: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        replica_completion_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum number of successful replica completions before overall job completion.
        """
elif False:
    JobConfigurationManualTriggerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobConfigurationManualTriggerConfigArgs:
    def __init__(__self__, *,
                 parallelism: Optional[pulumi.Input[builtins.int]] = None,
                 replica_completion_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        :param pulumi.Input[builtins.int] parallelism: Number of parallel replicas of a job that can run at a given time.
        :param pulumi.Input[builtins.int] replica_completion_count: Minimum number of successful replica completions before overall job completion.
        """
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if replica_completion_count is not None:
            pulumi.set(__self__, "replica_completion_count", replica_completion_count)

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        return pulumi.get(self, "parallelism")

    @parallelism.setter
    def parallelism(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "parallelism", value)

    @property
    @pulumi.getter(name="replicaCompletionCount")
    def replica_completion_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum number of successful replica completions before overall job completion.
        """
        return pulumi.get(self, "replica_completion_count")

    @replica_completion_count.setter
    def replica_completion_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "replica_completion_count", value)


if not MYPY:
    class JobConfigurationScheduleTriggerConfigArgsDict(TypedDict):
        """
        Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        """
        cron_expression: pulumi.Input[builtins.str]
        """
        Cron formatted repeating schedule ("* * * * *") of a Cron Job.
        """
        parallelism: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        replica_completion_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum number of successful replica completions before overall job completion.
        """
elif False:
    JobConfigurationScheduleTriggerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobConfigurationScheduleTriggerConfigArgs:
    def __init__(__self__, *,
                 cron_expression: pulumi.Input[builtins.str],
                 parallelism: Optional[pulumi.Input[builtins.int]] = None,
                 replica_completion_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        :param pulumi.Input[builtins.str] cron_expression: Cron formatted repeating schedule ("* * * * *") of a Cron Job.
        :param pulumi.Input[builtins.int] parallelism: Number of parallel replicas of a job that can run at a given time.
        :param pulumi.Input[builtins.int] replica_completion_count: Minimum number of successful replica completions before overall job completion.
        """
        pulumi.set(__self__, "cron_expression", cron_expression)
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if replica_completion_count is not None:
            pulumi.set(__self__, "replica_completion_count", replica_completion_count)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> pulumi.Input[builtins.str]:
        """
        Cron formatted repeating schedule ("* * * * *") of a Cron Job.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of parallel replicas of a job that can run at a given time.
        """
        return pulumi.get(self, "parallelism")

    @parallelism.setter
    def parallelism(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "parallelism", value)

    @property
    @pulumi.getter(name="replicaCompletionCount")
    def replica_completion_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum number of successful replica completions before overall job completion.
        """
        return pulumi.get(self, "replica_completion_count")

    @replica_completion_count.setter
    def replica_completion_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "replica_completion_count", value)


if not MYPY:
    class JobConfigurationArgsDict(TypedDict):
        """
        Non versioned Container Apps Job configuration properties
        """
        replica_timeout: pulumi.Input[builtins.int]
        """
        Maximum number of seconds a replica is allowed to run.
        """
        trigger_type: pulumi.Input[Union[builtins.str, 'TriggerType']]
        """
        Trigger type of the job
        """
        event_trigger_config: NotRequired[pulumi.Input['JobConfigurationEventTriggerConfigArgsDict']]
        """
        Trigger configuration of an event driven job.
        """
        manual_trigger_config: NotRequired[pulumi.Input['JobConfigurationManualTriggerConfigArgsDict']]
        """
        Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        """
        registries: NotRequired[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgsDict']]]]
        """
        Collection of private container registry credentials used by a Container apps job
        """
        replica_retry_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of retries before failing the job.
        """
        schedule_trigger_config: NotRequired[pulumi.Input['JobConfigurationScheduleTriggerConfigArgsDict']]
        """
        Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecretArgsDict']]]]
        """
        Collection of secrets used by a Container Apps Job
        """
elif False:
    JobConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobConfigurationArgs:
    def __init__(__self__, *,
                 replica_timeout: pulumi.Input[builtins.int],
                 trigger_type: Optional[pulumi.Input[Union[builtins.str, 'TriggerType']]] = None,
                 event_trigger_config: Optional[pulumi.Input['JobConfigurationEventTriggerConfigArgs']] = None,
                 manual_trigger_config: Optional[pulumi.Input['JobConfigurationManualTriggerConfigArgs']] = None,
                 registries: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]]] = None,
                 replica_retry_limit: Optional[pulumi.Input[builtins.int]] = None,
                 schedule_trigger_config: Optional[pulumi.Input['JobConfigurationScheduleTriggerConfigArgs']] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]] = None):
        """
        Non versioned Container Apps Job configuration properties
        :param pulumi.Input[builtins.int] replica_timeout: Maximum number of seconds a replica is allowed to run.
        :param pulumi.Input[Union[builtins.str, 'TriggerType']] trigger_type: Trigger type of the job
        :param pulumi.Input['JobConfigurationEventTriggerConfigArgs'] event_trigger_config: Trigger configuration of an event driven job.
        :param pulumi.Input['JobConfigurationManualTriggerConfigArgs'] manual_trigger_config: Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        :param pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]] registries: Collection of private container registry credentials used by a Container apps job
        :param pulumi.Input[builtins.int] replica_retry_limit: Maximum number of retries before failing the job.
        :param pulumi.Input['JobConfigurationScheduleTriggerConfigArgs'] schedule_trigger_config: Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        :param pulumi.Input[Sequence[pulumi.Input['SecretArgs']]] secrets: Collection of secrets used by a Container Apps Job
        """
        pulumi.set(__self__, "replica_timeout", replica_timeout)
        if trigger_type is None:
            trigger_type = 'Manual'
        pulumi.set(__self__, "trigger_type", trigger_type)
        if event_trigger_config is not None:
            pulumi.set(__self__, "event_trigger_config", event_trigger_config)
        if manual_trigger_config is not None:
            pulumi.set(__self__, "manual_trigger_config", manual_trigger_config)
        if registries is not None:
            pulumi.set(__self__, "registries", registries)
        if replica_retry_limit is not None:
            pulumi.set(__self__, "replica_retry_limit", replica_retry_limit)
        if schedule_trigger_config is not None:
            pulumi.set(__self__, "schedule_trigger_config", schedule_trigger_config)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @property
    @pulumi.getter(name="replicaTimeout")
    def replica_timeout(self) -> pulumi.Input[builtins.int]:
        """
        Maximum number of seconds a replica is allowed to run.
        """
        return pulumi.get(self, "replica_timeout")

    @replica_timeout.setter
    def replica_timeout(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "replica_timeout", value)

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> pulumi.Input[Union[builtins.str, 'TriggerType']]:
        """
        Trigger type of the job
        """
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: pulumi.Input[Union[builtins.str, 'TriggerType']]):
        pulumi.set(self, "trigger_type", value)

    @property
    @pulumi.getter(name="eventTriggerConfig")
    def event_trigger_config(self) -> Optional[pulumi.Input['JobConfigurationEventTriggerConfigArgs']]:
        """
        Trigger configuration of an event driven job.
        """
        return pulumi.get(self, "event_trigger_config")

    @event_trigger_config.setter
    def event_trigger_config(self, value: Optional[pulumi.Input['JobConfigurationEventTriggerConfigArgs']]):
        pulumi.set(self, "event_trigger_config", value)

    @property
    @pulumi.getter(name="manualTriggerConfig")
    def manual_trigger_config(self) -> Optional[pulumi.Input['JobConfigurationManualTriggerConfigArgs']]:
        """
        Manual trigger configuration for a single execution job. Properties replicaCompletionCount and parallelism would be set to 1 by default
        """
        return pulumi.get(self, "manual_trigger_config")

    @manual_trigger_config.setter
    def manual_trigger_config(self, value: Optional[pulumi.Input['JobConfigurationManualTriggerConfigArgs']]):
        pulumi.set(self, "manual_trigger_config", value)

    @property
    @pulumi.getter
    def registries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]]]:
        """
        Collection of private container registry credentials used by a Container apps job
        """
        return pulumi.get(self, "registries")

    @registries.setter
    def registries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]]]):
        pulumi.set(self, "registries", value)

    @property
    @pulumi.getter(name="replicaRetryLimit")
    def replica_retry_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of retries before failing the job.
        """
        return pulumi.get(self, "replica_retry_limit")

    @replica_retry_limit.setter
    def replica_retry_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "replica_retry_limit", value)

    @property
    @pulumi.getter(name="scheduleTriggerConfig")
    def schedule_trigger_config(self) -> Optional[pulumi.Input['JobConfigurationScheduleTriggerConfigArgs']]:
        """
        Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and parallelism would be set to 1 by default
        """
        return pulumi.get(self, "schedule_trigger_config")

    @schedule_trigger_config.setter
    def schedule_trigger_config(self, value: Optional[pulumi.Input['JobConfigurationScheduleTriggerConfigArgs']]):
        pulumi.set(self, "schedule_trigger_config", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]]:
        """
        Collection of secrets used by a Container Apps Job
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class JobScaleRuleArgsDict(TypedDict):
        """
        Scaling rule.
        """
        auth: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgsDict']]]]
        """
        Authentication secrets for the scale rule.
        """
        metadata: NotRequired[Any]
        """
        Metadata properties to describe the scale rule.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Scale Rule Name
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of the scale rule
        eg: azure-servicebus, redis etc.
        """
elif False:
    JobScaleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobScaleRuleArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
                 metadata: Optional[Any] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        Scaling rule.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]] auth: Authentication secrets for the scale rule.
        :param Any metadata: Metadata properties to describe the scale rule.
        :param pulumi.Input[builtins.str] name: Scale Rule Name
        :param pulumi.Input[builtins.str] type: Type of the scale rule
               eg: azure-servicebus, redis etc.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]:
        """
        Authentication secrets for the scale rule.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Any]:
        """
        Metadata properties to describe the scale rule.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[Any]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Scale Rule Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of the scale rule
        eg: azure-servicebus, redis etc.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class JobScaleArgsDict(TypedDict):
        """
        Scaling configurations for event driven jobs.
        """
        max_executions: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of job executions that are created for a trigger, default 100.
        """
        min_executions: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum number of job executions that are created for a trigger, default 0
        """
        polling_interval: NotRequired[pulumi.Input[builtins.int]]
        """
        Interval to check each event source in seconds. Defaults to 30s
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobScaleRuleArgsDict']]]]
        """
        Scaling rules.
        """
elif False:
    JobScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobScaleArgs:
    def __init__(__self__, *,
                 max_executions: Optional[pulumi.Input[builtins.int]] = None,
                 min_executions: Optional[pulumi.Input[builtins.int]] = None,
                 polling_interval: Optional[pulumi.Input[builtins.int]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['JobScaleRuleArgs']]]] = None):
        """
        Scaling configurations for event driven jobs.
        :param pulumi.Input[builtins.int] max_executions: Maximum number of job executions that are created for a trigger, default 100.
        :param pulumi.Input[builtins.int] min_executions: Minimum number of job executions that are created for a trigger, default 0
        :param pulumi.Input[builtins.int] polling_interval: Interval to check each event source in seconds. Defaults to 30s
        :param pulumi.Input[Sequence[pulumi.Input['JobScaleRuleArgs']]] rules: Scaling rules.
        """
        if max_executions is None:
            max_executions = 100
        if max_executions is not None:
            pulumi.set(__self__, "max_executions", max_executions)
        if min_executions is None:
            min_executions = 0
        if min_executions is not None:
            pulumi.set(__self__, "min_executions", min_executions)
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="maxExecutions")
    def max_executions(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of job executions that are created for a trigger, default 100.
        """
        return pulumi.get(self, "max_executions")

    @max_executions.setter
    def max_executions(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_executions", value)

    @property
    @pulumi.getter(name="minExecutions")
    def min_executions(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum number of job executions that are created for a trigger, default 0
        """
        return pulumi.get(self, "min_executions")

    @min_executions.setter
    def min_executions(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_executions", value)

    @property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Interval to check each event source in seconds. Defaults to 30s
        """
        return pulumi.get(self, "polling_interval")

    @polling_interval.setter
    def polling_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "polling_interval", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobScaleRuleArgs']]]]:
        """
        Scaling rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobScaleRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class JobTemplateArgsDict(TypedDict):
        """
        Container Apps Job versioned application definition. Defines the desired state of an immutable revision. Any changes to this section Will result in a new revision being created
        """
        containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContainerArgsDict']]]]
        """
        List of container definitions for the Container App.
        """
        init_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['InitContainerArgsDict']]]]
        """
        List of specialized containers that run before app containers.
        """
        volumes: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeArgsDict']]]]
        """
        List of volume definitions for the Container App.
        """
elif False:
    JobTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTemplateArgs:
    def __init__(__self__, *,
                 containers: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]]] = None,
                 init_containers: Optional[pulumi.Input[Sequence[pulumi.Input['InitContainerArgs']]]] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]]] = None):
        """
        Container Apps Job versioned application definition. Defines the desired state of an immutable revision. Any changes to this section Will result in a new revision being created
        :param pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]] containers: List of container definitions for the Container App.
        :param pulumi.Input[Sequence[pulumi.Input['InitContainerArgs']]] init_containers: List of specialized containers that run before app containers.
        :param pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]] volumes: List of volume definitions for the Container App.
        """
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if init_containers is not None:
            pulumi.set(__self__, "init_containers", init_containers)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]]]:
        """
        List of container definitions for the Container App.
        """
        return pulumi.get(self, "containers")

    @containers.setter
    def containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]]]):
        pulumi.set(self, "containers", value)

    @property
    @pulumi.getter(name="initContainers")
    def init_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InitContainerArgs']]]]:
        """
        List of specialized containers that run before app containers.
        """
        return pulumi.get(self, "init_containers")

    @init_containers.setter
    def init_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InitContainerArgs']]]]):
        pulumi.set(self, "init_containers", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]]]:
        """
        List of volume definitions for the Container App.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]]]):
        pulumi.set(self, "volumes", value)


if not MYPY:
    class JwtClaimChecksArgsDict(TypedDict):
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        allowed_client_applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of the allowed client applications.
        """
        allowed_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of the allowed groups.
        """
elif False:
    JwtClaimChecksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JwtClaimChecksArgs:
    def __init__(__self__, *,
                 allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_client_applications: The list of the allowed client applications.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_groups: The list of the allowed groups.
        """
        if allowed_client_applications is not None:
            pulumi.set(__self__, "allowed_client_applications", allowed_client_applications)
        if allowed_groups is not None:
            pulumi.set(__self__, "allowed_groups", allowed_groups)

    @property
    @pulumi.getter(name="allowedClientApplications")
    def allowed_client_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of the allowed client applications.
        """
        return pulumi.get(self, "allowed_client_applications")

    @allowed_client_applications.setter
    def allowed_client_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_client_applications", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of the allowed groups.
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_groups", value)


if not MYPY:
    class LogAnalyticsConfigurationArgsDict(TypedDict):
        """
        Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
        """
        customer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Log analytics customer id
        """
        shared_key: NotRequired[pulumi.Input[builtins.str]]
        """
        Log analytics customer key
        """
elif False:
    LogAnalyticsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogAnalyticsConfigurationArgs:
    def __init__(__self__, *,
                 customer_id: Optional[pulumi.Input[builtins.str]] = None,
                 shared_key: Optional[pulumi.Input[builtins.str]] = None):
        """
        Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
        :param pulumi.Input[builtins.str] customer_id: Log analytics customer id
        :param pulumi.Input[builtins.str] shared_key: Log analytics customer key
        """
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)
        if shared_key is not None:
            pulumi.set(__self__, "shared_key", shared_key)

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Log analytics customer id
        """
        return pulumi.get(self, "customer_id")

    @customer_id.setter
    def customer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "customer_id", value)

    @property
    @pulumi.getter(name="sharedKey")
    def shared_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Log analytics customer key
        """
        return pulumi.get(self, "shared_key")

    @shared_key.setter
    def shared_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "shared_key", value)


if not MYPY:
    class LoginRoutesArgsDict(TypedDict):
        """
        The routes that specify the endpoints used for login and logout requests.
        """
        logout_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The endpoint at which a logout request should be made.
        """
elif False:
    LoginRoutesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoginRoutesArgs:
    def __init__(__self__, *,
                 logout_endpoint: Optional[pulumi.Input[builtins.str]] = None):
        """
        The routes that specify the endpoints used for login and logout requests.
        :param pulumi.Input[builtins.str] logout_endpoint: The endpoint at which a logout request should be made.
        """
        if logout_endpoint is not None:
            pulumi.set(__self__, "logout_endpoint", logout_endpoint)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The endpoint at which a logout request should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @logout_endpoint.setter
    def logout_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "logout_endpoint", value)


if not MYPY:
    class LoginScopesArgsDict(TypedDict):
        """
        The configuration settings of the login flow, including the scopes that should be requested.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of the scopes that should be requested while authenticating.
        """
elif False:
    LoginScopesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoginScopesArgs:
    def __init__(__self__, *,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The configuration settings of the login flow, including the scopes that should be requested.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: A list of the scopes that should be requested while authenticating.
        """
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class LoginArgsDict(TypedDict):
        """
        The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
        """
        allowed_external_redirect_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
        This is an advanced setting typically only needed by Windows Store application backends.
        Note that URLs within the current domain are always implicitly allowed.
        """
        cookie_expiration: NotRequired[pulumi.Input['CookieExpirationArgsDict']]
        """
        The configuration settings of the session cookie's expiration.
        """
        nonce: NotRequired[pulumi.Input['NonceArgsDict']]
        """
        The configuration settings of the nonce used in the login flow.
        """
        preserve_url_fragments_for_logins: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        """
        routes: NotRequired[pulumi.Input['LoginRoutesArgsDict']]
        """
        The routes that specify the endpoints used for login and logout requests.
        """
        token_store: NotRequired[pulumi.Input['TokenStoreArgsDict']]
        """
        The configuration settings of the token store.
        """
elif False:
    LoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoginArgs:
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 cookie_expiration: Optional[pulumi.Input['CookieExpirationArgs']] = None,
                 nonce: Optional[pulumi.Input['NonceArgs']] = None,
                 preserve_url_fragments_for_logins: Optional[pulumi.Input[builtins.bool]] = None,
                 routes: Optional[pulumi.Input['LoginRoutesArgs']] = None,
                 token_store: Optional[pulumi.Input['TokenStoreArgs']] = None):
        """
        The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
               This is an advanced setting typically only needed by Windows Store application backends.
               Note that URLs within the current domain are always implicitly allowed.
        :param pulumi.Input['CookieExpirationArgs'] cookie_expiration: The configuration settings of the session cookie's expiration.
        :param pulumi.Input['NonceArgs'] nonce: The configuration settings of the nonce used in the login flow.
        :param pulumi.Input[builtins.bool] preserve_url_fragments_for_logins: <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        :param pulumi.Input['LoginRoutesArgs'] routes: The routes that specify the endpoints used for login and logout requests.
        :param pulumi.Input['TokenStoreArgs'] token_store: The configuration settings of the token store.
        """
        if allowed_external_redirect_urls is not None:
            pulumi.set(__self__, "allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration is not None:
            pulumi.set(__self__, "cookie_expiration", cookie_expiration)
        if nonce is not None:
            pulumi.set(__self__, "nonce", nonce)
        if preserve_url_fragments_for_logins is not None:
            pulumi.set(__self__, "preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if token_store is not None:
            pulumi.set(__self__, "token_store", token_store)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
        This is an advanced setting typically only needed by Windows Store application backends.
        Note that URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="cookieExpiration")
    def cookie_expiration(self) -> Optional[pulumi.Input['CookieExpirationArgs']]:
        """
        The configuration settings of the session cookie's expiration.
        """
        return pulumi.get(self, "cookie_expiration")

    @cookie_expiration.setter
    def cookie_expiration(self, value: Optional[pulumi.Input['CookieExpirationArgs']]):
        pulumi.set(self, "cookie_expiration", value)

    @property
    @pulumi.getter
    def nonce(self) -> Optional[pulumi.Input['NonceArgs']]:
        """
        The configuration settings of the nonce used in the login flow.
        """
        return pulumi.get(self, "nonce")

    @nonce.setter
    def nonce(self, value: Optional[pulumi.Input['NonceArgs']]):
        pulumi.set(self, "nonce", value)

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @preserve_url_fragments_for_logins.setter
    def preserve_url_fragments_for_logins(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "preserve_url_fragments_for_logins", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input['LoginRoutesArgs']]:
        """
        The routes that specify the endpoints used for login and logout requests.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input['LoginRoutesArgs']]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter(name="tokenStore")
    def token_store(self) -> Optional[pulumi.Input['TokenStoreArgs']]:
        """
        The configuration settings of the token store.
        """
        return pulumi.get(self, "token_store")

    @token_store.setter
    def token_store(self, value: Optional[pulumi.Input['TokenStoreArgs']]):
        pulumi.set(self, "token_store", value)


if not MYPY:
    class ManagedCertificatePropertiesArgsDict(TypedDict):
        """
        Certificate resource specific properties
        """
        domain_control_validation: NotRequired[pulumi.Input[Union[builtins.str, 'ManagedCertificateDomainControlValidation']]]
        """
        Selected type of domain control validation for managed certificates.
        """
        subject_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Subject name of the certificate.
        """
elif False:
    ManagedCertificatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedCertificatePropertiesArgs:
    def __init__(__self__, *,
                 domain_control_validation: Optional[pulumi.Input[Union[builtins.str, 'ManagedCertificateDomainControlValidation']]] = None,
                 subject_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Certificate resource specific properties
        :param pulumi.Input[Union[builtins.str, 'ManagedCertificateDomainControlValidation']] domain_control_validation: Selected type of domain control validation for managed certificates.
        :param pulumi.Input[builtins.str] subject_name: Subject name of the certificate.
        """
        if domain_control_validation is not None:
            pulumi.set(__self__, "domain_control_validation", domain_control_validation)
        if subject_name is not None:
            pulumi.set(__self__, "subject_name", subject_name)

    @property
    @pulumi.getter(name="domainControlValidation")
    def domain_control_validation(self) -> Optional[pulumi.Input[Union[builtins.str, 'ManagedCertificateDomainControlValidation']]]:
        """
        Selected type of domain control validation for managed certificates.
        """
        return pulumi.get(self, "domain_control_validation")

    @domain_control_validation.setter
    def domain_control_validation(self, value: Optional[pulumi.Input[Union[builtins.str, 'ManagedCertificateDomainControlValidation']]]):
        pulumi.set(self, "domain_control_validation", value)

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subject name of the certificate.
        """
        return pulumi.get(self, "subject_name")

    @subject_name.setter
    def subject_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subject_name", value)


if not MYPY:
    class ManagedEnvironmentEncryptionArgsDict(TypedDict):
        """
        Peer traffic encryption settings for the Managed Environment
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Boolean indicating whether the peer traffic encryption is enabled
        """
elif False:
    ManagedEnvironmentEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedEnvironmentEncryptionArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Peer traffic encryption settings for the Managed Environment
        :param pulumi.Input[builtins.bool] enabled: Boolean indicating whether the peer traffic encryption is enabled
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Boolean indicating whether the peer traffic encryption is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ManagedEnvironmentPeerAuthenticationArgsDict(TypedDict):
        """
        Peer authentication settings for the Managed Environment
        """
        mtls: NotRequired[pulumi.Input['MtlsArgsDict']]
        """
        Mutual TLS authentication settings for the Managed Environment
        """
elif False:
    ManagedEnvironmentPeerAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedEnvironmentPeerAuthenticationArgs:
    def __init__(__self__, *,
                 mtls: Optional[pulumi.Input['MtlsArgs']] = None):
        """
        Peer authentication settings for the Managed Environment
        :param pulumi.Input['MtlsArgs'] mtls: Mutual TLS authentication settings for the Managed Environment
        """
        if mtls is not None:
            pulumi.set(__self__, "mtls", mtls)

    @property
    @pulumi.getter
    def mtls(self) -> Optional[pulumi.Input['MtlsArgs']]:
        """
        Mutual TLS authentication settings for the Managed Environment
        """
        return pulumi.get(self, "mtls")

    @mtls.setter
    def mtls(self, value: Optional[pulumi.Input['MtlsArgs']]):
        pulumi.set(self, "mtls", value)


if not MYPY:
    class ManagedEnvironmentPeerTrafficConfigurationArgsDict(TypedDict):
        """
        Peer traffic settings for the Managed Environment
        """
        encryption: NotRequired[pulumi.Input['ManagedEnvironmentEncryptionArgsDict']]
        """
        Peer traffic encryption settings for the Managed Environment
        """
elif False:
    ManagedEnvironmentPeerTrafficConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedEnvironmentPeerTrafficConfigurationArgs:
    def __init__(__self__, *,
                 encryption: Optional[pulumi.Input['ManagedEnvironmentEncryptionArgs']] = None):
        """
        Peer traffic settings for the Managed Environment
        :param pulumi.Input['ManagedEnvironmentEncryptionArgs'] encryption: Peer traffic encryption settings for the Managed Environment
        """
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)

    @property
    @pulumi.getter
    def encryption(self) -> Optional[pulumi.Input['ManagedEnvironmentEncryptionArgs']]:
        """
        Peer traffic encryption settings for the Managed Environment
        """
        return pulumi.get(self, "encryption")

    @encryption.setter
    def encryption(self, value: Optional[pulumi.Input['ManagedEnvironmentEncryptionArgs']]):
        pulumi.set(self, "encryption", value)


if not MYPY:
    class ManagedEnvironmentStoragePropertiesArgsDict(TypedDict):
        """
        Storage properties
        """
        azure_file: NotRequired[pulumi.Input['AzureFilePropertiesArgsDict']]
        """
        Azure file properties
        """
elif False:
    ManagedEnvironmentStoragePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedEnvironmentStoragePropertiesArgs:
    def __init__(__self__, *,
                 azure_file: Optional[pulumi.Input['AzureFilePropertiesArgs']] = None):
        """
        Storage properties
        :param pulumi.Input['AzureFilePropertiesArgs'] azure_file: Azure file properties
        """
        if azure_file is not None:
            pulumi.set(__self__, "azure_file", azure_file)

    @property
    @pulumi.getter(name="azureFile")
    def azure_file(self) -> Optional[pulumi.Input['AzureFilePropertiesArgs']]:
        """
        Azure file properties
        """
        return pulumi.get(self, "azure_file")

    @azure_file.setter
    def azure_file(self, value: Optional[pulumi.Input['AzureFilePropertiesArgs']]):
        pulumi.set(self, "azure_file", value)


if not MYPY:
    class ManagedIdentitySettingArgsDict(TypedDict):
        """
        Optional settings for a Managed Identity that is assigned to the Session pool.
        """
        identity: pulumi.Input[builtins.str]
        """
        The resource ID of a user-assigned managed identity that is assigned to the Session Pool, or 'system' for system-assigned identity.
        """
        lifecycle: NotRequired[pulumi.Input[Union[builtins.str, 'IdentitySettingsLifeCycle']]]
        """
        Use to select the lifecycle stages of a Session Pool during which the Managed Identity should be available.
        """
elif False:
    ManagedIdentitySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedIdentitySettingArgs:
    def __init__(__self__, *,
                 identity: pulumi.Input[builtins.str],
                 lifecycle: Optional[pulumi.Input[Union[builtins.str, 'IdentitySettingsLifeCycle']]] = None):
        """
        Optional settings for a Managed Identity that is assigned to the Session pool.
        :param pulumi.Input[builtins.str] identity: The resource ID of a user-assigned managed identity that is assigned to the Session Pool, or 'system' for system-assigned identity.
        :param pulumi.Input[Union[builtins.str, 'IdentitySettingsLifeCycle']] lifecycle: Use to select the lifecycle stages of a Session Pool during which the Managed Identity should be available.
        """
        pulumi.set(__self__, "identity", identity)
        if lifecycle is None:
            lifecycle = 'None'
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)

    @property
    @pulumi.getter
    def identity(self) -> pulumi.Input[builtins.str]:
        """
        The resource ID of a user-assigned managed identity that is assigned to the Session Pool, or 'system' for system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional[pulumi.Input[Union[builtins.str, 'IdentitySettingsLifeCycle']]]:
        """
        Use to select the lifecycle stages of a Session Pool during which the Managed Identity should be available.
        """
        return pulumi.get(self, "lifecycle")

    @lifecycle.setter
    def lifecycle(self, value: Optional[pulumi.Input[Union[builtins.str, 'IdentitySettingsLifeCycle']]]):
        pulumi.set(self, "lifecycle", value)


if not MYPY:
    class ManagedServiceIdentityArgsDict(TypedDict):
        """
        Managed service identity (system assigned and/or user assigned identities)
        """
        type: pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']]
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        user_assigned_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
elif False:
    ManagedServiceIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        pulumi.set(__self__, "type", type)
        if user_assigned_identities is not None:
            pulumi.set(__self__, "user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[builtins.str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


if not MYPY:
    class MtlsArgsDict(TypedDict):
        """
        Configuration properties for mutual TLS authentication
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Boolean indicating whether the mutual TLS authentication is enabled
        """
elif False:
    MtlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MtlsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None):
        """
        Configuration properties for mutual TLS authentication
        :param pulumi.Input[builtins.bool] enabled: Boolean indicating whether the mutual TLS authentication is enabled
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Boolean indicating whether the mutual TLS authentication is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NacosComponentArgsDict(TypedDict):
        """
        Nacos properties.
        """
        component_type: pulumi.Input[builtins.str]
        """
        Type of the Java Component.
        Expected value is 'Nacos'.
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgsDict']]]]
        """
        List of Java Components configuration properties
        """
        scale: NotRequired[pulumi.Input['JavaComponentPropertiesScaleArgsDict']]
        """
        Java component scaling configurations
        """
        service_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgsDict']]]]
        """
        List of Java Components that are bound to the Java component
        """
elif False:
    NacosComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NacosComponentArgs:
    def __init__(__self__, *,
                 component_type: pulumi.Input[builtins.str],
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]] = None,
                 scale: Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']] = None,
                 service_binds: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]] = None):
        """
        Nacos properties.
        :param pulumi.Input[builtins.str] component_type: Type of the Java Component.
               Expected value is 'Nacos'.
        :param pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]] configurations: List of Java Components configuration properties
        :param pulumi.Input['JavaComponentPropertiesScaleArgs'] scale: Java component scaling configurations
        :param pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]] service_binds: List of Java Components that are bound to the Java component
        """
        pulumi.set(__self__, "component_type", 'Nacos')
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if service_binds is not None:
            pulumi.set(__self__, "service_binds", service_binds)

    @property
    @pulumi.getter(name="componentType")
    def component_type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the Java Component.
        Expected value is 'Nacos'.
        """
        return pulumi.get(self, "component_type")

    @component_type.setter
    def component_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "component_type", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]]:
        """
        List of Java Components configuration properties
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']]:
        """
        Java component scaling configurations
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']]):
        pulumi.set(self, "scale", value)

    @property
    @pulumi.getter(name="serviceBinds")
    def service_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]]:
        """
        List of Java Components that are bound to the Java component
        """
        return pulumi.get(self, "service_binds")

    @service_binds.setter
    def service_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]]):
        pulumi.set(self, "service_binds", value)


if not MYPY:
    class NonceArgsDict(TypedDict):
        """
        The configuration settings of the nonce used in the login flow.
        """
        nonce_expiration_interval: NotRequired[pulumi.Input[builtins.str]]
        """
        The time after the request is made when the nonce should expire.
        """
        validate_nonce: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
elif False:
    NonceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NonceArgs:
    def __init__(__self__, *,
                 nonce_expiration_interval: Optional[pulumi.Input[builtins.str]] = None,
                 validate_nonce: Optional[pulumi.Input[builtins.bool]] = None):
        """
        The configuration settings of the nonce used in the login flow.
        :param pulumi.Input[builtins.str] nonce_expiration_interval: The time after the request is made when the nonce should expire.
        :param pulumi.Input[builtins.bool] validate_nonce: <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
        if nonce_expiration_interval is not None:
            pulumi.set(__self__, "nonce_expiration_interval", nonce_expiration_interval)
        if validate_nonce is not None:
            pulumi.set(__self__, "validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="nonceExpirationInterval")
    def nonce_expiration_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The time after the request is made when the nonce should expire.
        """
        return pulumi.get(self, "nonce_expiration_interval")

    @nonce_expiration_interval.setter
    def nonce_expiration_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nonce_expiration_interval", value)

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "validate_nonce")

    @validate_nonce.setter
    def validate_nonce(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "validate_nonce", value)


if not MYPY:
    class OpenIdConnectClientCredentialArgsDict(TypedDict):
        """
        The authentication client credentials of the custom Open ID Connect provider.
        """
        client_secret_setting_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The app setting that contains the client secret for the custom Open ID Connect provider.
        """
        method: NotRequired[pulumi.Input['ClientCredentialMethod']]
        """
        The method that should be used to authenticate the user.
        """
elif False:
    OpenIdConnectClientCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenIdConnectClientCredentialArgs:
    def __init__(__self__, *,
                 client_secret_setting_name: Optional[pulumi.Input[builtins.str]] = None,
                 method: Optional[pulumi.Input['ClientCredentialMethod']] = None):
        """
        The authentication client credentials of the custom Open ID Connect provider.
        :param pulumi.Input[builtins.str] client_secret_setting_name: The app setting that contains the client secret for the custom Open ID Connect provider.
        :param pulumi.Input['ClientCredentialMethod'] method: The method that should be used to authenticate the user.
        """
        if client_secret_setting_name is not None:
            pulumi.set(__self__, "client_secret_setting_name", client_secret_setting_name)
        if method is not None:
            pulumi.set(__self__, "method", method)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The app setting that contains the client secret for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['ClientCredentialMethod']]:
        """
        The method that should be used to authenticate the user.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['ClientCredentialMethod']]):
        pulumi.set(self, "method", value)


if not MYPY:
    class OpenIdConnectConfigArgsDict(TypedDict):
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        authorization_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The endpoint to be used to make an authorization request.
        """
        certification_uri: NotRequired[pulumi.Input[builtins.str]]
        """
        The endpoint that provides the keys necessary to validate the token.
        """
        issuer: NotRequired[pulumi.Input[builtins.str]]
        """
        The endpoint that issues the token.
        """
        token_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The endpoint to be used to request a token.
        """
        well_known_open_id_configuration: NotRequired[pulumi.Input[builtins.str]]
        """
        The endpoint that contains all the configuration endpoints for the provider.
        """
elif False:
    OpenIdConnectConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenIdConnectConfigArgs:
    def __init__(__self__, *,
                 authorization_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 certification_uri: Optional[pulumi.Input[builtins.str]] = None,
                 issuer: Optional[pulumi.Input[builtins.str]] = None,
                 token_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 well_known_open_id_configuration: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        :param pulumi.Input[builtins.str] authorization_endpoint: The endpoint to be used to make an authorization request.
        :param pulumi.Input[builtins.str] certification_uri: The endpoint that provides the keys necessary to validate the token.
        :param pulumi.Input[builtins.str] issuer: The endpoint that issues the token.
        :param pulumi.Input[builtins.str] token_endpoint: The endpoint to be used to request a token.
        :param pulumi.Input[builtins.str] well_known_open_id_configuration: The endpoint that contains all the configuration endpoints for the provider.
        """
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if certification_uri is not None:
            pulumi.set(__self__, "certification_uri", certification_uri)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if well_known_open_id_configuration is not None:
            pulumi.set(__self__, "well_known_open_id_configuration", well_known_open_id_configuration)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The endpoint to be used to make an authorization request.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The endpoint that provides the keys necessary to validate the token.
        """
        return pulumi.get(self, "certification_uri")

    @certification_uri.setter
    def certification_uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certification_uri", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The endpoint that issues the token.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The endpoint to be used to request a token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="wellKnownOpenIdConfiguration")
    def well_known_open_id_configuration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The endpoint that contains all the configuration endpoints for the provider.
        """
        return pulumi.get(self, "well_known_open_id_configuration")

    @well_known_open_id_configuration.setter
    def well_known_open_id_configuration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "well_known_open_id_configuration", value)


if not MYPY:
    class OpenIdConnectLoginArgsDict(TypedDict):
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        """
        name_claim_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the claim that contains the users name.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of the scopes that should be requested while authenticating.
        """
elif False:
    OpenIdConnectLoginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenIdConnectLoginArgs:
    def __init__(__self__, *,
                 name_claim_type: Optional[pulumi.Input[builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        :param pulumi.Input[builtins.str] name_claim_type: The name of the claim that contains the users name.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: A list of the scopes that should be requested while authenticating.
        """
        if name_claim_type is not None:
            pulumi.set(__self__, "name_claim_type", name_claim_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @name_claim_type.setter
    def name_claim_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name_claim_type", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class OpenIdConnectRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        client_credential: NotRequired[pulumi.Input['OpenIdConnectClientCredentialArgsDict']]
        """
        The authentication credentials of the custom Open ID Connect provider.
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The client id of the custom Open ID Connect provider.
        """
        open_id_connect_configuration: NotRequired[pulumi.Input['OpenIdConnectConfigArgsDict']]
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
elif False:
    OpenIdConnectRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OpenIdConnectRegistrationArgs:
    def __init__(__self__, *,
                 client_credential: Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']] = None,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 open_id_connect_configuration: Optional[pulumi.Input['OpenIdConnectConfigArgs']] = None):
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        :param pulumi.Input['OpenIdConnectClientCredentialArgs'] client_credential: The authentication credentials of the custom Open ID Connect provider.
        :param pulumi.Input[builtins.str] client_id: The client id of the custom Open ID Connect provider.
        :param pulumi.Input['OpenIdConnectConfigArgs'] open_id_connect_configuration: The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        if client_credential is not None:
            pulumi.set(__self__, "client_credential", client_credential)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if open_id_connect_configuration is not None:
            pulumi.set(__self__, "open_id_connect_configuration", open_id_connect_configuration)

    @property
    @pulumi.getter(name="clientCredential")
    def client_credential(self) -> Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']]:
        """
        The authentication credentials of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_credential")

    @client_credential.setter
    def client_credential(self, value: Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']]):
        pulumi.set(self, "client_credential", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The client id of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="openIdConnectConfiguration")
    def open_id_connect_configuration(self) -> Optional[pulumi.Input['OpenIdConnectConfigArgs']]:
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "open_id_connect_configuration")

    @open_id_connect_configuration.setter
    def open_id_connect_configuration(self, value: Optional[pulumi.Input['OpenIdConnectConfigArgs']]):
        pulumi.set(self, "open_id_connect_configuration", value)


if not MYPY:
    class PreBuildStepArgsDict(TypedDict):
        """
        Model representing a pre-build step.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of the pre-build step.
        """
        http_get: NotRequired[pulumi.Input['HttpGetArgsDict']]
        """
        Http get request to send before the build.
        """
        scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of custom commands to run.
        """
elif False:
    PreBuildStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreBuildStepArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 http_get: Optional[pulumi.Input['HttpGetArgs']] = None,
                 scripts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Model representing a pre-build step.
        :param pulumi.Input[builtins.str] description: Description of the pre-build step.
        :param pulumi.Input['HttpGetArgs'] http_get: Http get request to send before the build.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scripts: List of custom commands to run.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if scripts is not None:
            pulumi.set(__self__, "scripts", scripts)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of the pre-build step.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['HttpGetArgs']]:
        """
        Http get request to send before the build.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['HttpGetArgs']]):
        pulumi.set(self, "http_get", value)

    @property
    @pulumi.getter
    def scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of custom commands to run.
        """
        return pulumi.get(self, "scripts")

    @scripts.setter
    def scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scripts", value)


if not MYPY:
    class PrivateLinkServiceConnectionStateArgsDict(TypedDict):
        """
        A collection of information about the state of the connection between service consumer and provider.
        """
        actions_required: NotRequired[pulumi.Input[builtins.str]]
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The reason for approval/rejection of the connection.
        """
        status: NotRequired[pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']]]
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
elif False:
    PrivateLinkServiceConnectionStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateLinkServiceConnectionStateArgs:
    def __init__(__self__, *,
                 actions_required: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']]] = None):
        """
        A collection of information about the state of the connection between service consumer and provider.
        :param pulumi.Input[builtins.str] actions_required: A message indicating if changes on the service provider require any updates on the consumer.
        :param pulumi.Input[builtins.str] description: The reason for approval/rejection of the connection.
        :param pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']] status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        if actions_required is not None:
            pulumi.set(__self__, "actions_required", actions_required)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="actionsRequired")
    def actions_required(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A message indicating if changes on the service provider require any updates on the consumer.
        """
        return pulumi.get(self, "actions_required")

    @actions_required.setter
    def actions_required(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "actions_required", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The reason for approval/rejection of the connection.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']]]:
        """
        Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[builtins.str, 'PrivateEndpointServiceConnectionStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class QueueScaleRuleArgsDict(TypedDict):
        """
        Container App container Azure Queue based scaling rule.
        """
        auth: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgsDict']]]]
        """
        Authentication secrets for the queue scale rule.
        """
        queue_length: NotRequired[pulumi.Input[builtins.int]]
        """
        Queue length.
        """
        queue_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Queue name.
        """
elif False:
    QueueScaleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueScaleRuleArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
                 queue_length: Optional[pulumi.Input[builtins.int]] = None,
                 queue_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Container App container Azure Queue based scaling rule.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]] auth: Authentication secrets for the queue scale rule.
        :param pulumi.Input[builtins.int] queue_length: Queue length.
        :param pulumi.Input[builtins.str] queue_name: Queue name.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if queue_length is not None:
            pulumi.set(__self__, "queue_length", queue_length)
        if queue_name is not None:
            pulumi.set(__self__, "queue_name", queue_name)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]:
        """
        Authentication secrets for the queue scale rule.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="queueLength")
    def queue_length(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Queue length.
        """
        return pulumi.get(self, "queue_length")

    @queue_length.setter
    def queue_length(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "queue_length", value)

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Queue name.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "queue_name", value)


if not MYPY:
    class RegistryCredentialsArgsDict(TypedDict):
        """
        Container App Private Registry
        """
        identity: NotRequired[pulumi.Input[builtins.str]]
        """
        A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        """
        password_secret_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the Secret that contains the registry login password
        """
        server: NotRequired[pulumi.Input[builtins.str]]
        """
        Container Registry Server
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Container Registry Username
        """
elif False:
    RegistryCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryCredentialsArgs:
    def __init__(__self__, *,
                 identity: Optional[pulumi.Input[builtins.str]] = None,
                 password_secret_ref: Optional[pulumi.Input[builtins.str]] = None,
                 server: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        Container App Private Registry
        :param pulumi.Input[builtins.str] identity: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        :param pulumi.Input[builtins.str] password_secret_ref: The name of the Secret that contains the registry login password
        :param pulumi.Input[builtins.str] server: Container Registry Server
        :param pulumi.Input[builtins.str] username: Container Registry Username
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if password_secret_ref is not None:
            pulumi.set(__self__, "password_secret_ref", password_secret_ref)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter(name="passwordSecretRef")
    def password_secret_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the Secret that contains the registry login password
        """
        return pulumi.get(self, "password_secret_ref")

    @password_secret_ref.setter
    def password_secret_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password_secret_ref", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Container Registry Server
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Container Registry Username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class RegistryInfoArgsDict(TypedDict):
        """
        Container App registry information.
        """
        registry_password: NotRequired[pulumi.Input[builtins.str]]
        """
        registry secret.
        """
        registry_url: NotRequired[pulumi.Input[builtins.str]]
        """
        registry server Url.
        """
        registry_user_name: NotRequired[pulumi.Input[builtins.str]]
        """
        registry username.
        """
elif False:
    RegistryInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryInfoArgs:
    def __init__(__self__, *,
                 registry_password: Optional[pulumi.Input[builtins.str]] = None,
                 registry_url: Optional[pulumi.Input[builtins.str]] = None,
                 registry_user_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Container App registry information.
        :param pulumi.Input[builtins.str] registry_password: registry secret.
        :param pulumi.Input[builtins.str] registry_url: registry server Url.
        :param pulumi.Input[builtins.str] registry_user_name: registry username.
        """
        if registry_password is not None:
            pulumi.set(__self__, "registry_password", registry_password)
        if registry_url is not None:
            pulumi.set(__self__, "registry_url", registry_url)
        if registry_user_name is not None:
            pulumi.set(__self__, "registry_user_name", registry_user_name)

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        registry secret.
        """
        return pulumi.get(self, "registry_password")

    @registry_password.setter
    def registry_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "registry_password", value)

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        registry server Url.
        """
        return pulumi.get(self, "registry_url")

    @registry_url.setter
    def registry_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "registry_url", value)

    @property
    @pulumi.getter(name="registryUserName")
    def registry_user_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        registry username.
        """
        return pulumi.get(self, "registry_user_name")

    @registry_user_name.setter
    def registry_user_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "registry_user_name", value)


if not MYPY:
    class ScaleConfigurationArgsDict(TypedDict):
        """
        Scale configuration.
        """
        max_concurrent_sessions: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum count of sessions at the same time.
        """
        ready_session_instances: NotRequired[pulumi.Input[builtins.int]]
        """
        The minimum count of ready session instances.
        """
elif False:
    ScaleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleConfigurationArgs:
    def __init__(__self__, *,
                 max_concurrent_sessions: Optional[pulumi.Input[builtins.int]] = None,
                 ready_session_instances: Optional[pulumi.Input[builtins.int]] = None):
        """
        Scale configuration.
        :param pulumi.Input[builtins.int] max_concurrent_sessions: The maximum count of sessions at the same time.
        :param pulumi.Input[builtins.int] ready_session_instances: The minimum count of ready session instances.
        """
        if max_concurrent_sessions is not None:
            pulumi.set(__self__, "max_concurrent_sessions", max_concurrent_sessions)
        if ready_session_instances is not None:
            pulumi.set(__self__, "ready_session_instances", ready_session_instances)

    @property
    @pulumi.getter(name="maxConcurrentSessions")
    def max_concurrent_sessions(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum count of sessions at the same time.
        """
        return pulumi.get(self, "max_concurrent_sessions")

    @max_concurrent_sessions.setter
    def max_concurrent_sessions(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_concurrent_sessions", value)

    @property
    @pulumi.getter(name="readySessionInstances")
    def ready_session_instances(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The minimum count of ready session instances.
        """
        return pulumi.get(self, "ready_session_instances")

    @ready_session_instances.setter
    def ready_session_instances(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ready_session_instances", value)


if not MYPY:
    class ScaleRuleAuthArgsDict(TypedDict):
        """
        Auth Secrets for Scale Rule
        """
        secret_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the secret from which to pull the auth params.
        """
        trigger_parameter: NotRequired[pulumi.Input[builtins.str]]
        """
        Trigger Parameter that uses the secret
        """
elif False:
    ScaleRuleAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleRuleAuthArgs:
    def __init__(__self__, *,
                 secret_ref: Optional[pulumi.Input[builtins.str]] = None,
                 trigger_parameter: Optional[pulumi.Input[builtins.str]] = None):
        """
        Auth Secrets for Scale Rule
        :param pulumi.Input[builtins.str] secret_ref: Name of the secret from which to pull the auth params.
        :param pulumi.Input[builtins.str] trigger_parameter: Trigger Parameter that uses the secret
        """
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if trigger_parameter is not None:
            pulumi.set(__self__, "trigger_parameter", trigger_parameter)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the secret from which to pull the auth params.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_ref", value)

    @property
    @pulumi.getter(name="triggerParameter")
    def trigger_parameter(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Trigger Parameter that uses the secret
        """
        return pulumi.get(self, "trigger_parameter")

    @trigger_parameter.setter
    def trigger_parameter(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "trigger_parameter", value)


if not MYPY:
    class ScaleRuleArgsDict(TypedDict):
        """
        Container App container scaling rule.
        """
        azure_queue: NotRequired[pulumi.Input['QueueScaleRuleArgsDict']]
        """
        Azure Queue based scaling.
        """
        custom: NotRequired[pulumi.Input['CustomScaleRuleArgsDict']]
        """
        Custom scale rule.
        """
        http: NotRequired[pulumi.Input['HttpScaleRuleArgsDict']]
        """
        HTTP requests based scaling.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Scale Rule Name
        """
        tcp: NotRequired[pulumi.Input['TcpScaleRuleArgsDict']]
        """
        Tcp requests based scaling.
        """
elif False:
    ScaleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleRuleArgs:
    def __init__(__self__, *,
                 azure_queue: Optional[pulumi.Input['QueueScaleRuleArgs']] = None,
                 custom: Optional[pulumi.Input['CustomScaleRuleArgs']] = None,
                 http: Optional[pulumi.Input['HttpScaleRuleArgs']] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 tcp: Optional[pulumi.Input['TcpScaleRuleArgs']] = None):
        """
        Container App container scaling rule.
        :param pulumi.Input['QueueScaleRuleArgs'] azure_queue: Azure Queue based scaling.
        :param pulumi.Input['CustomScaleRuleArgs'] custom: Custom scale rule.
        :param pulumi.Input['HttpScaleRuleArgs'] http: HTTP requests based scaling.
        :param pulumi.Input[builtins.str] name: Scale Rule Name
        :param pulumi.Input['TcpScaleRuleArgs'] tcp: Tcp requests based scaling.
        """
        if azure_queue is not None:
            pulumi.set(__self__, "azure_queue", azure_queue)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)

    @property
    @pulumi.getter(name="azureQueue")
    def azure_queue(self) -> Optional[pulumi.Input['QueueScaleRuleArgs']]:
        """
        Azure Queue based scaling.
        """
        return pulumi.get(self, "azure_queue")

    @azure_queue.setter
    def azure_queue(self, value: Optional[pulumi.Input['QueueScaleRuleArgs']]):
        pulumi.set(self, "azure_queue", value)

    @property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input['CustomScaleRuleArgs']]:
        """
        Custom scale rule.
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input['CustomScaleRuleArgs']]):
        pulumi.set(self, "custom", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['HttpScaleRuleArgs']]:
        """
        HTTP requests based scaling.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['HttpScaleRuleArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Scale Rule Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['TcpScaleRuleArgs']]:
        """
        Tcp requests based scaling.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['TcpScaleRuleArgs']]):
        pulumi.set(self, "tcp", value)


if not MYPY:
    class ScaleArgsDict(TypedDict):
        """
        Container App scaling configurations.
        """
        max_replicas: NotRequired[pulumi.Input[builtins.int]]
        """
        Optional. Maximum number of container replicas. Defaults to 10 if not set.
        """
        min_replicas: NotRequired[pulumi.Input[builtins.int]]
        """
        Optional. Minimum number of container replicas.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgsDict']]]]
        """
        Scaling rules.
        """
elif False:
    ScaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScaleArgs:
    def __init__(__self__, *,
                 max_replicas: Optional[pulumi.Input[builtins.int]] = None,
                 min_replicas: Optional[pulumi.Input[builtins.int]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]]] = None):
        """
        Container App scaling configurations.
        :param pulumi.Input[builtins.int] max_replicas: Optional. Maximum number of container replicas. Defaults to 10 if not set.
        :param pulumi.Input[builtins.int] min_replicas: Optional. Minimum number of container replicas.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]] rules: Scaling rules.
        """
        if max_replicas is None:
            max_replicas = 10
        if max_replicas is not None:
            pulumi.set(__self__, "max_replicas", max_replicas)
        if min_replicas is not None:
            pulumi.set(__self__, "min_replicas", min_replicas)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optional. Maximum number of container replicas. Defaults to 10 if not set.
        """
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_replicas", value)

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Optional. Minimum number of container replicas.
        """
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_replicas", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]]]:
        """
        Scaling rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class ScgRouteArgsDict(TypedDict):
        """
        Spring Cloud Gateway route definition
        """
        id: pulumi.Input[builtins.str]
        """
        Id of the route
        """
        uri: pulumi.Input[builtins.str]
        """
        Uri of the route
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Filters of the route
        """
        order: NotRequired[pulumi.Input[builtins.float]]
        """
        Order of the route
        """
        predicates: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Predicates of the route
        """
elif False:
    ScgRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScgRouteArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 uri: pulumi.Input[builtins.str],
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 order: Optional[pulumi.Input[builtins.float]] = None,
                 predicates: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Spring Cloud Gateway route definition
        :param pulumi.Input[builtins.str] id: Id of the route
        :param pulumi.Input[builtins.str] uri: Uri of the route
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] filters: Filters of the route
        :param pulumi.Input[builtins.float] order: Order of the route
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] predicates: Predicates of the route
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "uri", uri)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if predicates is not None:
            pulumi.set(__self__, "predicates", predicates)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        Id of the route
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[builtins.str]:
        """
        Uri of the route
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Filters of the route
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Order of the route
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def predicates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Predicates of the route
        """
        return pulumi.get(self, "predicates")

    @predicates.setter
    def predicates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "predicates", value)


if not MYPY:
    class ScheduledEntryArgsDict(TypedDict):
        """
        Maintenance schedule entry for a managed environment.
        """
        duration_hours: pulumi.Input[builtins.int]
        """
        Length of maintenance window range from 8 to 24 hours.
        """
        start_hour_utc: pulumi.Input[builtins.int]
        """
        Start hour after which managed environment maintenance can start from 0 to 23 hour.
        """
        week_day: pulumi.Input['WeekDay']
        """
        Day of the week when a managed environment can be patched.
        """
elif False:
    ScheduledEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduledEntryArgs:
    def __init__(__self__, *,
                 duration_hours: pulumi.Input[builtins.int],
                 start_hour_utc: pulumi.Input[builtins.int],
                 week_day: pulumi.Input['WeekDay']):
        """
        Maintenance schedule entry for a managed environment.
        :param pulumi.Input[builtins.int] duration_hours: Length of maintenance window range from 8 to 24 hours.
        :param pulumi.Input[builtins.int] start_hour_utc: Start hour after which managed environment maintenance can start from 0 to 23 hour.
        :param pulumi.Input['WeekDay'] week_day: Day of the week when a managed environment can be patched.
        """
        pulumi.set(__self__, "duration_hours", duration_hours)
        pulumi.set(__self__, "start_hour_utc", start_hour_utc)
        pulumi.set(__self__, "week_day", week_day)

    @property
    @pulumi.getter(name="durationHours")
    def duration_hours(self) -> pulumi.Input[builtins.int]:
        """
        Length of maintenance window range from 8 to 24 hours.
        """
        return pulumi.get(self, "duration_hours")

    @duration_hours.setter
    def duration_hours(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "duration_hours", value)

    @property
    @pulumi.getter(name="startHourUtc")
    def start_hour_utc(self) -> pulumi.Input[builtins.int]:
        """
        Start hour after which managed environment maintenance can start from 0 to 23 hour.
        """
        return pulumi.get(self, "start_hour_utc")

    @start_hour_utc.setter
    def start_hour_utc(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "start_hour_utc", value)

    @property
    @pulumi.getter(name="weekDay")
    def week_day(self) -> pulumi.Input['WeekDay']:
        """
        Day of the week when a managed environment can be patched.
        """
        return pulumi.get(self, "week_day")

    @week_day.setter
    def week_day(self, value: pulumi.Input['WeekDay']):
        pulumi.set(self, "week_day", value)


if not MYPY:
    class SecretVolumeItemArgsDict(TypedDict):
        """
        Secret to be added to volume.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
        """
        secret_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the Container App secret from which to pull the secret value.
        """
elif False:
    SecretVolumeItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretVolumeItemArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        Secret to be added to volume.
        :param pulumi.Input[builtins.str] path: Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
        :param pulumi.Input[builtins.str] secret_ref: Name of the Container App secret from which to pull the secret value.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the Container App secret from which to pull the secret value.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class SecretArgsDict(TypedDict):
        """
        Secret definition.
        """
        identity: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        """
        key_vault_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Azure Key Vault URL pointing to the secret referenced by the container app.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Secret Name.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Secret Value.
        """
elif False:
    SecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretArgs:
    def __init__(__self__, *,
                 identity: Optional[pulumi.Input[builtins.str]] = None,
                 key_vault_url: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Secret definition.
        :param pulumi.Input[builtins.str] identity: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        :param pulumi.Input[builtins.str] key_vault_url: Azure Key Vault URL pointing to the secret referenced by the container app.
        :param pulumi.Input[builtins.str] name: Secret Name.
        :param pulumi.Input[builtins.str] value: Secret Value.
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if key_vault_url is not None:
            pulumi.set(__self__, "key_vault_url", key_vault_url)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter(name="keyVaultUrl")
    def key_vault_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Azure Key Vault URL pointing to the secret referenced by the container app.
        """
        return pulumi.get(self, "key_vault_url")

    @key_vault_url.setter
    def key_vault_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_vault_url", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Secret Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Secret Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceBindArgsDict(TypedDict):
        """
        Configuration to bind a ContainerApp to a dev ContainerApp Service
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the service bind
        """
        service_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource id of the target service
        """
elif False:
    ServiceBindArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceBindArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 service_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        Configuration to bind a ContainerApp to a dev ContainerApp Service
        :param pulumi.Input[builtins.str] name: Name of the service bind
        :param pulumi.Input[builtins.str] service_id: Resource id of the target service
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the service bind
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource id of the target service
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_id", value)


if not MYPY:
    class ServiceArgsDict(TypedDict):
        """
        Container App to be a dev service
        """
        type: pulumi.Input[builtins.str]
        """
        Dev ContainerApp service type
        """
elif False:
    ServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str]):
        """
        Container App to be a dev service
        :param pulumi.Input[builtins.str] type: Dev ContainerApp service type
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Dev ContainerApp service type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SessionContainerResourcesArgsDict(TypedDict):
        """
        Container resource requirements for sessions of the session pool.
        """
        cpu: NotRequired[pulumi.Input[builtins.float]]
        """
        Required CPU in cores, e.g. 0.5
        """
        memory: NotRequired[pulumi.Input[builtins.str]]
        """
        Required memory, e.g. "250Mb"
        """
elif False:
    SessionContainerResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionContainerResourcesArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[builtins.float]] = None,
                 memory: Optional[pulumi.Input[builtins.str]] = None):
        """
        Container resource requirements for sessions of the session pool.
        :param pulumi.Input[builtins.float] cpu: Required CPU in cores, e.g. 0.5
        :param pulumi.Input[builtins.str] memory: Required memory, e.g. "250Mb"
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Required CPU in cores, e.g. 0.5
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Required memory, e.g. "250Mb"
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class SessionContainerArgsDict(TypedDict):
        """
        Container definitions for the sessions of the session pool.
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Container start command arguments.
        """
        command: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Container start command.
        """
        env: NotRequired[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgsDict']]]]
        """
        Container environment variables.
        """
        image: NotRequired[pulumi.Input[builtins.str]]
        """
        Container image tag.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Custom container name.
        """
        resources: NotRequired[pulumi.Input['SessionContainerResourcesArgsDict']]
        """
        Container resource requirements.
        """
elif False:
    SessionContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionContainerArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 command: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]] = None,
                 image: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 resources: Optional[pulumi.Input['SessionContainerResourcesArgs']] = None):
        """
        Container definitions for the sessions of the session pool.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] args: Container start command arguments.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] command: Container start command.
        :param pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]] env: Container environment variables.
        :param pulumi.Input[builtins.str] image: Container image tag.
        :param pulumi.Input[builtins.str] name: Custom container name.
        :param pulumi.Input['SessionContainerResourcesArgs'] resources: Container resource requirements.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Container start command arguments.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Container start command.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]]:
        """
        Container environment variables.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Container image tag.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Custom container name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['SessionContainerResourcesArgs']]:
        """
        Container resource requirements.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['SessionContainerResourcesArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class SessionIngressArgsDict(TypedDict):
        """
        Session pool ingress configuration.
        """
        target_port: NotRequired[pulumi.Input[builtins.int]]
        """
        Target port in containers for traffic from ingress
        """
elif False:
    SessionIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionIngressArgs:
    def __init__(__self__, *,
                 target_port: Optional[pulumi.Input[builtins.int]] = None):
        """
        Session pool ingress configuration.
        :param pulumi.Input[builtins.int] target_port: Target port in containers for traffic from ingress
        """
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Target port in containers for traffic from ingress
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "target_port", value)


if not MYPY:
    class SessionNetworkConfigurationArgsDict(TypedDict):
        """
        Session network configuration.
        """
        status: NotRequired[pulumi.Input[Union[builtins.str, 'SessionNetworkStatus']]]
        """
        Network status for the sessions.
        """
elif False:
    SessionNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionNetworkConfigurationArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[Union[builtins.str, 'SessionNetworkStatus']]] = None):
        """
        Session network configuration.
        :param pulumi.Input[Union[builtins.str, 'SessionNetworkStatus']] status: Network status for the sessions.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[Union[builtins.str, 'SessionNetworkStatus']]]:
        """
        Network status for the sessions.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[Union[builtins.str, 'SessionNetworkStatus']]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class SessionPoolSecretArgsDict(TypedDict):
        """
        Secret definition.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Secret Name.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Secret Value.
        """
elif False:
    SessionPoolSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionPoolSecretArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        Secret definition.
        :param pulumi.Input[builtins.str] name: Secret Name.
        :param pulumi.Input[builtins.str] value: Secret Value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Secret Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Secret Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SessionRegistryCredentialsArgsDict(TypedDict):
        """
        Session pool private registry credentials.
        """
        identity: NotRequired[pulumi.Input[builtins.str]]
        """
        A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        """
        password_secret_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the secret that contains the registry login password
        """
        server: NotRequired[pulumi.Input[builtins.str]]
        """
        Container registry server.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Container registry username.
        """
elif False:
    SessionRegistryCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionRegistryCredentialsArgs:
    def __init__(__self__, *,
                 identity: Optional[pulumi.Input[builtins.str]] = None,
                 password_secret_ref: Optional[pulumi.Input[builtins.str]] = None,
                 server: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        Session pool private registry credentials.
        :param pulumi.Input[builtins.str] identity: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        :param pulumi.Input[builtins.str] password_secret_ref: The name of the secret that contains the registry login password
        :param pulumi.Input[builtins.str] server: Container registry server.
        :param pulumi.Input[builtins.str] username: Container registry username.
        """
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if password_secret_ref is not None:
            pulumi.set(__self__, "password_secret_ref", password_secret_ref)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter(name="passwordSecretRef")
    def password_secret_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the secret that contains the registry login password
        """
        return pulumi.get(self, "password_secret_ref")

    @password_secret_ref.setter
    def password_secret_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password_secret_ref", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Container registry server.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Container registry username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class SpringBootAdminComponentArgsDict(TypedDict):
        """
        Spring Boot Admin properties.
        """
        component_type: pulumi.Input[builtins.str]
        """
        Type of the Java Component.
        Expected value is 'SpringBootAdmin'.
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgsDict']]]]
        """
        List of Java Components configuration properties
        """
        scale: NotRequired[pulumi.Input['JavaComponentPropertiesScaleArgsDict']]
        """
        Java component scaling configurations
        """
        service_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgsDict']]]]
        """
        List of Java Components that are bound to the Java component
        """
elif False:
    SpringBootAdminComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpringBootAdminComponentArgs:
    def __init__(__self__, *,
                 component_type: pulumi.Input[builtins.str],
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]] = None,
                 scale: Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']] = None,
                 service_binds: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]] = None):
        """
        Spring Boot Admin properties.
        :param pulumi.Input[builtins.str] component_type: Type of the Java Component.
               Expected value is 'SpringBootAdmin'.
        :param pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]] configurations: List of Java Components configuration properties
        :param pulumi.Input['JavaComponentPropertiesScaleArgs'] scale: Java component scaling configurations
        :param pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]] service_binds: List of Java Components that are bound to the Java component
        """
        pulumi.set(__self__, "component_type", 'SpringBootAdmin')
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if service_binds is not None:
            pulumi.set(__self__, "service_binds", service_binds)

    @property
    @pulumi.getter(name="componentType")
    def component_type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the Java Component.
        Expected value is 'SpringBootAdmin'.
        """
        return pulumi.get(self, "component_type")

    @component_type.setter
    def component_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "component_type", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]]:
        """
        List of Java Components configuration properties
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']]:
        """
        Java component scaling configurations
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']]):
        pulumi.set(self, "scale", value)

    @property
    @pulumi.getter(name="serviceBinds")
    def service_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]]:
        """
        List of Java Components that are bound to the Java component
        """
        return pulumi.get(self, "service_binds")

    @service_binds.setter
    def service_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]]):
        pulumi.set(self, "service_binds", value)


if not MYPY:
    class SpringCloudConfigComponentArgsDict(TypedDict):
        """
        Spring Cloud Config properties.
        """
        component_type: pulumi.Input[builtins.str]
        """
        Type of the Java Component.
        Expected value is 'SpringCloudConfig'.
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgsDict']]]]
        """
        List of Java Components configuration properties
        """
        scale: NotRequired[pulumi.Input['JavaComponentPropertiesScaleArgsDict']]
        """
        Java component scaling configurations
        """
        service_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgsDict']]]]
        """
        List of Java Components that are bound to the Java component
        """
elif False:
    SpringCloudConfigComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpringCloudConfigComponentArgs:
    def __init__(__self__, *,
                 component_type: pulumi.Input[builtins.str],
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]] = None,
                 scale: Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']] = None,
                 service_binds: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]] = None):
        """
        Spring Cloud Config properties.
        :param pulumi.Input[builtins.str] component_type: Type of the Java Component.
               Expected value is 'SpringCloudConfig'.
        :param pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]] configurations: List of Java Components configuration properties
        :param pulumi.Input['JavaComponentPropertiesScaleArgs'] scale: Java component scaling configurations
        :param pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]] service_binds: List of Java Components that are bound to the Java component
        """
        pulumi.set(__self__, "component_type", 'SpringCloudConfig')
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if service_binds is not None:
            pulumi.set(__self__, "service_binds", service_binds)

    @property
    @pulumi.getter(name="componentType")
    def component_type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the Java Component.
        Expected value is 'SpringCloudConfig'.
        """
        return pulumi.get(self, "component_type")

    @component_type.setter
    def component_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "component_type", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]]:
        """
        List of Java Components configuration properties
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']]:
        """
        Java component scaling configurations
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']]):
        pulumi.set(self, "scale", value)

    @property
    @pulumi.getter(name="serviceBinds")
    def service_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]]:
        """
        List of Java Components that are bound to the Java component
        """
        return pulumi.get(self, "service_binds")

    @service_binds.setter
    def service_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]]):
        pulumi.set(self, "service_binds", value)


if not MYPY:
    class SpringCloudEurekaComponentArgsDict(TypedDict):
        """
        Spring Cloud Eureka properties.
        """
        component_type: pulumi.Input[builtins.str]
        """
        Type of the Java Component.
        Expected value is 'SpringCloudEureka'.
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgsDict']]]]
        """
        List of Java Components configuration properties
        """
        scale: NotRequired[pulumi.Input['JavaComponentPropertiesScaleArgsDict']]
        """
        Java component scaling configurations
        """
        service_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgsDict']]]]
        """
        List of Java Components that are bound to the Java component
        """
elif False:
    SpringCloudEurekaComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpringCloudEurekaComponentArgs:
    def __init__(__self__, *,
                 component_type: pulumi.Input[builtins.str],
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]] = None,
                 scale: Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']] = None,
                 service_binds: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]] = None):
        """
        Spring Cloud Eureka properties.
        :param pulumi.Input[builtins.str] component_type: Type of the Java Component.
               Expected value is 'SpringCloudEureka'.
        :param pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]] configurations: List of Java Components configuration properties
        :param pulumi.Input['JavaComponentPropertiesScaleArgs'] scale: Java component scaling configurations
        :param pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]] service_binds: List of Java Components that are bound to the Java component
        """
        pulumi.set(__self__, "component_type", 'SpringCloudEureka')
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if service_binds is not None:
            pulumi.set(__self__, "service_binds", service_binds)

    @property
    @pulumi.getter(name="componentType")
    def component_type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the Java Component.
        Expected value is 'SpringCloudEureka'.
        """
        return pulumi.get(self, "component_type")

    @component_type.setter
    def component_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "component_type", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]]:
        """
        List of Java Components configuration properties
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']]:
        """
        Java component scaling configurations
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']]):
        pulumi.set(self, "scale", value)

    @property
    @pulumi.getter(name="serviceBinds")
    def service_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]]:
        """
        List of Java Components that are bound to the Java component
        """
        return pulumi.get(self, "service_binds")

    @service_binds.setter
    def service_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]]):
        pulumi.set(self, "service_binds", value)


if not MYPY:
    class SpringCloudGatewayComponentArgsDict(TypedDict):
        """
        Spring Cloud Gateway properties.
        """
        component_type: pulumi.Input[builtins.str]
        """
        Type of the Java Component.
        Expected value is 'SpringCloudGateway'.
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgsDict']]]]
        """
        List of Java Components configuration properties
        """
        scale: NotRequired[pulumi.Input['JavaComponentPropertiesScaleArgsDict']]
        """
        Java component scaling configurations
        """
        service_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgsDict']]]]
        """
        List of Java Components that are bound to the Java component
        """
        spring_cloud_gateway_routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScgRouteArgsDict']]]]
        """
        Gateway route definition
        """
elif False:
    SpringCloudGatewayComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpringCloudGatewayComponentArgs:
    def __init__(__self__, *,
                 component_type: pulumi.Input[builtins.str],
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]] = None,
                 scale: Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']] = None,
                 service_binds: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]] = None,
                 spring_cloud_gateway_routes: Optional[pulumi.Input[Sequence[pulumi.Input['ScgRouteArgs']]]] = None):
        """
        Spring Cloud Gateway properties.
        :param pulumi.Input[builtins.str] component_type: Type of the Java Component.
               Expected value is 'SpringCloudGateway'.
        :param pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]] configurations: List of Java Components configuration properties
        :param pulumi.Input['JavaComponentPropertiesScaleArgs'] scale: Java component scaling configurations
        :param pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]] service_binds: List of Java Components that are bound to the Java component
        :param pulumi.Input[Sequence[pulumi.Input['ScgRouteArgs']]] spring_cloud_gateway_routes: Gateway route definition
        """
        pulumi.set(__self__, "component_type", 'SpringCloudGateway')
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if service_binds is not None:
            pulumi.set(__self__, "service_binds", service_binds)
        if spring_cloud_gateway_routes is not None:
            pulumi.set(__self__, "spring_cloud_gateway_routes", spring_cloud_gateway_routes)

    @property
    @pulumi.getter(name="componentType")
    def component_type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the Java Component.
        Expected value is 'SpringCloudGateway'.
        """
        return pulumi.get(self, "component_type")

    @component_type.setter
    def component_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "component_type", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]]:
        """
        List of Java Components configuration properties
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentConfigurationPropertyArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']]:
        """
        Java component scaling configurations
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input['JavaComponentPropertiesScaleArgs']]):
        pulumi.set(self, "scale", value)

    @property
    @pulumi.getter(name="serviceBinds")
    def service_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]]:
        """
        List of Java Components that are bound to the Java component
        """
        return pulumi.get(self, "service_binds")

    @service_binds.setter
    def service_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JavaComponentServiceBindArgs']]]]):
        pulumi.set(self, "service_binds", value)

    @property
    @pulumi.getter(name="springCloudGatewayRoutes")
    def spring_cloud_gateway_routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScgRouteArgs']]]]:
        """
        Gateway route definition
        """
        return pulumi.get(self, "spring_cloud_gateway_routes")

    @spring_cloud_gateway_routes.setter
    def spring_cloud_gateway_routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScgRouteArgs']]]]):
        pulumi.set(self, "spring_cloud_gateway_routes", value)


if not MYPY:
    class TcpConnectionPoolArgsDict(TypedDict):
        """
        Defines parameters for tcp connection pooling
        """
        max_connections: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of tcp connections allowed
        """
elif False:
    TcpConnectionPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpConnectionPoolArgs:
    def __init__(__self__, *,
                 max_connections: Optional[pulumi.Input[builtins.int]] = None):
        """
        Defines parameters for tcp connection pooling
        :param pulumi.Input[builtins.int] max_connections: Maximum number of tcp connections allowed
        """
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of tcp connections allowed
        """
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_connections", value)


if not MYPY:
    class TcpRetryPolicyArgsDict(TypedDict):
        """
        Policy that defines tcp request retry conditions
        """
        max_connect_attempts: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of attempts to connect to the tcp service
        """
elif False:
    TcpRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpRetryPolicyArgs:
    def __init__(__self__, *,
                 max_connect_attempts: Optional[pulumi.Input[builtins.int]] = None):
        """
        Policy that defines tcp request retry conditions
        :param pulumi.Input[builtins.int] max_connect_attempts: Maximum number of attempts to connect to the tcp service
        """
        if max_connect_attempts is not None:
            pulumi.set(__self__, "max_connect_attempts", max_connect_attempts)

    @property
    @pulumi.getter(name="maxConnectAttempts")
    def max_connect_attempts(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of attempts to connect to the tcp service
        """
        return pulumi.get(self, "max_connect_attempts")

    @max_connect_attempts.setter
    def max_connect_attempts(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_connect_attempts", value)


if not MYPY:
    class TcpScaleRuleArgsDict(TypedDict):
        """
        Container App container Tcp scaling rule.
        """
        auth: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgsDict']]]]
        """
        Authentication secrets for the tcp scale rule.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Metadata properties to describe tcp scale rule.
        """
elif False:
    TcpScaleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TcpScaleRuleArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        Container App container Tcp scaling rule.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]] auth: Authentication secrets for the tcp scale rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] metadata: Metadata properties to describe tcp scale rule.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]:
        """
        Authentication secrets for the tcp scale rule.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Metadata properties to describe tcp scale rule.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class TemplateArgsDict(TypedDict):
        """
        Container App versioned application definition.
        Defines the desired state of an immutable revision.
        Any changes to this section Will result in a new revision being created
        """
        containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ContainerArgsDict']]]]
        """
        List of container definitions for the Container App.
        """
        init_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['InitContainerArgsDict']]]]
        """
        List of specialized containers that run before app containers.
        """
        revision_suffix: NotRequired[pulumi.Input[builtins.str]]
        """
        User friendly suffix that is appended to the revision name
        """
        scale: NotRequired[pulumi.Input['ScaleArgsDict']]
        """
        Scaling properties for the Container App.
        """
        service_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceBindArgsDict']]]]
        """
        List of container app services bound to the app
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[builtins.float]]
        """
        Optional duration in seconds the Container App Instance needs to terminate gracefully. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
        """
        volumes: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeArgsDict']]]]
        """
        List of volume definitions for the Container App.
        """
elif False:
    TemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateArgs:
    def __init__(__self__, *,
                 containers: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]]] = None,
                 init_containers: Optional[pulumi.Input[Sequence[pulumi.Input['InitContainerArgs']]]] = None,
                 revision_suffix: Optional[pulumi.Input[builtins.str]] = None,
                 scale: Optional[pulumi.Input['ScaleArgs']] = None,
                 service_binds: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceBindArgs']]]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[builtins.float]] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]]] = None):
        """
        Container App versioned application definition.
        Defines the desired state of an immutable revision.
        Any changes to this section Will result in a new revision being created
        :param pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]] containers: List of container definitions for the Container App.
        :param pulumi.Input[Sequence[pulumi.Input['InitContainerArgs']]] init_containers: List of specialized containers that run before app containers.
        :param pulumi.Input[builtins.str] revision_suffix: User friendly suffix that is appended to the revision name
        :param pulumi.Input['ScaleArgs'] scale: Scaling properties for the Container App.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceBindArgs']]] service_binds: List of container app services bound to the app
        :param pulumi.Input[builtins.float] termination_grace_period_seconds: Optional duration in seconds the Container App Instance needs to terminate gracefully. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
        :param pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]] volumes: List of volume definitions for the Container App.
        """
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if init_containers is not None:
            pulumi.set(__self__, "init_containers", init_containers)
        if revision_suffix is not None:
            pulumi.set(__self__, "revision_suffix", revision_suffix)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)
        if service_binds is not None:
            pulumi.set(__self__, "service_binds", service_binds)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]]]:
        """
        List of container definitions for the Container App.
        """
        return pulumi.get(self, "containers")

    @containers.setter
    def containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]]]):
        pulumi.set(self, "containers", value)

    @property
    @pulumi.getter(name="initContainers")
    def init_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InitContainerArgs']]]]:
        """
        List of specialized containers that run before app containers.
        """
        return pulumi.get(self, "init_containers")

    @init_containers.setter
    def init_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InitContainerArgs']]]]):
        pulumi.set(self, "init_containers", value)

    @property
    @pulumi.getter(name="revisionSuffix")
    def revision_suffix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User friendly suffix that is appended to the revision name
        """
        return pulumi.get(self, "revision_suffix")

    @revision_suffix.setter
    def revision_suffix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "revision_suffix", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input['ScaleArgs']]:
        """
        Scaling properties for the Container App.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input['ScaleArgs']]):
        pulumi.set(self, "scale", value)

    @property
    @pulumi.getter(name="serviceBinds")
    def service_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceBindArgs']]]]:
        """
        List of container app services bound to the app
        """
        return pulumi.get(self, "service_binds")

    @service_binds.setter
    def service_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceBindArgs']]]]):
        pulumi.set(self, "service_binds", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        Optional duration in seconds the Container App Instance needs to terminate gracefully. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "termination_grace_period_seconds", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]]]:
        """
        List of volume definitions for the Container App.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]]]):
        pulumi.set(self, "volumes", value)


if not MYPY:
    class TimeoutPolicyArgsDict(TypedDict):
        """
        Policy to set request timeouts
        """
        connection_timeout_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Timeout, in seconds, for a request to initiate a connection
        """
        response_timeout_in_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Timeout, in seconds, for a request to respond
        """
elif False:
    TimeoutPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TimeoutPolicyArgs:
    def __init__(__self__, *,
                 connection_timeout_in_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 response_timeout_in_seconds: Optional[pulumi.Input[builtins.int]] = None):
        """
        Policy to set request timeouts
        :param pulumi.Input[builtins.int] connection_timeout_in_seconds: Timeout, in seconds, for a request to initiate a connection
        :param pulumi.Input[builtins.int] response_timeout_in_seconds: Timeout, in seconds, for a request to respond
        """
        if connection_timeout_in_seconds is not None:
            pulumi.set(__self__, "connection_timeout_in_seconds", connection_timeout_in_seconds)
        if response_timeout_in_seconds is not None:
            pulumi.set(__self__, "response_timeout_in_seconds", response_timeout_in_seconds)

    @property
    @pulumi.getter(name="connectionTimeoutInSeconds")
    def connection_timeout_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Timeout, in seconds, for a request to initiate a connection
        """
        return pulumi.get(self, "connection_timeout_in_seconds")

    @connection_timeout_in_seconds.setter
    def connection_timeout_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "connection_timeout_in_seconds", value)

    @property
    @pulumi.getter(name="responseTimeoutInSeconds")
    def response_timeout_in_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Timeout, in seconds, for a request to respond
        """
        return pulumi.get(self, "response_timeout_in_seconds")

    @response_timeout_in_seconds.setter
    def response_timeout_in_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "response_timeout_in_seconds", value)


if not MYPY:
    class TokenStoreArgsDict(TypedDict):
        """
        The configuration settings of the token store.
        """
        azure_blob_storage: NotRequired[pulumi.Input['BlobStorageTokenStoreArgsDict']]
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
         The default is <code>false</code>.
        """
        token_refresh_extension_hours: NotRequired[pulumi.Input[builtins.float]]
        """
        The number of hours after session token expiration that a session token can be used to
        call the token refresh API. The default is 72 hours.
        """
elif False:
    TokenStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TokenStoreArgs:
    def __init__(__self__, *,
                 azure_blob_storage: Optional[pulumi.Input['BlobStorageTokenStoreArgs']] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 token_refresh_extension_hours: Optional[pulumi.Input[builtins.float]] = None):
        """
        The configuration settings of the token store.
        :param pulumi.Input['BlobStorageTokenStoreArgs'] azure_blob_storage: The configuration settings of the storage of the tokens if blob storage is used.
        :param pulumi.Input[builtins.bool] enabled: <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
                The default is <code>false</code>.
        :param pulumi.Input[builtins.float] token_refresh_extension_hours: The number of hours after session token expiration that a session token can be used to
               call the token refresh API. The default is 72 hours.
        """
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if token_refresh_extension_hours is not None:
            pulumi.set(__self__, "token_refresh_extension_hours", token_refresh_extension_hours)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['BlobStorageTokenStoreArgs']]:
        """
        The configuration settings of the storage of the tokens if blob storage is used.
        """
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['BlobStorageTokenStoreArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
         The default is <code>false</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="tokenRefreshExtensionHours")
    def token_refresh_extension_hours(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        The number of hours after session token expiration that a session token can be used to
        call the token refresh API. The default is 72 hours.
        """
        return pulumi.get(self, "token_refresh_extension_hours")

    @token_refresh_extension_hours.setter
    def token_refresh_extension_hours(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "token_refresh_extension_hours", value)


if not MYPY:
    class TrafficWeightArgsDict(TypedDict):
        """
        Traffic weight assigned to a revision
        """
        label: NotRequired[pulumi.Input[builtins.str]]
        """
        Associates a traffic label with a revision
        """
        latest_revision: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates that the traffic weight belongs to a latest stable revision
        """
        revision_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of a revision
        """
        weight: NotRequired[pulumi.Input[builtins.int]]
        """
        Traffic weight assigned to a revision
        """
elif False:
    TrafficWeightArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficWeightArgs:
    def __init__(__self__, *,
                 label: Optional[pulumi.Input[builtins.str]] = None,
                 latest_revision: Optional[pulumi.Input[builtins.bool]] = None,
                 revision_name: Optional[pulumi.Input[builtins.str]] = None,
                 weight: Optional[pulumi.Input[builtins.int]] = None):
        """
        Traffic weight assigned to a revision
        :param pulumi.Input[builtins.str] label: Associates a traffic label with a revision
        :param pulumi.Input[builtins.bool] latest_revision: Indicates that the traffic weight belongs to a latest stable revision
        :param pulumi.Input[builtins.str] revision_name: Name of a revision
        :param pulumi.Input[builtins.int] weight: Traffic weight assigned to a revision
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if latest_revision is None:
            latest_revision = False
        if latest_revision is not None:
            pulumi.set(__self__, "latest_revision", latest_revision)
        if revision_name is not None:
            pulumi.set(__self__, "revision_name", revision_name)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Associates a traffic label with a revision
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="latestRevision")
    def latest_revision(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates that the traffic weight belongs to a latest stable revision
        """
        return pulumi.get(self, "latest_revision")

    @latest_revision.setter
    def latest_revision(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "latest_revision", value)

    @property
    @pulumi.getter(name="revisionName")
    def revision_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of a revision
        """
        return pulumi.get(self, "revision_name")

    @revision_name.setter
    def revision_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "revision_name", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Traffic weight assigned to a revision
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class TwitterRegistrationArgsDict(TypedDict):
        """
        The configuration settings of the app registration for the Twitter provider.
        """
        consumer_key: NotRequired[pulumi.Input[builtins.str]]
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        This setting is required for enabling Twitter Sign-In.
        Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        """
        consumer_secret_setting_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
        application used for sign-in.
        """
elif False:
    TwitterRegistrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwitterRegistrationArgs:
    def __init__(__self__, *,
                 consumer_key: Optional[pulumi.Input[builtins.str]] = None,
                 consumer_secret_setting_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        The configuration settings of the app registration for the Twitter provider.
        :param pulumi.Input[builtins.str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
               This setting is required for enabling Twitter Sign-In.
               Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        :param pulumi.Input[builtins.str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
               application used for sign-in.
        """
        if consumer_key is not None:
            pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret_setting_name is not None:
            pulumi.set(__self__, "consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        This setting is required for enabling Twitter Sign-In.
        Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
        application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "consumer_secret_setting_name", value)


if not MYPY:
    class TwitterArgsDict(TypedDict):
        """
        The configuration settings of the Twitter provider.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        registration: NotRequired[pulumi.Input['TwitterRegistrationArgsDict']]
        """
        The configuration settings of the app registration for the Twitter provider.
        """
elif False:
    TwitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TwitterArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 registration: Optional[pulumi.Input['TwitterRegistrationArgs']] = None):
        """
        The configuration settings of the Twitter provider.
        :param pulumi.Input[builtins.bool] enabled: <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['TwitterRegistrationArgs'] registration: The configuration settings of the app registration for the Twitter provider.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if registration is not None:
            pulumi.set(__self__, "registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['TwitterRegistrationArgs']]:
        """
        The configuration settings of the app registration for the Twitter provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['TwitterRegistrationArgs']]):
        pulumi.set(self, "registration", value)


if not MYPY:
    class VnetConfigurationArgsDict(TypedDict):
        """
        Configuration properties for apps environment to join a Virtual Network
        """
        docker_bridge_cidr: NotRequired[pulumi.Input[builtins.str]]
        """
        CIDR notation IP range assigned to the Docker bridge, network. Must not overlap with any other provided IP ranges.
        """
        infrastructure_subnet_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource ID of a subnet for infrastructure components. Must not overlap with any other provided IP ranges.
        """
        internal: NotRequired[pulumi.Input[builtins.bool]]
        """
        Boolean indicating the environment only has an internal load balancer. These environments do not have a public static IP resource. They must provide infrastructureSubnetId if enabling this property
        """
        platform_reserved_cidr: NotRequired[pulumi.Input[builtins.str]]
        """
        IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. Must not overlap with any other provided IP ranges.
        """
        platform_reserved_dns_ip: NotRequired[pulumi.Input[builtins.str]]
        """
         An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server.
        """
elif False:
    VnetConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VnetConfigurationArgs:
    def __init__(__self__, *,
                 docker_bridge_cidr: Optional[pulumi.Input[builtins.str]] = None,
                 infrastructure_subnet_id: Optional[pulumi.Input[builtins.str]] = None,
                 internal: Optional[pulumi.Input[builtins.bool]] = None,
                 platform_reserved_cidr: Optional[pulumi.Input[builtins.str]] = None,
                 platform_reserved_dns_ip: Optional[pulumi.Input[builtins.str]] = None):
        """
        Configuration properties for apps environment to join a Virtual Network
        :param pulumi.Input[builtins.str] docker_bridge_cidr: CIDR notation IP range assigned to the Docker bridge, network. Must not overlap with any other provided IP ranges.
        :param pulumi.Input[builtins.str] infrastructure_subnet_id: Resource ID of a subnet for infrastructure components. Must not overlap with any other provided IP ranges.
        :param pulumi.Input[builtins.bool] internal: Boolean indicating the environment only has an internal load balancer. These environments do not have a public static IP resource. They must provide infrastructureSubnetId if enabling this property
        :param pulumi.Input[builtins.str] platform_reserved_cidr: IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. Must not overlap with any other provided IP ranges.
        :param pulumi.Input[builtins.str] platform_reserved_dns_ip:  An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server.
        """
        if docker_bridge_cidr is not None:
            pulumi.set(__self__, "docker_bridge_cidr", docker_bridge_cidr)
        if infrastructure_subnet_id is not None:
            pulumi.set(__self__, "infrastructure_subnet_id", infrastructure_subnet_id)
        if internal is not None:
            pulumi.set(__self__, "internal", internal)
        if platform_reserved_cidr is not None:
            pulumi.set(__self__, "platform_reserved_cidr", platform_reserved_cidr)
        if platform_reserved_dns_ip is not None:
            pulumi.set(__self__, "platform_reserved_dns_ip", platform_reserved_dns_ip)

    @property
    @pulumi.getter(name="dockerBridgeCidr")
    def docker_bridge_cidr(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        CIDR notation IP range assigned to the Docker bridge, network. Must not overlap with any other provided IP ranges.
        """
        return pulumi.get(self, "docker_bridge_cidr")

    @docker_bridge_cidr.setter
    def docker_bridge_cidr(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "docker_bridge_cidr", value)

    @property
    @pulumi.getter(name="infrastructureSubnetId")
    def infrastructure_subnet_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource ID of a subnet for infrastructure components. Must not overlap with any other provided IP ranges.
        """
        return pulumi.get(self, "infrastructure_subnet_id")

    @infrastructure_subnet_id.setter
    def infrastructure_subnet_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "infrastructure_subnet_id", value)

    @property
    @pulumi.getter
    def internal(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Boolean indicating the environment only has an internal load balancer. These environments do not have a public static IP resource. They must provide infrastructureSubnetId if enabling this property
        """
        return pulumi.get(self, "internal")

    @internal.setter
    def internal(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "internal", value)

    @property
    @pulumi.getter(name="platformReservedCidr")
    def platform_reserved_cidr(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. Must not overlap with any other provided IP ranges.
        """
        return pulumi.get(self, "platform_reserved_cidr")

    @platform_reserved_cidr.setter
    def platform_reserved_cidr(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "platform_reserved_cidr", value)

    @property
    @pulumi.getter(name="platformReservedDnsIP")
    def platform_reserved_dns_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
         An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server.
        """
        return pulumi.get(self, "platform_reserved_dns_ip")

    @platform_reserved_dns_ip.setter
    def platform_reserved_dns_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "platform_reserved_dns_ip", value)


if not MYPY:
    class VolumeMountArgsDict(TypedDict):
        """
        Volume mount for the Container App.
        """
        mount_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path within the container at which the volume should be mounted.Must not contain ':'.
        """
        sub_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        volume_name: NotRequired[pulumi.Input[builtins.str]]
        """
        This must match the Name of a Volume.
        """
elif False:
    VolumeMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeMountArgs:
    def __init__(__self__, *,
                 mount_path: Optional[pulumi.Input[builtins.str]] = None,
                 sub_path: Optional[pulumi.Input[builtins.str]] = None,
                 volume_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        Volume mount for the Container App.
        :param pulumi.Input[builtins.str] mount_path: Path within the container at which the volume should be mounted.Must not contain ':'.
        :param pulumi.Input[builtins.str] sub_path: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        :param pulumi.Input[builtins.str] volume_name: This must match the Name of a Volume.
        """
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path within the container at which the volume should be mounted.Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        """
        return pulumi.get(self, "sub_path")

    @sub_path.setter
    def sub_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sub_path", value)

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "volume_name")

    @volume_name.setter
    def volume_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "volume_name", value)


if not MYPY:
    class VolumeArgsDict(TypedDict):
        """
        Volume definitions for the Container App.
        """
        mount_options: NotRequired[pulumi.Input[builtins.str]]
        """
        Mount options used while mounting the AzureFile. Must be a comma-separated string.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Volume name.
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecretVolumeItemArgsDict']]]]
        """
        List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
        """
        storage_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of storage resource. No need to provide for EmptyDir and Secret.
        """
        storage_type: NotRequired[pulumi.Input[Union[builtins.str, 'StorageType']]]
        """
        Storage type for the volume. If not provided, use EmptyDir.
        """
elif False:
    VolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeArgs:
    def __init__(__self__, *,
                 mount_options: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['SecretVolumeItemArgs']]]] = None,
                 storage_name: Optional[pulumi.Input[builtins.str]] = None,
                 storage_type: Optional[pulumi.Input[Union[builtins.str, 'StorageType']]] = None):
        """
        Volume definitions for the Container App.
        :param pulumi.Input[builtins.str] mount_options: Mount options used while mounting the AzureFile. Must be a comma-separated string.
        :param pulumi.Input[builtins.str] name: Volume name.
        :param pulumi.Input[Sequence[pulumi.Input['SecretVolumeItemArgs']]] secrets: List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
        :param pulumi.Input[builtins.str] storage_name: Name of storage resource. No need to provide for EmptyDir and Secret.
        :param pulumi.Input[Union[builtins.str, 'StorageType']] storage_type: Storage type for the volume. If not provided, use EmptyDir.
        """
        if mount_options is not None:
            pulumi.set(__self__, "mount_options", mount_options)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if storage_name is not None:
            pulumi.set(__self__, "storage_name", storage_name)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @property
    @pulumi.getter(name="mountOptions")
    def mount_options(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Mount options used while mounting the AzureFile. Must be a comma-separated string.
        """
        return pulumi.get(self, "mount_options")

    @mount_options.setter
    def mount_options(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mount_options", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Volume name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecretVolumeItemArgs']]]]:
        """
        List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecretVolumeItemArgs']]]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter(name="storageName")
    def storage_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of storage resource. No need to provide for EmptyDir and Secret.
        """
        return pulumi.get(self, "storage_name")

    @storage_name.setter
    def storage_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "storage_name", value)

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[Union[builtins.str, 'StorageType']]]:
        """
        Storage type for the volume. If not provided, use EmptyDir.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[Union[builtins.str, 'StorageType']]]):
        pulumi.set(self, "storage_type", value)


if not MYPY:
    class WorkloadProfileArgsDict(TypedDict):
        """
        Workload profile to scope container app execution.
        """
        name: pulumi.Input[builtins.str]
        """
        Workload profile type for the workloads to run on.
        """
        workload_profile_type: pulumi.Input[builtins.str]
        """
        Workload profile type for the workloads to run on.
        """
        maximum_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum capacity.
        """
        minimum_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The minimum capacity.
        """
elif False:
    WorkloadProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadProfileArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 workload_profile_type: pulumi.Input[builtins.str],
                 maximum_count: Optional[pulumi.Input[builtins.int]] = None,
                 minimum_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        Workload profile to scope container app execution.
        :param pulumi.Input[builtins.str] name: Workload profile type for the workloads to run on.
        :param pulumi.Input[builtins.str] workload_profile_type: Workload profile type for the workloads to run on.
        :param pulumi.Input[builtins.int] maximum_count: The maximum capacity.
        :param pulumi.Input[builtins.int] minimum_count: The minimum capacity.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "workload_profile_type", workload_profile_type)
        if maximum_count is not None:
            pulumi.set(__self__, "maximum_count", maximum_count)
        if minimum_count is not None:
            pulumi.set(__self__, "minimum_count", minimum_count)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Workload profile type for the workloads to run on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="workloadProfileType")
    def workload_profile_type(self) -> pulumi.Input[builtins.str]:
        """
        Workload profile type for the workloads to run on.
        """
        return pulumi.get(self, "workload_profile_type")

    @workload_profile_type.setter
    def workload_profile_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "workload_profile_type", value)

    @property
    @pulumi.getter(name="maximumCount")
    def maximum_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum capacity.
        """
        return pulumi.get(self, "maximum_count")

    @maximum_count.setter
    def maximum_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "maximum_count", value)

    @property
    @pulumi.getter(name="minimumCount")
    def minimum_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The minimum capacity.
        """
        return pulumi.get(self, "minimum_count")

    @minimum_count.setter
    def minimum_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "minimum_count", value)


