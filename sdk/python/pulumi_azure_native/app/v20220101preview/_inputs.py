# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from ._enums import *

__all__ = [
    'AllowedAudiencesValidationArgs',
    'AllowedPrincipalsArgs',
    'AppLogsConfigurationArgs',
    'AppRegistrationArgs',
    'AppleRegistrationArgs',
    'AppleArgs',
    'AuthPlatformArgs',
    'AzureActiveDirectoryLoginArgs',
    'AzureActiveDirectoryRegistrationArgs',
    'AzureActiveDirectoryValidationArgs',
    'AzureActiveDirectoryArgs',
    'AzureCredentialsArgs',
    'AzureFilePropertiesArgs',
    'AzureStaticWebAppsRegistrationArgs',
    'AzureStaticWebAppsArgs',
    'CertificatePropertiesArgs',
    'ClientRegistrationArgs',
    'ConfigurationArgs',
    'ContainerAppProbeHttpGetArgs',
    'ContainerAppProbeHttpHeadersArgs',
    'ContainerAppProbeTcpSocketArgs',
    'ContainerAppProbeArgs',
    'ContainerResourcesArgs',
    'ContainerArgs',
    'CookieExpirationArgs',
    'CustomDomainArgs',
    'CustomOpenIdConnectProviderArgs',
    'CustomScaleRuleArgs',
    'DaprMetadataArgs',
    'DaprArgs',
    'DefaultAuthorizationPolicyArgs',
    'EnvironmentVarArgs',
    'FacebookArgs',
    'ForwardProxyArgs',
    'GitHubArgs',
    'GithubActionConfigurationArgs',
    'GlobalValidationArgs',
    'GoogleArgs',
    'HttpScaleRuleArgs',
    'HttpSettingsRoutesArgs',
    'HttpSettingsArgs',
    'IdentityProvidersArgs',
    'IngressArgs',
    'JwtClaimChecksArgs',
    'LogAnalyticsConfigurationArgs',
    'LoginRoutesArgs',
    'LoginScopesArgs',
    'LoginArgs',
    'ManagedEnvironmentStoragePropertiesArgs',
    'ManagedServiceIdentityArgs',
    'NonceArgs',
    'OpenIdConnectClientCredentialArgs',
    'OpenIdConnectConfigArgs',
    'OpenIdConnectLoginArgs',
    'OpenIdConnectRegistrationArgs',
    'QueueScaleRuleArgs',
    'RegistryCredentialsArgs',
    'RegistryInfoArgs',
    'ScaleRuleAuthArgs',
    'ScaleRuleArgs',
    'ScaleArgs',
    'SecretArgs',
    'TemplateArgs',
    'TrafficWeightArgs',
    'TwitterRegistrationArgs',
    'TwitterArgs',
    'VnetConfigurationArgs',
    'VolumeMountArgs',
    'VolumeArgs',
]

@pulumi.input_type
class AllowedAudiencesValidationArgs:
    def __init__(__self__, *,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The configuration settings of the Allowed Audiences validation flow.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
        AllowedAudiencesValidationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_audiences=allowed_audiences,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedAudiences' in kwargs:
            allowed_audiences = kwargs['allowedAudiences']

        if allowed_audiences is not None:
            _setter("allowed_audiences", allowed_audiences)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The configuration settings of the allowed list of audiences from which to validate the JWT token.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)


@pulumi.input_type
class AllowedPrincipalsArgs:
    def __init__(__self__, *,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The configuration settings of the Azure Active Directory allowed principals.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups: The list of the allowed groups.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] identities: The list of the allowed identities.
        """
        AllowedPrincipalsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            groups=groups,
            identities=identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if groups is not None:
            _setter("groups", groups)
        if identities is not None:
            _setter("identities", identities)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the allowed groups.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the allowed identities.
        """
        return pulumi.get(self, "identities")

    @identities.setter
    def identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "identities", value)


@pulumi.input_type
class AppLogsConfigurationArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[str]] = None,
                 log_analytics_configuration: Optional[pulumi.Input['LogAnalyticsConfigurationArgs']] = None):
        """
        Configuration of application logs
        :param pulumi.Input[str] destination: Logs destination, can be 'log-analytics', 'azure-monitor' or 'none'
        :param pulumi.Input['LogAnalyticsConfigurationArgs'] log_analytics_configuration: Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
        """
        AppLogsConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            log_analytics_configuration=log_analytics_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: Optional[pulumi.Input[str]] = None,
             log_analytics_configuration: Optional[pulumi.Input['LogAnalyticsConfigurationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'logAnalyticsConfiguration' in kwargs:
            log_analytics_configuration = kwargs['logAnalyticsConfiguration']

        if destination is not None:
            _setter("destination", destination)
        if log_analytics_configuration is not None:
            _setter("log_analytics_configuration", log_analytics_configuration)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        """
        Logs destination, can be 'log-analytics', 'azure-monitor' or 'none'
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="logAnalyticsConfiguration")
    def log_analytics_configuration(self) -> Optional[pulumi.Input['LogAnalyticsConfigurationArgs']]:
        """
        Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
        """
        return pulumi.get(self, "log_analytics_configuration")

    @log_analytics_configuration.setter
    def log_analytics_configuration(self, value: Optional[pulumi.Input['LogAnalyticsConfigurationArgs']]):
        pulumi.set(self, "log_analytics_configuration", value)


@pulumi.input_type
class AppRegistrationArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[str]] = None,
                 app_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        The configuration settings of the app registration for providers that have app ids and app secrets
        :param pulumi.Input[str] app_id: The App ID of the app used for login.
        :param pulumi.Input[str] app_secret_setting_name: The app setting name that contains the app secret.
        """
        AppRegistrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_id=app_id,
            app_secret_setting_name=app_secret_setting_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_id: Optional[pulumi.Input[str]] = None,
             app_secret_setting_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'appId' in kwargs:
            app_id = kwargs['appId']
        if 'appSecretSettingName' in kwargs:
            app_secret_setting_name = kwargs['appSecretSettingName']

        if app_id is not None:
            _setter("app_id", app_id)
        if app_secret_setting_name is not None:
            _setter("app_secret_setting_name", app_secret_setting_name)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[str]]:
        """
        The App ID of the app used for login.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appSecretSettingName")
    def app_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the app secret.
        """
        return pulumi.get(self, "app_secret_setting_name")

    @app_secret_setting_name.setter
    def app_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_secret_setting_name", value)


@pulumi.input_type
class AppleRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        The configuration settings of the registration for the Apple provider
        :param pulumi.Input[str] client_id: The Client ID of the app used for login.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the client secret.
        """
        AppleRegistrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret_setting_name=client_secret_setting_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[pulumi.Input[str]] = None,
             client_secret_setting_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if 'clientSecretSettingName' in kwargs:
            client_secret_setting_name = kwargs['clientSecretSettingName']

        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret_setting_name is not None:
            _setter("client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the client secret.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)


@pulumi.input_type
class AppleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['AppleRegistrationArgs']] = None):
        """
        The configuration settings of the Apple provider.
        :param pulumi.Input[bool] enabled: <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['LoginScopesArgs'] login: The configuration settings of the login flow.
        :param pulumi.Input['AppleRegistrationArgs'] registration: The configuration settings of the Apple registration.
        """
        AppleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            login=login,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             login: Optional[pulumi.Input['LoginScopesArgs']] = None,
             registration: Optional[pulumi.Input['AppleRegistrationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AppleRegistrationArgs']]:
        """
        The configuration settings of the Apple registration.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AppleRegistrationArgs']]):
        pulumi.set(self, "registration", value)


@pulumi.input_type
class AuthPlatformArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None):
        """
        The configuration settings of the platform of ContainerApp Service Authentication/Authorization.
        :param pulumi.Input[bool] enabled: <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        :param pulumi.Input[str] runtime_version: The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
               The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
        AuthPlatformArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            runtime_version=runtime_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             runtime_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'runtimeVersion' in kwargs:
            runtime_version = kwargs['runtimeVersion']

        if enabled is not None:
            _setter("enabled", enabled)
        if runtime_version is not None:
            _setter("runtime_version", runtime_version)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)


@pulumi.input_type
class AzureActiveDirectoryLoginArgs:
    def __init__(__self__, *,
                 disable_www_authenticate: Optional[pulumi.Input[bool]] = None,
                 login_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The configuration settings of the Azure Active Directory login flow.
        :param pulumi.Input[bool] disable_www_authenticate: <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] login_parameters: Login parameters to send to the OpenID Connect authorization endpoint when
               a user logs in. Each parameter must be in the form "key=value".
        """
        AzureActiveDirectoryLoginArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            disable_www_authenticate=disable_www_authenticate,
            login_parameters=login_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             disable_www_authenticate: Optional[pulumi.Input[bool]] = None,
             login_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'disableWWWAuthenticate' in kwargs:
            disable_www_authenticate = kwargs['disableWWWAuthenticate']
        if 'loginParameters' in kwargs:
            login_parameters = kwargs['loginParameters']

        if disable_www_authenticate is not None:
            _setter("disable_www_authenticate", disable_www_authenticate)
        if login_parameters is not None:
            _setter("login_parameters", login_parameters)

    @property
    @pulumi.getter(name="disableWWWAuthenticate")
    def disable_www_authenticate(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "disable_www_authenticate")

    @disable_www_authenticate.setter
    def disable_www_authenticate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_www_authenticate", value)

    @property
    @pulumi.getter(name="loginParameters")
    def login_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Login parameters to send to the OpenID Connect authorization endpoint when
        a user logs in. Each parameter must be in the form "key=value".
        """
        return pulumi.get(self, "login_parameters")

    @login_parameters.setter
    def login_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "login_parameters", value)


@pulumi.input_type
class AzureActiveDirectoryRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret_certificate_issuer: Optional[pulumi.Input[str]] = None,
                 client_secret_certificate_subject_alternative_name: Optional[pulumi.Input[str]] = None,
                 client_secret_certificate_thumbprint: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 open_id_issuer: Optional[pulumi.Input[str]] = None):
        """
        The configuration settings of the Azure Active Directory app registration.
        :param pulumi.Input[str] client_id: The Client ID of this relying party application, known as the client_id.
               This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
               other 3rd party OpenID Connect providers.
               More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        :param pulumi.Input[str] client_secret_certificate_issuer: An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        :param pulumi.Input[str] client_secret_certificate_subject_alternative_name: An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        :param pulumi.Input[str] client_secret_certificate_thumbprint: An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
               a replacement for the Client Secret. It is also optional.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the client secret of the relying party application.
        :param pulumi.Input[str] open_id_issuer: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
               When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://login.microsoftonline.com/v2.0/{tenant-guid}/.
               This URI is a case-sensitive identifier for the token issuer.
               More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
        AzureActiveDirectoryRegistrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret_certificate_issuer=client_secret_certificate_issuer,
            client_secret_certificate_subject_alternative_name=client_secret_certificate_subject_alternative_name,
            client_secret_certificate_thumbprint=client_secret_certificate_thumbprint,
            client_secret_setting_name=client_secret_setting_name,
            open_id_issuer=open_id_issuer,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[pulumi.Input[str]] = None,
             client_secret_certificate_issuer: Optional[pulumi.Input[str]] = None,
             client_secret_certificate_subject_alternative_name: Optional[pulumi.Input[str]] = None,
             client_secret_certificate_thumbprint: Optional[pulumi.Input[str]] = None,
             client_secret_setting_name: Optional[pulumi.Input[str]] = None,
             open_id_issuer: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if 'clientSecretCertificateIssuer' in kwargs:
            client_secret_certificate_issuer = kwargs['clientSecretCertificateIssuer']
        if 'clientSecretCertificateSubjectAlternativeName' in kwargs:
            client_secret_certificate_subject_alternative_name = kwargs['clientSecretCertificateSubjectAlternativeName']
        if 'clientSecretCertificateThumbprint' in kwargs:
            client_secret_certificate_thumbprint = kwargs['clientSecretCertificateThumbprint']
        if 'clientSecretSettingName' in kwargs:
            client_secret_setting_name = kwargs['clientSecretSettingName']
        if 'openIdIssuer' in kwargs:
            open_id_issuer = kwargs['openIdIssuer']

        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret_certificate_issuer is not None:
            _setter("client_secret_certificate_issuer", client_secret_certificate_issuer)
        if client_secret_certificate_subject_alternative_name is not None:
            _setter("client_secret_certificate_subject_alternative_name", client_secret_certificate_subject_alternative_name)
        if client_secret_certificate_thumbprint is not None:
            _setter("client_secret_certificate_thumbprint", client_secret_certificate_thumbprint)
        if client_secret_setting_name is not None:
            _setter("client_secret_setting_name", client_secret_setting_name)
        if open_id_issuer is not None:
            _setter("open_id_issuer", open_id_issuer)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of this relying party application, known as the client_id.
        This setting is required for enabling OpenID Connection authentication with Azure Active Directory or 
        other 3rd party OpenID Connect providers.
        More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretCertificateIssuer")
    def client_secret_certificate_issuer(self) -> Optional[pulumi.Input[str]]:
        """
        An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_issuer")

    @client_secret_certificate_issuer.setter
    def client_secret_certificate_issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_certificate_issuer", value)

    @property
    @pulumi.getter(name="clientSecretCertificateSubjectAlternativeName")
    def client_secret_certificate_subject_alternative_name(self) -> Optional[pulumi.Input[str]]:
        """
        An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret Certificate Thumbprint. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_subject_alternative_name")

    @client_secret_certificate_subject_alternative_name.setter
    def client_secret_certificate_subject_alternative_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_certificate_subject_alternative_name", value)

    @property
    @pulumi.getter(name="clientSecretCertificateThumbprint")
    def client_secret_certificate_thumbprint(self) -> Optional[pulumi.Input[str]]:
        """
        An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as
        a replacement for the Client Secret. It is also optional.
        """
        return pulumi.get(self, "client_secret_certificate_thumbprint")

    @client_secret_certificate_thumbprint.setter
    def client_secret_certificate_thumbprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_certificate_thumbprint", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the client secret of the relying party application.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter(name="openIdIssuer")
    def open_id_issuer(self) -> Optional[pulumi.Input[str]]:
        """
        The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
        When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://login.microsoftonline.com/v2.0/{tenant-guid}/.
        This URI is a case-sensitive identifier for the token issuer.
        More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
        """
        return pulumi.get(self, "open_id_issuer")

    @open_id_issuer.setter
    def open_id_issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "open_id_issuer", value)


@pulumi.input_type
class AzureActiveDirectoryValidationArgs:
    def __init__(__self__, *,
                 allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 default_authorization_policy: Optional[pulumi.Input['DefaultAuthorizationPolicyArgs']] = None,
                 jwt_claim_checks: Optional[pulumi.Input['JwtClaimChecksArgs']] = None):
        """
        The configuration settings of the Azure Active Directory token validation flow.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_audiences: The list of audiences that can make successful authentication/authorization requests.
        :param pulumi.Input['DefaultAuthorizationPolicyArgs'] default_authorization_policy: The configuration settings of the default authorization policy.
        :param pulumi.Input['JwtClaimChecksArgs'] jwt_claim_checks: The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        AzureActiveDirectoryValidationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_audiences=allowed_audiences,
            default_authorization_policy=default_authorization_policy,
            jwt_claim_checks=jwt_claim_checks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             default_authorization_policy: Optional[pulumi.Input['DefaultAuthorizationPolicyArgs']] = None,
             jwt_claim_checks: Optional[pulumi.Input['JwtClaimChecksArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedAudiences' in kwargs:
            allowed_audiences = kwargs['allowedAudiences']
        if 'defaultAuthorizationPolicy' in kwargs:
            default_authorization_policy = kwargs['defaultAuthorizationPolicy']
        if 'jwtClaimChecks' in kwargs:
            jwt_claim_checks = kwargs['jwtClaimChecks']

        if allowed_audiences is not None:
            _setter("allowed_audiences", allowed_audiences)
        if default_authorization_policy is not None:
            _setter("default_authorization_policy", default_authorization_policy)
        if jwt_claim_checks is not None:
            _setter("jwt_claim_checks", jwt_claim_checks)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of audiences that can make successful authentication/authorization requests.
        """
        return pulumi.get(self, "allowed_audiences")

    @allowed_audiences.setter
    def allowed_audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_audiences", value)

    @property
    @pulumi.getter(name="defaultAuthorizationPolicy")
    def default_authorization_policy(self) -> Optional[pulumi.Input['DefaultAuthorizationPolicyArgs']]:
        """
        The configuration settings of the default authorization policy.
        """
        return pulumi.get(self, "default_authorization_policy")

    @default_authorization_policy.setter
    def default_authorization_policy(self, value: Optional[pulumi.Input['DefaultAuthorizationPolicyArgs']]):
        pulumi.set(self, "default_authorization_policy", value)

    @property
    @pulumi.getter(name="jwtClaimChecks")
    def jwt_claim_checks(self) -> Optional[pulumi.Input['JwtClaimChecksArgs']]:
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        """
        return pulumi.get(self, "jwt_claim_checks")

    @jwt_claim_checks.setter
    def jwt_claim_checks(self, value: Optional[pulumi.Input['JwtClaimChecksArgs']]):
        pulumi.set(self, "jwt_claim_checks", value)


@pulumi.input_type
class AzureActiveDirectoryArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 is_auto_provisioned: Optional[pulumi.Input[bool]] = None,
                 login: Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']] = None,
                 registration: Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']] = None,
                 validation: Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']] = None):
        """
        The configuration settings of the Azure Active directory provider.
        :param pulumi.Input[bool] enabled: <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input[bool] is_auto_provisioned: Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
               This is an internal flag primarily intended to support the Azure Management Portal. Users should not
               read or write to this property.
        :param pulumi.Input['AzureActiveDirectoryLoginArgs'] login: The configuration settings of the Azure Active Directory login flow.
        :param pulumi.Input['AzureActiveDirectoryRegistrationArgs'] registration: The configuration settings of the Azure Active Directory app registration.
        :param pulumi.Input['AzureActiveDirectoryValidationArgs'] validation: The configuration settings of the Azure Active Directory token validation flow.
        """
        AzureActiveDirectoryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            is_auto_provisioned=is_auto_provisioned,
            login=login,
            registration=registration,
            validation=validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             is_auto_provisioned: Optional[pulumi.Input[bool]] = None,
             login: Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']] = None,
             registration: Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']] = None,
             validation: Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isAutoProvisioned' in kwargs:
            is_auto_provisioned = kwargs['isAutoProvisioned']

        if enabled is not None:
            _setter("enabled", enabled)
        if is_auto_provisioned is not None:
            _setter("is_auto_provisioned", is_auto_provisioned)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)
        if validation is not None:
            _setter("validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="isAutoProvisioned")
    def is_auto_provisioned(self) -> Optional[pulumi.Input[bool]]:
        """
        Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
        This is an internal flag primarily intended to support the Azure Management Portal. Users should not
        read or write to this property.
        """
        return pulumi.get(self, "is_auto_provisioned")

    @is_auto_provisioned.setter
    def is_auto_provisioned(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_auto_provisioned", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']]:
        """
        The configuration settings of the Azure Active Directory login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['AzureActiveDirectoryLoginArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']]:
        """
        The configuration settings of the Azure Active Directory app registration.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AzureActiveDirectoryRegistrationArgs']]):
        pulumi.set(self, "registration", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']]:
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input['AzureActiveDirectoryValidationArgs']]):
        pulumi.set(self, "validation", value)


@pulumi.input_type
class AzureCredentialsArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 subscription_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        Container App credentials.
        :param pulumi.Input[str] client_id: Client Id.
        :param pulumi.Input[str] client_secret: Client Secret.
        :param pulumi.Input[str] subscription_id: Subscription Id.
        :param pulumi.Input[str] tenant_id: Tenant Id.
        """
        AzureCredentialsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret=client_secret,
            subscription_id=subscription_id,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[pulumi.Input[str]] = None,
             client_secret: Optional[pulumi.Input[str]] = None,
             subscription_id: Optional[pulumi.Input[str]] = None,
             tenant_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if 'clientSecret' in kwargs:
            client_secret = kwargs['clientSecret']
        if 'subscriptionId' in kwargs:
            subscription_id = kwargs['subscriptionId']
        if 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']

        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret is not None:
            _setter("client_secret", client_secret)
        if subscription_id is not None:
            _setter("subscription_id", subscription_id)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client Id.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Client Secret.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        Subscription Id.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        Tenant Id.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class AzureFilePropertiesArgs:
    def __init__(__self__, *,
                 access_mode: Optional[pulumi.Input[Union[str, 'AccessMode']]] = None,
                 account_key: Optional[pulumi.Input[str]] = None,
                 account_name: Optional[pulumi.Input[str]] = None,
                 share_name: Optional[pulumi.Input[str]] = None):
        """
        Azure File Properties.
        :param pulumi.Input[Union[str, 'AccessMode']] access_mode: Access mode for storage
        :param pulumi.Input[str] account_key: Storage account key for azure file.
        :param pulumi.Input[str] account_name: Storage account name for azure file.
        :param pulumi.Input[str] share_name: Azure file share name.
        """
        AzureFilePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_mode=access_mode,
            account_key=account_key,
            account_name=account_name,
            share_name=share_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_mode: Optional[pulumi.Input[Union[str, 'AccessMode']]] = None,
             account_key: Optional[pulumi.Input[str]] = None,
             account_name: Optional[pulumi.Input[str]] = None,
             share_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accessMode' in kwargs:
            access_mode = kwargs['accessMode']
        if 'accountKey' in kwargs:
            account_key = kwargs['accountKey']
        if 'accountName' in kwargs:
            account_name = kwargs['accountName']
        if 'shareName' in kwargs:
            share_name = kwargs['shareName']

        if access_mode is not None:
            _setter("access_mode", access_mode)
        if account_key is not None:
            _setter("account_key", account_key)
        if account_name is not None:
            _setter("account_name", account_name)
        if share_name is not None:
            _setter("share_name", share_name)

    @property
    @pulumi.getter(name="accessMode")
    def access_mode(self) -> Optional[pulumi.Input[Union[str, 'AccessMode']]]:
        """
        Access mode for storage
        """
        return pulumi.get(self, "access_mode")

    @access_mode.setter
    def access_mode(self, value: Optional[pulumi.Input[Union[str, 'AccessMode']]]):
        pulumi.set(self, "access_mode", value)

    @property
    @pulumi.getter(name="accountKey")
    def account_key(self) -> Optional[pulumi.Input[str]]:
        """
        Storage account key for azure file.
        """
        return pulumi.get(self, "account_key")

    @account_key.setter
    def account_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_key", value)

    @property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[str]]:
        """
        Storage account name for azure file.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_name", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[pulumi.Input[str]]:
        """
        Azure file share name.
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "share_name", value)


@pulumi.input_type
class AzureStaticWebAppsRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None):
        """
        The configuration settings of the registration for the Azure Static Web Apps provider
        :param pulumi.Input[str] client_id: The Client ID of the app used for login.
        """
        AzureStaticWebAppsRegistrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']

        if client_id is not None:
            _setter("client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)


@pulumi.input_type
class AzureStaticWebAppsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 registration: Optional[pulumi.Input['AzureStaticWebAppsRegistrationArgs']] = None):
        """
        The configuration settings of the Azure Static Web Apps provider.
        :param pulumi.Input[bool] enabled: <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['AzureStaticWebAppsRegistrationArgs'] registration: The configuration settings of the Azure Static Web Apps registration.
        """
        AzureStaticWebAppsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             registration: Optional[pulumi.Input['AzureStaticWebAppsRegistrationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AzureStaticWebAppsRegistrationArgs']]:
        """
        The configuration settings of the Azure Static Web Apps registration.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AzureStaticWebAppsRegistrationArgs']]):
        pulumi.set(self, "registration", value)


@pulumi.input_type
class CertificatePropertiesArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Certificate resource specific properties
        :param pulumi.Input[str] password: Certificate password.
        :param pulumi.Input[str] value: PFX or PEM blob
        """
        CertificatePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if password is not None:
            _setter("password", password)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Certificate password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        PFX or PEM blob
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ClientRegistrationArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        The configuration settings of the app registration for providers that have client ids and client secrets
        :param pulumi.Input[str] client_id: The Client ID of the app used for login.
        :param pulumi.Input[str] client_secret_setting_name: The app setting name that contains the client secret.
        """
        ClientRegistrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            client_secret_setting_name=client_secret_setting_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: Optional[pulumi.Input[str]] = None,
             client_secret_setting_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if 'clientSecretSettingName' in kwargs:
            client_secret_setting_name = kwargs['clientSecretSettingName']

        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret_setting_name is not None:
            _setter("client_secret_setting_name", client_secret_setting_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the app used for login.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the client secret.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)


@pulumi.input_type
class ConfigurationArgs:
    def __init__(__self__, *,
                 active_revisions_mode: Optional[pulumi.Input[Union[str, 'ActiveRevisionsMode']]] = None,
                 dapr: Optional[pulumi.Input['DaprArgs']] = None,
                 ingress: Optional[pulumi.Input['IngressArgs']] = None,
                 registries: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]] = None):
        """
        Non versioned Container App configuration properties that define the mutable settings of a Container app
        :param pulumi.Input[Union[str, 'ActiveRevisionsMode']] active_revisions_mode: ActiveRevisionsMode controls how active revisions are handled for the Container app:
               <list><item>Multiple: multiple revisions can be active. If no value if provided, this is the default</item><item>Single: Only one revision can be active at a time. Revision weights can not be used in this mode</item></list>
        :param pulumi.Input['DaprArgs'] dapr: Dapr configuration for the Container App.
        :param pulumi.Input['IngressArgs'] ingress: Ingress configurations.
        :param pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]] registries: Collection of private container registry credentials for containers used by the Container app
        :param pulumi.Input[Sequence[pulumi.Input['SecretArgs']]] secrets: Collection of secrets used by a Container app
        """
        ConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            active_revisions_mode=active_revisions_mode,
            dapr=dapr,
            ingress=ingress,
            registries=registries,
            secrets=secrets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             active_revisions_mode: Optional[pulumi.Input[Union[str, 'ActiveRevisionsMode']]] = None,
             dapr: Optional[pulumi.Input['DaprArgs']] = None,
             ingress: Optional[pulumi.Input['IngressArgs']] = None,
             registries: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]]] = None,
             secrets: Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'activeRevisionsMode' in kwargs:
            active_revisions_mode = kwargs['activeRevisionsMode']

        if active_revisions_mode is not None:
            _setter("active_revisions_mode", active_revisions_mode)
        if dapr is not None:
            _setter("dapr", dapr)
        if ingress is not None:
            _setter("ingress", ingress)
        if registries is not None:
            _setter("registries", registries)
        if secrets is not None:
            _setter("secrets", secrets)

    @property
    @pulumi.getter(name="activeRevisionsMode")
    def active_revisions_mode(self) -> Optional[pulumi.Input[Union[str, 'ActiveRevisionsMode']]]:
        """
        ActiveRevisionsMode controls how active revisions are handled for the Container app:
        <list><item>Multiple: multiple revisions can be active. If no value if provided, this is the default</item><item>Single: Only one revision can be active at a time. Revision weights can not be used in this mode</item></list>
        """
        return pulumi.get(self, "active_revisions_mode")

    @active_revisions_mode.setter
    def active_revisions_mode(self, value: Optional[pulumi.Input[Union[str, 'ActiveRevisionsMode']]]):
        pulumi.set(self, "active_revisions_mode", value)

    @property
    @pulumi.getter
    def dapr(self) -> Optional[pulumi.Input['DaprArgs']]:
        """
        Dapr configuration for the Container App.
        """
        return pulumi.get(self, "dapr")

    @dapr.setter
    def dapr(self, value: Optional[pulumi.Input['DaprArgs']]):
        pulumi.set(self, "dapr", value)

    @property
    @pulumi.getter
    def ingress(self) -> Optional[pulumi.Input['IngressArgs']]:
        """
        Ingress configurations.
        """
        return pulumi.get(self, "ingress")

    @ingress.setter
    def ingress(self, value: Optional[pulumi.Input['IngressArgs']]):
        pulumi.set(self, "ingress", value)

    @property
    @pulumi.getter
    def registries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]]]:
        """
        Collection of private container registry credentials for containers used by the Container app
        """
        return pulumi.get(self, "registries")

    @registries.setter
    def registries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RegistryCredentialsArgs']]]]):
        pulumi.set(self, "registries", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]]:
        """
        Collection of secrets used by a Container app
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecretArgs']]]]):
        pulumi.set(self, "secrets", value)


@pulumi.input_type
class ContainerAppProbeHttpGetArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 host: Optional[pulumi.Input[str]] = None,
                 http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgs']]]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 scheme: Optional[pulumi.Input[Union[str, 'Scheme']]] = None):
        """
        HTTPGet specifies the http request to perform.
        :param pulumi.Input[int] port: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param pulumi.Input[str] host: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        :param pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgs']]] http_headers: Custom headers to set in the request. HTTP allows repeated headers.
        :param pulumi.Input[str] path: Path to access on the HTTP server.
        :param pulumi.Input[Union[str, 'Scheme']] scheme: Scheme to use for connecting to the host. Defaults to HTTP.
        """
        ContainerAppProbeHttpGetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            host=host,
            http_headers=http_headers,
            path=path,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: pulumi.Input[int],
             host: Optional[pulumi.Input[str]] = None,
             http_headers: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgs']]]] = None,
             path: Optional[pulumi.Input[str]] = None,
             scheme: Optional[pulumi.Input[Union[str, 'Scheme']]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpHeaders' in kwargs:
            http_headers = kwargs['httpHeaders']

        _setter("port", port)
        if host is not None:
            _setter("host", host)
        if http_headers is not None:
            _setter("http_headers", http_headers)
        if path is not None:
            _setter("path", path)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgs']]]]:
        """
        Custom headers to set in the request. HTTP allows repeated headers.
        """
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeHttpHeadersArgs']]]]):
        pulumi.set(self, "http_headers", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to access on the HTTP server.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[Union[str, 'Scheme']]]:
        """
        Scheme to use for connecting to the host. Defaults to HTTP.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[Union[str, 'Scheme']]]):
        pulumi.set(self, "scheme", value)


@pulumi.input_type
class ContainerAppProbeHttpHeadersArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        HTTPHeader describes a custom header to be used in HTTP probes
        :param pulumi.Input[str] name: The header field name
        :param pulumi.Input[str] value: The header field value
        """
        ContainerAppProbeHttpHeadersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The header field name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The header field value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ContainerAppProbeTcpSocketArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 host: Optional[pulumi.Input[str]] = None):
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        :param pulumi.Input[int] port: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        :param pulumi.Input[str] host: Optional: Host name to connect to, defaults to the pod IP.
        """
        ContainerAppProbeTcpSocketArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            host=host,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: pulumi.Input[int],
             host: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("port", port)
        if host is not None:
            _setter("host", host)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Optional: Host name to connect to, defaults to the pod IP.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


@pulumi.input_type
class ContainerAppProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 http_get: Optional[pulumi.Input['ContainerAppProbeHttpGetArgs']] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 tcp_socket: Optional[pulumi.Input['ContainerAppProbeTcpSocketArgs']] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[float]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[Union[str, 'Type']]] = None):
        """
        Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
        :param pulumi.Input[int] failure_threshold: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        :param pulumi.Input['ContainerAppProbeHttpGetArgs'] http_get: HTTPGet specifies the http request to perform.
        :param pulumi.Input[int] initial_delay_seconds: Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        :param pulumi.Input[int] period_seconds: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        :param pulumi.Input[int] success_threshold: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        :param pulumi.Input['ContainerAppProbeTcpSocketArgs'] tcp_socket: TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        :param pulumi.Input[float] termination_grace_period_seconds: Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        :param pulumi.Input[int] timeout_seconds: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        :param pulumi.Input[Union[str, 'Type']] type: The type of probe.
        """
        ContainerAppProbeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_threshold=failure_threshold,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            success_threshold=success_threshold,
            tcp_socket=tcp_socket,
            termination_grace_period_seconds=termination_grace_period_seconds,
            timeout_seconds=timeout_seconds,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_threshold: Optional[pulumi.Input[int]] = None,
             http_get: Optional[pulumi.Input['ContainerAppProbeHttpGetArgs']] = None,
             initial_delay_seconds: Optional[pulumi.Input[int]] = None,
             period_seconds: Optional[pulumi.Input[int]] = None,
             success_threshold: Optional[pulumi.Input[int]] = None,
             tcp_socket: Optional[pulumi.Input['ContainerAppProbeTcpSocketArgs']] = None,
             termination_grace_period_seconds: Optional[pulumi.Input[float]] = None,
             timeout_seconds: Optional[pulumi.Input[int]] = None,
             type: Optional[pulumi.Input[Union[str, 'Type']]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'failureThreshold' in kwargs:
            failure_threshold = kwargs['failureThreshold']
        if 'httpGet' in kwargs:
            http_get = kwargs['httpGet']
        if 'initialDelaySeconds' in kwargs:
            initial_delay_seconds = kwargs['initialDelaySeconds']
        if 'periodSeconds' in kwargs:
            period_seconds = kwargs['periodSeconds']
        if 'successThreshold' in kwargs:
            success_threshold = kwargs['successThreshold']
        if 'tcpSocket' in kwargs:
            tcp_socket = kwargs['tcpSocket']
        if 'terminationGracePeriodSeconds' in kwargs:
            termination_grace_period_seconds = kwargs['terminationGracePeriodSeconds']
        if 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        if failure_threshold is not None:
            _setter("failure_threshold", failure_threshold)
        if http_get is not None:
            _setter("http_get", http_get)
        if initial_delay_seconds is not None:
            _setter("initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            _setter("period_seconds", period_seconds)
        if success_threshold is not None:
            _setter("success_threshold", success_threshold)
        if tcp_socket is not None:
            _setter("tcp_socket", tcp_socket)
        if termination_grace_period_seconds is not None:
            _setter("termination_grace_period_seconds", termination_grace_period_seconds)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['ContainerAppProbeHttpGetArgs']]:
        """
        HTTPGet specifies the http request to perform.
        """
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['ContainerAppProbeHttpGetArgs']]):
        pulumi.set(self, "http_get", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional[pulumi.Input['ContainerAppProbeTcpSocketArgs']]:
        """
        TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported.
        """
        return pulumi.get(self, "tcp_socket")

    @tcp_socket.setter
    def tcp_socket(self, value: Optional[pulumi.Input['ContainerAppProbeTcpSocketArgs']]):
        pulumi.set(self, "tcp_socket", value)

    @property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "termination_grace_period_seconds", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[Union[str, 'Type']]]:
        """
        The type of probe.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[Union[str, 'Type']]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ContainerResourcesArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[float]] = None,
                 memory: Optional[pulumi.Input[str]] = None):
        """
        Container App container resource requirements.
        :param pulumi.Input[float] cpu: Required CPU in cores, e.g. 0.5
        :param pulumi.Input[str] memory: Required memory, e.g. "250Mb"
        """
        ContainerResourcesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu=cpu,
            memory=memory,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu: Optional[pulumi.Input[float]] = None,
             memory: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if cpu is not None:
            _setter("cpu", cpu)
        if memory is not None:
            _setter("memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[float]]:
        """
        Required CPU in cores, e.g. 0.5
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[str]]:
        """
        Required memory, e.g. "250Mb"
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory", value)


@pulumi.input_type
class ContainerArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 command: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 env: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 probes: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgs']]]] = None,
                 resources: Optional[pulumi.Input['ContainerResourcesArgs']] = None,
                 volume_mounts: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]] = None):
        """
        Container App container definition.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] args: Container start command arguments.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] command: Container start command.
        :param pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]] env: Container environment variables.
        :param pulumi.Input[str] image: Container image tag.
        :param pulumi.Input[str] name: Custom container name.
        :param pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgs']]] probes: List of probes for the container.
        :param pulumi.Input['ContainerResourcesArgs'] resources: Container resource requirements.
        :param pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]] volume_mounts: Container volume mounts.
        """
        ContainerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            args=args,
            command=command,
            env=env,
            image=image,
            name=name,
            probes=probes,
            resources=resources,
            volume_mounts=volume_mounts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             args: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             command: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             env: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]] = None,
             image: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             probes: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgs']]]] = None,
             resources: Optional[pulumi.Input['ContainerResourcesArgs']] = None,
             volume_mounts: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'volumeMounts' in kwargs:
            volume_mounts = kwargs['volumeMounts']

        if args is not None:
            _setter("args", args)
        if command is not None:
            _setter("command", command)
        if env is not None:
            _setter("env", env)
        if image is not None:
            _setter("image", image)
        if name is not None:
            _setter("name", name)
        if probes is not None:
            _setter("probes", probes)
        if resources is not None:
            _setter("resources", resources)
        if volume_mounts is not None:
            _setter("volume_mounts", volume_mounts)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Container start command arguments.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Container start command.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]]:
        """
        Container environment variables.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentVarArgs']]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Container image tag.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Custom container name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def probes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgs']]]]:
        """
        List of probes for the container.
        """
        return pulumi.get(self, "probes")

    @probes.setter
    def probes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerAppProbeArgs']]]]):
        pulumi.set(self, "probes", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['ContainerResourcesArgs']]:
        """
        Container resource requirements.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['ContainerResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="volumeMounts")
    def volume_mounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]]:
        """
        Container volume mounts.
        """
        return pulumi.get(self, "volume_mounts")

    @volume_mounts.setter
    def volume_mounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeMountArgs']]]]):
        pulumi.set(self, "volume_mounts", value)


@pulumi.input_type
class CookieExpirationArgs:
    def __init__(__self__, *,
                 convention: Optional[pulumi.Input['CookieExpirationConvention']] = None,
                 time_to_expiration: Optional[pulumi.Input[str]] = None):
        """
        The configuration settings of the session cookie's expiration.
        :param pulumi.Input['CookieExpirationConvention'] convention: The convention used when determining the session cookie's expiration.
        :param pulumi.Input[str] time_to_expiration: The time after the request is made when the session cookie should expire.
        """
        CookieExpirationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            convention=convention,
            time_to_expiration=time_to_expiration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             convention: Optional[pulumi.Input['CookieExpirationConvention']] = None,
             time_to_expiration: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'timeToExpiration' in kwargs:
            time_to_expiration = kwargs['timeToExpiration']

        if convention is not None:
            _setter("convention", convention)
        if time_to_expiration is not None:
            _setter("time_to_expiration", time_to_expiration)

    @property
    @pulumi.getter
    def convention(self) -> Optional[pulumi.Input['CookieExpirationConvention']]:
        """
        The convention used when determining the session cookie's expiration.
        """
        return pulumi.get(self, "convention")

    @convention.setter
    def convention(self, value: Optional[pulumi.Input['CookieExpirationConvention']]):
        pulumi.set(self, "convention", value)

    @property
    @pulumi.getter(name="timeToExpiration")
    def time_to_expiration(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the session cookie should expire.
        """
        return pulumi.get(self, "time_to_expiration")

    @time_to_expiration.setter
    def time_to_expiration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_to_expiration", value)


@pulumi.input_type
class CustomDomainArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 binding_type: Optional[pulumi.Input[Union[str, 'BindingType']]] = None,
                 certificate_id: Optional[pulumi.Input[str]] = None):
        """
        Custom Domain of a Container App
        :param pulumi.Input[str] name: Hostname.
        :param pulumi.Input[Union[str, 'BindingType']] binding_type: Custom Domain binding type.
        :param pulumi.Input[str] certificate_id: Resource Id of the Certificate to be bound to this hostname.
        """
        CustomDomainArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            binding_type=binding_type,
            certificate_id=certificate_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             binding_type: Optional[pulumi.Input[Union[str, 'BindingType']]] = None,
             certificate_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'bindingType' in kwargs:
            binding_type = kwargs['bindingType']
        if 'certificateId' in kwargs:
            certificate_id = kwargs['certificateId']

        _setter("name", name)
        if binding_type is not None:
            _setter("binding_type", binding_type)
        if certificate_id is not None:
            _setter("certificate_id", certificate_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Hostname.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="bindingType")
    def binding_type(self) -> Optional[pulumi.Input[Union[str, 'BindingType']]]:
        """
        Custom Domain binding type.
        """
        return pulumi.get(self, "binding_type")

    @binding_type.setter
    def binding_type(self, value: Optional[pulumi.Input[Union[str, 'BindingType']]]):
        pulumi.set(self, "binding_type", value)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource Id of the Certificate to be bound to this hostname.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)


@pulumi.input_type
class CustomOpenIdConnectProviderArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 login: Optional[pulumi.Input['OpenIdConnectLoginArgs']] = None,
                 registration: Optional[pulumi.Input['OpenIdConnectRegistrationArgs']] = None):
        """
        The configuration settings of the custom Open ID Connect provider.
        :param pulumi.Input[bool] enabled: <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        :param pulumi.Input['OpenIdConnectLoginArgs'] login: The configuration settings of the login flow of the custom Open ID Connect provider.
        :param pulumi.Input['OpenIdConnectRegistrationArgs'] registration: The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        CustomOpenIdConnectProviderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            login=login,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             login: Optional[pulumi.Input['OpenIdConnectLoginArgs']] = None,
             registration: Optional[pulumi.Input['OpenIdConnectRegistrationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>false</code> if the custom Open ID provider provider should not be enabled; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['OpenIdConnectLoginArgs']]:
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['OpenIdConnectLoginArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['OpenIdConnectRegistrationArgs']]:
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['OpenIdConnectRegistrationArgs']]):
        pulumi.set(self, "registration", value)


@pulumi.input_type
class CustomScaleRuleArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        Container App container Custom scaling rule.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]] auth: Authentication secrets for the custom scale rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Metadata properties to describe custom scale rule.
        :param pulumi.Input[str] type: Type of the custom scale rule
               eg: azure-servicebus, redis etc.
        """
        CustomScaleRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth=auth,
            metadata=metadata,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
             metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if auth is not None:
            _setter("auth", auth)
        if metadata is not None:
            _setter("metadata", metadata)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]:
        """
        Authentication secrets for the custom scale rule.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Metadata properties to describe custom scale rule.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the custom scale rule
        eg: azure-servicebus, redis etc.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DaprMetadataArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 secret_ref: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Dapr component metadata.
        :param pulumi.Input[str] name: Metadata property name.
        :param pulumi.Input[str] secret_ref: Name of the Dapr Component secret from which to pull the metadata property value.
        :param pulumi.Input[str] value: Metadata property value.
        """
        DaprMetadataArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            secret_ref=secret_ref,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             secret_ref: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretRef' in kwargs:
            secret_ref = kwargs['secretRef']

        if name is not None:
            _setter("name", name)
        if secret_ref is not None:
            _setter("secret_ref", secret_ref)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Metadata property name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Dapr Component secret from which to pull the metadata property value.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_ref", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Metadata property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DaprArgs:
    def __init__(__self__, *,
                 app_id: Optional[pulumi.Input[str]] = None,
                 app_port: Optional[pulumi.Input[int]] = None,
                 app_protocol: Optional[pulumi.Input[Union[str, 'AppProtocol']]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        Container App Dapr configuration.
        :param pulumi.Input[str] app_id: Dapr application identifier
        :param pulumi.Input[int] app_port: Tells Dapr which port your application is listening on
        :param pulumi.Input[Union[str, 'AppProtocol']] app_protocol: Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
        :param pulumi.Input[bool] enabled: Boolean indicating if the Dapr side car is enabled
        """
        DaprArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app_id=app_id,
            app_port=app_port,
            app_protocol=app_protocol,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app_id: Optional[pulumi.Input[str]] = None,
             app_port: Optional[pulumi.Input[int]] = None,
             app_protocol: Optional[pulumi.Input[Union[str, 'AppProtocol']]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'appId' in kwargs:
            app_id = kwargs['appId']
        if 'appPort' in kwargs:
            app_port = kwargs['appPort']
        if 'appProtocol' in kwargs:
            app_protocol = kwargs['appProtocol']

        if app_id is not None:
            _setter("app_id", app_id)
        if app_port is not None:
            _setter("app_port", app_port)
        if app_protocol is not None:
            _setter("app_protocol", app_protocol)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[str]]:
        """
        Dapr application identifier
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appPort")
    def app_port(self) -> Optional[pulumi.Input[int]]:
        """
        Tells Dapr which port your application is listening on
        """
        return pulumi.get(self, "app_port")

    @app_port.setter
    def app_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "app_port", value)

    @property
    @pulumi.getter(name="appProtocol")
    def app_protocol(self) -> Optional[pulumi.Input[Union[str, 'AppProtocol']]]:
        """
        Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
        """
        return pulumi.get(self, "app_protocol")

    @app_protocol.setter
    def app_protocol(self, value: Optional[pulumi.Input[Union[str, 'AppProtocol']]]):
        pulumi.set(self, "app_protocol", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating if the Dapr side car is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class DefaultAuthorizationPolicyArgs:
    def __init__(__self__, *,
                 allowed_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_principals: Optional[pulumi.Input['AllowedPrincipalsArgs']] = None):
        """
        The configuration settings of the Azure Active Directory default authorization policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_applications: The configuration settings of the Azure Active Directory allowed applications.
        :param pulumi.Input['AllowedPrincipalsArgs'] allowed_principals: The configuration settings of the Azure Active Directory allowed principals.
        """
        DefaultAuthorizationPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_applications=allowed_applications,
            allowed_principals=allowed_principals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             allowed_principals: Optional[pulumi.Input['AllowedPrincipalsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedApplications' in kwargs:
            allowed_applications = kwargs['allowedApplications']
        if 'allowedPrincipals' in kwargs:
            allowed_principals = kwargs['allowedPrincipals']

        if allowed_applications is not None:
            _setter("allowed_applications", allowed_applications)
        if allowed_principals is not None:
            _setter("allowed_principals", allowed_principals)

    @property
    @pulumi.getter(name="allowedApplications")
    def allowed_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The configuration settings of the Azure Active Directory allowed applications.
        """
        return pulumi.get(self, "allowed_applications")

    @allowed_applications.setter
    def allowed_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_applications", value)

    @property
    @pulumi.getter(name="allowedPrincipals")
    def allowed_principals(self) -> Optional[pulumi.Input['AllowedPrincipalsArgs']]:
        """
        The configuration settings of the Azure Active Directory allowed principals.
        """
        return pulumi.get(self, "allowed_principals")

    @allowed_principals.setter
    def allowed_principals(self, value: Optional[pulumi.Input['AllowedPrincipalsArgs']]):
        pulumi.set(self, "allowed_principals", value)


@pulumi.input_type
class EnvironmentVarArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 secret_ref: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Container App container environment variable.
        :param pulumi.Input[str] name: Environment variable name.
        :param pulumi.Input[str] secret_ref: Name of the Container App secret from which to pull the environment variable value.
        :param pulumi.Input[str] value: Non-secret environment variable value.
        """
        EnvironmentVarArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            secret_ref=secret_ref,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             secret_ref: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretRef' in kwargs:
            secret_ref = kwargs['secretRef']

        if name is not None:
            _setter("name", name)
        if secret_ref is not None:
            _setter("secret_ref", secret_ref)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Environment variable name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Container App secret from which to pull the environment variable value.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_ref", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Non-secret environment variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class FacebookArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 graph_api_version: Optional[pulumi.Input[str]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['AppRegistrationArgs']] = None):
        """
        The configuration settings of the Facebook provider.
        :param pulumi.Input[bool] enabled: <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input[str] graph_api_version: The version of the Facebook api to be used while logging in.
        :param pulumi.Input['LoginScopesArgs'] login: The configuration settings of the login flow.
        :param pulumi.Input['AppRegistrationArgs'] registration: The configuration settings of the app registration for the Facebook provider.
        """
        FacebookArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            graph_api_version=graph_api_version,
            login=login,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             graph_api_version: Optional[pulumi.Input[str]] = None,
             login: Optional[pulumi.Input['LoginScopesArgs']] = None,
             registration: Optional[pulumi.Input['AppRegistrationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'graphApiVersion' in kwargs:
            graph_api_version = kwargs['graphApiVersion']

        if enabled is not None:
            _setter("enabled", enabled)
        if graph_api_version is not None:
            _setter("graph_api_version", graph_api_version)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="graphApiVersion")
    def graph_api_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Facebook api to be used while logging in.
        """
        return pulumi.get(self, "graph_api_version")

    @graph_api_version.setter
    def graph_api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_api_version", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['AppRegistrationArgs']]:
        """
        The configuration settings of the app registration for the Facebook provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['AppRegistrationArgs']]):
        pulumi.set(self, "registration", value)


@pulumi.input_type
class ForwardProxyArgs:
    def __init__(__self__, *,
                 convention: Optional[pulumi.Input['ForwardProxyConvention']] = None,
                 custom_host_header_name: Optional[pulumi.Input[str]] = None,
                 custom_proto_header_name: Optional[pulumi.Input[str]] = None):
        """
        The configuration settings of a forward proxy used to make the requests.
        :param pulumi.Input['ForwardProxyConvention'] convention: The convention used to determine the url of the request made.
        :param pulumi.Input[str] custom_host_header_name: The name of the header containing the host of the request.
        :param pulumi.Input[str] custom_proto_header_name: The name of the header containing the scheme of the request.
        """
        ForwardProxyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            convention=convention,
            custom_host_header_name=custom_host_header_name,
            custom_proto_header_name=custom_proto_header_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             convention: Optional[pulumi.Input['ForwardProxyConvention']] = None,
             custom_host_header_name: Optional[pulumi.Input[str]] = None,
             custom_proto_header_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customHostHeaderName' in kwargs:
            custom_host_header_name = kwargs['customHostHeaderName']
        if 'customProtoHeaderName' in kwargs:
            custom_proto_header_name = kwargs['customProtoHeaderName']

        if convention is not None:
            _setter("convention", convention)
        if custom_host_header_name is not None:
            _setter("custom_host_header_name", custom_host_header_name)
        if custom_proto_header_name is not None:
            _setter("custom_proto_header_name", custom_proto_header_name)

    @property
    @pulumi.getter
    def convention(self) -> Optional[pulumi.Input['ForwardProxyConvention']]:
        """
        The convention used to determine the url of the request made.
        """
        return pulumi.get(self, "convention")

    @convention.setter
    def convention(self, value: Optional[pulumi.Input['ForwardProxyConvention']]):
        pulumi.set(self, "convention", value)

    @property
    @pulumi.getter(name="customHostHeaderName")
    def custom_host_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the header containing the host of the request.
        """
        return pulumi.get(self, "custom_host_header_name")

    @custom_host_header_name.setter
    def custom_host_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_host_header_name", value)

    @property
    @pulumi.getter(name="customProtoHeaderName")
    def custom_proto_header_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the header containing the scheme of the request.
        """
        return pulumi.get(self, "custom_proto_header_name")

    @custom_proto_header_name.setter
    def custom_proto_header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_proto_header_name", value)


@pulumi.input_type
class GitHubArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['ClientRegistrationArgs']] = None):
        """
        The configuration settings of the GitHub provider.
        :param pulumi.Input[bool] enabled: <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['LoginScopesArgs'] login: The configuration settings of the login flow.
        :param pulumi.Input['ClientRegistrationArgs'] registration: The configuration settings of the app registration for the GitHub provider.
        """
        GitHubArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            login=login,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             login: Optional[pulumi.Input['LoginScopesArgs']] = None,
             registration: Optional[pulumi.Input['ClientRegistrationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['ClientRegistrationArgs']]:
        """
        The configuration settings of the app registration for the GitHub provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['ClientRegistrationArgs']]):
        pulumi.set(self, "registration", value)


@pulumi.input_type
class GithubActionConfigurationArgs:
    def __init__(__self__, *,
                 azure_credentials: Optional[pulumi.Input['AzureCredentialsArgs']] = None,
                 dockerfile_path: Optional[pulumi.Input[str]] = None,
                 os: Optional[pulumi.Input[str]] = None,
                 publish_type: Optional[pulumi.Input[str]] = None,
                 registry_info: Optional[pulumi.Input['RegistryInfoArgs']] = None,
                 runtime_stack: Optional[pulumi.Input[str]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None):
        """
        Configuration properties that define the mutable settings of a Container App SourceControl
        :param pulumi.Input['AzureCredentialsArgs'] azure_credentials: AzureCredentials configurations.
        :param pulumi.Input[str] dockerfile_path: Docker file path
        :param pulumi.Input[str] os: Operation system
        :param pulumi.Input[str] publish_type: Code or Image
        :param pulumi.Input['RegistryInfoArgs'] registry_info: Registry configurations.
        :param pulumi.Input[str] runtime_stack: Runtime stack
        :param pulumi.Input[str] runtime_version: Runtime Version
        """
        GithubActionConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_credentials=azure_credentials,
            dockerfile_path=dockerfile_path,
            os=os,
            publish_type=publish_type,
            registry_info=registry_info,
            runtime_stack=runtime_stack,
            runtime_version=runtime_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_credentials: Optional[pulumi.Input['AzureCredentialsArgs']] = None,
             dockerfile_path: Optional[pulumi.Input[str]] = None,
             os: Optional[pulumi.Input[str]] = None,
             publish_type: Optional[pulumi.Input[str]] = None,
             registry_info: Optional[pulumi.Input['RegistryInfoArgs']] = None,
             runtime_stack: Optional[pulumi.Input[str]] = None,
             runtime_version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'azureCredentials' in kwargs:
            azure_credentials = kwargs['azureCredentials']
        if 'dockerfilePath' in kwargs:
            dockerfile_path = kwargs['dockerfilePath']
        if 'publishType' in kwargs:
            publish_type = kwargs['publishType']
        if 'registryInfo' in kwargs:
            registry_info = kwargs['registryInfo']
        if 'runtimeStack' in kwargs:
            runtime_stack = kwargs['runtimeStack']
        if 'runtimeVersion' in kwargs:
            runtime_version = kwargs['runtimeVersion']

        if azure_credentials is not None:
            _setter("azure_credentials", azure_credentials)
        if dockerfile_path is not None:
            _setter("dockerfile_path", dockerfile_path)
        if os is not None:
            _setter("os", os)
        if publish_type is not None:
            _setter("publish_type", publish_type)
        if registry_info is not None:
            _setter("registry_info", registry_info)
        if runtime_stack is not None:
            _setter("runtime_stack", runtime_stack)
        if runtime_version is not None:
            _setter("runtime_version", runtime_version)

    @property
    @pulumi.getter(name="azureCredentials")
    def azure_credentials(self) -> Optional[pulumi.Input['AzureCredentialsArgs']]:
        """
        AzureCredentials configurations.
        """
        return pulumi.get(self, "azure_credentials")

    @azure_credentials.setter
    def azure_credentials(self, value: Optional[pulumi.Input['AzureCredentialsArgs']]):
        pulumi.set(self, "azure_credentials", value)

    @property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[pulumi.Input[str]]:
        """
        Docker file path
        """
        return pulumi.get(self, "dockerfile_path")

    @dockerfile_path.setter
    def dockerfile_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dockerfile_path", value)

    @property
    @pulumi.getter
    def os(self) -> Optional[pulumi.Input[str]]:
        """
        Operation system
        """
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os", value)

    @property
    @pulumi.getter(name="publishType")
    def publish_type(self) -> Optional[pulumi.Input[str]]:
        """
        Code or Image
        """
        return pulumi.get(self, "publish_type")

    @publish_type.setter
    def publish_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "publish_type", value)

    @property
    @pulumi.getter(name="registryInfo")
    def registry_info(self) -> Optional[pulumi.Input['RegistryInfoArgs']]:
        """
        Registry configurations.
        """
        return pulumi.get(self, "registry_info")

    @registry_info.setter
    def registry_info(self, value: Optional[pulumi.Input['RegistryInfoArgs']]):
        pulumi.set(self, "registry_info", value)

    @property
    @pulumi.getter(name="runtimeStack")
    def runtime_stack(self) -> Optional[pulumi.Input[str]]:
        """
        Runtime stack
        """
        return pulumi.get(self, "runtime_stack")

    @runtime_stack.setter
    def runtime_stack(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_stack", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        Runtime Version
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)


@pulumi.input_type
class GlobalValidationArgs:
    def __init__(__self__, *,
                 excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 redirect_to_provider: Optional[pulumi.Input[str]] = None,
                 unauthenticated_client_action: Optional[pulumi.Input['UnauthenticatedClientActionV2']] = None):
        """
        The configuration settings that determines the validation flow of users using ContainerApp Service Authentication/Authorization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_paths: The paths for which unauthenticated flow would not be redirected to the login page.
        :param pulumi.Input[str] redirect_to_provider: The default authentication provider to use when multiple providers are configured.
               This setting is only needed if multiple providers are configured and the unauthenticated client
               action is set to "RedirectToLoginPage".
        :param pulumi.Input['UnauthenticatedClientActionV2'] unauthenticated_client_action: The action to take when an unauthenticated client attempts to access the app.
        """
        GlobalValidationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            excluded_paths=excluded_paths,
            redirect_to_provider=redirect_to_provider,
            unauthenticated_client_action=unauthenticated_client_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             excluded_paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             redirect_to_provider: Optional[pulumi.Input[str]] = None,
             unauthenticated_client_action: Optional[pulumi.Input['UnauthenticatedClientActionV2']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'excludedPaths' in kwargs:
            excluded_paths = kwargs['excludedPaths']
        if 'redirectToProvider' in kwargs:
            redirect_to_provider = kwargs['redirectToProvider']
        if 'unauthenticatedClientAction' in kwargs:
            unauthenticated_client_action = kwargs['unauthenticatedClientAction']

        if excluded_paths is not None:
            _setter("excluded_paths", excluded_paths)
        if redirect_to_provider is not None:
            _setter("redirect_to_provider", redirect_to_provider)
        if unauthenticated_client_action is not None:
            _setter("unauthenticated_client_action", unauthenticated_client_action)

    @property
    @pulumi.getter(name="excludedPaths")
    def excluded_paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The paths for which unauthenticated flow would not be redirected to the login page.
        """
        return pulumi.get(self, "excluded_paths")

    @excluded_paths.setter
    def excluded_paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_paths", value)

    @property
    @pulumi.getter(name="redirectToProvider")
    def redirect_to_provider(self) -> Optional[pulumi.Input[str]]:
        """
        The default authentication provider to use when multiple providers are configured.
        This setting is only needed if multiple providers are configured and the unauthenticated client
        action is set to "RedirectToLoginPage".
        """
        return pulumi.get(self, "redirect_to_provider")

    @redirect_to_provider.setter
    def redirect_to_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_to_provider", value)

    @property
    @pulumi.getter(name="unauthenticatedClientAction")
    def unauthenticated_client_action(self) -> Optional[pulumi.Input['UnauthenticatedClientActionV2']]:
        """
        The action to take when an unauthenticated client attempts to access the app.
        """
        return pulumi.get(self, "unauthenticated_client_action")

    @unauthenticated_client_action.setter
    def unauthenticated_client_action(self, value: Optional[pulumi.Input['UnauthenticatedClientActionV2']]):
        pulumi.set(self, "unauthenticated_client_action", value)


@pulumi.input_type
class GoogleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 login: Optional[pulumi.Input['LoginScopesArgs']] = None,
                 registration: Optional[pulumi.Input['ClientRegistrationArgs']] = None,
                 validation: Optional[pulumi.Input['AllowedAudiencesValidationArgs']] = None):
        """
        The configuration settings of the Google provider.
        :param pulumi.Input[bool] enabled: <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['LoginScopesArgs'] login: The configuration settings of the login flow.
        :param pulumi.Input['ClientRegistrationArgs'] registration: The configuration settings of the app registration for the Google provider.
        :param pulumi.Input['AllowedAudiencesValidationArgs'] validation: The configuration settings of the Azure Active Directory token validation flow.
        """
        GoogleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            login=login,
            registration=registration,
            validation=validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             login: Optional[pulumi.Input['LoginScopesArgs']] = None,
             registration: Optional[pulumi.Input['ClientRegistrationArgs']] = None,
             validation: Optional[pulumi.Input['AllowedAudiencesValidationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if login is not None:
            _setter("login", login)
        if registration is not None:
            _setter("registration", registration)
        if validation is not None:
            _setter("validation", validation)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def login(self) -> Optional[pulumi.Input['LoginScopesArgs']]:
        """
        The configuration settings of the login flow.
        """
        return pulumi.get(self, "login")

    @login.setter
    def login(self, value: Optional[pulumi.Input['LoginScopesArgs']]):
        pulumi.set(self, "login", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['ClientRegistrationArgs']]:
        """
        The configuration settings of the app registration for the Google provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['ClientRegistrationArgs']]):
        pulumi.set(self, "registration", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input['AllowedAudiencesValidationArgs']]:
        """
        The configuration settings of the Azure Active Directory token validation flow.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input['AllowedAudiencesValidationArgs']]):
        pulumi.set(self, "validation", value)


@pulumi.input_type
class HttpScaleRuleArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Container App container Custom scaling rule.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]] auth: Authentication secrets for the custom scale rule.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: Metadata properties to describe http scale rule.
        """
        HttpScaleRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth=auth,
            metadata=metadata,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
             metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if auth is not None:
            _setter("auth", auth)
        if metadata is not None:
            _setter("metadata", metadata)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]:
        """
        Authentication secrets for the custom scale rule.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Metadata properties to describe http scale rule.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)


@pulumi.input_type
class HttpSettingsRoutesArgs:
    def __init__(__self__, *,
                 api_prefix: Optional[pulumi.Input[str]] = None):
        """
        The configuration settings of the paths HTTP requests.
        :param pulumi.Input[str] api_prefix: The prefix that should precede all the authentication/authorization paths.
        """
        HttpSettingsRoutesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_prefix=api_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_prefix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'apiPrefix' in kwargs:
            api_prefix = kwargs['apiPrefix']

        if api_prefix is not None:
            _setter("api_prefix", api_prefix)

    @property
    @pulumi.getter(name="apiPrefix")
    def api_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix that should precede all the authentication/authorization paths.
        """
        return pulumi.get(self, "api_prefix")

    @api_prefix.setter
    def api_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_prefix", value)


@pulumi.input_type
class HttpSettingsArgs:
    def __init__(__self__, *,
                 forward_proxy: Optional[pulumi.Input['ForwardProxyArgs']] = None,
                 require_https: Optional[pulumi.Input[bool]] = None,
                 routes: Optional[pulumi.Input['HttpSettingsRoutesArgs']] = None):
        """
        The configuration settings of the HTTP requests for authentication and authorization requests made against ContainerApp Service Authentication/Authorization.
        :param pulumi.Input['ForwardProxyArgs'] forward_proxy: The configuration settings of a forward proxy used to make the requests.
        :param pulumi.Input[bool] require_https: <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        :param pulumi.Input['HttpSettingsRoutesArgs'] routes: The configuration settings of the paths HTTP requests.
        """
        HttpSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forward_proxy=forward_proxy,
            require_https=require_https,
            routes=routes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forward_proxy: Optional[pulumi.Input['ForwardProxyArgs']] = None,
             require_https: Optional[pulumi.Input[bool]] = None,
             routes: Optional[pulumi.Input['HttpSettingsRoutesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'forwardProxy' in kwargs:
            forward_proxy = kwargs['forwardProxy']
        if 'requireHttps' in kwargs:
            require_https = kwargs['requireHttps']

        if forward_proxy is not None:
            _setter("forward_proxy", forward_proxy)
        if require_https is not None:
            _setter("require_https", require_https)
        if routes is not None:
            _setter("routes", routes)

    @property
    @pulumi.getter(name="forwardProxy")
    def forward_proxy(self) -> Optional[pulumi.Input['ForwardProxyArgs']]:
        """
        The configuration settings of a forward proxy used to make the requests.
        """
        return pulumi.get(self, "forward_proxy")

    @forward_proxy.setter
    def forward_proxy(self, value: Optional[pulumi.Input['ForwardProxyArgs']]):
        pulumi.set(self, "forward_proxy", value)

    @property
    @pulumi.getter(name="requireHttps")
    def require_https(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "require_https")

    @require_https.setter
    def require_https(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_https", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input['HttpSettingsRoutesArgs']]:
        """
        The configuration settings of the paths HTTP requests.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input['HttpSettingsRoutesArgs']]):
        pulumi.set(self, "routes", value)


@pulumi.input_type
class IdentityProvidersArgs:
    def __init__(__self__, *,
                 apple: Optional[pulumi.Input['AppleArgs']] = None,
                 azure_active_directory: Optional[pulumi.Input['AzureActiveDirectoryArgs']] = None,
                 azure_static_web_apps: Optional[pulumi.Input['AzureStaticWebAppsArgs']] = None,
                 custom_open_id_connect_providers: Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]] = None,
                 facebook: Optional[pulumi.Input['FacebookArgs']] = None,
                 git_hub: Optional[pulumi.Input['GitHubArgs']] = None,
                 google: Optional[pulumi.Input['GoogleArgs']] = None,
                 twitter: Optional[pulumi.Input['TwitterArgs']] = None):
        """
        The configuration settings of each of the identity providers used to configure ContainerApp Service Authentication/Authorization.
        :param pulumi.Input['AppleArgs'] apple: The configuration settings of the Apple provider.
        :param pulumi.Input['AzureActiveDirectoryArgs'] azure_active_directory: The configuration settings of the Azure Active directory provider.
        :param pulumi.Input['AzureStaticWebAppsArgs'] azure_static_web_apps: The configuration settings of the Azure Static Web Apps provider.
        :param pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]] custom_open_id_connect_providers: The map of the name of the alias of each custom Open ID Connect provider to the
               configuration settings of the custom Open ID Connect provider.
        :param pulumi.Input['FacebookArgs'] facebook: The configuration settings of the Facebook provider.
        :param pulumi.Input['GitHubArgs'] git_hub: The configuration settings of the GitHub provider.
        :param pulumi.Input['GoogleArgs'] google: The configuration settings of the Google provider.
        :param pulumi.Input['TwitterArgs'] twitter: The configuration settings of the Twitter provider.
        """
        IdentityProvidersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apple=apple,
            azure_active_directory=azure_active_directory,
            azure_static_web_apps=azure_static_web_apps,
            custom_open_id_connect_providers=custom_open_id_connect_providers,
            facebook=facebook,
            git_hub=git_hub,
            google=google,
            twitter=twitter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apple: Optional[pulumi.Input['AppleArgs']] = None,
             azure_active_directory: Optional[pulumi.Input['AzureActiveDirectoryArgs']] = None,
             azure_static_web_apps: Optional[pulumi.Input['AzureStaticWebAppsArgs']] = None,
             custom_open_id_connect_providers: Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]] = None,
             facebook: Optional[pulumi.Input['FacebookArgs']] = None,
             git_hub: Optional[pulumi.Input['GitHubArgs']] = None,
             google: Optional[pulumi.Input['GoogleArgs']] = None,
             twitter: Optional[pulumi.Input['TwitterArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'azureActiveDirectory' in kwargs:
            azure_active_directory = kwargs['azureActiveDirectory']
        if 'azureStaticWebApps' in kwargs:
            azure_static_web_apps = kwargs['azureStaticWebApps']
        if 'customOpenIdConnectProviders' in kwargs:
            custom_open_id_connect_providers = kwargs['customOpenIdConnectProviders']
        if 'gitHub' in kwargs:
            git_hub = kwargs['gitHub']

        if apple is not None:
            _setter("apple", apple)
        if azure_active_directory is not None:
            _setter("azure_active_directory", azure_active_directory)
        if azure_static_web_apps is not None:
            _setter("azure_static_web_apps", azure_static_web_apps)
        if custom_open_id_connect_providers is not None:
            _setter("custom_open_id_connect_providers", custom_open_id_connect_providers)
        if facebook is not None:
            _setter("facebook", facebook)
        if git_hub is not None:
            _setter("git_hub", git_hub)
        if google is not None:
            _setter("google", google)
        if twitter is not None:
            _setter("twitter", twitter)

    @property
    @pulumi.getter
    def apple(self) -> Optional[pulumi.Input['AppleArgs']]:
        """
        The configuration settings of the Apple provider.
        """
        return pulumi.get(self, "apple")

    @apple.setter
    def apple(self, value: Optional[pulumi.Input['AppleArgs']]):
        pulumi.set(self, "apple", value)

    @property
    @pulumi.getter(name="azureActiveDirectory")
    def azure_active_directory(self) -> Optional[pulumi.Input['AzureActiveDirectoryArgs']]:
        """
        The configuration settings of the Azure Active directory provider.
        """
        return pulumi.get(self, "azure_active_directory")

    @azure_active_directory.setter
    def azure_active_directory(self, value: Optional[pulumi.Input['AzureActiveDirectoryArgs']]):
        pulumi.set(self, "azure_active_directory", value)

    @property
    @pulumi.getter(name="azureStaticWebApps")
    def azure_static_web_apps(self) -> Optional[pulumi.Input['AzureStaticWebAppsArgs']]:
        """
        The configuration settings of the Azure Static Web Apps provider.
        """
        return pulumi.get(self, "azure_static_web_apps")

    @azure_static_web_apps.setter
    def azure_static_web_apps(self, value: Optional[pulumi.Input['AzureStaticWebAppsArgs']]):
        pulumi.set(self, "azure_static_web_apps", value)

    @property
    @pulumi.getter(name="customOpenIdConnectProviders")
    def custom_open_id_connect_providers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]]:
        """
        The map of the name of the alias of each custom Open ID Connect provider to the
        configuration settings of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "custom_open_id_connect_providers")

    @custom_open_id_connect_providers.setter
    def custom_open_id_connect_providers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['CustomOpenIdConnectProviderArgs']]]]):
        pulumi.set(self, "custom_open_id_connect_providers", value)

    @property
    @pulumi.getter
    def facebook(self) -> Optional[pulumi.Input['FacebookArgs']]:
        """
        The configuration settings of the Facebook provider.
        """
        return pulumi.get(self, "facebook")

    @facebook.setter
    def facebook(self, value: Optional[pulumi.Input['FacebookArgs']]):
        pulumi.set(self, "facebook", value)

    @property
    @pulumi.getter(name="gitHub")
    def git_hub(self) -> Optional[pulumi.Input['GitHubArgs']]:
        """
        The configuration settings of the GitHub provider.
        """
        return pulumi.get(self, "git_hub")

    @git_hub.setter
    def git_hub(self, value: Optional[pulumi.Input['GitHubArgs']]):
        pulumi.set(self, "git_hub", value)

    @property
    @pulumi.getter
    def google(self) -> Optional[pulumi.Input['GoogleArgs']]:
        """
        The configuration settings of the Google provider.
        """
        return pulumi.get(self, "google")

    @google.setter
    def google(self, value: Optional[pulumi.Input['GoogleArgs']]):
        pulumi.set(self, "google", value)

    @property
    @pulumi.getter
    def twitter(self) -> Optional[pulumi.Input['TwitterArgs']]:
        """
        The configuration settings of the Twitter provider.
        """
        return pulumi.get(self, "twitter")

    @twitter.setter
    def twitter(self, value: Optional[pulumi.Input['TwitterArgs']]):
        pulumi.set(self, "twitter", value)


@pulumi.input_type
class IngressArgs:
    def __init__(__self__, *,
                 allow_insecure: Optional[pulumi.Input[bool]] = None,
                 custom_domains: Optional[pulumi.Input[Sequence[pulumi.Input['CustomDomainArgs']]]] = None,
                 external: Optional[pulumi.Input[bool]] = None,
                 target_port: Optional[pulumi.Input[int]] = None,
                 traffic: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficWeightArgs']]]] = None,
                 transport: Optional[pulumi.Input[Union[str, 'IngressTransportMethod']]] = None):
        """
        Container App Ingress configuration.
        :param pulumi.Input[bool] allow_insecure: Bool indicating if HTTP connections to is allowed. If set to false HTTP connections are automatically redirected to HTTPS connections
        :param pulumi.Input[Sequence[pulumi.Input['CustomDomainArgs']]] custom_domains: custom domain bindings for Container Apps' hostnames.
        :param pulumi.Input[bool] external: Bool indicating if app exposes an external http endpoint
        :param pulumi.Input[int] target_port: Target Port in containers for traffic from ingress
        :param pulumi.Input[Sequence[pulumi.Input['TrafficWeightArgs']]] traffic: Traffic weights for app's revisions
        :param pulumi.Input[Union[str, 'IngressTransportMethod']] transport: Ingress transport protocol
        """
        IngressArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_insecure=allow_insecure,
            custom_domains=custom_domains,
            external=external,
            target_port=target_port,
            traffic=traffic,
            transport=transport,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_insecure: Optional[pulumi.Input[bool]] = None,
             custom_domains: Optional[pulumi.Input[Sequence[pulumi.Input['CustomDomainArgs']]]] = None,
             external: Optional[pulumi.Input[bool]] = None,
             target_port: Optional[pulumi.Input[int]] = None,
             traffic: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficWeightArgs']]]] = None,
             transport: Optional[pulumi.Input[Union[str, 'IngressTransportMethod']]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowInsecure' in kwargs:
            allow_insecure = kwargs['allowInsecure']
        if 'customDomains' in kwargs:
            custom_domains = kwargs['customDomains']
        if 'targetPort' in kwargs:
            target_port = kwargs['targetPort']

        if allow_insecure is not None:
            _setter("allow_insecure", allow_insecure)
        if custom_domains is not None:
            _setter("custom_domains", custom_domains)
        if external is None:
            external = False
        if external is not None:
            _setter("external", external)
        if target_port is not None:
            _setter("target_port", target_port)
        if traffic is not None:
            _setter("traffic", traffic)
        if transport is not None:
            _setter("transport", transport)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Bool indicating if HTTP connections to is allowed. If set to false HTTP connections are automatically redirected to HTTPS connections
        """
        return pulumi.get(self, "allow_insecure")

    @allow_insecure.setter
    def allow_insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_insecure", value)

    @property
    @pulumi.getter(name="customDomains")
    def custom_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CustomDomainArgs']]]]:
        """
        custom domain bindings for Container Apps' hostnames.
        """
        return pulumi.get(self, "custom_domains")

    @custom_domains.setter
    def custom_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CustomDomainArgs']]]]):
        pulumi.set(self, "custom_domains", value)

    @property
    @pulumi.getter
    def external(self) -> Optional[pulumi.Input[bool]]:
        """
        Bool indicating if app exposes an external http endpoint
        """
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "external", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[int]]:
        """
        Target Port in containers for traffic from ingress
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_port", value)

    @property
    @pulumi.getter
    def traffic(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TrafficWeightArgs']]]]:
        """
        Traffic weights for app's revisions
        """
        return pulumi.get(self, "traffic")

    @traffic.setter
    def traffic(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TrafficWeightArgs']]]]):
        pulumi.set(self, "traffic", value)

    @property
    @pulumi.getter
    def transport(self) -> Optional[pulumi.Input[Union[str, 'IngressTransportMethod']]]:
        """
        Ingress transport protocol
        """
        return pulumi.get(self, "transport")

    @transport.setter
    def transport(self, value: Optional[pulumi.Input[Union[str, 'IngressTransportMethod']]]):
        pulumi.set(self, "transport", value)


@pulumi.input_type
class JwtClaimChecksArgs:
    def __init__(__self__, *,
                 allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The configuration settings of the checks that should be made while validating the JWT Claims.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_client_applications: The list of the allowed client applications.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_groups: The list of the allowed groups.
        """
        JwtClaimChecksArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_client_applications=allowed_client_applications,
            allowed_groups=allowed_groups,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             allowed_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedClientApplications' in kwargs:
            allowed_client_applications = kwargs['allowedClientApplications']
        if 'allowedGroups' in kwargs:
            allowed_groups = kwargs['allowedGroups']

        if allowed_client_applications is not None:
            _setter("allowed_client_applications", allowed_client_applications)
        if allowed_groups is not None:
            _setter("allowed_groups", allowed_groups)

    @property
    @pulumi.getter(name="allowedClientApplications")
    def allowed_client_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the allowed client applications.
        """
        return pulumi.get(self, "allowed_client_applications")

    @allowed_client_applications.setter
    def allowed_client_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_client_applications", value)

    @property
    @pulumi.getter(name="allowedGroups")
    def allowed_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the allowed groups.
        """
        return pulumi.get(self, "allowed_groups")

    @allowed_groups.setter
    def allowed_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_groups", value)


@pulumi.input_type
class LogAnalyticsConfigurationArgs:
    def __init__(__self__, *,
                 customer_id: Optional[pulumi.Input[str]] = None,
                 shared_key: Optional[pulumi.Input[str]] = None):
        """
        Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
        :param pulumi.Input[str] customer_id: Log analytics customer id
        :param pulumi.Input[str] shared_key: Log analytics customer key
        """
        LogAnalyticsConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            customer_id=customer_id,
            shared_key=shared_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             customer_id: Optional[pulumi.Input[str]] = None,
             shared_key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customerId' in kwargs:
            customer_id = kwargs['customerId']
        if 'sharedKey' in kwargs:
            shared_key = kwargs['sharedKey']

        if customer_id is not None:
            _setter("customer_id", customer_id)
        if shared_key is not None:
            _setter("shared_key", shared_key)

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[pulumi.Input[str]]:
        """
        Log analytics customer id
        """
        return pulumi.get(self, "customer_id")

    @customer_id.setter
    def customer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_id", value)

    @property
    @pulumi.getter(name="sharedKey")
    def shared_key(self) -> Optional[pulumi.Input[str]]:
        """
        Log analytics customer key
        """
        return pulumi.get(self, "shared_key")

    @shared_key.setter
    def shared_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_key", value)


@pulumi.input_type
class LoginRoutesArgs:
    def __init__(__self__, *,
                 logout_endpoint: Optional[pulumi.Input[str]] = None):
        """
        The routes that specify the endpoints used for login and logout requests.
        :param pulumi.Input[str] logout_endpoint: The endpoint at which a logout request should be made.
        """
        LoginRoutesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            logout_endpoint=logout_endpoint,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             logout_endpoint: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'logoutEndpoint' in kwargs:
            logout_endpoint = kwargs['logoutEndpoint']

        if logout_endpoint is not None:
            _setter("logout_endpoint", logout_endpoint)

    @property
    @pulumi.getter(name="logoutEndpoint")
    def logout_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint at which a logout request should be made.
        """
        return pulumi.get(self, "logout_endpoint")

    @logout_endpoint.setter
    def logout_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_endpoint", value)


@pulumi.input_type
class LoginScopesArgs:
    def __init__(__self__, *,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The configuration settings of the login flow, including the scopes that should be requested.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: A list of the scopes that should be requested while authenticating.
        """
        LoginScopesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scopes=scopes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if scopes is not None:
            _setter("scopes", scopes)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)


@pulumi.input_type
class LoginArgs:
    def __init__(__self__, *,
                 allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cookie_expiration: Optional[pulumi.Input['CookieExpirationArgs']] = None,
                 nonce: Optional[pulumi.Input['NonceArgs']] = None,
                 preserve_url_fragments_for_logins: Optional[pulumi.Input[bool]] = None,
                 routes: Optional[pulumi.Input['LoginRoutesArgs']] = None):
        """
        The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_external_redirect_urls: External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
               This is an advanced setting typically only needed by Windows Store application backends.
               Note that URLs within the current domain are always implicitly allowed.
        :param pulumi.Input['CookieExpirationArgs'] cookie_expiration: The configuration settings of the session cookie's expiration.
        :param pulumi.Input['NonceArgs'] nonce: The configuration settings of the nonce used in the login flow.
        :param pulumi.Input[bool] preserve_url_fragments_for_logins: <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        :param pulumi.Input['LoginRoutesArgs'] routes: The routes that specify the endpoints used for login and logout requests.
        """
        LoginArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_external_redirect_urls=allowed_external_redirect_urls,
            cookie_expiration=cookie_expiration,
            nonce=nonce,
            preserve_url_fragments_for_logins=preserve_url_fragments_for_logins,
            routes=routes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_external_redirect_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             cookie_expiration: Optional[pulumi.Input['CookieExpirationArgs']] = None,
             nonce: Optional[pulumi.Input['NonceArgs']] = None,
             preserve_url_fragments_for_logins: Optional[pulumi.Input[bool]] = None,
             routes: Optional[pulumi.Input['LoginRoutesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedExternalRedirectUrls' in kwargs:
            allowed_external_redirect_urls = kwargs['allowedExternalRedirectUrls']
        if 'cookieExpiration' in kwargs:
            cookie_expiration = kwargs['cookieExpiration']
        if 'preserveUrlFragmentsForLogins' in kwargs:
            preserve_url_fragments_for_logins = kwargs['preserveUrlFragmentsForLogins']

        if allowed_external_redirect_urls is not None:
            _setter("allowed_external_redirect_urls", allowed_external_redirect_urls)
        if cookie_expiration is not None:
            _setter("cookie_expiration", cookie_expiration)
        if nonce is not None:
            _setter("nonce", nonce)
        if preserve_url_fragments_for_logins is not None:
            _setter("preserve_url_fragments_for_logins", preserve_url_fragments_for_logins)
        if routes is not None:
            _setter("routes", routes)

    @property
    @pulumi.getter(name="allowedExternalRedirectUrls")
    def allowed_external_redirect_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
        This is an advanced setting typically only needed by Windows Store application backends.
        Note that URLs within the current domain are always implicitly allowed.
        """
        return pulumi.get(self, "allowed_external_redirect_urls")

    @allowed_external_redirect_urls.setter
    def allowed_external_redirect_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_external_redirect_urls", value)

    @property
    @pulumi.getter(name="cookieExpiration")
    def cookie_expiration(self) -> Optional[pulumi.Input['CookieExpirationArgs']]:
        """
        The configuration settings of the session cookie's expiration.
        """
        return pulumi.get(self, "cookie_expiration")

    @cookie_expiration.setter
    def cookie_expiration(self, value: Optional[pulumi.Input['CookieExpirationArgs']]):
        pulumi.set(self, "cookie_expiration", value)

    @property
    @pulumi.getter
    def nonce(self) -> Optional[pulumi.Input['NonceArgs']]:
        """
        The configuration settings of the nonce used in the login flow.
        """
        return pulumi.get(self, "nonce")

    @nonce.setter
    def nonce(self, value: Optional[pulumi.Input['NonceArgs']]):
        pulumi.set(self, "nonce", value)

    @property
    @pulumi.getter(name="preserveUrlFragmentsForLogins")
    def preserve_url_fragments_for_logins(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        """
        return pulumi.get(self, "preserve_url_fragments_for_logins")

    @preserve_url_fragments_for_logins.setter
    def preserve_url_fragments_for_logins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_url_fragments_for_logins", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input['LoginRoutesArgs']]:
        """
        The routes that specify the endpoints used for login and logout requests.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input['LoginRoutesArgs']]):
        pulumi.set(self, "routes", value)


@pulumi.input_type
class ManagedEnvironmentStoragePropertiesArgs:
    def __init__(__self__, *,
                 azure_file: Optional[pulumi.Input['AzureFilePropertiesArgs']] = None):
        """
        Storage properties
        :param pulumi.Input['AzureFilePropertiesArgs'] azure_file: Azure file properties
        """
        ManagedEnvironmentStoragePropertiesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_file=azure_file,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_file: Optional[pulumi.Input['AzureFilePropertiesArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'azureFile' in kwargs:
            azure_file = kwargs['azureFile']

        if azure_file is not None:
            _setter("azure_file", azure_file)

    @property
    @pulumi.getter(name="azureFile")
    def azure_file(self) -> Optional[pulumi.Input['AzureFilePropertiesArgs']]:
        """
        Azure file properties
        """
        return pulumi.get(self, "azure_file")

    @azure_file.setter
    def azure_file(self, value: Optional[pulumi.Input['AzureFilePropertiesArgs']]):
        pulumi.set(self, "azure_file", value)


@pulumi.input_type
class ManagedServiceIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
                 user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Managed service identity (system assigned and/or user assigned identities)
        :param pulumi.Input[Union[str, 'ManagedServiceIdentityType']] type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_assigned_identities: The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        ManagedServiceIdentityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            user_assigned_identities=user_assigned_identities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[Union[str, 'ManagedServiceIdentityType']],
             user_assigned_identities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'userAssignedIdentities' in kwargs:
            user_assigned_identities = kwargs['userAssignedIdentities']

        _setter("type", type)
        if user_assigned_identities is not None:
            _setter("user_assigned_identities", user_assigned_identities)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[Union[str, 'ManagedServiceIdentityType']]:
        """
        Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[Union[str, 'ManagedServiceIdentityType']]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAssignedIdentities")
    def user_assigned_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
        """
        return pulumi.get(self, "user_assigned_identities")

    @user_assigned_identities.setter
    def user_assigned_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_assigned_identities", value)


@pulumi.input_type
class NonceArgs:
    def __init__(__self__, *,
                 nonce_expiration_interval: Optional[pulumi.Input[str]] = None,
                 validate_nonce: Optional[pulumi.Input[bool]] = None):
        """
        The configuration settings of the nonce used in the login flow.
        :param pulumi.Input[str] nonce_expiration_interval: The time after the request is made when the nonce should expire.
        :param pulumi.Input[bool] validate_nonce: <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
        NonceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            nonce_expiration_interval=nonce_expiration_interval,
            validate_nonce=validate_nonce,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             nonce_expiration_interval: Optional[pulumi.Input[str]] = None,
             validate_nonce: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'nonceExpirationInterval' in kwargs:
            nonce_expiration_interval = kwargs['nonceExpirationInterval']
        if 'validateNonce' in kwargs:
            validate_nonce = kwargs['validateNonce']

        if nonce_expiration_interval is not None:
            _setter("nonce_expiration_interval", nonce_expiration_interval)
        if validate_nonce is not None:
            _setter("validate_nonce", validate_nonce)

    @property
    @pulumi.getter(name="nonceExpirationInterval")
    def nonce_expiration_interval(self) -> Optional[pulumi.Input[str]]:
        """
        The time after the request is made when the nonce should expire.
        """
        return pulumi.get(self, "nonce_expiration_interval")

    @nonce_expiration_interval.setter
    def nonce_expiration_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nonce_expiration_interval", value)

    @property
    @pulumi.getter(name="validateNonce")
    def validate_nonce(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "validate_nonce")

    @validate_nonce.setter
    def validate_nonce(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_nonce", value)


@pulumi.input_type
class OpenIdConnectClientCredentialArgs:
    def __init__(__self__, *,
                 client_secret_setting_name: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input['ClientCredentialMethod']] = None):
        """
        The authentication client credentials of the custom Open ID Connect provider.
        :param pulumi.Input[str] client_secret_setting_name: The app setting that contains the client secret for the custom Open ID Connect provider.
        :param pulumi.Input['ClientCredentialMethod'] method: The method that should be used to authenticate the user.
        """
        OpenIdConnectClientCredentialArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_secret_setting_name=client_secret_setting_name,
            method=method,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_secret_setting_name: Optional[pulumi.Input[str]] = None,
             method: Optional[pulumi.Input['ClientCredentialMethod']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientSecretSettingName' in kwargs:
            client_secret_setting_name = kwargs['clientSecretSettingName']

        if client_secret_setting_name is not None:
            _setter("client_secret_setting_name", client_secret_setting_name)
        if method is not None:
            _setter("method", method)

    @property
    @pulumi.getter(name="clientSecretSettingName")
    def client_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting that contains the client secret for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_secret_setting_name")

    @client_secret_setting_name.setter
    def client_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret_setting_name", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input['ClientCredentialMethod']]:
        """
        The method that should be used to authenticate the user.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input['ClientCredentialMethod']]):
        pulumi.set(self, "method", value)


@pulumi.input_type
class OpenIdConnectConfigArgs:
    def __init__(__self__, *,
                 authorization_endpoint: Optional[pulumi.Input[str]] = None,
                 certification_uri: Optional[pulumi.Input[str]] = None,
                 issuer: Optional[pulumi.Input[str]] = None,
                 token_endpoint: Optional[pulumi.Input[str]] = None,
                 well_known_open_id_configuration: Optional[pulumi.Input[str]] = None):
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        :param pulumi.Input[str] authorization_endpoint: The endpoint to be used to make an authorization request.
        :param pulumi.Input[str] certification_uri: The endpoint that provides the keys necessary to validate the token.
        :param pulumi.Input[str] issuer: The endpoint that issues the token.
        :param pulumi.Input[str] token_endpoint: The endpoint to be used to request a token.
        :param pulumi.Input[str] well_known_open_id_configuration: The endpoint that contains all the configuration endpoints for the provider.
        """
        OpenIdConnectConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorization_endpoint=authorization_endpoint,
            certification_uri=certification_uri,
            issuer=issuer,
            token_endpoint=token_endpoint,
            well_known_open_id_configuration=well_known_open_id_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorization_endpoint: Optional[pulumi.Input[str]] = None,
             certification_uri: Optional[pulumi.Input[str]] = None,
             issuer: Optional[pulumi.Input[str]] = None,
             token_endpoint: Optional[pulumi.Input[str]] = None,
             well_known_open_id_configuration: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'authorizationEndpoint' in kwargs:
            authorization_endpoint = kwargs['authorizationEndpoint']
        if 'certificationUri' in kwargs:
            certification_uri = kwargs['certificationUri']
        if 'tokenEndpoint' in kwargs:
            token_endpoint = kwargs['tokenEndpoint']
        if 'wellKnownOpenIdConfiguration' in kwargs:
            well_known_open_id_configuration = kwargs['wellKnownOpenIdConfiguration']

        if authorization_endpoint is not None:
            _setter("authorization_endpoint", authorization_endpoint)
        if certification_uri is not None:
            _setter("certification_uri", certification_uri)
        if issuer is not None:
            _setter("issuer", issuer)
        if token_endpoint is not None:
            _setter("token_endpoint", token_endpoint)
        if well_known_open_id_configuration is not None:
            _setter("well_known_open_id_configuration", well_known_open_id_configuration)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to be used to make an authorization request.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="certificationUri")
    def certification_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that provides the keys necessary to validate the token.
        """
        return pulumi.get(self, "certification_uri")

    @certification_uri.setter
    def certification_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certification_uri", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that issues the token.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint to be used to request a token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_endpoint", value)

    @property
    @pulumi.getter(name="wellKnownOpenIdConfiguration")
    def well_known_open_id_configuration(self) -> Optional[pulumi.Input[str]]:
        """
        The endpoint that contains all the configuration endpoints for the provider.
        """
        return pulumi.get(self, "well_known_open_id_configuration")

    @well_known_open_id_configuration.setter
    def well_known_open_id_configuration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "well_known_open_id_configuration", value)


@pulumi.input_type
class OpenIdConnectLoginArgs:
    def __init__(__self__, *,
                 name_claim_type: Optional[pulumi.Input[str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The configuration settings of the login flow of the custom Open ID Connect provider.
        :param pulumi.Input[str] name_claim_type: The name of the claim that contains the users name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] scopes: A list of the scopes that should be requested while authenticating.
        """
        OpenIdConnectLoginArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name_claim_type=name_claim_type,
            scopes=scopes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name_claim_type: Optional[pulumi.Input[str]] = None,
             scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'nameClaimType' in kwargs:
            name_claim_type = kwargs['nameClaimType']

        if name_claim_type is not None:
            _setter("name_claim_type", name_claim_type)
        if scopes is not None:
            _setter("scopes", scopes)

    @property
    @pulumi.getter(name="nameClaimType")
    def name_claim_type(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the claim that contains the users name.
        """
        return pulumi.get(self, "name_claim_type")

    @name_claim_type.setter
    def name_claim_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_claim_type", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the scopes that should be requested while authenticating.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "scopes", value)


@pulumi.input_type
class OpenIdConnectRegistrationArgs:
    def __init__(__self__, *,
                 client_credential: Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 open_id_connect_configuration: Optional[pulumi.Input['OpenIdConnectConfigArgs']] = None):
        """
        The configuration settings of the app registration for the custom Open ID Connect provider.
        :param pulumi.Input['OpenIdConnectClientCredentialArgs'] client_credential: The authentication credentials of the custom Open ID Connect provider.
        :param pulumi.Input[str] client_id: The client id of the custom Open ID Connect provider.
        :param pulumi.Input['OpenIdConnectConfigArgs'] open_id_connect_configuration: The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        OpenIdConnectRegistrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_credential=client_credential,
            client_id=client_id,
            open_id_connect_configuration=open_id_connect_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_credential: Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']] = None,
             client_id: Optional[pulumi.Input[str]] = None,
             open_id_connect_configuration: Optional[pulumi.Input['OpenIdConnectConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientCredential' in kwargs:
            client_credential = kwargs['clientCredential']
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if 'openIdConnectConfiguration' in kwargs:
            open_id_connect_configuration = kwargs['openIdConnectConfiguration']

        if client_credential is not None:
            _setter("client_credential", client_credential)
        if client_id is not None:
            _setter("client_id", client_id)
        if open_id_connect_configuration is not None:
            _setter("open_id_connect_configuration", open_id_connect_configuration)

    @property
    @pulumi.getter(name="clientCredential")
    def client_credential(self) -> Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']]:
        """
        The authentication credentials of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_credential")

    @client_credential.setter
    def client_credential(self, value: Optional[pulumi.Input['OpenIdConnectClientCredentialArgs']]):
        pulumi.set(self, "client_credential", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The client id of the custom Open ID Connect provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="openIdConnectConfiguration")
    def open_id_connect_configuration(self) -> Optional[pulumi.Input['OpenIdConnectConfigArgs']]:
        """
        The configuration settings of the endpoints used for the custom Open ID Connect provider.
        """
        return pulumi.get(self, "open_id_connect_configuration")

    @open_id_connect_configuration.setter
    def open_id_connect_configuration(self, value: Optional[pulumi.Input['OpenIdConnectConfigArgs']]):
        pulumi.set(self, "open_id_connect_configuration", value)


@pulumi.input_type
class QueueScaleRuleArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
                 queue_length: Optional[pulumi.Input[int]] = None,
                 queue_name: Optional[pulumi.Input[str]] = None):
        """
        Container App container Azure Queue based scaling rule.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]] auth: Authentication secrets for the queue scale rule.
        :param pulumi.Input[int] queue_length: Queue length.
        :param pulumi.Input[str] queue_name: Queue name.
        """
        QueueScaleRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth=auth,
            queue_length=queue_length,
            queue_name=queue_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]] = None,
             queue_length: Optional[pulumi.Input[int]] = None,
             queue_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'queueLength' in kwargs:
            queue_length = kwargs['queueLength']
        if 'queueName' in kwargs:
            queue_name = kwargs['queueName']

        if auth is not None:
            _setter("auth", auth)
        if queue_length is not None:
            _setter("queue_length", queue_length)
        if queue_name is not None:
            _setter("queue_name", queue_name)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]:
        """
        Authentication secrets for the queue scale rule.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleAuthArgs']]]]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="queueLength")
    def queue_length(self) -> Optional[pulumi.Input[int]]:
        """
        Queue length.
        """
        return pulumi.get(self, "queue_length")

    @queue_length.setter
    def queue_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "queue_length", value)

    @property
    @pulumi.getter(name="queueName")
    def queue_name(self) -> Optional[pulumi.Input[str]]:
        """
        Queue name.
        """
        return pulumi.get(self, "queue_name")

    @queue_name.setter
    def queue_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "queue_name", value)


@pulumi.input_type
class RegistryCredentialsArgs:
    def __init__(__self__, *,
                 password_secret_ref: Optional[pulumi.Input[str]] = None,
                 server: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        Container App Private Registry
        :param pulumi.Input[str] password_secret_ref: The name of the Secret that contains the registry login password
        :param pulumi.Input[str] server: Container Registry Server
        :param pulumi.Input[str] username: Container Registry Username
        """
        RegistryCredentialsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password_secret_ref=password_secret_ref,
            server=server,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password_secret_ref: Optional[pulumi.Input[str]] = None,
             server: Optional[pulumi.Input[str]] = None,
             username: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'passwordSecretRef' in kwargs:
            password_secret_ref = kwargs['passwordSecretRef']

        if password_secret_ref is not None:
            _setter("password_secret_ref", password_secret_ref)
        if server is not None:
            _setter("server", server)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter(name="passwordSecretRef")
    def password_secret_ref(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Secret that contains the registry login password
        """
        return pulumi.get(self, "password_secret_ref")

    @password_secret_ref.setter
    def password_secret_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password_secret_ref", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[str]]:
        """
        Container Registry Server
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Container Registry Username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class RegistryInfoArgs:
    def __init__(__self__, *,
                 registry_password: Optional[pulumi.Input[str]] = None,
                 registry_url: Optional[pulumi.Input[str]] = None,
                 registry_user_name: Optional[pulumi.Input[str]] = None):
        """
        Container App registry information.
        :param pulumi.Input[str] registry_password: registry secret.
        :param pulumi.Input[str] registry_url: registry server Url.
        :param pulumi.Input[str] registry_user_name: registry username.
        """
        RegistryInfoArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            registry_password=registry_password,
            registry_url=registry_url,
            registry_user_name=registry_user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             registry_password: Optional[pulumi.Input[str]] = None,
             registry_url: Optional[pulumi.Input[str]] = None,
             registry_user_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'registryPassword' in kwargs:
            registry_password = kwargs['registryPassword']
        if 'registryUrl' in kwargs:
            registry_url = kwargs['registryUrl']
        if 'registryUserName' in kwargs:
            registry_user_name = kwargs['registryUserName']

        if registry_password is not None:
            _setter("registry_password", registry_password)
        if registry_url is not None:
            _setter("registry_url", registry_url)
        if registry_user_name is not None:
            _setter("registry_user_name", registry_user_name)

    @property
    @pulumi.getter(name="registryPassword")
    def registry_password(self) -> Optional[pulumi.Input[str]]:
        """
        registry secret.
        """
        return pulumi.get(self, "registry_password")

    @registry_password.setter
    def registry_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_password", value)

    @property
    @pulumi.getter(name="registryUrl")
    def registry_url(self) -> Optional[pulumi.Input[str]]:
        """
        registry server Url.
        """
        return pulumi.get(self, "registry_url")

    @registry_url.setter
    def registry_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_url", value)

    @property
    @pulumi.getter(name="registryUserName")
    def registry_user_name(self) -> Optional[pulumi.Input[str]]:
        """
        registry username.
        """
        return pulumi.get(self, "registry_user_name")

    @registry_user_name.setter
    def registry_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_user_name", value)


@pulumi.input_type
class ScaleRuleAuthArgs:
    def __init__(__self__, *,
                 secret_ref: Optional[pulumi.Input[str]] = None,
                 trigger_parameter: Optional[pulumi.Input[str]] = None):
        """
        Auth Secrets for Container App Scale Rule
        :param pulumi.Input[str] secret_ref: Name of the Container App secret from which to pull the auth params.
        :param pulumi.Input[str] trigger_parameter: Trigger Parameter that uses the secret
        """
        ScaleRuleAuthArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_ref=secret_ref,
            trigger_parameter=trigger_parameter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_ref: Optional[pulumi.Input[str]] = None,
             trigger_parameter: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretRef' in kwargs:
            secret_ref = kwargs['secretRef']
        if 'triggerParameter' in kwargs:
            trigger_parameter = kwargs['triggerParameter']

        if secret_ref is not None:
            _setter("secret_ref", secret_ref)
        if trigger_parameter is not None:
            _setter("trigger_parameter", trigger_parameter)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Container App secret from which to pull the auth params.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_ref", value)

    @property
    @pulumi.getter(name="triggerParameter")
    def trigger_parameter(self) -> Optional[pulumi.Input[str]]:
        """
        Trigger Parameter that uses the secret
        """
        return pulumi.get(self, "trigger_parameter")

    @trigger_parameter.setter
    def trigger_parameter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_parameter", value)


@pulumi.input_type
class ScaleRuleArgs:
    def __init__(__self__, *,
                 azure_queue: Optional[pulumi.Input['QueueScaleRuleArgs']] = None,
                 custom: Optional[pulumi.Input['CustomScaleRuleArgs']] = None,
                 http: Optional[pulumi.Input['HttpScaleRuleArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Container App container scaling rule.
        :param pulumi.Input['QueueScaleRuleArgs'] azure_queue: Azure Queue based scaling.
        :param pulumi.Input['CustomScaleRuleArgs'] custom: Custom scale rule.
        :param pulumi.Input['HttpScaleRuleArgs'] http: HTTP requests based scaling.
        :param pulumi.Input[str] name: Scale Rule Name
        """
        ScaleRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_queue=azure_queue,
            custom=custom,
            http=http,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_queue: Optional[pulumi.Input['QueueScaleRuleArgs']] = None,
             custom: Optional[pulumi.Input['CustomScaleRuleArgs']] = None,
             http: Optional[pulumi.Input['HttpScaleRuleArgs']] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'azureQueue' in kwargs:
            azure_queue = kwargs['azureQueue']

        if azure_queue is not None:
            _setter("azure_queue", azure_queue)
        if custom is not None:
            _setter("custom", custom)
        if http is not None:
            _setter("http", http)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="azureQueue")
    def azure_queue(self) -> Optional[pulumi.Input['QueueScaleRuleArgs']]:
        """
        Azure Queue based scaling.
        """
        return pulumi.get(self, "azure_queue")

    @azure_queue.setter
    def azure_queue(self, value: Optional[pulumi.Input['QueueScaleRuleArgs']]):
        pulumi.set(self, "azure_queue", value)

    @property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input['CustomScaleRuleArgs']]:
        """
        Custom scale rule.
        """
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input['CustomScaleRuleArgs']]):
        pulumi.set(self, "custom", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['HttpScaleRuleArgs']]:
        """
        HTTP requests based scaling.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['HttpScaleRuleArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Scale Rule Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ScaleArgs:
    def __init__(__self__, *,
                 max_replicas: Optional[pulumi.Input[int]] = None,
                 min_replicas: Optional[pulumi.Input[int]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]]] = None):
        """
        Container App scaling configurations.
        :param pulumi.Input[int] max_replicas: Optional. Maximum number of container replicas. Defaults to 10 if not set.
        :param pulumi.Input[int] min_replicas: Optional. Minimum number of container replicas.
        :param pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]] rules: Scaling rules.
        """
        ScaleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_replicas=max_replicas,
            min_replicas=min_replicas,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_replicas: Optional[pulumi.Input[int]] = None,
             min_replicas: Optional[pulumi.Input[int]] = None,
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxReplicas' in kwargs:
            max_replicas = kwargs['maxReplicas']
        if 'minReplicas' in kwargs:
            min_replicas = kwargs['minReplicas']

        if max_replicas is None:
            max_replicas = 10
        if max_replicas is not None:
            _setter("max_replicas", max_replicas)
        if min_replicas is not None:
            _setter("min_replicas", min_replicas)
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. Maximum number of container replicas. Defaults to 10 if not set.
        """
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_replicas", value)

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Optional. Minimum number of container replicas.
        """
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_replicas", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]]]:
        """
        Scaling rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScaleRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class SecretArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        Secret definition.
        :param pulumi.Input[str] name: Secret Name.
        :param pulumi.Input[str] value: Secret Value.
        """
        SecretArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Secret Name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Secret Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TemplateArgs:
    def __init__(__self__, *,
                 containers: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]]] = None,
                 revision_suffix: Optional[pulumi.Input[str]] = None,
                 scale: Optional[pulumi.Input['ScaleArgs']] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]]] = None):
        """
        Container App versioned application definition.
        Defines the desired state of an immutable revision.
        Any changes to this section Will result in a new revision being created
        :param pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]] containers: List of container definitions for the Container App.
        :param pulumi.Input[str] revision_suffix: User friendly suffix that is appended to the revision name
        :param pulumi.Input['ScaleArgs'] scale: Scaling properties for the Container App.
        :param pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]] volumes: List of volume definitions for the Container App.
        """
        TemplateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            containers=containers,
            revision_suffix=revision_suffix,
            scale=scale,
            volumes=volumes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             containers: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]]] = None,
             revision_suffix: Optional[pulumi.Input[str]] = None,
             scale: Optional[pulumi.Input['ScaleArgs']] = None,
             volumes: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'revisionSuffix' in kwargs:
            revision_suffix = kwargs['revisionSuffix']

        if containers is not None:
            _setter("containers", containers)
        if revision_suffix is not None:
            _setter("revision_suffix", revision_suffix)
        if scale is not None:
            _setter("scale", scale)
        if volumes is not None:
            _setter("volumes", volumes)

    @property
    @pulumi.getter
    def containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]]]:
        """
        List of container definitions for the Container App.
        """
        return pulumi.get(self, "containers")

    @containers.setter
    def containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerArgs']]]]):
        pulumi.set(self, "containers", value)

    @property
    @pulumi.getter(name="revisionSuffix")
    def revision_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        User friendly suffix that is appended to the revision name
        """
        return pulumi.get(self, "revision_suffix")

    @revision_suffix.setter
    def revision_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "revision_suffix", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input['ScaleArgs']]:
        """
        Scaling properties for the Container App.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input['ScaleArgs']]):
        pulumi.set(self, "scale", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]]]:
        """
        List of volume definitions for the Container App.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeArgs']]]]):
        pulumi.set(self, "volumes", value)


@pulumi.input_type
class TrafficWeightArgs:
    def __init__(__self__, *,
                 latest_revision: Optional[pulumi.Input[bool]] = None,
                 revision_name: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        Traffic weight assigned to a revision
        :param pulumi.Input[bool] latest_revision: Indicates that the traffic weight belongs to a latest stable revision
        :param pulumi.Input[str] revision_name: Name of a revision
        :param pulumi.Input[int] weight: Traffic weight assigned to a revision
        """
        TrafficWeightArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            latest_revision=latest_revision,
            revision_name=revision_name,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             latest_revision: Optional[pulumi.Input[bool]] = None,
             revision_name: Optional[pulumi.Input[str]] = None,
             weight: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'latestRevision' in kwargs:
            latest_revision = kwargs['latestRevision']
        if 'revisionName' in kwargs:
            revision_name = kwargs['revisionName']

        if latest_revision is None:
            latest_revision = False
        if latest_revision is not None:
            _setter("latest_revision", latest_revision)
        if revision_name is not None:
            _setter("revision_name", revision_name)
        if weight is not None:
            _setter("weight", weight)

    @property
    @pulumi.getter(name="latestRevision")
    def latest_revision(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates that the traffic weight belongs to a latest stable revision
        """
        return pulumi.get(self, "latest_revision")

    @latest_revision.setter
    def latest_revision(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "latest_revision", value)

    @property
    @pulumi.getter(name="revisionName")
    def revision_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of a revision
        """
        return pulumi.get(self, "revision_name")

    @revision_name.setter
    def revision_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "revision_name", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Traffic weight assigned to a revision
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class TwitterRegistrationArgs:
    def __init__(__self__, *,
                 consumer_key: Optional[pulumi.Input[str]] = None,
                 consumer_secret_setting_name: Optional[pulumi.Input[str]] = None):
        """
        The configuration settings of the app registration for the Twitter provider.
        :param pulumi.Input[str] consumer_key: The OAuth 1.0a consumer key of the Twitter application used for sign-in.
               This setting is required for enabling Twitter Sign-In.
               Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        :param pulumi.Input[str] consumer_secret_setting_name: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
               application used for sign-in.
        """
        TwitterRegistrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            consumer_key=consumer_key,
            consumer_secret_setting_name=consumer_secret_setting_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             consumer_key: Optional[pulumi.Input[str]] = None,
             consumer_secret_setting_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'consumerKey' in kwargs:
            consumer_key = kwargs['consumerKey']
        if 'consumerSecretSettingName' in kwargs:
            consumer_secret_setting_name = kwargs['consumerSecretSettingName']

        if consumer_key is not None:
            _setter("consumer_key", consumer_key)
        if consumer_secret_setting_name is not None:
            _setter("consumer_secret_setting_name", consumer_secret_setting_name)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth 1.0a consumer key of the Twitter application used for sign-in.
        This setting is required for enabling Twitter Sign-In.
        Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecretSettingName")
    def consumer_secret_setting_name(self) -> Optional[pulumi.Input[str]]:
        """
        The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
        application used for sign-in.
        """
        return pulumi.get(self, "consumer_secret_setting_name")

    @consumer_secret_setting_name.setter
    def consumer_secret_setting_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_secret_setting_name", value)


@pulumi.input_type
class TwitterArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 registration: Optional[pulumi.Input['TwitterRegistrationArgs']] = None):
        """
        The configuration settings of the Twitter provider.
        :param pulumi.Input[bool] enabled: <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        :param pulumi.Input['TwitterRegistrationArgs'] registration: The configuration settings of the app registration for the Twitter provider.
        """
        TwitterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            registration=registration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             registration: Optional[pulumi.Input['TwitterRegistrationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if registration is not None:
            _setter("registration", registration)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def registration(self) -> Optional[pulumi.Input['TwitterRegistrationArgs']]:
        """
        The configuration settings of the app registration for the Twitter provider.
        """
        return pulumi.get(self, "registration")

    @registration.setter
    def registration(self, value: Optional[pulumi.Input['TwitterRegistrationArgs']]):
        pulumi.set(self, "registration", value)


@pulumi.input_type
class VnetConfigurationArgs:
    def __init__(__self__, *,
                 docker_bridge_cidr: Optional[pulumi.Input[str]] = None,
                 infrastructure_subnet_id: Optional[pulumi.Input[str]] = None,
                 internal: Optional[pulumi.Input[bool]] = None,
                 platform_reserved_cidr: Optional[pulumi.Input[str]] = None,
                 platform_reserved_dns_ip: Optional[pulumi.Input[str]] = None,
                 runtime_subnet_id: Optional[pulumi.Input[str]] = None):
        """
        Configuration properties for apps environment to join a Virtual Network
        :param pulumi.Input[str] docker_bridge_cidr: CIDR notation IP range assigned to the Docker bridge, network. Must not overlap with any other provided IP ranges.
        :param pulumi.Input[str] infrastructure_subnet_id: Resource ID of a subnet for infrastructure components. This subnet must be in the same VNET as the subnet defined in runtimeSubnetId. Must not overlap with any other provided IP ranges.
        :param pulumi.Input[bool] internal: Boolean indicating the environment only has an internal load balancer. These environments do not have a public static IP resource. They must provide runtimeSubnetId and infrastructureSubnetId if enabling this property
        :param pulumi.Input[str] platform_reserved_cidr: IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. Must not overlap with any other provided IP ranges.
        :param pulumi.Input[str] platform_reserved_dns_ip:  An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server.
        :param pulumi.Input[str] runtime_subnet_id: This field is deprecated and not used. If you wish to provide your own subnet that Container App containers are injected into, then you should leverage the infrastructureSubnetId.
        """
        VnetConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            docker_bridge_cidr=docker_bridge_cidr,
            infrastructure_subnet_id=infrastructure_subnet_id,
            internal=internal,
            platform_reserved_cidr=platform_reserved_cidr,
            platform_reserved_dns_ip=platform_reserved_dns_ip,
            runtime_subnet_id=runtime_subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             docker_bridge_cidr: Optional[pulumi.Input[str]] = None,
             infrastructure_subnet_id: Optional[pulumi.Input[str]] = None,
             internal: Optional[pulumi.Input[bool]] = None,
             platform_reserved_cidr: Optional[pulumi.Input[str]] = None,
             platform_reserved_dns_ip: Optional[pulumi.Input[str]] = None,
             runtime_subnet_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dockerBridgeCidr' in kwargs:
            docker_bridge_cidr = kwargs['dockerBridgeCidr']
        if 'infrastructureSubnetId' in kwargs:
            infrastructure_subnet_id = kwargs['infrastructureSubnetId']
        if 'platformReservedCidr' in kwargs:
            platform_reserved_cidr = kwargs['platformReservedCidr']
        if 'platformReservedDnsIP' in kwargs:
            platform_reserved_dns_ip = kwargs['platformReservedDnsIP']
        if 'runtimeSubnetId' in kwargs:
            runtime_subnet_id = kwargs['runtimeSubnetId']

        if docker_bridge_cidr is not None:
            _setter("docker_bridge_cidr", docker_bridge_cidr)
        if infrastructure_subnet_id is not None:
            _setter("infrastructure_subnet_id", infrastructure_subnet_id)
        if internal is not None:
            _setter("internal", internal)
        if platform_reserved_cidr is not None:
            _setter("platform_reserved_cidr", platform_reserved_cidr)
        if platform_reserved_dns_ip is not None:
            _setter("platform_reserved_dns_ip", platform_reserved_dns_ip)
        if runtime_subnet_id is not None:
            _setter("runtime_subnet_id", runtime_subnet_id)

    @property
    @pulumi.getter(name="dockerBridgeCidr")
    def docker_bridge_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        CIDR notation IP range assigned to the Docker bridge, network. Must not overlap with any other provided IP ranges.
        """
        return pulumi.get(self, "docker_bridge_cidr")

    @docker_bridge_cidr.setter
    def docker_bridge_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_bridge_cidr", value)

    @property
    @pulumi.getter(name="infrastructureSubnetId")
    def infrastructure_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Resource ID of a subnet for infrastructure components. This subnet must be in the same VNET as the subnet defined in runtimeSubnetId. Must not overlap with any other provided IP ranges.
        """
        return pulumi.get(self, "infrastructure_subnet_id")

    @infrastructure_subnet_id.setter
    def infrastructure_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "infrastructure_subnet_id", value)

    @property
    @pulumi.getter
    def internal(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean indicating the environment only has an internal load balancer. These environments do not have a public static IP resource. They must provide runtimeSubnetId and infrastructureSubnetId if enabling this property
        """
        return pulumi.get(self, "internal")

    @internal.setter
    def internal(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "internal", value)

    @property
    @pulumi.getter(name="platformReservedCidr")
    def platform_reserved_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. Must not overlap with any other provided IP ranges.
        """
        return pulumi.get(self, "platform_reserved_cidr")

    @platform_reserved_cidr.setter
    def platform_reserved_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform_reserved_cidr", value)

    @property
    @pulumi.getter(name="platformReservedDnsIP")
    def platform_reserved_dns_ip(self) -> Optional[pulumi.Input[str]]:
        """
         An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server.
        """
        return pulumi.get(self, "platform_reserved_dns_ip")

    @platform_reserved_dns_ip.setter
    def platform_reserved_dns_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform_reserved_dns_ip", value)

    @property
    @pulumi.getter(name="runtimeSubnetId")
    def runtime_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        This field is deprecated and not used. If you wish to provide your own subnet that Container App containers are injected into, then you should leverage the infrastructureSubnetId.
        """
        return pulumi.get(self, "runtime_subnet_id")

    @runtime_subnet_id.setter
    def runtime_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_subnet_id", value)


@pulumi.input_type
class VolumeMountArgs:
    def __init__(__self__, *,
                 mount_path: Optional[pulumi.Input[str]] = None,
                 volume_name: Optional[pulumi.Input[str]] = None):
        """
        Volume mount for the Container App.
        :param pulumi.Input[str] mount_path: Path within the container at which the volume should be mounted.Must not contain ':'.
        :param pulumi.Input[str] volume_name: This must match the Name of a Volume.
        """
        VolumeMountArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mount_path=mount_path,
            volume_name=volume_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mount_path: Optional[pulumi.Input[str]] = None,
             volume_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mountPath' in kwargs:
            mount_path = kwargs['mountPath']
        if 'volumeName' in kwargs:
            volume_name = kwargs['volumeName']

        if mount_path is not None:
            _setter("mount_path", mount_path)
        if volume_name is not None:
            _setter("volume_name", volume_name)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path within the container at which the volume should be mounted.Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[pulumi.Input[str]]:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "volume_name")

    @volume_name.setter
    def volume_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_name", value)


@pulumi.input_type
class VolumeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 storage_name: Optional[pulumi.Input[str]] = None,
                 storage_type: Optional[pulumi.Input[Union[str, 'StorageType']]] = None):
        """
        Volume definitions for the Container App.
        :param pulumi.Input[str] name: Volume name.
        :param pulumi.Input[str] storage_name: Name of storage resource. No need to provide for EmptyDir.
        :param pulumi.Input[Union[str, 'StorageType']] storage_type: Storage type for the volume. If not provided, use EmptyDir.
        """
        VolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            storage_name=storage_name,
            storage_type=storage_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             storage_name: Optional[pulumi.Input[str]] = None,
             storage_type: Optional[pulumi.Input[Union[str, 'StorageType']]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'storageName' in kwargs:
            storage_name = kwargs['storageName']
        if 'storageType' in kwargs:
            storage_type = kwargs['storageType']

        if name is not None:
            _setter("name", name)
        if storage_name is not None:
            _setter("storage_name", storage_name)
        if storage_type is not None:
            _setter("storage_type", storage_type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Volume name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="storageName")
    def storage_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of storage resource. No need to provide for EmptyDir.
        """
        return pulumi.get(self, "storage_name")

    @storage_name.setter
    def storage_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_name", value)

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[Union[str, 'StorageType']]]:
        """
        Storage type for the volume. If not provided, use EmptyDir.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[Union[str, 'StorageType']]]):
        pulumi.set(self, "storage_type", value)


