# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AuthorizationActionMappingResponse',
    'DefaultRolloutPropertiesResponseSpecification',
    'DefaultRolloutPropertiesResponseStatus',
    'DefaultRolloutResponseProperties',
    'DefaultRolloutSpecificationResponseCanary',
    'DefaultRolloutSpecificationResponseExpeditedRollout',
    'DefaultRolloutSpecificationResponseHighTraffic',
    'DefaultRolloutSpecificationResponseLowTraffic',
    'DefaultRolloutSpecificationResponseMediumTraffic',
    'DefaultRolloutSpecificationResponseProviderRegistration',
    'DefaultRolloutSpecificationResponseRestOfTheWorldGroupOne',
    'DefaultRolloutSpecificationResponseRestOfTheWorldGroupTwo',
    'ExtendedErrorInfoResponse',
    'ExtendedLocationOptionsResponse',
    'LightHouseAuthorizationResponse',
    'LinkedAccessCheckResponse',
    'LoggingRuleResponse',
    'LoggingRuleResponseHiddenPropertyPaths',
    'NotificationEndpointResponse',
    'NotificationRegistrationResponseProperties',
    'OpenApiConfigurationResponse',
    'OpenApiValidationResponse',
    'ProviderHubMetadataResponseProviderAuthentication',
    'ProviderHubMetadataResponseThirdPartyProviderAuthorization',
    'ProviderRegistrationPropertiesResponseProviderHubMetadata',
    'ProviderRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications',
    'ProviderRegistrationResponseProperties',
    'ResourceConcurrencyControlOptionResponse',
    'ResourceProviderAuthorizationResponse',
    'ResourceProviderCapabilitiesResponse',
    'ResourceProviderManifestPropertiesResponseFeaturesRule',
    'ResourceProviderManifestPropertiesResponseManagement',
    'ResourceProviderManifestPropertiesResponseProviderAuthentication',
    'ResourceProviderManifestPropertiesResponseRequestHeaderOptions',
    'ResourceProviderManifestPropertiesResponseTemplateDeploymentOptions',
    'ResourceTypeEndpointResponse',
    'ResourceTypeEndpointResponseFeaturesRule',
    'ResourceTypeExtensionOptionsResponseResourceCreationBegin',
    'ResourceTypeExtensionResponse',
    'ResourceTypeRegistrationPropertiesResponseCheckNameAvailabilitySpecifications',
    'ResourceTypeRegistrationPropertiesResponseExtensionOptions',
    'ResourceTypeRegistrationPropertiesResponseFeaturesRule',
    'ResourceTypeRegistrationPropertiesResponseIdentityManagement',
    'ResourceTypeRegistrationPropertiesResponseManagement',
    'ResourceTypeRegistrationPropertiesResponseRequestHeaderOptions',
    'ResourceTypeRegistrationPropertiesResponseResourceGraphConfiguration',
    'ResourceTypeRegistrationPropertiesResponseResourceMovePolicy',
    'ResourceTypeRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications',
    'ResourceTypeRegistrationPropertiesResponseTemplateDeploymentOptions',
    'ResourceTypeRegistrationResponse',
    'ResourceTypeRegistrationResponseProperties',
    'ServiceTreeInfoResponse',
    'SkuCapabilityResponse',
    'SkuCostResponse',
    'SkuLocationInfoResponse',
    'SkuResourceResponseProperties',
    'SkuSettingResponse',
    'SkuSettingResponseCapacity',
    'SkuZoneDetailResponse',
    'SubscriptionStateOverrideActionResponse',
    'SubscriptionStateRuleResponse',
    'SwaggerSpecificationResponse',
    'SystemDataResponse',
    'ThrottlingMetricResponse',
    'ThrottlingRuleResponse',
    'TypedErrorInfoResponse',
]

@pulumi.output_type
class AuthorizationActionMappingResponse(dict):
    def __init__(__self__, *,
                 desired: Optional[str] = None,
                 original: Optional[str] = None):
        AuthorizationActionMappingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            desired=desired,
            original=original,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             desired: Optional[str] = None,
             original: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if desired is not None:
            _setter("desired", desired)
        if original is not None:
            _setter("original", original)

    @property
    @pulumi.getter
    def desired(self) -> Optional[str]:
        return pulumi.get(self, "desired")

    @property
    @pulumi.getter
    def original(self) -> Optional[str]:
        return pulumi.get(self, "original")


@pulumi.output_type
class DefaultRolloutPropertiesResponseSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expeditedRollout":
            suggest = "expedited_rollout"
        elif key == "highTraffic":
            suggest = "high_traffic"
        elif key == "lowTraffic":
            suggest = "low_traffic"
        elif key == "mediumTraffic":
            suggest = "medium_traffic"
        elif key == "providerRegistration":
            suggest = "provider_registration"
        elif key == "resourceTypeRegistrations":
            suggest = "resource_type_registrations"
        elif key == "restOfTheWorldGroupOne":
            suggest = "rest_of_the_world_group_one"
        elif key == "restOfTheWorldGroupTwo":
            suggest = "rest_of_the_world_group_two"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultRolloutPropertiesResponseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultRolloutPropertiesResponseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultRolloutPropertiesResponseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canary: Optional['outputs.DefaultRolloutSpecificationResponseCanary'] = None,
                 expedited_rollout: Optional['outputs.DefaultRolloutSpecificationResponseExpeditedRollout'] = None,
                 high_traffic: Optional['outputs.DefaultRolloutSpecificationResponseHighTraffic'] = None,
                 low_traffic: Optional['outputs.DefaultRolloutSpecificationResponseLowTraffic'] = None,
                 medium_traffic: Optional['outputs.DefaultRolloutSpecificationResponseMediumTraffic'] = None,
                 provider_registration: Optional['outputs.DefaultRolloutSpecificationResponseProviderRegistration'] = None,
                 resource_type_registrations: Optional[Sequence['outputs.ResourceTypeRegistrationResponse']] = None,
                 rest_of_the_world_group_one: Optional['outputs.DefaultRolloutSpecificationResponseRestOfTheWorldGroupOne'] = None,
                 rest_of_the_world_group_two: Optional['outputs.DefaultRolloutSpecificationResponseRestOfTheWorldGroupTwo'] = None):
        DefaultRolloutPropertiesResponseSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canary=canary,
            expedited_rollout=expedited_rollout,
            high_traffic=high_traffic,
            low_traffic=low_traffic,
            medium_traffic=medium_traffic,
            provider_registration=provider_registration,
            resource_type_registrations=resource_type_registrations,
            rest_of_the_world_group_one=rest_of_the_world_group_one,
            rest_of_the_world_group_two=rest_of_the_world_group_two,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canary: Optional['outputs.DefaultRolloutSpecificationResponseCanary'] = None,
             expedited_rollout: Optional['outputs.DefaultRolloutSpecificationResponseExpeditedRollout'] = None,
             high_traffic: Optional['outputs.DefaultRolloutSpecificationResponseHighTraffic'] = None,
             low_traffic: Optional['outputs.DefaultRolloutSpecificationResponseLowTraffic'] = None,
             medium_traffic: Optional['outputs.DefaultRolloutSpecificationResponseMediumTraffic'] = None,
             provider_registration: Optional['outputs.DefaultRolloutSpecificationResponseProviderRegistration'] = None,
             resource_type_registrations: Optional[Sequence['outputs.ResourceTypeRegistrationResponse']] = None,
             rest_of_the_world_group_one: Optional['outputs.DefaultRolloutSpecificationResponseRestOfTheWorldGroupOne'] = None,
             rest_of_the_world_group_two: Optional['outputs.DefaultRolloutSpecificationResponseRestOfTheWorldGroupTwo'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'expeditedRollout' in kwargs:
            expedited_rollout = kwargs['expeditedRollout']
        if 'highTraffic' in kwargs:
            high_traffic = kwargs['highTraffic']
        if 'lowTraffic' in kwargs:
            low_traffic = kwargs['lowTraffic']
        if 'mediumTraffic' in kwargs:
            medium_traffic = kwargs['mediumTraffic']
        if 'providerRegistration' in kwargs:
            provider_registration = kwargs['providerRegistration']
        if 'resourceTypeRegistrations' in kwargs:
            resource_type_registrations = kwargs['resourceTypeRegistrations']
        if 'restOfTheWorldGroupOne' in kwargs:
            rest_of_the_world_group_one = kwargs['restOfTheWorldGroupOne']
        if 'restOfTheWorldGroupTwo' in kwargs:
            rest_of_the_world_group_two = kwargs['restOfTheWorldGroupTwo']

        if canary is not None:
            _setter("canary", canary)
        if expedited_rollout is not None:
            _setter("expedited_rollout", expedited_rollout)
        if high_traffic is not None:
            _setter("high_traffic", high_traffic)
        if low_traffic is not None:
            _setter("low_traffic", low_traffic)
        if medium_traffic is not None:
            _setter("medium_traffic", medium_traffic)
        if provider_registration is not None:
            _setter("provider_registration", provider_registration)
        if resource_type_registrations is not None:
            _setter("resource_type_registrations", resource_type_registrations)
        if rest_of_the_world_group_one is not None:
            _setter("rest_of_the_world_group_one", rest_of_the_world_group_one)
        if rest_of_the_world_group_two is not None:
            _setter("rest_of_the_world_group_two", rest_of_the_world_group_two)

    @property
    @pulumi.getter
    def canary(self) -> Optional['outputs.DefaultRolloutSpecificationResponseCanary']:
        return pulumi.get(self, "canary")

    @property
    @pulumi.getter(name="expeditedRollout")
    def expedited_rollout(self) -> Optional['outputs.DefaultRolloutSpecificationResponseExpeditedRollout']:
        return pulumi.get(self, "expedited_rollout")

    @property
    @pulumi.getter(name="highTraffic")
    def high_traffic(self) -> Optional['outputs.DefaultRolloutSpecificationResponseHighTraffic']:
        return pulumi.get(self, "high_traffic")

    @property
    @pulumi.getter(name="lowTraffic")
    def low_traffic(self) -> Optional['outputs.DefaultRolloutSpecificationResponseLowTraffic']:
        return pulumi.get(self, "low_traffic")

    @property
    @pulumi.getter(name="mediumTraffic")
    def medium_traffic(self) -> Optional['outputs.DefaultRolloutSpecificationResponseMediumTraffic']:
        return pulumi.get(self, "medium_traffic")

    @property
    @pulumi.getter(name="providerRegistration")
    def provider_registration(self) -> Optional['outputs.DefaultRolloutSpecificationResponseProviderRegistration']:
        return pulumi.get(self, "provider_registration")

    @property
    @pulumi.getter(name="resourceTypeRegistrations")
    def resource_type_registrations(self) -> Optional[Sequence['outputs.ResourceTypeRegistrationResponse']]:
        return pulumi.get(self, "resource_type_registrations")

    @property
    @pulumi.getter(name="restOfTheWorldGroupOne")
    def rest_of_the_world_group_one(self) -> Optional['outputs.DefaultRolloutSpecificationResponseRestOfTheWorldGroupOne']:
        return pulumi.get(self, "rest_of_the_world_group_one")

    @property
    @pulumi.getter(name="restOfTheWorldGroupTwo")
    def rest_of_the_world_group_two(self) -> Optional['outputs.DefaultRolloutSpecificationResponseRestOfTheWorldGroupTwo']:
        return pulumi.get(self, "rest_of_the_world_group_two")


@pulumi.output_type
class DefaultRolloutPropertiesResponseStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "completedRegions":
            suggest = "completed_regions"
        elif key == "failedOrSkippedRegions":
            suggest = "failed_or_skipped_regions"
        elif key == "nextTrafficRegion":
            suggest = "next_traffic_region"
        elif key == "nextTrafficRegionScheduledTime":
            suggest = "next_traffic_region_scheduled_time"
        elif key == "subscriptionReregistrationResult":
            suggest = "subscription_reregistration_result"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultRolloutPropertiesResponseStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultRolloutPropertiesResponseStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultRolloutPropertiesResponseStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completed_regions: Optional[Sequence[str]] = None,
                 failed_or_skipped_regions: Optional[Mapping[str, 'outputs.ExtendedErrorInfoResponse']] = None,
                 next_traffic_region: Optional[str] = None,
                 next_traffic_region_scheduled_time: Optional[str] = None,
                 subscription_reregistration_result: Optional[str] = None):
        DefaultRolloutPropertiesResponseStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            completed_regions=completed_regions,
            failed_or_skipped_regions=failed_or_skipped_regions,
            next_traffic_region=next_traffic_region,
            next_traffic_region_scheduled_time=next_traffic_region_scheduled_time,
            subscription_reregistration_result=subscription_reregistration_result,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             completed_regions: Optional[Sequence[str]] = None,
             failed_or_skipped_regions: Optional[Mapping[str, 'outputs.ExtendedErrorInfoResponse']] = None,
             next_traffic_region: Optional[str] = None,
             next_traffic_region_scheduled_time: Optional[str] = None,
             subscription_reregistration_result: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'completedRegions' in kwargs:
            completed_regions = kwargs['completedRegions']
        if 'failedOrSkippedRegions' in kwargs:
            failed_or_skipped_regions = kwargs['failedOrSkippedRegions']
        if 'nextTrafficRegion' in kwargs:
            next_traffic_region = kwargs['nextTrafficRegion']
        if 'nextTrafficRegionScheduledTime' in kwargs:
            next_traffic_region_scheduled_time = kwargs['nextTrafficRegionScheduledTime']
        if 'subscriptionReregistrationResult' in kwargs:
            subscription_reregistration_result = kwargs['subscriptionReregistrationResult']

        if completed_regions is not None:
            _setter("completed_regions", completed_regions)
        if failed_or_skipped_regions is not None:
            _setter("failed_or_skipped_regions", failed_or_skipped_regions)
        if next_traffic_region is not None:
            _setter("next_traffic_region", next_traffic_region)
        if next_traffic_region_scheduled_time is not None:
            _setter("next_traffic_region_scheduled_time", next_traffic_region_scheduled_time)
        if subscription_reregistration_result is not None:
            _setter("subscription_reregistration_result", subscription_reregistration_result)

    @property
    @pulumi.getter(name="completedRegions")
    def completed_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "completed_regions")

    @property
    @pulumi.getter(name="failedOrSkippedRegions")
    def failed_or_skipped_regions(self) -> Optional[Mapping[str, 'outputs.ExtendedErrorInfoResponse']]:
        return pulumi.get(self, "failed_or_skipped_regions")

    @property
    @pulumi.getter(name="nextTrafficRegion")
    def next_traffic_region(self) -> Optional[str]:
        return pulumi.get(self, "next_traffic_region")

    @property
    @pulumi.getter(name="nextTrafficRegionScheduledTime")
    def next_traffic_region_scheduled_time(self) -> Optional[str]:
        return pulumi.get(self, "next_traffic_region_scheduled_time")

    @property
    @pulumi.getter(name="subscriptionReregistrationResult")
    def subscription_reregistration_result(self) -> Optional[str]:
        return pulumi.get(self, "subscription_reregistration_result")


@pulumi.output_type
class DefaultRolloutResponseProperties(dict):
    """
    Properties of the rollout.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultRolloutResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultRolloutResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultRolloutResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provisioning_state: Optional[str] = None,
                 specification: Optional['outputs.DefaultRolloutPropertiesResponseSpecification'] = None,
                 status: Optional['outputs.DefaultRolloutPropertiesResponseStatus'] = None):
        """
        Properties of the rollout.
        :param str provisioning_state: The provisioned state of the resource.
        """
        DefaultRolloutResponseProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provisioning_state=provisioning_state,
            specification=specification,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provisioning_state: Optional[str] = None,
             specification: Optional['outputs.DefaultRolloutPropertiesResponseSpecification'] = None,
             status: Optional['outputs.DefaultRolloutPropertiesResponseStatus'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']

        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if specification is not None:
            _setter("specification", specification)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioned state of the resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def specification(self) -> Optional['outputs.DefaultRolloutPropertiesResponseSpecification']:
        return pulumi.get(self, "specification")

    @property
    @pulumi.getter
    def status(self) -> Optional['outputs.DefaultRolloutPropertiesResponseStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class DefaultRolloutSpecificationResponseCanary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skipRegions":
            suggest = "skip_regions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultRolloutSpecificationResponseCanary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultRolloutSpecificationResponseCanary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultRolloutSpecificationResponseCanary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regions: Optional[Sequence[str]] = None,
                 skip_regions: Optional[Sequence[str]] = None):
        DefaultRolloutSpecificationResponseCanary._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regions=regions,
            skip_regions=skip_regions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regions: Optional[Sequence[str]] = None,
             skip_regions: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'skipRegions' in kwargs:
            skip_regions = kwargs['skipRegions']

        if regions is not None:
            _setter("regions", regions)
        if skip_regions is not None:
            _setter("skip_regions", skip_regions)

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="skipRegions")
    def skip_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "skip_regions")


@pulumi.output_type
class DefaultRolloutSpecificationResponseExpeditedRollout(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Indicates whether expedited rollout is enabled/disabled
        """
        DefaultRolloutSpecificationResponseExpeditedRollout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether expedited rollout is enabled/disabled
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class DefaultRolloutSpecificationResponseHighTraffic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitDuration":
            suggest = "wait_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultRolloutSpecificationResponseHighTraffic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultRolloutSpecificationResponseHighTraffic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultRolloutSpecificationResponseHighTraffic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regions: Optional[Sequence[str]] = None,
                 wait_duration: Optional[str] = None):
        DefaultRolloutSpecificationResponseHighTraffic._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regions=regions,
            wait_duration=wait_duration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regions: Optional[Sequence[str]] = None,
             wait_duration: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'waitDuration' in kwargs:
            wait_duration = kwargs['waitDuration']

        if regions is not None:
            _setter("regions", regions)
        if wait_duration is not None:
            _setter("wait_duration", wait_duration)

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="waitDuration")
    def wait_duration(self) -> Optional[str]:
        return pulumi.get(self, "wait_duration")


@pulumi.output_type
class DefaultRolloutSpecificationResponseLowTraffic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitDuration":
            suggest = "wait_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultRolloutSpecificationResponseLowTraffic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultRolloutSpecificationResponseLowTraffic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultRolloutSpecificationResponseLowTraffic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regions: Optional[Sequence[str]] = None,
                 wait_duration: Optional[str] = None):
        DefaultRolloutSpecificationResponseLowTraffic._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regions=regions,
            wait_duration=wait_duration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regions: Optional[Sequence[str]] = None,
             wait_duration: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'waitDuration' in kwargs:
            wait_duration = kwargs['waitDuration']

        if regions is not None:
            _setter("regions", regions)
        if wait_duration is not None:
            _setter("wait_duration", wait_duration)

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="waitDuration")
    def wait_duration(self) -> Optional[str]:
        return pulumi.get(self, "wait_duration")


@pulumi.output_type
class DefaultRolloutSpecificationResponseMediumTraffic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitDuration":
            suggest = "wait_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultRolloutSpecificationResponseMediumTraffic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultRolloutSpecificationResponseMediumTraffic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultRolloutSpecificationResponseMediumTraffic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regions: Optional[Sequence[str]] = None,
                 wait_duration: Optional[str] = None):
        DefaultRolloutSpecificationResponseMediumTraffic._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regions=regions,
            wait_duration=wait_duration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regions: Optional[Sequence[str]] = None,
             wait_duration: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'waitDuration' in kwargs:
            wait_duration = kwargs['waitDuration']

        if regions is not None:
            _setter("regions", regions)
        if wait_duration is not None:
            _setter("wait_duration", wait_duration)

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="waitDuration")
    def wait_duration(self) -> Optional[str]:
        return pulumi.get(self, "wait_duration")


@pulumi.output_type
class DefaultRolloutSpecificationResponseProviderRegistration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemData":
            suggest = "system_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultRolloutSpecificationResponseProviderRegistration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultRolloutSpecificationResponseProviderRegistration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultRolloutSpecificationResponseProviderRegistration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 system_data: 'outputs.SystemDataResponse',
                 type: str,
                 properties: Optional['outputs.ProviderRegistrationResponseProperties'] = None):
        """
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str name: The name of the resource
        :param 'SystemDataResponse' system_data: Metadata pertaining to creation and last modification of the resource.
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        DefaultRolloutSpecificationResponseProviderRegistration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            system_data=system_data,
            type=type,
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             name: str,
             system_data: 'outputs.SystemDataResponse',
             type: str,
             properties: Optional['outputs.ProviderRegistrationResponseProperties'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'systemData' in kwargs:
            system_data = kwargs['systemData']

        _setter("id", id)
        _setter("name", name)
        _setter("system_data", system_data)
        _setter("type", type)
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Metadata pertaining to creation and last modification of the resource.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.ProviderRegistrationResponseProperties']:
        return pulumi.get(self, "properties")


@pulumi.output_type
class DefaultRolloutSpecificationResponseRestOfTheWorldGroupOne(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitDuration":
            suggest = "wait_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultRolloutSpecificationResponseRestOfTheWorldGroupOne. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultRolloutSpecificationResponseRestOfTheWorldGroupOne.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultRolloutSpecificationResponseRestOfTheWorldGroupOne.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regions: Optional[Sequence[str]] = None,
                 wait_duration: Optional[str] = None):
        DefaultRolloutSpecificationResponseRestOfTheWorldGroupOne._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regions=regions,
            wait_duration=wait_duration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regions: Optional[Sequence[str]] = None,
             wait_duration: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'waitDuration' in kwargs:
            wait_duration = kwargs['waitDuration']

        if regions is not None:
            _setter("regions", regions)
        if wait_duration is not None:
            _setter("wait_duration", wait_duration)

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="waitDuration")
    def wait_duration(self) -> Optional[str]:
        return pulumi.get(self, "wait_duration")


@pulumi.output_type
class DefaultRolloutSpecificationResponseRestOfTheWorldGroupTwo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "waitDuration":
            suggest = "wait_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DefaultRolloutSpecificationResponseRestOfTheWorldGroupTwo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DefaultRolloutSpecificationResponseRestOfTheWorldGroupTwo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DefaultRolloutSpecificationResponseRestOfTheWorldGroupTwo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regions: Optional[Sequence[str]] = None,
                 wait_duration: Optional[str] = None):
        DefaultRolloutSpecificationResponseRestOfTheWorldGroupTwo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regions=regions,
            wait_duration=wait_duration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regions: Optional[Sequence[str]] = None,
             wait_duration: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'waitDuration' in kwargs:
            wait_duration = kwargs['waitDuration']

        if regions is not None:
            _setter("regions", regions)
        if wait_duration is not None:
            _setter("wait_duration", wait_duration)

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="waitDuration")
    def wait_duration(self) -> Optional[str]:
        return pulumi.get(self, "wait_duration")


@pulumi.output_type
class ExtendedErrorInfoResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalInfo":
            suggest = "additional_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExtendedErrorInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExtendedErrorInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExtendedErrorInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_info: Optional[Sequence['outputs.TypedErrorInfoResponse']] = None,
                 code: Optional[str] = None,
                 details: Optional[Sequence['outputs.ExtendedErrorInfoResponse']] = None,
                 message: Optional[str] = None,
                 target: Optional[str] = None):
        ExtendedErrorInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_info=additional_info,
            code=code,
            details=details,
            message=message,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_info: Optional[Sequence['outputs.TypedErrorInfoResponse']] = None,
             code: Optional[str] = None,
             details: Optional[Sequence['outputs.ExtendedErrorInfoResponse']] = None,
             message: Optional[str] = None,
             target: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'additionalInfo' in kwargs:
            additional_info = kwargs['additionalInfo']

        if additional_info is not None:
            _setter("additional_info", additional_info)
        if code is not None:
            _setter("code", code)
        if details is not None:
            _setter("details", details)
        if message is not None:
            _setter("message", message)
        if target is not None:
            _setter("target", target)

    @property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Optional[Sequence['outputs.TypedErrorInfoResponse']]:
        return pulumi.get(self, "additional_info")

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Optional[Sequence['outputs.ExtendedErrorInfoResponse']]:
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")


@pulumi.output_type
class ExtendedLocationOptionsResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supportedPolicy":
            suggest = "supported_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExtendedLocationOptionsResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExtendedLocationOptionsResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExtendedLocationOptionsResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 supported_policy: Optional[str] = None,
                 type: Optional[str] = None):
        ExtendedLocationOptionsResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            supported_policy=supported_policy,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             supported_policy: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'supportedPolicy' in kwargs:
            supported_policy = kwargs['supportedPolicy']

        if supported_policy is not None:
            _setter("supported_policy", supported_policy)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="supportedPolicy")
    def supported_policy(self) -> Optional[str]:
        return pulumi.get(self, "supported_policy")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class LightHouseAuthorizationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalId":
            suggest = "principal_id"
        elif key == "roleDefinitionId":
            suggest = "role_definition_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LightHouseAuthorizationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LightHouseAuthorizationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LightHouseAuthorizationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal_id: str,
                 role_definition_id: str):
        LightHouseAuthorizationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principal_id=principal_id,
            role_definition_id=role_definition_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principal_id: str,
             role_definition_id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'principalId' in kwargs:
            principal_id = kwargs['principalId']
        if 'roleDefinitionId' in kwargs:
            role_definition_id = kwargs['roleDefinitionId']

        _setter("principal_id", principal_id)
        _setter("role_definition_id", role_definition_id)

    @property
    @pulumi.getter(name="principalId")
    def principal_id(self) -> str:
        return pulumi.get(self, "principal_id")

    @property
    @pulumi.getter(name="roleDefinitionId")
    def role_definition_id(self) -> str:
        return pulumi.get(self, "role_definition_id")


@pulumi.output_type
class LinkedAccessCheckResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionName":
            suggest = "action_name"
        elif key == "linkedAction":
            suggest = "linked_action"
        elif key == "linkedActionVerb":
            suggest = "linked_action_verb"
        elif key == "linkedProperty":
            suggest = "linked_property"
        elif key == "linkedType":
            suggest = "linked_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LinkedAccessCheckResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LinkedAccessCheckResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LinkedAccessCheckResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_name: Optional[str] = None,
                 linked_action: Optional[str] = None,
                 linked_action_verb: Optional[str] = None,
                 linked_property: Optional[str] = None,
                 linked_type: Optional[str] = None):
        LinkedAccessCheckResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_name=action_name,
            linked_action=linked_action,
            linked_action_verb=linked_action_verb,
            linked_property=linked_property,
            linked_type=linked_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_name: Optional[str] = None,
             linked_action: Optional[str] = None,
             linked_action_verb: Optional[str] = None,
             linked_property: Optional[str] = None,
             linked_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'actionName' in kwargs:
            action_name = kwargs['actionName']
        if 'linkedAction' in kwargs:
            linked_action = kwargs['linkedAction']
        if 'linkedActionVerb' in kwargs:
            linked_action_verb = kwargs['linkedActionVerb']
        if 'linkedProperty' in kwargs:
            linked_property = kwargs['linkedProperty']
        if 'linkedType' in kwargs:
            linked_type = kwargs['linkedType']

        if action_name is not None:
            _setter("action_name", action_name)
        if linked_action is not None:
            _setter("linked_action", linked_action)
        if linked_action_verb is not None:
            _setter("linked_action_verb", linked_action_verb)
        if linked_property is not None:
            _setter("linked_property", linked_property)
        if linked_type is not None:
            _setter("linked_type", linked_type)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> Optional[str]:
        return pulumi.get(self, "action_name")

    @property
    @pulumi.getter(name="linkedAction")
    def linked_action(self) -> Optional[str]:
        return pulumi.get(self, "linked_action")

    @property
    @pulumi.getter(name="linkedActionVerb")
    def linked_action_verb(self) -> Optional[str]:
        return pulumi.get(self, "linked_action_verb")

    @property
    @pulumi.getter(name="linkedProperty")
    def linked_property(self) -> Optional[str]:
        return pulumi.get(self, "linked_property")

    @property
    @pulumi.getter(name="linkedType")
    def linked_type(self) -> Optional[str]:
        return pulumi.get(self, "linked_type")


@pulumi.output_type
class LoggingRuleResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detailLevel":
            suggest = "detail_level"
        elif key == "hiddenPropertyPaths":
            suggest = "hidden_property_paths"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 detail_level: str,
                 direction: str,
                 hidden_property_paths: Optional['outputs.LoggingRuleResponseHiddenPropertyPaths'] = None):
        LoggingRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            detail_level=detail_level,
            direction=direction,
            hidden_property_paths=hidden_property_paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             detail_level: str,
             direction: str,
             hidden_property_paths: Optional['outputs.LoggingRuleResponseHiddenPropertyPaths'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'detailLevel' in kwargs:
            detail_level = kwargs['detailLevel']
        if 'hiddenPropertyPaths' in kwargs:
            hidden_property_paths = kwargs['hiddenPropertyPaths']

        _setter("action", action)
        _setter("detail_level", detail_level)
        _setter("direction", direction)
        if hidden_property_paths is not None:
            _setter("hidden_property_paths", hidden_property_paths)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="detailLevel")
    def detail_level(self) -> str:
        return pulumi.get(self, "detail_level")

    @property
    @pulumi.getter
    def direction(self) -> str:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="hiddenPropertyPaths")
    def hidden_property_paths(self) -> Optional['outputs.LoggingRuleResponseHiddenPropertyPaths']:
        return pulumi.get(self, "hidden_property_paths")


@pulumi.output_type
class LoggingRuleResponseHiddenPropertyPaths(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hiddenPathsOnRequest":
            suggest = "hidden_paths_on_request"
        elif key == "hiddenPathsOnResponse":
            suggest = "hidden_paths_on_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoggingRuleResponseHiddenPropertyPaths. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoggingRuleResponseHiddenPropertyPaths.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoggingRuleResponseHiddenPropertyPaths.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hidden_paths_on_request: Optional[Sequence[str]] = None,
                 hidden_paths_on_response: Optional[Sequence[str]] = None):
        LoggingRuleResponseHiddenPropertyPaths._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hidden_paths_on_request=hidden_paths_on_request,
            hidden_paths_on_response=hidden_paths_on_response,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hidden_paths_on_request: Optional[Sequence[str]] = None,
             hidden_paths_on_response: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'hiddenPathsOnRequest' in kwargs:
            hidden_paths_on_request = kwargs['hiddenPathsOnRequest']
        if 'hiddenPathsOnResponse' in kwargs:
            hidden_paths_on_response = kwargs['hiddenPathsOnResponse']

        if hidden_paths_on_request is not None:
            _setter("hidden_paths_on_request", hidden_paths_on_request)
        if hidden_paths_on_response is not None:
            _setter("hidden_paths_on_response", hidden_paths_on_response)

    @property
    @pulumi.getter(name="hiddenPathsOnRequest")
    def hidden_paths_on_request(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hidden_paths_on_request")

    @property
    @pulumi.getter(name="hiddenPathsOnResponse")
    def hidden_paths_on_response(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hidden_paths_on_response")


@pulumi.output_type
class NotificationEndpointResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notificationDestination":
            suggest = "notification_destination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 locations: Optional[Sequence[str]] = None,
                 notification_destination: Optional[str] = None):
        NotificationEndpointResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            locations=locations,
            notification_destination=notification_destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             locations: Optional[Sequence[str]] = None,
             notification_destination: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'notificationDestination' in kwargs:
            notification_destination = kwargs['notificationDestination']

        if locations is not None:
            _setter("locations", locations)
        if notification_destination is not None:
            _setter("notification_destination", notification_destination)

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="notificationDestination")
    def notification_destination(self) -> Optional[str]:
        return pulumi.get(self, "notification_destination")


@pulumi.output_type
class NotificationRegistrationResponseProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includedEvents":
            suggest = "included_events"
        elif key == "messageScope":
            suggest = "message_scope"
        elif key == "notificationEndpoints":
            suggest = "notification_endpoints"
        elif key == "notificationMode":
            suggest = "notification_mode"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationRegistrationResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationRegistrationResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationRegistrationResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 included_events: Optional[Sequence[str]] = None,
                 message_scope: Optional[str] = None,
                 notification_endpoints: Optional[Sequence['outputs.NotificationEndpointResponse']] = None,
                 notification_mode: Optional[str] = None,
                 provisioning_state: Optional[str] = None):
        """
        :param str provisioning_state: The provisioned state of the resource.
        """
        NotificationRegistrationResponseProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            included_events=included_events,
            message_scope=message_scope,
            notification_endpoints=notification_endpoints,
            notification_mode=notification_mode,
            provisioning_state=provisioning_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             included_events: Optional[Sequence[str]] = None,
             message_scope: Optional[str] = None,
             notification_endpoints: Optional[Sequence['outputs.NotificationEndpointResponse']] = None,
             notification_mode: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'includedEvents' in kwargs:
            included_events = kwargs['includedEvents']
        if 'messageScope' in kwargs:
            message_scope = kwargs['messageScope']
        if 'notificationEndpoints' in kwargs:
            notification_endpoints = kwargs['notificationEndpoints']
        if 'notificationMode' in kwargs:
            notification_mode = kwargs['notificationMode']
        if 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']

        if included_events is not None:
            _setter("included_events", included_events)
        if message_scope is not None:
            _setter("message_scope", message_scope)
        if notification_endpoints is not None:
            _setter("notification_endpoints", notification_endpoints)
        if notification_mode is not None:
            _setter("notification_mode", notification_mode)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="includedEvents")
    def included_events(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "included_events")

    @property
    @pulumi.getter(name="messageScope")
    def message_scope(self) -> Optional[str]:
        return pulumi.get(self, "message_scope")

    @property
    @pulumi.getter(name="notificationEndpoints")
    def notification_endpoints(self) -> Optional[Sequence['outputs.NotificationEndpointResponse']]:
        return pulumi.get(self, "notification_endpoints")

    @property
    @pulumi.getter(name="notificationMode")
    def notification_mode(self) -> Optional[str]:
        return pulumi.get(self, "notification_mode")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioned state of the resource.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class OpenApiConfigurationResponse(dict):
    def __init__(__self__, *,
                 validation: Optional['outputs.OpenApiValidationResponse'] = None):
        OpenApiConfigurationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            validation=validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             validation: Optional['outputs.OpenApiValidationResponse'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if validation is not None:
            _setter("validation", validation)

    @property
    @pulumi.getter
    def validation(self) -> Optional['outputs.OpenApiValidationResponse']:
        return pulumi.get(self, "validation")


@pulumi.output_type
class OpenApiValidationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowNoncompliantCollectionResponse":
            suggest = "allow_noncompliant_collection_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OpenApiValidationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OpenApiValidationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OpenApiValidationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_noncompliant_collection_response: Optional[bool] = None):
        """
        :param bool allow_noncompliant_collection_response: Indicates whether a non compliance response is allowed for a LIST call
        """
        OpenApiValidationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_noncompliant_collection_response=allow_noncompliant_collection_response,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_noncompliant_collection_response: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowNoncompliantCollectionResponse' in kwargs:
            allow_noncompliant_collection_response = kwargs['allowNoncompliantCollectionResponse']

        if allow_noncompliant_collection_response is not None:
            _setter("allow_noncompliant_collection_response", allow_noncompliant_collection_response)

    @property
    @pulumi.getter(name="allowNoncompliantCollectionResponse")
    def allow_noncompliant_collection_response(self) -> Optional[bool]:
        """
        Indicates whether a non compliance response is allowed for a LIST call
        """
        return pulumi.get(self, "allow_noncompliant_collection_response")


@pulumi.output_type
class ProviderHubMetadataResponseProviderAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAudiences":
            suggest = "allowed_audiences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProviderHubMetadataResponseProviderAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProviderHubMetadataResponseProviderAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProviderHubMetadataResponseProviderAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_audiences: Sequence[str]):
        ProviderHubMetadataResponseProviderAuthentication._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_audiences=allowed_audiences,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_audiences: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedAudiences' in kwargs:
            allowed_audiences = kwargs['allowedAudiences']

        _setter("allowed_audiences", allowed_audiences)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_audiences")


@pulumi.output_type
class ProviderHubMetadataResponseThirdPartyProviderAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedByTenantId":
            suggest = "managed_by_tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProviderHubMetadataResponseThirdPartyProviderAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProviderHubMetadataResponseThirdPartyProviderAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProviderHubMetadataResponseThirdPartyProviderAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorizations: Optional[Sequence['outputs.LightHouseAuthorizationResponse']] = None,
                 managed_by_tenant_id: Optional[str] = None):
        ProviderHubMetadataResponseThirdPartyProviderAuthorization._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorizations=authorizations,
            managed_by_tenant_id=managed_by_tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorizations: Optional[Sequence['outputs.LightHouseAuthorizationResponse']] = None,
             managed_by_tenant_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'managedByTenantId' in kwargs:
            managed_by_tenant_id = kwargs['managedByTenantId']

        if authorizations is not None:
            _setter("authorizations", authorizations)
        if managed_by_tenant_id is not None:
            _setter("managed_by_tenant_id", managed_by_tenant_id)

    @property
    @pulumi.getter
    def authorizations(self) -> Optional[Sequence['outputs.LightHouseAuthorizationResponse']]:
        return pulumi.get(self, "authorizations")

    @property
    @pulumi.getter(name="managedByTenantId")
    def managed_by_tenant_id(self) -> Optional[str]:
        return pulumi.get(self, "managed_by_tenant_id")


@pulumi.output_type
class ProviderRegistrationPropertiesResponseProviderHubMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerAuthentication":
            suggest = "provider_authentication"
        elif key == "providerAuthorizations":
            suggest = "provider_authorizations"
        elif key == "thirdPartyProviderAuthorization":
            suggest = "third_party_provider_authorization"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProviderRegistrationPropertiesResponseProviderHubMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProviderRegistrationPropertiesResponseProviderHubMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProviderRegistrationPropertiesResponseProviderHubMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provider_authentication: Optional['outputs.ProviderHubMetadataResponseProviderAuthentication'] = None,
                 provider_authorizations: Optional[Sequence['outputs.ResourceProviderAuthorizationResponse']] = None,
                 third_party_provider_authorization: Optional['outputs.ProviderHubMetadataResponseThirdPartyProviderAuthorization'] = None):
        ProviderRegistrationPropertiesResponseProviderHubMetadata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            provider_authentication=provider_authentication,
            provider_authorizations=provider_authorizations,
            third_party_provider_authorization=third_party_provider_authorization,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             provider_authentication: Optional['outputs.ProviderHubMetadataResponseProviderAuthentication'] = None,
             provider_authorizations: Optional[Sequence['outputs.ResourceProviderAuthorizationResponse']] = None,
             third_party_provider_authorization: Optional['outputs.ProviderHubMetadataResponseThirdPartyProviderAuthorization'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'providerAuthentication' in kwargs:
            provider_authentication = kwargs['providerAuthentication']
        if 'providerAuthorizations' in kwargs:
            provider_authorizations = kwargs['providerAuthorizations']
        if 'thirdPartyProviderAuthorization' in kwargs:
            third_party_provider_authorization = kwargs['thirdPartyProviderAuthorization']

        if provider_authentication is not None:
            _setter("provider_authentication", provider_authentication)
        if provider_authorizations is not None:
            _setter("provider_authorizations", provider_authorizations)
        if third_party_provider_authorization is not None:
            _setter("third_party_provider_authorization", third_party_provider_authorization)

    @property
    @pulumi.getter(name="providerAuthentication")
    def provider_authentication(self) -> Optional['outputs.ProviderHubMetadataResponseProviderAuthentication']:
        return pulumi.get(self, "provider_authentication")

    @property
    @pulumi.getter(name="providerAuthorizations")
    def provider_authorizations(self) -> Optional[Sequence['outputs.ResourceProviderAuthorizationResponse']]:
        return pulumi.get(self, "provider_authorizations")

    @property
    @pulumi.getter(name="thirdPartyProviderAuthorization")
    def third_party_provider_authorization(self) -> Optional['outputs.ProviderHubMetadataResponseThirdPartyProviderAuthorization']:
        return pulumi.get(self, "third_party_provider_authorization")


@pulumi.output_type
class ProviderRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "softDeleteTTL":
            suggest = "soft_delete_ttl"
        elif key == "subscriptionStateOverrideActions":
            suggest = "subscription_state_override_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProviderRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProviderRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProviderRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 soft_delete_ttl: Optional[str] = None,
                 subscription_state_override_actions: Optional[Sequence['outputs.SubscriptionStateOverrideActionResponse']] = None):
        ProviderRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            soft_delete_ttl=soft_delete_ttl,
            subscription_state_override_actions=subscription_state_override_actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             soft_delete_ttl: Optional[str] = None,
             subscription_state_override_actions: Optional[Sequence['outputs.SubscriptionStateOverrideActionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'softDeleteTTL' in kwargs:
            soft_delete_ttl = kwargs['softDeleteTTL']
        if 'subscriptionStateOverrideActions' in kwargs:
            subscription_state_override_actions = kwargs['subscriptionStateOverrideActions']

        if soft_delete_ttl is not None:
            _setter("soft_delete_ttl", soft_delete_ttl)
        if subscription_state_override_actions is not None:
            _setter("subscription_state_override_actions", subscription_state_override_actions)

    @property
    @pulumi.getter(name="softDeleteTTL")
    def soft_delete_ttl(self) -> Optional[str]:
        return pulumi.get(self, "soft_delete_ttl")

    @property
    @pulumi.getter(name="subscriptionStateOverrideActions")
    def subscription_state_override_actions(self) -> Optional[Sequence['outputs.SubscriptionStateOverrideActionResponse']]:
        return pulumi.get(self, "subscription_state_override_actions")


@pulumi.output_type
class ProviderRegistrationResponseProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "featuresRule":
            suggest = "features_rule"
        elif key == "providerAuthentication":
            suggest = "provider_authentication"
        elif key == "providerAuthorizations":
            suggest = "provider_authorizations"
        elif key == "providerHubMetadata":
            suggest = "provider_hub_metadata"
        elif key == "providerType":
            suggest = "provider_type"
        elif key == "providerVersion":
            suggest = "provider_version"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "requestHeaderOptions":
            suggest = "request_header_options"
        elif key == "requiredFeatures":
            suggest = "required_features"
        elif key == "subscriptionLifecycleNotificationSpecifications":
            suggest = "subscription_lifecycle_notification_specifications"
        elif key == "templateDeploymentOptions":
            suggest = "template_deployment_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProviderRegistrationResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProviderRegistrationResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProviderRegistrationResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capabilities: Optional[Sequence['outputs.ResourceProviderCapabilitiesResponse']] = None,
                 features_rule: Optional['outputs.ResourceProviderManifestPropertiesResponseFeaturesRule'] = None,
                 management: Optional['outputs.ResourceProviderManifestPropertiesResponseManagement'] = None,
                 metadata: Optional[Any] = None,
                 namespace: Optional[str] = None,
                 provider_authentication: Optional['outputs.ResourceProviderManifestPropertiesResponseProviderAuthentication'] = None,
                 provider_authorizations: Optional[Sequence['outputs.ResourceProviderAuthorizationResponse']] = None,
                 provider_hub_metadata: Optional['outputs.ProviderRegistrationPropertiesResponseProviderHubMetadata'] = None,
                 provider_type: Optional[str] = None,
                 provider_version: Optional[str] = None,
                 provisioning_state: Optional[str] = None,
                 request_header_options: Optional['outputs.ResourceProviderManifestPropertiesResponseRequestHeaderOptions'] = None,
                 required_features: Optional[Sequence[str]] = None,
                 subscription_lifecycle_notification_specifications: Optional['outputs.ProviderRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications'] = None,
                 template_deployment_options: Optional['outputs.ResourceProviderManifestPropertiesResponseTemplateDeploymentOptions'] = None):
        """
        :param str provisioning_state: The provisioned state of the resource.
        """
        ProviderRegistrationResponseProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capabilities=capabilities,
            features_rule=features_rule,
            management=management,
            metadata=metadata,
            namespace=namespace,
            provider_authentication=provider_authentication,
            provider_authorizations=provider_authorizations,
            provider_hub_metadata=provider_hub_metadata,
            provider_type=provider_type,
            provider_version=provider_version,
            provisioning_state=provisioning_state,
            request_header_options=request_header_options,
            required_features=required_features,
            subscription_lifecycle_notification_specifications=subscription_lifecycle_notification_specifications,
            template_deployment_options=template_deployment_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capabilities: Optional[Sequence['outputs.ResourceProviderCapabilitiesResponse']] = None,
             features_rule: Optional['outputs.ResourceProviderManifestPropertiesResponseFeaturesRule'] = None,
             management: Optional['outputs.ResourceProviderManifestPropertiesResponseManagement'] = None,
             metadata: Optional[Any] = None,
             namespace: Optional[str] = None,
             provider_authentication: Optional['outputs.ResourceProviderManifestPropertiesResponseProviderAuthentication'] = None,
             provider_authorizations: Optional[Sequence['outputs.ResourceProviderAuthorizationResponse']] = None,
             provider_hub_metadata: Optional['outputs.ProviderRegistrationPropertiesResponseProviderHubMetadata'] = None,
             provider_type: Optional[str] = None,
             provider_version: Optional[str] = None,
             provisioning_state: Optional[str] = None,
             request_header_options: Optional['outputs.ResourceProviderManifestPropertiesResponseRequestHeaderOptions'] = None,
             required_features: Optional[Sequence[str]] = None,
             subscription_lifecycle_notification_specifications: Optional['outputs.ProviderRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications'] = None,
             template_deployment_options: Optional['outputs.ResourceProviderManifestPropertiesResponseTemplateDeploymentOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'featuresRule' in kwargs:
            features_rule = kwargs['featuresRule']
        if 'providerAuthentication' in kwargs:
            provider_authentication = kwargs['providerAuthentication']
        if 'providerAuthorizations' in kwargs:
            provider_authorizations = kwargs['providerAuthorizations']
        if 'providerHubMetadata' in kwargs:
            provider_hub_metadata = kwargs['providerHubMetadata']
        if 'providerType' in kwargs:
            provider_type = kwargs['providerType']
        if 'providerVersion' in kwargs:
            provider_version = kwargs['providerVersion']
        if 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if 'requestHeaderOptions' in kwargs:
            request_header_options = kwargs['requestHeaderOptions']
        if 'requiredFeatures' in kwargs:
            required_features = kwargs['requiredFeatures']
        if 'subscriptionLifecycleNotificationSpecifications' in kwargs:
            subscription_lifecycle_notification_specifications = kwargs['subscriptionLifecycleNotificationSpecifications']
        if 'templateDeploymentOptions' in kwargs:
            template_deployment_options = kwargs['templateDeploymentOptions']

        if capabilities is not None:
            _setter("capabilities", capabilities)
        if features_rule is not None:
            _setter("features_rule", features_rule)
        if management is not None:
            _setter("management", management)
        if metadata is not None:
            _setter("metadata", metadata)
        if namespace is not None:
            _setter("namespace", namespace)
        if provider_authentication is not None:
            _setter("provider_authentication", provider_authentication)
        if provider_authorizations is not None:
            _setter("provider_authorizations", provider_authorizations)
        if provider_hub_metadata is not None:
            _setter("provider_hub_metadata", provider_hub_metadata)
        if provider_type is not None:
            _setter("provider_type", provider_type)
        if provider_version is not None:
            _setter("provider_version", provider_version)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if request_header_options is not None:
            _setter("request_header_options", request_header_options)
        if required_features is not None:
            _setter("required_features", required_features)
        if subscription_lifecycle_notification_specifications is not None:
            _setter("subscription_lifecycle_notification_specifications", subscription_lifecycle_notification_specifications)
        if template_deployment_options is not None:
            _setter("template_deployment_options", template_deployment_options)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence['outputs.ResourceProviderCapabilitiesResponse']]:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter(name="featuresRule")
    def features_rule(self) -> Optional['outputs.ResourceProviderManifestPropertiesResponseFeaturesRule']:
        return pulumi.get(self, "features_rule")

    @property
    @pulumi.getter
    def management(self) -> Optional['outputs.ResourceProviderManifestPropertiesResponseManagement']:
        return pulumi.get(self, "management")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Any]:
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="providerAuthentication")
    def provider_authentication(self) -> Optional['outputs.ResourceProviderManifestPropertiesResponseProviderAuthentication']:
        return pulumi.get(self, "provider_authentication")

    @property
    @pulumi.getter(name="providerAuthorizations")
    def provider_authorizations(self) -> Optional[Sequence['outputs.ResourceProviderAuthorizationResponse']]:
        return pulumi.get(self, "provider_authorizations")

    @property
    @pulumi.getter(name="providerHubMetadata")
    def provider_hub_metadata(self) -> Optional['outputs.ProviderRegistrationPropertiesResponseProviderHubMetadata']:
        return pulumi.get(self, "provider_hub_metadata")

    @property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> Optional[str]:
        return pulumi.get(self, "provider_type")

    @property
    @pulumi.getter(name="providerVersion")
    def provider_version(self) -> Optional[str]:
        return pulumi.get(self, "provider_version")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioned state of the resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter(name="requestHeaderOptions")
    def request_header_options(self) -> Optional['outputs.ResourceProviderManifestPropertiesResponseRequestHeaderOptions']:
        return pulumi.get(self, "request_header_options")

    @property
    @pulumi.getter(name="requiredFeatures")
    def required_features(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "required_features")

    @property
    @pulumi.getter(name="subscriptionLifecycleNotificationSpecifications")
    def subscription_lifecycle_notification_specifications(self) -> Optional['outputs.ProviderRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications']:
        return pulumi.get(self, "subscription_lifecycle_notification_specifications")

    @property
    @pulumi.getter(name="templateDeploymentOptions")
    def template_deployment_options(self) -> Optional['outputs.ResourceProviderManifestPropertiesResponseTemplateDeploymentOptions']:
        return pulumi.get(self, "template_deployment_options")


@pulumi.output_type
class ResourceConcurrencyControlOptionResponse(dict):
    def __init__(__self__, *,
                 policy: Optional[str] = None):
        ResourceConcurrencyControlOptionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy=policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if policy is not None:
            _setter("policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        return pulumi.get(self, "policy")


@pulumi.output_type
class ResourceProviderAuthorizationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "managedByRoleDefinitionId":
            suggest = "managed_by_role_definition_id"
        elif key == "roleDefinitionId":
            suggest = "role_definition_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceProviderAuthorizationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceProviderAuthorizationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceProviderAuthorizationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 managed_by_role_definition_id: Optional[str] = None,
                 role_definition_id: Optional[str] = None):
        ResourceProviderAuthorizationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_id=application_id,
            managed_by_role_definition_id=managed_by_role_definition_id,
            role_definition_id=role_definition_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_id: Optional[str] = None,
             managed_by_role_definition_id: Optional[str] = None,
             role_definition_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'applicationId' in kwargs:
            application_id = kwargs['applicationId']
        if 'managedByRoleDefinitionId' in kwargs:
            managed_by_role_definition_id = kwargs['managedByRoleDefinitionId']
        if 'roleDefinitionId' in kwargs:
            role_definition_id = kwargs['roleDefinitionId']

        if application_id is not None:
            _setter("application_id", application_id)
        if managed_by_role_definition_id is not None:
            _setter("managed_by_role_definition_id", managed_by_role_definition_id)
        if role_definition_id is not None:
            _setter("role_definition_id", role_definition_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="managedByRoleDefinitionId")
    def managed_by_role_definition_id(self) -> Optional[str]:
        return pulumi.get(self, "managed_by_role_definition_id")

    @property
    @pulumi.getter(name="roleDefinitionId")
    def role_definition_id(self) -> Optional[str]:
        return pulumi.get(self, "role_definition_id")


@pulumi.output_type
class ResourceProviderCapabilitiesResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quotaId":
            suggest = "quota_id"
        elif key == "requiredFeatures":
            suggest = "required_features"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceProviderCapabilitiesResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceProviderCapabilitiesResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceProviderCapabilitiesResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effect: str,
                 quota_id: str,
                 required_features: Optional[Sequence[str]] = None):
        ResourceProviderCapabilitiesResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            quota_id=quota_id,
            required_features=required_features,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: str,
             quota_id: str,
             required_features: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'quotaId' in kwargs:
            quota_id = kwargs['quotaId']
        if 'requiredFeatures' in kwargs:
            required_features = kwargs['requiredFeatures']

        _setter("effect", effect)
        _setter("quota_id", quota_id)
        if required_features is not None:
            _setter("required_features", required_features)

    @property
    @pulumi.getter
    def effect(self) -> str:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter(name="quotaId")
    def quota_id(self) -> str:
        return pulumi.get(self, "quota_id")

    @property
    @pulumi.getter(name="requiredFeatures")
    def required_features(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "required_features")


@pulumi.output_type
class ResourceProviderManifestPropertiesResponseFeaturesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requiredFeaturesPolicy":
            suggest = "required_features_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceProviderManifestPropertiesResponseFeaturesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceProviderManifestPropertiesResponseFeaturesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceProviderManifestPropertiesResponseFeaturesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 required_features_policy: str):
        ResourceProviderManifestPropertiesResponseFeaturesRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            required_features_policy=required_features_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             required_features_policy: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'requiredFeaturesPolicy' in kwargs:
            required_features_policy = kwargs['requiredFeaturesPolicy']

        _setter("required_features_policy", required_features_policy)

    @property
    @pulumi.getter(name="requiredFeaturesPolicy")
    def required_features_policy(self) -> str:
        return pulumi.get(self, "required_features_policy")


@pulumi.output_type
class ResourceProviderManifestPropertiesResponseManagement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentContactEmail":
            suggest = "incident_contact_email"
        elif key == "incidentRoutingService":
            suggest = "incident_routing_service"
        elif key == "incidentRoutingTeam":
            suggest = "incident_routing_team"
        elif key == "manifestOwners":
            suggest = "manifest_owners"
        elif key == "resourceAccessPolicy":
            suggest = "resource_access_policy"
        elif key == "resourceAccessRoles":
            suggest = "resource_access_roles"
        elif key == "schemaOwners":
            suggest = "schema_owners"
        elif key == "serviceTreeInfos":
            suggest = "service_tree_infos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceProviderManifestPropertiesResponseManagement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceProviderManifestPropertiesResponseManagement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceProviderManifestPropertiesResponseManagement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_contact_email: Optional[str] = None,
                 incident_routing_service: Optional[str] = None,
                 incident_routing_team: Optional[str] = None,
                 manifest_owners: Optional[Sequence[str]] = None,
                 resource_access_policy: Optional[str] = None,
                 resource_access_roles: Optional[Sequence[Any]] = None,
                 schema_owners: Optional[Sequence[str]] = None,
                 service_tree_infos: Optional[Sequence['outputs.ServiceTreeInfoResponse']] = None):
        ResourceProviderManifestPropertiesResponseManagement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            incident_contact_email=incident_contact_email,
            incident_routing_service=incident_routing_service,
            incident_routing_team=incident_routing_team,
            manifest_owners=manifest_owners,
            resource_access_policy=resource_access_policy,
            resource_access_roles=resource_access_roles,
            schema_owners=schema_owners,
            service_tree_infos=service_tree_infos,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             incident_contact_email: Optional[str] = None,
             incident_routing_service: Optional[str] = None,
             incident_routing_team: Optional[str] = None,
             manifest_owners: Optional[Sequence[str]] = None,
             resource_access_policy: Optional[str] = None,
             resource_access_roles: Optional[Sequence[Any]] = None,
             schema_owners: Optional[Sequence[str]] = None,
             service_tree_infos: Optional[Sequence['outputs.ServiceTreeInfoResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'incidentContactEmail' in kwargs:
            incident_contact_email = kwargs['incidentContactEmail']
        if 'incidentRoutingService' in kwargs:
            incident_routing_service = kwargs['incidentRoutingService']
        if 'incidentRoutingTeam' in kwargs:
            incident_routing_team = kwargs['incidentRoutingTeam']
        if 'manifestOwners' in kwargs:
            manifest_owners = kwargs['manifestOwners']
        if 'resourceAccessPolicy' in kwargs:
            resource_access_policy = kwargs['resourceAccessPolicy']
        if 'resourceAccessRoles' in kwargs:
            resource_access_roles = kwargs['resourceAccessRoles']
        if 'schemaOwners' in kwargs:
            schema_owners = kwargs['schemaOwners']
        if 'serviceTreeInfos' in kwargs:
            service_tree_infos = kwargs['serviceTreeInfos']

        if incident_contact_email is not None:
            _setter("incident_contact_email", incident_contact_email)
        if incident_routing_service is not None:
            _setter("incident_routing_service", incident_routing_service)
        if incident_routing_team is not None:
            _setter("incident_routing_team", incident_routing_team)
        if manifest_owners is not None:
            _setter("manifest_owners", manifest_owners)
        if resource_access_policy is not None:
            _setter("resource_access_policy", resource_access_policy)
        if resource_access_roles is not None:
            _setter("resource_access_roles", resource_access_roles)
        if schema_owners is not None:
            _setter("schema_owners", schema_owners)
        if service_tree_infos is not None:
            _setter("service_tree_infos", service_tree_infos)

    @property
    @pulumi.getter(name="incidentContactEmail")
    def incident_contact_email(self) -> Optional[str]:
        return pulumi.get(self, "incident_contact_email")

    @property
    @pulumi.getter(name="incidentRoutingService")
    def incident_routing_service(self) -> Optional[str]:
        return pulumi.get(self, "incident_routing_service")

    @property
    @pulumi.getter(name="incidentRoutingTeam")
    def incident_routing_team(self) -> Optional[str]:
        return pulumi.get(self, "incident_routing_team")

    @property
    @pulumi.getter(name="manifestOwners")
    def manifest_owners(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "manifest_owners")

    @property
    @pulumi.getter(name="resourceAccessPolicy")
    def resource_access_policy(self) -> Optional[str]:
        return pulumi.get(self, "resource_access_policy")

    @property
    @pulumi.getter(name="resourceAccessRoles")
    def resource_access_roles(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "resource_access_roles")

    @property
    @pulumi.getter(name="schemaOwners")
    def schema_owners(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "schema_owners")

    @property
    @pulumi.getter(name="serviceTreeInfos")
    def service_tree_infos(self) -> Optional[Sequence['outputs.ServiceTreeInfoResponse']]:
        return pulumi.get(self, "service_tree_infos")


@pulumi.output_type
class ResourceProviderManifestPropertiesResponseProviderAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAudiences":
            suggest = "allowed_audiences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceProviderManifestPropertiesResponseProviderAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceProviderManifestPropertiesResponseProviderAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceProviderManifestPropertiesResponseProviderAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_audiences: Sequence[str]):
        ResourceProviderManifestPropertiesResponseProviderAuthentication._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_audiences=allowed_audiences,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_audiences: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedAudiences' in kwargs:
            allowed_audiences = kwargs['allowedAudiences']

        _setter("allowed_audiences", allowed_audiences)

    @property
    @pulumi.getter(name="allowedAudiences")
    def allowed_audiences(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_audiences")


@pulumi.output_type
class ResourceProviderManifestPropertiesResponseRequestHeaderOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optInHeaders":
            suggest = "opt_in_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceProviderManifestPropertiesResponseRequestHeaderOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceProviderManifestPropertiesResponseRequestHeaderOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceProviderManifestPropertiesResponseRequestHeaderOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 opt_in_headers: Optional[str] = None):
        ResourceProviderManifestPropertiesResponseRequestHeaderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            opt_in_headers=opt_in_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opt_in_headers: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'optInHeaders' in kwargs:
            opt_in_headers = kwargs['optInHeaders']

        if opt_in_headers is not None:
            _setter("opt_in_headers", opt_in_headers)

    @property
    @pulumi.getter(name="optInHeaders")
    def opt_in_headers(self) -> Optional[str]:
        return pulumi.get(self, "opt_in_headers")


@pulumi.output_type
class ResourceProviderManifestPropertiesResponseTemplateDeploymentOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preflightOptions":
            suggest = "preflight_options"
        elif key == "preflightSupported":
            suggest = "preflight_supported"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceProviderManifestPropertiesResponseTemplateDeploymentOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceProviderManifestPropertiesResponseTemplateDeploymentOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceProviderManifestPropertiesResponseTemplateDeploymentOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preflight_options: Optional[Sequence[str]] = None,
                 preflight_supported: Optional[bool] = None):
        ResourceProviderManifestPropertiesResponseTemplateDeploymentOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            preflight_options=preflight_options,
            preflight_supported=preflight_supported,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             preflight_options: Optional[Sequence[str]] = None,
             preflight_supported: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'preflightOptions' in kwargs:
            preflight_options = kwargs['preflightOptions']
        if 'preflightSupported' in kwargs:
            preflight_supported = kwargs['preflightSupported']

        if preflight_options is not None:
            _setter("preflight_options", preflight_options)
        if preflight_supported is not None:
            _setter("preflight_supported", preflight_supported)

    @property
    @pulumi.getter(name="preflightOptions")
    def preflight_options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "preflight_options")

    @property
    @pulumi.getter(name="preflightSupported")
    def preflight_supported(self) -> Optional[bool]:
        return pulumi.get(self, "preflight_supported")


@pulumi.output_type
class ResourceTypeEndpointResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersions":
            suggest = "api_versions"
        elif key == "endpointType":
            suggest = "endpoint_type"
        elif key == "featuresRule":
            suggest = "features_rule"
        elif key == "requiredFeatures":
            suggest = "required_features"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeEndpointResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeEndpointResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeEndpointResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_versions: Optional[Sequence[str]] = None,
                 enabled: Optional[bool] = None,
                 endpoint_type: Optional[str] = None,
                 extensions: Optional[Sequence['outputs.ResourceTypeExtensionResponse']] = None,
                 features_rule: Optional['outputs.ResourceTypeEndpointResponseFeaturesRule'] = None,
                 locations: Optional[Sequence[str]] = None,
                 required_features: Optional[Sequence[str]] = None,
                 timeout: Optional[str] = None):
        ResourceTypeEndpointResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_versions=api_versions,
            enabled=enabled,
            endpoint_type=endpoint_type,
            extensions=extensions,
            features_rule=features_rule,
            locations=locations,
            required_features=required_features,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_versions: Optional[Sequence[str]] = None,
             enabled: Optional[bool] = None,
             endpoint_type: Optional[str] = None,
             extensions: Optional[Sequence['outputs.ResourceTypeExtensionResponse']] = None,
             features_rule: Optional['outputs.ResourceTypeEndpointResponseFeaturesRule'] = None,
             locations: Optional[Sequence[str]] = None,
             required_features: Optional[Sequence[str]] = None,
             timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'apiVersions' in kwargs:
            api_versions = kwargs['apiVersions']
        if 'endpointType' in kwargs:
            endpoint_type = kwargs['endpointType']
        if 'featuresRule' in kwargs:
            features_rule = kwargs['featuresRule']
        if 'requiredFeatures' in kwargs:
            required_features = kwargs['requiredFeatures']

        if api_versions is not None:
            _setter("api_versions", api_versions)
        if enabled is not None:
            _setter("enabled", enabled)
        if endpoint_type is not None:
            _setter("endpoint_type", endpoint_type)
        if extensions is not None:
            _setter("extensions", extensions)
        if features_rule is not None:
            _setter("features_rule", features_rule)
        if locations is not None:
            _setter("locations", locations)
        if required_features is not None:
            _setter("required_features", required_features)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter(name="apiVersions")
    def api_versions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "api_versions")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[str]:
        return pulumi.get(self, "endpoint_type")

    @property
    @pulumi.getter
    def extensions(self) -> Optional[Sequence['outputs.ResourceTypeExtensionResponse']]:
        return pulumi.get(self, "extensions")

    @property
    @pulumi.getter(name="featuresRule")
    def features_rule(self) -> Optional['outputs.ResourceTypeEndpointResponseFeaturesRule']:
        return pulumi.get(self, "features_rule")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="requiredFeatures")
    def required_features(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "required_features")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ResourceTypeEndpointResponseFeaturesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requiredFeaturesPolicy":
            suggest = "required_features_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeEndpointResponseFeaturesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeEndpointResponseFeaturesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeEndpointResponseFeaturesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 required_features_policy: str):
        ResourceTypeEndpointResponseFeaturesRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            required_features_policy=required_features_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             required_features_policy: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'requiredFeaturesPolicy' in kwargs:
            required_features_policy = kwargs['requiredFeaturesPolicy']

        _setter("required_features_policy", required_features_policy)

    @property
    @pulumi.getter(name="requiredFeaturesPolicy")
    def required_features_policy(self) -> str:
        return pulumi.get(self, "required_features_policy")


@pulumi.output_type
class ResourceTypeExtensionOptionsResponseResourceCreationBegin(dict):
    def __init__(__self__, *,
                 request: Optional[Sequence[str]] = None,
                 response: Optional[Sequence[str]] = None):
        ResourceTypeExtensionOptionsResponseResourceCreationBegin._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            request=request,
            response=response,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             request: Optional[Sequence[str]] = None,
             response: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if request is not None:
            _setter("request", request)
        if response is not None:
            _setter("response", response)

    @property
    @pulumi.getter
    def request(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "response")


@pulumi.output_type
class ResourceTypeExtensionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointUri":
            suggest = "endpoint_uri"
        elif key == "extensionCategories":
            suggest = "extension_categories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeExtensionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeExtensionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeExtensionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_uri: Optional[str] = None,
                 extension_categories: Optional[Sequence[str]] = None,
                 timeout: Optional[str] = None):
        ResourceTypeExtensionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_uri=endpoint_uri,
            extension_categories=extension_categories,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_uri: Optional[str] = None,
             extension_categories: Optional[Sequence[str]] = None,
             timeout: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointUri' in kwargs:
            endpoint_uri = kwargs['endpointUri']
        if 'extensionCategories' in kwargs:
            extension_categories = kwargs['extensionCategories']

        if endpoint_uri is not None:
            _setter("endpoint_uri", endpoint_uri)
        if extension_categories is not None:
            _setter("extension_categories", extension_categories)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter(name="endpointUri")
    def endpoint_uri(self) -> Optional[str]:
        return pulumi.get(self, "endpoint_uri")

    @property
    @pulumi.getter(name="extensionCategories")
    def extension_categories(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "extension_categories")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ResourceTypeRegistrationPropertiesResponseCheckNameAvailabilitySpecifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableDefaultValidation":
            suggest = "enable_default_validation"
        elif key == "resourceTypesWithCustomValidation":
            suggest = "resource_types_with_custom_validation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeRegistrationPropertiesResponseCheckNameAvailabilitySpecifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeRegistrationPropertiesResponseCheckNameAvailabilitySpecifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeRegistrationPropertiesResponseCheckNameAvailabilitySpecifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_default_validation: Optional[bool] = None,
                 resource_types_with_custom_validation: Optional[Sequence[str]] = None):
        ResourceTypeRegistrationPropertiesResponseCheckNameAvailabilitySpecifications._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_default_validation=enable_default_validation,
            resource_types_with_custom_validation=resource_types_with_custom_validation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_default_validation: Optional[bool] = None,
             resource_types_with_custom_validation: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'enableDefaultValidation' in kwargs:
            enable_default_validation = kwargs['enableDefaultValidation']
        if 'resourceTypesWithCustomValidation' in kwargs:
            resource_types_with_custom_validation = kwargs['resourceTypesWithCustomValidation']

        if enable_default_validation is not None:
            _setter("enable_default_validation", enable_default_validation)
        if resource_types_with_custom_validation is not None:
            _setter("resource_types_with_custom_validation", resource_types_with_custom_validation)

    @property
    @pulumi.getter(name="enableDefaultValidation")
    def enable_default_validation(self) -> Optional[bool]:
        return pulumi.get(self, "enable_default_validation")

    @property
    @pulumi.getter(name="resourceTypesWithCustomValidation")
    def resource_types_with_custom_validation(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "resource_types_with_custom_validation")


@pulumi.output_type
class ResourceTypeRegistrationPropertiesResponseExtensionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceCreationBegin":
            suggest = "resource_creation_begin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeRegistrationPropertiesResponseExtensionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeRegistrationPropertiesResponseExtensionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeRegistrationPropertiesResponseExtensionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_creation_begin: Optional['outputs.ResourceTypeExtensionOptionsResponseResourceCreationBegin'] = None):
        ResourceTypeRegistrationPropertiesResponseExtensionOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_creation_begin=resource_creation_begin,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_creation_begin: Optional['outputs.ResourceTypeExtensionOptionsResponseResourceCreationBegin'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'resourceCreationBegin' in kwargs:
            resource_creation_begin = kwargs['resourceCreationBegin']

        if resource_creation_begin is not None:
            _setter("resource_creation_begin", resource_creation_begin)

    @property
    @pulumi.getter(name="resourceCreationBegin")
    def resource_creation_begin(self) -> Optional['outputs.ResourceTypeExtensionOptionsResponseResourceCreationBegin']:
        return pulumi.get(self, "resource_creation_begin")


@pulumi.output_type
class ResourceTypeRegistrationPropertiesResponseFeaturesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requiredFeaturesPolicy":
            suggest = "required_features_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeRegistrationPropertiesResponseFeaturesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeRegistrationPropertiesResponseFeaturesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeRegistrationPropertiesResponseFeaturesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 required_features_policy: str):
        ResourceTypeRegistrationPropertiesResponseFeaturesRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            required_features_policy=required_features_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             required_features_policy: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'requiredFeaturesPolicy' in kwargs:
            required_features_policy = kwargs['requiredFeaturesPolicy']

        _setter("required_features_policy", required_features_policy)

    @property
    @pulumi.getter(name="requiredFeaturesPolicy")
    def required_features_policy(self) -> str:
        return pulumi.get(self, "required_features_policy")


@pulumi.output_type
class ResourceTypeRegistrationPropertiesResponseIdentityManagement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeRegistrationPropertiesResponseIdentityManagement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeRegistrationPropertiesResponseIdentityManagement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeRegistrationPropertiesResponseIdentityManagement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 type: Optional[str] = None):
        ResourceTypeRegistrationPropertiesResponseIdentityManagement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_id=application_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'applicationId' in kwargs:
            application_id = kwargs['applicationId']

        if application_id is not None:
            _setter("application_id", application_id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ResourceTypeRegistrationPropertiesResponseManagement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "incidentContactEmail":
            suggest = "incident_contact_email"
        elif key == "incidentRoutingService":
            suggest = "incident_routing_service"
        elif key == "incidentRoutingTeam":
            suggest = "incident_routing_team"
        elif key == "manifestOwners":
            suggest = "manifest_owners"
        elif key == "resourceAccessPolicy":
            suggest = "resource_access_policy"
        elif key == "resourceAccessRoles":
            suggest = "resource_access_roles"
        elif key == "schemaOwners":
            suggest = "schema_owners"
        elif key == "serviceTreeInfos":
            suggest = "service_tree_infos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeRegistrationPropertiesResponseManagement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeRegistrationPropertiesResponseManagement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeRegistrationPropertiesResponseManagement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 incident_contact_email: Optional[str] = None,
                 incident_routing_service: Optional[str] = None,
                 incident_routing_team: Optional[str] = None,
                 manifest_owners: Optional[Sequence[str]] = None,
                 resource_access_policy: Optional[str] = None,
                 resource_access_roles: Optional[Sequence[Any]] = None,
                 schema_owners: Optional[Sequence[str]] = None,
                 service_tree_infos: Optional[Sequence['outputs.ServiceTreeInfoResponse']] = None):
        ResourceTypeRegistrationPropertiesResponseManagement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            incident_contact_email=incident_contact_email,
            incident_routing_service=incident_routing_service,
            incident_routing_team=incident_routing_team,
            manifest_owners=manifest_owners,
            resource_access_policy=resource_access_policy,
            resource_access_roles=resource_access_roles,
            schema_owners=schema_owners,
            service_tree_infos=service_tree_infos,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             incident_contact_email: Optional[str] = None,
             incident_routing_service: Optional[str] = None,
             incident_routing_team: Optional[str] = None,
             manifest_owners: Optional[Sequence[str]] = None,
             resource_access_policy: Optional[str] = None,
             resource_access_roles: Optional[Sequence[Any]] = None,
             schema_owners: Optional[Sequence[str]] = None,
             service_tree_infos: Optional[Sequence['outputs.ServiceTreeInfoResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'incidentContactEmail' in kwargs:
            incident_contact_email = kwargs['incidentContactEmail']
        if 'incidentRoutingService' in kwargs:
            incident_routing_service = kwargs['incidentRoutingService']
        if 'incidentRoutingTeam' in kwargs:
            incident_routing_team = kwargs['incidentRoutingTeam']
        if 'manifestOwners' in kwargs:
            manifest_owners = kwargs['manifestOwners']
        if 'resourceAccessPolicy' in kwargs:
            resource_access_policy = kwargs['resourceAccessPolicy']
        if 'resourceAccessRoles' in kwargs:
            resource_access_roles = kwargs['resourceAccessRoles']
        if 'schemaOwners' in kwargs:
            schema_owners = kwargs['schemaOwners']
        if 'serviceTreeInfos' in kwargs:
            service_tree_infos = kwargs['serviceTreeInfos']

        if incident_contact_email is not None:
            _setter("incident_contact_email", incident_contact_email)
        if incident_routing_service is not None:
            _setter("incident_routing_service", incident_routing_service)
        if incident_routing_team is not None:
            _setter("incident_routing_team", incident_routing_team)
        if manifest_owners is not None:
            _setter("manifest_owners", manifest_owners)
        if resource_access_policy is not None:
            _setter("resource_access_policy", resource_access_policy)
        if resource_access_roles is not None:
            _setter("resource_access_roles", resource_access_roles)
        if schema_owners is not None:
            _setter("schema_owners", schema_owners)
        if service_tree_infos is not None:
            _setter("service_tree_infos", service_tree_infos)

    @property
    @pulumi.getter(name="incidentContactEmail")
    def incident_contact_email(self) -> Optional[str]:
        return pulumi.get(self, "incident_contact_email")

    @property
    @pulumi.getter(name="incidentRoutingService")
    def incident_routing_service(self) -> Optional[str]:
        return pulumi.get(self, "incident_routing_service")

    @property
    @pulumi.getter(name="incidentRoutingTeam")
    def incident_routing_team(self) -> Optional[str]:
        return pulumi.get(self, "incident_routing_team")

    @property
    @pulumi.getter(name="manifestOwners")
    def manifest_owners(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "manifest_owners")

    @property
    @pulumi.getter(name="resourceAccessPolicy")
    def resource_access_policy(self) -> Optional[str]:
        return pulumi.get(self, "resource_access_policy")

    @property
    @pulumi.getter(name="resourceAccessRoles")
    def resource_access_roles(self) -> Optional[Sequence[Any]]:
        return pulumi.get(self, "resource_access_roles")

    @property
    @pulumi.getter(name="schemaOwners")
    def schema_owners(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "schema_owners")

    @property
    @pulumi.getter(name="serviceTreeInfos")
    def service_tree_infos(self) -> Optional[Sequence['outputs.ServiceTreeInfoResponse']]:
        return pulumi.get(self, "service_tree_infos")


@pulumi.output_type
class ResourceTypeRegistrationPropertiesResponseRequestHeaderOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optInHeaders":
            suggest = "opt_in_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeRegistrationPropertiesResponseRequestHeaderOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeRegistrationPropertiesResponseRequestHeaderOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeRegistrationPropertiesResponseRequestHeaderOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 opt_in_headers: Optional[str] = None):
        ResourceTypeRegistrationPropertiesResponseRequestHeaderOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            opt_in_headers=opt_in_headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opt_in_headers: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'optInHeaders' in kwargs:
            opt_in_headers = kwargs['optInHeaders']

        if opt_in_headers is not None:
            _setter("opt_in_headers", opt_in_headers)

    @property
    @pulumi.getter(name="optInHeaders")
    def opt_in_headers(self) -> Optional[str]:
        return pulumi.get(self, "opt_in_headers")


@pulumi.output_type
class ResourceTypeRegistrationPropertiesResponseResourceGraphConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeRegistrationPropertiesResponseResourceGraphConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeRegistrationPropertiesResponseResourceGraphConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeRegistrationPropertiesResponseResourceGraphConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 enabled: Optional[bool] = None):
        ResourceTypeRegistrationPropertiesResponseResourceGraphConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_version=api_version,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_version: Optional[str] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'apiVersion' in kwargs:
            api_version = kwargs['apiVersion']

        if api_version is not None:
            _setter("api_version", api_version)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ResourceTypeRegistrationPropertiesResponseResourceMovePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossResourceGroupMoveEnabled":
            suggest = "cross_resource_group_move_enabled"
        elif key == "crossSubscriptionMoveEnabled":
            suggest = "cross_subscription_move_enabled"
        elif key == "validationRequired":
            suggest = "validation_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeRegistrationPropertiesResponseResourceMovePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeRegistrationPropertiesResponseResourceMovePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeRegistrationPropertiesResponseResourceMovePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cross_resource_group_move_enabled: Optional[bool] = None,
                 cross_subscription_move_enabled: Optional[bool] = None,
                 validation_required: Optional[bool] = None):
        ResourceTypeRegistrationPropertiesResponseResourceMovePolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cross_resource_group_move_enabled=cross_resource_group_move_enabled,
            cross_subscription_move_enabled=cross_subscription_move_enabled,
            validation_required=validation_required,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cross_resource_group_move_enabled: Optional[bool] = None,
             cross_subscription_move_enabled: Optional[bool] = None,
             validation_required: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'crossResourceGroupMoveEnabled' in kwargs:
            cross_resource_group_move_enabled = kwargs['crossResourceGroupMoveEnabled']
        if 'crossSubscriptionMoveEnabled' in kwargs:
            cross_subscription_move_enabled = kwargs['crossSubscriptionMoveEnabled']
        if 'validationRequired' in kwargs:
            validation_required = kwargs['validationRequired']

        if cross_resource_group_move_enabled is not None:
            _setter("cross_resource_group_move_enabled", cross_resource_group_move_enabled)
        if cross_subscription_move_enabled is not None:
            _setter("cross_subscription_move_enabled", cross_subscription_move_enabled)
        if validation_required is not None:
            _setter("validation_required", validation_required)

    @property
    @pulumi.getter(name="crossResourceGroupMoveEnabled")
    def cross_resource_group_move_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "cross_resource_group_move_enabled")

    @property
    @pulumi.getter(name="crossSubscriptionMoveEnabled")
    def cross_subscription_move_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "cross_subscription_move_enabled")

    @property
    @pulumi.getter(name="validationRequired")
    def validation_required(self) -> Optional[bool]:
        return pulumi.get(self, "validation_required")


@pulumi.output_type
class ResourceTypeRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "softDeleteTTL":
            suggest = "soft_delete_ttl"
        elif key == "subscriptionStateOverrideActions":
            suggest = "subscription_state_override_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 soft_delete_ttl: Optional[str] = None,
                 subscription_state_override_actions: Optional[Sequence['outputs.SubscriptionStateOverrideActionResponse']] = None):
        ResourceTypeRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            soft_delete_ttl=soft_delete_ttl,
            subscription_state_override_actions=subscription_state_override_actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             soft_delete_ttl: Optional[str] = None,
             subscription_state_override_actions: Optional[Sequence['outputs.SubscriptionStateOverrideActionResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'softDeleteTTL' in kwargs:
            soft_delete_ttl = kwargs['softDeleteTTL']
        if 'subscriptionStateOverrideActions' in kwargs:
            subscription_state_override_actions = kwargs['subscriptionStateOverrideActions']

        if soft_delete_ttl is not None:
            _setter("soft_delete_ttl", soft_delete_ttl)
        if subscription_state_override_actions is not None:
            _setter("subscription_state_override_actions", subscription_state_override_actions)

    @property
    @pulumi.getter(name="softDeleteTTL")
    def soft_delete_ttl(self) -> Optional[str]:
        return pulumi.get(self, "soft_delete_ttl")

    @property
    @pulumi.getter(name="subscriptionStateOverrideActions")
    def subscription_state_override_actions(self) -> Optional[Sequence['outputs.SubscriptionStateOverrideActionResponse']]:
        return pulumi.get(self, "subscription_state_override_actions")


@pulumi.output_type
class ResourceTypeRegistrationPropertiesResponseTemplateDeploymentOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preflightOptions":
            suggest = "preflight_options"
        elif key == "preflightSupported":
            suggest = "preflight_supported"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeRegistrationPropertiesResponseTemplateDeploymentOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeRegistrationPropertiesResponseTemplateDeploymentOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeRegistrationPropertiesResponseTemplateDeploymentOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preflight_options: Optional[Sequence[str]] = None,
                 preflight_supported: Optional[bool] = None):
        ResourceTypeRegistrationPropertiesResponseTemplateDeploymentOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            preflight_options=preflight_options,
            preflight_supported=preflight_supported,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             preflight_options: Optional[Sequence[str]] = None,
             preflight_supported: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'preflightOptions' in kwargs:
            preflight_options = kwargs['preflightOptions']
        if 'preflightSupported' in kwargs:
            preflight_supported = kwargs['preflightSupported']

        if preflight_options is not None:
            _setter("preflight_options", preflight_options)
        if preflight_supported is not None:
            _setter("preflight_supported", preflight_supported)

    @property
    @pulumi.getter(name="preflightOptions")
    def preflight_options(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "preflight_options")

    @property
    @pulumi.getter(name="preflightSupported")
    def preflight_supported(self) -> Optional[bool]:
        return pulumi.get(self, "preflight_supported")


@pulumi.output_type
class ResourceTypeRegistrationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemData":
            suggest = "system_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeRegistrationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeRegistrationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeRegistrationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 name: str,
                 system_data: 'outputs.SystemDataResponse',
                 type: str,
                 properties: Optional['outputs.ResourceTypeRegistrationResponseProperties'] = None):
        """
        :param str id: Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        :param str name: The name of the resource
        :param 'SystemDataResponse' system_data: Metadata pertaining to creation and last modification of the resource.
        :param str type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        ResourceTypeRegistrationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            system_data=system_data,
            type=type,
            properties=properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             name: str,
             system_data: 'outputs.SystemDataResponse',
             type: str,
             properties: Optional['outputs.ResourceTypeRegistrationResponseProperties'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'systemData' in kwargs:
            system_data = kwargs['systemData']

        _setter("id", id)
        _setter("name", name)
        _setter("system_data", system_data)
        _setter("type", type)
        if properties is not None:
            _setter("properties", properties)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="systemData")
    def system_data(self) -> 'outputs.SystemDataResponse':
        """
        Metadata pertaining to creation and last modification of the resource.
        """
        return pulumi.get(self, "system_data")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def properties(self) -> Optional['outputs.ResourceTypeRegistrationResponseProperties']:
        return pulumi.get(self, "properties")


@pulumi.output_type
class ResourceTypeRegistrationResponseProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedUnauthorizedActions":
            suggest = "allowed_unauthorized_actions"
        elif key == "authorizationActionMappings":
            suggest = "authorization_action_mappings"
        elif key == "checkNameAvailabilitySpecifications":
            suggest = "check_name_availability_specifications"
        elif key == "defaultApiVersion":
            suggest = "default_api_version"
        elif key == "disallowedActionVerbs":
            suggest = "disallowed_action_verbs"
        elif key == "enableAsyncOperation":
            suggest = "enable_async_operation"
        elif key == "enableThirdPartyS2S":
            suggest = "enable_third_party_s2_s"
        elif key == "extendedLocations":
            suggest = "extended_locations"
        elif key == "extensionOptions":
            suggest = "extension_options"
        elif key == "featuresRule":
            suggest = "features_rule"
        elif key == "identityManagement":
            suggest = "identity_management"
        elif key == "isPureProxy":
            suggest = "is_pure_proxy"
        elif key == "linkedAccessChecks":
            suggest = "linked_access_checks"
        elif key == "loggingRules":
            suggest = "logging_rules"
        elif key == "marketplaceType":
            suggest = "marketplace_type"
        elif key == "openApiConfiguration":
            suggest = "open_api_configuration"
        elif key == "provisioningState":
            suggest = "provisioning_state"
        elif key == "requestHeaderOptions":
            suggest = "request_header_options"
        elif key == "requiredFeatures":
            suggest = "required_features"
        elif key == "resourceConcurrencyControlOptions":
            suggest = "resource_concurrency_control_options"
        elif key == "resourceDeletionPolicy":
            suggest = "resource_deletion_policy"
        elif key == "resourceGraphConfiguration":
            suggest = "resource_graph_configuration"
        elif key == "resourceMovePolicy":
            suggest = "resource_move_policy"
        elif key == "routingType":
            suggest = "routing_type"
        elif key == "serviceTreeInfos":
            suggest = "service_tree_infos"
        elif key == "subscriptionLifecycleNotificationSpecifications":
            suggest = "subscription_lifecycle_notification_specifications"
        elif key == "subscriptionStateRules":
            suggest = "subscription_state_rules"
        elif key == "swaggerSpecifications":
            suggest = "swagger_specifications"
        elif key == "templateDeploymentOptions":
            suggest = "template_deployment_options"
        elif key == "throttlingRules":
            suggest = "throttling_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceTypeRegistrationResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceTypeRegistrationResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceTypeRegistrationResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_unauthorized_actions: Optional[Sequence[str]] = None,
                 authorization_action_mappings: Optional[Sequence['outputs.AuthorizationActionMappingResponse']] = None,
                 check_name_availability_specifications: Optional['outputs.ResourceTypeRegistrationPropertiesResponseCheckNameAvailabilitySpecifications'] = None,
                 default_api_version: Optional[str] = None,
                 disallowed_action_verbs: Optional[Sequence[str]] = None,
                 enable_async_operation: Optional[bool] = None,
                 enable_third_party_s2_s: Optional[bool] = None,
                 endpoints: Optional[Sequence['outputs.ResourceTypeEndpointResponse']] = None,
                 extended_locations: Optional[Sequence['outputs.ExtendedLocationOptionsResponse']] = None,
                 extension_options: Optional['outputs.ResourceTypeRegistrationPropertiesResponseExtensionOptions'] = None,
                 features_rule: Optional['outputs.ResourceTypeRegistrationPropertiesResponseFeaturesRule'] = None,
                 identity_management: Optional['outputs.ResourceTypeRegistrationPropertiesResponseIdentityManagement'] = None,
                 is_pure_proxy: Optional[bool] = None,
                 linked_access_checks: Optional[Sequence['outputs.LinkedAccessCheckResponse']] = None,
                 logging_rules: Optional[Sequence['outputs.LoggingRuleResponse']] = None,
                 management: Optional['outputs.ResourceTypeRegistrationPropertiesResponseManagement'] = None,
                 marketplace_type: Optional[str] = None,
                 open_api_configuration: Optional['outputs.OpenApiConfigurationResponse'] = None,
                 provisioning_state: Optional[str] = None,
                 regionality: Optional[str] = None,
                 request_header_options: Optional['outputs.ResourceTypeRegistrationPropertiesResponseRequestHeaderOptions'] = None,
                 required_features: Optional[Sequence[str]] = None,
                 resource_concurrency_control_options: Optional[Mapping[str, 'outputs.ResourceConcurrencyControlOptionResponse']] = None,
                 resource_deletion_policy: Optional[str] = None,
                 resource_graph_configuration: Optional['outputs.ResourceTypeRegistrationPropertiesResponseResourceGraphConfiguration'] = None,
                 resource_move_policy: Optional['outputs.ResourceTypeRegistrationPropertiesResponseResourceMovePolicy'] = None,
                 routing_type: Optional[str] = None,
                 service_tree_infos: Optional[Sequence['outputs.ServiceTreeInfoResponse']] = None,
                 subscription_lifecycle_notification_specifications: Optional['outputs.ResourceTypeRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications'] = None,
                 subscription_state_rules: Optional[Sequence['outputs.SubscriptionStateRuleResponse']] = None,
                 swagger_specifications: Optional[Sequence['outputs.SwaggerSpecificationResponse']] = None,
                 template_deployment_options: Optional['outputs.ResourceTypeRegistrationPropertiesResponseTemplateDeploymentOptions'] = None,
                 throttling_rules: Optional[Sequence['outputs.ThrottlingRuleResponse']] = None):
        """
        :param str provisioning_state: The provisioned state of the resource.
        """
        ResourceTypeRegistrationResponseProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_unauthorized_actions=allowed_unauthorized_actions,
            authorization_action_mappings=authorization_action_mappings,
            check_name_availability_specifications=check_name_availability_specifications,
            default_api_version=default_api_version,
            disallowed_action_verbs=disallowed_action_verbs,
            enable_async_operation=enable_async_operation,
            enable_third_party_s2_s=enable_third_party_s2_s,
            endpoints=endpoints,
            extended_locations=extended_locations,
            extension_options=extension_options,
            features_rule=features_rule,
            identity_management=identity_management,
            is_pure_proxy=is_pure_proxy,
            linked_access_checks=linked_access_checks,
            logging_rules=logging_rules,
            management=management,
            marketplace_type=marketplace_type,
            open_api_configuration=open_api_configuration,
            provisioning_state=provisioning_state,
            regionality=regionality,
            request_header_options=request_header_options,
            required_features=required_features,
            resource_concurrency_control_options=resource_concurrency_control_options,
            resource_deletion_policy=resource_deletion_policy,
            resource_graph_configuration=resource_graph_configuration,
            resource_move_policy=resource_move_policy,
            routing_type=routing_type,
            service_tree_infos=service_tree_infos,
            subscription_lifecycle_notification_specifications=subscription_lifecycle_notification_specifications,
            subscription_state_rules=subscription_state_rules,
            swagger_specifications=swagger_specifications,
            template_deployment_options=template_deployment_options,
            throttling_rules=throttling_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_unauthorized_actions: Optional[Sequence[str]] = None,
             authorization_action_mappings: Optional[Sequence['outputs.AuthorizationActionMappingResponse']] = None,
             check_name_availability_specifications: Optional['outputs.ResourceTypeRegistrationPropertiesResponseCheckNameAvailabilitySpecifications'] = None,
             default_api_version: Optional[str] = None,
             disallowed_action_verbs: Optional[Sequence[str]] = None,
             enable_async_operation: Optional[bool] = None,
             enable_third_party_s2_s: Optional[bool] = None,
             endpoints: Optional[Sequence['outputs.ResourceTypeEndpointResponse']] = None,
             extended_locations: Optional[Sequence['outputs.ExtendedLocationOptionsResponse']] = None,
             extension_options: Optional['outputs.ResourceTypeRegistrationPropertiesResponseExtensionOptions'] = None,
             features_rule: Optional['outputs.ResourceTypeRegistrationPropertiesResponseFeaturesRule'] = None,
             identity_management: Optional['outputs.ResourceTypeRegistrationPropertiesResponseIdentityManagement'] = None,
             is_pure_proxy: Optional[bool] = None,
             linked_access_checks: Optional[Sequence['outputs.LinkedAccessCheckResponse']] = None,
             logging_rules: Optional[Sequence['outputs.LoggingRuleResponse']] = None,
             management: Optional['outputs.ResourceTypeRegistrationPropertiesResponseManagement'] = None,
             marketplace_type: Optional[str] = None,
             open_api_configuration: Optional['outputs.OpenApiConfigurationResponse'] = None,
             provisioning_state: Optional[str] = None,
             regionality: Optional[str] = None,
             request_header_options: Optional['outputs.ResourceTypeRegistrationPropertiesResponseRequestHeaderOptions'] = None,
             required_features: Optional[Sequence[str]] = None,
             resource_concurrency_control_options: Optional[Mapping[str, 'outputs.ResourceConcurrencyControlOptionResponse']] = None,
             resource_deletion_policy: Optional[str] = None,
             resource_graph_configuration: Optional['outputs.ResourceTypeRegistrationPropertiesResponseResourceGraphConfiguration'] = None,
             resource_move_policy: Optional['outputs.ResourceTypeRegistrationPropertiesResponseResourceMovePolicy'] = None,
             routing_type: Optional[str] = None,
             service_tree_infos: Optional[Sequence['outputs.ServiceTreeInfoResponse']] = None,
             subscription_lifecycle_notification_specifications: Optional['outputs.ResourceTypeRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications'] = None,
             subscription_state_rules: Optional[Sequence['outputs.SubscriptionStateRuleResponse']] = None,
             swagger_specifications: Optional[Sequence['outputs.SwaggerSpecificationResponse']] = None,
             template_deployment_options: Optional['outputs.ResourceTypeRegistrationPropertiesResponseTemplateDeploymentOptions'] = None,
             throttling_rules: Optional[Sequence['outputs.ThrottlingRuleResponse']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedUnauthorizedActions' in kwargs:
            allowed_unauthorized_actions = kwargs['allowedUnauthorizedActions']
        if 'authorizationActionMappings' in kwargs:
            authorization_action_mappings = kwargs['authorizationActionMappings']
        if 'checkNameAvailabilitySpecifications' in kwargs:
            check_name_availability_specifications = kwargs['checkNameAvailabilitySpecifications']
        if 'defaultApiVersion' in kwargs:
            default_api_version = kwargs['defaultApiVersion']
        if 'disallowedActionVerbs' in kwargs:
            disallowed_action_verbs = kwargs['disallowedActionVerbs']
        if 'enableAsyncOperation' in kwargs:
            enable_async_operation = kwargs['enableAsyncOperation']
        if 'enableThirdPartyS2S' in kwargs:
            enable_third_party_s2_s = kwargs['enableThirdPartyS2S']
        if 'extendedLocations' in kwargs:
            extended_locations = kwargs['extendedLocations']
        if 'extensionOptions' in kwargs:
            extension_options = kwargs['extensionOptions']
        if 'featuresRule' in kwargs:
            features_rule = kwargs['featuresRule']
        if 'identityManagement' in kwargs:
            identity_management = kwargs['identityManagement']
        if 'isPureProxy' in kwargs:
            is_pure_proxy = kwargs['isPureProxy']
        if 'linkedAccessChecks' in kwargs:
            linked_access_checks = kwargs['linkedAccessChecks']
        if 'loggingRules' in kwargs:
            logging_rules = kwargs['loggingRules']
        if 'marketplaceType' in kwargs:
            marketplace_type = kwargs['marketplaceType']
        if 'openApiConfiguration' in kwargs:
            open_api_configuration = kwargs['openApiConfiguration']
        if 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']
        if 'requestHeaderOptions' in kwargs:
            request_header_options = kwargs['requestHeaderOptions']
        if 'requiredFeatures' in kwargs:
            required_features = kwargs['requiredFeatures']
        if 'resourceConcurrencyControlOptions' in kwargs:
            resource_concurrency_control_options = kwargs['resourceConcurrencyControlOptions']
        if 'resourceDeletionPolicy' in kwargs:
            resource_deletion_policy = kwargs['resourceDeletionPolicy']
        if 'resourceGraphConfiguration' in kwargs:
            resource_graph_configuration = kwargs['resourceGraphConfiguration']
        if 'resourceMovePolicy' in kwargs:
            resource_move_policy = kwargs['resourceMovePolicy']
        if 'routingType' in kwargs:
            routing_type = kwargs['routingType']
        if 'serviceTreeInfos' in kwargs:
            service_tree_infos = kwargs['serviceTreeInfos']
        if 'subscriptionLifecycleNotificationSpecifications' in kwargs:
            subscription_lifecycle_notification_specifications = kwargs['subscriptionLifecycleNotificationSpecifications']
        if 'subscriptionStateRules' in kwargs:
            subscription_state_rules = kwargs['subscriptionStateRules']
        if 'swaggerSpecifications' in kwargs:
            swagger_specifications = kwargs['swaggerSpecifications']
        if 'templateDeploymentOptions' in kwargs:
            template_deployment_options = kwargs['templateDeploymentOptions']
        if 'throttlingRules' in kwargs:
            throttling_rules = kwargs['throttlingRules']

        if allowed_unauthorized_actions is not None:
            _setter("allowed_unauthorized_actions", allowed_unauthorized_actions)
        if authorization_action_mappings is not None:
            _setter("authorization_action_mappings", authorization_action_mappings)
        if check_name_availability_specifications is not None:
            _setter("check_name_availability_specifications", check_name_availability_specifications)
        if default_api_version is not None:
            _setter("default_api_version", default_api_version)
        if disallowed_action_verbs is not None:
            _setter("disallowed_action_verbs", disallowed_action_verbs)
        if enable_async_operation is not None:
            _setter("enable_async_operation", enable_async_operation)
        if enable_third_party_s2_s is not None:
            _setter("enable_third_party_s2_s", enable_third_party_s2_s)
        if endpoints is not None:
            _setter("endpoints", endpoints)
        if extended_locations is not None:
            _setter("extended_locations", extended_locations)
        if extension_options is not None:
            _setter("extension_options", extension_options)
        if features_rule is not None:
            _setter("features_rule", features_rule)
        if identity_management is not None:
            _setter("identity_management", identity_management)
        if is_pure_proxy is not None:
            _setter("is_pure_proxy", is_pure_proxy)
        if linked_access_checks is not None:
            _setter("linked_access_checks", linked_access_checks)
        if logging_rules is not None:
            _setter("logging_rules", logging_rules)
        if management is not None:
            _setter("management", management)
        if marketplace_type is not None:
            _setter("marketplace_type", marketplace_type)
        if open_api_configuration is not None:
            _setter("open_api_configuration", open_api_configuration)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)
        if regionality is not None:
            _setter("regionality", regionality)
        if request_header_options is not None:
            _setter("request_header_options", request_header_options)
        if required_features is not None:
            _setter("required_features", required_features)
        if resource_concurrency_control_options is not None:
            _setter("resource_concurrency_control_options", resource_concurrency_control_options)
        if resource_deletion_policy is not None:
            _setter("resource_deletion_policy", resource_deletion_policy)
        if resource_graph_configuration is not None:
            _setter("resource_graph_configuration", resource_graph_configuration)
        if resource_move_policy is not None:
            _setter("resource_move_policy", resource_move_policy)
        if routing_type is not None:
            _setter("routing_type", routing_type)
        if service_tree_infos is not None:
            _setter("service_tree_infos", service_tree_infos)
        if subscription_lifecycle_notification_specifications is not None:
            _setter("subscription_lifecycle_notification_specifications", subscription_lifecycle_notification_specifications)
        if subscription_state_rules is not None:
            _setter("subscription_state_rules", subscription_state_rules)
        if swagger_specifications is not None:
            _setter("swagger_specifications", swagger_specifications)
        if template_deployment_options is not None:
            _setter("template_deployment_options", template_deployment_options)
        if throttling_rules is not None:
            _setter("throttling_rules", throttling_rules)

    @property
    @pulumi.getter(name="allowedUnauthorizedActions")
    def allowed_unauthorized_actions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_unauthorized_actions")

    @property
    @pulumi.getter(name="authorizationActionMappings")
    def authorization_action_mappings(self) -> Optional[Sequence['outputs.AuthorizationActionMappingResponse']]:
        return pulumi.get(self, "authorization_action_mappings")

    @property
    @pulumi.getter(name="checkNameAvailabilitySpecifications")
    def check_name_availability_specifications(self) -> Optional['outputs.ResourceTypeRegistrationPropertiesResponseCheckNameAvailabilitySpecifications']:
        return pulumi.get(self, "check_name_availability_specifications")

    @property
    @pulumi.getter(name="defaultApiVersion")
    def default_api_version(self) -> Optional[str]:
        return pulumi.get(self, "default_api_version")

    @property
    @pulumi.getter(name="disallowedActionVerbs")
    def disallowed_action_verbs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "disallowed_action_verbs")

    @property
    @pulumi.getter(name="enableAsyncOperation")
    def enable_async_operation(self) -> Optional[bool]:
        return pulumi.get(self, "enable_async_operation")

    @property
    @pulumi.getter(name="enableThirdPartyS2S")
    def enable_third_party_s2_s(self) -> Optional[bool]:
        return pulumi.get(self, "enable_third_party_s2_s")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.ResourceTypeEndpointResponse']]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="extendedLocations")
    def extended_locations(self) -> Optional[Sequence['outputs.ExtendedLocationOptionsResponse']]:
        return pulumi.get(self, "extended_locations")

    @property
    @pulumi.getter(name="extensionOptions")
    def extension_options(self) -> Optional['outputs.ResourceTypeRegistrationPropertiesResponseExtensionOptions']:
        return pulumi.get(self, "extension_options")

    @property
    @pulumi.getter(name="featuresRule")
    def features_rule(self) -> Optional['outputs.ResourceTypeRegistrationPropertiesResponseFeaturesRule']:
        return pulumi.get(self, "features_rule")

    @property
    @pulumi.getter(name="identityManagement")
    def identity_management(self) -> Optional['outputs.ResourceTypeRegistrationPropertiesResponseIdentityManagement']:
        return pulumi.get(self, "identity_management")

    @property
    @pulumi.getter(name="isPureProxy")
    def is_pure_proxy(self) -> Optional[bool]:
        return pulumi.get(self, "is_pure_proxy")

    @property
    @pulumi.getter(name="linkedAccessChecks")
    def linked_access_checks(self) -> Optional[Sequence['outputs.LinkedAccessCheckResponse']]:
        return pulumi.get(self, "linked_access_checks")

    @property
    @pulumi.getter(name="loggingRules")
    def logging_rules(self) -> Optional[Sequence['outputs.LoggingRuleResponse']]:
        return pulumi.get(self, "logging_rules")

    @property
    @pulumi.getter
    def management(self) -> Optional['outputs.ResourceTypeRegistrationPropertiesResponseManagement']:
        return pulumi.get(self, "management")

    @property
    @pulumi.getter(name="marketplaceType")
    def marketplace_type(self) -> Optional[str]:
        return pulumi.get(self, "marketplace_type")

    @property
    @pulumi.getter(name="openApiConfiguration")
    def open_api_configuration(self) -> Optional['outputs.OpenApiConfigurationResponse']:
        return pulumi.get(self, "open_api_configuration")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioned state of the resource.
        """
        return pulumi.get(self, "provisioning_state")

    @property
    @pulumi.getter
    def regionality(self) -> Optional[str]:
        return pulumi.get(self, "regionality")

    @property
    @pulumi.getter(name="requestHeaderOptions")
    def request_header_options(self) -> Optional['outputs.ResourceTypeRegistrationPropertiesResponseRequestHeaderOptions']:
        return pulumi.get(self, "request_header_options")

    @property
    @pulumi.getter(name="requiredFeatures")
    def required_features(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "required_features")

    @property
    @pulumi.getter(name="resourceConcurrencyControlOptions")
    def resource_concurrency_control_options(self) -> Optional[Mapping[str, 'outputs.ResourceConcurrencyControlOptionResponse']]:
        return pulumi.get(self, "resource_concurrency_control_options")

    @property
    @pulumi.getter(name="resourceDeletionPolicy")
    def resource_deletion_policy(self) -> Optional[str]:
        return pulumi.get(self, "resource_deletion_policy")

    @property
    @pulumi.getter(name="resourceGraphConfiguration")
    def resource_graph_configuration(self) -> Optional['outputs.ResourceTypeRegistrationPropertiesResponseResourceGraphConfiguration']:
        return pulumi.get(self, "resource_graph_configuration")

    @property
    @pulumi.getter(name="resourceMovePolicy")
    def resource_move_policy(self) -> Optional['outputs.ResourceTypeRegistrationPropertiesResponseResourceMovePolicy']:
        return pulumi.get(self, "resource_move_policy")

    @property
    @pulumi.getter(name="routingType")
    def routing_type(self) -> Optional[str]:
        return pulumi.get(self, "routing_type")

    @property
    @pulumi.getter(name="serviceTreeInfos")
    def service_tree_infos(self) -> Optional[Sequence['outputs.ServiceTreeInfoResponse']]:
        return pulumi.get(self, "service_tree_infos")

    @property
    @pulumi.getter(name="subscriptionLifecycleNotificationSpecifications")
    def subscription_lifecycle_notification_specifications(self) -> Optional['outputs.ResourceTypeRegistrationPropertiesResponseSubscriptionLifecycleNotificationSpecifications']:
        return pulumi.get(self, "subscription_lifecycle_notification_specifications")

    @property
    @pulumi.getter(name="subscriptionStateRules")
    def subscription_state_rules(self) -> Optional[Sequence['outputs.SubscriptionStateRuleResponse']]:
        return pulumi.get(self, "subscription_state_rules")

    @property
    @pulumi.getter(name="swaggerSpecifications")
    def swagger_specifications(self) -> Optional[Sequence['outputs.SwaggerSpecificationResponse']]:
        return pulumi.get(self, "swagger_specifications")

    @property
    @pulumi.getter(name="templateDeploymentOptions")
    def template_deployment_options(self) -> Optional['outputs.ResourceTypeRegistrationPropertiesResponseTemplateDeploymentOptions']:
        return pulumi.get(self, "template_deployment_options")

    @property
    @pulumi.getter(name="throttlingRules")
    def throttling_rules(self) -> Optional[Sequence['outputs.ThrottlingRuleResponse']]:
        return pulumi.get(self, "throttling_rules")


@pulumi.output_type
class ServiceTreeInfoResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentId":
            suggest = "component_id"
        elif key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceTreeInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceTreeInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceTreeInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_id: Optional[str] = None,
                 readiness: Optional[str] = None,
                 service_id: Optional[str] = None):
        ServiceTreeInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            component_id=component_id,
            readiness=readiness,
            service_id=service_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             component_id: Optional[str] = None,
             readiness: Optional[str] = None,
             service_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'componentId' in kwargs:
            component_id = kwargs['componentId']
        if 'serviceId' in kwargs:
            service_id = kwargs['serviceId']

        if component_id is not None:
            _setter("component_id", component_id)
        if readiness is not None:
            _setter("readiness", readiness)
        if service_id is not None:
            _setter("service_id", service_id)

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[str]:
        return pulumi.get(self, "component_id")

    @property
    @pulumi.getter
    def readiness(self) -> Optional[str]:
        return pulumi.get(self, "readiness")

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[str]:
        return pulumi.get(self, "service_id")


@pulumi.output_type
class SkuCapabilityResponse(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        SkuCapabilityResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SkuCostResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "meterId":
            suggest = "meter_id"
        elif key == "extendedUnit":
            suggest = "extended_unit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SkuCostResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SkuCostResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SkuCostResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 meter_id: str,
                 extended_unit: Optional[str] = None,
                 quantity: Optional[int] = None):
        SkuCostResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            meter_id=meter_id,
            extended_unit=extended_unit,
            quantity=quantity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             meter_id: str,
             extended_unit: Optional[str] = None,
             quantity: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'meterId' in kwargs:
            meter_id = kwargs['meterId']
        if 'extendedUnit' in kwargs:
            extended_unit = kwargs['extendedUnit']

        _setter("meter_id", meter_id)
        if extended_unit is not None:
            _setter("extended_unit", extended_unit)
        if quantity is not None:
            _setter("quantity", quantity)

    @property
    @pulumi.getter(name="meterId")
    def meter_id(self) -> str:
        return pulumi.get(self, "meter_id")

    @property
    @pulumi.getter(name="extendedUnit")
    def extended_unit(self) -> Optional[str]:
        return pulumi.get(self, "extended_unit")

    @property
    @pulumi.getter
    def quantity(self) -> Optional[int]:
        return pulumi.get(self, "quantity")


@pulumi.output_type
class SkuLocationInfoResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extendedLocations":
            suggest = "extended_locations"
        elif key == "zoneDetails":
            suggest = "zone_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SkuLocationInfoResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SkuLocationInfoResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SkuLocationInfoResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 extended_locations: Optional[Sequence[str]] = None,
                 type: Optional[str] = None,
                 zone_details: Optional[Sequence['outputs.SkuZoneDetailResponse']] = None,
                 zones: Optional[Sequence[str]] = None):
        SkuLocationInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            location=location,
            extended_locations=extended_locations,
            type=type,
            zone_details=zone_details,
            zones=zones,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             location: str,
             extended_locations: Optional[Sequence[str]] = None,
             type: Optional[str] = None,
             zone_details: Optional[Sequence['outputs.SkuZoneDetailResponse']] = None,
             zones: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'extendedLocations' in kwargs:
            extended_locations = kwargs['extendedLocations']
        if 'zoneDetails' in kwargs:
            zone_details = kwargs['zoneDetails']

        _setter("location", location)
        if extended_locations is not None:
            _setter("extended_locations", extended_locations)
        if type is not None:
            _setter("type", type)
        if zone_details is not None:
            _setter("zone_details", zone_details)
        if zones is not None:
            _setter("zones", zones)

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="extendedLocations")
    def extended_locations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "extended_locations")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="zoneDetails")
    def zone_details(self) -> Optional[Sequence['outputs.SkuZoneDetailResponse']]:
        return pulumi.get(self, "zone_details")

    @property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "zones")


@pulumi.output_type
class SkuResourceResponseProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skuSettings":
            suggest = "sku_settings"
        elif key == "provisioningState":
            suggest = "provisioning_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SkuResourceResponseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SkuResourceResponseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SkuResourceResponseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sku_settings: Sequence['outputs.SkuSettingResponse'],
                 provisioning_state: Optional[str] = None):
        """
        :param str provisioning_state: The provisioned state of the resource.
        """
        SkuResourceResponseProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sku_settings=sku_settings,
            provisioning_state=provisioning_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sku_settings: Sequence['outputs.SkuSettingResponse'],
             provisioning_state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'skuSettings' in kwargs:
            sku_settings = kwargs['skuSettings']
        if 'provisioningState' in kwargs:
            provisioning_state = kwargs['provisioningState']

        _setter("sku_settings", sku_settings)
        if provisioning_state is not None:
            _setter("provisioning_state", provisioning_state)

    @property
    @pulumi.getter(name="skuSettings")
    def sku_settings(self) -> Sequence['outputs.SkuSettingResponse']:
        return pulumi.get(self, "sku_settings")

    @property
    @pulumi.getter(name="provisioningState")
    def provisioning_state(self) -> Optional[str]:
        """
        The provisioned state of the resource.
        """
        return pulumi.get(self, "provisioning_state")


@pulumi.output_type
class SkuSettingResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "locationInfo":
            suggest = "location_info"
        elif key == "requiredFeatures":
            suggest = "required_features"
        elif key == "requiredQuotaIds":
            suggest = "required_quota_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SkuSettingResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SkuSettingResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SkuSettingResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 capabilities: Optional[Sequence['outputs.SkuCapabilityResponse']] = None,
                 capacity: Optional['outputs.SkuSettingResponseCapacity'] = None,
                 costs: Optional[Sequence['outputs.SkuCostResponse']] = None,
                 family: Optional[str] = None,
                 kind: Optional[str] = None,
                 location_info: Optional[Sequence['outputs.SkuLocationInfoResponse']] = None,
                 locations: Optional[Sequence[str]] = None,
                 required_features: Optional[Sequence[str]] = None,
                 required_quota_ids: Optional[Sequence[str]] = None,
                 size: Optional[str] = None,
                 tier: Optional[str] = None):
        SkuSettingResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            capabilities=capabilities,
            capacity=capacity,
            costs=costs,
            family=family,
            kind=kind,
            location_info=location_info,
            locations=locations,
            required_features=required_features,
            required_quota_ids=required_quota_ids,
            size=size,
            tier=tier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             capabilities: Optional[Sequence['outputs.SkuCapabilityResponse']] = None,
             capacity: Optional['outputs.SkuSettingResponseCapacity'] = None,
             costs: Optional[Sequence['outputs.SkuCostResponse']] = None,
             family: Optional[str] = None,
             kind: Optional[str] = None,
             location_info: Optional[Sequence['outputs.SkuLocationInfoResponse']] = None,
             locations: Optional[Sequence[str]] = None,
             required_features: Optional[Sequence[str]] = None,
             required_quota_ids: Optional[Sequence[str]] = None,
             size: Optional[str] = None,
             tier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'locationInfo' in kwargs:
            location_info = kwargs['locationInfo']
        if 'requiredFeatures' in kwargs:
            required_features = kwargs['requiredFeatures']
        if 'requiredQuotaIds' in kwargs:
            required_quota_ids = kwargs['requiredQuotaIds']

        _setter("name", name)
        if capabilities is not None:
            _setter("capabilities", capabilities)
        if capacity is not None:
            _setter("capacity", capacity)
        if costs is not None:
            _setter("costs", costs)
        if family is not None:
            _setter("family", family)
        if kind is not None:
            _setter("kind", kind)
        if location_info is not None:
            _setter("location_info", location_info)
        if locations is not None:
            _setter("locations", locations)
        if required_features is not None:
            _setter("required_features", required_features)
        if required_quota_ids is not None:
            _setter("required_quota_ids", required_quota_ids)
        if size is not None:
            _setter("size", size)
        if tier is not None:
            _setter("tier", tier)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence['outputs.SkuCapabilityResponse']]:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def capacity(self) -> Optional['outputs.SkuSettingResponseCapacity']:
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def costs(self) -> Optional[Sequence['outputs.SkuCostResponse']]:
        return pulumi.get(self, "costs")

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="locationInfo")
    def location_info(self) -> Optional[Sequence['outputs.SkuLocationInfoResponse']]:
        return pulumi.get(self, "location_info")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="requiredFeatures")
    def required_features(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "required_features")

    @property
    @pulumi.getter(name="requiredQuotaIds")
    def required_quota_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "required_quota_ids")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        return pulumi.get(self, "tier")


@pulumi.output_type
class SkuSettingResponseCapacity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleType":
            suggest = "scale_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SkuSettingResponseCapacity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SkuSettingResponseCapacity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SkuSettingResponseCapacity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 minimum: int,
                 default: Optional[int] = None,
                 maximum: Optional[int] = None,
                 scale_type: Optional[str] = None):
        SkuSettingResponseCapacity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            minimum=minimum,
            default=default,
            maximum=maximum,
            scale_type=scale_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             minimum: int,
             default: Optional[int] = None,
             maximum: Optional[int] = None,
             scale_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'scaleType' in kwargs:
            scale_type = kwargs['scaleType']

        _setter("minimum", minimum)
        if default is not None:
            _setter("default", default)
        if maximum is not None:
            _setter("maximum", maximum)
        if scale_type is not None:
            _setter("scale_type", scale_type)

    @property
    @pulumi.getter
    def minimum(self) -> int:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def default(self) -> Optional[int]:
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def maximum(self) -> Optional[int]:
        return pulumi.get(self, "maximum")

    @property
    @pulumi.getter(name="scaleType")
    def scale_type(self) -> Optional[str]:
        return pulumi.get(self, "scale_type")


@pulumi.output_type
class SkuZoneDetailResponse(dict):
    def __init__(__self__, *,
                 capabilities: Optional[Sequence['outputs.SkuCapabilityResponse']] = None,
                 name: Optional[Sequence[str]] = None):
        SkuZoneDetailResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capabilities=capabilities,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capabilities: Optional[Sequence['outputs.SkuCapabilityResponse']] = None,
             name: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if capabilities is not None:
            _setter("capabilities", capabilities)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence['outputs.SkuCapabilityResponse']]:
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def name(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "name")


@pulumi.output_type
class SubscriptionStateOverrideActionResponse(dict):
    def __init__(__self__, *,
                 action: str,
                 state: str):
        SubscriptionStateOverrideActionResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             state: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("action", action)
        _setter("state", state)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")


@pulumi.output_type
class SubscriptionStateRuleResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedActions":
            suggest = "allowed_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubscriptionStateRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubscriptionStateRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubscriptionStateRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_actions: Optional[Sequence[str]] = None,
                 state: Optional[str] = None):
        SubscriptionStateRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_actions=allowed_actions,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_actions: Optional[Sequence[str]] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedActions' in kwargs:
            allowed_actions = kwargs['allowedActions']

        if allowed_actions is not None:
            _setter("allowed_actions", allowed_actions)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="allowedActions")
    def allowed_actions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_actions")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class SwaggerSpecificationResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersions":
            suggest = "api_versions"
        elif key == "swaggerSpecFolderUri":
            suggest = "swagger_spec_folder_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwaggerSpecificationResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwaggerSpecificationResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwaggerSpecificationResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_versions: Optional[Sequence[str]] = None,
                 swagger_spec_folder_uri: Optional[str] = None):
        SwaggerSpecificationResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_versions=api_versions,
            swagger_spec_folder_uri=swagger_spec_folder_uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_versions: Optional[Sequence[str]] = None,
             swagger_spec_folder_uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'apiVersions' in kwargs:
            api_versions = kwargs['apiVersions']
        if 'swaggerSpecFolderUri' in kwargs:
            swagger_spec_folder_uri = kwargs['swaggerSpecFolderUri']

        if api_versions is not None:
            _setter("api_versions", api_versions)
        if swagger_spec_folder_uri is not None:
            _setter("swagger_spec_folder_uri", swagger_spec_folder_uri)

    @property
    @pulumi.getter(name="apiVersions")
    def api_versions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "api_versions")

    @property
    @pulumi.getter(name="swaggerSpecFolderUri")
    def swagger_spec_folder_uri(self) -> Optional[str]:
        return pulumi.get(self, "swagger_spec_folder_uri")


@pulumi.output_type
class SystemDataResponse(dict):
    """
    Metadata pertaining to creation and last modification of the resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "createdByType":
            suggest = "created_by_type"
        elif key == "lastModifiedAt":
            suggest = "last_modified_at"
        elif key == "lastModifiedBy":
            suggest = "last_modified_by"
        elif key == "lastModifiedByType":
            suggest = "last_modified_by_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SystemDataResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SystemDataResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 created_by: Optional[str] = None,
                 created_by_type: Optional[str] = None,
                 last_modified_at: Optional[str] = None,
                 last_modified_by: Optional[str] = None,
                 last_modified_by_type: Optional[str] = None):
        """
        Metadata pertaining to creation and last modification of the resource.
        :param str created_at: The timestamp of resource creation (UTC).
        :param str created_by: The identity that created the resource.
        :param str created_by_type: The type of identity that created the resource.
        :param str last_modified_at: The timestamp of resource last modification (UTC)
        :param str last_modified_by: The identity that last modified the resource.
        :param str last_modified_by_type: The type of identity that last modified the resource.
        """
        SystemDataResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            created_by=created_by,
            created_by_type=created_by_type,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            last_modified_by_type=last_modified_by_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             created_by: Optional[str] = None,
             created_by_type: Optional[str] = None,
             last_modified_at: Optional[str] = None,
             last_modified_by: Optional[str] = None,
             last_modified_by_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'createdBy' in kwargs:
            created_by = kwargs['createdBy']
        if 'createdByType' in kwargs:
            created_by_type = kwargs['createdByType']
        if 'lastModifiedAt' in kwargs:
            last_modified_at = kwargs['lastModifiedAt']
        if 'lastModifiedBy' in kwargs:
            last_modified_by = kwargs['lastModifiedBy']
        if 'lastModifiedByType' in kwargs:
            last_modified_by_type = kwargs['lastModifiedByType']

        if created_at is not None:
            _setter("created_at", created_at)
        if created_by is not None:
            _setter("created_by", created_by)
        if created_by_type is not None:
            _setter("created_by_type", created_by_type)
        if last_modified_at is not None:
            _setter("last_modified_at", last_modified_at)
        if last_modified_by is not None:
            _setter("last_modified_by", last_modified_by)
        if last_modified_by_type is not None:
            _setter("last_modified_by_type", last_modified_by_type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The timestamp of resource creation (UTC).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[str]:
        """
        The identity that created the resource.
        """
        return pulumi.get(self, "created_by")

    @property
    @pulumi.getter(name="createdByType")
    def created_by_type(self) -> Optional[str]:
        """
        The type of identity that created the resource.
        """
        return pulumi.get(self, "created_by_type")

    @property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[str]:
        """
        The timestamp of resource last modification (UTC)
        """
        return pulumi.get(self, "last_modified_at")

    @property
    @pulumi.getter(name="lastModifiedBy")
    def last_modified_by(self) -> Optional[str]:
        """
        The identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by")

    @property
    @pulumi.getter(name="lastModifiedByType")
    def last_modified_by_type(self) -> Optional[str]:
        """
        The type of identity that last modified the resource.
        """
        return pulumi.get(self, "last_modified_by_type")


@pulumi.output_type
class ThrottlingMetricResponse(dict):
    def __init__(__self__, *,
                 limit: float,
                 type: str,
                 interval: Optional[str] = None):
        ThrottlingMetricResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            limit=limit,
            type=type,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             limit: float,
             type: str,
             interval: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("limit", limit)
        _setter("type", type)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def limit(self) -> float:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class ThrottlingRuleResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requiredFeatures":
            suggest = "required_features"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThrottlingRuleResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThrottlingRuleResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThrottlingRuleResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 metrics: Sequence['outputs.ThrottlingMetricResponse'],
                 required_features: Optional[Sequence[str]] = None):
        ThrottlingRuleResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            metrics=metrics,
            required_features=required_features,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             metrics: Sequence['outputs.ThrottlingMetricResponse'],
             required_features: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'requiredFeatures' in kwargs:
            required_features = kwargs['requiredFeatures']

        _setter("action", action)
        _setter("metrics", metrics)
        if required_features is not None:
            _setter("required_features", required_features)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def metrics(self) -> Sequence['outputs.ThrottlingMetricResponse']:
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="requiredFeatures")
    def required_features(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "required_features")


@pulumi.output_type
class TypedErrorInfoResponse(dict):
    def __init__(__self__, *,
                 info: Any,
                 type: str):
        TypedErrorInfoResponse._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            info=info,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             info: Any,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("info", info)
        _setter("type", type)

    @property
    @pulumi.getter
    def info(self) -> Any:
        return pulumi.get(self, "info")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


